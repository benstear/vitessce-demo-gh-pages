function U(t) {
  let i = t.length;
  for (; --i >= 0; )
    t[i] = 0;
}
const tt = 3, it = 258, $e = 29, nt = 256, at = nt + 1 + $e, ze = 30, ft = 512, ot = new Array((at + 2) * 2);
U(ot);
const lt = new Array(ze * 2);
U(lt);
const st = new Array(ft);
U(st);
const rt = new Array(it - tt + 1);
U(rt);
const ct = new Array($e);
U(ct);
const dt = new Array(ze);
U(dt);
const ht = (t, i, e, o) => {
  let r = t & 65535 | 0, n = t >>> 16 & 65535 | 0, d = 0;
  for (; e !== 0; ) {
    d = e > 2e3 ? 2e3 : e, e -= d;
    do
      r = r + i[o++] | 0, n = n + r | 0;
    while (--d);
    r %= 65521, n %= 65521;
  }
  return r | n << 16 | 0;
};
var ne = ht;
const ut = () => {
  let t, i = [];
  for (var e = 0; e < 256; e++) {
    t = e;
    for (var o = 0; o < 8; o++)
      t = t & 1 ? 3988292384 ^ t >>> 1 : t >>> 1;
    i[e] = t;
  }
  return i;
}, wt = new Uint32Array(ut()), xt = (t, i, e, o) => {
  const r = wt, n = o + e;
  t ^= -1;
  for (let d = o; d < n; d++)
    t = t >>> 8 ^ r[(t ^ i[d]) & 255];
  return t ^ -1;
};
var C = xt, ae = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, He = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const _t = (t, i) => Object.prototype.hasOwnProperty.call(t, i);
var bt = function(t) {
  const i = Array.prototype.slice.call(arguments, 1);
  for (; i.length; ) {
    const e = i.shift();
    if (e) {
      if (typeof e != "object")
        throw new TypeError(e + "must be non-object");
      for (const o in e)
        _t(e, o) && (t[o] = e[o]);
    }
  }
  return t;
}, kt = (t) => {
  let i = 0;
  for (let o = 0, r = t.length; o < r; o++)
    i += t[o].length;
  const e = new Uint8Array(i);
  for (let o = 0, r = 0, n = t.length; o < n; o++) {
    let d = t[o];
    e.set(d, r), r += d.length;
  }
  return e;
}, Be = {
  assign: bt,
  flattenChunks: kt
};
let Fe = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  Fe = !1;
}
const $ = new Uint8Array(256);
for (let t = 0; t < 256; t++)
  $[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
$[254] = $[254] = 1;
var gt = (t) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(t);
  let i, e, o, r, n, d = t.length, l = 0;
  for (r = 0; r < d; r++)
    e = t.charCodeAt(r), (e & 64512) === 55296 && r + 1 < d && (o = t.charCodeAt(r + 1), (o & 64512) === 56320 && (e = 65536 + (e - 55296 << 10) + (o - 56320), r++)), l += e < 128 ? 1 : e < 2048 ? 2 : e < 65536 ? 3 : 4;
  for (i = new Uint8Array(l), n = 0, r = 0; n < l; r++)
    e = t.charCodeAt(r), (e & 64512) === 55296 && r + 1 < d && (o = t.charCodeAt(r + 1), (o & 64512) === 56320 && (e = 65536 + (e - 55296 << 10) + (o - 56320), r++)), e < 128 ? i[n++] = e : e < 2048 ? (i[n++] = 192 | e >>> 6, i[n++] = 128 | e & 63) : e < 65536 ? (i[n++] = 224 | e >>> 12, i[n++] = 128 | e >>> 6 & 63, i[n++] = 128 | e & 63) : (i[n++] = 240 | e >>> 18, i[n++] = 128 | e >>> 12 & 63, i[n++] = 128 | e >>> 6 & 63, i[n++] = 128 | e & 63);
  return i;
};
const vt = (t, i) => {
  if (i < 65534 && t.subarray && Fe)
    return String.fromCharCode.apply(null, t.length === i ? t : t.subarray(0, i));
  let e = "";
  for (let o = 0; o < i; o++)
    e += String.fromCharCode(t[o]);
  return e;
};
var Et = (t, i) => {
  const e = i || t.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(t.subarray(0, i));
  let o, r;
  const n = new Array(e * 2);
  for (r = 0, o = 0; o < e; ) {
    let d = t[o++];
    if (d < 128) {
      n[r++] = d;
      continue;
    }
    let l = $[d];
    if (l > 4) {
      n[r++] = 65533, o += l - 1;
      continue;
    }
    for (d &= l === 2 ? 31 : l === 3 ? 15 : 7; l > 1 && o < e; )
      d = d << 6 | t[o++] & 63, l--;
    if (l > 1) {
      n[r++] = 65533;
      continue;
    }
    d < 65536 ? n[r++] = d : (d -= 65536, n[r++] = 55296 | d >> 10 & 1023, n[r++] = 56320 | d & 1023);
  }
  return vt(n, r);
}, pt = (t, i) => {
  i = i || t.length, i > t.length && (i = t.length);
  let e = i - 1;
  for (; e >= 0 && (t[e] & 192) === 128; )
    e--;
  return e < 0 || e === 0 ? i : e + $[t[e]] > i ? e : i;
}, fe = {
  string2buf: gt,
  buf2string: Et,
  utf8border: pt
};
function yt() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var At = yt;
const G = 30, Rt = 12;
var St = function(i, e) {
  let o, r, n, d, l, p, a, f, S, w, s, u, T, g, x, E, k, c, v, D, h, A, y, _;
  const b = i.state;
  o = i.next_in, y = i.input, r = o + (i.avail_in - 5), n = i.next_out, _ = i.output, d = n - (e - i.avail_out), l = n + (i.avail_out - 257), p = b.dmax, a = b.wsize, f = b.whave, S = b.wnext, w = b.window, s = b.hold, u = b.bits, T = b.lencode, g = b.distcode, x = (1 << b.lenbits) - 1, E = (1 << b.distbits) - 1;
  e:
    do {
      u < 15 && (s += y[o++] << u, u += 8, s += y[o++] << u, u += 8), k = T[s & x];
      t:
        for (; ; ) {
          if (c = k >>> 24, s >>>= c, u -= c, c = k >>> 16 & 255, c === 0)
            _[n++] = k & 65535;
          else if (c & 16) {
            v = k & 65535, c &= 15, c && (u < c && (s += y[o++] << u, u += 8), v += s & (1 << c) - 1, s >>>= c, u -= c), u < 15 && (s += y[o++] << u, u += 8, s += y[o++] << u, u += 8), k = g[s & E];
            i:
              for (; ; ) {
                if (c = k >>> 24, s >>>= c, u -= c, c = k >>> 16 & 255, c & 16) {
                  if (D = k & 65535, c &= 15, u < c && (s += y[o++] << u, u += 8, u < c && (s += y[o++] << u, u += 8)), D += s & (1 << c) - 1, D > p) {
                    i.msg = "invalid distance too far back", b.mode = G;
                    break e;
                  }
                  if (s >>>= c, u -= c, c = n - d, D > c) {
                    if (c = D - c, c > f && b.sane) {
                      i.msg = "invalid distance too far back", b.mode = G;
                      break e;
                    }
                    if (h = 0, A = w, S === 0) {
                      if (h += a - c, c < v) {
                        v -= c;
                        do
                          _[n++] = w[h++];
                        while (--c);
                        h = n - D, A = _;
                      }
                    } else if (S < c) {
                      if (h += a + S - c, c -= S, c < v) {
                        v -= c;
                        do
                          _[n++] = w[h++];
                        while (--c);
                        if (h = 0, S < v) {
                          c = S, v -= c;
                          do
                            _[n++] = w[h++];
                          while (--c);
                          h = n - D, A = _;
                        }
                      }
                    } else if (h += S - c, c < v) {
                      v -= c;
                      do
                        _[n++] = w[h++];
                      while (--c);
                      h = n - D, A = _;
                    }
                    for (; v > 2; )
                      _[n++] = A[h++], _[n++] = A[h++], _[n++] = A[h++], v -= 3;
                    v && (_[n++] = A[h++], v > 1 && (_[n++] = A[h++]));
                  } else {
                    h = n - D;
                    do
                      _[n++] = _[h++], _[n++] = _[h++], _[n++] = _[h++], v -= 3;
                    while (v > 2);
                    v && (_[n++] = _[h++], v > 1 && (_[n++] = _[h++]));
                  }
                } else if ((c & 64) === 0) {
                  k = g[(k & 65535) + (s & (1 << c) - 1)];
                  continue i;
                } else {
                  i.msg = "invalid distance code", b.mode = G;
                  break e;
                }
                break;
              }
          } else if ((c & 64) === 0) {
            k = T[(k & 65535) + (s & (1 << c) - 1)];
            continue t;
          } else if (c & 32) {
            b.mode = Rt;
            break e;
          } else {
            i.msg = "invalid literal/length code", b.mode = G;
            break e;
          }
          break;
        }
    } while (o < r && n < l);
  v = u >> 3, o -= v, u -= v << 3, s &= (1 << u) - 1, i.next_in = o, i.next_out = n, i.avail_in = o < r ? 5 + (r - o) : 5 - (o - r), i.avail_out = n < l ? 257 + (l - n) : 257 - (n - l), b.hold = s, b.bits = u;
};
const M = 15, se = 852, re = 592, ce = 0, W = 1, de = 2, Tt = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), Dt = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), mt = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), Ct = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), It = (t, i, e, o, r, n, d, l) => {
  const p = l.bits;
  let a = 0, f = 0, S = 0, w = 0, s = 0, u = 0, T = 0, g = 0, x = 0, E = 0, k, c, v, D, h, A = null, y = 0, _;
  const b = new Uint16Array(M + 1), Z = new Uint16Array(M + 1);
  let H = null, oe = 0, le, B, F;
  for (a = 0; a <= M; a++)
    b[a] = 0;
  for (f = 0; f < o; f++)
    b[i[e + f]]++;
  for (s = p, w = M; w >= 1 && b[w] === 0; w--)
    ;
  if (s > w && (s = w), w === 0)
    return r[n++] = 1 << 24 | 64 << 16 | 0, r[n++] = 1 << 24 | 64 << 16 | 0, l.bits = 1, 0;
  for (S = 1; S < w && b[S] === 0; S++)
    ;
  for (s < S && (s = S), g = 1, a = 1; a <= M; a++)
    if (g <<= 1, g -= b[a], g < 0)
      return -1;
  if (g > 0 && (t === ce || w !== 1))
    return -1;
  for (Z[1] = 0, a = 1; a < M; a++)
    Z[a + 1] = Z[a] + b[a];
  for (f = 0; f < o; f++)
    i[e + f] !== 0 && (d[Z[i[e + f]]++] = f);
  if (t === ce ? (A = H = d, _ = 19) : t === W ? (A = Tt, y -= 257, H = Dt, oe -= 257, _ = 256) : (A = mt, H = Ct, _ = -1), E = 0, f = 0, a = S, h = n, u = s, T = 0, v = -1, x = 1 << s, D = x - 1, t === W && x > se || t === de && x > re)
    return 1;
  for (; ; ) {
    le = a - T, d[f] < _ ? (B = 0, F = d[f]) : d[f] > _ ? (B = H[oe + d[f]], F = A[y + d[f]]) : (B = 96, F = 0), k = 1 << a - T, c = 1 << u, S = c;
    do
      c -= k, r[h + (E >> T) + c] = le << 24 | B << 16 | F | 0;
    while (c !== 0);
    for (k = 1 << a - 1; E & k; )
      k >>= 1;
    if (k !== 0 ? (E &= k - 1, E += k) : E = 0, f++, --b[a] === 0) {
      if (a === w)
        break;
      a = i[e + d[f]];
    }
    if (a > s && (E & D) !== v) {
      for (T === 0 && (T = s), h += S, u = a - T, g = 1 << u; u + T < w && (g -= b[u + T], !(g <= 0)); )
        u++, g <<= 1;
      if (x += 1 << u, t === W && x > se || t === de && x > re)
        return 1;
      v = E & D, r[v] = s << 24 | u << 16 | h - n | 0;
    }
  }
  return E !== 0 && (r[h + E] = a - T << 24 | 64 << 16 | 0), l.bits = s, 0;
};
var L = It;
const Ot = 0, Ge = 1, Ke = 2, {
  Z_FINISH: he,
  Z_BLOCK: Zt,
  Z_TREES: K,
  Z_OK: N,
  Z_STREAM_END: Nt,
  Z_NEED_DICT: Mt,
  Z_STREAM_ERROR: m,
  Z_DATA_ERROR: Pe,
  Z_MEM_ERROR: je,
  Z_BUF_ERROR: Ut,
  Z_DEFLATED: ue
} = He, Xe = 1, we = 2, xe = 3, _e = 4, be = 5, ke = 6, ge = 7, ve = 8, Ee = 9, pe = 10, X = 11, I = 12, J = 13, ye = 14, Q = 15, Ae = 16, Re = 17, Se = 18, Te = 19, P = 20, j = 21, De = 22, me = 23, Ce = 24, Ie = 25, Oe = 26, V = 27, Ze = 28, Ne = 29, R = 30, Ye = 31, Lt = 32, $t = 852, zt = 592, Ht = 15, Bt = Ht, Me = (t) => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((t & 65280) << 8) + ((t & 255) << 24);
function Ft() {
  this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const We = (t) => {
  if (!t || !t.state)
    return m;
  const i = t.state;
  return t.total_in = t.total_out = i.total = 0, t.msg = "", i.wrap && (t.adler = i.wrap & 1), i.mode = Xe, i.last = 0, i.havedict = 0, i.dmax = 32768, i.head = null, i.hold = 0, i.bits = 0, i.lencode = i.lendyn = new Int32Array($t), i.distcode = i.distdyn = new Int32Array(zt), i.sane = 1, i.back = -1, N;
}, Je = (t) => {
  if (!t || !t.state)
    return m;
  const i = t.state;
  return i.wsize = 0, i.whave = 0, i.wnext = 0, We(t);
}, Qe = (t, i) => {
  let e;
  if (!t || !t.state)
    return m;
  const o = t.state;
  return i < 0 ? (e = 0, i = -i) : (e = (i >> 4) + 1, i < 48 && (i &= 15)), i && (i < 8 || i > 15) ? m : (o.window !== null && o.wbits !== i && (o.window = null), o.wrap = e, o.wbits = i, Je(t));
}, Ve = (t, i) => {
  if (!t)
    return m;
  const e = new Ft();
  t.state = e, e.window = null;
  const o = Qe(t, i);
  return o !== N && (t.state = null), o;
}, Gt = (t) => Ve(t, Bt);
let Ue = !0, q, ee;
const Kt = (t) => {
  if (Ue) {
    q = new Int32Array(512), ee = new Int32Array(32);
    let i = 0;
    for (; i < 144; )
      t.lens[i++] = 8;
    for (; i < 256; )
      t.lens[i++] = 9;
    for (; i < 280; )
      t.lens[i++] = 7;
    for (; i < 288; )
      t.lens[i++] = 8;
    for (L(Ge, t.lens, 0, 288, q, 0, t.work, { bits: 9 }), i = 0; i < 32; )
      t.lens[i++] = 5;
    L(Ke, t.lens, 0, 32, ee, 0, t.work, { bits: 5 }), Ue = !1;
  }
  t.lencode = q, t.lenbits = 9, t.distcode = ee, t.distbits = 5;
}, qe = (t, i, e, o) => {
  let r;
  const n = t.state;
  return n.window === null && (n.wsize = 1 << n.wbits, n.wnext = 0, n.whave = 0, n.window = new Uint8Array(n.wsize)), o >= n.wsize ? (n.window.set(i.subarray(e - n.wsize, e), 0), n.wnext = 0, n.whave = n.wsize) : (r = n.wsize - n.wnext, r > o && (r = o), n.window.set(i.subarray(e - o, e - o + r), n.wnext), o -= r, o ? (n.window.set(i.subarray(e - o, e), 0), n.wnext = o, n.whave = n.wsize) : (n.wnext += r, n.wnext === n.wsize && (n.wnext = 0), n.whave < n.wsize && (n.whave += r))), 0;
}, Pt = (t, i) => {
  let e, o, r, n, d, l, p, a, f, S, w, s, u, T, g = 0, x, E, k, c, v, D, h, A;
  const y = new Uint8Array(4);
  let _, b;
  const Z = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (!t || !t.state || !t.output || !t.input && t.avail_in !== 0)
    return m;
  e = t.state, e.mode === I && (e.mode = J), d = t.next_out, r = t.output, p = t.avail_out, n = t.next_in, o = t.input, l = t.avail_in, a = e.hold, f = e.bits, S = l, w = p, A = N;
  e:
    for (; ; )
      switch (e.mode) {
        case Xe:
          if (e.wrap === 0) {
            e.mode = J;
            break;
          }
          for (; f < 16; ) {
            if (l === 0)
              break e;
            l--, a += o[n++] << f, f += 8;
          }
          if (e.wrap & 2 && a === 35615) {
            e.check = 0, y[0] = a & 255, y[1] = a >>> 8 & 255, e.check = C(e.check, y, 2, 0), a = 0, f = 0, e.mode = we;
            break;
          }
          if (e.flags = 0, e.head && (e.head.done = !1), !(e.wrap & 1) || /* check if zlib header allowed */
          (((a & 255) << 8) + (a >> 8)) % 31) {
            t.msg = "incorrect header check", e.mode = R;
            break;
          }
          if ((a & 15) !== ue) {
            t.msg = "unknown compression method", e.mode = R;
            break;
          }
          if (a >>>= 4, f -= 4, h = (a & 15) + 8, e.wbits === 0)
            e.wbits = h;
          else if (h > e.wbits) {
            t.msg = "invalid window size", e.mode = R;
            break;
          }
          e.dmax = 1 << e.wbits, t.adler = e.check = 1, e.mode = a & 512 ? pe : I, a = 0, f = 0;
          break;
        case we:
          for (; f < 16; ) {
            if (l === 0)
              break e;
            l--, a += o[n++] << f, f += 8;
          }
          if (e.flags = a, (e.flags & 255) !== ue) {
            t.msg = "unknown compression method", e.mode = R;
            break;
          }
          if (e.flags & 57344) {
            t.msg = "unknown header flags set", e.mode = R;
            break;
          }
          e.head && (e.head.text = a >> 8 & 1), e.flags & 512 && (y[0] = a & 255, y[1] = a >>> 8 & 255, e.check = C(e.check, y, 2, 0)), a = 0, f = 0, e.mode = xe;
        /* falls through */
        case xe:
          for (; f < 32; ) {
            if (l === 0)
              break e;
            l--, a += o[n++] << f, f += 8;
          }
          e.head && (e.head.time = a), e.flags & 512 && (y[0] = a & 255, y[1] = a >>> 8 & 255, y[2] = a >>> 16 & 255, y[3] = a >>> 24 & 255, e.check = C(e.check, y, 4, 0)), a = 0, f = 0, e.mode = _e;
        /* falls through */
        case _e:
          for (; f < 16; ) {
            if (l === 0)
              break e;
            l--, a += o[n++] << f, f += 8;
          }
          e.head && (e.head.xflags = a & 255, e.head.os = a >> 8), e.flags & 512 && (y[0] = a & 255, y[1] = a >>> 8 & 255, e.check = C(e.check, y, 2, 0)), a = 0, f = 0, e.mode = be;
        /* falls through */
        case be:
          if (e.flags & 1024) {
            for (; f < 16; ) {
              if (l === 0)
                break e;
              l--, a += o[n++] << f, f += 8;
            }
            e.length = a, e.head && (e.head.extra_len = a), e.flags & 512 && (y[0] = a & 255, y[1] = a >>> 8 & 255, e.check = C(e.check, y, 2, 0)), a = 0, f = 0;
          } else e.head && (e.head.extra = null);
          e.mode = ke;
        /* falls through */
        case ke:
          if (e.flags & 1024 && (s = e.length, s > l && (s = l), s && (e.head && (h = e.head.extra_len - e.length, e.head.extra || (e.head.extra = new Uint8Array(e.head.extra_len)), e.head.extra.set(
            o.subarray(
              n,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              n + s
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            h
          )), e.flags & 512 && (e.check = C(e.check, o, s, n)), l -= s, n += s, e.length -= s), e.length))
            break e;
          e.length = 0, e.mode = ge;
        /* falls through */
        case ge:
          if (e.flags & 2048) {
            if (l === 0)
              break e;
            s = 0;
            do
              h = o[n + s++], e.head && h && e.length < 65536 && (e.head.name += String.fromCharCode(h));
            while (h && s < l);
            if (e.flags & 512 && (e.check = C(e.check, o, s, n)), l -= s, n += s, h)
              break e;
          } else e.head && (e.head.name = null);
          e.length = 0, e.mode = ve;
        /* falls through */
        case ve:
          if (e.flags & 4096) {
            if (l === 0)
              break e;
            s = 0;
            do
              h = o[n + s++], e.head && h && e.length < 65536 && (e.head.comment += String.fromCharCode(h));
            while (h && s < l);
            if (e.flags & 512 && (e.check = C(e.check, o, s, n)), l -= s, n += s, h)
              break e;
          } else e.head && (e.head.comment = null);
          e.mode = Ee;
        /* falls through */
        case Ee:
          if (e.flags & 512) {
            for (; f < 16; ) {
              if (l === 0)
                break e;
              l--, a += o[n++] << f, f += 8;
            }
            if (a !== (e.check & 65535)) {
              t.msg = "header crc mismatch", e.mode = R;
              break;
            }
            a = 0, f = 0;
          }
          e.head && (e.head.hcrc = e.flags >> 9 & 1, e.head.done = !0), t.adler = e.check = 0, e.mode = I;
          break;
        case pe:
          for (; f < 32; ) {
            if (l === 0)
              break e;
            l--, a += o[n++] << f, f += 8;
          }
          t.adler = e.check = Me(a), a = 0, f = 0, e.mode = X;
        /* falls through */
        case X:
          if (e.havedict === 0)
            return t.next_out = d, t.avail_out = p, t.next_in = n, t.avail_in = l, e.hold = a, e.bits = f, Mt;
          t.adler = e.check = 1, e.mode = I;
        /* falls through */
        case I:
          if (i === Zt || i === K)
            break e;
        /* falls through */
        case J:
          if (e.last) {
            a >>>= f & 7, f -= f & 7, e.mode = V;
            break;
          }
          for (; f < 3; ) {
            if (l === 0)
              break e;
            l--, a += o[n++] << f, f += 8;
          }
          switch (e.last = a & 1, a >>>= 1, f -= 1, a & 3) {
            case 0:
              e.mode = ye;
              break;
            case 1:
              if (Kt(e), e.mode = P, i === K) {
                a >>>= 2, f -= 2;
                break e;
              }
              break;
            case 2:
              e.mode = Re;
              break;
            case 3:
              t.msg = "invalid block type", e.mode = R;
          }
          a >>>= 2, f -= 2;
          break;
        case ye:
          for (a >>>= f & 7, f -= f & 7; f < 32; ) {
            if (l === 0)
              break e;
            l--, a += o[n++] << f, f += 8;
          }
          if ((a & 65535) !== (a >>> 16 ^ 65535)) {
            t.msg = "invalid stored block lengths", e.mode = R;
            break;
          }
          if (e.length = a & 65535, a = 0, f = 0, e.mode = Q, i === K)
            break e;
        /* falls through */
        case Q:
          e.mode = Ae;
        /* falls through */
        case Ae:
          if (s = e.length, s) {
            if (s > l && (s = l), s > p && (s = p), s === 0)
              break e;
            r.set(o.subarray(n, n + s), d), l -= s, n += s, p -= s, d += s, e.length -= s;
            break;
          }
          e.mode = I;
          break;
        case Re:
          for (; f < 14; ) {
            if (l === 0)
              break e;
            l--, a += o[n++] << f, f += 8;
          }
          if (e.nlen = (a & 31) + 257, a >>>= 5, f -= 5, e.ndist = (a & 31) + 1, a >>>= 5, f -= 5, e.ncode = (a & 15) + 4, a >>>= 4, f -= 4, e.nlen > 286 || e.ndist > 30) {
            t.msg = "too many length or distance symbols", e.mode = R;
            break;
          }
          e.have = 0, e.mode = Se;
        /* falls through */
        case Se:
          for (; e.have < e.ncode; ) {
            for (; f < 3; ) {
              if (l === 0)
                break e;
              l--, a += o[n++] << f, f += 8;
            }
            e.lens[Z[e.have++]] = a & 7, a >>>= 3, f -= 3;
          }
          for (; e.have < 19; )
            e.lens[Z[e.have++]] = 0;
          if (e.lencode = e.lendyn, e.lenbits = 7, _ = { bits: e.lenbits }, A = L(Ot, e.lens, 0, 19, e.lencode, 0, e.work, _), e.lenbits = _.bits, A) {
            t.msg = "invalid code lengths set", e.mode = R;
            break;
          }
          e.have = 0, e.mode = Te;
        /* falls through */
        case Te:
          for (; e.have < e.nlen + e.ndist; ) {
            for (; g = e.lencode[a & (1 << e.lenbits) - 1], x = g >>> 24, E = g >>> 16 & 255, k = g & 65535, !(x <= f); ) {
              if (l === 0)
                break e;
              l--, a += o[n++] << f, f += 8;
            }
            if (k < 16)
              a >>>= x, f -= x, e.lens[e.have++] = k;
            else {
              if (k === 16) {
                for (b = x + 2; f < b; ) {
                  if (l === 0)
                    break e;
                  l--, a += o[n++] << f, f += 8;
                }
                if (a >>>= x, f -= x, e.have === 0) {
                  t.msg = "invalid bit length repeat", e.mode = R;
                  break;
                }
                h = e.lens[e.have - 1], s = 3 + (a & 3), a >>>= 2, f -= 2;
              } else if (k === 17) {
                for (b = x + 3; f < b; ) {
                  if (l === 0)
                    break e;
                  l--, a += o[n++] << f, f += 8;
                }
                a >>>= x, f -= x, h = 0, s = 3 + (a & 7), a >>>= 3, f -= 3;
              } else {
                for (b = x + 7; f < b; ) {
                  if (l === 0)
                    break e;
                  l--, a += o[n++] << f, f += 8;
                }
                a >>>= x, f -= x, h = 0, s = 11 + (a & 127), a >>>= 7, f -= 7;
              }
              if (e.have + s > e.nlen + e.ndist) {
                t.msg = "invalid bit length repeat", e.mode = R;
                break;
              }
              for (; s--; )
                e.lens[e.have++] = h;
            }
          }
          if (e.mode === R)
            break;
          if (e.lens[256] === 0) {
            t.msg = "invalid code -- missing end-of-block", e.mode = R;
            break;
          }
          if (e.lenbits = 9, _ = { bits: e.lenbits }, A = L(Ge, e.lens, 0, e.nlen, e.lencode, 0, e.work, _), e.lenbits = _.bits, A) {
            t.msg = "invalid literal/lengths set", e.mode = R;
            break;
          }
          if (e.distbits = 6, e.distcode = e.distdyn, _ = { bits: e.distbits }, A = L(Ke, e.lens, e.nlen, e.ndist, e.distcode, 0, e.work, _), e.distbits = _.bits, A) {
            t.msg = "invalid distances set", e.mode = R;
            break;
          }
          if (e.mode = P, i === K)
            break e;
        /* falls through */
        case P:
          e.mode = j;
        /* falls through */
        case j:
          if (l >= 6 && p >= 258) {
            t.next_out = d, t.avail_out = p, t.next_in = n, t.avail_in = l, e.hold = a, e.bits = f, St(t, w), d = t.next_out, r = t.output, p = t.avail_out, n = t.next_in, o = t.input, l = t.avail_in, a = e.hold, f = e.bits, e.mode === I && (e.back = -1);
            break;
          }
          for (e.back = 0; g = e.lencode[a & (1 << e.lenbits) - 1], x = g >>> 24, E = g >>> 16 & 255, k = g & 65535, !(x <= f); ) {
            if (l === 0)
              break e;
            l--, a += o[n++] << f, f += 8;
          }
          if (E && (E & 240) === 0) {
            for (c = x, v = E, D = k; g = e.lencode[D + ((a & (1 << c + v) - 1) >> c)], x = g >>> 24, E = g >>> 16 & 255, k = g & 65535, !(c + x <= f); ) {
              if (l === 0)
                break e;
              l--, a += o[n++] << f, f += 8;
            }
            a >>>= c, f -= c, e.back += c;
          }
          if (a >>>= x, f -= x, e.back += x, e.length = k, E === 0) {
            e.mode = Oe;
            break;
          }
          if (E & 32) {
            e.back = -1, e.mode = I;
            break;
          }
          if (E & 64) {
            t.msg = "invalid literal/length code", e.mode = R;
            break;
          }
          e.extra = E & 15, e.mode = De;
        /* falls through */
        case De:
          if (e.extra) {
            for (b = e.extra; f < b; ) {
              if (l === 0)
                break e;
              l--, a += o[n++] << f, f += 8;
            }
            e.length += a & (1 << e.extra) - 1, a >>>= e.extra, f -= e.extra, e.back += e.extra;
          }
          e.was = e.length, e.mode = me;
        /* falls through */
        case me:
          for (; g = e.distcode[a & (1 << e.distbits) - 1], x = g >>> 24, E = g >>> 16 & 255, k = g & 65535, !(x <= f); ) {
            if (l === 0)
              break e;
            l--, a += o[n++] << f, f += 8;
          }
          if ((E & 240) === 0) {
            for (c = x, v = E, D = k; g = e.distcode[D + ((a & (1 << c + v) - 1) >> c)], x = g >>> 24, E = g >>> 16 & 255, k = g & 65535, !(c + x <= f); ) {
              if (l === 0)
                break e;
              l--, a += o[n++] << f, f += 8;
            }
            a >>>= c, f -= c, e.back += c;
          }
          if (a >>>= x, f -= x, e.back += x, E & 64) {
            t.msg = "invalid distance code", e.mode = R;
            break;
          }
          e.offset = k, e.extra = E & 15, e.mode = Ce;
        /* falls through */
        case Ce:
          if (e.extra) {
            for (b = e.extra; f < b; ) {
              if (l === 0)
                break e;
              l--, a += o[n++] << f, f += 8;
            }
            e.offset += a & (1 << e.extra) - 1, a >>>= e.extra, f -= e.extra, e.back += e.extra;
          }
          if (e.offset > e.dmax) {
            t.msg = "invalid distance too far back", e.mode = R;
            break;
          }
          e.mode = Ie;
        /* falls through */
        case Ie:
          if (p === 0)
            break e;
          if (s = w - p, e.offset > s) {
            if (s = e.offset - s, s > e.whave && e.sane) {
              t.msg = "invalid distance too far back", e.mode = R;
              break;
            }
            s > e.wnext ? (s -= e.wnext, u = e.wsize - s) : u = e.wnext - s, s > e.length && (s = e.length), T = e.window;
          } else
            T = r, u = d - e.offset, s = e.length;
          s > p && (s = p), p -= s, e.length -= s;
          do
            r[d++] = T[u++];
          while (--s);
          e.length === 0 && (e.mode = j);
          break;
        case Oe:
          if (p === 0)
            break e;
          r[d++] = e.length, p--, e.mode = j;
          break;
        case V:
          if (e.wrap) {
            for (; f < 32; ) {
              if (l === 0)
                break e;
              l--, a |= o[n++] << f, f += 8;
            }
            if (w -= p, t.total_out += w, e.total += w, w && (t.adler = e.check = /*UPDATE(state.check, put - _out, _out);*/
            e.flags ? C(e.check, r, w, d - w) : ne(e.check, r, w, d - w)), w = p, (e.flags ? a : Me(a)) !== e.check) {
              t.msg = "incorrect data check", e.mode = R;
              break;
            }
            a = 0, f = 0;
          }
          e.mode = Ze;
        /* falls through */
        case Ze:
          if (e.wrap && e.flags) {
            for (; f < 32; ) {
              if (l === 0)
                break e;
              l--, a += o[n++] << f, f += 8;
            }
            if (a !== (e.total & 4294967295)) {
              t.msg = "incorrect length check", e.mode = R;
              break;
            }
            a = 0, f = 0;
          }
          e.mode = Ne;
        /* falls through */
        case Ne:
          A = Nt;
          break e;
        case R:
          A = Pe;
          break e;
        case Ye:
          return je;
        case Lt:
        /* falls through */
        default:
          return m;
      }
  return t.next_out = d, t.avail_out = p, t.next_in = n, t.avail_in = l, e.hold = a, e.bits = f, (e.wsize || w !== t.avail_out && e.mode < R && (e.mode < V || i !== he)) && qe(t, t.output, t.next_out, w - t.avail_out), S -= t.avail_in, w -= t.avail_out, t.total_in += S, t.total_out += w, e.total += w, e.wrap && w && (t.adler = e.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
  e.flags ? C(e.check, r, w, t.next_out - w) : ne(e.check, r, w, t.next_out - w)), t.data_type = e.bits + (e.last ? 64 : 0) + (e.mode === I ? 128 : 0) + (e.mode === P || e.mode === Q ? 256 : 0), (S === 0 && w === 0 || i === he) && A === N && (A = Ut), A;
}, jt = (t) => {
  if (!t || !t.state)
    return m;
  let i = t.state;
  return i.window && (i.window = null), t.state = null, N;
}, Xt = (t, i) => {
  if (!t || !t.state)
    return m;
  const e = t.state;
  return (e.wrap & 2) === 0 ? m : (e.head = i, i.done = !1, N);
}, Yt = (t, i) => {
  const e = i.length;
  let o, r, n;
  return !t || !t.state || (o = t.state, o.wrap !== 0 && o.mode !== X) ? m : o.mode === X && (r = 1, r = ne(r, i, e, 0), r !== o.check) ? Pe : (n = qe(t, i, e, e), n ? (o.mode = Ye, je) : (o.havedict = 1, N));
};
var Wt = Je, Jt = Qe, Qt = We, Vt = Gt, qt = Ve, ei = Pt, ti = jt, ii = Xt, ni = Yt, ai = "pako inflate (from Nodeca project)", O = {
  inflateReset: Wt,
  inflateReset2: Jt,
  inflateResetKeep: Qt,
  inflateInit: Vt,
  inflateInit2: qt,
  inflate: ei,
  inflateEnd: ti,
  inflateGetHeader: ii,
  inflateSetDictionary: ni,
  inflateInfo: ai
};
function fi() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var oi = fi;
const et = Object.prototype.toString, {
  Z_NO_FLUSH: li,
  Z_FINISH: si,
  Z_OK: z,
  Z_STREAM_END: te,
  Z_NEED_DICT: ie,
  Z_STREAM_ERROR: ri,
  Z_DATA_ERROR: Le,
  Z_MEM_ERROR: ci
} = He;
function Y(t) {
  this.options = Be.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, t || {});
  const i = this.options;
  i.raw && i.windowBits >= 0 && i.windowBits < 16 && (i.windowBits = -i.windowBits, i.windowBits === 0 && (i.windowBits = -15)), i.windowBits >= 0 && i.windowBits < 16 && !(t && t.windowBits) && (i.windowBits += 32), i.windowBits > 15 && i.windowBits < 48 && (i.windowBits & 15) === 0 && (i.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new At(), this.strm.avail_out = 0;
  let e = O.inflateInit2(
    this.strm,
    i.windowBits
  );
  if (e !== z)
    throw new Error(ae[e]);
  if (this.header = new oi(), O.inflateGetHeader(this.strm, this.header), i.dictionary && (typeof i.dictionary == "string" ? i.dictionary = fe.string2buf(i.dictionary) : et.call(i.dictionary) === "[object ArrayBuffer]" && (i.dictionary = new Uint8Array(i.dictionary)), i.raw && (e = O.inflateSetDictionary(this.strm, i.dictionary), e !== z)))
    throw new Error(ae[e]);
}
Y.prototype.push = function(t, i) {
  const e = this.strm, o = this.options.chunkSize, r = this.options.dictionary;
  let n, d, l;
  if (this.ended) return !1;
  for (i === ~~i ? d = i : d = i === !0 ? si : li, et.call(t) === "[object ArrayBuffer]" ? e.input = new Uint8Array(t) : e.input = t, e.next_in = 0, e.avail_in = e.input.length; ; ) {
    for (e.avail_out === 0 && (e.output = new Uint8Array(o), e.next_out = 0, e.avail_out = o), n = O.inflate(e, d), n === ie && r && (n = O.inflateSetDictionary(e, r), n === z ? n = O.inflate(e, d) : n === Le && (n = ie)); e.avail_in > 0 && n === te && e.state.wrap > 0 && t[e.next_in] !== 0; )
      O.inflateReset(e), n = O.inflate(e, d);
    switch (n) {
      case ri:
      case Le:
      case ie:
      case ci:
        return this.onEnd(n), this.ended = !0, !1;
    }
    if (l = e.avail_out, e.next_out && (e.avail_out === 0 || n === te))
      if (this.options.to === "string") {
        let p = fe.utf8border(e.output, e.next_out), a = e.next_out - p, f = fe.buf2string(e.output, p);
        e.next_out = a, e.avail_out = o - a, a && e.output.set(e.output.subarray(p, p + a), 0), this.onData(f);
      } else
        this.onData(e.output.length === e.next_out ? e.output : e.output.subarray(0, e.next_out));
    if (!(n === z && l === 0)) {
      if (n === te)
        return n = O.inflateEnd(this.strm), this.onEnd(n), this.ended = !0, !0;
      if (e.avail_in === 0) break;
    }
  }
  return !0;
};
Y.prototype.onData = function(t) {
  this.chunks.push(t);
};
Y.prototype.onEnd = function(t) {
  t === z && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Be.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
};
function di(t, i) {
  const e = new Y(i);
  if (e.push(t), e.err) throw e.msg || ae[e.err];
  return e.result;
}
var hi = di, ui = {
  inflate: hi
};
const { inflate: wi } = ui;
var xi = wi;
export {
  xi as i
};
