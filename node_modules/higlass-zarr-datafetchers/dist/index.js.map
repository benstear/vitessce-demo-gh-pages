{
  "version": 3,
  "sources": ["../src/ZarrMultivecDataFetcher.js"],
  "sourcesContent": ["import {\n  open as zarrOpen,\n  root as zarrRoot,\n  get as zarrGet,\n  slice,\n  FetchStore,\n} from 'zarrita';\n\nfunction multivecChunksToTileDenseArray(chunks, tileShape, isRow) {\n  // Allocate a Float32Array for the tile (with length tile_size).\n  const fullTileLength = (isRow ? tileShape[1] : tileShape[0] * tileShape[1]);\n  const fullTileArray = new Float32Array(fullTileLength);\n\n  // Fill in the data for each sample and chunk.\n  let offset = 0;\n  if(isRow) {\n    // Single row, no need to iterate over samples.\n    for (const chunk of chunks) {\n      const chunkData = chunk.data;\n      fullTileArray.set(chunkData, offset);\n      offset += chunkData.length;\n    }\n  } else {\n    // Multi-row, need to iterate over samples.\n    const numSamples = tileShape[0];\n    for (let sampleI = 0; sampleI < numSamples; sampleI++) {\n      for (const chunk of chunks) {\n        // Zarrita returns strided arrays.\n        const chunkData = chunk.data.subarray(sampleI * chunk.stride[0], (sampleI+1) * chunk.stride[0]);\n        fullTileArray.set(chunkData, offset);\n        offset += chunkData.length;\n      }\n    }\n  }\n  \n  return fullTileArray;\n}\n\nconst ZarrMultivecDataFetcher = function ZarrMultivecDataFetcher(HGC, ...args) {\n\n  if (!new.target) {\n        throw new Error(\n          'Uncaught TypeError: Class constructor cannot be invoked without \"new\"',\n        );\n    }\n\n    const { slugid } = HGC.libraries;\n    const {\n      absToChr,\n      parseChromsizesRows,\n      genomicRangeToChromosomeChunks,\n      DenseDataExtrema1D,\n      minNonZero,\n      maxNonZero,\n    } = HGC.utils;\n\n    class ZarrMultivecDataFetcherClass {\n        constructor(dataConfig) {\n            this.dataConfig = dataConfig;\n            this.trackUid = slugid.nice();\n        \n            if (dataConfig.url) {\n              // console.assert(dataConfig.url.endsWith('.zarr'));\n              // S3 bucket must have a CORS policy to allow reading from any origin.\n              const { url, options = {} } = dataConfig;\n              this.store = new FetchStore(url, options);\n              this.storeRoot = Promise.resolve(zarrRoot(this.store));\n            }\n\n            if(dataConfig.row !== undefined) {\n              this.row = dataConfig.row;\n            }\n        }\n\n        tilesetInfo(callback) {\n            this.tilesetInfoLoading = true;\n        \n            // Use the tileset_info stored as JSON in file.zarr/.zattrs\n            return this.storeRoot\n              .then(root => zarrOpen(root))\n              .then(grp => {\n                const attrs = grp.attrs;\n                this.tilesetInfoLoading = false;\n\n                const chromSizes = attrs.multiscales.map(d => ([d.name, d.metadata.chromsize]));\n                \n                const finalChrom = attrs.multiscales[attrs.multiscales.length - 1];\n                const maxPos = finalChrom.metadata.chromoffset + finalChrom.metadata.chromsize;\n                const tileSize = attrs.shape[1];\n                const retVal = {\n                  ...attrs,\n                  shape: [attrs.shape[1], attrs.shape[0]],\n                  chromSizes,\n                  tile_size: tileSize,\n                  max_width: maxPos,\n                  min_pos: [0],\n                  max_pos: [maxPos],\n                  max_zoom: Math.ceil(Math.log(maxPos / tileSize) / Math.log(2)),\n                };\n        \n                if (callback) {\n                  callback(retVal);\n                }\n        \n                return retVal;\n              })\n              .catch(err => {\n                this.tilesetInfoLoading = false;\n        \n                if (callback) {\n                  callback({\n                    error: `Error parsing zarr multivec: ${err}`,\n                  });\n                }\n              });\n          }\n        \n          fetchTilesDebounced(receivedTiles, tileIds) {\n            const tiles = {};\n        \n            const validTileIds = [];\n            const tilePromises = [];\n        \n            for (const tileId of tileIds) {\n              const parts = tileId.split('.');\n              const z = parseInt(parts[0], 10);\n              const x = parseInt(parts[1], 10);\n        \n              if (Number.isNaN(x) || Number.isNaN(z)) {\n                console.warn('Invalid tile zoom or position:', z, x);\n                continue;\n              }\n        \n              validTileIds.push(tileId);\n              tilePromises.push(this.tile(z, x, tileId));\n            }\n        \n            Promise.all(tilePromises).then(values => {\n              for (let i = 0; i < values.length; i++) {\n                const validTileId = validTileIds[i];\n                tiles[validTileId] = values[i];\n                tiles[validTileId].tilePositionId = validTileId;\n              }\n              receivedTiles(tiles);\n            });\n            return tiles;\n          }\n        \n          tile(z, x, tileId) {\n            const { storeRoot } = this;\n            return this.tilesetInfo().then(tsInfo => {\n              // const multiscales = tsInfo.multiscales;\n        \n              // Adapted from clodius.tiles.multivec.get_single_tile\n              // Reference: https://github.com/higlass/clodius/blob/develop/clodius/tiles/multivec.py#L66\n        \n              // z is the index of the resolution that should be selected.\n              // Resolution is size of each bin (except for the last bin in each chromosome).\n              const resolution = +tsInfo.resolutions[z];\n              const tileSize = +tsInfo.tile_size;\n              const binSize = resolution;\n        \n              // Where in the data does the tile start and end?\n              const tileStart = x * tileSize * resolution;\n              const tileEnd = tileStart + tileSize * resolution;\n        \n              // chromSizes is an array of \"tuples\" [ [\"chr1\", 1000], ... ]\n              const chromSizes = tsInfo.chromSizes;\n        \n              // Adapted from clodius.tiles.multivec.get_tile\n              // Reference: https://github.com/higlass/clodius/blob/develop/clodius/tiles/multivec.py#L110\n\n              const chromInfo = parseChromsizesRows(chromSizes);\n              const [chrStart, chrStartPos] = absToChr(tileStart, chromInfo);\n              const [chrEnd, chrEndPos] = absToChr(tileEnd, chromInfo);\n              const genomicStart = { chr: chrStart, pos: chrStartPos };\n              const genomicEnd = { chr: chrEnd, pos: chrEndPos };\n        \n              // Using the [genomicStart, genomicEnd] range, get an array of \"chromosome chunks\",\n              // where each chunk range starts and ends with the same chromosome.\n              // Start a new chromosome chunk at each chromosome boundary.\n              const chrChunks = genomicRangeToChromosomeChunks(\n                chromSizes,\n                genomicStart,\n                genomicEnd,\n                binSize,\n                tileSize,\n              );\n        \n              // Get the zarr data for each chromosome chunk,\n              // since data for each chromosome is stored in a separate zarr array.\n              return Promise.all(\n                chrChunks.map(([chrName, zStart, zEnd]) => {\n                  return storeRoot\n                    .then(root => zarrOpen(root.resolve(`/chromosomes/${chrName}/${resolution}/`), { kind: \"array\" }))\n                    .then(arr => (this.row !== undefined\n                    ? zarrGet(arr, [this.row, slice(zStart, zEnd)])\n                    : zarrGet(arr, [null, slice(zStart, zEnd)])\n                  ));\n                }),\n              ).then(chunks => {\n                const dense = multivecChunksToTileDenseArray(chunks, [tsInfo.shape[1], tsInfo.shape[0]], this.row !== undefined);\n                return Promise.resolve({\n                  dense,\n                  denseDataExtrema: new DenseDataExtrema1D(dense),\n                  dtype: 'float32',\n                  min_value: Math.min.apply(null, dense),\n                  max_value: Math.max.apply(null, dense),\n                  minNonZero: minNonZero(dense),\n                  maxNonZero: maxNonZero(dense),\n                  server: null,\n                  size: 1,\n                  shape: tsInfo.shape,\n                  tileId,\n                  tilePos: [x],\n                  tilePositionId: tileId,\n                  tilesetUid: null,\n                  zoomLevel: z,\n                });\n              });\n            });\n        }\n    } // end class\n    return new ZarrMultivecDataFetcherClass(...args);\n} // end function wrapper\n\n\nZarrMultivecDataFetcher.config = {\n    type: 'zarr-multivec',\n};\n\nexport default ZarrMultivecDataFetcher;\n"],
  "mappings": "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",
  "names": ["ZarrMultivecDataFetcher"]
}
