{
  "version": 3,
  "sources": ["../src/ZarrMultivecDataFetcher.js"],
  "sourcesContent": ["import {\n  open as zarrOpen,\n  root as zarrRoot,\n  get as zarrGet,\n  slice,\n  FetchStore,\n} from 'zarrita';\n\nfunction multivecChunksToTileDenseArray(chunks, tileShape, isRow) {\n  // Allocate a Float32Array for the tile (with length tile_size).\n  const fullTileLength = (isRow ? tileShape[1] : tileShape[0] * tileShape[1]);\n  const fullTileArray = new Float32Array(fullTileLength);\n\n  // Fill in the data for each sample and chunk.\n  let offset = 0;\n  if(isRow) {\n    // Single row, no need to iterate over samples.\n    for (const chunk of chunks) {\n      const chunkData = chunk.data;\n      fullTileArray.set(chunkData, offset);\n      offset += chunkData.length;\n    }\n  } else {\n    // Multi-row, need to iterate over samples.\n    const numSamples = tileShape[0];\n    for (let sampleI = 0; sampleI < numSamples; sampleI++) {\n      for (const chunk of chunks) {\n        // Zarrita returns strided arrays.\n        const chunkData = chunk.data.subarray(sampleI * chunk.stride[0], (sampleI+1) * chunk.stride[0]);\n        fullTileArray.set(chunkData, offset);\n        offset += chunkData.length;\n      }\n    }\n  }\n  \n  return fullTileArray;\n}\n\nconst ZarrMultivecDataFetcher = function ZarrMultivecDataFetcher(HGC, ...args) {\n\n  if (!new.target) {\n        throw new Error(\n          'Uncaught TypeError: Class constructor cannot be invoked without \"new\"',\n        );\n    }\n\n    const { slugid } = HGC.libraries;\n    const {\n      absToChr,\n      parseChromsizesRows,\n      genomicRangeToChromosomeChunks,\n      DenseDataExtrema1D,\n      minNonZero,\n      maxNonZero,\n    } = HGC.utils;\n\n    class ZarrMultivecDataFetcherClass {\n        constructor(dataConfig) {\n            this.dataConfig = dataConfig;\n            this.trackUid = slugid.nice();\n        \n            if (dataConfig.url) {\n              // console.assert(dataConfig.url.endsWith('.zarr'));\n              // S3 bucket must have a CORS policy to allow reading from any origin.\n              const { url, options = {} } = dataConfig;\n              this.store = new FetchStore(url, options);\n              this.storeRoot = Promise.resolve(zarrRoot(this.store));\n            }\n\n            if(dataConfig.row !== undefined) {\n              this.row = dataConfig.row;\n            }\n        }\n\n        tilesetInfo(callback) {\n            this.tilesetInfoLoading = true;\n        \n            // Use the tileset_info stored as JSON in file.zarr/.zattrs\n            return this.storeRoot\n              .then(root => zarrOpen(root))\n              .then(grp => {\n                const attrs = grp.attrs;\n                this.tilesetInfoLoading = false;\n\n                const chromSizes = attrs.multiscales.map(d => ([d.name, d.metadata.chromsize]));\n                \n                const finalChrom = attrs.multiscales[attrs.multiscales.length - 1];\n                const maxPos = finalChrom.metadata.chromoffset + finalChrom.metadata.chromsize;\n                const tileSize = attrs.shape[1];\n                const retVal = {\n                  ...attrs,\n                  shape: [attrs.shape[1], attrs.shape[0]],\n                  chromSizes,\n                  tile_size: tileSize,\n                  max_width: maxPos,\n                  min_pos: [0],\n                  max_pos: [maxPos],\n                  max_zoom: Math.ceil(Math.log(maxPos / tileSize) / Math.log(2)),\n                };\n        \n                if (callback) {\n                  callback(retVal);\n                }\n        \n                return retVal;\n              })\n              .catch(err => {\n                this.tilesetInfoLoading = false;\n        \n                if (callback) {\n                  callback({\n                    error: `Error parsing zarr multivec: ${err}`,\n                  });\n                }\n              });\n          }\n        \n          fetchTilesDebounced(receivedTiles, tileIds) {\n            const tiles = {};\n        \n            const validTileIds = [];\n            const tilePromises = [];\n        \n            for (const tileId of tileIds) {\n              const parts = tileId.split('.');\n              const z = parseInt(parts[0], 10);\n              const x = parseInt(parts[1], 10);\n        \n              if (Number.isNaN(x) || Number.isNaN(z)) {\n                console.warn('Invalid tile zoom or position:', z, x);\n                continue;\n              }\n        \n              validTileIds.push(tileId);\n              tilePromises.push(this.tile(z, x, tileId));\n            }\n        \n            Promise.all(tilePromises).then(values => {\n              for (let i = 0; i < values.length; i++) {\n                const validTileId = validTileIds[i];\n                tiles[validTileId] = values[i];\n                tiles[validTileId].tilePositionId = validTileId;\n              }\n              receivedTiles(tiles);\n            });\n            return tiles;\n          }\n        \n          tile(z, x, tileId) {\n            const { storeRoot } = this;\n            return this.tilesetInfo().then(tsInfo => {\n              // const multiscales = tsInfo.multiscales;\n        \n              // Adapted from clodius.tiles.multivec.get_single_tile\n              // Reference: https://github.com/higlass/clodius/blob/develop/clodius/tiles/multivec.py#L66\n        \n              // z is the index of the resolution that should be selected.\n              // Resolution is size of each bin (except for the last bin in each chromosome).\n              const resolution = +tsInfo.resolutions[z];\n              const tileSize = +tsInfo.tile_size;\n              const binSize = resolution;\n        \n              // Where in the data does the tile start and end?\n              const tileStart = x * tileSize * resolution;\n              const tileEnd = tileStart + tileSize * resolution;\n        \n              // chromSizes is an array of \"tuples\" [ [\"chr1\", 1000], ... ]\n              const chromSizes = tsInfo.chromSizes;\n        \n              // Adapted from clodius.tiles.multivec.get_tile\n              // Reference: https://github.com/higlass/clodius/blob/develop/clodius/tiles/multivec.py#L110\n\n              const chromInfo = parseChromsizesRows(chromSizes);\n              const [chrStart, chrStartPos] = absToChr(tileStart, chromInfo);\n              const [chrEnd, chrEndPos] = absToChr(tileEnd, chromInfo);\n              const genomicStart = { chr: chrStart, pos: chrStartPos };\n              const genomicEnd = { chr: chrEnd, pos: chrEndPos };\n        \n              // Using the [genomicStart, genomicEnd] range, get an array of \"chromosome chunks\",\n              // where each chunk range starts and ends with the same chromosome.\n              // Start a new chromosome chunk at each chromosome boundary.\n              const chrChunks = genomicRangeToChromosomeChunks(\n                chromSizes,\n                genomicStart,\n                genomicEnd,\n                binSize,\n                tileSize,\n              );\n        \n              // Get the zarr data for each chromosome chunk,\n              // since data for each chromosome is stored in a separate zarr array.\n              return Promise.all(\n                chrChunks.map(([chrName, zStart, zEnd]) => {\n                  return storeRoot\n                    .then(root => zarrOpen(root.resolve(`/chromosomes/${chrName}/${resolution}/`), { kind: \"array\" }))\n                    .then(arr => (this.row !== undefined\n                    ? zarrGet(arr, [this.row, slice(zStart, zEnd)])\n                    : zarrGet(arr, [null, slice(zStart, zEnd)])\n                  ));\n                }),\n              ).then(chunks => {\n                const dense = multivecChunksToTileDenseArray(chunks, [tsInfo.shape[1], tsInfo.shape[0]], this.row !== undefined);\n                return Promise.resolve({\n                  dense,\n                  denseDataExtrema: new DenseDataExtrema1D(dense),\n                  dtype: 'float32',\n                  min_value: Math.min.apply(null, dense),\n                  max_value: Math.max.apply(null, dense),\n                  minNonZero: minNonZero(dense),\n                  maxNonZero: maxNonZero(dense),\n                  server: null,\n                  size: 1,\n                  shape: tsInfo.shape,\n                  tileId,\n                  tilePos: [x],\n                  tilePositionId: tileId,\n                  tilesetUid: null,\n                  zoomLevel: z,\n                });\n              });\n            });\n        }\n    } // end class\n    return new ZarrMultivecDataFetcherClass(...args);\n} // end function wrapper\n\n\nZarrMultivecDataFetcher.config = {\n    type: 'zarr-multivec',\n};\n\nexport default ZarrMultivecDataFetcher;\n"],
  "mappings": "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",
  "names": ["zarrOpen", "zarrRoot", "zarrGet", "slice", "FetchStore", "multivecChunksToTileDenseArray", "chunks", "tileShape", "isRow", "fullTileLength", "fullTileArray", "offset", "chunk", "chunkData", "numSamples", "sampleI", "ZarrMultivecDataFetcher", "HGC", "args", "slugid", "absToChr", "parseChromsizesRows", "genomicRangeToChromosomeChunks", "DenseDataExtrema1D", "minNonZero", "maxNonZero", "ZarrMultivecDataFetcherClass", "dataConfig", "url", "options", "callback", "root", "grp", "attrs", "chromSizes", "d", "finalChrom", "maxPos", "tileSize", "retVal", "err", "receivedTiles", "tileIds", "tiles", "validTileIds", "tilePromises", "tileId", "parts", "z", "x", "values", "i", "validTileId", "storeRoot", "tsInfo", "resolution", "binSize", "tileStart", "tileEnd", "chromInfo", "chrStart", "chrStartPos", "chrEnd", "chrEndPos", "chrChunks", "chrName", "zStart", "zEnd", "arr", "dense", "ZarrMultivecDataFetcher_default"]
}
