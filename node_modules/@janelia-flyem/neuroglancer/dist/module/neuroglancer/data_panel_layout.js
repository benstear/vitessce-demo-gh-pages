import _Object$keys from 'babel-runtime/core-js/object/keys';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Set from 'babel-runtime/core-js/set';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Map from 'babel-runtime/core-js/map';

import debounce from 'lodash/debounce'; /**
                                         * @license
                                         * Copyright 2016 Google Inc.
                                         * Licensed under the Apache License, Version 2.0 (the "License");
                                         * you may not use this file except in compliance with the License.
                                         * You may obtain a copy of the License at
                                         *
                                         *      http://www.apache.org/licenses/LICENSE-2.0
                                         *
                                         * Unless required by applicable law or agreed to in writing, software
                                         * distributed under the License is distributed on an "AS IS" BASIS,
                                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                         * See the License for the specific language governing permissions and
                                         * limitations under the License.
                                         */

import * as L from './layout';
import { DisplayPose, LinkedOrientationState, LinkedPosition, linkedStateLegacyJsonView, LinkedZoomState, NavigationState, OrientationState } from './navigation_state';
import { PerspectivePanel } from './perspective_view/panel';
import { SliceView } from './sliceview/frontend';
import { SliceViewPanel } from './sliceview/panel';
import { TrackableBoolean } from './trackable_boolean';
import { TrackableValue } from './trackable_value';
import { RefCounted } from './util/disposable';
import { removeChildren, removeFromParent } from './util/dom';
import { EventActionMap, registerActionListener } from './util/event_action_map';
import { quat } from './util/geom';
import { verifyObject, verifyObjectProperty, verifyPositiveInt } from './util/json';
import { NullarySignal } from './util/signal';
import { optionallyRestoreFromJsonMember } from './util/trackable';
import { WatchableMap } from './util/watchable_map';
import { DisplayDimensionsWidget } from './widget/display_dimensions_widget';
export class InputEventBindings {
    constructor() {
        this.perspectiveView = new EventActionMap();
        this.sliceView = new EventActionMap();
    }
}
const AXES_RELATIVE_ORIENTATION = new _Map([['xy', undefined], ['xz', quat.rotateX(quat.create(), quat.create(), Math.PI / 2)], ['yz', quat.rotateY(quat.create(), quat.create(), Math.PI / 2)]]);
const oneSquareSymbol = '◻';
const LAYOUT_SYMBOLS = new _Map([['4panel', '◱'], ['3d', oneSquareSymbol]]);
export function makeSliceView(viewerState, baseToSelf) {
    let navigationState;
    if (baseToSelf === undefined) {
        navigationState = viewerState.navigationState.addRef();
    } else {
        navigationState = new NavigationState(new DisplayPose(viewerState.navigationState.pose.position.addRef(), viewerState.navigationState.pose.displayDimensionRenderInfo.addRef(), OrientationState.makeRelative(viewerState.navigationState.pose.orientation, baseToSelf)), viewerState.navigationState.zoomFactor.addRef(), viewerState.navigationState.depthRange.addRef());
    }
    return new SliceView(viewerState.chunkManager, viewerState.layerManager, navigationState, viewerState.wireFrame);
}
export function makeNamedSliceView(viewerState, axes) {
    return makeSliceView(viewerState, AXES_RELATIVE_ORIENTATION.get(axes));
}
export function makeOrthogonalSliceViews(viewerState) {
    return new _Map([['xy', makeNamedSliceView(viewerState, 'xy')], ['xz', makeNamedSliceView(viewerState, 'xz')], ['yz', makeNamedSliceView(viewerState, 'yz')]]);
}
export function getCommonViewerState(viewer) {
    return {
        crossSectionBackgroundColor: viewer.crossSectionBackgroundColor,
        perspectiveViewBackgroundColor: viewer.perspectiveViewBackgroundColor,
        selectionDetailsState: viewer.selectionDetailsState,
        mouseState: viewer.mouseState,
        layerManager: viewer.layerManager,
        showAxisLines: viewer.showAxisLines,
        wireFrame: viewer.wireFrame,
        visibleLayerRoles: viewer.visibleLayerRoles,
        selectedLayer: viewer.selectedLayer,
        visibility: viewer.visibility,
        scaleBarOptions: viewer.scaleBarOptions
    };
}
function getCommonPerspectiveViewerState(container) {
    const viewer = container.viewer;

    return _Object$assign(_Object$assign({}, getCommonViewerState(viewer)), { navigationState: viewer.perspectiveNavigationState, inputEventMap: viewer.inputEventBindings.perspectiveView, orthographicProjection: container.specification.orthographicProjection, showScaleBar: viewer.showScaleBar, rpc: viewer.chunkManager.rpc });
}
function getCommonSliceViewerState(viewer) {
    return _Object$assign(_Object$assign({}, getCommonViewerState(viewer)), { navigationState: viewer.navigationState, inputEventMap: viewer.inputEventBindings.sliceView });
}
function addDisplayDimensionsWidget(layout, panel) {
    const navigationState = panel.navigationState;

    panel.element.appendChild(layout.registerDisposer(new DisplayDimensionsWidget(navigationState.pose.displayDimensionRenderInfo.addRef(), navigationState.zoomFactor, navigationState.depthRange.addRef(), panel instanceof SliceViewPanel ? 'px' : 'vh')).element);
}
function registerRelatedLayouts(layout, panel, relatedLayouts) {
    const controls = document.createElement('div');
    controls.className = 'neuroglancer-data-panel-layout-controls';
    layout.registerDisposer(() => removeFromParent(controls));
    for (let i = 0; i < 2; ++i) {
        const relatedLayout = relatedLayouts[Math.min(relatedLayouts.length - 1, i)];
        layout.registerDisposer(registerActionListener(panel.element, i === 0 ? 'toggle-layout' : 'toggle-layout-alternative', event => {
            layout.container.name = relatedLayout;
            event.stopPropagation();
        }));
    }
    for (const relatedLayout of relatedLayouts) {
        const button = document.createElement('button');
        const innerDiv = document.createElement('div');
        button.appendChild(innerDiv);
        innerDiv.textContent = LAYOUT_SYMBOLS.get(relatedLayout);
        button.title = `Switch to ${relatedLayout} layout.`;
        button.addEventListener('click', () => {
            layout.container.name = relatedLayout;
        });
        controls.appendChild(button);
    }
    panel.element.appendChild(controls);
}
function makeSliceViewFromSpecification(viewer, specification) {
    const sliceView = new SliceView(viewer.chunkManager, viewer.layerManager, specification.navigationState.addRef(), viewer.wireFrame);
    const updateViewportSize = () => {
        const width = specification.width.value,
              height = specification.height.value;

        sliceView.projectionParameters.setViewport({
            width,
            height,
            logicalWidth: width,
            logicalHeight: height,
            visibleLeftFraction: 0,
            visibleTopFraction: 0,
            visibleWidthFraction: 1,
            visibleHeightFraction: 1
        });
    };
    sliceView.registerDisposer(specification.width.changed.add(updateViewportSize));
    sliceView.registerDisposer(specification.height.changed.add(updateViewportSize));
    updateViewportSize();
    return sliceView;
}
function addUnconditionalSliceViews(viewer, panel, crossSections) {
    const previouslyAdded = new _Map();
    const update = () => {
        const currentCrossSections = new _Set();
        // Add missing cross sections.
        for (const crossSection of crossSections.values()) {
            currentCrossSections.add(crossSection);
            if (previouslyAdded.has(crossSection)) {
                continue;
            }
            const sliceView = makeSliceViewFromSpecification(viewer, crossSection);
            panel.sliceViews.set(sliceView, true);
            previouslyAdded.set(crossSection, sliceView);
        }
        // Remove extra cross sections.
        for (const _ref of previouslyAdded) {
            var _ref2 = _slicedToArray(_ref, 2);

            const crossSection = _ref2[0];
            const sliceView = _ref2[1];

            if (currentCrossSections.has(crossSection)) {
                continue;
            }
            panel.sliceViews.delete(sliceView);
        }
    };
    update();
}
export class FourPanelLayout extends RefCounted {
    constructor(container, rootElement, viewer, crossSections) {
        super();
        this.container = container;
        this.rootElement = rootElement;
        this.viewer = viewer;
        let sliceViews = makeOrthogonalSliceViews(viewer);
        let display = viewer.display;

        const perspectiveViewerState = _Object$assign(_Object$assign({}, getCommonPerspectiveViewerState(container)), { showSliceViews: viewer.showPerspectiveSliceViews, showSliceViewsCheckbox: true });
        const sliceViewerState = _Object$assign(_Object$assign({}, getCommonSliceViewerState(viewer)), { showScaleBar: viewer.showScaleBar });
        const sliceViewerStateWithoutScaleBar = _Object$assign(_Object$assign({}, getCommonSliceViewerState(viewer)), { showScaleBar: new TrackableBoolean(false, false) });
        const makeSliceViewPanel = (axes, element, state, displayDimensionsWidget) => {
            const panel = this.registerDisposer(new SliceViewPanel(display, element, sliceViews.get(axes), state));
            if (displayDimensionsWidget) {
                addDisplayDimensionsWidget(this, panel);
            }
            registerRelatedLayouts(this, panel, [axes, `${axes}-3d`]);
            return panel;
        };
        let mainDisplayContents = [L.withFlex(1, L.box('column', [L.withFlex(1, L.box('row', [L.withFlex(1, element => {
            makeSliceViewPanel('xy', element, sliceViewerState, true);
        }), L.withFlex(1, element => {
            makeSliceViewPanel('xz', element, sliceViewerStateWithoutScaleBar, false);
        })])), L.withFlex(1, L.box('row', [L.withFlex(1, element => {
            let panel = this.registerDisposer(new PerspectivePanel(display, element, perspectiveViewerState));
            for (let sliceView of sliceViews.values()) {
                panel.sliceViews.set(sliceView.addRef(), false);
            }
            addDisplayDimensionsWidget(this, panel);
            addUnconditionalSliceViews(viewer, panel, crossSections);
            registerRelatedLayouts(this, panel, ['3d']);
        }), L.withFlex(1, element => {
            makeSliceViewPanel('yz', element, sliceViewerStateWithoutScaleBar, false);
        })]))]))];
        L.box('row', mainDisplayContents)(rootElement);
    }
    disposed() {
        removeChildren(this.rootElement);
        super.disposed();
    }
}
export class SliceViewPerspectiveTwoPanelLayout extends RefCounted {
    constructor(container, rootElement, viewer, direction, axes, crossSections) {
        super();
        this.container = container;
        this.rootElement = rootElement;
        this.viewer = viewer;
        this.direction = direction;
        let sliceView = makeNamedSliceView(viewer, axes);
        let display = viewer.display;

        const perspectiveViewerState = _Object$assign(_Object$assign({}, getCommonPerspectiveViewerState(container)), { showSliceViews: viewer.showPerspectiveSliceViews, showSliceViewsCheckbox: true });
        const sliceViewerState = _Object$assign(_Object$assign({}, getCommonSliceViewerState(viewer)), { showScaleBar: viewer.showScaleBar });
        L.withFlex(1, L.box(direction, [L.withFlex(1, element => {
            const panel = this.registerDisposer(new SliceViewPanel(display, element, sliceView, sliceViewerState));
            addDisplayDimensionsWidget(this, panel);
            registerRelatedLayouts(this, panel, [axes, '4panel']);
        }), L.withFlex(1, element => {
            let panel = this.registerDisposer(new PerspectivePanel(display, element, perspectiveViewerState));
            panel.sliceViews.set(sliceView.addRef(), false);
            addUnconditionalSliceViews(viewer, panel, crossSections);
            addDisplayDimensionsWidget(this, panel);
            registerRelatedLayouts(this, panel, ['3d', '4panel']);
        })]))(rootElement);
    }
    disposed() {
        removeChildren(this.rootElement);
        super.disposed();
    }
}
export class SinglePanelLayout extends RefCounted {
    constructor(container, rootElement, viewer, axes) {
        super();
        this.container = container;
        this.rootElement = rootElement;
        this.viewer = viewer;
        let sliceView = makeNamedSliceView(viewer, axes);
        const sliceViewerState = _Object$assign(_Object$assign({}, getCommonSliceViewerState(viewer)), { showScaleBar: viewer.showScaleBar });
        L.box('row', [L.withFlex(1, element => {
            const panel = this.registerDisposer(new SliceViewPanel(viewer.display, element, sliceView, sliceViewerState));
            addDisplayDimensionsWidget(this, panel);
            registerRelatedLayouts(this, panel, ['4panel', `${axes}-3d`]);
        })])(rootElement);
    }
    disposed() {
        removeChildren(this.rootElement);
        super.disposed();
    }
}
export class SinglePerspectiveLayout extends RefCounted {
    constructor(container, rootElement, viewer, crossSections) {
        super();
        this.container = container;
        this.rootElement = rootElement;
        this.viewer = viewer;
        let perspectiveViewerState = _Object$assign(_Object$assign({}, getCommonPerspectiveViewerState(container)), { showSliceViews: new TrackableBoolean(false, false) });
        L.box('row', [L.withFlex(1, element => {
            const panel = this.registerDisposer(new PerspectivePanel(viewer.display, element, perspectiveViewerState));
            addUnconditionalSliceViews(viewer, panel, crossSections);
            addDisplayDimensionsWidget(this, panel);
            registerRelatedLayouts(this, panel, ['4panel']);
        })])(rootElement);
    }
    disposed() {
        removeChildren(this.rootElement);
        super.disposed();
    }
}
export const LAYOUTS = new _Map([['4panel', {
    factory: (container, element, viewer, crossSections) => new FourPanelLayout(container, element, viewer, crossSections)
}], ['3d', {
    factory: (container, element, viewer, crossSections) => new SinglePerspectiveLayout(container, element, viewer, crossSections)
}]]);
for (const axes of AXES_RELATIVE_ORIENTATION.keys()) {
    LAYOUTS.set(axes, {
        factory: (container, element, viewer) => new SinglePanelLayout(container, element, viewer, axes)
    });
    const splitLayout = `${axes}-3d`;
    LAYOUT_SYMBOLS.set(axes, oneSquareSymbol);
    LAYOUT_SYMBOLS.set(splitLayout, '◫');
    LAYOUTS.set(splitLayout, {
        factory: (container, element, viewer, crossSections) => new SliceViewPerspectiveTwoPanelLayout(container, element, viewer, 'row', axes, crossSections)
    });
}
export function getLayoutByName(obj) {
    let layout = LAYOUTS.get(obj);
    if (layout === undefined) {
        throw new Error(`Invalid layout name: ${_JSON$stringify(obj)}.`);
    }
    return layout;
}
export function validateLayoutName(obj) {
    getLayoutByName(obj);
    return obj;
}
export class CrossSectionSpecification extends RefCounted {
    constructor(parent) {
        super();
        this.width = new TrackableValue(1000, verifyPositiveInt);
        this.height = new TrackableValue(1000, verifyPositiveInt);
        this.changed = new NullarySignal();
        this.position = new LinkedPosition(parent.position.addRef());
        this.position.changed.add(this.changed.dispatch);
        this.orientation = new LinkedOrientationState(parent.pose.orientation.addRef());
        this.orientation.changed.add(this.changed.dispatch);
        this.width.changed.add(this.changed.dispatch);
        this.height.changed.add(this.changed.dispatch);
        this.scale = new LinkedZoomState(parent.zoomFactor.addRef(), parent.zoomFactor.displayDimensionRenderInfo.addRef());
        this.scale.changed.add(this.changed.dispatch);
        this.navigationState = this.registerDisposer(new NavigationState(new DisplayPose(this.position.value, parent.pose.displayDimensionRenderInfo.addRef(), this.orientation.value), this.scale.value, parent.depthRange.addRef()));
    }
    restoreState(obj) {
        verifyObject(obj);
        optionallyRestoreFromJsonMember(obj, 'width', this.width);
        optionallyRestoreFromJsonMember(obj, 'height', this.height);
        optionallyRestoreFromJsonMember(obj, 'position', linkedStateLegacyJsonView(this.position));
        optionallyRestoreFromJsonMember(obj, 'orientation', this.orientation);
        optionallyRestoreFromJsonMember(obj, 'scale', this.scale);
        optionallyRestoreFromJsonMember(obj, 'zoom', linkedStateLegacyJsonView(this.scale));
    }
    reset() {
        this.width.reset();
        this.height.reset();
        this.position.reset();
        this.orientation.reset();
        this.scale.reset();
    }
    toJSON() {
        return {
            width: this.width.toJSON(),
            height: this.height.toJSON(),
            position: this.position.toJSON(),
            orientation: this.orientation.toJSON(),
            scale: this.scale.toJSON()
        };
    }
}
export class CrossSectionSpecificationMap extends WatchableMap {
    constructor(parentNavigationState) {
        super((context, spec) => context.registerDisposer(context.registerDisposer(spec).changed.add(this.changed.dispatch)));
        this.parentNavigationState = parentNavigationState;
        this.registerDisposer(parentNavigationState);
    }
    restoreState(obj) {
        verifyObject(obj);
        for (const key of _Object$keys(obj)) {
            const state = new CrossSectionSpecification(this.parentNavigationState);
            try {
                this.set(key, state.addRef());
                state.restoreState(obj[key]);
            } finally {
                state.dispose();
            }
        }
    }
    reset() {
        this.clear();
    }
    toJSON() {
        if (this.size === 0) return undefined;
        const obj = {};
        for (const _ref3 of this) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const k = _ref4[0];
            const v = _ref4[1];

            obj[k] = v.toJSON();
        }
        return obj;
    }
}
export class DataPanelLayoutSpecification extends RefCounted {
    constructor(parentNavigationState, defaultLayout) {
        super();
        this.changed = new NullarySignal();
        this.orthographicProjection = new TrackableBoolean(false);
        this.type = new TrackableValue(defaultLayout, validateLayoutName);
        this.type.changed.add(this.changed.dispatch);
        this.crossSections = this.registerDisposer(new CrossSectionSpecificationMap(parentNavigationState.addRef()));
        this.crossSections.changed.add(this.changed.dispatch);
        this.orthographicProjection.changed.add(this.changed.dispatch);
        this.registerDisposer(parentNavigationState);
    }
    reset() {
        this.crossSections.clear();
        this.orthographicProjection.reset();
        this.type.reset();
    }
    restoreState(obj) {
        this.crossSections.clear();
        this.orthographicProjection.reset();
        if (typeof obj === 'string') {
            this.type.restoreState(obj);
        } else {
            verifyObject(obj);
            verifyObjectProperty(obj, 'type', x => this.type.restoreState(x));
            verifyObjectProperty(obj, 'orthographicProjection', x => this.orthographicProjection.restoreState(x));
            verifyObjectProperty(obj, 'crossSections', x => x !== undefined && this.crossSections.restoreState(x));
        }
    }
    toJSON() {
        const type = this.type,
              crossSections = this.crossSections,
              orthographicProjection = this.orthographicProjection;

        const orthographicProjectionJson = orthographicProjection.toJSON();
        if (crossSections.size === 0 && orthographicProjectionJson === undefined) {
            return type.value;
        }
        return {
            type: type.value,
            crossSections: crossSections.toJSON(),
            orthographicProjection: orthographicProjectionJson
        };
    }
}
export class DataPanelLayoutContainer extends RefCounted {
    constructor(viewer, defaultLayout) {
        super();
        this.viewer = viewer;
        this.element = document.createElement('div');
        this.specification = this.registerDisposer(new DataPanelLayoutSpecification(this.viewer.navigationState.addRef(), defaultLayout));
        this.element.style.flex = '1';
        const scheduleUpdateLayout = this.registerCancellable(debounce(() => this.updateLayout(), 0));
        this.specification.type.changed.add(scheduleUpdateLayout);
        registerActionListener(this.element, 'toggle-orthographic-projection', () => this.specification.orthographicProjection.toggle());
        // Ensure the layout is updated before drawing begins to avoid flicker.
        this.registerDisposer(this.viewer.display.updateStarted.add(() => scheduleUpdateLayout.flush()));
        scheduleUpdateLayout();
    }
    get name() {
        return this.specification.type.value;
    }
    set name(value) {
        this.specification.type.value = value;
    }
    get changed() {
        return this.specification.changed;
    }
    toJSON() {
        return this.specification.toJSON();
    }
    restoreState(obj) {
        this.specification.restoreState(obj);
    }
    reset() {
        this.specification.reset();
    }
    disposeLayout() {
        let layout = this.layout;

        if (layout !== undefined) {
            layout.dispose();
            this.layout = undefined;
        }
    }
    updateLayout() {
        this.disposeLayout();
        this.layout = getLayoutByName(this.name).factory(this, this.element, this.viewer, this.specification.crossSections);
    }
    disposed() {
        this.disposeLayout();
        super.disposed();
    }
}
//# sourceMappingURL=data_panel_layout.js.map