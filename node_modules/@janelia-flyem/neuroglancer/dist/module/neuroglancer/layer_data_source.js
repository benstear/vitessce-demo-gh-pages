import _Array$from from 'babel-runtime/core-js/array/from';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { coordinateTransformSpecificationFromJson, coordinateTransformSpecificationToJson, makeCoordinateSpace, makeIdentityTransform, WatchableCoordinateSpaceTransform } from './coordinate_transform';
import { makeEmptyDataSourceSpecification } from './datasource';
import { getWatchableRenderLayerTransform } from './render_coordinate_transform';
import { arraysEqual } from './util/array';
import { CancellationTokenSource } from './util/cancellation';
import { disposableOnce, RefCounted } from './util/disposable';
import { verifyBoolean, verifyObject, verifyObjectAsMap, verifyObjectProperty, verifyOptionalObjectProperty, verifyString } from './util/json';
import * as matrix from './util/matrix';
import { MessageList, MessageSeverity } from './util/message_list';
import { NullarySignal } from './util/signal';
export function parseDataSubsourceSpecificationFromJson(json) {
    if (typeof json === 'boolean') {
        return { enabled: json };
    }
    verifyObject(json);
    return { enabled: verifyOptionalObjectProperty(json, 'enabled', verifyBoolean) };
}
export function layerDataSourceSpecificationFromJson(obj, legacyTransform = undefined) {
    if (typeof obj === 'string') {
        return {
            url: obj,
            transform: legacyTransform,
            enableDefaultSubsources: true,
            subsources: new _Map()
        };
    }
    verifyObject(obj);
    return {
        url: verifyObjectProperty(obj, 'url', verifyString),
        transform: verifyObjectProperty(obj, 'transform', coordinateTransformSpecificationFromJson) || legacyTransform,
        enableDefaultSubsources: verifyOptionalObjectProperty(obj, 'enableDefaultSubsources', verifyBoolean, true),
        subsources: verifyOptionalObjectProperty(obj, 'subsources', subsourcesObj => verifyObjectAsMap(subsourcesObj, parseDataSubsourceSpecificationFromJson), new _Map())
    };
}
function dataSubsourceSpecificationToJson(spec) {
    return spec.enabled;
}
export function layerDataSourceSpecificationToJson(spec) {
    const transform = coordinateTransformSpecificationToJson(spec.transform);
    const subsourcesJson = {};
    let emptySubsources = true;
    for (const _ref of spec.subsources) {
        var _ref2 = _slicedToArray(_ref, 2);

        const id = _ref2[0];
        const subsource = _ref2[1];

        const j = dataSubsourceSpecificationToJson(subsource);
        if (j !== undefined) {
            subsourcesJson[id] = j;
            emptySubsources = false;
        }
    }
    if (transform === undefined && emptySubsources && spec.enableDefaultSubsources === true) {
        return spec.url;
    }
    return {
        url: spec.url,
        transform,
        subsources: emptySubsources ? undefined : subsourcesJson,
        enableDefaultSubsources: spec.enableDefaultSubsources === true ? undefined : false
    };
}
export class LoadedDataSubsource {
    constructor(loadedDataSource, subsourceEntry, subsourceSpec, subsourceIndex, enableDefaultSubsources) {
        this.loadedDataSource = loadedDataSource;
        this.subsourceEntry = subsourceEntry;
        this.subsourceSpec = subsourceSpec;
        this.subsourceIndex = subsourceIndex;
        this.activated = undefined;
        this.guardValues = [];
        this.messages = new MessageList();
        this.isActiveChanged = new NullarySignal();
        let enabled;
        if (subsourceSpec === undefined || subsourceSpec.enabled === undefined) {
            enabled = subsourceEntry.default && enableDefaultSubsources;
        } else {
            enabled = subsourceSpec.enabled;
        }
        const modelRank = loadedDataSource.dataSource.modelTransform.sourceRank;
        let modelSubspaceDimensionIndices = subsourceEntry.modelSubspaceDimensionIndices;

        if (modelSubspaceDimensionIndices === undefined) {
            modelSubspaceDimensionIndices = new Array(modelRank);
            for (let i = 0; i < modelRank; ++i) {
                modelSubspaceDimensionIndices[i] = i;
            }
        }
        var _subsourceEntry$subso = subsourceEntry.subsourceToModelSubspaceTransform;
        const subsourceToModelSubspaceTransform = _subsourceEntry$subso === undefined ? matrix.createIdentity(Float32Array, modelSubspaceDimensionIndices.length + 1) : _subsourceEntry$subso;

        this.enabled = enabled;
        this.subsourceToModelSubspaceTransform = subsourceToModelSubspaceTransform;
        this.modelSubspaceDimensionIndices = modelSubspaceDimensionIndices;
        this.isActiveChanged.add(loadedDataSource.activatedSubsourcesChanged.dispatch);
    }
    activate(callback, ...guardValues) {
        this.messages.clearMessages();
        if (this.activated !== undefined) {
            if (arraysEqual(guardValues, this.guardValues)) return;
            this.activated.dispose();
        }
        this.guardValues = guardValues;
        const activated = this.activated = new RefCounted();
        callback(activated);
        this.isActiveChanged.dispatch();
    }
    deactivate(error) {
        this.messages.clearMessages();
        this.messages.addMessage({ severity: MessageSeverity.error, message: error });
        const activated = this.activated;

        if (activated === undefined) return;
        this.activated = undefined;
        activated.dispose();
        this.isActiveChanged.dispatch();
    }
    addRenderLayer(renderLayer) {
        const activated = this.activated;
        activated.registerDisposer(this.loadedDataSource.layer.addRenderLayer(renderLayer));
        activated.registerDisposer(this.messages.addChild(renderLayer.messages));
    }
    getRenderLayerTransform(channelCoordinateSpace) {
        const activated = this.activated;
        var _loadedDataSource = this.loadedDataSource;
        const layer = _loadedDataSource.layer,
              transform = _loadedDataSource.transform;

        return activated.registerDisposer(getWatchableRenderLayerTransform(layer.manager.root.coordinateSpace, layer.localPosition.coordinateSpace, transform, this, channelCoordinateSpace));
    }
}
export class LoadedLayerDataSource extends RefCounted {
    constructor(layerDataSource, dataSource, spec) {
        super();
        this.layerDataSource = layerDataSource;
        this.dataSource = dataSource;
        this.error = undefined;
        this.enabledSubsourcesChanged = new NullarySignal();
        this.activatedSubsourcesChanged = new NullarySignal();
        this.messages = new MessageList();
        if (dataSource.canChangeModelSpaceRank) {
            this.transform = new WatchableCoordinateSpaceTransform(makeIdentityTransform(makeCoordinateSpace({ rank: 0, scales: new Float64Array(0), units: [], names: [] })), true);
            this.transform.value = dataSource.modelTransform;
        } else {
            this.transform = new WatchableCoordinateSpaceTransform(dataSource.modelTransform);
        }
        if (spec.transform !== undefined) {
            this.transform.spec = spec.transform;
        }
        const subsourceSpecs = spec.subsources;
        this.enableDefaultSubsources = spec.enableDefaultSubsources;
        this.subsources = dataSource.subsources.map((subsourceEntry, subsourceIndex) => new LoadedDataSubsource(this, subsourceEntry, subsourceSpecs.get(subsourceEntry.id), subsourceIndex, this.enableDefaultSubsources));
    }
    get enabledSubsources() {
        return this.subsources.filter(x => x.enabled);
    }
    get layer() {
        return this.layerDataSource.layer;
    }
    disposed() {
        for (const subsource of this.subsources) {
            const activated = subsource.activated;

            if (activated !== undefined) {
                subsource.activated = undefined;
                activated.dispose();
            }
        }
    }
}
export class LayerDataSource extends RefCounted {
    constructor(layer, spec = undefined) {
        super();
        this.layer = layer;
        this.changed = new NullarySignal();
        this.messages = new MessageList();
        this.loadState_ = undefined;
        this.specGeneration = -1;
        this.refCounted_ = undefined;
        this.registerDisposer(this.changed.add(layer.dataSourcesChanged.dispatch));
        if (spec === undefined) {
            this.spec_ = makeEmptyDataSourceSpecification();
        } else {
            this.spec = spec;
        }
    }
    get spec() {
        const loadState = this.loadState;

        if (loadState !== undefined && loadState.error === undefined) {
            const generation = this.changed.count;
            if (generation !== this.specGeneration) {
                this.specGeneration = generation;
                this.spec_ = {
                    url: this.spec.url,
                    transform: loadState.transform.spec,
                    enableDefaultSubsources: loadState.enableDefaultSubsources,
                    subsources: new _Map(_Array$from(loadState.subsources, loadedSubsource => {
                        const defaultEnabledValue = loadState.enableDefaultSubsources && loadedSubsource.subsourceEntry.default;
                        return [loadedSubsource.subsourceEntry.id, {
                            enabled: loadedSubsource.enabled !== defaultEnabledValue ? loadedSubsource.enabled : undefined
                        }];
                    }))
                };
            }
        }
        return this.spec_;
    }
    get loadState() {
        return this.loadState_;
    }
    set spec(spec) {
        const layer = this.layer;

        this.messages.clearMessages();
        if (spec.url.length === 0) {
            if (layer.dataSources.length !== 1) {
                const index = layer.dataSources.indexOf(this);
                if (index !== -1) {
                    layer.dataSources.splice(index, 1);
                    layer.dataSourcesChanged.dispatch();
                    this.dispose();
                    return;
                }
            }
            this.spec_ = spec;
            if (this.refCounted_ !== undefined) {
                this.refCounted_.dispose();
                this.refCounted_ = undefined;
                this.loadState_ = undefined;
                this.changed.dispatch();
            }
            return;
        }
        const refCounted = new RefCounted();
        const retainer = refCounted.registerDisposer(disposableOnce(layer.markLoading()));
        if (this.refCounted_ !== undefined) {
            this.refCounted_.dispose();
            this.loadState_ = undefined;
        }
        this.refCounted_ = refCounted;
        this.spec_ = spec;
        const chunkManager = layer.manager.chunkManager;
        const registry = layer.manager.dataSourceProviderRegistry;
        const cancellationToken = new CancellationTokenSource();
        this.messages.addMessage({ severity: MessageSeverity.info, message: 'Loading data source' });
        registry.get({
            chunkManager,
            url: spec.url,
            cancellationToken,
            globalCoordinateSpace: layer.manager.root.coordinateSpace,
            transform: spec.transform
        }).then(source => {
            if (refCounted.wasDisposed) return;
            this.messages.clearMessages();
            const loaded = refCounted.registerDisposer(new LoadedLayerDataSource(this, source, spec));
            loaded.registerDisposer(layer.addCoordinateSpace(loaded.transform.outputSpace));
            loaded.registerDisposer(loaded.transform.changed.add(this.changed.dispatch));
            this.loadState_ = loaded;
            loaded.registerDisposer(loaded.enabledSubsourcesChanged.add(this.changed.dispatch));
            this.changed.dispatch();
            retainer();
        }).catch(error => {
            if (this.wasDisposed) return;
            this.loadState_ = { error };
            this.messages.clearMessages();
            this.messages.addMessage({ severity: MessageSeverity.error, message: error.message });
            this.changed.dispatch();
        });
        refCounted.registerDisposer(() => {
            cancellationToken.cancel();
        });
        this.changed.dispatch();
    }
    disposed() {
        const refCounted = this.refCounted_;
        if (refCounted !== undefined) {
            refCounted.dispose();
        }
    }
    toJSON() {
        const loadState = this.loadState;

        if (loadState === undefined || loadState.error !== undefined) {
            return layerDataSourceSpecificationToJson(this.spec);
        }
        return layerDataSourceSpecificationToJson({
            url: this.spec.url,
            transform: loadState.transform.spec,
            enableDefaultSubsources: loadState.enableDefaultSubsources,
            subsources: new _Map(_Array$from(loadState.subsources, loadedSubsource => {
                const defaultEnabledValue = loadState.enableDefaultSubsources && loadedSubsource.subsourceEntry.default;
                return [loadedSubsource.subsourceEntry.id, {
                    enabled: loadedSubsource.enabled !== defaultEnabledValue ? loadedSubsource.enabled : undefined
                }];
            }))
        });
    }
}
//# sourceMappingURL=layer_data_source.js.map