import _Array$from from 'babel-runtime/core-js/array/from';
import _Number$isInteger from 'babel-runtime/core-js/number/is-integer';
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { emptyValidCoordinateSpace, homogeneousTransformSubmatrix } from './coordinate_transform';
import { constantWatchableValue, makeCachedDerivedWatchableValue } from './trackable_value';
import { arraysEqual, scatterUpdate } from './util/array';
import { mat4 } from './util/geom';
import { getDependentTransformInputDimensions } from './util/geom';
import * as matrix from './util/matrix';
import * as vector from './util/vector';
import { prod } from './util/vector';
export const zeroRankChannelSpace = {
    channelCoordinateSpace: emptyValidCoordinateSpace,
    shape: new Uint32Array(0),
    numChannels: 1,
    coordinates: new Uint32Array(0)
};
export function getChannelSpace(channelCoordinateSpace) {
    const rank = channelCoordinateSpace.rank;
    var _channelCoordinateSpa = channelCoordinateSpace.bounds;
    const lowerBounds = _channelCoordinateSpa.lowerBounds,
          upperBounds = _channelCoordinateSpa.upperBounds;

    if (lowerBounds.some(x => x !== 0)) {
        throw new Error('Lower bounds of channel coordinate space must all be 0');
    }
    if (upperBounds.some(x => !_Number$isInteger(x) || x <= 0 || x >= 2 ** 32)) {
        throw new Error('Upper bounds of channel coordinate space must all be positive integers');
    }
    const shape = new Uint32Array(upperBounds);
    const numChannels = prod(shape);
    const coordinates = new Uint32Array(numChannels * rank);
    for (let flatIndex = 0; flatIndex < numChannels; ++flatIndex) {
        let remainder = flatIndex;
        for (let dim = 0; dim < rank; ++dim) {
            const coordinate = remainder % shape[dim];
            remainder = (remainder - coordinate) / shape[dim];
            coordinates[flatIndex * rank + dim] = coordinate;
        }
    }
    return { channelCoordinateSpace, shape, numChannels, coordinates };
}
function scaleTransformSubmatrix(transform, rank, baseInputSpace, inputToBaseDimensions, baseOutputSpace, baseToOutputDimensions) {
    const baseInputScales = baseInputSpace.scales;
    const baseOutputScales = baseOutputSpace.scales,
          baseOutputRank = baseOutputSpace.rank;

    const stride = rank + 1;
    for (let baseOutputDim = 0; baseOutputDim < baseOutputRank; ++baseOutputDim) {
        const outputDim = baseToOutputDimensions[baseOutputDim];
        if (outputDim === -1) continue;
        const baseOutputScale = baseOutputScales[baseOutputDim];
        for (let inputDim = 0; inputDim < rank; ++inputDim) {
            const baseInputDim = inputToBaseDimensions[inputDim];
            const baseInputScale = baseInputScales[baseInputDim];
            transform[stride * inputDim + outputDim] *= baseInputScale / baseOutputScale;
        }
    }
}
export function getRenderLayerTransform(globalCoordinateSpace, localCoordinateSpace, modelToLayerTransform, subsourceEntry, channelCoordinateSpace = emptyValidCoordinateSpace) {
    const modelSpace = modelToLayerTransform.inputSpace,
          fullRank = modelToLayerTransform.rank,
          sourceRank = modelToLayerTransform.sourceRank,
          layerSpace = modelToLayerTransform.outputSpace,
          oldTransform = modelToLayerTransform.transform;
    const modelDimensionNames = modelSpace.names;
    const transformOutputDimensions = layerSpace.names;

    let requiredInputDims;
    if (subsourceEntry !== undefined) {
        requiredInputDims = _Array$from(subsourceEntry.modelSubspaceDimensionIndices);
    } else {
        requiredInputDims = [];
        for (let i = 0; i < sourceRank; ++i) {
            requiredInputDims[i] = i;
        }
    }
    const unpaddedRank = requiredInputDims.length;
    for (let i = sourceRank; i < fullRank; ++i) {
        requiredInputDims.push(i);
    }
    const requiredOutputDims = getDependentTransformInputDimensions(modelToLayerTransform.transform, fullRank, requiredInputDims, true);
    const subspaceRank = requiredInputDims.length;
    const modelSubspaceDimensionNames = requiredInputDims.map(i => modelDimensionNames[i] || `${i}`);
    const layerSubspaceDimensionNames = requiredOutputDims.map(i => transformOutputDimensions[i]);
    if (subspaceRank !== requiredOutputDims.length) {
        return {
            error: 'Rank mismatch between model subspace dimensions (' + modelSubspaceDimensionNames.join(', ') + ') and corresponding layer/global dimensions (' + layerSubspaceDimensionNames.join(', ') + ')'
        };
    }
    let newTransform = homogeneousTransformSubmatrix(Float32Array, oldTransform, fullRank, requiredOutputDims, requiredInputDims);
    const renderLayerDimensions = requiredOutputDims.map(i => transformOutputDimensions[i]);
    const localToRenderLayerDimensions = localCoordinateSpace.names.map(x => renderLayerDimensions.indexOf(x));
    const globalToRenderLayerDimensions = globalCoordinateSpace.names.map(x => renderLayerDimensions.indexOf(x));
    scaleTransformSubmatrix(newTransform, subspaceRank, modelSpace, requiredInputDims, globalCoordinateSpace, globalToRenderLayerDimensions);
    scaleTransformSubmatrix(newTransform, subspaceRank, modelSpace, requiredInputDims, localCoordinateSpace, localToRenderLayerDimensions);
    const channelToRenderLayerDimensions = channelCoordinateSpace.names.map(x => renderLayerDimensions.indexOf(x));
    scaleTransformSubmatrix(newTransform, subspaceRank, modelSpace, requiredInputDims, channelCoordinateSpace, channelToRenderLayerDimensions);
    const channelToModelSubspaceDimensions = [];
    const channelRank = channelCoordinateSpace.rank;
    if (subsourceEntry !== undefined) {
        let subsourceToModelSubspaceTransform = subsourceEntry.subsourceToModelSubspaceTransform;

        if (unpaddedRank !== subspaceRank) {
            subsourceToModelSubspaceTransform = matrix.extendHomogeneousTransform(new Float32Array((subspaceRank + 1) ** 2), subspaceRank, subsourceToModelSubspaceTransform, unpaddedRank);
        }
        newTransform = matrix.multiply(new Float32Array((subspaceRank + 1) ** 2), subspaceRank + 1, newTransform, subspaceRank + 1, subsourceToModelSubspaceTransform, subspaceRank + 1, subspaceRank + 1, subspaceRank + 1, subspaceRank + 1);
    }
    const channelSpaceShape = new Uint32Array(channelRank);
    for (let channelDim = 0; channelDim < channelRank; ++channelDim) {
        const lower = channelCoordinateSpace.bounds.lowerBounds[channelDim];
        const upper = channelCoordinateSpace.bounds.upperBounds[channelDim];
        if (lower !== 0 || !_Number$isInteger(upper) || upper <= 0 || upper >= 2 ** 32) {
            return {
                error: `Channel dimension ${channelCoordinateSpace.names[channelDim]} must have ` + `lower bound of 0 and positive integer upper bound`
            };
        }
        channelSpaceShape[channelDim] = upper;
        const layerDim = channelToRenderLayerDimensions[channelDim];
        let correspondingModelSubspaceDim = -1;
        if (layerDim !== -1) {
            for (let chunkDim = 0; chunkDim < subspaceRank; ++chunkDim) {
                const coeff = newTransform[layerDim + chunkDim * (subspaceRank + 1)];
                if (coeff === 0) continue;
                if (coeff !== 1 || correspondingModelSubspaceDim !== -1) {
                    return {
                        error: `Channel dimension ${layerSubspaceDimensionNames[layerDim]} ` + `must map to a single source dimension`
                    };
                }
                correspondingModelSubspaceDim = chunkDim;
            }
        }
        channelToModelSubspaceDimensions[channelDim] = correspondingModelSubspaceDim;
    }
    return {
        rank: subspaceRank,
        unpaddedRank,
        modelDimensionNames: modelSubspaceDimensionNames,
        layerDimensionNames: layerSubspaceDimensionNames,
        localToRenderLayerDimensions,
        globalToRenderLayerDimensions,
        channelToRenderLayerDimensions,
        modelToRenderLayerTransform: newTransform,
        channelToModelDimensions: channelToModelSubspaceDimensions,
        channelSpaceShape
    };
}
export function renderLayerTransformsEqual(a, b) {
    if (a === b) return true;
    if (a.error !== undefined || b.error !== undefined) return false;
    return arraysEqual(a.modelDimensionNames, b.modelDimensionNames) && arraysEqual(a.layerDimensionNames, b.layerDimensionNames) && arraysEqual(a.globalToRenderLayerDimensions, b.globalToRenderLayerDimensions) && arraysEqual(a.localToRenderLayerDimensions, b.localToRenderLayerDimensions) && arraysEqual(a.channelToRenderLayerDimensions, b.channelToRenderLayerDimensions) && arraysEqual(a.modelToRenderLayerTransform, b.modelToRenderLayerTransform) && arraysEqual(a.channelSpaceShape, b.channelSpaceShape);
}
export function getWatchableRenderLayerTransform(globalCoordinateSpace, localCoordinateSpace, modelToLayerTransform, subsourceEntry, channelCoordinateSpace) {
    return makeCachedDerivedWatchableValue((globalCoordinateSpace, localCoordinateSpace, modelToLayerTransform, channelCoordinateSpace) => getRenderLayerTransform(globalCoordinateSpace, localCoordinateSpace, modelToLayerTransform, subsourceEntry, channelCoordinateSpace), [globalCoordinateSpace, localCoordinateSpace, modelToLayerTransform, channelCoordinateSpace === undefined ? constantWatchableValue(undefined) : channelCoordinateSpace], renderLayerTransformsEqual);
}
export function layerToDisplayCoordinates(displayPosition, layerPosition, modelTransform, displayDimensionIndices) {
    const globalToRenderLayerDimensions = modelTransform.globalToRenderLayerDimensions;

    for (let displayDim = 0; displayDim < 3; ++displayDim) {
        let v = 0;
        const globalDim = displayDimensionIndices[displayDim];
        if (globalDim !== -1) {
            const layerDim = globalToRenderLayerDimensions[globalDim];
            if (layerDim !== -1) {
                v = layerPosition[layerDim];
            }
        }
        displayPosition[displayDim] = v;
    }
}
export function displayToLayerCoordinates(layerPosition, displayPosition, modelTransform, displayDimensionIndices) {
    const globalToRenderLayerDimensions = modelTransform.globalToRenderLayerDimensions;

    for (let displayDim = 0; displayDim < 3; ++displayDim) {
        const globalDim = displayDimensionIndices[displayDim];
        if (globalDim !== -1) {
            const layerDim = globalToRenderLayerDimensions[globalDim];
            if (layerDim !== -1) {
                layerPosition[layerDim] = displayPosition[displayDim];
            }
        }
    }
}
export function chunkToDisplayCoordinates(displayPosition, chunkPosition, chunkTransform, displayDimensionIndices) {
    const globalToRenderLayerDimensions = chunkTransform.modelTransform.globalToRenderLayerDimensions;
    const layerRank = chunkTransform.layerRank,
          chunkToLayerTransform = chunkTransform.chunkToLayerTransform;

    const stride = layerRank + 1;
    for (let displayDim = 0; displayDim < 3; ++displayDim) {
        let sum = 0;
        const globalDim = displayDimensionIndices[displayDim];
        if (globalDim !== -1) {
            const layerDim = globalToRenderLayerDimensions[globalDim];
            if (layerDim !== -1) {
                sum = chunkToLayerTransform[stride * layerRank + layerDim];
                for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {
                    sum += chunkToLayerTransform[stride * chunkDim + layerDim] * chunkPosition[chunkDim];
                }
            }
        }
        displayPosition[displayDim] = sum;
    }
    return displayPosition;
}
export function getChunkTransformParameters(modelTransform, chunkToModelTransform) {
    const layerRank = modelTransform.rank;
    const unpaddedRank = modelTransform.unpaddedRank;
    let chunkToLayerTransform;
    if (unpaddedRank !== layerRank && chunkToModelTransform !== undefined) {
        chunkToModelTransform = matrix.extendHomogeneousTransform(new Float32Array((layerRank + 1) ** 2), layerRank, chunkToModelTransform, unpaddedRank);
    }
    if (chunkToModelTransform !== undefined) {
        chunkToLayerTransform = new Float32Array((layerRank + 1) * (layerRank + 1));
        matrix.multiply(chunkToLayerTransform, layerRank + 1, modelTransform.modelToRenderLayerTransform, layerRank + 1, chunkToModelTransform, layerRank + 1, layerRank + 1, layerRank + 1, layerRank + 1);
    } else {
        chunkToLayerTransform = modelTransform.modelToRenderLayerTransform;
    }
    const layerToChunkTransform = new Float32Array((layerRank + 1) * (layerRank + 1));
    const det = matrix.inverse(layerToChunkTransform, layerRank + 1, chunkToLayerTransform, layerRank + 1, layerRank + 1);
    if (det === 0) {
        throw new Error(`Transform is singular`);
    }
    const globalToRenderLayerDimensions = modelTransform.globalToRenderLayerDimensions,
          localToRenderLayerDimensions = modelTransform.localToRenderLayerDimensions,
          channelToRenderLayerDimensions = modelTransform.channelToRenderLayerDimensions;

    const globalRank = globalToRenderLayerDimensions.length;
    const localRank = localToRenderLayerDimensions.length;
    const combinedGlobalLocalRank = globalRank + localRank;
    // Compute `combinedGlobalLocalToChunkTransform`.
    const combinedGlobalLocalToChunkTransform = new Float32Array((combinedGlobalLocalRank + 1) * layerRank);
    for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {
        for (let globalDim = 0; globalDim < globalRank; ++globalDim) {
            const layerDim = globalToRenderLayerDimensions[globalDim];
            if (layerDim === -1) continue;
            combinedGlobalLocalToChunkTransform[chunkDim + globalDim * layerRank] = layerToChunkTransform[chunkDim + layerDim * (layerRank + 1)];
        }
        for (let localDim = 0; localDim < localRank; ++localDim) {
            const layerDim = localToRenderLayerDimensions[localDim];
            if (layerDim === -1) continue;
            combinedGlobalLocalToChunkTransform[chunkDim + (globalRank + localDim) * layerRank] = layerToChunkTransform[chunkDim + layerDim * (layerRank + 1)];
        }
        combinedGlobalLocalToChunkTransform[chunkDim + combinedGlobalLocalRank * layerRank] = layerToChunkTransform[chunkDim + layerRank * (layerRank + 1)];
    }
    const channelRank = channelToRenderLayerDimensions.length;
    let channelToChunkDimensionIndices = new Array(channelRank);
    const chunkChannelDimensionIndices = [];
    for (let channelDim = 0; channelDim < channelRank; ++channelDim) {
        const layerDim = channelToRenderLayerDimensions[channelDim];
        let correspondingChunkDim = -1;
        if (layerDim !== -1) {
            for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {
                const coeff = chunkToLayerTransform[layerDim + chunkDim * (layerRank + 1)];
                if (coeff === 0) continue;
                if (coeff !== 1 || correspondingChunkDim !== -1) {
                    throw new Error(`Channel dimension ${modelTransform.layerDimensionNames[layerDim]} ` + `must map with stride 1 to a single data chunk dimensions`);
                }
                correspondingChunkDim = chunkDim;
            }
            if (correspondingChunkDim !== -1) {
                if (chunkToLayerTransform[layerDim + layerRank * (layerRank + 1)] !== 0) {
                    throw new Error(`Channel dimension ${modelTransform.layerDimensionNames[layerDim]} ` + `must have an offset of 0 in the chunk coordinate space`);
                }
                chunkChannelDimensionIndices.push(correspondingChunkDim);
            }
        }
        channelToChunkDimensionIndices[channelDim] = correspondingChunkDim;
    }
    const channelSpaceShape = modelTransform.channelSpaceShape;

    const numChannels = vector.prod(channelSpaceShape);
    const chunkChannelRank = chunkChannelDimensionIndices.length;
    const chunkChannelCoordinates = new Uint32Array(numChannels * chunkChannelRank);
    for (let channelIndex = 0; channelIndex < numChannels; ++channelIndex) {
        let remainder = channelIndex;
        let chunkChannelDim = 0;
        for (let channelDim = 0; channelDim < channelRank; ++channelDim) {
            const coordinate = remainder % channelSpaceShape[channelDim];
            remainder = (remainder - coordinate) / channelSpaceShape[channelDim];
            const chunkDim = channelToChunkDimensionIndices[channelDim];
            if (chunkDim !== -1) {
                chunkChannelCoordinates[channelIndex * chunkChannelRank + chunkChannelDim] = coordinate;
                ++chunkChannelDim;
            }
        }
    }
    return {
        layerRank: layerRank,
        modelTransform,
        chunkToLayerTransform,
        layerToChunkTransform,
        chunkToLayerTransformDet: det,
        combinedGlobalLocalRank,
        combinedGlobalLocalToChunkTransform,
        channelToChunkDimensionIndices,
        chunkChannelDimensionIndices,
        numChannels,
        chunkChannelCoordinates,
        channelSpaceShape
    };
}
export function getLayerDisplayDimensionMapping(transform, displayDimensionIndices) {
    const globalToRenderLayerDimensions = transform.globalToRenderLayerDimensions;
    // List of layer dimension indices corresponding to global display dimensions.

    const layerDisplayDimensionIndices = [];
    // Maps global display dimension (in {0, 1, 2}) to the corresponding layer dimension index, or
    // `-1`.
    const displayToLayerDimensionIndices = [];
    for (let displayDim = 0; displayDim < 3; ++displayDim) {
        const globalDim = displayDimensionIndices[displayDim];
        if (globalDim == -1) continue;
        const layerDim = globalToRenderLayerDimensions[globalDim];
        displayToLayerDimensionIndices.push(layerDim);
        if (layerDim === -1) continue;
        layerDisplayDimensionIndices.push(layerDim);
    }
    for (let i = displayToLayerDimensionIndices.length; i < 3; ++i) {
        displayToLayerDimensionIndices[i] = -1;
    }
    return { layerDisplayDimensionIndices, displayToLayerDimensionIndices };
}
export function getChunkDisplayTransformParameters(chunkTransform, layerDisplayDimensionMapping) {
    const chunkToLayerTransform = chunkTransform.chunkToLayerTransform,
          modelTransform = chunkTransform.modelTransform;

    const rank = modelTransform.rank;
    const layerDisplayDimensionIndices = layerDisplayDimensionMapping.layerDisplayDimensionIndices,
          displayToLayerDimensionIndices = layerDisplayDimensionMapping.displayToLayerDimensionIndices;

    const numLayerDisplayDims = layerDisplayDimensionIndices.length;
    const chunkDisplayDimensionIndices = getDependentTransformInputDimensions(chunkToLayerTransform, rank, layerDisplayDimensionIndices);
    if (chunkDisplayDimensionIndices.length !== numLayerDisplayDims) {
        const modelDimensionNames = modelTransform.modelDimensionNames,
              layerDimensionNames = modelTransform.layerDimensionNames;

        throw new Error(`Rank mismatch between displayed layer dimensions ` + `(${_Array$from(layerDisplayDimensionIndices, i => layerDimensionNames[i]).join(',\u00a0')}) ` + `and corresponding chunk dimensions ` + `(${_Array$from(chunkDisplayDimensionIndices, i => modelDimensionNames[i]).join(',\u00a0')})`);
    }
    // Compute "model matrix" (transform from the displayed subspace of the chunk space) to the global
    // display coordinate space.
    const displaySubspaceModelMatrix = mat4.create();
    for (let displayDim = 0; displayDim < 3; ++displayDim) {
        const layerDim = displayToLayerDimensionIndices[displayDim];
        if (layerDim === -1) continue;
        for (let chunkDisplayDimIndex = 0; chunkDisplayDimIndex < numLayerDisplayDims; ++chunkDisplayDimIndex) {
            const chunkDim = chunkDisplayDimensionIndices[chunkDisplayDimIndex];
            displaySubspaceModelMatrix[chunkDisplayDimIndex * 4 + displayDim] = chunkToLayerTransform[chunkDim * (rank + 1) + layerDim];
        }
        displaySubspaceModelMatrix[12 + displayDim] = chunkToLayerTransform[rank * (rank + 1) + layerDim];
    }
    const displaySubspaceInvModelMatrix = mat4.create();
    mat4.invert(displaySubspaceInvModelMatrix, displaySubspaceModelMatrix);
    for (let i = chunkDisplayDimensionIndices.length; i < 3; ++i) {
        chunkDisplayDimensionIndices[i] = -1;
    }
    return {
        modelTransform: chunkTransform.modelTransform,
        chunkTransform,
        displaySubspaceModelMatrix,
        displaySubspaceInvModelMatrix,
        chunkDisplayDimensionIndices,
        numChunkDisplayDims: numLayerDisplayDims
    };
}
export function getChunkPositionFromCombinedGlobalLocalPositions(chunkPosition, globalPosition, localPosition, layerRank, combinedGlobalLocalToChunkTransform) {
    const globalRank = globalPosition.length;
    const localRank = localPosition.length;
    const rank = chunkPosition.length;
    let valid = true;
    for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {
        let off = chunkDim;
        let sum = 0;
        for (let globalDim = 0; globalDim < globalRank; ++globalDim) {
            sum += combinedGlobalLocalToChunkTransform[off + globalDim * layerRank] * globalPosition[globalDim];
        }
        off += globalRank * layerRank;
        for (let localDim = 0; localDim < localRank; ++localDim) {
            sum += combinedGlobalLocalToChunkTransform[off + localDim * layerRank] * localPosition[localDim];
        }
        sum += combinedGlobalLocalToChunkTransform[off + localRank * layerRank];
        if (chunkDim < rank) {
            chunkPosition[chunkDim] = sum;
        } else {
            // Handle clipping
            if (sum < 0 || sum >= 1) {
                valid = false;
            }
        }
    }
    return valid;
}
export function getLayerPositionFromCombinedGlobalLocalPositions(layerPosition, globalPosition, localPosition, modelTransform) {
    scatterUpdate(layerPosition, globalPosition, modelTransform.globalToRenderLayerDimensions);
    scatterUpdate(layerPosition, localPosition, modelTransform.localToRenderLayerDimensions);
    return layerPosition;
}
export function get3dModelToDisplaySpaceMatrix(out, displayDimensionRenderInfo, transform) {
    out.fill(0);
    out[15] = 1;
    let fullRank = true;
    const displayDimensionIndices = displayDimensionRenderInfo.displayDimensionIndices;
    const globalToRenderLayerDimensions = transform.globalToRenderLayerDimensions,
          modelToRenderLayerTransform = transform.modelToRenderLayerTransform;

    const layerRank = transform.rank;
    for (let displayDim = 0; displayDim < 3; ++displayDim) {
        const globalDim = displayDimensionIndices[displayDim];
        if (globalDim === -1) {
            fullRank = false;
            continue;
        }
        const layerDim = globalToRenderLayerDimensions[globalDim];
        if (layerDim === -1) {
            fullRank = false;
            continue;
        }
        out[displayDim + 12] = modelToRenderLayerTransform[layerDim + layerRank * (layerRank + 1)];
        for (let modelDim = 0; modelDim < 3; ++modelDim) {
            out[displayDim + 4 * modelDim] = modelToRenderLayerTransform[layerDim + (layerRank + 1) * modelDim];
        }
    }
    if (!fullRank) {
        const globalDimensionNames = displayDimensionRenderInfo.globalDimensionNames;

        const displayDimDesc = _Array$from(displayDimensionIndices.filter(i => i !== -1), i => globalDimensionNames[i]).join(',\u00a0');
        throw new Error(`Transform from model dimensions (${transform.modelDimensionNames.join(',\u00a0')}) ` + `to display dimensions (${displayDimDesc}) does not have full rank`);
    }
}
//# sourceMappingURL=render_coordinate_transform.js.map