import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import { withChunkManager } from "../chunk_manager/backend";
import { ChunkState } from "../chunk_manager/base";
import { RenderLayerBackend } from "../render_layer_backend";
import { BASE_PRIORITY, deserializeTransformedSources, SCALE_PRIORITY_MULTIPLIER } from "../sliceview/backend";
import { vec3 } from "../util/geom";
import { getBasePriority, getPriorityTier } from "../visibility_priority/backend";
import { forEachVisibleVolumeRenderingChunk, VOLUME_RENDERING_RENDER_LAYER_RPC_ID, VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID } from "./base";
import { registerRPC, registerSharedObject } from "../worker_rpc";
const tempChunkPosition = vec3.create();
const tempCenter = vec3.create();
const tempChunkSize = vec3.create();
const tempCenterDataPosition = vec3.create();
let VolumeRenderingRenderLayerBackend = class VolumeRenderingRenderLayerBackend extends withChunkManager(RenderLayerBackend) {
    constructor(rpc, options) {
        super(rpc, options);
        this.renderScaleTarget = rpc.get(options.renderScaleTarget);
        this.localPosition = rpc.get(options.localPosition);
        const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
        this.registerDisposer(this.localPosition.changed.add(scheduleUpdateChunkPriorities));
        this.registerDisposer(this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities));
        this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => this.recomputeChunkPriorities()));
    }
    attach(attachment) {
        const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
        const view = attachment.view;

        attachment.registerDisposer(scheduleUpdateChunkPriorities);
        attachment.registerDisposer(view.projectionParameters.changed.add(scheduleUpdateChunkPriorities));
        attachment.registerDisposer(view.visibility.changed.add(scheduleUpdateChunkPriorities));
        attachment.state = {
            displayDimensionRenderInfo: view.projectionParameters.value.displayDimensionRenderInfo,
            transformedSources: []
        };
    }
    recomputeChunkPriorities() {
        for (const attachment of this.attachments.values()) {
            const view = attachment.view;

            const visibility = view.visibility.value;
            if (visibility === Number.NEGATIVE_INFINITY) {
                continue;
            }
            var _attachment$state = attachment.state;
            const transformedSources = _attachment$state.transformedSources,
                  displayDimensionRenderInfo = _attachment$state.displayDimensionRenderInfo;

            if (transformedSources.length === 0 || displayDimensionRenderInfo !== view.projectionParameters.value.displayDimensionRenderInfo) {
                continue;
            }
            const projectionParameters = view.projectionParameters.value;
            const priorityTier = getPriorityTier(visibility);
            let basePriority = getBasePriority(visibility);
            basePriority += BASE_PRIORITY;
            const localCenter = tempCenter;
            const chunkSize = tempChunkSize;
            const centerDataPosition = tempCenterDataPosition;
            const globalPosition = projectionParameters.globalPosition,
                  displayDimensionIndices = projectionParameters.displayDimensionRenderInfo.displayDimensionIndices;

            for (let displayDim = 0; displayDim < 3; ++displayDim) {
                const globalDim = displayDimensionIndices[displayDim];
                centerDataPosition[displayDim] = globalDim === -1 ? 0 : globalPosition[globalDim];
            }
            let sourceBasePriority;
            const chunkManager = this.chunkManager;

            chunkManager.registerLayer(this);
            forEachVisibleVolumeRenderingChunk(projectionParameters, this.localPosition.value, this.renderScaleTarget.value, transformedSources[0], (tsource, scaleIndex) => {
                const chunkLayout = tsource.chunkLayout;

                for (let i = 0; i < 3; ++i) {}
                chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);
                const size = chunkLayout.size,
                      finiteRank = chunkLayout.finiteRank;

                vec3.copy(chunkSize, size);
                for (let i = finiteRank; i < 3; ++i) {
                    chunkSize[i] = 0;
                    localCenter[i] = 0;
                }
                const priorityIndex = transformedSources[0].length - 1 - scaleIndex;
                sourceBasePriority = basePriority + SCALE_PRIORITY_MULTIPLIER * priorityIndex;
            }, (tsource, _, positionInChunks) => {
                vec3.multiply(tempChunkPosition, positionInChunks, chunkSize);
                const priority = -vec3.distance(localCenter, tempChunkPosition);
                const chunk = tsource.source.getChunk(tsource.curPositionInChunks);
                ++this.numVisibleChunksNeeded;
                chunkManager.requestChunk(chunk, priorityTier, sourceBasePriority + priority);
                if (chunk.state === ChunkState.GPU_MEMORY) {
                    ++this.numVisibleChunksAvailable;
                }
            });
        }
    }
};
VolumeRenderingRenderLayerBackend = __decorate([registerSharedObject(VOLUME_RENDERING_RENDER_LAYER_RPC_ID)], VolumeRenderingRenderLayerBackend);
VolumeRenderingRenderLayerBackend;
registerRPC(VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, function (x) {
    const view = this.get(x.view);
    const layer = this.get(x.layer);
    const attachment = layer.attachments.get(view);
    attachment.state.transformedSources = deserializeTransformedSources(this, x.sources, layer);
    attachment.state.displayDimensionRenderInfo = attachment.view.projectionParameters.value.displayDimensionRenderInfo;
    layer.chunkManager.scheduleUpdateChunkPriorities();
});
//# sourceMappingURL=backend.js.map