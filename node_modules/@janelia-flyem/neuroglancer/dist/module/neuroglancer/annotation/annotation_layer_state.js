/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { getChunkTransformParameters } from '../render_coordinate_transform';
import { RenderLayerRole } from '../renderlayer';
import { TrackableBoolean } from '../trackable_boolean';
import { makeCachedLazyDerivedWatchableValue, registerNested, WatchableValue } from '../trackable_value';
import { TrackableRGB } from '../util/color';
import { RefCounted } from '../util/disposable';
import { makeValueOrError, valueOrThrow } from '../util/error';
import { vec3 } from '../util/geom';
import { WatchableMap } from '../util/watchable_map';
import { makeTrackableFragmentMain, makeWatchableShaderError } from '../webgl/dynamic_shader';
import { getFallbackBuilderState, parseShaderUiControls, ShaderControlState } from '../webgl/shader_ui_controls';
export class AnnotationHoverState extends WatchableValue {}
export class WatchableAnnotationRelationshipStates extends WatchableMap {
    constructor() {
        super((context, { showMatches, segmentationState }) => {
            context.registerDisposer(showMatches.changed.add(this.changed.dispatch));
            context.registerDisposer(segmentationState.changed.add(this.changed.dispatch));
            context.registerDisposer(registerNested((nestedContext, segmentationState) => {
                if (segmentationState == null) return;
                const segmentationGroupState = segmentationState.segmentationGroupState;

                nestedContext.registerDisposer(segmentationGroupState.changed.add(this.changed.dispatch));
                nestedContext.registerDisposer(registerNested((groupContext, groupState) => {
                    const visibleSegments = groupState.visibleSegments;

                    let wasEmpty = visibleSegments.size === 0;
                    groupContext.registerDisposer(visibleSegments.changed.add(() => {
                        const isEmpty = visibleSegments.size === 0;
                        if (isEmpty !== wasEmpty) {
                            wasEmpty = isEmpty;
                            this.changed.dispatch();
                        }
                    }));
                }, segmentationGroupState));
            }, segmentationState));
        });
    }
    get(name) {
        let value = super.get(name);
        if (value === undefined) {
            value = {
                segmentationState: new WatchableValue(undefined),
                showMatches: new TrackableBoolean(false)
            };
            super.set(name, value);
        }
        return value;
    }
}
const DEFAULT_FRAGMENT_MAIN = `
void main() {
  setColor(defaultColor());
}
`;
export class AnnotationDisplayState extends RefCounted {
    constructor() {
        super(...arguments);
        this.shader = makeTrackableFragmentMain(DEFAULT_FRAGMENT_MAIN);
        this.shaderControls = new ShaderControlState(this.shader);
        this.fallbackShaderControls = new WatchableValue(getFallbackBuilderState(parseShaderUiControls(DEFAULT_FRAGMENT_MAIN)));
        this.shaderError = makeWatchableShaderError();
        this.color = new TrackableRGB(vec3.fromValues(1, 1, 0));
        this.relationshipStates = this.registerDisposer(new WatchableAnnotationRelationshipStates());
        this.ignoreNullSegmentFilter = new TrackableBoolean(true);
        this.displayUnfiltered = makeCachedLazyDerivedWatchableValue((map, ignoreNullSegmentFilter) => {
            for (const state of map.values()) {
                if (state.showMatches.value) {
                    if (!ignoreNullSegmentFilter) return false;
                    const segmentationState = state.segmentationState.value;
                    if (segmentationState != null) {
                        if (segmentationState.segmentationGroupState.value.visibleSegments.size > 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }, this.relationshipStates, this.ignoreNullSegmentFilter);
        this.hoverState = new AnnotationHoverState(undefined);
    }
}
export class AnnotationLayerState extends RefCounted {
    constructor(options) {
        super();
        const transform = options.transform,
              localPosition = options.localPosition,
              source = options.source;
        var _options$role = options.role;
        const role = _options$role === undefined ? RenderLayerRole.ANNOTATION : _options$role;

        this.transform = transform;
        this.localPosition = localPosition;
        this.source = this.registerDisposer(source);
        this.role = role;
        this.displayState = options.displayState;
        this.chunkTransform = this.registerDisposer(makeCachedLazyDerivedWatchableValue(modelTransform => makeValueOrError(() => getChunkTransformParameters(valueOrThrow(modelTransform))), this.transform));
        this.dataSource = options.dataSource;
        this.subsourceId = options.subsourceId;
        this.subsourceIndex = options.subsourceIndex;
    }
    get sourceIndex() {
        const dataSource = this.dataSource;

        return dataSource.layer.dataSources.indexOf(dataSource);
    }
}
//# sourceMappingURL=annotation_layer_state.js.map