import _Object$assign from "babel-runtime/core-js/object/assign";
import _Number$isFinite from "babel-runtime/core-js/number/is-finite";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import "./bounding_box";
import "./line";
import "./point";
import "./ellipsoid";
import "./sphere";
import { AnnotationSerializer, AnnotationSource, annotationTypes, formatAnnotationPropertyValue } from "./index";
import { ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, ANNOTATION_RENDER_LAYER_RPC_ID, ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID, ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID, forEachVisibleAnnotationChunk } from "./base";
import { computeNumPickIds, MultiscaleAnnotationSource } from "./frontend_source";
import { getAnnotationTypeRenderHandler } from "./type_handler";
import { ChunkState, LayerChunkProgressInfo } from "../chunk_manager/base";
import { ChunkRenderLayerFrontend } from "../chunk_manager/frontend";
import { PerspectiveViewRenderLayer } from "../perspective_view/render_layer";
import { getChunkDisplayTransformParameters, getChunkPositionFromCombinedGlobalLocalPositions, getLayerDisplayDimensionMapping } from "../render_coordinate_transform";
import { forEachVisibleSegment, getObjectKey } from "../segmentation_display_state/base";
import { sendVisibleSegmentsState } from "../segmentation_display_state/frontend";
import { SharedWatchableValue } from "../shared_watchable_value";
import { getVolumetricTransformedSources, serializeAllTransformedSources } from "../sliceview/frontend";
import { SliceViewPanelRenderLayer } from "../sliceview/renderlayer";
import { crossSectionBoxWireFrameShader, projectionViewBoxWireFrameShader } from "../sliceview/wire_frame";
import { constantWatchableValue, makeCachedDerivedWatchableValue, registerNested, registerNestedSync } from "../trackable_value";
import { arraysEqual } from "../util/array";
import { RefCounted } from "../util/disposable";
import { Endianness, ENDIANNESS } from "../util/endian";
import { mat4 } from "../util/geom";
import { MessageSeverity } from "../util/message_list";
import { NullarySignal } from "../util/signal";
import { withSharedVisibility } from "../visibility_priority/frontend";
import { Buffer } from "../webgl/buffer";
import { parameterizedEmitterDependentShaderGetter } from "../webgl/dynamic_shader";
import { registerSharedObjectOwner } from "../worker_rpc";
const tempMat = mat4.create();
function segmentationFilter(segmentationStates) {
    if (segmentationStates === undefined) return undefined;
    return annotation => {
        const relatedSegments = annotation.relatedSegments;

        if (relatedSegments === undefined) {
            return false;
        }
        for (let i = 0, count = relatedSegments.length; i < count; ++i) {
            const segmentationState = segmentationStates[i];
            if (segmentationState == null) continue;
            var _segmentationState$se = segmentationState.segmentationGroupState.value;
            const visibleSegments = _segmentationState$se.visibleSegments,
                  segmentEquivalences = _segmentationState$se.segmentEquivalences;

            for (const segment of relatedSegments[i]) {
                if (visibleSegments.has(segmentEquivalences.get(segment))) {
                    return true;
                }
            }
        }
        return false;
    };
}
function serializeAnnotationSet(annotationSet, filter) {
    const serializer = new AnnotationSerializer(annotationSet.annotationPropertySerializers);
    for (const annotation of annotationSet) {
        if (filter === undefined || filter(annotation)) {
            serializer.add(annotation);
        }
    }
    return serializer.serialize();
}
let AnnotationLayerSharedObject = class AnnotationLayerSharedObject extends withSharedVisibility(ChunkRenderLayerFrontend) {
    constructor(chunkManager, source, segmentationStates, chunkRenderLayer) {
        super(chunkRenderLayer);
        this.chunkManager = chunkManager;
        this.source = source;
        this.segmentationStates = segmentationStates;
        this.initializeCounterpart(this.chunkManager.rpc, {
            chunkManager: this.chunkManager.rpcId,
            source: source.rpcId,
            segmentationStates: this.serializeDisplayState()
        });
        const update = () => {
            const msg = { id: this.rpcId, segmentationStates: this.serializeDisplayState() };
            this.rpc.invoke(ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID, msg);
        };
        this.registerDisposer(segmentationStates.changed.add(update));
    }
    serializeDisplayState() {
        const segmentationStates = this.segmentationStates.value;

        if (segmentationStates === undefined) return undefined;
        return segmentationStates.map(segmentationState => {
            if (segmentationState == null) return segmentationState;
            return sendVisibleSegmentsState(segmentationState.segmentationGroupState.value);
        });
    }
};
AnnotationLayerSharedObject = __decorate([registerSharedObjectOwner(ANNOTATION_RENDER_LAYER_RPC_ID)], AnnotationLayerSharedObject);
export class AnnotationLayer extends RefCounted {
    constructor(chunkManager, state) {
        super();
        this.chunkManager = chunkManager;
        this.state = state;
        this.layerChunkProgressInfo = new LayerChunkProgressInfo();
        this.numPickIds = 0;
        /**
         * The value of this.state.annotationSet.changed.count when `buffer` was last updated.
         */
        this.generation = -1;
        this.redrawNeeded = new NullarySignal();
        this.serializedAnnotations = undefined;
        this.handleChangeAffectingBuffer = () => {
            this.generation = -1;
            this.redrawNeeded.dispatch();
        };
        this.segmentationStates = this.registerDisposer(makeCachedDerivedWatchableValue(_ => {
            var _state = this.state;
            const displayState = _state.displayState,
                  source = _state.source;
            const relationshipStates = displayState.relationshipStates;

            return displayState.displayUnfiltered.value ? undefined : source.relationships.map(relationship => {
                const state = relationshipStates.get(relationship);
                return state.showMatches.value ? state.segmentationState.value : undefined;
            });
        }, [this.state.displayState.relationshipStates], (a, b) => {
            if (a === undefined || b === undefined) {
                return a === b;
            }
            return arraysEqual(a, b);
        }));
        this.registerDisposer(state);
        this.registerDisposer(this.source.changed.add(this.handleChangeAffectingBuffer));
        this.registerDisposer(registerNested((context, segmentationStates) => {
            this.handleChangeAffectingBuffer();
            if (segmentationStates === undefined) return;
            for (const segmentationState of segmentationStates) {
                if (segmentationState == null) continue;
                context.registerDisposer(registerNestedSync((context, group) => {
                    context.registerDisposer(group.visibleSegments.changed.add(() => this.handleChangeAffectingBuffer()));
                    context.registerDisposer(group.segmentEquivalences.changed.add(() => this.handleChangeAffectingBuffer()));
                }, segmentationState.segmentationGroupState));
            }
        }, this.segmentationStates));
        if (!(this.source instanceof AnnotationSource)) {
            this.sharedObject = this.registerDisposer(new AnnotationLayerSharedObject(chunkManager, this.source, this.segmentationStates, this.layerChunkProgressInfo));
        }
        const displayState = this.state.displayState;

        this.registerDisposer(displayState.color.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(displayState.shader.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(displayState.shaderControls.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(this.hoverState.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(this.transform.changed.add(this.redrawNeeded.dispatch));
    }
    get source() {
        return this.state.source;
    }
    get transform() {
        return this.state.transform;
    }
    get hoverState() {
        return this.state.displayState.hoverState;
    }
    get visibility() {
        const sharedObject = this.sharedObject;

        if (sharedObject === undefined) {
            return undefined;
        }
        return sharedObject.visibility;
    }
    get gl() {
        return this.chunkManager.gl;
    }
    updateBuffer() {
        const source = this.source;

        if (source instanceof AnnotationSource) {
            const generation = source.changed.count;
            if (this.generation !== generation) {
                let buffer = this.buffer;

                if (buffer === undefined) {
                    buffer = this.buffer = this.registerDisposer(new Buffer(this.chunkManager.gl));
                }
                this.generation = generation;
                const serializedAnnotations = this.serializedAnnotations = serializeAnnotationSet(source, segmentationFilter(this.segmentationStates.value));
                buffer.setData(this.serializedAnnotations.data);
                this.numPickIds = computeNumPickIds(serializedAnnotations);
            }
        }
    }
}
function getAnnotationProjectionParameters(chunkDisplayTransform) {
    const chunkTransform = chunkDisplayTransform.chunkTransform;
    const unpaddedRank = chunkTransform.modelTransform.unpaddedRank;

    const modelClipBounds = new Float32Array(unpaddedRank * 2);
    const renderSubspaceTransform = new Float32Array(unpaddedRank * 3);
    renderSubspaceTransform.fill(0);
    modelClipBounds.fill(1, unpaddedRank);
    const numChunkDisplayDims = chunkDisplayTransform.numChunkDisplayDims,
          chunkDisplayDimensionIndices = chunkDisplayTransform.chunkDisplayDimensionIndices;

    for (let i = 0; i < numChunkDisplayDims; ++i) {
        const chunkDim = chunkDisplayDimensionIndices[i];
        modelClipBounds[unpaddedRank + chunkDim] = 0;
        renderSubspaceTransform[chunkDim * 3 + i] = 1;
    }
    return { modelClipBounds, renderSubspaceTransform };
}
function getChunkRenderParameters(chunkTransform, displayDimensionRenderInfo, messages) {
    messages.clearMessages();
    const returnError = message => {
        messages.addMessage({ severity: MessageSeverity.error, message });
        return undefined;
    };
    if (chunkTransform.error !== undefined) {
        return returnError(chunkTransform.error);
    }
    const layerRenderDimensionMapping = getLayerDisplayDimensionMapping(chunkTransform.modelTransform, displayDimensionRenderInfo.displayDimensionIndices);
    let chunkDisplayTransform;
    try {
        chunkDisplayTransform = getChunkDisplayTransformParameters(chunkTransform, layerRenderDimensionMapping);
    } catch (e) {
        return returnError(e.message);
    }

    var _getAnnotationProject = getAnnotationProjectionParameters(chunkDisplayTransform);

    const modelClipBounds = _getAnnotationProject.modelClipBounds,
          renderSubspaceTransform = _getAnnotationProject.renderSubspaceTransform;

    return { chunkTransform, chunkDisplayTransform, modelClipBounds, renderSubspaceTransform };
}
function AnnotationRenderLayer(Base, renderHelperType) {
    class C extends Base {
        constructor(base, renderScaleHistogram) {
            super();
            this.base = base;
            this.renderScaleHistogram = renderScaleHistogram;
            this.curRank = -1;
            this.renderHelpers = [];
            this.isAnnotation = true;
            const baseVisibility = base.visibility;
            if (baseVisibility !== undefined) {
                this.registerDisposer(baseVisibility.add(this.visibility));
            }
            this.registerDisposer(this.renderScaleHistogram.visibility.add(this.visibility));
            this.registerDisposer(() => {
                for (const helper of this.renderHelpers) {
                    helper.dispose();
                }
            });
            this.role = base.state.role;
            this.registerDisposer(base.redrawNeeded.add(this.redrawNeeded.dispatch));
            this.handleRankChanged();
        }
        handleRankChanged() {
            const rank = this.base.source.rank;

            if (rank === this.curRank) return;
            this.curRank = rank;
            this.tempChunkPosition = new Float32Array(rank);
            const renderHelpers = this.renderHelpers,
                  gl = this.gl;

            for (const oldHelper of renderHelpers) {
                oldHelper.dispose();
            }
            const properties = this.base.source.properties;
            const displayState = this.base.state.displayState;

            for (const annotationType of annotationTypes) {
                const handler = getAnnotationTypeRenderHandler(annotationType);
                const renderHelperConstructor = handler[renderHelperType];
                const helper = renderHelpers[annotationType] = new renderHelperConstructor(gl, annotationType, rank, properties, displayState.shaderControls, displayState.fallbackShaderControls, displayState.shaderError);
                helper.pickIdsPerInstance = handler.pickIdsPerInstance;
                helper.targetIsSliceView = renderHelperType === 'sliceViewRenderHelper';
            }
        }
        attach(attachment) {
            super.attach(attachment);
            this.handleRankChanged();
            const chunkTransform = this.chunkTransform;

            const displayDimensionRenderInfo = attachment.view.displayDimensionRenderInfo.value;
            attachment.state = {
                chunkTransform,
                displayDimensionRenderInfo,
                chunkRenderParameters: getChunkRenderParameters(chunkTransform, displayDimensionRenderInfo, attachment.messages)
            };
        }
        updateAttachmentState(attachment) {
            const state = attachment.state;
            this.handleRankChanged();
            const chunkTransform = this.chunkTransform;

            const displayDimensionRenderInfo = attachment.view.displayDimensionRenderInfo.value;
            if (state !== undefined && state.chunkTransform === chunkTransform && state.displayDimensionRenderInfo === displayDimensionRenderInfo) {
                return state.chunkRenderParameters;
            }
            state.chunkTransform = chunkTransform;
            state.displayDimensionRenderInfo = displayDimensionRenderInfo;
            const chunkRenderParameters = state.chunkRenderParameters = getChunkRenderParameters(chunkTransform, displayDimensionRenderInfo, attachment.messages);
            return chunkRenderParameters;
        }
        get chunkTransform() {
            return this.base.state.chunkTransform.value;
        }
        updateModelClipBounds(renderContext, state) {
            const modelClipBounds = state.modelClipBounds;

            const rank = this.curRank;
            const chunkTransform = state.chunkTransform;

            getChunkPositionFromCombinedGlobalLocalPositions(modelClipBounds.subarray(0, rank), renderContext.projectionParameters.globalPosition, this.base.state.localPosition.value, chunkTransform.layerRank, chunkTransform.combinedGlobalLocalToChunkTransform);
        }
        get gl() {
            return this.base.chunkManager.gl;
        }
        drawGeometryChunkData(chunk, renderContext, state, drawFraction = 1) {
            if (!chunk.bufferValid) {
                let buffer = chunk.buffer;

                if (buffer === undefined) {
                    buffer = chunk.buffer = new Buffer(this.gl);
                }
                const serializedAnnotations = chunk.serializedAnnotations;

                buffer.setData(serializedAnnotations.data);
                chunk.numPickIds = computeNumPickIds(serializedAnnotations);
                chunk.bufferValid = true;
            }
            this.drawGeometry(chunk, renderContext, state, drawFraction);
        }
        drawGeometry(chunk, renderContext, state, drawFraction = 1) {
            const base = this.base;
            const chunkDisplayTransform = state.chunkDisplayTransform;
            const serializedAnnotations = chunk.serializedAnnotations;
            const typeToIdMaps = serializedAnnotations.typeToIdMaps,
                  typeToOffset = serializedAnnotations.typeToOffset;

            let pickId = 0;
            if (renderContext.emitPickID) {
                pickId = renderContext.pickIDs.register(this, chunk.numPickIds, 0, 0, chunk);
            }
            const hoverValue = base.hoverState.value;
            const modelViewProjectionMatrix = mat4.multiply(tempMat, renderContext.projectionParameters.viewProjectionMat, chunkDisplayTransform.displaySubspaceModelMatrix);
            const context = {
                annotationLayer: base,
                renderContext,
                selectedIndex: 0,
                basePickId: pickId,
                buffer: chunk.buffer,
                bufferOffset: 0,
                count: 0,
                modelViewProjectionMatrix,
                modelClipBounds: state.modelClipBounds,
                subspaceMatrix: state.renderSubspaceTransform,
                renderSubspaceModelMatrix: chunkDisplayTransform.displaySubspaceModelMatrix,
                renderSubspaceInvModelMatrix: chunkDisplayTransform.displaySubspaceInvModelMatrix,
                chunkDisplayTransform
            };
            for (const annotationType of annotationTypes) {
                const idMap = typeToIdMaps[annotationType];
                let count = idMap.size;
                if (count > 0) {
                    const handler = getAnnotationTypeRenderHandler(annotationType);
                    let selectedIndex = 0xFFFFFFFF;
                    if (hoverValue !== undefined) {
                        const index = idMap.get(hoverValue.id);
                        if (index !== undefined) {
                            selectedIndex = index * handler.pickIdsPerInstance;
                            // If we wanted to include the partIndex, we would add:
                            // selectedIndex += hoverValue.partIndex;
                        }
                    }
                    count = Math.round(count * drawFraction);
                    context.count = count;
                    context.bufferOffset = typeToOffset[annotationType];
                    context.selectedIndex = selectedIndex;
                    this.renderHelpers[annotationType].draw(context);
                    context.basePickId += count * handler.pickIdsPerInstance;
                }
            }
        }
        updateMouseState(mouseState, _pickedValue, pickedOffset, data) {
            const chunk = data;
            const serializedAnnotations = chunk.serializedAnnotations;
            const typeToIds = serializedAnnotations.typeToIds,
                  typeToOffset = serializedAnnotations.typeToOffset;

            const rank = this.curRank;
            const chunkTransform = this.chunkTransform;
            if (chunkTransform.error !== undefined) return;
            for (const annotationType of annotationTypes) {
                const ids = typeToIds[annotationType];
                const renderHandler = getAnnotationTypeRenderHandler(annotationType);
                const pickIdsPerInstance = renderHandler.pickIdsPerInstance;

                if (pickedOffset < ids.length * pickIdsPerInstance) {
                    const instanceIndex = Math.floor(pickedOffset / pickIdsPerInstance);
                    const id = ids[instanceIndex];
                    const partIndex = pickedOffset % pickIdsPerInstance;
                    mouseState.pickedAnnotationId = id;
                    mouseState.pickedAnnotationLayer = this.base.state;
                    mouseState.pickedOffset = partIndex;
                    mouseState.pickedAnnotationBuffer = serializedAnnotations.data.buffer;
                    mouseState.pickedAnnotationType = annotationType;
                    mouseState.pickedAnnotationBufferBaseOffset = serializedAnnotations.data.byteOffset + typeToOffset[annotationType];
                    mouseState.pickedAnnotationIndex = instanceIndex;
                    mouseState.pickedAnnotationCount = ids.length;
                    const chunkPosition = this.tempChunkPosition;
                    const chunkToLayerTransform = chunkTransform.chunkToLayerTransform,
                          combinedGlobalLocalToChunkTransform = chunkTransform.combinedGlobalLocalToChunkTransform,
                          layerRank = chunkTransform.layerRank;
                    const globalToRenderLayerDimensions = chunkTransform.modelTransform.globalToRenderLayerDimensions;
                    const mousePosition = mouseState.position;

                    if (!getChunkPositionFromCombinedGlobalLocalPositions(chunkPosition, mousePosition, this.base.state.localPosition.value, layerRank, combinedGlobalLocalToChunkTransform)) {
                        return;
                    }
                    const propertySerializer = this.base.source.annotationPropertySerializers[annotationType];
                    renderHandler.snapPosition(chunkPosition, mouseState.pickedAnnotationBuffer, mouseState.pickedAnnotationBufferBaseOffset + mouseState.pickedAnnotationIndex * propertySerializer.propertyGroupBytes[0], partIndex);
                    const globalRank = globalToRenderLayerDimensions.length;
                    for (let globalDim = 0; globalDim < globalRank; ++globalDim) {
                        const layerDim = globalToRenderLayerDimensions[globalDim];
                        if (layerDim === -1) continue;
                        let sum = chunkToLayerTransform[(rank + 1) * rank + layerDim];
                        for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
                            sum += chunkPosition[chunkDim] * chunkToLayerTransform[chunkDim * (layerRank + 1) + layerDim];
                        }
                        if (!_Number$isFinite(sum)) {
                            continue;
                        }
                        mousePosition[globalDim] = sum;
                    }
                    return;
                }
                pickedOffset -= ids.length * pickIdsPerInstance;
            }
        }
        transformPickedValue(pickState) {
            const pickedAnnotationBuffer = pickState.pickedAnnotationBuffer;

            if (pickedAnnotationBuffer === undefined) return undefined;
            const properties = this.base.source.properties;

            if (properties.length === 0) return undefined;
            const pickedAnnotationBufferBaseOffset = pickState.pickedAnnotationBufferBaseOffset,
                  pickedAnnotationType = pickState.pickedAnnotationType,
                  pickedAnnotationIndex = pickState.pickedAnnotationIndex,
                  pickedAnnotationCount = pickState.pickedAnnotationCount;
            const annotationPropertySerializers = this.base.source.annotationPropertySerializers;
            // Check if there are any properties.

            const propertyValues = new Array(properties.length);
            annotationPropertySerializers[pickedAnnotationType].deserialize(new DataView(pickedAnnotationBuffer), pickedAnnotationBufferBaseOffset, pickedAnnotationIndex, pickedAnnotationCount,
            /*isLittleEndian=*/Endianness.LITTLE === ENDIANNESS, propertyValues);
            return formatAnnotationPropertyValue(properties[0], propertyValues[0]);
        }
        isReady() {
            const base = this.base;
            const source = base.source;

            if (!(source instanceof MultiscaleAnnotationSource)) {
                return true;
            }
            const segmentationStates = this.base.segmentationStates.value;

            if (segmentationStates === undefined) return true;
            for (let i = 0, count = segmentationStates.length; i < count; ++i) {
                const segmentationState = segmentationStates[i];
                if (segmentationState === null) return false;
                if (segmentationState === undefined) continue;
                const chunks = source.segmentFilteredSources[i].chunks;
                let missing = false;
                forEachVisibleSegment(segmentationState.segmentationGroupState.value, objectId => {
                    const key = getObjectKey(objectId);
                    if (!chunks.has(key)) {
                        missing = true;
                    }
                });
                if (missing) return false;
            }
            return true;
        }
    }
    ;
    return C;
}
const NonSpatiallyIndexedAnnotationRenderLayer = Base => class C extends Base {
    constructor() {
        super(...arguments);
        this.layerChunkProgressInfo = this.base.layerChunkProgressInfo;
    }
    draw(renderContext, attachment) {
        const chunkRenderParameters = this.updateAttachmentState(attachment);
        if (this.curRank === 0 || chunkRenderParameters === undefined) return;
        this.updateModelClipBounds(renderContext, chunkRenderParameters);
        const source = this.base.source;

        if (source instanceof AnnotationSource) {
            const base = this.base;

            base.updateBuffer();
            this.drawGeometry(base, renderContext, chunkRenderParameters);
        } else {
            const renderScaleHistogram = this.renderScaleHistogram;

            renderScaleHistogram.begin(this.base.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
            this.drawGeometryChunkData(source.temporary.data, renderContext, chunkRenderParameters);
            const segmentationStates = this.base.segmentationStates.value;

            let presentChunks = 0;
            let notPresentChunks = 0;
            if (segmentationStates !== undefined) {
                for (let i = 0, count = segmentationStates.length; i < count; ++i) {
                    const segmentationState = segmentationStates[i];
                    if (segmentationState == null) continue;
                    const chunks = source.segmentFilteredSources[i].chunks;
                    forEachVisibleSegment(segmentationState.segmentationGroupState.value, objectId => {
                        const key = getObjectKey(objectId);
                        const chunk = chunks.get(key);
                        if (chunk !== undefined && chunk.state === ChunkState.GPU_MEMORY) {
                            const data = chunk.data;

                            if (data === undefined) return;
                            this.drawGeometryChunkData(data, renderContext, chunkRenderParameters);
                            ++presentChunks;
                        } else {
                            ++notPresentChunks;
                        }
                    });
                }
            }
            renderScaleHistogram.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, presentChunks, notPresentChunks);
        }
    }
};
const PerspectiveViewAnnotationLayerBase = AnnotationRenderLayer(PerspectiveViewRenderLayer, 'perspectiveViewRenderHelper');
export class PerspectiveViewAnnotationLayer extends NonSpatiallyIndexedAnnotationRenderLayer(PerspectiveViewAnnotationLayerBase) {}
const SpatiallyIndexedAnnotationLayer = Base => {
    class SpatiallyIndexedAnnotationLayer extends Base {
        constructor(options) {
            super(options.annotationLayer, options.renderScaleHistogram);
            this.wireFrameRenderHelper = this instanceof SliceViewPanelRenderLayer ? crossSectionBoxWireFrameShader : projectionViewBoxWireFrameShader;
            this.wireFrameShaderGetter = parameterizedEmitterDependentShaderGetter(this, this.gl, {
                memoizeKey: `annotation/wireFrameShader:${this instanceof SliceViewPanelRenderLayer}`,
                parameters: constantWatchableValue(undefined),
                defineShader: builder => {
                    this.wireFrameRenderHelper.defineShader(builder);
                }
            });
            this.renderScaleTarget = options.renderScaleTarget;
            this.registerDisposer(this.renderScaleTarget.changed.add(this.redrawNeeded.dispatch));
            const sharedObject = this.registerDisposer(new ChunkRenderLayerFrontend(this.layerChunkProgressInfo));
            const rpc = this.base.chunkManager.rpc;
            sharedObject.RPC_TYPE_ID = ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID;
            sharedObject.initializeCounterpart(rpc, {
                chunkManager: this.base.chunkManager.rpcId,
                localPosition: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.base.state.localPosition)).rpcId,
                renderScaleTarget: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.renderScaleTarget)).rpcId
            });
            this.backend = sharedObject;
        }
        attach(attachment) {
            super.attach(attachment);
            attachment.state.sources = attachment.registerDisposer(registerNested((context, transform, displayDimensionRenderInfo) => {
                const transformedSources = getVolumetricTransformedSources(displayDimensionRenderInfo, transform, options => this.base.state.source.getSources(options), attachment.messages, this);
                for (const scales of transformedSources) {
                    for (const tsource of scales) {
                        context.registerDisposer(tsource.source);
                        _Object$assign(tsource, getAnnotationProjectionParameters(tsource.chunkDisplayTransform));
                    }
                }
                attachment.view.flushBackendProjectionParameters();
                this.backend.rpc.invoke(ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, {
                    layer: this.backend.rpcId,
                    view: attachment.view.rpcId,
                    displayDimensionRenderInfo,
                    sources: serializeAllTransformedSources(transformedSources)
                });
                this.redrawNeeded.dispatch();
                return transformedSources;
            }, this.base.state.transform, attachment.view.displayDimensionRenderInfo));
        }
        draw(renderContext, attachment) {
            const chunkRenderParameters = this.updateAttachmentState(attachment);
            if (this.curRank === 0 || chunkRenderParameters === undefined) return;
            const transformedSources = attachment.state.sources.value;
            if (transformedSources.length === 0) return;
            this.updateModelClipBounds(renderContext, chunkRenderParameters);
            const renderScaleHistogram = this.renderScaleHistogram;

            renderScaleHistogram.begin(this.base.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
            const projectionParameters = renderContext.projectionParameters;

            let wireFrameShader;
            if (renderContext.wireFrame) {
                var _wireFrameShaderGette = this.wireFrameShaderGetter(renderContext.emitter);

                const shader = _wireFrameShaderGette.shader;

                if (shader === null) return;
                shader.bind();
                this.wireFrameRenderHelper.initialize(shader, projectionParameters);
                wireFrameShader = shader;
            }
            forEachVisibleAnnotationChunk(projectionParameters, this.base.state.localPosition.value, this.renderScaleTarget.value, transformedSources[0], () => {}, (tsource, index, drawFraction, physicalSpacing, pixelSpacing) => {
                index;
                const chunk = tsource.source.chunks.get(tsource.curPositionInChunks.join());
                let present;
                if (chunk === undefined || chunk.state !== ChunkState.GPU_MEMORY) {
                    present = 0;
                } else {
                    const data = chunk.data;

                    if (data === undefined) {
                        return;
                    }
                    if (wireFrameShader !== undefined) {
                        this.wireFrameRenderHelper.draw(wireFrameShader, tsource, projectionParameters);
                    } else {
                        this.drawGeometryChunkData(data, renderContext, chunkRenderParameters, drawFraction);
                    }
                    present = 1;
                }
                renderScaleHistogram.add(physicalSpacing, pixelSpacing, present, 1 - present);
            });
        }
    }
    ;
    return SpatiallyIndexedAnnotationLayer;
};
export const SpatiallyIndexedPerspectiveViewAnnotationLayer = SpatiallyIndexedAnnotationLayer(PerspectiveViewAnnotationLayerBase);
export const SpatiallyIndexedSliceViewAnnotationLayer = SpatiallyIndexedAnnotationLayer(AnnotationRenderLayer(SliceViewPanelRenderLayer, 'sliceViewRenderHelper'));
export const SliceViewAnnotationLayer = NonSpatiallyIndexedAnnotationRenderLayer(AnnotationRenderLayer(SliceViewPanelRenderLayer, 'sliceViewRenderHelper'));
//# sourceMappingURL=renderlayer.js.map