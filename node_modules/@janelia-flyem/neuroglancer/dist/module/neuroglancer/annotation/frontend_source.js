import _Symbol$iterator from "babel-runtime/core-js/symbol/iterator";
import _Set from "babel-runtime/core-js/set";
import _Map from "babel-runtime/core-js/map";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import { AnnotationReference, AnnotationType, annotationTypeHandlers, annotationTypes, fixAnnotationAfterStructuredCloning, makeAnnotationId, makeAnnotationPropertySerializers } from "./index";
import { ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, ANNOTATION_COMMIT_UPDATE_RPC_ID, ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID, ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID, ANNOTATION_REFERENCE_ADD_RPC_ID, ANNOTATION_REFERENCE_DELETE_RPC_ID, ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID } from "./base";
import { getAnnotationTypeRenderHandler } from "./type_handler";
import { Chunk, ChunkSource } from "../chunk_manager/frontend";
import { getObjectKey } from "../segmentation_display_state/base";
import { SliceViewChunk, SliceViewChunkSource } from "../sliceview/frontend";
import { StatusMessage } from "../status";
import { ENDIANNESS, Endianness } from "../util/endian";
import * as matrix from "../util/matrix";
import { NullarySignal, Signal } from "../util/signal";
import { registerRPC, registerSharedObjectOwner, SharedObject } from "../worker_rpc";
const DEBUG = false;
export function computeNumPickIds(serializedAnnotations) {
    let numPickIds = 0;
    const typeToIds = serializedAnnotations.typeToIds;

    for (const annotationType of annotationTypes) {
        numPickIds += getAnnotationTypeRenderHandler(annotationType).pickIdsPerInstance * typeToIds[annotationType].length;
    }
    return numPickIds;
}
export class AnnotationGeometryData {
    constructor(x) {
        this.bufferValid = false;
        this.numPickIds = 0;
        this.serializedAnnotations = {
            data: x.data,
            typeToIds: x.typeToIds,
            typeToOffset: x.typeToOffset,
            typeToIdMaps: x.typeToIdMaps
        };
    }
    freeGPUMemory(gl) {
        gl;
        const buffer = this.buffer;

        if (buffer !== undefined) {
            buffer.dispose();
            this.bufferValid = false;
            this.buffer = undefined;
        }
    }
}
export class AnnotationSubsetGeometryChunk extends Chunk {
    constructor(source, x) {
        super(source);
        if (x.data !== undefined) {
            this.data = new AnnotationGeometryData(x);
        }
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        const data = this.data;

        if (data !== undefined) {
            data.freeGPUMemory(gl);
        }
    }
    dispose() {
        this.data = undefined;
    }
}
export class AnnotationGeometryChunk extends SliceViewChunk {
    constructor(source, x) {
        super(source, x);
        if (x.data !== undefined) {
            this.data = new AnnotationGeometryData(x);
        }
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        const data = this.data;

        if (data !== undefined) {
            data.freeGPUMemory(gl);
        }
    }
    dispose() {
        this.data = undefined;
    }
}
let AnnotationGeometryChunkSource = class AnnotationGeometryChunkSource extends SliceViewChunkSource {
    constructor(chunkManager, options) {
        super(chunkManager, options);
        this.immediateChunkUpdates = true;
        const parent = this.parent = options.parent;
        parent.spatiallyIndexedSources.add(this);
        var _spec = this.spec;
        const rank = _spec.rank,
              chunkDataSize = _spec.chunkDataSize;

        const multiscaleToChunkTransform = this.multiscaleToChunkTransform = new Float32Array((rank + 1) ** 2);
        matrix.inverse(multiscaleToChunkTransform, rank + 1, this.spec.chunkToMultiscaleTransform, rank + 1, rank + 1);
        for (let i = 0; i < rank; ++i) {
            for (let j = 0; j < rank + 1; ++j) {
                multiscaleToChunkTransform[(rank + 1) * j + i] /= chunkDataSize[i];
            }
        }
    }
    disposed() {
        this.parent.spatiallyIndexedSources.delete(this);
        super.disposed();
    }
    initializeCounterpart(rpc, options) {
        options['parent'] = this.parent.rpcId;
        super.initializeCounterpart(rpc, options);
    }
    addChunk(key, chunk) {
        super.addChunk(key, chunk);
        // TODO: process local deletions
    }
    getChunk(x) {
        return new AnnotationGeometryChunk(this, x);
    }
};
AnnotationGeometryChunkSource = __decorate([registerSharedObjectOwner(ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID)], AnnotationGeometryChunkSource);
export { AnnotationGeometryChunkSource };
let AnnotationSubsetGeometryChunkSource = class AnnotationSubsetGeometryChunkSource extends ChunkSource {
    constructor(chunkManager, parent, relationshipIndex) {
        super(chunkManager, {});
        this.parent = parent;
        this.relationshipIndex = relationshipIndex;
        this.immediateChunkUpdates = true;
    }
    addChunk(key, chunk) {
        super.addChunk(key, chunk);
        // TODO: process local deletions
    }
    getChunk(x) {
        return new AnnotationSubsetGeometryChunk(this, x);
    }
};
AnnotationSubsetGeometryChunkSource = __decorate([registerSharedObjectOwner(ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID)], AnnotationSubsetGeometryChunkSource);
export { AnnotationSubsetGeometryChunkSource };
export class AnnotationMetadataChunk extends Chunk {
    constructor(source, x) {
        super(source);
        this.annotation = fixAnnotationAfterStructuredCloning(x.annotation);
    }
}
let AnnotationMetadataChunkSource = class AnnotationMetadataChunkSource extends ChunkSource {
    constructor(chunkManager, parent) {
        super(chunkManager);
        this.parent = parent;
    }
    getChunk(x) {
        return new AnnotationMetadataChunk(this, x);
    }
    addChunk(key, chunk) {
        super.addChunk(key, chunk);
        const references = this.parent.references;

        const reference = references.get(key);
        if (reference !== undefined) {
            reference.value = chunk.annotation;
            reference.changed.dispatch();
        }
    }
    deleteChunk(key) {
        const references = this.parent.references;

        const reference = references.get(key);
        if (reference !== undefined) {
            reference.value = undefined;
            reference.changed.dispatch();
        }
    }
};
AnnotationMetadataChunkSource = __decorate([registerSharedObjectOwner(ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID)], AnnotationMetadataChunkSource);
export { AnnotationMetadataChunkSource };
function copyOtherAnnotations(serializedAnnotations, propertySerializers, excludedType, excludedTypeAdjustment) {
    const newData = new Uint8Array(serializedAnnotations.data.length + excludedTypeAdjustment);
    // Copy all other annotation types
    for (const otherType of annotationTypes) {
        if (otherType === excludedType) continue;
        let otherTypeOffset = serializedAnnotations.typeToOffset[otherType];
        let newTypeOffset = otherTypeOffset;
        if (otherType > excludedType) {
            newTypeOffset += excludedTypeAdjustment;
            serializedAnnotations.typeToOffset[otherType] = newTypeOffset;
        }
        newData.set(serializedAnnotations.data.subarray(otherTypeOffset, otherTypeOffset + serializedAnnotations.typeToIds[otherType].length * propertySerializers[otherType].serializedBytes), newTypeOffset);
    }
    return newData;
}
function copyAnnotationSlice(serializedAnnotations, propertySerializers, type, dest, sourceBeginIndex, sourceEndIndex, destBeginIndex, destCount) {
    const typeOffset = serializedAnnotations.typeToOffset[type];
    let sourceGroupOffset = typeOffset;
    let destGroupOffset = typeOffset;
    const propertyGroupBytes = propertySerializers[type].propertyGroupBytes;

    const numGroups = propertyGroupBytes.length;
    const count = serializedAnnotations.typeToIds[type].length;
    for (let groupIndex = 0; groupIndex < numGroups; ++groupIndex) {
        const groupBytes = propertyGroupBytes[groupIndex];
        dest.set(serializedAnnotations.data.subarray(sourceGroupOffset + sourceBeginIndex * groupBytes, sourceGroupOffset + sourceEndIndex * groupBytes), destGroupOffset + destBeginIndex * groupBytes);
        sourceGroupOffset += groupBytes * count;
        destGroupOffset += groupBytes * destCount;
    }
}
export function updateAnnotation(chunk, annotation, propertySerializers) {
    // Find insertion point.
    const type = annotation.type;
    const rank = propertySerializers[type].rank;
    const serializedAnnotations = chunk.serializedAnnotations;

    const ids = serializedAnnotations.typeToIds[type];
    const idMap = serializedAnnotations.typeToIdMaps[type];
    const handler = annotationTypeHandlers[type];
    const numBytes = propertySerializers[type].serializedBytes;
    let index = idMap.get(annotation.id);
    if (index === undefined) {
        // Doesn't already exist.
        index = idMap.size;
        idMap.set(annotation.id, index);
        const newData = copyOtherAnnotations(serializedAnnotations, propertySerializers, type, numBytes);
        copyAnnotationSlice(serializedAnnotations, propertySerializers, type, newData, /*sourceBeginIndex=*/0,
        /*sourceEndIndex=*/index, /*destBeginIndex=*/0, /*destCount=*/index + 1);
        ids.push(annotation.id);
        serializedAnnotations.data = newData;
    }
    const bufferOffset = serializedAnnotations.typeToOffset[type];
    const dv = new DataView(serializedAnnotations.data.buffer, serializedAnnotations.data.byteOffset, serializedAnnotations.data.byteLength);
    const isLittleEndian = ENDIANNESS === Endianness.LITTLE;
    const propertySerializer = propertySerializers[type];
    handler.serialize(dv, bufferOffset + propertySerializer.propertyGroupBytes[0] * index, isLittleEndian, rank, annotation);
    propertySerializer.serialize(dv, bufferOffset, index, ids.length, isLittleEndian, annotation.properties);
    chunk.bufferValid = false;
}
export function deleteAnnotation(chunk, type, id, propertySerializers) {
    const serializedAnnotations = chunk.serializedAnnotations;

    const idMap = serializedAnnotations.typeToIdMaps[type];
    const index = idMap.get(id);
    if (index === undefined) {
        return false;
    }
    const ids = serializedAnnotations.typeToIds[type];
    const numBytes = propertySerializers[type].serializedBytes;
    const newData = copyOtherAnnotations(serializedAnnotations, propertySerializers, type, -numBytes);
    copyAnnotationSlice(serializedAnnotations, propertySerializers, type, newData, /*sourceBeginIndex=*/0,
    /*sourceEndIndex=*/index, /*destBeginIndex=*/0, /*destCount=*/ids.length - 1);
    copyAnnotationSlice(serializedAnnotations, propertySerializers, type, newData, /*sourceBeginIndex=*/index + 1,
    /*sourceEndIndex=*/ids.length, /*destBeginIndex=*/index, /*destCount=*/ids.length - 1);
    ids.splice(index, 1);
    idMap.delete(id);
    for (let i = index, count = ids.length; i < count; ++i) {
        idMap.set(ids[i], i);
    }
    serializedAnnotations.data = newData;
    chunk.bufferValid = false;
    return true;
}
export function makeTemporaryChunk() {
    const typeToIds = [];
    const typeToOffset = [];
    const typeToIdMaps = [];
    for (const annotationType of annotationTypes) {
        typeToIds[annotationType] = [];
        typeToOffset[annotationType] = 0;
        typeToIdMaps[annotationType] = new _Map();
    }
    return new AnnotationGeometryChunk(undefined, { data: new Uint8Array(0), numPickIds: 0, typeToOffset, typeToIds, typeToIdMaps });
}
export class MultiscaleAnnotationSource extends SharedObject {
    constructor(chunkManager, options) {
        super();
        this.chunkManager = chunkManager;
        this.metadataChunkSource = this.registerDisposer(new AnnotationMetadataChunkSource(this.chunkManager, this));
        this.spatiallyIndexedSources = new _Set();
        this.temporary = makeTemporaryChunk();
        this.references = new _Map();
        this.localUpdates = new _Map();
        this.numCommitsInProgress = 0;
        // FIXME
        this.changed = new NullarySignal();
        this.referencesChanged = new Signal();
        this.readonly = false;
        this.childRefreshed = new NullarySignal();
        this.rank = options.rank;
        this.properties = options.properties;
        this.annotationPropertySerializers = makeAnnotationPropertySerializers(this.rank, this.properties);
        const segmentFilteredSources = this.segmentFilteredSources = [];
        const relationships = options.relationships;

        this.relationships = relationships;
        for (let i = 0, count = relationships.length; i < count; ++i) {
            segmentFilteredSources.push(this.registerDisposer(new AnnotationSubsetGeometryChunkSource(chunkManager, this, i)));
        }
        if (DEBUG) {
            this.referencesChanged.add(source => {
                console.log('annotation references changed:', source);
            });
        }
    }
    hasNonSerializedProperties() {
        return this.relationships.length > 0;
    }
    getSources(_options) {
        throw new Error('not implemented');
    }
    initializeCounterpart(rpc, options) {
        this.metadataChunkSource.initializeCounterpart(rpc, {});
        for (const source of this.segmentFilteredSources) {
            source.initializeCounterpart(rpc, {});
        }
        options.segmentFilteredSource = this.segmentFilteredSources.map(x => x.addCounterpartRef());
        options.metadataChunkSource = this.metadataChunkSource.addCounterpartRef();
        options.chunkManager = this.chunkManager.rpcId;
        super.initializeCounterpart(rpc, options);
    }
    add(annotation, commit = true) {
        annotation.id = makeAnnotationId();
        const reference = new AnnotationReference(annotation.id);
        reference.value = annotation;
        this.references.set(reference.id, reference);
        this.referencesChanged.dispatch({ action: 'adding', id: reference.id });
        reference.registerDisposer(() => {
            this.references.delete(reference.id);
            this.referencesChanged.dispatch({ action: 'deref', id: reference.id });
        });
        this.applyLocalUpdate(reference, /*existing=*/false, /*commit=*/commit, /*newAnnotation=*/annotation);
        return reference;
    }
    applyLocalUpdate(reference, existing, commit, newAnnotation) {
        const localUpdates = this.localUpdates;
        const id = reference.id;

        let localUpdate = this.localUpdates.get(id);
        const annotation = reference.value;
        if (annotation == null) {
            throw new Error(`Cannot create local update from null annotation`);
        }
        if (localUpdate === undefined) {
            localUpdate = {
                type: annotation.type,
                reference: reference.addRef(),
                existingAnnotation: existing ? annotation : undefined,
                pendingCommit: undefined,
                commitInProgress: undefined
            };
            localUpdates.set(id, localUpdate);
            this.forEachPossibleChunk(annotation, chunk => {
                const data = chunk.data;

                if (data === undefined) return;
                const annotationType = annotation.type;
                deleteAnnotation(data, annotationType, id, this.annotationPropertySerializers);
            });
            if (newAnnotation !== null) {
                // Add to temporary chunk.
                updateAnnotation(this.temporary.data, newAnnotation, this.annotationPropertySerializers);
            }
        } else {
            if (newAnnotation === null) {
                // Annotation has a local update already, so we need to delete it from the temporary chunk.
                deleteAnnotation(this.temporary.data, annotation.type, annotation.id, this.annotationPropertySerializers);
            } else {
                // Modify existing entry in temporary chunk.
                updateAnnotation(this.temporary.data, newAnnotation, this.annotationPropertySerializers);
            }
            reference.value = newAnnotation;
        }
        if (commit) {
            if (localUpdate.commitInProgress !== undefined) {
                localUpdate.pendingCommit = newAnnotation;
            } else {
                if (newAnnotation === null && localUpdate.existingAnnotation === undefined) {
                    // Local update, which we would now like to delete, has never been committed.
                    // Therefore we can just delete it locally.
                    localUpdates.delete(id);
                    localUpdate.reference.dispose();
                    return;
                }
                this.sendCommitRequest(localUpdate, newAnnotation);
            }
        }
        this.notifyChanged(reference.id, newAnnotation || undefined);
    }
    sendCommitRequest(localUpdate, newAnnotation) {
        this.updateCommitsInProgress(1);
        localUpdate.commitInProgress = newAnnotation;
        this.rpc.invoke(ANNOTATION_COMMIT_UPDATE_RPC_ID, {
            id: this.rpcId,
            annotationId: localUpdate.existingAnnotation && localUpdate.reference.id,
            newAnnotation
        });
    }
    delete(reference) {
        this.applyLocalUpdate(reference, /*existing=*/true, /*commit=*/true, /*newAnnotation=*/null);
    }
    update(reference, newAnnotation) {
        this.applyLocalUpdate(reference, /*existing=*/true, /*commit=*/false, /*newAnnotation=*/newAnnotation);
    }
    notifyChanged(id, annotation) {
        const reference = this.references.get(id);
        const chunk = this.metadataChunkSource.chunks.get(id);
        if (chunk !== undefined) {
            chunk.annotation = annotation || null;
        }
        if (reference !== undefined) {
            reference.value = annotation || null;
            reference.changed.dispatch();
            this.referencesChanged.dispatch({ action: 'changed', id });
        }
        this.chunkManager.chunkQueueManager.visibleChunksChanged.dispatch();
    }
    /**
     * Must be called after `add` or `update` to commit the result.
     */
    commit(reference) {
        this.applyLocalUpdate(reference, /*existing=*/true, /*commit=*/true, reference.value);
    }
    updateReference(annotation) {
        let existing = this.references.get(annotation.id);
        if (existing !== undefined) {
            existing.value = annotation;
        } else {
            let reference = new AnnotationReference(annotation.id);
            this.references.set(annotation.id, reference);
            reference.value = annotation;
            this.referencesChanged.dispatch({ action: 'update', id: reference.id });
            reference.registerDisposer(() => {
                this.references.delete(reference.id);
                this.referencesChanged.dispatch({ action: 'deref', id: reference.id });
            });
        }
    }
    hasReference(id) {
        return this.references.has(id);
    }
    getReference(id) {
        let existing = this.references.get(id);
        if (existing !== undefined) {
            return existing.addRef();
        }
        existing = new AnnotationReference(id);
        this.references.set(id, existing);
        this.referencesChanged.dispatch({ 'action': 'get', id });
        // existing.addRef(); //Looks like it is necessary
        this.rpc.invoke(ANNOTATION_REFERENCE_ADD_RPC_ID, { id: this.rpcId, annotation: id });
        existing.registerDisposer(() => {
            this.references.delete(id);
            this.referencesChanged.dispatch({ 'action': 'deref', id });
            this.rpc.invoke(ANNOTATION_REFERENCE_DELETE_RPC_ID, { id: this.rpcId, annotation: id });
        });
        const chunk = this.metadataChunkSource.chunks.get(id);
        if (chunk !== undefined && chunk.annotation !== null) {
            existing.value = chunk.annotation;
        }
        return existing;
    }
    forEachPossibleChunk(annotation, callback) {
        annotation;
        const relatedSegments = annotation.relatedSegments;

        if (relatedSegments !== undefined) {
            const numRelationships = relatedSegments.length;
            const segmentFilteredSources = this.segmentFilteredSources;

            for (let i = 0; i < numRelationships; ++i) {
                const segments = relatedSegments[i];
                if (segments === undefined) return;
                const source = segmentFilteredSources[i];
                for (const segment of segments) {
                    const chunk = source.chunks.get(getObjectKey(segment));
                    if (chunk === undefined) {
                        continue;
                    }
                    callback(chunk);
                }
            }
        }
        const rank = this.rank;

        const tempLower = new Float32Array(rank);
        const tempUpper = new Float32Array(rank);
        const tempChunk = new Float32Array(rank);
        for (const source of this.spatiallyIndexedSources) {
            switch (annotation.type) {
                case AnnotationType.POINT:
                    matrix.transformPoint(tempLower, source.multiscaleToChunkTransform, rank + 1, annotation.point, rank);
                    tempUpper.set(tempLower);
                    break;
                case AnnotationType.LINE:
                case AnnotationType.SPHERE:
                case AnnotationType.AXIS_ALIGNED_BOUNDING_BOX:
                    matrix.transformPoint(tempLower, source.multiscaleToChunkTransform, rank + 1, annotation.pointA, rank);
                    matrix.transformPoint(tempUpper, source.multiscaleToChunkTransform, rank + 1, annotation.pointB, rank);
                    break;
                case AnnotationType.ELLIPSOID:
                    matrix.transformPoint(tempLower, source.multiscaleToChunkTransform, rank + 1, annotation.center, rank);
                    matrix.transformVector(tempUpper, source.multiscaleToChunkTransform, rank + 1, annotation.radii, rank);
                    for (let i = 0; i < rank; ++i) {
                        const c = tempLower[i];
                        const r = tempUpper[i];
                        tempLower[i] = c - r;
                        tempUpper[i] = c + r;
                    }
                    break;
            }
            let totalChunks = 1;
            for (let i = 0; i < rank; ++i) {
                const a = tempLower[i];
                const b = tempUpper[i];
                const lower = Math.min(a, b);
                const upper = Math.max(a, b);
                // In the case that the point lies directly on a boundary, ensure it is included in both
                // chunks, since we don't know how the datasource handles this case.
                tempLower[i] = Math.ceil(lower - 1);
                tempUpper[i] = Math.floor(upper + 1);
                totalChunks *= tempUpper[i] - tempLower[i];
            }
            const chunks = source.chunks;

            for (let chunkIndex = 0; chunkIndex < totalChunks; ++chunkIndex) {
                let remainder = chunkIndex;
                for (let i = 0; i < rank; ++i) {
                    const lower = tempLower[i];
                    const upper = tempUpper[i];
                    const size = upper - lower;
                    const x = tempChunk[i] = remainder % size;
                    remainder = (remainder - x) / size;
                }
                const chunk = chunks.get(tempChunk.join());
                if (chunk !== undefined) {
                    callback(chunk);
                }
            }
        }
    }
    static encodeOptions(_options) {
        return {};
    }
    handleSuccessfulUpdate(id, newAnnotation) {
        const localUpdate = this.localUpdates.get(id);
        if (localUpdate === undefined || localUpdate.commitInProgress === undefined) {
            throw new Error(`Received invalid successful update notification`);
        }
        this.updateCommitsInProgress(-1);
        if (newAnnotation !== null && localUpdate.reference.id !== newAnnotation.id) {
            if (localUpdate.commitInProgress === null) {
                throw new Error(`Received invalid successful update notification`);
            }
            localUpdate.reference.id = newAnnotation.id;
            this.references.delete(id);
            this.references.set(newAnnotation.id, localUpdate.reference.addRef());
            this.localUpdates.delete(id);
            this.localUpdates.set(newAnnotation.id, localUpdate);
            if (localUpdate.reference.value !== null) {
                localUpdate.reference.value.id = newAnnotation.id;
                deleteAnnotation(this.temporary.data, localUpdate.type, id, this.annotationPropertySerializers);
                updateAnnotation(this.temporary.data, localUpdate.reference.value, this.annotationPropertySerializers);
            }
            localUpdate.reference.changed.dispatch();
        }
        let added = localUpdate.existingAnnotation === undefined;
        localUpdate.existingAnnotation = newAnnotation || undefined;
        localUpdate.commitInProgress = undefined;
        let pendingCommit = localUpdate.pendingCommit;

        localUpdate.pendingCommit = undefined;
        if (newAnnotation === null) {
            pendingCommit = undefined;
        }
        if (pendingCommit !== undefined) {
            if (pendingCommit !== null) {
                pendingCommit.id = newAnnotation.id;
            }
            this.sendCommitRequest(localUpdate, pendingCommit);
        } else {
            this.revertLocalUpdate(localUpdate);
            if (added) {
                this.childAdded.dispatch(newAnnotation);
                this.referencesChanged.dispatch({ action: 'added', id: newAnnotation.id });
            } else if (newAnnotation === null) {
                this.references.get(id).dispose();
                this.childDeleted.dispatch(id);
                this.referencesChanged.dispatch({ action: 'deleted', id });
            } else {
                this.childUpdated.dispatch(newAnnotation);
                this.referencesChanged.dispatch({ action: 'updated', id: newAnnotation.id });
            }
        }
    }
    disposed() {
        const commitStatus = this.commitStatus;

        if (commitStatus !== undefined) {
            commitStatus.dispose();
        }
    }
    updateCommitsInProgress(amount) {
        this.numCommitsInProgress += amount;
        if (this.numCommitsInProgress === 0) {
            if (this.commitStatus !== undefined) {
                this.commitStatus.dispose();
                this.commitStatus = undefined;
            }
        } else if (this.commitStatus === undefined) {
            const status = this.commitStatus = new StatusMessage( /*delay=*/true);
            status.setText('Commiting annotations');
        }
    }
    handleFailedUpdate(id, message) {
        const localUpdate = this.localUpdates.get(id);
        if (localUpdate === undefined || localUpdate.commitInProgress === undefined) {
            throw new Error(`Received invalid update notification`);
        }
        const status = new StatusMessage();
        status.setErrorMessage(`Error commiting annotation update: ${message}`);
        this.revertLocalUpdate(localUpdate);
        this.updateCommitsInProgress(-1);
    }
    revertLocalUpdate(localUpdate) {
        deleteAnnotation(this.temporary.data, localUpdate.type, localUpdate.reference.id, this.annotationPropertySerializers);
        const existingAnnotation = localUpdate.existingAnnotation;

        if (existingAnnotation !== undefined) {
            this.forEachPossibleChunk(existingAnnotation, chunk => {
                const data = chunk.data;

                if (data === undefined) return;
                updateAnnotation(data, existingAnnotation, this.annotationPropertySerializers);
            });
        }
        const reference = localUpdate.reference;
        const id = reference.id;

        reference.value = existingAnnotation || null;
        reference.changed.dispatch();
        reference.dispose();
        this.localUpdates.delete(id);
        if (DEBUG) {
            console.log('#references', this.references.size);
        }
    }
    *[_Symbol$iterator]() {}
}
registerRPC(ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, function (x) {
    const source = this.get(x.id);
    const annotationId = x.annotationId;
    const error = x.error;
    if (error !== undefined) {
        source.handleFailedUpdate(annotationId, error);
    } else {
        const newAnnotation = fixAnnotationAfterStructuredCloning(x.newAnnotation);
        source.handleSuccessfulUpdate(annotationId, newAnnotation);
    }
});
//# sourceMappingURL=frontend_source.js.map