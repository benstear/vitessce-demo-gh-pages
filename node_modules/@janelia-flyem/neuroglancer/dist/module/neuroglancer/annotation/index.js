import _Symbol$iterator from 'babel-runtime/core-js/symbol/iterator';
import _Map from 'babel-runtime/core-js/map';
import _Array$from from 'babel-runtime/core-js/array/from';
import _Set from 'babel-runtime/core-js/set';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { arraysEqual } from '../util/array';
import { packColor, parseRGBAColorSpecification, parseRGBColorSpecification, serializeColor, unpackRGB, unpackRGBA } from '../util/color';
import { DataType } from '../util/data_type';
import { RefCounted } from '../util/disposable';
import { Endianness, ENDIANNESS } from '../util/endian';
import { expectArray, parseArray, parseFixedLengthArray, verifyEnumString, verifyFiniteFloat, verifyFiniteNonNegativeFloat, verifyFloat, verifyInt, verifyObject, verifyObjectProperty, verifyOptionalObjectProperty, verifyOptionalString, verifyString } from '../util/json';
import { parseDataTypeValue } from '../util/lerp';
import { getRandomHexString } from '../util/random';
import { NullarySignal, Signal } from '../util/signal';
import { Uint64 } from '../util/uint64';
const DEBUG = false;
export class AnnotationReference extends RefCounted {
    constructor(id) {
        super();
        this.id = id;
        this.changed = new NullarySignal();
    }
    addRef() {
        if (DEBUG) {
            console.log('INC ref', this);
        }
        return super.addRef();
    }
    dispose() {
        if (DEBUG) {
            console.log('DEC ref', this);
            if (this.refCount === 1) {
                console.log('Deleting', this);
            }
        }
        super.dispose();
    }
}
export var AnnotationType;
(function (AnnotationType) {
    AnnotationType[AnnotationType["POINT"] = 0] = "POINT";
    AnnotationType[AnnotationType["LINE"] = 1] = "LINE";
    AnnotationType[AnnotationType["AXIS_ALIGNED_BOUNDING_BOX"] = 2] = "AXIS_ALIGNED_BOUNDING_BOX";
    AnnotationType[AnnotationType["ELLIPSOID"] = 3] = "ELLIPSOID";
    AnnotationType[AnnotationType["SPHERE"] = 4] = "SPHERE";
})(AnnotationType || (AnnotationType = {}));
export const annotationTypes = [AnnotationType.POINT, AnnotationType.LINE, AnnotationType.AXIS_ALIGNED_BOUNDING_BOX, AnnotationType.ELLIPSOID, AnnotationType.SPHERE];
export const annotationPropertyTypeHandlers = {
    'rgb': {
        serializedBytes() {
            return 3;
        },
        alignment() {
            return 1;
        },
        serializeCode(property, offset) {
            return `dv.setUint16(${offset}, ${property}, true);` + `dv.setUint8(${offset} + 2, ${property} >>> 16);`;
        },
        deserializeCode(property, offset) {
            return `${property} = dv.getUint16(${offset}, true) | (dv.getUint8(${offset} + 2) << 16);`;
        },
        deserializeJson(obj) {
            return packColor(parseRGBColorSpecification(obj));
        },
        serializeJson(value) {
            return serializeColor(unpackRGB(value));
        }
    },
    'rgba': {
        serializedBytes() {
            return 4;
        },
        alignment() {
            return 1;
        },
        serializeCode(property, offset) {
            return `dv.setUint32(${offset}, ${property}, true);`;
        },
        deserializeCode(property, offset) {
            return `${property} = dv.getUint32(${offset}, true);`;
        },
        deserializeJson(obj) {
            return packColor(parseRGBAColorSpecification(obj));
        },
        serializeJson(value) {
            return serializeColor(unpackRGBA(value));
        }
    },
    'float32': {
        serializedBytes() {
            return 4;
        },
        alignment() {
            return 4;
        },
        serializeCode(property, offset) {
            return `dv.setFloat32(${offset}, ${property}, isLittleEndian);`;
        },
        deserializeCode(property, offset) {
            return `${property} = dv.getFloat32(${offset}, isLittleEndian);`;
        },
        deserializeJson(obj) {
            return verifyFloat(obj);
        },
        serializeJson(value) {
            return value;
        }
    },
    'uint32': {
        serializedBytes() {
            return 4;
        },
        alignment() {
            return 4;
        },
        serializeCode(property, offset) {
            return `dv.setUint32(${offset}, ${property}, isLittleEndian);`;
        },
        deserializeCode(property, offset) {
            return `${property} = dv.getUint32(${offset}, isLittleEndian);`;
        },
        deserializeJson(obj) {
            return verifyInt(obj);
        },
        serializeJson(value) {
            return value;
        }
    },
    'int32': {
        serializedBytes() {
            return 4;
        },
        alignment() {
            return 4;
        },
        serializeCode(property, offset) {
            return `dv.setInt32(${offset}, ${property}, isLittleEndian);`;
        },
        deserializeCode(property, offset) {
            return `${property} = dv.getInt32(${offset}, isLittleEndian);`;
        },
        deserializeJson(obj) {
            return verifyInt(obj);
        },
        serializeJson(value) {
            return value;
        }
    },
    'uint16': {
        serializedBytes() {
            return 2;
        },
        alignment() {
            return 2;
        },
        serializeCode(property, offset) {
            return `dv.setUint16(${offset}, ${property}, isLittleEndian);`;
        },
        deserializeCode(property, offset) {
            return `${property} = dv.getUint16(${offset}, isLittleEndian);`;
        },
        deserializeJson(obj) {
            return verifyInt(obj);
        },
        serializeJson(value) {
            return value;
        }
    },
    'int16': {
        serializedBytes() {
            return 2;
        },
        alignment() {
            return 2;
        },
        serializeCode(property, offset) {
            return `dv.setInt16(${offset}, ${property}, isLittleEndian);`;
        },
        deserializeCode(property, offset) {
            return `${property} = dv.getInt16(${offset}, isLittleEndian);`;
        },
        deserializeJson(obj) {
            return verifyInt(obj);
        },
        serializeJson(value) {
            return value;
        }
    },
    'uint8': {
        serializedBytes() {
            return 1;
        },
        alignment() {
            return 1;
        },
        serializeCode(property, offset) {
            return `dv.setUint8(${offset}, ${property});`;
        },
        deserializeCode(property, offset) {
            return `${property} = dv.getUint8(${offset});`;
        },
        deserializeJson(obj) {
            return verifyInt(obj);
        },
        serializeJson(value) {
            return value;
        }
    },
    'int8': {
        serializedBytes() {
            return 2;
        },
        alignment() {
            return 1;
        },
        serializeCode(property, offset) {
            return `dv.setInt8(${offset}, ${property});`;
        },
        deserializeCode(property, offset) {
            return `${property} = dv.getInt8(${offset});`;
        },
        deserializeJson(obj) {
            return verifyInt(obj);
        },
        serializeJson(value) {
            return value;
        }
    }
};
// Maximum stride value supported by WebGL.
const MAX_BUFFER_STRIDE = 255;
export function getPropertyOffsets(rank, firstGroupInitialOffset, propertySpecs) {
    let serializedBytes = 0;
    const numProperties = propertySpecs.length;
    const permutation = new Array(numProperties);
    const propertyGroupBytes = [];
    for (let i = 0; i < numProperties; ++i) {
        permutation[i] = i;
    }
    const getAlignment = i => annotationPropertyTypeHandlers[propertySpecs[i].type].alignment(rank);
    permutation.sort((i, j) => getAlignment(j) - getAlignment(i));
    let propertyGroupIndex = 0;
    const offsets = new Array(numProperties);
    let propertyGroupOffset = firstGroupInitialOffset;
    const nextPropertyGroup = () => {
        propertyGroupOffset += (4 - propertyGroupOffset % 4) % 4;
        serializedBytes += propertyGroupOffset;
        propertyGroupBytes[propertyGroupIndex] = propertyGroupOffset;
        propertyGroupOffset = 0;
        ++propertyGroupIndex;
    };
    for (let outputIndex = 0; outputIndex < numProperties; ++outputIndex) {
        const propertyIndex = permutation[outputIndex];
        const spec = propertySpecs[propertyIndex];
        const handler = annotationPropertyTypeHandlers[spec.type];
        const numBytes = handler.serializedBytes(rank);
        const alignment = handler.alignment(rank);
        // Check if the property fits in the current property group.
        const alignmentOffset = (alignment - propertyGroupOffset % alignment) % alignment;
        const newStartOffset = propertyGroupOffset + alignmentOffset;
        const newEndOffset = newStartOffset + numBytes;
        const newAlignedEndOffset = newEndOffset + (4 - newEndOffset % 4) % 4;
        if (newAlignedEndOffset <= MAX_BUFFER_STRIDE) {
            // Property fits
            propertyGroupOffset += alignmentOffset;
        } else {
            // Property does not fit.
            nextPropertyGroup();
        }
        offsets[propertyIndex] = { offset: propertyGroupOffset, group: propertyGroupIndex };
        propertyGroupOffset += numBytes;
    }
    nextPropertyGroup();
    return { serializedBytes, offsets, propertyGroupBytes };
}
export class AnnotationPropertySerializer {
    constructor(rank, firstGroupInitialOffset, propertySpecs) {
        this.rank = rank;
        this.firstGroupInitialOffset = firstGroupInitialOffset;
        this.propertySpecs = propertySpecs;
        if (propertySpecs.length === 0) {
            this.serializedBytes = firstGroupInitialOffset;
            this.serialize = this.deserialize = () => {};
            this.propertyGroupBytes = [firstGroupInitialOffset];
            return;
        }

        var _getPropertyOffsets = getPropertyOffsets(rank, firstGroupInitialOffset, propertySpecs);

        const serializedBytes = _getPropertyOffsets.serializedBytes,
              offsets = _getPropertyOffsets.offsets,
              propertyGroupBytes = _getPropertyOffsets.propertyGroupBytes;

        this.propertyGroupBytes = propertyGroupBytes;
        let groupOffsetCode = 'let groupOffset0 = offset;';
        for (let groupIndex = 1; groupIndex < propertyGroupBytes.length; ++groupIndex) {
            groupOffsetCode += `let groupOffset${groupIndex} = groupOffset${groupIndex - 1} + ${propertyGroupBytes[groupIndex - 1]}*annotationCount;`;
        }
        for (let groupIndex = 0; groupIndex < propertyGroupBytes.length; ++groupIndex) {
            groupOffsetCode += `groupOffset${groupIndex} += ${propertyGroupBytes[groupIndex]}*annotationIndex;`;
        }
        let serializeCode = groupOffsetCode;
        let deserializeCode = groupOffsetCode;
        const numProperties = propertySpecs.length;
        for (let propertyIndex = 0; propertyIndex < numProperties; ++propertyIndex) {
            var _offsets$propertyInde = offsets[propertyIndex];
            const group = _offsets$propertyInde.group,
                  offset = _offsets$propertyInde.offset;

            const spec = propertySpecs[propertyIndex];
            const handler = annotationPropertyTypeHandlers[spec.type];
            const propId = `properties[${propertyIndex}]`;
            const offsetExpr = `groupOffset${group} + ${offset}`;
            serializeCode += handler.serializeCode(propId, offsetExpr, rank);
            deserializeCode += handler.deserializeCode(propId, offsetExpr, rank);
        }
        this.serializedBytes = serializedBytes;
        this.serialize = new Function('dv', 'offset', 'annotationIndex', 'annotationCount', 'isLittleEndian', 'properties', serializeCode);
        this.deserialize = new Function('dv', 'offset', 'annotationIndex', 'annotationCount', 'isLittleEndian', 'properties', deserializeCode);
    }
}
export function makeAnnotationPropertySerializers(rank, propertySpecs) {
    const serializers = [];
    for (const annotationType of annotationTypes) {
        const handler = annotationTypeHandlers[annotationType];
        serializers[annotationType] = new AnnotationPropertySerializer(rank, handler.serializedBytes(rank), propertySpecs);
    }
    return serializers;
}
export function formatNumericProperty(property, value) {
    const formattedValue = property.type === 'float32' ? value.toPrecision(6) : value.toString();
    const enumValues = property.enumValues,
          enumLabels = property.enumLabels;

    if (enumValues !== undefined) {
        const enumIndex = enumValues.indexOf(value);
        if (enumIndex !== -1) {
            return `${enumLabels[enumIndex]} (${formattedValue})`;
        }
    }
    return formattedValue;
}
export function formatAnnotationPropertyValue(property, value) {
    switch (property.type) {
        case 'rgb':
            return serializeColor(unpackRGB(value));
        case 'rgba':
            return serializeColor(unpackRGBA(value));
        default:
            return formatNumericProperty(property, value);
    }
}
export function parseAnnotationPropertyId(obj) {
    const s = verifyString(obj);
    if (s.match(/^[a-z][a-zA-Z0-9_]*$/) === null) {
        throw new Error(`Invalid property identifier: ${_JSON$stringify(obj)}`);
    }
    return s;
}
export function parseAnnotationPropertyType(obj) {
    verifyString(obj);
    if (!Object.prototype.hasOwnProperty.call(annotationPropertyTypeHandlers, obj)) {
        throw new Error(`Unsupported property type: $JSON.stringify(obj)}`);
    }
    return obj;
}
export function ensureUniqueAnnotationPropertyIds(properties) {
    const ids = new _Set();
    for (const p of properties) {
        if (ids.has(p.identifier)) {
            throw new Error(`Duplicate property identifier: ${p.identifier}`);
        }
        ids.add(p.identifier);
    }
}
function parseAnnotationPropertySpec(obj) {
    verifyObject(obj);
    const identifier = verifyObjectProperty(obj, 'id', parseAnnotationPropertyId);
    const type = verifyObjectProperty(obj, 'type', parseAnnotationPropertyType);
    const description = verifyOptionalObjectProperty(obj, 'description', verifyString);
    let defaultValue = verifyOptionalObjectProperty(obj, 'default', x => annotationPropertyTypeHandlers[type].deserializeJson(x), 0);
    let enumValues;
    let enumLabels;
    switch (type) {
        case 'rgb':
        case 'rgba':
            break;
        default:
            {
                const dataType = DataType[type.toUpperCase()];
                enumValues = verifyOptionalObjectProperty(obj, 'enum_values', valuesObj => parseArray(valuesObj, x => parseDataTypeValue(dataType, x)));
                if (enumValues !== undefined) {
                    enumLabels = verifyObjectProperty(obj, 'enum_labels', labelsObj => parseFixedLengthArray(new Array(enumValues.length), labelsObj, verifyString));
                }
            }
    }
    return { type, identifier, description, default: defaultValue, enumValues, enumLabels };
}
function annotationPropertySpecToJson(spec) {
    const defaultValue = spec.default;
    return {
        id: spec.identifier,
        description: spec.description,
        type: spec.type,
        default: defaultValue === 0 ? undefined : annotationPropertyTypeHandlers[spec.type].serializeJson(defaultValue)
    };
}
export function annotationPropertySpecsToJson(specs) {
    if (specs === undefined || specs.length === 0) return undefined;
    return specs.map(annotationPropertySpecToJson);
}
export function parseAnnotationPropertySpecs(obj) {
    if (obj === undefined) return [];
    const properties = parseArray(obj, parseAnnotationPropertySpec);
    ensureUniqueAnnotationPropertyIds(properties);
    return properties;
}
function serializeFloatVector(buffer, offset, isLittleEndian, rank, vec) {
    for (let i = 0; i < rank; ++i) {
        buffer.setFloat32(offset, vec[i], isLittleEndian);
        offset += 4;
    }
    return offset;
}
function serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, vecA, vecB) {
    offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, vecA);
    offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, vecB);
    return offset;
}
function deserializeFloatVector(buffer, offset, isLittleEndian, rank, vec) {
    for (let i = 0; i < rank; ++i) {
        vec[i] = buffer.getFloat32(offset, isLittleEndian);
        offset += 4;
    }
    return offset;
}
function deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, vecA, vecB) {
    offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, vecA);
    offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, vecB);
    return offset;
}
export const annotationTypeHandlers = {
    [AnnotationType.LINE]: {
        icon: 'ꕹ',
        description: 'Line',
        toJSON(annotation) {
            return {
                pointA: _Array$from(annotation.pointA),
                pointB: _Array$from(annotation.pointB)
            };
        },
        restoreState(annotation, obj, rank) {
            annotation.pointA = verifyObjectProperty(obj, 'pointA', x => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
            annotation.pointB = verifyObjectProperty(obj, 'pointB', x => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
        },
        serializedBytes(rank) {
            return 2 * 4 * rank;
        },
        serialize(buffer, offset, isLittleEndian, rank, annotation) {
            serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.pointA, annotation.pointB);
        },
        deserialize: (buffer, offset, isLittleEndian, rank, id) => {
            const pointA = new Float32Array(rank);
            const pointB = new Float32Array(rank);
            deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, pointA, pointB);
            return { type: AnnotationType.LINE, pointA, pointB, id, properties: [] };
        },
        visitGeometry(annotation, callback) {
            callback(annotation.pointA, false);
            callback(annotation.pointB, false);
        }
    },
    [AnnotationType.SPHERE]: {
        icon: '⊖',
        description: 'Sphere',
        toJSON(annotation) {
            return {
                pointA: _Array$from(annotation.pointA),
                pointB: _Array$from(annotation.pointB)
            };
        },
        restoreState(annotation, obj, rank) {
            annotation.pointA = verifyObjectProperty(obj, 'pointA', x => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
            annotation.pointB = verifyObjectProperty(obj, 'pointB', x => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
        },
        serializedBytes(rank) {
            return 2 * 4 * rank;
        },
        serialize(buffer, offset, isLittleEndian, rank, annotation) {
            serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.pointA, annotation.pointB);
        },
        deserialize: (buffer, offset, isLittleEndian, rank, id) => {
            const pointA = new Float32Array(rank);
            const pointB = new Float32Array(rank);
            deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, pointA, pointB);
            return { type: AnnotationType.SPHERE, pointA, pointB, id, properties: [] };
        },
        visitGeometry(annotation, callback) {
            callback(annotation.pointA, false);
            callback(annotation.pointB, false);
        }
    },
    [AnnotationType.POINT]: {
        icon: '⚬',
        description: 'Point',
        toJSON: annotation => {
            return {
                point: _Array$from(annotation.point)
            };
        },
        restoreState: (annotation, obj, rank) => {
            annotation.point = verifyObjectProperty(obj, 'point', x => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
        },
        serializedBytes: rank => rank * 4,
        serialize: (buffer, offset, isLittleEndian, rank, annotation) => {
            serializeFloatVector(buffer, offset, isLittleEndian, rank, annotation.point);
        },
        deserialize: (buffer, offset, isLittleEndian, rank, id) => {
            const point = new Float32Array(rank);
            deserializeFloatVector(buffer, offset, isLittleEndian, rank, point);
            return { type: AnnotationType.POINT, point, id, properties: [] };
        },
        visitGeometry(annotation, callback) {
            callback(annotation.point, false);
        }
    },
    [AnnotationType.AXIS_ALIGNED_BOUNDING_BOX]: {
        icon: '❑',
        description: 'Bounding Box',
        toJSON: annotation => {
            return {
                pointA: _Array$from(annotation.pointA),
                pointB: _Array$from(annotation.pointB)
            };
        },
        restoreState: (annotation, obj, rank) => {
            annotation.pointA = verifyObjectProperty(obj, 'pointA', x => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
            annotation.pointB = verifyObjectProperty(obj, 'pointB', x => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
        },
        serializedBytes: rank => 2 * 4 * rank,
        serialize(buffer, offset, isLittleEndian, rank, annotation) {
            serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.pointA, annotation.pointB);
        },
        deserialize: (buffer, offset, isLittleEndian, rank, id) => {
            const pointA = new Float32Array(rank);
            const pointB = new Float32Array(rank);
            deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, pointA, pointB);
            return { type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX, pointA, pointB, id, properties: [] };
        },
        visitGeometry(annotation, callback) {
            callback(annotation.pointA, false);
            callback(annotation.pointB, false);
        }
    },
    [AnnotationType.ELLIPSOID]: {
        icon: '◎',
        description: 'Ellipsoid',
        toJSON: annotation => {
            return {
                center: _Array$from(annotation.center),
                radii: _Array$from(annotation.radii)
            };
        },
        restoreState: (annotation, obj, rank) => {
            annotation.center = verifyObjectProperty(obj, 'center', x => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
            annotation.radii = verifyObjectProperty(obj, 'radii', x => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteNonNegativeFloat));
        },
        serializedBytes: rank => 2 * 4 * rank,
        serialize(buffer, offset, isLittleEndian, rank, annotation) {
            serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.center, annotation.radii);
        },
        deserialize: (buffer, offset, isLittleEndian, rank, id) => {
            const center = new Float32Array(rank);
            const radii = new Float32Array(rank);
            deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, center, radii);
            return { type: AnnotationType.ELLIPSOID, center, radii, id, properties: [] };
        },
        visitGeometry(annotation, callback) {
            callback(annotation.center, false);
            callback(annotation.radii, true);
        }
    }
};
export function annotationToJson(annotation, schema) {
    const result = annotationTypeHandlers[annotation.type].toJSON(annotation, schema.rank);
    result.type = AnnotationType[annotation.type].toLowerCase();
    result.id = annotation.id;
    result.description = annotation.description || undefined;
    const relatedSegments = annotation.relatedSegments;

    if (relatedSegments !== undefined && relatedSegments.some(x => x.length !== 0)) {
        result.segments = relatedSegments.map(segments => segments.map(x => x.toString()));
    }
    if (schema.properties.length !== 0) {
        const propertySpecs = schema.properties;
        result.props = annotation.properties.map((prop, i) => annotationPropertyTypeHandlers[propertySpecs[i].type].serializeJson(prop));
    }
    return result;
}
function restoreAnnotation(obj, schema, allowMissingId = false) {
    verifyObject(obj);
    const type = verifyObjectProperty(obj, 'type', x => verifyEnumString(x, AnnotationType));
    const id = verifyObjectProperty(obj, 'id', allowMissingId ? verifyOptionalString : verifyString) || makeAnnotationId();
    const relatedSegments = verifyObjectProperty(obj, 'segments', relObj => {
        if (relObj === undefined) {
            return schema.relationships.map(() => []);
        }
        const a = expectArray(relObj);
        if (a.length === 0) {
            return schema.relationships.map(() => []);
        }
        if (schema.relationships.length === 1 && !Array.isArray(a[0])) {
            return [parseArray(a, x => Uint64.parseString(x))];
        }
        return parseArray(expectArray(relObj, schema.relationships.length), segments => parseArray(segments, y => Uint64.parseString(y)));
    });
    const properties = verifyObjectProperty(obj, 'props', propsObj => {
        const propSpecs = schema.properties;
        if (propsObj === undefined) return propSpecs.map(x => x.default);
        return parseArray(expectArray(propsObj, schema.properties.length), (x, i) => annotationPropertyTypeHandlers[propSpecs[i].type].deserializeJson(x));
    });
    const result = {
        id,
        description: verifyObjectProperty(obj, 'description', verifyOptionalString),
        relatedSegments,
        properties,
        type
    };
    annotationTypeHandlers[type].restoreState(result, obj, schema.rank);
    return result;
}
export class AnnotationSource extends RefCounted {
    constructor(rank, relationships = [], properties = []) {
        super();
        this.relationships = relationships;
        this.properties = properties;
        this.annotationMap = new _Map();
        this.changed = new NullarySignal();
        this.readonly = false;
        this.childAdded = new Signal();
        this.childUpdated = new Signal();
        this.childDeleted = new Signal();
        this.childRefreshed = new NullarySignal();
        this.pending = new _Set();
        this.references = new _Map();
        this.rank_ = rank;
        this.annotationPropertySerializers = makeAnnotationPropertySerializers(rank, properties);
    }
    get rank() {
        return this.rank_;
    }
    hasNonSerializedProperties() {
        return true;
    }
    add(annotation, commit = true) {
        this.ensureUpdated();
        if (!annotation.id) {
            annotation.id = makeAnnotationId();
        } else if (this.annotationMap.has(annotation.id)) {
            throw new Error(`Annotation id already exists: ${_JSON$stringify(annotation.id)}.`);
        }
        this.annotationMap.set(annotation.id, annotation);
        this.changed.dispatch();
        this.childAdded.dispatch(annotation);
        if (!commit) {
            this.pending.add(annotation.id);
        }
        return this.getReference(annotation.id);
    }
    commit(reference) {
        this.ensureUpdated();
        const id = reference.id;
        this.pending.delete(id);
        this.changed.dispatch();
    }
    update(reference, annotation) {
        this.ensureUpdated();
        if (reference.value === null) {
            throw new Error(`Annotation already deleted.`);
        }
        reference.value = annotation;
        this.annotationMap.set(annotation.id, annotation);
        reference.changed.dispatch();
        this.changed.dispatch();
        this.childUpdated.dispatch(annotation);
    }
    [_Symbol$iterator]() {
        this.ensureUpdated();
        return this.annotationMap.values();
    }
    get(id) {
        this.ensureUpdated();
        return this.annotationMap.get(id);
    }
    delete(reference) {
        if (reference.value === null) {
            return;
        }
        reference.value = null;
        this.annotationMap.delete(reference.id);
        this.pending.delete(reference.id);
        reference.changed.dispatch();
        this.changed.dispatch();
        this.childDeleted.dispatch(reference.id);
    }
    getReference(id) {
        let existing = this.references.get(id);
        if (existing !== undefined) {
            return existing.addRef();
        }
        existing = new AnnotationReference(id);
        existing.value = this.annotationMap.get(id) || null;
        this.references.set(id, existing);
        existing.registerDisposer(() => {
            this.references.delete(id);
        });
        return existing;
    }
    ensureUpdated() {}
    toJSON() {
        this.ensureUpdated();
        const result = [];
        const pending = this.pending;

        for (const annotation of this) {
            if (pending.has(annotation.id)) {
                // Don't serialize uncommitted annotations.
                continue;
            }
            result.push(annotationToJson(annotation, this));
        }
        return result;
    }
    clear() {
        this.annotationMap.clear();
        this.pending.clear();
        this.changed.dispatch();
    }
    restoreState(obj) {
        this.ensureUpdated();
        const annotationMap = this.annotationMap;

        annotationMap.clear();
        this.pending.clear();
        if (obj !== undefined) {
            parseArray(obj, x => {
                const annotation = restoreAnnotation(x, this);
                annotationMap.set(annotation.id, annotation);
            });
        }
        for (const reference of this.references.values()) {
            const id = reference.id;

            const value = annotationMap.get(id);
            reference.value = value || null;
            reference.changed.dispatch();
        }
        this.changed.dispatch();
    }
    reset() {
        this.clear();
    }
}
export class LocalAnnotationSource extends AnnotationSource {
    constructor(watchableTransform, properties, relationships) {
        super(watchableTransform.value.sourceRank, relationships, properties);
        this.watchableTransform = watchableTransform;
        this.curCoordinateTransform = watchableTransform.value;
        this.registerDisposer(watchableTransform.changed.add(() => this.ensureUpdated()));
    }
    get rank() {
        this.ensureUpdated();
        return this.rank_;
    }
    ensureUpdated() {
        const transform = this.watchableTransform.value;
        const curCoordinateTransform = this.curCoordinateTransform;

        if (transform === curCoordinateTransform) return;
        this.curCoordinateTransform = transform;
        const sourceRank = transform.sourceRank;
        const oldSourceRank = curCoordinateTransform.sourceRank;
        if (oldSourceRank === sourceRank && (curCoordinateTransform.inputSpace === transform.inputSpace || arraysEqual(curCoordinateTransform.inputSpace.ids.slice(0, sourceRank), transform.inputSpace.ids.slice(0, sourceRank)))) {
            return;
        }
        const newIds = transform.inputSpace.ids;

        const oldIds = curCoordinateTransform.inputSpace.ids;
        const newToOldDims = [];
        for (let newDim = 0; newDim < sourceRank; ++newDim) {
            let oldDim = oldIds.indexOf(newIds[newDim]);
            if (oldDim >= oldSourceRank) {
                oldDim = -1;
            }
            newToOldDims.push(oldDim);
        }
        const mapVector = radii => {
            const newRadii = new Float32Array(sourceRank);
            for (let i = 0; i < sourceRank; ++i) {
                const oldDim = newToOldDims[i];
                newRadii[i] = oldDim === -1 ? 0 : radii[i];
            }
            return newRadii;
        };
        for (const annotation of this.annotationMap.values()) {
            switch (annotation.type) {
                case AnnotationType.POINT:
                    annotation.point = mapVector(annotation.point);
                    break;
                case AnnotationType.LINE:
                case AnnotationType.SPHERE:
                case AnnotationType.AXIS_ALIGNED_BOUNDING_BOX:
                    annotation.pointA = mapVector(annotation.pointA);
                    annotation.pointB = mapVector(annotation.pointB);
                    break;
                case AnnotationType.ELLIPSOID:
                    annotation.center = mapVector(annotation.center);
                    annotation.radii = mapVector(annotation.radii);
                    break;
            }
        }
        if (this.rank_ !== sourceRank) {
            this.rank_ = sourceRank;
            this.annotationPropertySerializers = makeAnnotationPropertySerializers(this.rank_, this.properties);
        }
        this.changed.dispatch();
    }
}
export const DATA_BOUNDS_DESCRIPTION = 'Data Bounds';
export function makeAnnotationId() {
    return getRandomHexString(160);
}
export function makeDataBoundsBoundingBoxAnnotation(box) {
    return {
        type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,
        id: 'data-bounds',
        description: DATA_BOUNDS_DESCRIPTION,
        pointA: new Float32Array(box.lowerBounds),
        pointB: new Float32Array(box.upperBounds),
        properties: []
    };
}
export function makeDataBoundsBoundingBoxAnnotationSet(box) {
    const annotationSource = new AnnotationSource(box.lowerBounds.length);
    annotationSource.readonly = true;
    annotationSource.add(makeDataBoundsBoundingBoxAnnotation(box));
    return annotationSource;
}
function serializeAnnotations(allAnnotations, propertySerializers) {
    let totalBytes = 0;
    const typeToOffset = [];
    for (const annotationType of annotationTypes) {
        const propertySerializer = propertySerializers[annotationType];
        const serializedPropertiesBytes = propertySerializer.serializedBytes;
        typeToOffset[annotationType] = totalBytes;
        const annotations = allAnnotations[annotationType];
        const count = annotations.length;
        totalBytes += serializedPropertiesBytes * count;
    }
    const typeToIds = [];
    const typeToIdMaps = [];
    const data = new ArrayBuffer(totalBytes);
    const dataView = new DataView(data);
    const isLittleEndian = ENDIANNESS === Endianness.LITTLE;
    for (const annotationType of annotationTypes) {
        const propertySerializer = propertySerializers[annotationType];
        const rank = propertySerializer.rank;

        const serializeProperties = propertySerializer.serialize;
        const annotations = allAnnotations[annotationType];
        typeToIds[annotationType] = annotations.map(x => x.id);
        typeToIdMaps[annotationType] = new _Map(annotations.map((x, i) => [x.id, i]));
        const handler = annotationTypeHandlers[annotationType];
        const serialize = handler.serialize;
        const offset = typeToOffset[annotationType];
        const geometryDataStride = propertySerializer.propertyGroupBytes[0];
        for (let i = 0, count = annotations.length; i < count; ++i) {
            const annotation = annotations[i];
            serialize(dataView, offset + i * geometryDataStride, isLittleEndian, rank, annotation);
            serializeProperties(dataView, offset, i, count, isLittleEndian, annotation.properties);
        }
    }
    return { data: new Uint8Array(data), typeToIds, typeToOffset, typeToIdMaps };
}
export class AnnotationSerializer {
    constructor(propertySerializers) {
        this.propertySerializers = propertySerializers;
        this.annotations = [[], [], [], [], []];
    }
    add(annotation) {
        this.annotations[annotation.type].push(annotation);
    }
    serialize() {
        return serializeAnnotations(this.annotations, this.propertySerializers);
    }
}
export function fixAnnotationAfterStructuredCloning(obj) {
    if (obj == null) {
        return obj;
    }
    const relatedSegments = obj.relatedSegments;

    if (relatedSegments !== undefined) {
        for (let i = 0, numRelationships = relatedSegments.length; i < numRelationships; ++i) {
            const segments = relatedSegments[i];
            if (segments === undefined) continue;
            relatedSegments[i] = segments.map(x => new Uint64(x.low, x.high));
        }
    }
    return obj;
}
//# sourceMappingURL=index.js.map