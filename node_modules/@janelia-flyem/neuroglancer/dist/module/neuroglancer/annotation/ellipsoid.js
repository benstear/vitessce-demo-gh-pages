import _Object$assign from 'babel-runtime/core-js/object/assign';
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Support for rendering ellipsoid annotations.
 */
import { AnnotationType } from './index';
import { AnnotationRenderHelper, registerAnnotationTypeRenderHandler } from './type_handler';
import { mat3, mat4, vec3 } from '../util/geom';
import { computeCenterOrientEllipseDebug, computeCrossSectionEllipseDebug, glsl_computeCenterOrientEllipse, glsl_computeCrossSectionEllipse } from '../webgl/ellipse';
import { drawQuads, glsl_getQuadVertexPosition } from '../webgl/quad';
import { defineVectorArrayVertexShaderInput } from '../webgl/shader_lib';
import { SphereRenderHelper } from '../webgl/spheres';
import { defineVertexId, VertexIdHelper } from '../webgl/vertex_id';
const tempMat4 = mat4.create();
const DEBUG = false;
class RenderHelper extends AnnotationRenderHelper {
    defineShader(builder) {
        const rank = this.rank;

        defineVectorArrayVertexShaderInput(builder, 'float', WebGL2RenderingContext.FLOAT, /*normalized=*/false, 'CenterAndRadii', rank, 2);
        builder.addVertexCode(`
struct SubspaceParams {
  highp vec3 subspaceCenter;
  highp vec3 subspaceRadii;
  highp float clipCoefficient;
  bool cull;
};
SubspaceParams getSubspaceParams() {
  SubspaceParams params;
  highp float modelCenter[${rank}] = getCenterAndRadii0();
  highp float modelRadii[${rank}] = getCenterAndRadii1();
  float radiusAdjustment = 1.0;
  float clipCoefficient = 1.0;
  for (int i = 0; i < ${rank}; ++i) {
    float r = modelRadii[i];
    float c = modelCenter[i];
    float x = uModelClipBounds[i];
    float clipRadius = uModelClipBounds[i + ${rank}];
    if (r != 0.0 && clipRadius != 0.0) {
      float d = c - x;
      d = d * d;
      radiusAdjustment -= d / (r * r);
    }
    float e = abs(x - clamp(x, c - r, c + r)) * clipRadius;
    clipCoefficient *= max(0.0, 1.0 - e);
  }
  radiusAdjustment = sqrt(max(0.0, radiusAdjustment));
  params.subspaceCenter = projectModelVectorToSubspace(modelCenter);
  params.subspaceRadii = projectModelVectorToSubspace(modelRadii) * radiusAdjustment;
  params.clipCoefficient = clipCoefficient;
  params.cull = clipCoefficient == 0.0 || radiusAdjustment == 0.0;
  return params;
}
void setEllipsoidFillColor(vec4 color) {
  vColor = color;
}
`);
    }
    enable(shaderGetter, context, callback) {
        super.enable(shaderGetter, context, shader => {
            const binder = shader.vertexShaderInputBinders['CenterAndRadii'];
            binder.enable(1);
            this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, context.buffer.buffer);
            binder.bind(this.geometryDataStride, context.bufferOffset);
            callback(shader);
            binder.disable();
        });
    }
}
/**
 * Render an ellipsoid as a transformed triangulated sphere.
 */
class PerspectiveRenderHelper extends RenderHelper {
    constructor() {
        super(...arguments);
        this.sphereRenderHelper = this.registerDisposer(new SphereRenderHelper(this.gl, 10, 10));
        this.shaderGetter = this.getDependentShader('annotation/ellipsoid/projection', builder => {
            this.defineShader(builder);
            this.sphereRenderHelper.defineShader(builder);
            builder.addUniform('highp vec4', 'uLightDirection');
            builder.addUniform('highp mat4', 'uNormalTransform');
            builder.addVarying('highp float', 'vClipCoefficient');
            builder.setVertexMain(`
SubspaceParams params = getSubspaceParams();
if (params.cull) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vClipCoefficient = params.clipCoefficient;
${this.invokeUserMain}
emitSphere(uModelViewProjection, uNormalTransform, params.subspaceCenter, params.subspaceRadii, uLightDirection);
${this.setPartIndex(builder)};
`);
            builder.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb * vLightingFactor, vColor.a * vClipCoefficient));
`);
        });
        this.tempLightVec = new Float32Array(4);
    }
    draw(context) {
        this.enable(this.shaderGetter, context, shader => {
            const gl = shader.gl;

            let lightVec = this.tempLightVec;
            var _context$renderContex = context.renderContext;
            let lightDirection = _context$renderContex.lightDirection,
                ambientLighting = _context$renderContex.ambientLighting,
                directionalLighting = _context$renderContex.directionalLighting;

            vec3.scale(lightVec, lightDirection, directionalLighting);
            lightVec[3] = ambientLighting;
            gl.uniform4fv(shader.uniform('uLightDirection'), lightVec);
            gl.uniformMatrix4fv(shader.uniform('uNormalTransform'), /*transpose=*/false, mat4.transpose(mat4.create(), context.renderSubspaceInvModelMatrix));
            this.sphereRenderHelper.draw(shader, context.count);
        });
    }
}
/**
 * Render a cross section of an ellipsoid.
 *
 * This is done using the following steps:
 *
 * Vertex shader:
 *
 * 1. We transform the ellipsoid parameters to the cross section coordinate frame (with the z
 *    axis corresponding to the plane normal).
 *
 * 2. We then compute the quadratic form parameters of the ellipse corresponding to the intersection
 *    of the ellipsoid with the `z=0` plane.
 *
 * 3. We convert the quadratic form parameterization into the center-orient parameterization.
 *
 * 4. The vertex shader emits the 4 vertices of the bounding box of the ellipse, equal to:
 *
 *      `k +/- a*u1 +/- b*u2`,
 *
 *    where `k` is the center of the ellipse, `u1` and `u2` are the major and minor axis directions
 *    respectively, and `a` and `b` are the semi-major and semi-minor axis lengths, respectively.
 *    These four vertices are used to draw a quad (two triangles).
 *
 * Fragment shader:
 *
 * 5. The fragment shader discards fragments outside the bounds of the ellipse.
 */
class SliceViewRenderHelper extends RenderHelper {
    constructor() {
        super(...arguments);
        this.shaderGetter = this.getDependentShader('annotation/ellipsoid/crossSection', builder => {
            defineVertexId(builder);
            this.defineShader(builder);
            builder.addUniform('highp mat4', 'uViewportToObject');
            builder.addUniform('highp mat4', 'uObjectToViewport');
            builder.addUniform('highp mat4', 'uViewportToDevice');
            builder.addAttribute('highp vec2', 'aCornerOffset');
            builder.addVarying('highp vec2', 'vCircleCoord');
            builder.addVarying('highp float', 'vClipCoefficient');
            builder.addVertexCode(glsl_computeCrossSectionEllipse);
            builder.addVertexCode(glsl_computeCenterOrientEllipse);
            builder.addVertexCode(glsl_getQuadVertexPosition);
            builder.setVertexMain(`
SubspaceParams params = getSubspaceParams();
if (params.cull) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vClipCoefficient = params.clipCoefficient;
mat3 Aobject = mat3(0.0);
for (int i = 0; i < 3; ++i) {
  float r = max(params.subspaceRadii[i], 1e-3);
  Aobject[i][i] = 1.0 / (r * r);
}
mat3 RviewportToObject = mat3(uViewportToObject);
mat3 Aviewport = transpose(RviewportToObject) * Aobject * RviewportToObject;
vec3 cViewport = (uObjectToViewport * vec4(params.subspaceCenter, 1.0)).xyz;
EllipseQuadraticForm quadraticForm = computeCrossSectionEllipse(Aviewport, cViewport);
vec2 u1, u2;
float a, b;
CenterOrientEllipse centerOrient = computeCenterOrientEllipse(quadraticForm);
vec2 cornerOffset = getQuadVertexPosition(vec2(-1.0, -1.0), vec2(1.0, 1.0));
vec2 viewportCorner = centerOrient.k +
  centerOrient.u1 * cornerOffset.x * centerOrient.a +
  centerOrient.u2 * cornerOffset.y * centerOrient.b;
if (centerOrient.valid) {
  gl_Position = uViewportToDevice * vec4(viewportCorner, 0.0, 1.0);
} else {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
}
vCircleCoord = cornerOffset;
${this.invokeUserMain}
${this.setPartIndex(builder)};
`);
            builder.setFragmentMain(`
if (dot(vCircleCoord, vCircleCoord) > 1.0) {
  discard;
}
emitAnnotation(vec4(vColor.rgb, vColor.a * vClipCoefficient));
`);
        });
        this.vertexIdHelper = this.registerDisposer(VertexIdHelper.get(this.gl));
    }
    draw(context) {
        this.enable(this.shaderGetter, context, shader => {
            const gl = shader.gl;

            const projectionParameters = context.renderContext.sliceView.projectionParameters.value;
            const viewportToObject = mat4.multiply(tempMat4, context.renderSubspaceInvModelMatrix, projectionParameters.invViewMatrix);
            gl.uniformMatrix4fv(shader.uniform('uViewportToObject'), /*transpose=*/false, viewportToObject);
            gl.uniformMatrix4fv(shader.uniform('uViewportToDevice'), /*transpose=*/false, projectionParameters.projectionMat);
            const objectToViewport = tempMat4;
            mat4.invert(objectToViewport, viewportToObject);
            gl.uniformMatrix4fv(shader.uniform('uObjectToViewport'), /*transpose=*/false, objectToViewport);
            const vertexIdHelper = this.vertexIdHelper;

            vertexIdHelper.enable();
            drawQuads(gl, 1, context.count);
            vertexIdHelper.disable();
            if (DEBUG) {
                const center = vec3.fromValues(3406.98779296875, 3234.910400390625, 4045);
                const radii = vec3.fromValues(10, 10, 10);
                const Aobject = mat3.create();
                Aobject[0] = 1 / (radii[0] * radii[0]);
                Aobject[4] = 1 / (radii[1] * radii[1]);
                Aobject[8] = 1 / (radii[2] * radii[2]);
                const RviewportToObject = mat3.fromMat4(mat3.create(), viewportToObject);
                const Aviewport = mat3.multiply(mat3.create(), mat3.transpose(mat3.create(), RviewportToObject), Aobject);
                mat3.multiply(Aviewport, Aviewport, RviewportToObject);
                const cViewport = vec3.transformMat4(vec3.create(), center, objectToViewport);
                console.log('Aviewport', Aviewport);
                console.log('cViewport', cViewport);
                const p = computeCrossSectionEllipseDebug(Aviewport, cViewport);
                const centerOrient = computeCenterOrientEllipseDebug(p);
                console.log(p);
                console.log(centerOrient);
            }
        });
    }
}
registerAnnotationTypeRenderHandler(AnnotationType.ELLIPSOID, {
    sliceViewRenderHelper: SliceViewRenderHelper,
    perspectiveViewRenderHelper: PerspectiveRenderHelper,
    defineShaderNoOpSetters(builder) {
        builder.addVertexCode(`
void setEllipsoidFillColor(vec4 color) {}
`);
    },
    pickIdsPerInstance: 1,
    snapPosition: () => /*position, annotation, partIndex*/{
        // FIXME: snap to nearest point on ellipsoid surface
    },
    getRepresentativePoint(position, ann) {
        position.set(ann.center);
    },
    updateViaRepresentativePoint(oldAnnotation, position) {
        return _Object$assign(_Object$assign({}, oldAnnotation), { center: new Float32Array(position) });
    }
});
//# sourceMappingURL=ellipsoid.js.map