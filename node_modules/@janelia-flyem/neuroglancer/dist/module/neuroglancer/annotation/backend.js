import _Object$assign from "babel-runtime/core-js/object/assign";
import _Set from "babel-runtime/core-js/set";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import { fixAnnotationAfterStructuredCloning } from "./index";
import { ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, ANNOTATION_COMMIT_UPDATE_RPC_ID, ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID, ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, ANNOTATION_REFERENCE_ADD_RPC_ID, ANNOTATION_REFERENCE_DELETE_RPC_ID, ANNOTATION_RENDER_LAYER_RPC_ID, ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID, ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID, ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID, forEachVisibleAnnotationChunk } from "./base";
import { Chunk, ChunkRenderLayerBackend, ChunkSource, withChunkManager } from "../chunk_manager/backend";
import { ChunkPriorityTier, ChunkState } from "../chunk_manager/base";
import { displayDimensionRenderInfosEqual } from "../navigation_state";
import { RenderLayerBackend } from "../render_layer_backend";
import { receiveVisibleSegmentsState } from "../segmentation_display_state/backend";
import { forEachVisibleSegment, getObjectKey, onTemporaryVisibleSegmentsStateChanged, onVisibleSegmentsStateChanged } from "../segmentation_display_state/base";
import { deserializeTransformedSources, SCALE_PRIORITY_MULTIPLIER, SliceViewChunk, SliceViewChunkSourceBackend } from "../sliceview/backend";
import { registerNested, WatchableValue } from "../trackable_value";
import { getBasePriority, getPriorityTier, withSharedVisibility } from "../visibility_priority/backend";
import { registerRPC, registerSharedObject, SharedObjectCounterpart } from "../worker_rpc";
const ANNOTATION_METADATA_CHUNK_PRIORITY = 200;
const ANNOTATION_SEGMENT_FILTERED_CHUNK_PRIORITY = 60;
export class AnnotationMetadataChunk extends Chunk {
    freeSystemMemory() {
        this.annotation = undefined;
    }
    serialize(msg, transfers) {
        super.serialize(msg, transfers);
        msg.annotation = this.annotation;
    }
    downloadSucceeded() {
        this.systemMemoryBytes = this.gpuMemoryBytes = 0;
        super.downloadSucceeded();
    }
}
export class AnnotationGeometryData {
    serialize(msg, transfers) {
        msg.data = this.data;
        msg.typeToOffset = this.typeToOffset;
        msg.typeToIds = this.typeToIds;
        msg.typeToIdMaps = this.typeToIdMaps;
        transfers.push(this.data.buffer);
    }
    get numBytes() {
        return this.data.byteLength;
    }
}
function GeometryChunkMixin(Base) {
    class C extends Base {
        serialize(msg, transfers) {
            super.serialize(msg, transfers);
            const data = this.data;

            if (data !== undefined) {
                data.serialize(msg, transfers);
                this.data = undefined;
            }
        }
        downloadSucceeded() {
            const data = this.data;

            this.systemMemoryBytes = this.gpuMemoryBytes = data === undefined ? 0 : data.numBytes;
            super.downloadSucceeded();
        }
        freeSystemMemory() {
            this.data = undefined;
        }
    }
    return C;
}
export class AnnotationGeometryChunk extends GeometryChunkMixin(SliceViewChunk) {}
export class AnnotationSubsetGeometryChunk extends GeometryChunkMixin(Chunk) {}
let AnnotationMetadataChunkSource = class AnnotationMetadataChunkSource extends ChunkSource {
    constructor() {
        super(...arguments);
        this.parent = undefined;
    }
    getChunk(id) {
        const chunks = this.chunks;

        let chunk = chunks.get(id);
        if (chunk === undefined) {
            chunk = this.getNewChunk_(AnnotationMetadataChunk);
            chunk.initialize(id);
            this.addChunk(chunk);
        }
        return chunk;
    }
    download(chunk, cancellationToken) {
        return this.parent.downloadMetadata(chunk, cancellationToken);
    }
};
AnnotationMetadataChunkSource = __decorate([registerSharedObject(ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID)], AnnotationMetadataChunkSource);
export class AnnotationGeometryChunkSourceBackend extends SliceViewChunkSourceBackend {
    constructor(rpc, options) {
        super(rpc, options);
        this.parent = rpc.get(options.parent);
    }
}
AnnotationGeometryChunkSourceBackend.prototype.chunkConstructor = AnnotationGeometryChunk;
let AnnotationSubsetGeometryChunkSource = class AnnotationSubsetGeometryChunkSource extends ChunkSource {
    constructor() {
        super(...arguments);
        this.parent = undefined;
    }
    getChunk(objectId) {
        const key = getObjectKey(objectId);
        const chunks = this.chunks;

        let chunk = chunks.get(key);
        if (chunk === undefined) {
            chunk = this.getNewChunk_(AnnotationSubsetGeometryChunk);
            chunk.initialize(key);
            chunk.objectId = objectId.clone();
            this.addChunk(chunk);
        }
        return chunk;
    }
    download(chunk, cancellationToken) {
        return this.parent.downloadSegmentFilteredGeometry(chunk, this.relationshipIndex, cancellationToken);
    }
};
AnnotationSubsetGeometryChunkSource = __decorate([registerSharedObject(ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID)], AnnotationSubsetGeometryChunkSource);
export class AnnotationSource extends SharedObjectCounterpart {
    constructor(rpc, options) {
        super(rpc, options);
        this.references = new _Set();
        const chunkManager = this.chunkManager = rpc.get(options.chunkManager);
        const metadataChunkSource = this.metadataChunkSource = this.registerDisposer(rpc.getRef(options.metadataChunkSource));
        this.segmentFilteredSources = options.segmentFilteredSource.map((x, i) => {
            const source = this.registerDisposer(rpc.getRef(x));
            source.parent = this;
            source.relationshipIndex = i;
            return source;
        });
        metadataChunkSource.parent = this;
        this.registerDisposer(chunkManager.recomputeChunkPriorities.add(() => this.recomputeChunkPriorities()));
    }
    recomputeChunkPriorities() {
        const chunkManager = this.chunkManager,
              metadataChunkSource = this.metadataChunkSource;

        for (const id of this.references) {
            chunkManager.requestChunk(metadataChunkSource.getChunk(id), ChunkPriorityTier.VISIBLE, ANNOTATION_METADATA_CHUNK_PRIORITY);
        }
    }
    add(annotation) {
        annotation;
        throw new Error('Not implemented');
    }
    delete(id) {
        id;
        throw new Error('Not implemented');
    }
    update(id, newAnnotation) {
        id;
        newAnnotation;
        throw new Error('Not implemented');
    }
}
registerRPC(ANNOTATION_REFERENCE_ADD_RPC_ID, function (x) {
    const obj = this.get(x.id);
    obj.references.add(x.annotation);
    obj.chunkManager.scheduleUpdateChunkPriorities();
});
registerRPC(ANNOTATION_REFERENCE_DELETE_RPC_ID, function (x) {
    const obj = this.get(x.id);
    obj.references.delete(x.annotation);
    obj.chunkManager.scheduleUpdateChunkPriorities();
});
registerRPC(ANNOTATION_COMMIT_UPDATE_RPC_ID, function (x) {
    const obj = this.get(x.id);
    const annotationId = x.annotationId;
    const newAnnotation = fixAnnotationAfterStructuredCloning(x.newAnnotation);
    let promise;
    if (annotationId === undefined) {
        promise = obj.add(newAnnotation).then(id => _Object$assign(_Object$assign({}, newAnnotation), { id }));
    } else if (newAnnotation === null) {
        promise = obj.delete(annotationId).then(() => null);
    } else {
        promise = obj.update(annotationId, newAnnotation).then(() => newAnnotation);
    }
    // FIXME: Handle new chunks requested prior to update but not yet sent to frontend.
    promise.then(result => {
        if (!obj.wasDisposed) {
            this.invoke(ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, {
                id: obj.rpcId,
                annotationId: annotationId || newAnnotation.id,
                newAnnotation: result
            });
        }
    }, error => {
        if (!obj.wasDisposed) {
            this.invoke(ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, {
                id: obj.rpcId,
                annotationId: annotationId || newAnnotation && newAnnotation.id,
                error: error.message
            });
        }
    });
});
let AnnotationSpatiallyIndexedRenderLayerBackend = class AnnotationSpatiallyIndexedRenderLayerBackend extends withChunkManager(RenderLayerBackend) {
    constructor(rpc, options) {
        super(rpc, options);
        this.renderScaleTarget = rpc.get(options.renderScaleTarget);
        this.localPosition = rpc.get(options.localPosition);
        const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
        this.registerDisposer(this.localPosition.changed.add(scheduleUpdateChunkPriorities));
        this.registerDisposer(this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities));
        this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => this.recomputeChunkPriorities()));
    }
    attach(attachment) {
        const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
        const view = attachment.view;

        attachment.registerDisposer(scheduleUpdateChunkPriorities);
        attachment.registerDisposer(view.projectionParameters.changed.add(scheduleUpdateChunkPriorities));
        attachment.registerDisposer(view.visibility.changed.add(scheduleUpdateChunkPriorities));
        attachment.state = {
            displayDimensionRenderInfo: view.projectionParameters.value.displayDimensionRenderInfo,
            transformedSources: []
        };
    }
    recomputeChunkPriorities() {
        this.chunkManager.registerLayer(this);
        for (const attachment of this.attachments.values()) {
            const view = attachment.view;

            const visibility = view.visibility.value;
            if (visibility === Number.NEGATIVE_INFINITY) {
                continue;
            }
            const attachmentState = attachment.state;
            const transformedSources = attachmentState.transformedSources,
                  displayDimensionRenderInfo = attachmentState.displayDimensionRenderInfo;

            if (transformedSources.length === 0) continue;
            const viewDisplayDimensionRenderInfo = view.projectionParameters.value.displayDimensionRenderInfo;
            if (displayDimensionRenderInfo !== viewDisplayDimensionRenderInfo) {
                if (!displayDimensionRenderInfosEqual(displayDimensionRenderInfo, viewDisplayDimensionRenderInfo)) {
                    continue;
                }
                attachmentState.displayDimensionRenderInfo = viewDisplayDimensionRenderInfo;
            }
            const priorityTier = getPriorityTier(visibility);
            const basePriority = getBasePriority(visibility);
            const projectionParameters = view.projectionParameters.value;
            const chunkManager = this.chunkManager;

            forEachVisibleAnnotationChunk(projectionParameters, this.localPosition.value, this.renderScaleTarget.value, transformedSources[0], () => {}, (tsource, scaleIndex) => {
                const chunk = tsource.source.getChunk(tsource.curPositionInChunks);
                ++this.numVisibleChunksNeeded;
                // FIXME: calculate priority
                if (chunk.state === ChunkState.GPU_MEMORY) {
                    ++this.numVisibleChunksAvailable;
                }
                let priority = 0;
                chunkManager.requestChunk(chunk, priorityTier, basePriority + priority + SCALE_PRIORITY_MULTIPLIER * scaleIndex);
            });
        }
    }
};
AnnotationSpatiallyIndexedRenderLayerBackend = __decorate([registerSharedObject(ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID)], AnnotationSpatiallyIndexedRenderLayerBackend);
AnnotationSpatiallyIndexedRenderLayerBackend;
registerRPC(ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, function (x) {
    const view = this.get(x.view);
    const layer = this.get(x.layer);
    const attachment = layer.attachments.get(view);
    attachment.state.transformedSources = deserializeTransformedSources(this, x.sources, layer);
    attachment.state.displayDimensionRenderInfo = x.displayDimensionRenderInfo;
    layer.chunkManager.scheduleUpdateChunkPriorities();
});
let AnnotationLayerSharedObjectCounterpart = class AnnotationLayerSharedObjectCounterpart extends withSharedVisibility(withChunkManager(ChunkRenderLayerBackend)) {
    constructor(rpc, options) {
        super(rpc, options);
        this.source = rpc.get(options.source);
        this.segmentationStates = new WatchableValue(this.getSegmentationState(options.segmentationStates));
        const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
        this.registerDisposer(registerNested((context, states) => {
            if (states === undefined) return;
            for (const state of states) {
                if (state == null) continue;
                onVisibleSegmentsStateChanged(context, state, scheduleUpdateChunkPriorities);
                onTemporaryVisibleSegmentsStateChanged(context, state, scheduleUpdateChunkPriorities);
            }
            scheduleUpdateChunkPriorities();
        }, this.segmentationStates));
        this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => this.recomputeChunkPriorities()));
    }
    recomputeChunkPriorities() {
        const visibility = this.visibility.value;
        if (visibility === Number.NEGATIVE_INFINITY) {
            return;
        }
        const states = this.segmentationStates.value,
              segmentFilteredSources = this.source.segmentFilteredSources;

        if (states === undefined) return;
        const chunkManager = this.chunkManager;

        chunkManager.registerLayer(this);
        const numRelationships = states.length;
        for (let i = 0; i < numRelationships; ++i) {
            const state = states[i];
            if (state == null) {
                continue;
            }
            const priorityTier = getPriorityTier(visibility);
            const basePriority = getBasePriority(visibility);
            const source = segmentFilteredSources[i];
            forEachVisibleSegment(state, objectId => {
                const chunk = source.getChunk(objectId);
                ++this.numVisibleChunksNeeded;
                if (chunk.state === ChunkState.GPU_MEMORY) {
                    ++this.numVisibleChunksAvailable;
                }
                chunkManager.requestChunk(chunk, priorityTier, basePriority + ANNOTATION_SEGMENT_FILTERED_CHUNK_PRIORITY);
            });
        }
    }
    getSegmentationState(msg) {
        if (msg === undefined) return undefined;
        return msg.map(x => {
            if (x == null) {
                return x;
            }
            return receiveVisibleSegmentsState(this.rpc, x);
        });
    }
};
AnnotationLayerSharedObjectCounterpart = __decorate([registerSharedObject(ANNOTATION_RENDER_LAYER_RPC_ID)], AnnotationLayerSharedObjectCounterpart);
AnnotationLayerSharedObjectCounterpart;
registerRPC(ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID, function (x) {
    const obj = this.get(x.id);
    obj.segmentationStates.value = obj.getSegmentationState(x.segmentationStates);
});
//# sourceMappingURL=backend.js.map