import _getIterator from 'babel-runtime/core-js/get-iterator';
import _Symbol$iterator from 'babel-runtime/core-js/symbol/iterator';
import _Set from 'babel-runtime/core-js/set';
import _Object$keys from 'babel-runtime/core-js/object/keys';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import debounce from 'lodash/debounce';
import { invokeDisposers, RefCounted } from './util/disposable';
import { neverSignal, NullarySignal, Signal } from './util/signal';
export class WatchableValue {
    constructor(value_) {
        this.value_ = value_;
        this.changed = new NullarySignal();
    }
    get value() {
        return this.value_;
    }
    set value(newValue) {
        if (newValue !== this.value_) {
            this.value_ = newValue;
            this.changed.dispatch();
        }
    }
}
export class TrackableValue extends WatchableValue {
    constructor(value, validator, defaultValue = value) {
        super(value);
        this.validator = validator;
        this.defaultValue = defaultValue;
    }
    toJSON() {
        let value_ = this.value_;

        if (value_ === this.defaultValue) {
            return undefined;
        }
        return this.value_;
    }
    reset() {
        this.value = this.defaultValue;
    }
    restoreState(x) {
        if (x !== undefined) {
            let validator = this.validator;

            try {
                this.value = validator(x);
                return;
            } catch (ignoredError) {}
        }
        this.value = this.defaultValue;
    }
}
class DerivedWatchableValue extends RefCounted {
    constructor(f, ws) {
        super();
        this.changed = new NullarySignal();
        this.f = f;
        this.ws = ws;
        for (const w of ws) {
            this.registerDisposer(w.changed.add(this.changed.dispatch));
        }
    }
    get value() {
        return this.f(...this.ws.map(w => w.value));
    }
}
export function makeDerivedWatchableValue(f, ...ws) {
    return new DerivedWatchableValue(f, ws);
}
class CachedLazyDerivedWatchableValue extends RefCounted {
    constructor(f, ws) {
        super();
        this.changed = new NullarySignal();
        this.valueGeneration = -1;
        this.f = f;
        this.ws = ws;
        for (const w of ws) {
            this.registerDisposer(w.changed.add(this.changed.dispatch));
        }
    }
    get value() {
        const generation = this.changed.count;
        if (generation !== this.valueGeneration) {
            this.value_ = this.f(...this.ws.map(w => w.value));
            this.valueGeneration = generation;
        }
        return this.value_;
    }
}
export function makeCachedLazyDerivedWatchableValue(f, ...ws) {
    return new CachedLazyDerivedWatchableValue(f, ws);
}
export class CachedWatchableValue extends RefCounted {
    constructor(base, isEqual = (a, b) => a === b) {
        super();
        this.changed = new Signal();
        this.value = base.value;
        this.registerDisposer(base.changed.add(() => {
            const newValue = base.value;
            if (!isEqual(this.value, newValue)) {
                this.value = newValue;
                this.changed.dispatch();
            }
        }));
    }
}
export function makeCachedDerivedWatchableValue(f, ws, isEqual) {
    const derived = new DerivedWatchableValue(f, ws);
    const cached = new CachedWatchableValue(derived, isEqual);
    cached.registerDisposer(derived);
    return cached;
}
export class AggregateWatchableValue extends RefCounted {
    constructor(getWatchables) {
        super();
        this.changed = new NullarySignal();
        const watchables = getWatchables(this);
        const keys = _Object$keys(watchables);
        const updateValue = () => {
            const obj = Array.isArray(watchables) ? [] : {};
            for (const k of keys) {
                obj[k] = watchables[k].value;
            }
            this.value = obj;
            this.changed.dispatch();
        };
        updateValue();
        for (const k of keys) {
            const watchable = watchables[k];
            // Ensure a unique function is used each time in case the same watchable is assigned to
            // multiple properties.
            this.registerDisposer(watchable.changed.add(() => updateValue()));
        }
    }
}
export class ComputedWatchableValue extends RefCounted {
    constructor(f, ...signals) {
        super();
        this.f = f;
        this.changed = new NullarySignal();
        for (const signal of signals) {
            this.registerDisposer(signal.add(this.changed.dispatch));
        }
    }
    get value() {
        return this.f();
    }
}
export class WatchableRefCounted extends RefCounted {
    constructor() {
        super(...arguments);
        this.changed = new NullarySignal();
    }
    get value() {
        return this.value_;
    }
    set value(value) {
        const value_ = this.value_;

        this.value_ = value;
        if (value_ !== undefined) {
            value_.dispose();
            value_.unregisterDisposer(this.valueHandler);
            this.valueHandler = undefined;
        }
        if (value !== undefined) {
            const valueHandler = this.valueHandler = () => {
                if (this.value_ === value) {
                    this.value_ = undefined;
                    this.changed.dispatch();
                }
            };
            value.registerDisposer(valueHandler);
        }
        if (value !== value_) {
            this.changed.dispatch();
        }
    }
    reset() {
        this.value = undefined;
    }
    disposed() {
        if (this.value_ !== undefined) {
            this.value_.unregisterDisposer(this.valueHandler);
            this.value_.dispose();
        }
        this.value_ = undefined;
        super.disposed();
    }
}
export class TrackableRefCounted extends WatchableRefCounted {
    constructor(validator, jsonConverter) {
        super();
        this.validator = validator;
        this.jsonConverter = jsonConverter;
    }
    toJSON() {
        const value = this.value;

        return value && this.jsonConverter(value);
    }
    restoreState(x) {
        this.value = this.validator(x);
    }
}
export class WatchableSet {
    constructor(values) {
        this.changed = new NullarySignal();
        if (values === undefined) {
            this.values = new _Set();
        } else {
            this.values = new _Set(values);
        }
    }
    add(x) {
        const values = this.values;

        if (!values.has(x)) {
            values.add(x);
            this.changed.dispatch();
        }
        return this;
    }
    delete(x) {
        const values = this.values;

        if (values.delete(x)) {
            this.changed.dispatch();
            return true;
        }
        return false;
    }
    has(x) {
        return this.values.has(x);
    }
    get size() {
        return this.values.size;
    }
    [_Symbol$iterator]() {
        return _getIterator(this.values);
    }
    clear() {
        const values = this.values;

        if (values.size > 0) {
            values.clear();
            this.changed.dispatch();
        }
    }
}
export function registerNested(f, ...watchables) {
    let values = watchables.map(w => w.value);
    const count = watchables.length;
    let context = new RefCounted();
    let result = f(context, ...values);
    const handleChange = debounce(() => {
        let changed = false;
        for (let i = 0; i < count; ++i) {
            const watchable = watchables[i];
            const value = watchable.value;
            if (values[i] !== value) {
                values[i] = value;
                changed = true;
            }
        }
        if (!changed) return;
        context.dispose();
        context = new RefCounted();
        result = f(context, ...values);
    }, 0);
    const signalDisposers = watchables.map(w => w.changed.add(handleChange));
    return {
        flush() {
            handleChange.flush();
        },
        dispose() {
            handleChange.cancel();
            invokeDisposers(signalDisposers);
            context.dispose();
        },
        get value() {
            handleChange.flush();
            return result;
        }
    };
}
export function registerNestedSync(f, ...watchables) {
    let values = watchables.map(w => w.value);
    const count = watchables.length;
    let context = new RefCounted();
    let result = f(context, ...values);
    const handleChange = () => {
        let changed = false;
        for (let i = 0; i < count; ++i) {
            const watchable = watchables[i];
            const value = watchable.value;
            if (values[i] !== value) {
                values[i] = value;
                changed = true;
            }
        }
        if (!changed) return;
        context.dispose();
        context = new RefCounted();
        result = f(context, ...values);
    };
    const signalDisposers = watchables.map(w => w.changed.add(handleChange));
    return {
        dispose() {
            invokeDisposers(signalDisposers);
            context.dispose();
        },
        get value() {
            return result;
        }
    };
}
export function constantWatchableValue(value) {
    return { changed: neverSignal, value };
}
export function observeWatchable(callback, watchable) {
    callback(watchable.value);
    return watchable.changed.add(() => callback(watchable.value));
}
export function linkWatchableValue(source, target) {
    target.value = source.value;
    return source.changed.add(() => {
        target.value = source.value;
    });
}
export class IndirectWatchableValue {
    constructor(outer, getInner) {
        this.outer = outer;
        this.getInner = getInner;
        this.changed = new NullarySignal();
        this.update = () => {
            const disposer = this.disposer,
                  outer = this.outer;

            if (disposer !== undefined) {
                disposer();
            }
            const inner = this.inner = this.getInner(outer.value);
            this.disposer = inner.changed.add(this.changed.dispatch);
            this.changed.dispatch();
        };
        outer.changed.add(this.update);
        this.update();
    }
    dispose() {
        this.outer.changed.remove(this.update);
        this.disposer();
    }
    get value() {
        return this.inner.value;
    }
    set value(value) {
        this.inner.value = value;
    }
}
export class IndirectTrackableValue extends IndirectWatchableValue {
    reset() {
        this.inner.reset();
    }
    restoreState(obj) {
        this.inner.restoreState(obj);
    }
    toJSON() {
        return this.inner.toJSON();
    }
}
//# sourceMappingURL=trackable_value.js.map