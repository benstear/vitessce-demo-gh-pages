import _Promise from 'babel-runtime/core-js/promise';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * This implements a CredentialsProvider based on Keycloak.
 */
import { CredentialsProvider, makeCredentialsGetter } from '../../credentials_provider';
import { StatusMessage } from '../../status';
import { CANCELED, CancellationTokenSource, uncancelableToken } from '../../util/cancellation';
import { verifyObject, verifyString } from '../../util/json';
import { getRandomHexString } from '../../util/random';
import { Signal } from '../../util/signal';
class PendingRequest {
    constructor() {
        this.finished = new Signal();
    }
}
class AuthHandler {
    constructor() {
        this.oidcCallbackService = `bossAuthCallback`;
        this.pendingRequests = new _Map();
        this.registerListener();
    }
    registerListener() {
        addEventListener('message', event => {
            if (event.origin !== location.origin) {
                // Ignore messages from different origins.
                return;
            }
            try {
                let data = verifyObject(JSON.parse(event.data));
                let service = verifyString(data['service']);
                if (service === this.oidcCallbackService) {
                    let accessToken = verifyString(data['access_token']);
                    let state = verifyString(data['state']);
                    let request = this.pendingRequests.get(state);
                    if (request === undefined) {
                        // Request may have been cancelled.
                        return;
                    }
                    request.finished.dispatch(accessToken);
                }
            } catch (parseError) {
                // Ignore invalid message.
            }
        });
    }
    addPendingRequest(state) {
        let request = new PendingRequest();
        this.pendingRequests.set(state, request);
        request.finished.add(() => {
            this.pendingRequests.delete(state);
        });
        return request;
    }
    makeAuthRequestUrl(options) {
        let url = `${options.authServer}/realms/BOSS/protocol/openid-connect/auth?`;
        url += `client_id=${encodeURIComponent(options.clientId)}`;
        url += `&redirect_uri=${encodeURIComponent(options.redirect_uri)}`;
        url += `&response_mode=fragment`;
        url += `&response_type=code%20id_token%20token`;
        if (options.state) {
            url += `&state=${options.state}`;
        }
        if (options.nonce) {
            url += `&nonce=${options.nonce}`;
        }
        return url;
    }
}
let authHandlerInstance;
function authHandler() {
    if (authHandlerInstance === undefined) {
        authHandlerInstance = new AuthHandler();
    }
    return authHandlerInstance;
}
/**
 * Obtain a Keycloak OIDC authentication token.
 * @return A Promise that resolves to an authentication token.
 */
export function authenticateKeycloakOIDC(options, cancellationToken = uncancelableToken) {
    const state = getRandomHexString();
    const nonce = getRandomHexString();
    const handler = authHandler();
    const url = handler.makeAuthRequestUrl({
        state: state,
        clientId: options.clientId,
        redirect_uri: new URL('bossauth.html', window.location.href).href,
        authServer: options.authServer,
        nonce: nonce
    });
    const request = handler.addPendingRequest(state);
    const promise = new _Promise((resolve, reject) => {
        request.finished.add((token, error) => {
            if (token !== undefined) {
                resolve(token);
            } else {
                reject(error);
            }
        });
    });
    request.finished.add(cancellationToken.add(() => {
        request.finished.dispatch(undefined, CANCELED);
    }));
    if (!cancellationToken.isCanceled) {
        const newWindow = open(url);
        if (newWindow !== null) {
            request.finished.add(() => {
                newWindow.close();
            });
        }
    }
    return promise;
}
export class BossCredentialsProvider extends CredentialsProvider {
    constructor(authServer) {
        super();
        this.authServer = authServer;
        this.get = makeCredentialsGetter(cancellationToken => {
            const status = new StatusMessage( /*delay=*/true);
            let cancellationSource;
            return new _Promise((resolve, reject) => {
                const dispose = () => {
                    cancellationSource = undefined;
                    status.dispose();
                };
                cancellationToken.add(() => {
                    if (cancellationSource !== undefined) {
                        cancellationSource.cancel();
                        cancellationSource = undefined;
                        status.dispose();
                        reject(CANCELED);
                    }
                });
                function writeLoginStatus(msg = 'Boss authorization required.', linkMessage = 'Request authorization.') {
                    status.setText(msg + ' ');
                    let button = document.createElement('button');
                    button.textContent = linkMessage;
                    status.element.appendChild(button);
                    button.addEventListener('click', () => {
                        login();
                    });
                    status.setVisible(true);
                }
                let authServer = this.authServer;
                function login() {
                    if (cancellationSource !== undefined) {
                        cancellationSource.cancel();
                    }
                    cancellationSource = new CancellationTokenSource();
                    writeLoginStatus('Waiting for Boss authorization...', 'Retry');
                    authenticateKeycloakOIDC({ realm: 'boss', clientId: 'endpoint', authServer: authServer }, cancellationSource).then(token => {
                        if (cancellationSource !== undefined) {
                            dispose();
                            resolve(token);
                        }
                    }, reason => {
                        if (cancellationSource !== undefined) {
                            cancellationSource = undefined;
                            writeLoginStatus(`Boss authorization failed: ${reason}.`, 'Retry');
                        }
                    });
                }
                writeLoginStatus();
            });
        });
    }
}
//# sourceMappingURL=credentials_provider.js.map