import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Array$from from 'babel-runtime/core-js/array/from';
import _Promise from 'babel-runtime/core-js/promise';
import _Set from 'babel-runtime/core-js/set';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Support for The Boss (https://github.com/jhuapl-boss) web services.
 */
import { makeDataBoundsBoundingBoxAnnotationSet } from '../../annotation';
import { WithParameters } from '../../chunk_manager/frontend';
import { makeCoordinateSpace, makeIdentityTransform, makeIdentityTransformedBoundingBox } from '../../coordinate_transform';
import { WithCredentialsProvider } from '../../credentials_provider/chunk_source_frontend';
import { DataSourceProvider } from './..';
import { credentialsKey, fetchWithBossCredentials } from './api';
import { MeshSourceParameters, VolumeChunkSourceParameters } from './base';
import { MeshSource } from '../../mesh/frontend';
import { DataType, makeDefaultVolumeChunkSpecifications, VolumeType } from '../../sliceview/volume/base';
import { MultiscaleVolumeChunkSource, VolumeChunkSource } from '../../sliceview/volume/frontend';
import { transposeNestedArrays } from '../../util/array';
import { applyCompletionOffset, getPrefixMatchesWithDescriptions } from '../../util/completion';
import { vec2, vec3 } from '../../util/geom';
import { responseJson } from '../../util/http_request';
import { parseArray, parseQueryStringParameters, verify3dDimensions, verify3dScale, verifyEnumString, verifyFiniteFloat, verifyFinitePositiveFloat, verifyInt, verifyObject, verifyObjectAsMap, verifyObjectProperty, verifyOptionalString, verifyString } from '../../util/json';
class BossVolumeChunkSource extends WithParameters(WithCredentialsProvider()(VolumeChunkSource), VolumeChunkSourceParameters) {}
class BossMeshSource extends WithParameters(WithCredentialsProvider()(MeshSource), MeshSourceParameters) {}
let serverVolumeTypes = new _Map();
serverVolumeTypes.set('image', VolumeType.IMAGE);
serverVolumeTypes.set('annotation', VolumeType.SEGMENTATION);
const VALID_ENCODINGS = new _Set(['npz', 'jpeg']);
const DEFAULT_CUBOID_SIZE = Uint32Array.of(512, 512, 16);
var VoxelUnitType;
(function (VoxelUnitType) {
    VoxelUnitType[VoxelUnitType["NANOMETERS"] = 0] = "NANOMETERS";
    VoxelUnitType[VoxelUnitType["MICROMETERS"] = 1] = "MICROMETERS";
    VoxelUnitType[VoxelUnitType["MILLIMETERS"] = 2] = "MILLIMETERS";
    VoxelUnitType[VoxelUnitType["CENTIMETERS"] = 3] = "CENTIMETERS";
})(VoxelUnitType || (VoxelUnitType = {}));
function getVoxelUnitInvScale(voxelUnit) {
    switch (voxelUnit) {
        case VoxelUnitType.MICROMETERS:
            return 1e6;
        case VoxelUnitType.MILLIMETERS:
            return 1e3;
        case VoxelUnitType.CENTIMETERS:
            return 1e2;
        case VoxelUnitType.NANOMETERS:
            return 1e9;
    }
}
/**
 * This function adds scaling info by processing coordinate frame object and adding it to the
 * experiment.
 */
function parseCoordinateFrame(coordFrame, experimentInfo) {
    verifyObject(coordFrame);
    const voxelUnit = verifyObjectProperty(coordFrame, 'voxel_unit', x => verifyEnumString(x, VoxelUnitType));
    const voxelSizeBaseInvScale = getVoxelUnitInvScale(voxelUnit);
    const voxelSizeBaseInOriginalUnits = new Float32Array(3),
          voxelSizeBaseInMeters = new Float64Array(3),
          voxelOffsetBase = new Float64Array(3),
          imageSizeBase = new Float64Array(3);
    const dimNames = ['x', 'y', 'z'];
    for (let i = 0; i < 3; ++i) {
        const dimName = dimNames[i];
        voxelSizeBaseInOriginalUnits[i] = verifyObjectProperty(coordFrame, `${dimName}_voxel_size`, verifyFinitePositiveFloat);
        voxelSizeBaseInMeters[i] = voxelSizeBaseInOriginalUnits[i] / voxelSizeBaseInvScale;
        voxelOffsetBase[i] = verifyObjectProperty(coordFrame, `${dimName}_start`, verifyInt);
        imageSizeBase[i] = verifyObjectProperty(coordFrame, `${dimName}_stop`, verifyInt);
    }
    experimentInfo.coordFrame = {
        voxelSizeBaseInMeters,
        voxelSizeBaseInOriginalUnits,
        voxelOffsetBase,
        imageSizeBase,
        voxelUnit,
        names: dimNames
    };
    return experimentInfo;
}
function getVolumeTypeFromChannelType(channelType) {
    let volumeType = serverVolumeTypes.get(channelType);
    if (volumeType === undefined) {
        volumeType = VolumeType.UNKNOWN;
    }
    return volumeType;
}
function parseChannelInfo(obj) {
    verifyObject(obj);
    let channelType = verifyObjectProperty(obj, 'type', verifyString);
    let downsampleStatus = false;
    let downsampleStr = verifyObjectProperty(obj, 'downsample_status', verifyString);
    if (downsampleStr === 'DOWNSAMPLED') {
        downsampleStatus = true;
    }
    return {
        channelType,
        description: verifyObjectProperty(obj, 'description', verifyString),
        volumeType: getVolumeTypeFromChannelType(channelType),
        dataType: verifyObjectProperty(obj, 'datatype', x => verifyEnumString(x, DataType)),
        downsampled: downsampleStatus,
        scales: [],
        key: verifyObjectProperty(obj, 'name', verifyString),
        baseResolution: verifyObjectProperty(obj, 'base_resolution', verifyInt)
    };
}
function parseExperimentInfo(obj, chunkManager, hostname, credentialsProvider, collection, experiment) {
    verifyObject(obj);
    let channelPromiseArray = verifyObjectProperty(obj, 'channels', x => parseArray(x, ch => getChannelInfo(chunkManager, hostname, credentialsProvider, experiment, collection, ch)));
    return _Promise.all(channelPromiseArray).then(channelArray => {
        // Parse out channel information
        let channels = new _Map();
        channelArray.forEach(channel => {
            channels.set(channel.key, channel);
        });
        let experimentInfo = {
            channels: channels,
            scalingLevels: verifyObjectProperty(obj, 'num_hierarchy_levels', verifyInt),
            coordFrameKey: verifyObjectProperty(obj, 'coord_frame', verifyString),
            coordFrame: undefined,
            key: verifyObjectProperty(obj, 'name', verifyString),
            collection: verifyObjectProperty(obj, 'collection', verifyString)
        };
        // Get and parse the coordinate frame
        return getCoordinateFrame(chunkManager, hostname, credentialsProvider, experimentInfo);
    });
}
export class BossMultiscaleVolumeChunkSource extends MultiscaleVolumeChunkSource {
    constructor(chunkManager, baseUrl, credentialsProvider, experimentInfo, channel, parameters) {
        super(chunkManager);
        this.baseUrl = baseUrl;
        this.credentialsProvider = credentialsProvider;
        this.experimentInfo = experimentInfo;
        this.parameters = parameters;
        /**
         * Parameters for getting 3D meshes alongside segmentations
         */
        this.meshPath = undefined;
        this.meshUrl = undefined;
        if (channel === undefined) {
            const channelNames = _Array$from(experimentInfo.channels.keys());
            if (channelNames.length !== 1) {
                throw new Error(`Experiment contains multiple channels: ${_JSON$stringify(channelNames)}`);
            }
            channel = channelNames[0];
        }
        const channelInfo = experimentInfo.channels.get(channel);
        if (channelInfo === undefined) {
            throw new Error(`Specified channel ${_JSON$stringify(channel)} is not one of the supported channels ${_JSON$stringify(_Array$from(experimentInfo.channels.keys()))}`);
        }
        this.channel = channel;
        this.channelInfo = channelInfo;
        this.scales = channelInfo.scales;
        if (experimentInfo.coordFrame === undefined) {
            throw new Error(`Specified experiment ${_JSON$stringify(experimentInfo.key)} does not have a valid coordinate frame`);
        }
        this.coordinateFrame = experimentInfo.coordFrame;
        if (this.channelInfo.downsampled === false) {
            this.scales = [channelInfo.scales[0]];
        }
        this.experiment = experimentInfo.key;
        let window = verifyOptionalString(parameters['window']);
        if (window !== undefined) {
            let windowobj = vec2.create();
            let parts = window.split(/,/);
            if (parts.length === 2) {
                windowobj[0] = verifyFiniteFloat(parts[0]);
                windowobj[1] = verifyFiniteFloat(parts[1]);
            } else if (parts.length === 1) {
                windowobj[0] = 0.;
                windowobj[1] = verifyFiniteFloat(parts[1]);
            } else {
                throw new Error(`Invalid window. Must be either one value or two comma separated values: ${_JSON$stringify(window)}`);
            }
            this.window = windowobj;
            if (this.window[0] === this.window[1]) {
                throw new Error(`Invalid window. First element must be different from second: ${_JSON$stringify(window)}.`);
            }
        }
        let meshUrl = verifyOptionalString(parameters['meshurl']);
        if (meshUrl !== undefined) {
            this.meshUrl = meshUrl;
        }
        let encoding = verifyOptionalString(parameters['encoding']);
        if (encoding === undefined) {
            encoding = this.volumeType === VolumeType.IMAGE ? 'jpeg' : 'npz';
        } else {
            if (!VALID_ENCODINGS.has(encoding)) {
                throw new Error(`Invalid encoding: ${_JSON$stringify(encoding)}.`);
            }
        }
        this.encoding = encoding;
    }
    get dataType() {
        return this.channelInfo.dataType;
    }
    get volumeType() {
        return this.channelInfo.volumeType;
    }
    get rank() {
        return 3;
    }
    getSources(volumeSourceOptions) {
        // Hannah change Feb 2021
        // Replaced scale calculations with those from ../precomputed
        const modelResolution = this.scales[0].downsampleFactors;
        const rank = this.rank;

        return transposeNestedArrays(this.scales.map(scaleInfo => {
            let voxelOffset = this.coordinateFrame.voxelOffsetBase;
            let baseVoxelOffset = vec3.create();
            for (let i = 0; i < 3; ++i) {
                baseVoxelOffset[i] = Math.ceil(voxelOffset[i]);
            }
            const resolution = scaleInfo.downsampleFactors;
            const stride = rank + 1;
            const chunkToMultiscaleTransform = new Float32Array(stride * stride);
            chunkToMultiscaleTransform[chunkToMultiscaleTransform.length - 1] = 1;
            for (let i = 0; i < 3; ++i) {
                const relativeScale = resolution[i] / modelResolution[i];
                chunkToMultiscaleTransform[stride * i + i] = relativeScale;
                chunkToMultiscaleTransform[stride * rank + i] = baseVoxelOffset[i] * relativeScale;
            }
            if (rank === 4) {
                chunkToMultiscaleTransform[stride * 3 + 3] = 1;
            }
            let imageSize = scaleInfo.imageSize;
            return makeDefaultVolumeChunkSpecifications({
                rank: 3,
                volumeType: this.volumeType,
                dataType: this.dataType,
                chunkToMultiscaleTransform: chunkToMultiscaleTransform,
                chunkDataSizes: [DEFAULT_CUBOID_SIZE],
                baseVoxelOffset: baseVoxelOffset,
                upperVoxelBound: imageSize,
                volumeSourceOptions
            }).map(spec => ({
                chunkSource: this.chunkManager.getChunkSource(BossVolumeChunkSource, {
                    credentialsProvider: this.credentialsProvider,
                    spec,
                    parameters: {
                        baseUrl: this.baseUrl,
                        collection: this.experimentInfo.collection,
                        experiment: this.experimentInfo.key,
                        channel: this.channel,
                        resolution: scaleInfo.key,
                        encoding: this.encoding,
                        window: this.window
                    }
                }),
                chunkToMultiscaleTransform
            }));
        }));
    }
    getMeshSource() {
        if (this.meshUrl !== undefined) {
            return this.chunkManager.getChunkSource(BossMeshSource, { credentialsProvider: this.credentialsProvider, parameters: { baseUrl: this.meshUrl } });
        }
        return null;
    }
}
const pathPattern = /^([^\/?]+)\/([^\/?]+)(?:\/([^\/?]+))?(?:\?(.*))?$/;
export function getExperimentInfo(chunkManager, hostname, credentialsProvider, experiment, collection) {
    return chunkManager.memoize.getUncounted({
        hostname: hostname,
        collection: collection,
        experiment: experiment,
        type: 'boss:getExperimentInfo'
    }, () => fetchWithBossCredentials(credentialsProvider, `${hostname}/latest/collection/${collection}/experiment/${experiment}/`, {}, responseJson).then(value => parseExperimentInfo(value, chunkManager, hostname, credentialsProvider, collection, experiment)));
}
export function getChannelInfo(chunkManager, hostname, credentialsProvider, experiment, collection, channel) {
    return chunkManager.memoize.getUncounted({
        hostname: hostname,
        collection: collection,
        experiment: experiment,
        channel: channel,
        type: 'boss:getChannelInfo'
    }, () => fetchWithBossCredentials(credentialsProvider, `${hostname}/latest/collection/${collection}/experiment/${experiment}/channel/${channel}/`, {}, responseJson).then(parseChannelInfo));
}
export function getDownsampleInfoForChannel(chunkManager, hostname, credentialsProvider, collection, experimentInfo, channel) {
    return chunkManager.memoize.getUncounted({
        hostname: hostname,
        collection: collection,
        experiment: experimentInfo.key,
        channel: channel,
        downsample: true,
        type: 'boss:getDownsampleInfoForChannel'
    }, () => fetchWithBossCredentials(credentialsProvider, `${hostname}/latest/downsample/${collection}/${experimentInfo.key}/${channel}`, {}, responseJson)).then(downsampleObj => {
        return parseDownsampleInfoForChannel(downsampleObj, experimentInfo, channel);
    });
}
export function parseDownsampleScales(downsampleObj, voxelSizeBaseInOriginalUnits) {
    verifyObject(downsampleObj);
    let voxelSizes = verifyObjectProperty(downsampleObj, 'voxel_size', x => verifyObjectAsMap(x, verify3dScale));
    let imageSizes = verifyObjectProperty(downsampleObj, 'extent', x => verifyObjectAsMap(x, verify3dDimensions));
    let num_hierarchy_levels = verifyObjectProperty(downsampleObj, 'num_hierarchy_levels', verifyInt);
    let scaleInfo = new Array();
    for (let i = 0; i < num_hierarchy_levels; i++) {
        let key = String(i);
        const voxelSize = voxelSizes.get(key);
        const imageSize = imageSizes.get(key);
        if (voxelSize === undefined || imageSize === undefined) {
            throw new Error(`Missing voxel_size/extent for resolution ${key}.`);
        }
        const downsampleFactors = new Float32Array(3);
        for (let i = 0; i < 3; ++i) {
            downsampleFactors[i] = voxelSize[i] / voxelSizeBaseInOriginalUnits[i];
        }
        scaleInfo[i] = { downsampleFactors, imageSize, key };
    }
    return scaleInfo;
}
export function parseDownsampleInfoForChannel(downsampleObj, experimentInfo, channel) {
    let coordFrame = experimentInfo.coordFrame;
    if (coordFrame === undefined) {
        throw new Error(`Missing coordinate frame information for experiment ${experimentInfo.key}. A valid coordinate frame is required to retrieve downsampling information.`);
    }
    let channelInfo = experimentInfo.channels.get(channel);
    if (channelInfo === undefined) {
        throw new Error(`Specified channel ${_JSON$stringify(channel)} is not one of the supported channels ${_JSON$stringify(_Array$from(experimentInfo.channels.keys()))}`);
    }
    channelInfo.scales = parseDownsampleScales(downsampleObj, coordFrame.voxelSizeBaseInOriginalUnits);
    experimentInfo.channels.set(channel, channelInfo);
    return experimentInfo;
}
export function getDataSource(chunkManager, hostname, credentialsProvider, path) {
    const match = path.match(pathPattern);
    if (match === null) {
        throw new Error(`Invalid volume path ${_JSON$stringify(path)}`);
    }
    const collection = match[1];
    const experiment = match[2];
    const channel = match[3];
    const parameters = parseQueryStringParameters(match[4] || '');
    // Warning: If additional arguments are added, the cache key should be updated as well.
    return chunkManager.memoize.getUncounted({ hostname: hostname, path: path, type: 'boss:getVolume' }, async () => {
        const experimentInfo = await getExperimentInfo(chunkManager, hostname, credentialsProvider, experiment, collection);
        const experimentInfoWithDownsample = await getDownsampleInfoForChannel(chunkManager, hostname, credentialsProvider, collection, experimentInfo, channel);
        const volume = new BossMultiscaleVolumeChunkSource(chunkManager, hostname, credentialsProvider, experimentInfoWithDownsample, channel, parameters);
        const coordFrame = experimentInfoWithDownsample.coordFrame;
        const box = {
            lowerBounds: coordFrame.voxelOffsetBase,
            upperBounds: Float64Array.from(coordFrame.imageSizeBase, (x, i) => coordFrame.voxelOffsetBase[i] + x)
        };
        const modelSpace = makeCoordinateSpace({
            rank: 3,
            names: coordFrame.names,
            units: ['m', 'm', 'm'],
            scales: coordFrame.voxelSizeBaseInMeters,
            boundingBoxes: [makeIdentityTransformedBoundingBox(box)]
        });
        const dataSource = {
            modelTransform: makeIdentityTransform(modelSpace),
            subsources: [{
                id: 'default',
                default: true,
                subsource: { volume }
            }, {
                id: 'bounds',
                default: true,
                subsource: { staticAnnotations: makeDataBoundsBoundingBoxAnnotationSet(box) }
            }]
        };
        return dataSource;
    });
}
const urlPattern = /^((?:http|https):\/\/[^\/?]+)\/(.*)$/;
export function getCollections(chunkManager, hostname, credentialsProvider) {
    return chunkManager.memoize.getUncounted({ hostname: hostname, type: 'boss:getCollections' }, () => fetchWithBossCredentials(credentialsProvider, `${hostname}/latest/collection/`, {}, responseJson).then(value => verifyObjectProperty(value, 'collections', x => parseArray(x, verifyString))));
}
export function getExperiments(chunkManager, hostname, credentialsProvider, collection) {
    return chunkManager.memoize.getUncounted({ hostname: hostname, collection: collection, type: 'boss:getExperiments' }, () => fetchWithBossCredentials(credentialsProvider, `${hostname}/latest/collection/${collection}/experiment/`, {}, responseJson).then(value => verifyObjectProperty(value, 'experiments', x => parseArray(x, verifyString))));
}
export function getCoordinateFrame(chunkManager, hostname, credentialsProvider, experimentInfo) {
    let key = experimentInfo.coordFrameKey;
    return chunkManager.memoize.getUncounted({
        hostname: hostname,
        coordinateframe: key,
        experimentInfo: experimentInfo,
        type: 'boss:getCoordinateFrame'
    }, () => fetchWithBossCredentials(credentialsProvider, `${hostname}/latest/coord/${key}/`, {}, responseJson).then(coordinateFrameObj => parseCoordinateFrame(coordinateFrameObj, experimentInfo)));
}
export function collectionExperimentChannelCompleter(chunkManager, hostname, credentialsProvider, path) {
    let channelMatch = path.match(/^(?:([^\/]+)(?:\/?([^\/]*)(?:\/?([^\/]*)(?:\/?([^\/]*)?))?)?)?$/);
    if (channelMatch === null) {
        // URL has incorrect format, don't return any results.
        return _Promise.reject(null);
    }
    if (channelMatch[1] === undefined) {
        // No collection. Reject.
        return _Promise.reject(null);
    }
    if (channelMatch[2] === undefined) {
        let collectionPrefix = channelMatch[1] || '';
        // Try to complete the collection.
        return getCollections(chunkManager, hostname, credentialsProvider).then(collections => {
            return {
                offset: 0,
                completions: getPrefixMatchesWithDescriptions(collectionPrefix, collections, x => x + '/', () => undefined)
            };
        });
    }
    if (channelMatch[3] === undefined) {
        let experimentPrefix = channelMatch[2] || '';
        return getExperiments(chunkManager, hostname, credentialsProvider, channelMatch[1]).then(experiments => {
            return {
                offset: channelMatch[1].length + 1,
                completions: getPrefixMatchesWithDescriptions(experimentPrefix, experiments, y => y + '/', () => undefined)
            };
        });
    }
    return getExperimentInfo(chunkManager, hostname, credentialsProvider, channelMatch[2], channelMatch[1]).then(experimentInfo => {
        let completions = getPrefixMatchesWithDescriptions(channelMatch[3], experimentInfo.channels, x => x[0], x => {
            return `${x[1].channelType} (${DataType[x[1].dataType]})`;
        });
        return { offset: channelMatch[1].length + channelMatch[2].length + 2, completions };
    });
}
function getAuthServer(endpoint) {
    let baseHostName = endpoint.match(/^(?:https:\/\/[^.]+([^\/]+))/);
    if (baseHostName === null) {
        throw new Error(`Unable to construct auth server hostname from base hostname ${endpoint}.`);
    }
    let authServer = `https://auth${baseHostName[1]}/auth`;
    return authServer;
}
export class BossDataSource extends DataSourceProvider {
    constructor(credentialsManager) {
        super();
        this.credentialsManager = credentialsManager;
    }
    get description() {
        return 'bossDB: Block & Object Storage System';
    }
    getCredentialsProvider(path) {
        let authServer = getAuthServer(path);
        return this.credentialsManager.getCredentialsProvider(credentialsKey, authServer);
    }
    get(options) {
        const match = options.providerUrl.match(urlPattern);
        if (match === null) {
            throw new Error(`Invalid boss volume path: ${_JSON$stringify(options.providerUrl)}`);
        }
        let credentialsProvider = this.getCredentialsProvider(options.providerUrl);
        return getDataSource(options.chunkManager, match[1], credentialsProvider, match[2]);
    }
    async completeUrl(options) {
        const match = options.providerUrl.match(urlPattern);
        if (match === null) {
            // We don't yet have a full hostname.
            throw null;
        }
        let hostname = match[1];
        let credentialsProvider = this.getCredentialsProvider(match[1]);
        let path = match[2];
        const completions = await collectionExperimentChannelCompleter(options.chunkManager, hostname, credentialsProvider, path);
        return applyCompletionOffset(match[1].length + 1, completions);
    }
}
//# sourceMappingURL=frontend.js.map