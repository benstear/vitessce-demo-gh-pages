import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Map from 'babel-runtime/core-js/map';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AnnotationType, makeDataBoundsBoundingBoxAnnotationSet, parseAnnotationPropertySpecs } from '../../annotation';
import { AnnotationGeometryChunkSource, MultiscaleAnnotationSource } from '../../annotation/frontend_source';
import { WithParameters } from '../../chunk_manager/frontend';
import { coordinateSpaceFromJson, emptyValidCoordinateSpace, makeCoordinateSpace, makeIdentityTransform, makeIdentityTransformedBoundingBox } from '../../coordinate_transform';
import { WithCredentialsProvider } from '../../credentials_provider/chunk_source_frontend';
import { DataSourceProvider, RedirectError } from './..';
import { AnnotationSourceParameters, AnnotationSpatialIndexSourceParameters, DataEncoding, IndexedSegmentPropertySourceParameters, MeshSourceParameters, MultiscaleMeshSourceParameters, ShardingHashFunction, SkeletonSourceParameters, VolumeChunkEncoding, VolumeChunkSourceParameters } from './base';
import { VertexPositionFormat } from '../../mesh/base';
import { MeshSource, MultiscaleMeshSource } from '../../mesh/frontend';
import { IndexedSegmentPropertySource, normalizeInlineSegmentPropertyMap, SegmentPropertyMap } from '../../segmentation_display_state/property_map';
import { SkeletonSource } from '../../skeleton/frontend';
import { makeSliceViewChunkSpecification } from '../../sliceview/base';
import { makeDefaultVolumeChunkSpecifications, VolumeType } from '../../sliceview/volume/base';
import { MultiscaleVolumeChunkSource, VolumeChunkSource } from '../../sliceview/volume/frontend';
import { transposeNestedArrays } from '../../util/array';
import { DATA_TYPE_ARRAY_CONSTRUCTOR, DataType } from '../../util/data_type';
import { mat4, vec3 } from '../../util/geom';
import { completeHttpPath } from '../../util/http_path_completion';
import { isNotFoundError, responseJson } from '../../util/http_request';
import { parseArray, parseFixedLengthArray, parseQueryStringParameters, unparseQueryStringParameters, verifyEnumString, verifyFiniteFloat, verifyFinitePositiveFloat, verifyInt, verifyObject, verifyObjectProperty, verifyOptionalObjectProperty, verifyOptionalString, verifyPositiveInt, verifyString, verifyStringArray } from '../../util/json';
import * as matrix from '../../util/matrix';
import { getObjectId } from '../../util/object_id';
import { cancellableFetchSpecialOk, parseSpecialUrl } from '../../util/special_protocol_request';
import { Uint64 } from '../../util/uint64';
export class PrecomputedVolumeChunkSource extends WithParameters(WithCredentialsProvider()(VolumeChunkSource), VolumeChunkSourceParameters) {}
class PrecomputedMeshSource extends WithParameters(WithCredentialsProvider()(MeshSource), MeshSourceParameters) {}
class PrecomputedMultiscaleMeshSource extends WithParameters(WithCredentialsProvider()(MultiscaleMeshSource), MultiscaleMeshSourceParameters) {}
class PrecomputedSkeletonSource extends WithParameters(WithCredentialsProvider()(SkeletonSource), SkeletonSourceParameters) {
    get skeletonVertexCoordinatesInVoxels() {
        return false;
    }
    get vertexAttributes() {
        return this.parameters.metadata.vertexAttributes;
    }
}
export function resolvePath(a, b) {
    const outputParts = a.split('/');
    for (const part of b.split('/')) {
        if (part === '..') {
            if (outputParts.length !== 0) {
                outputParts.length = outputParts.length - 1;
                continue;
            }
        }
        outputParts.push(part);
    }
    return outputParts.join('/');
}
class ScaleInfo {
    constructor(obj, numChannels) {
        verifyObject(obj);
        const rank = numChannels === 1 ? 3 : 4;
        const resolution = this.resolution = new Float64Array(rank);
        const voxelOffset = this.voxelOffset = new Float32Array(rank);
        const size = this.size = new Float32Array(rank);
        if (rank === 4) {
            resolution[3] = 1;
            size[3] = numChannels;
        }
        verifyObjectProperty(obj, 'resolution', x => parseFixedLengthArray(resolution.subarray(0, 3), x, verifyFinitePositiveFloat));
        verifyOptionalObjectProperty(obj, 'voxel_offset', x => parseFixedLengthArray(voxelOffset.subarray(0, 3), x, verifyInt));
        verifyObjectProperty(obj, 'size', x => parseFixedLengthArray(size.subarray(0, 3), x, verifyPositiveInt));
        this.chunkSizes = verifyObjectProperty(obj, 'chunk_sizes', x => parseArray(x, y => {
            const chunkSize = new Uint32Array(rank);
            if (rank === 4) chunkSize[3] = numChannels;
            parseFixedLengthArray(chunkSize.subarray(0, 3), y, verifyPositiveInt);
            return chunkSize;
        }));
        if (this.chunkSizes.length === 0) {
            throw new Error('No chunk sizes specified.');
        }
        this.sharding = verifyObjectProperty(obj, 'sharding', parseShardingParameters);
        if (this.sharding !== undefined && this.chunkSizes.length !== 1) {
            throw new Error('Sharding requires a single chunk size per scale');
        }
        let encoding = this.encoding = verifyObjectProperty(obj, 'encoding', x => verifyEnumString(x, VolumeChunkEncoding));
        if (encoding === VolumeChunkEncoding.COMPRESSED_SEGMENTATION) {
            this.compressedSegmentationBlockSize = verifyObjectProperty(obj, 'compressed_segmentation_block_size', x => parseFixedLengthArray(vec3.create(), x, verifyPositiveInt));
        }
        this.key = verifyObjectProperty(obj, 'key', verifyString);
    }
}
export function parseMultiscaleVolumeInfo(obj) {
    verifyObject(obj);
    const dataType = verifyObjectProperty(obj, 'data_type', x => verifyEnumString(x, DataType));
    const numChannels = verifyObjectProperty(obj, 'num_channels', verifyPositiveInt);
    const volumeType = verifyObjectProperty(obj, 'type', x => verifyEnumString(x, VolumeType));
    const mesh = verifyObjectProperty(obj, 'mesh', verifyOptionalString);
    const skeletons = verifyObjectProperty(obj, 'skeletons', verifyOptionalString);
    const segmentPropertyMap = verifyObjectProperty(obj, 'segment_properties', verifyOptionalString);
    const scaleInfos = verifyObjectProperty(obj, 'scales', x => parseArray(x, y => new ScaleInfo(y, numChannels)));
    if (scaleInfos.length === 0) throw new Error('Expected at least one scale');
    const baseScale = scaleInfos[0];
    const rank = numChannels === 1 ? 3 : 4;
    const scales = new Float64Array(rank);
    const lowerBounds = new Float64Array(rank);
    const upperBounds = new Float64Array(rank);
    const names = ['x', 'y', 'z'];
    const units = ['m', 'm', 'm'];
    for (let i = 0; i < 3; ++i) {
        scales[i] = baseScale.resolution[i] / 1e9;
        lowerBounds[i] = baseScale.voxelOffset[i];
        upperBounds[i] = lowerBounds[i] + baseScale.size[i];
    }
    if (rank === 4) {
        scales[3] = 1;
        upperBounds[3] = numChannels;
        names[3] = 'c^';
        units[3] = '';
    }
    const box = { lowerBounds, upperBounds };
    const modelSpace = makeCoordinateSpace({
        rank,
        names,
        units,
        scales,
        boundingBoxes: [makeIdentityTransformedBoundingBox(box)]
    });
    return {
        dataType,
        volumeType,
        mesh,
        skeletons,
        segmentPropertyMap,
        scales: scaleInfos,
        modelSpace
    };
}
export class PrecomputedMultiscaleVolumeChunkSource extends MultiscaleVolumeChunkSource {
    constructor(chunkManager, credentialsProvider, url, info) {
        super(chunkManager);
        this.credentialsProvider = credentialsProvider;
        this.url = url;
        this.info = info;
    }
    get dataType() {
        return this.info.dataType;
    }
    get volumeType() {
        return this.info.volumeType;
    }
    get rank() {
        return this.info.modelSpace.rank;
    }
    getSources(volumeSourceOptions) {
        const modelResolution = this.info.scales[0].resolution;
        const rank = this.rank;

        return transposeNestedArrays(this.info.scales.map(scaleInfo => {
            const resolution = scaleInfo.resolution;

            const stride = rank + 1;
            const chunkToMultiscaleTransform = new Float32Array(stride * stride);
            chunkToMultiscaleTransform[chunkToMultiscaleTransform.length - 1] = 1;
            var _info$modelSpace$boun = this.info.modelSpace.boundingBoxes[0].box;
            const baseLowerBound = _info$modelSpace$boun.lowerBounds,
                  baseUpperBound = _info$modelSpace$boun.upperBounds;

            const lowerClipBound = new Float32Array(rank);
            const upperClipBound = new Float32Array(rank);
            for (let i = 0; i < 3; ++i) {
                const relativeScale = resolution[i] / modelResolution[i];
                chunkToMultiscaleTransform[stride * i + i] = relativeScale;
                const voxelOffsetValue = scaleInfo.voxelOffset[i];
                chunkToMultiscaleTransform[stride * rank + i] = voxelOffsetValue * relativeScale;
                lowerClipBound[i] = baseLowerBound[i] / relativeScale - voxelOffsetValue;
                upperClipBound[i] = baseUpperBound[i] / relativeScale - voxelOffsetValue;
            }
            if (rank === 4) {
                chunkToMultiscaleTransform[stride * 3 + 3] = 1;
                lowerClipBound[3] = baseLowerBound[3];
                upperClipBound[3] = baseUpperBound[3];
            }
            return makeDefaultVolumeChunkSpecifications({
                rank,
                dataType: this.dataType,
                chunkToMultiscaleTransform,
                upperVoxelBound: scaleInfo.size,
                volumeType: this.volumeType,
                chunkDataSizes: scaleInfo.chunkSizes,
                baseVoxelOffset: scaleInfo.voxelOffset,
                compressedSegmentationBlockSize: scaleInfo.compressedSegmentationBlockSize,
                volumeSourceOptions
            }).map(spec => ({
                chunkSource: this.chunkManager.getChunkSource(PrecomputedVolumeChunkSource, {
                    credentialsProvider: this.credentialsProvider,
                    spec,
                    parameters: {
                        url: resolvePath(this.url, scaleInfo.key),
                        encoding: scaleInfo.encoding,
                        sharding: scaleInfo.sharding
                    }
                }),
                chunkToMultiscaleTransform,
                lowerClipBound,
                upperClipBound
            }));
        }));
    }
}
const MultiscaleAnnotationSourceBase = WithParameters(WithCredentialsProvider()(MultiscaleAnnotationSource), AnnotationSourceParameters);
class PrecomputedAnnotationSpatialIndexSource extends WithParameters(WithCredentialsProvider()(AnnotationGeometryChunkSource), AnnotationSpatialIndexSourceParameters) {}
export class PrecomputedAnnotationSource extends MultiscaleAnnotationSourceBase {
    constructor(chunkManager, options) {
        const parameters = options.parameters;

        super(chunkManager, {
            rank: parameters.rank,
            relationships: parameters.relationships.map(x => x.name),
            properties: parameters.properties,
            parameters
        });
        this.readonly = true;
        this.metadata = options.metadata;
        this.credentialsProvider = options.credentialsProvider;
    }
    getSources() {
        return [this.metadata.spatialIndices.map(spatialIndexLevel => {
            const spec = spatialIndexLevel.spec;

            return {
                chunkSource: this.chunkManager.getChunkSource(PrecomputedAnnotationSpatialIndexSource, {
                    credentialsProvider: this.credentialsProvider,
                    parent: this,
                    spec,
                    parameters: spatialIndexLevel.parameters
                }),
                chunkToMultiscaleTransform: spec.chunkToMultiscaleTransform
            };
        })];
    }
}
function getLegacyMeshSource(chunkManager, credentialsProvider, parameters) {
    return chunkManager.getChunkSource(PrecomputedMeshSource, { parameters, credentialsProvider });
}
function parseTransform(data) {
    return verifyObjectProperty(data, 'transform', value => {
        const transform = mat4.create();
        if (value !== undefined) {
            parseFixedLengthArray(transform.subarray(0, 12), value, verifyFiniteFloat);
        }
        mat4.transpose(transform, transform);
        return transform;
    });
}
function parseMeshMetadata(data) {
    verifyObject(data);
    const t = verifyObjectProperty(data, '@type', verifyString);
    let metadata;
    if (t === 'neuroglancer_legacy_mesh') {
        metadata = undefined;
    } else if (t !== 'neuroglancer_multilod_draco') {
        throw new Error(`Unsupported mesh type: ${_JSON$stringify(t)}`);
    } else {
        const lodScaleMultiplier = verifyObjectProperty(data, 'lod_scale_multiplier', verifyFinitePositiveFloat);
        const vertexQuantizationBits = verifyObjectProperty(data, 'vertex_quantization_bits', verifyPositiveInt);
        const transform = parseTransform(data);
        const sharding = verifyObjectProperty(data, 'sharding', parseShardingParameters);
        metadata = { lodScaleMultiplier, transform, sharding, vertexQuantizationBits };
    }
    const segmentPropertyMap = verifyObjectProperty(data, 'segment_properties', verifyOptionalString);
    return { metadata, segmentPropertyMap };
}
async function getMeshMetadata(chunkManager, credentialsProvider, url) {
    let metadata;
    try {
        metadata = await getJsonMetadata(chunkManager, credentialsProvider, url);
    } catch (e) {
        if (isNotFoundError(e)) {
            // If we fail to fetch the info file, assume it is the legacy
            // single-resolution mesh format.
            return { metadata: undefined };
        }
        throw e;
    }
    return parseMeshMetadata(metadata);
}
function parseShardingEncoding(y) {
    if (y === undefined) return DataEncoding.RAW;
    return verifyEnumString(y, DataEncoding);
}
function parseShardingParameters(shardingData) {
    if (shardingData === undefined) return undefined;
    verifyObject(shardingData);
    const t = verifyObjectProperty(shardingData, '@type', verifyString);
    if (t !== 'neuroglancer_uint64_sharded_v1') {
        throw new Error(`Unsupported sharding format: ${_JSON$stringify(t)}`);
    }
    const hash = verifyObjectProperty(shardingData, 'hash', y => verifyEnumString(y, ShardingHashFunction));
    const preshiftBits = verifyObjectProperty(shardingData, 'preshift_bits', verifyInt);
    const shardBits = verifyObjectProperty(shardingData, 'shard_bits', verifyInt);
    const minishardBits = verifyObjectProperty(shardingData, 'minishard_bits', verifyInt);
    const minishardIndexEncoding = verifyObjectProperty(shardingData, 'minishard_index_encoding', parseShardingEncoding);
    const dataEncoding = verifyObjectProperty(shardingData, 'data_encoding', parseShardingEncoding);
    return { hash, preshiftBits, shardBits, minishardBits, minishardIndexEncoding, dataEncoding };
}
function parseSkeletonMetadata(data) {
    verifyObject(data);
    const t = verifyObjectProperty(data, '@type', verifyString);
    if (t !== 'neuroglancer_skeletons') {
        throw new Error(`Unsupported skeleton type: ${_JSON$stringify(t)}`);
    }
    const transform = parseTransform(data);
    const vertexAttributes = new _Map();
    verifyObjectProperty(data, 'vertex_attributes', attributes => {
        if (attributes === undefined) return;
        parseArray(attributes, attributeData => {
            verifyObject(attributeData);
            const id = verifyObjectProperty(attributeData, 'id', verifyString);
            if (id === '') throw new Error('vertex attribute id must not be empty');
            if (vertexAttributes.has(id)) {
                throw new Error(`duplicate vertex attribute id ${_JSON$stringify(id)}`);
            }
            const dataType = verifyObjectProperty(attributeData, 'data_type', y => verifyEnumString(y, DataType));
            const numComponents = verifyObjectProperty(attributeData, 'num_components', verifyPositiveInt);
            vertexAttributes.set(id, { dataType, numComponents });
        });
    });
    const sharding = verifyObjectProperty(data, 'sharding', parseShardingParameters);
    const segmentPropertyMap = verifyObjectProperty(data, 'segment_properties', verifyOptionalString);
    return {
        metadata: { transform, vertexAttributes, sharding },
        segmentPropertyMap
    };
}
async function getSkeletonMetadata(chunkManager, credentialsProvider, url) {
    const metadata = await getJsonMetadata(chunkManager, credentialsProvider, url);
    return parseSkeletonMetadata(metadata);
}
function getDefaultCoordinateSpace() {
    return makeCoordinateSpace({ names: ['x', 'y', 'z'], units: ['m', 'm', 'm'], scales: Float64Array.of(1e-9, 1e-9, 1e-9) });
}
async function getMeshSource(chunkManager, credentialsProvider, url) {
    var _ref = await getMeshMetadata(chunkManager, credentialsProvider, url);

    const metadata = _ref.metadata,
          segmentPropertyMap = _ref.segmentPropertyMap;

    if (metadata === undefined) {
        return {
            source: getLegacyMeshSource(chunkManager, credentialsProvider, { url, lod: 0 }),
            transform: mat4.create(),
            segmentPropertyMap
        };
    }
    let vertexPositionFormat;
    const vertexQuantizationBits = metadata.vertexQuantizationBits;

    if (vertexQuantizationBits === 10) {
        vertexPositionFormat = VertexPositionFormat.uint10;
    } else if (vertexQuantizationBits === 16) {
        vertexPositionFormat = VertexPositionFormat.uint16;
    } else {
        throw new Error(`Invalid vertex quantization bits: ${vertexQuantizationBits}`);
    }
    return {
        source: chunkManager.getChunkSource(PrecomputedMultiscaleMeshSource, {
            credentialsProvider,
            parameters: { url, metadata },
            format: {
                fragmentRelativeVertices: true,
                vertexPositionFormat
            }
        }),
        transform: metadata.transform,
        segmentPropertyMap
    };
}
async function getSkeletonSource(chunkManager, credentialsProvider, url) {
    var _ref2 = await getSkeletonMetadata(chunkManager, credentialsProvider, url);

    const metadata = _ref2.metadata,
          segmentPropertyMap = _ref2.segmentPropertyMap;

    return {
        source: chunkManager.getChunkSource(PrecomputedSkeletonSource, {
            credentialsProvider,
            parameters: {
                url,
                metadata
            }
        }),
        transform: metadata.transform,
        segmentPropertyMap
    };
}
function getJsonMetadata(chunkManager, credentialsProvider, url) {
    return chunkManager.memoize.getUncounted({ 'type': 'precomputed:metadata', url, credentialsProvider: getObjectId(credentialsProvider) }, async () => {
        return await cancellableFetchSpecialOk(credentialsProvider, `${url}/info`, {}, responseJson);
    });
}
function getSubsourceToModelSubspaceTransform(info) {
    const m = mat4.create();
    const resolution = info.scales[0].resolution;
    for (let i = 0; i < 3; ++i) {
        m[5 * i] = 1 / resolution[i];
    }
    return m;
}
async function getVolumeDataSource(options, credentialsProvider, url, metadata) {
    const info = parseMultiscaleVolumeInfo(metadata);
    const volume = new PrecomputedMultiscaleVolumeChunkSource(options.chunkManager, credentialsProvider, url, info);
    const modelSpace = info.modelSpace;

    const subsources = [{
        id: 'default',
        default: true,
        subsource: { volume }
    }, {
        id: 'bounds',
        default: true,
        subsource: {
            staticAnnotations: makeDataBoundsBoundingBoxAnnotationSet(modelSpace.bounds)
        }
    }];
    if (info.segmentPropertyMap !== undefined) {
        const mapUrl = resolvePath(url, info.segmentPropertyMap);
        const metadata = await getJsonMetadata(options.chunkManager, credentialsProvider, mapUrl);
        const segmentPropertyMap = getSegmentPropertyMap(options.chunkManager, credentialsProvider, metadata, mapUrl);
        subsources.push({
            id: 'properties',
            default: true,
            subsource: { segmentPropertyMap }
        });
    }
    if (info.mesh !== undefined) {
        const meshUrl = resolvePath(url, info.mesh);

        var _ref3 = await getMeshSource(options.chunkManager, credentialsProvider, meshUrl);

        const meshSource = _ref3.source,
              transform = _ref3.transform;

        const subsourceToModelSubspaceTransform = getSubsourceToModelSubspaceTransform(info);
        mat4.multiply(subsourceToModelSubspaceTransform, subsourceToModelSubspaceTransform, transform);
        subsources.push({
            id: 'mesh',
            default: true,
            subsource: { mesh: meshSource },
            subsourceToModelSubspaceTransform
        });
    }
    if (info.skeletons !== undefined) {
        const skeletonsUrl = resolvePath(url, info.skeletons);

        var _ref4 = await getSkeletonSource(options.chunkManager, credentialsProvider, skeletonsUrl);

        const skeletonSource = _ref4.source,
              transform = _ref4.transform;

        const subsourceToModelSubspaceTransform = getSubsourceToModelSubspaceTransform(info);
        mat4.multiply(subsourceToModelSubspaceTransform, subsourceToModelSubspaceTransform, transform);
        subsources.push({
            id: 'skeletons',
            default: true,
            subsource: { mesh: skeletonSource },
            subsourceToModelSubspaceTransform
        });
    }
    return { modelTransform: makeIdentityTransform(modelSpace), subsources };
}
async function getSkeletonsDataSource(options, credentialsProvider, url) {
    var _ref5 = await getSkeletonSource(options.chunkManager, credentialsProvider, url);

    const skeletons = _ref5.source,
          transform = _ref5.transform,
          segmentPropertyMap = _ref5.segmentPropertyMap;

    const subsources = [{
        id: 'default',
        default: true,
        subsource: { mesh: skeletons },
        subsourceToModelSubspaceTransform: transform
    }];
    if (segmentPropertyMap !== undefined) {
        const mapUrl = resolvePath(url, segmentPropertyMap);
        const metadata = await getJsonMetadata(options.chunkManager, credentialsProvider, mapUrl);
        const segmentPropertyMapData = getSegmentPropertyMap(options.chunkManager, credentialsProvider, metadata, mapUrl);
        subsources.push({
            id: 'properties',
            default: true,
            subsource: { segmentPropertyMap: segmentPropertyMapData }
        });
    }
    return {
        modelTransform: makeIdentityTransform(getDefaultCoordinateSpace()),
        subsources
    };
}
function parseKeyAndShardingSpec(url, obj) {
    verifyObject(obj);
    return {
        url: resolvePath(url, verifyObjectProperty(obj, 'key', verifyString)),
        sharding: verifyObjectProperty(obj, 'sharding', parseShardingParameters)
    };
}
class AnnotationMetadata {
    constructor(url, metadata) {
        this.url = url;
        verifyObject(metadata);
        const baseCoordinateSpace = verifyObjectProperty(metadata, 'dimensions', coordinateSpaceFromJson);
        const rank = baseCoordinateSpace.rank;

        const lowerBounds = verifyObjectProperty(metadata, 'lower_bound', boundJson => parseFixedLengthArray(new Float64Array(rank), boundJson, verifyFiniteFloat));
        const upperBounds = verifyObjectProperty(metadata, 'upper_bound', boundJson => parseFixedLengthArray(new Float64Array(rank), boundJson, verifyFiniteFloat));
        this.coordinateSpace = makeCoordinateSpace({
            rank,
            names: baseCoordinateSpace.names,
            units: baseCoordinateSpace.units,
            scales: baseCoordinateSpace.scales,
            boundingBoxes: [makeIdentityTransformedBoundingBox({ lowerBounds, upperBounds })]
        });
        this.parameters = {
            type: verifyObjectProperty(metadata, 'annotation_type', typeObj => verifyEnumString(typeObj, AnnotationType)),
            rank,
            relationships: verifyObjectProperty(metadata, 'relationships', relsObj => parseArray(relsObj, relObj => {
                const common = parseKeyAndShardingSpec(url, relObj);
                const name = verifyObjectProperty(relObj, 'id', verifyString);
                return _Object$assign(_Object$assign({}, common), { name });
            })),
            properties: verifyObjectProperty(metadata, 'properties', parseAnnotationPropertySpecs),
            byId: verifyObjectProperty(metadata, 'by_id', obj => parseKeyAndShardingSpec(url, obj))
        };
        this.spatialIndices = verifyObjectProperty(metadata, 'spatial', spatialObj => parseArray(spatialObj, levelObj => {
            const common = parseKeyAndShardingSpec(url, levelObj);
            const gridShape = verifyObjectProperty(levelObj, 'grid_shape', j => parseFixedLengthArray(new Float32Array(rank), j, verifyPositiveInt));
            const chunkShape = verifyObjectProperty(levelObj, 'chunk_size', j => parseFixedLengthArray(new Float32Array(rank), j, verifyFinitePositiveFloat));
            const limit = verifyObjectProperty(levelObj, 'limit', verifyPositiveInt);
            const gridShapeInVoxels = new Float32Array(rank);
            for (let i = 0; i < rank; ++i) {
                gridShapeInVoxels[i] = gridShape[i] * chunkShape[i];
            }
            const chunkToMultiscaleTransform = matrix.createIdentity(Float32Array, rank + 1);
            for (let i = 0; i < rank; ++i) {
                chunkToMultiscaleTransform[(rank + 1) * rank + i] = lowerBounds[i];
            }
            const spec = _Object$assign({ limit,
                chunkToMultiscaleTransform }, makeSliceViewChunkSpecification({
                rank,
                chunkDataSize: chunkShape,
                upperVoxelBound: gridShapeInVoxels
            }));
            spec.upperChunkBound = gridShape;
            return {
                parameters: common,
                spec,
                limit
            };
        }));
        this.spatialIndices.reverse();
    }
}
async function getAnnotationDataSource(options, credentialsProvider, url, metadata) {
    const info = new AnnotationMetadata(url, metadata);
    const dataSource = {
        modelTransform: makeIdentityTransform(info.coordinateSpace),
        subsources: [{
            id: 'default',
            default: true,
            subsource: {
                annotation: options.chunkManager.getChunkSource(PrecomputedAnnotationSource, {
                    credentialsProvider,
                    metadata: info,
                    parameters: info.parameters
                })
            }
        }]
    };
    return dataSource;
}
async function getMeshDataSource(options, credentialsProvider, url) {
    var _ref6 = await getMeshSource(options.chunkManager, credentialsProvider, url);

    const mesh = _ref6.source,
          transform = _ref6.transform,
          segmentPropertyMap = _ref6.segmentPropertyMap;

    const subsources = [{
        id: 'default',
        default: true,
        subsource: { mesh },
        subsourceToModelSubspaceTransform: transform
    }];
    if (segmentPropertyMap !== undefined) {
        const mapUrl = resolvePath(url, segmentPropertyMap);
        const metadata = await getJsonMetadata(options.chunkManager, credentialsProvider, mapUrl);
        const segmentPropertyMapData = getSegmentPropertyMap(options.chunkManager, credentialsProvider, metadata, mapUrl);
        subsources.push({
            id: 'properties',
            default: true,
            subsource: { segmentPropertyMap: segmentPropertyMapData }
        });
    }
    return {
        modelTransform: makeIdentityTransform(getDefaultCoordinateSpace()),
        subsources
    };
}
function parseInlinePropertyMap(data) {
    verifyObject(data);
    const tempUint64 = new Uint64();
    const ids = verifyObjectProperty(data, 'ids', idsObj => {
        idsObj = verifyStringArray(idsObj);
        const numIds = idsObj.length;
        const ids = new Uint32Array(numIds * 2);
        for (let i = 0; i < numIds; ++i) {
            if (!tempUint64.tryParseString(idsObj[i])) {
                throw new Error(`Invalid uint64 id: ${_JSON$stringify(idsObj[i])}`);
            }
            ids[2 * i] = tempUint64.low;
            ids[2 * i + 1] = tempUint64.high;
        }
        return ids;
    });
    const numIds = ids.length / 2;
    const properties = verifyObjectProperty(data, 'properties', propertiesObj => parseArray(propertiesObj, propertyObj => {
        verifyObject(propertyObj);
        const id = verifyObjectProperty(propertyObj, 'id', verifyString);
        const description = verifyOptionalObjectProperty(propertyObj, 'description', verifyString);
        const type = verifyObjectProperty(propertyObj, 'type', type => {
            if (type !== 'label' && type !== 'description' && type !== 'string' && type !== 'tags' && type !== 'number') {
                throw new Error(`Invalid property type: ${_JSON$stringify(type)}`);
            }
            return type;
        });
        if (type === 'tags') {
            const tags = verifyObjectProperty(propertyObj, 'tags', verifyStringArray);
            let tagDescriptions = verifyOptionalObjectProperty(propertyObj, 'tag_descriptions', verifyStringArray);
            if (tagDescriptions === undefined) {
                tagDescriptions = new Array(tags.length);
                tagDescriptions.fill('');
            } else {
                if (tagDescriptions.length !== tags.length) {
                    throw new Error(`Expected tag_descriptions to have length: ${tags.length}`);
                }
            }
            const values = verifyObjectProperty(propertyObj, 'values', valuesObj => {
                if (!Array.isArray(valuesObj) || valuesObj.length !== numIds) {
                    throw new Error(`Expected ${numIds} values, but received: ${valuesObj.length}`);
                }
                return valuesObj.map(tagIndices => {
                    return String.fromCharCode(...tagIndices);
                });
            });
            return { id, description, type, tags, tagDescriptions, values };
        }
        if (type === 'number') {
            const dataType = verifyObjectProperty(propertyObj, 'data_type', x => verifyEnumString(x, DataType));
            if (dataType === DataType.UINT64) {
                throw new Error('uint64 properties not supported');
            }
            const values = verifyObjectProperty(propertyObj, 'values', valuesObj => {
                if (!Array.isArray(valuesObj) || valuesObj.length !== numIds) {
                    throw new Error(`Expected ${numIds} values, but received: ${valuesObj.length}`);
                }
                return DATA_TYPE_ARRAY_CONSTRUCTOR[dataType].from(valuesObj);
            });
            let min = Infinity,
                max = -Infinity;
            for (let i = values.length - 1; i >= 0; --i) {
                const v = values[i];
                if (v < min) min = v;
                if (v > max) max = v;
            }
            return { id, description, type, dataType, values, bounds: [min, max] };
        }
        const values = verifyObjectProperty(propertyObj, 'values', valuesObj => {
            verifyStringArray(valuesObj);
            if (valuesObj.length !== numIds) {
                throw new Error(`Expected ${numIds} values, but received: ${valuesObj.length}`);
            }
            return valuesObj;
        });
        return { id, description, type, values };
    }));
    return normalizeInlineSegmentPropertyMap({ ids, properties });
}
export const PrecomputedIndexedSegmentPropertySource = WithParameters(WithCredentialsProvider()(IndexedSegmentPropertySource), IndexedSegmentPropertySourceParameters);
// function parseIndexedPropertyMap(data: unknown): {
//   sharding: ShardingParameters|undefined,
//   properties: readonly Readonly<IndexedSegmentProperty>[]
// } {
//   verifyObject(data);
//   const sharding = verifyObjectProperty(data, 'sharding', parseShardingParameters);
//   const properties = verifyObjectProperty(
//       data, 'properties',
//       propertiesObj => parseArray(propertiesObj, (propertyObj): IndexedSegmentProperty => {
//         const id = verifyObjectProperty(propertyObj, 'id', verifyString);
//         const description = verifyOptionalObjectProperty(propertyObj, 'description', verifyString);
//         const type = verifyObjectProperty(propertyObj, 'type', type => {
//           if (type !== 'string') {
//             throw new Error(`Invalid property type: ${JSON.stringify(type)}`);
//           }
//           return type;
//         });
//         return {id, description, type};
//       }));
//   return {sharding, properties};
// }
export function getSegmentPropertyMap(chunkManager, credentialsProvider, data, url) {
    chunkManager;
    credentialsProvider;
    url;
    try {
        const t = verifyObjectProperty(data, '@type', verifyString);
        if (t !== 'neuroglancer_segment_properties') {
            throw new Error(`Unsupported segment property map type: ${_JSON$stringify(t)}`);
        }
        const inlineProperties = verifyOptionalObjectProperty(data, 'inline', parseInlinePropertyMap);
        // const indexedProperties = verifyOptionalObjectProperty(data, 'indexed', indexedObj => {
        //   const {sharding, properties} = parseIndexedPropertyMap(indexedObj);
        //   return chunkManager.getChunkSource(
        //       PrecomputedIndexedSegmentPropertySource,
        //       {credentialsProvider, properties, parameters: {sharding, url}});
        // });
        return new SegmentPropertyMap({ inlineProperties });
    } catch (e) {
        throw new Error(`Error parsing segment property map: ${e.message}`);
    }
}
async function getSegmentPropertyMapDataSource(options, credentialsProvider, url, metadata) {
    options;
    return {
        modelTransform: makeIdentityTransform(emptyValidCoordinateSpace),
        subsources: [{
            id: 'default',
            default: true,
            subsource: {
                segmentPropertyMap: getSegmentPropertyMap(options.chunkManager, credentialsProvider, metadata, url)
            }
        }]
    };
}
const urlPattern = /^([^#]*)(?:#(.*))?$/;
export function parseProviderUrl(providerUrl) {
    var _providerUrl$match = providerUrl.match(urlPattern),
        _providerUrl$match2 = _slicedToArray(_providerUrl$match, 3);

    let url = _providerUrl$match2[1],
        fragment = _providerUrl$match2[2];

    if (url.endsWith('/')) {
        url = url.substring(0, url.length - 1);
    }
    const parameters = parseQueryStringParameters(fragment || '');
    return { url, parameters };
}
function unparseProviderUrl(url, parameters) {
    const fragment = unparseQueryStringParameters(parameters);
    if (fragment) {
        url += `#${fragment}`;
    }
    return url;
}
export class PrecomputedDataSource extends DataSourceProvider {
    get description() {
        return 'Precomputed file-backed data source';
    }
    normalizeUrl(options) {
        var _parseProviderUrl = parseProviderUrl(options.providerUrl);

        const url = _parseProviderUrl.url,
              parameters = _parseProviderUrl.parameters;

        return options.providerProtocol + '://' + unparseProviderUrl(url, parameters);
    }
    convertLegacyUrl(options) {
        var _parseProviderUrl2 = parseProviderUrl(options.providerUrl);

        const url = _parseProviderUrl2.url,
              parameters = _parseProviderUrl2.parameters;

        if (options.type === 'mesh') {
            parameters['type'] = 'mesh';
        }
        return options.providerProtocol + '://' + unparseProviderUrl(url, parameters);
    }
    get(options) {
        var _parseProviderUrl3 = parseProviderUrl(options.providerUrl);

        const providerUrl = _parseProviderUrl3.url,
              parameters = _parseProviderUrl3.parameters;

        return options.chunkManager.memoize.getUncounted({ 'type': 'precomputed:get', providerUrl, parameters }, async () => {
            var _parseSpecialUrl = parseSpecialUrl(providerUrl, options.credentialsManager);

            const url = _parseSpecialUrl.url,
                  credentialsProvider = _parseSpecialUrl.credentialsProvider;

            let metadata;
            try {
                metadata = await getJsonMetadata(options.chunkManager, credentialsProvider, url);
            } catch (e) {
                if (isNotFoundError(e)) {
                    if (parameters['type'] === 'mesh') {
                        return await getMeshDataSource(options, credentialsProvider, url);
                    }
                }
                throw e;
            }
            verifyObject(metadata);
            const redirect = verifyOptionalObjectProperty(metadata, 'redirect', verifyString);
            if (redirect !== undefined) {
                throw new RedirectError(redirect);
            }
            const t = verifyOptionalObjectProperty(metadata, '@type', verifyString);
            switch (t) {
                case 'neuroglancer_skeletons':
                    return await getSkeletonsDataSource(options, credentialsProvider, url);
                case 'neuroglancer_multilod_draco':
                case 'neuroglancer_legacy_mesh':
                    return await getMeshDataSource(options, credentialsProvider, url);
                case 'neuroglancer_annotations_v1':
                    return await getAnnotationDataSource(options, credentialsProvider, url, metadata);
                case 'neuroglancer_segment_properties':
                    return await getSegmentPropertyMapDataSource(options, credentialsProvider, url, metadata);
                case 'neuroglancer_multiscale_volume':
                case undefined:
                    return await getVolumeDataSource(options, credentialsProvider, url, metadata);
                default:
                    throw new Error(`Invalid type: ${_JSON$stringify(t)}`);
            }
        });
    }
    completeUrl(options) {
        return completeHttpPath(options.credentialsManager, options.providerUrl, options.cancellationToken);
    }
}
//# sourceMappingURL=frontend.js.map