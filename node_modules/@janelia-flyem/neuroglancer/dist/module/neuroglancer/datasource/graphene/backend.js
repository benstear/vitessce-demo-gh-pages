import _slicedToArray from "babel-runtime/helpers/slicedToArray";
import _Map from "babel-runtime/core-js/map";
import _Promise from "babel-runtime/core-js/promise";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import { WithParameters } from "../../chunk_manager/backend";
import { WithSharedCredentialsProviderCounterpart } from "../../credentials_provider/shared_counterpart";
import { assignMeshFragmentData, MeshSource } from "../../mesh/backend";
import { getGrapheneFragmentKey, responseIdentity } from "./base";
import { isNotFoundError, responseArrayBuffer, responseJson } from "../../util/http_request";
import { cancellableFetchSpecialOk } from "../../util/special_protocol_request";
import { Uint64 } from "../../util/uint64";
import { registerSharedObject } from "../../worker_rpc";
import { ChunkedGraphSourceParameters, MeshSourceParameters } from "./base";
import { decodeManifestChunk } from "../precomputed/backend";
import { fetchSpecialHttpByteRange } from "../../util/byte_range_http_requests";
import debounce from 'lodash/debounce';
import { withChunkManager, Chunk, ChunkSource } from "../../chunk_manager/backend";
import { ChunkPriorityTier, ChunkState } from "../../chunk_manager/base";
import { forEachPlaneIntersectingVolumetricChunk, getNormalizedChunkLayout } from "../../sliceview/base";
import { CHUNKED_GRAPH_LAYER_RPC_ID, CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, RENDER_RATIO_LIMIT } from "./base";
import { Uint64Set } from "../../uint64_set";
import { vec3, vec3Key } from "../../util/geom";
import { registerRPC } from "../../worker_rpc";
import { deserializeTransformedSources } from "../../sliceview/backend";
import { getBasePriority, getPriorityTier, withSharedVisibility } from "../../visibility_priority/backend";
import { isBaseSegmentId } from "./base";
import { withSegmentationLayerBackendState } from "../../segmentation_display_state/backend";
import { RenderLayerBackend } from "../../render_layer_backend";
import { forEachVisibleSegment } from "../../segmentation_display_state/base";
import { computeChunkBounds } from "../../sliceview/volume/backend";
function getVerifiedFragmentPromise(credentialsProvider, chunk, parameters, cancellationToken) {
    if (chunk.fragmentId && chunk.fragmentId.charAt(0) === '~') {
        let parts = chunk.fragmentId.substr(1).split(':');
        let startOffset, endOffset;
        startOffset = Number(parts[1]);
        endOffset = startOffset + Number(parts[2]);
        return fetchSpecialHttpByteRange(credentialsProvider, `${parameters.fragmentUrl}/initial/${parts[0]}`, startOffset, endOffset, cancellationToken);
    }
    return cancellableFetchSpecialOk(credentialsProvider, `${parameters.fragmentUrl}/dynamic/${chunk.fragmentId}`, {}, responseArrayBuffer, cancellationToken);
}
function getFragmentDownloadPromise(credentialsProvider, chunk, parameters, cancellationToken) {
    let fragmentDownloadPromise;
    if (parameters.sharding) {
        fragmentDownloadPromise = getVerifiedFragmentPromise(credentialsProvider, chunk, parameters, cancellationToken);
    } else {
        fragmentDownloadPromise = cancellableFetchSpecialOk(credentialsProvider, `${parameters.fragmentUrl}/${chunk.fragmentId}`, {}, responseArrayBuffer, cancellationToken);
    }
    return fragmentDownloadPromise;
}
async function decodeDracoFragmentChunk(chunk, response) {
    const m = await import( /* webpackChunkName: "draco" */"../../mesh/draco");
    const rawMesh = await m.decodeDraco(new Uint8Array(response));
    assignMeshFragmentData(chunk, rawMesh);
}
let GrapheneMeshSource = class GrapheneMeshSource extends WithParameters(WithSharedCredentialsProviderCounterpart()(MeshSource), MeshSourceParameters) {
    async download(chunk, cancellationToken) {
        const parameters = this.parameters;

        if (isBaseSegmentId(chunk.objectId, parameters.nBitsForLayerId)) {
            return decodeManifestChunk(chunk, { fragments: [] });
        }
        let url = `${parameters.manifestUrl}/manifest`;
        let manifestUrl = `${url}/${chunk.objectId}:${parameters.lod}?verify=1&prepend_seg_ids=1`;
        await cancellableFetchSpecialOk(this.credentialsProvider, manifestUrl, {}, responseJson, cancellationToken).then(response => decodeManifestChunk(chunk, response));
    }
    async downloadFragment(chunk, cancellationToken) {
        const parameters = this.parameters;

        try {
            const response = await getFragmentDownloadPromise(undefined, chunk, parameters, cancellationToken);
            await decodeDracoFragmentChunk(chunk, response);
        } catch (e) {
            if (isNotFoundError(e)) {
                chunk.source.removeChunk(chunk);
            }
            _Promise.reject(e);
        }
    }
    getFragmentKey(objectKey, fragmentId) {
        objectKey;
        return getGrapheneFragmentKey(fragmentId);
    }
};
GrapheneMeshSource = __decorate([registerSharedObject()], GrapheneMeshSource);
export { GrapheneMeshSource };
export class ChunkedGraphChunk extends Chunk {
    constructor() {
        super(...arguments);
        this.backendOnly = true;
        this.source = null;
        this.leaves = [];
    }
    initializeVolumeChunk(key, chunkGridPosition) {
        super.initialize(key);
        this.chunkGridPosition = Float32Array.from(chunkGridPosition);
    }
    initializeChunkedGraphChunk(key, chunkGridPosition, segment) {
        this.initializeVolumeChunk(key, chunkGridPosition);
        this.chunkDataSize = null;
        this.systemMemoryBytes = 16;
        this.gpuMemoryBytes = 0;
        this.segment = segment;
    }
    downloadSucceeded() {
        this.systemMemoryBytes = 16; // this.segment
        this.systemMemoryBytes += 16 * this.leaves.length;
        this.queueManager.updateChunkState(this, ChunkState.SYSTEM_MEMORY_WORKER);
        if (this.priorityTier < ChunkPriorityTier.RECENT) {
            this.source.chunkManager.scheduleUpdateChunkPriorities();
        }
        super.downloadSucceeded();
    }
    freeSystemMemory() {
        this.leaves = [];
    }
}
function decodeChunkedGraphChunk(leaves) {
    const final = new Array(leaves.length);
    for (let i = 0; i < final.length; ++i) {
        final[i] = Uint64.parseString(leaves[i]);
    }
    return final;
}
let GrapheneChunkedGraphChunkSource = class GrapheneChunkedGraphChunkSource extends WithParameters(WithSharedCredentialsProviderCounterpart()(ChunkSource), ChunkedGraphSourceParameters) {
    constructor(rpc, options) {
        super(rpc, options);
        this.spec = options.spec;
        const rank = this.spec.rank;
        this.tempChunkDataSize = new Uint32Array(rank);
        this.tempChunkPosition = new Float32Array(rank);
    }
    async download(chunk, cancellationToken) {
        let parameters = this.parameters;

        let chunkPosition = this.computeChunkBounds(chunk);
        let chunkDataSize = chunk.chunkDataSize;
        let bounds = `${chunkPosition[0]}-${chunkPosition[0] + chunkDataSize[0]}_` + `${chunkPosition[1]}-${chunkPosition[1] + chunkDataSize[1]}_` + `${chunkPosition[2]}-${chunkPosition[2] + chunkDataSize[2]}`;
        const request = cancellableFetchSpecialOk(this.credentialsProvider, `${parameters.url}/${chunk.segment}/leaves?int64_as_str=1&bounds=${bounds}`, {}, responseIdentity, cancellationToken);
        await this.withErrorMessage(request, `Fetching leaves of segment ${chunk.segment} in region ${bounds}: `).then(res => res.json()).then(res => {
            chunk.leaves = decodeChunkedGraphChunk(res['leaf_ids']);
        }).catch(err => console.error(err));
    }
    getChunk(chunkGridPosition, segment) {
        const key = `${vec3Key(chunkGridPosition)}-${segment}`;
        let chunk = this.chunks.get(key);
        if (chunk === undefined) {
            chunk = this.getNewChunk_(ChunkedGraphChunk);
            chunk.initializeChunkedGraphChunk(key, chunkGridPosition, segment);
            this.addChunk(chunk);
        }
        return chunk;
    }
    computeChunkBounds(chunk) {
        return computeChunkBounds(this, chunk);
    }
    async withErrorMessage(promise, errorPrefix) {
        const response = await promise;
        if (response.ok) {
            return response;
        } else {
            let msg;
            try {
                msg = (await response.json())['message'];
            } catch (_a) {
                msg = await response.text();
            }
            throw new Error(`[${response.status}] ${errorPrefix}${msg}`);
        }
    }
};
GrapheneChunkedGraphChunkSource = __decorate([registerSharedObject()], GrapheneChunkedGraphChunkSource);
export { GrapheneChunkedGraphChunkSource };
const tempChunkPosition = vec3.create();
const tempCenter = vec3.create();
const tempChunkSize = vec3.create();
let ChunkedGraphLayer = class ChunkedGraphLayer extends withSegmentationLayerBackendState(withSharedVisibility(withChunkManager(RenderLayerBackend))) {
    constructor(rpc, options) {
        super(rpc, options);
        this.debouncedupdateDisplayState = debounce(() => {
            this.updateDisplayState();
        }, 100);
        this.source = this.registerDisposer(rpc.getRef(options['source']));
        this.localPosition = rpc.get(options.localPosition);
        this.leafRequestsActive = rpc.get(options.leafRequestsActive);
        this.nBitsForLayerId = rpc.get(options.nBitsForLayerId);
        this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => {
            this.updateChunkPriorities();
            this.debouncedupdateDisplayState();
        }));
    }
    attach(attachment) {
        const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
        const view = attachment.view;

        attachment.registerDisposer(scheduleUpdateChunkPriorities);
        attachment.registerDisposer(view.projectionParameters.changed.add(scheduleUpdateChunkPriorities));
        attachment.registerDisposer(view.visibility.changed.add(scheduleUpdateChunkPriorities));
        attachment.state = {
            displayDimensionRenderInfo: view.projectionParameters.value.displayDimensionRenderInfo
        };
    }
    // Used for the sliceview to set a limit on when to
    // make get_leaves to the ChunkedGraph
    get renderRatioLimit() {
        return RENDER_RATIO_LIMIT;
    }
    updateChunkPriorities() {
        const source = this.source,
              chunkManager = this.chunkManager;

        chunkManager.registerLayer(this);
        for (const attachment of this.attachments.values()) {
            const view = attachment.view;

            const visibility = view.visibility.value;
            if (visibility === Number.NEGATIVE_INFINITY) {
                continue;
            }
            const attachmentState = attachment.state;
            const tsource = attachmentState.transformedSource;

            const projectionParameters = view.projectionParameters.value;
            if (!tsource) {
                continue;
            }
            const pixelSize = projectionParameters.pixelSize * 1.1;
            const smallestVoxelSize = tsource.effectiveVoxelSize;
            this.leafRequestsActive.value = this.renderRatioLimit >= pixelSize / Math.min(...smallestVoxelSize);
            if (!this.leafRequestsActive.value) {
                continue;
            }
            const priorityTier = getPriorityTier(visibility);
            const basePriority = getBasePriority(visibility);
            const chunkLayout = tsource.chunkLayout;
            const size = chunkLayout.size,
                  finiteRank = chunkLayout.finiteRank;

            const chunkSize = tempChunkSize;
            const localCenter = tempCenter;
            vec3.copy(chunkSize, size);
            for (let i = finiteRank; i < 3; ++i) {
                chunkSize[i] = 0;
                localCenter[i] = 0;
            }
            const centerDataPosition = projectionParameters.centerDataPosition;

            chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);
            forEachPlaneIntersectingVolumetricChunk(projectionParameters, this.localPosition.value, tsource, getNormalizedChunkLayout(projectionParameters, chunkLayout), positionInChunks => {
                vec3.multiply(tempChunkPosition, positionInChunks, chunkSize);
                const priority = -vec3.distance(localCenter, tempChunkPosition);
                const curPositionInChunks = tsource.curPositionInChunks;

                forEachVisibleSegment(this, (segment, _) => {
                    if (isBaseSegmentId(segment, this.nBitsForLayerId.value)) return; // TODO maybe support highBitRepresentation?
                    const chunk = source.getChunk(curPositionInChunks, segment.clone());
                    chunkManager.requestChunk(chunk, priorityTier, basePriority + priority);
                    ++this.numVisibleChunksNeeded;
                    if (chunk.state === ChunkState.GPU_MEMORY) {
                        ++this.numVisibleChunksAvailable;
                    }
                });
            });
        }
    }
    forEachSelectedRootWithLeaves(callback) {
        const source = this.source;

        for (const chunk of source.chunks.values()) {
            if (chunk.state === ChunkState.SYSTEM_MEMORY_WORKER && chunk.priorityTier < ChunkPriorityTier.RECENT) {
                if (this.visibleSegments.has(chunk.segment) && chunk.leaves.length) {
                    callback(chunk.segment.toString(), chunk.leaves);
                }
            }
        }
    }
    updateDisplayState() {
        const visibleLeaves = new _Map();
        const capacities = new _Map();
        // Reserve
        this.forEachSelectedRootWithLeaves((rootObjectKey, leaves) => {
            if (!capacities.has(rootObjectKey)) {
                capacities.set(rootObjectKey, leaves.length);
            } else {
                capacities.set(rootObjectKey, capacities.get(rootObjectKey) + leaves.length);
            }
        });
        // Collect unique leaves
        this.forEachSelectedRootWithLeaves((rootObjectKey, leaves) => {
            if (!visibleLeaves.has(rootObjectKey)) {
                visibleLeaves.set(rootObjectKey, new Uint64Set());
                visibleLeaves.get(rootObjectKey).reserve(capacities.get(rootObjectKey));
                visibleLeaves.get(rootObjectKey).add(Uint64.parseString(rootObjectKey));
            }
            visibleLeaves.get(rootObjectKey).add(leaves);
        });
        for (const _ref of visibleLeaves) {
            var _ref2 = _slicedToArray(_ref, 2);

            const root = _ref2[0];
            const leaves = _ref2[1];

            // TODO: Delete segments not visible anymore from segmentEquivalences - requires a faster data
            // structure, though.
            /*if (this.segmentEquivalences.has(Uint64.parseString(root))) {
              this.segmentEquivalences.delete([...this.segmentEquivalences.setElements(Uint64.parseString(root))].filter(x
            => !leaves.has(x) && !this.visibleSegments.has(x)));
            }*/
            const filteredLeaves = [...leaves].filter(x => !this.segmentEquivalences.has(x));
            const rootInt = Uint64.parseString(root);
            for (const leaf of filteredLeaves) {
                this.segmentEquivalences.link(rootInt, leaf);
            }
        }
    }
};
ChunkedGraphLayer = __decorate([registerSharedObject(CHUNKED_GRAPH_LAYER_RPC_ID)], ChunkedGraphLayer);
export { ChunkedGraphLayer };
registerRPC(CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, function (x) {
    const view = this.get(x.view);
    const layer = this.get(x.layer);
    const attachment = layer.attachments.get(view);
    attachment.state.transformedSource = deserializeTransformedSources(this, x.sources, layer)[0][0];
    attachment.state.displayDimensionRenderInfo = x.displayDimensionRenderInfo;
    layer.chunkManager.scheduleUpdateChunkPriorities();
});
//# sourceMappingURL=backend.js.map