import _Object$assign from "babel-runtime/core-js/object/assign";
/**
 * @license
 * Copyright 2019 The Neuroglancer Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { makeSliceViewChunkSpecification } from "../../sliceview/base";
export const PYCG_APP_VERSION = 1;
export var VolumeChunkEncoding;
(function (VolumeChunkEncoding) {
    VolumeChunkEncoding[VolumeChunkEncoding["RAW"] = 0] = "RAW";
    VolumeChunkEncoding[VolumeChunkEncoding["JPEG"] = 1] = "JPEG";
    VolumeChunkEncoding[VolumeChunkEncoding["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
})(VolumeChunkEncoding || (VolumeChunkEncoding = {}));
export class VolumeChunkSourceParameters {}
VolumeChunkSourceParameters.RPC_ID = 'graphene/VolumeChunkSource';
export class ChunkedGraphSourceParameters {}
ChunkedGraphSourceParameters.RPC_ID = 'graphene/ChunkedGraphSource';
export class MeshSourceParameters {}
MeshSourceParameters.RPC_ID = 'graphene/MeshSource';
export class MultiscaleMeshMetadata {}
import { Uint64 } from "../../util/uint64";
export const responseIdentity = async x => x;
export function isBaseSegmentId(segmentId, nBitsForLayerId) {
    const layerId = Uint64.rshift(new Uint64(), segmentId, 64 - nBitsForLayerId);
    return Uint64.equal(layerId, Uint64.ONE);
}
export function getGrapheneFragmentKey(fragmentId) {
    const sharded = fragmentId.charAt(0) === '~';
    if (sharded) {
        const parts = fragmentId.substring(1).split(/:(.+)/);
        return { key: parts[0], fragmentId: parts[1] };
    } else {
        return { key: fragmentId, fragmentId: fragmentId };
    }
}
export const CHUNKED_GRAPH_LAYER_RPC_ID = 'ChunkedGraphLayer';
export const CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID = 'ChunkedGraphLayer:updateSources';
export const RENDER_RATIO_LIMIT = 5.0;
export function makeChunkedGraphChunkSpecification(options) {
    const rank = options.rank,
          dataType = options.dataType;
    var _options$baseVoxelOff = options.baseVoxelOffset;
    const baseVoxelOffset = _options$baseVoxelOff === undefined ? new Float32Array(rank) : _options$baseVoxelOff;

    return _Object$assign(_Object$assign({}, makeSliceViewChunkSpecification(options)), { baseVoxelOffset,
        dataType });
}
//# sourceMappingURL=base.js.map