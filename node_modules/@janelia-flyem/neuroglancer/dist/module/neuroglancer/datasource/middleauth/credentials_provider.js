import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Promise from 'babel-runtime/core-js/promise';
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { CredentialsProvider, makeCredentialsGetter } from '../../credentials_provider';
import { StatusMessage } from '../../status';
import { verifyObject, verifyObjectProperty, verifyString, verifyStringArray } from '../../util/json';
function openPopupCenter(url, width, height) {
    const top = window.outerHeight - window.innerHeight + window.innerHeight / 2 - height / 2;
    const left = window.innerWidth / 2 - width / 2;
    return window.open(url, undefined, `toolbar=no, menubar=no, width=${width}, height=${height}, top=${top}, left=${left}`);
}
async function waitForLogin(serverUrl) {
    const status = new StatusMessage( /*delay=*/false);
    const res = new _Promise(f => {
        function writeLoginStatus(message, buttonMessage) {
            status.element.textContent = message + ' ';
            const button = document.createElement('button');
            button.textContent = buttonMessage;
            status.element.appendChild(button);
            button.addEventListener('click', () => {
                writeLoginStatus(`Waiting for login to middleauth server ${serverUrl}...`, 'Retry');
                const auth_popup = openPopupCenter(`${serverUrl}/api/v1/authorize`, 400, 650);
                const closeAuthPopup = () => {
                    auth_popup === null || auth_popup === void 0 ? void 0 : auth_popup.close();
                };
                window.addEventListener('beforeunload', closeAuthPopup);
                const checkClosed = setInterval(() => {
                    if (auth_popup === null || auth_popup === void 0 ? void 0 : auth_popup.closed) {
                        clearInterval(checkClosed);
                        writeLoginStatus(`Login window closed for middleauth server ${serverUrl}.`, 'Retry');
                    }
                }, 1000);
                const tokenListener = async ev => {
                    if (ev.source === auth_popup) {
                        clearInterval(checkClosed);
                        window.removeEventListener('message', tokenListener);
                        window.removeEventListener('beforeunload', closeAuthPopup);
                        closeAuthPopup();
                        verifyObject(ev.data);
                        const accessToken = verifyObjectProperty(ev.data, 'token', verifyString);
                        const appUrls = verifyObjectProperty(ev.data, 'app_urls', verifyStringArray);
                        const token = { tokenType: 'Bearer', accessToken, url: serverUrl, appUrls };
                        f(token);
                    }
                };
                window.addEventListener('message', tokenListener);
            });
        }
        writeLoginStatus(`middleauth server ${serverUrl} login required.`, 'Login');
    });
    try {
        return await res;
    } finally {
        status.dispose();
    }
}
const LOCAL_STORAGE_AUTH_KEY = 'auth_token_v2';
function getAuthTokenFromLocalStorage(authURL) {
    const token = localStorage.getItem(`${LOCAL_STORAGE_AUTH_KEY}_${authURL}`);
    if (token) {
        return JSON.parse(token);
    } else {
        return null;
    }
}
function saveAuthTokenToLocalStorage(authURL, value) {
    localStorage.setItem(`${LOCAL_STORAGE_AUTH_KEY}_${authURL}`, _JSON$stringify(value));
}
export class MiddleAuthCredentialsProvider extends CredentialsProvider {
    constructor(serverUrl) {
        super();
        this.serverUrl = serverUrl;
        this.alreadyTriedLocalStorage = false;
        this.get = makeCredentialsGetter(async () => {
            let token = undefined;
            if (!this.alreadyTriedLocalStorage) {
                this.alreadyTriedLocalStorage = true;
                token = getAuthTokenFromLocalStorage(this.serverUrl);
            }
            if (!token) {
                token = await waitForLogin(this.serverUrl);
                saveAuthTokenToLocalStorage(this.serverUrl, token);
            }
            return token;
        });
    }
}
export class UnverifiedApp extends Error {
    constructor(url) {
        super();
        this.url = url;
    }
}
export class MiddleAuthAppCredentialsProvider extends CredentialsProvider {
    constructor(serverUrl, credentialsManager) {
        super();
        this.serverUrl = serverUrl;
        this.credentialsManager = credentialsManager;
        this.credentials = undefined;
        this.get = makeCredentialsGetter(async () => {
            const authInfo = await fetch(`${this.serverUrl}/auth_info`).then(res => res.json());
            const provider = this.credentialsManager.getCredentialsProvider('middleauth', authInfo.login_url);
            this.credentials = await provider.get(this.credentials);
            if (this.credentials.credentials.appUrls.includes(this.serverUrl)) {
                return this.credentials.credentials;
            } else {
                const status = new StatusMessage( /*delay=*/false);
                status.setText(`middleauth: unverified app ${this.serverUrl}`);
                throw new UnverifiedApp(this.serverUrl);
            }
        });
    }
}
//# sourceMappingURL=credentials_provider.js.map