import _Promise from 'babel-runtime/core-js/promise';
import _Array$from from 'babel-runtime/core-js/array/from';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Set from 'babel-runtime/core-js/set';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { emptyValidCoordinateSpace, makeCoordinateSpace, makeIdentityTransform } from '../coordinate_transform';
import { uncancelableToken } from '../util/cancellation';
import { applyCompletionOffset, getPrefixMatchesWithDescriptions } from '../util/completion';
import { RefCounted } from '../util/disposable';
import { createIdentity } from '../util/matrix';
export class RedirectError extends Error {
    constructor(redirectTarget) {
        super(`Redirected to: ${redirectTarget}`);
        this.redirectTarget = redirectTarget;
    }
}
/**
 * Returns the length of the prefix of path that corresponds to the "group", according to the
 * specified separator.
 *
 * If the separator is not specified, gueses whether it is '/' or ':'.
 */
export function findSourceGroupBasedOnSeparator(path, separator) {
    if (separator === undefined) {
        // Try to guess whether '/' or ':' is the separator.
        if (path.indexOf('/') === -1) {
            separator = ':';
        } else {
            separator = '/';
        }
    }
    let index = path.lastIndexOf(separator);
    if (index === -1) {
        return 0;
    }
    return index + 1;
}
/**
 * Returns the last "component" of path, according to the specified separator.
 * If the separator is not specified, gueses whether it is '/' or ':'.
 */
export function suggestLayerNameBasedOnSeparator(path, separator) {
    let groupIndex = findSourceGroupBasedOnSeparator(path, separator);
    return path.substring(groupIndex);
}
export var LocalDataSource;
(function (LocalDataSource) {
    LocalDataSource[LocalDataSource["annotations"] = 0] = "annotations";
    LocalDataSource[LocalDataSource["equivalences"] = 1] = "equivalences";
})(LocalDataSource || (LocalDataSource = {}));
export function makeEmptyDataSourceSpecification() {
    return { url: '', transform: undefined, enableDefaultSubsources: true, subsources: new _Map() };
}
export class DataSourceProvider extends RefCounted {
    normalizeUrl(options) {
        return options.url;
    }
    convertLegacyUrl(options) {
        return options.url;
    }
    async completeUrl(options) {
        options;
        throw null;
    }
}
export const localAnnotationsUrl = 'local://annotations';
export const localEquivalencesUrl = 'local://equivalences';
class LocalDataSourceProvider extends DataSourceProvider {
    get description() {
        return 'Local in-memory';
    }
    async get(options) {
        switch (options.url) {
            case localAnnotationsUrl:
                {
                    const transform = options.transform;

                    let modelTransform;
                    if (transform === undefined) {
                        const baseSpace = options.globalCoordinateSpace.value;
                        const rank = baseSpace.rank,
                              names = baseSpace.names,
                              scales = baseSpace.scales,
                              units = baseSpace.units;

                        const inputSpace = makeCoordinateSpace({
                            rank,
                            scales,
                            units,
                            names: names.map((_, i) => `${i}`)
                        });
                        const outputSpace = makeCoordinateSpace({ rank, scales, units, names });
                        modelTransform = {
                            rank,
                            sourceRank: rank,
                            inputSpace,
                            outputSpace,
                            transform: createIdentity(Float64Array, rank + 1)
                        };
                    } else {
                        modelTransform = makeIdentityTransform(emptyValidCoordinateSpace);
                    }
                    return {
                        modelTransform,
                        canChangeModelSpaceRank: true,
                        subsources: [{
                            id: 'default',
                            default: true,
                            subsource: {
                                local: LocalDataSource.annotations
                            }
                        }]
                    };
                }
            case localEquivalencesUrl:
                {
                    return {
                        modelTransform: makeIdentityTransform(emptyValidCoordinateSpace),
                        canChangeModelSpaceRank: false,
                        subsources: [{
                            id: 'default',
                            default: true,
                            subsource: {
                                local: LocalDataSource.equivalences
                            }
                        }]
                    };
                }
        }
        throw new Error('Invalid local data source URL');
    }
    async completeUrl(options) {
        return {
            offset: 0,
            completions: getPrefixMatchesWithDescriptions(options.providerUrl, [{
                value: 'annotations',
                description: 'Annotations stored in the JSON state'
            }, {
                value: 'equivalences',
                description: 'Segmentation equivalence graph stored in the JSON state'
            }], x => x.value, x => x.description)
        };
    }
}
const protocolPattern = /^(?:([a-zA-Z][a-zA-Z0-9-+_]*):\/\/)?(.*)$/;
export class DataSourceProviderRegistry extends RefCounted {
    constructor(credentialsManager) {
        super();
        this.credentialsManager = credentialsManager;
        this.dataSources = new _Map([['local', new LocalDataSourceProvider()]]);
    }
    register(name, dataSource) {
        this.dataSources.set(name, this.registerDisposer(dataSource));
    }
    getProvider(url) {
        const m = url.match(protocolPattern);
        if (m === null || m[1] === undefined) {
            throw new Error(`Data source URL must have the form "<protocol>://<path>".`);
        }

        var _m = _slicedToArray(m, 3);

        const providerProtocol = _m[1],
              providerUrl = _m[2];

        const factory = this.dataSources.get(providerProtocol);
        if (factory === undefined) {
            throw new Error(`Unsupported data source: ${_JSON$stringify(providerProtocol)}.`);
        }
        return [factory, providerUrl, providerProtocol];
    }
    async get(options) {
        const redirectLog = new _Set();
        var _options$cancellation = options.cancellationToken;
        const cancellationToken = _options$cancellation === undefined ? uncancelableToken : _options$cancellation;

        let url = options.url;
        while (true) {
            var _getProvider = this.getProvider(options.url),
                _getProvider2 = _slicedToArray(_getProvider, 3);

            const provider = _getProvider2[0],
                  providerUrl = _getProvider2[1],
                  providerProtocol = _getProvider2[2];

            redirectLog.add(options.url);
            try {
                return provider.get(_Object$assign(_Object$assign({}, options), { url,
                    providerProtocol,
                    providerUrl, registry: this, cancellationToken, credentialsManager: this.credentialsManager }));
            } catch (e) {
                if (e instanceof RedirectError) {
                    const redirect = e.redirectTarget;
                    if (redirectLog.has(redirect)) {
                        throw Error(`Layer source redirection contains loop: ${_JSON$stringify(_Array$from(redirectLog))}`);
                    }
                    if (redirectLog.size >= 10) {
                        throw Error(`Too many layer source redirections: ${_JSON$stringify(_Array$from(redirectLog))}`);
                    }
                    url = redirect;
                    continue;
                }
                throw e;
            }
        }
    }
    convertLegacyUrl(options) {
        try {
            var _getProvider3 = this.getProvider(options.url),
                _getProvider4 = _slicedToArray(_getProvider3, 3);

            const provider = _getProvider4[0],
                  providerUrl = _getProvider4[1],
                  providerProtocol = _getProvider4[2];

            return provider.convertLegacyUrl(_Object$assign(_Object$assign({}, options), { providerUrl, providerProtocol, registry: this }));
        } catch (_a) {
            return options.url;
        }
    }
    normalizeUrl(options) {
        try {
            var _getProvider5 = this.getProvider(options.url),
                _getProvider6 = _slicedToArray(_getProvider5, 3);

            const provider = _getProvider6[0],
                  providerUrl = _getProvider6[1],
                  providerProtocol = _getProvider6[2];

            return provider.normalizeUrl(_Object$assign(_Object$assign({}, options), { providerUrl, providerProtocol, registry: this }));
        } catch (_a) {
            return options.url;
        }
    }
    async completeUrl(options) {
        // Check if url matches a protocol.  Note that protocolPattern always matches.
        const url = options.url;
        var _options$cancellation2 = options.cancellationToken;
        const cancellationToken = _options$cancellation2 === undefined ? uncancelableToken : _options$cancellation2;

        let protocolMatch = url.match(protocolPattern);
        let protocol = protocolMatch[1];
        if (protocol === undefined) {
            return _Promise.resolve({
                offset: 0,
                completions: getPrefixMatchesWithDescriptions(url, this.dataSources, ([name]) => `${name}://`, ([, factory]) => factory.description)
            });
        } else {
            const factory = this.dataSources.get(protocol);
            if (factory !== undefined) {
                const completions = await factory.completeUrl({
                    registry: this,
                    url,
                    providerUrl: protocolMatch[2],
                    chunkManager: options.chunkManager,
                    cancellationToken,
                    credentialsManager: this.credentialsManager
                });
                return applyCompletionOffset(protocol.length + 3, completions);
            }
            throw null;
        }
    }
    suggestLayerName(url) {
        var _getProvider7 = this.getProvider(url),
            _getProvider8 = _slicedToArray(_getProvider7, 2);

        let dataSource = _getProvider8[0],
            path = _getProvider8[1];

        if (path.endsWith('/')) {
            path = path.substring(0, path.length - 1);
        }
        let suggestor = dataSource.suggestLayerName;
        if (suggestor !== undefined) {
            return suggestor(path);
        }
        return suggestLayerNameBasedOnSeparator(path);
    }
    findSourceGroup(url) {
        var _getProvider9 = this.getProvider(url),
            _getProvider10 = _slicedToArray(_getProvider9, 3);

        let dataSource = _getProvider10[0],
            path = _getProvider10[1],
            dataSourceName = _getProvider10[2];

        let helper = dataSource.findSourceGroup || findSourceGroupBasedOnSeparator;
        return helper(path) + dataSourceName.length + 3;
    }
}
//# sourceMappingURL=index.js.map