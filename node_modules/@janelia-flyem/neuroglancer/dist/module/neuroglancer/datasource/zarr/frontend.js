import _Promise from 'babel-runtime/core-js/promise';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Array$from from 'babel-runtime/core-js/array/from';
import _Number$isInteger from 'babel-runtime/core-js/number/is-integer';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { makeDataBoundsBoundingBoxAnnotationSet } from '../../annotation';
import { WithParameters } from '../../chunk_manager/frontend';
import { makeCoordinateSpace, makeIdentityTransform, makeIdentityTransformedBoundingBox } from '../../coordinate_transform';
import { WithCredentialsProvider } from '../../credentials_provider/chunk_source_frontend';
import { DataSourceProvider } from './..';
import { VolumeChunkSourceParameters, ZarrCompressor } from './base';
import { makeDefaultVolumeChunkSpecifications, VolumeType } from '../../sliceview/volume/base';
import { MultiscaleVolumeChunkSource as GenericMultiscaleVolumeChunkSource, VolumeChunkSource } from '../../sliceview/volume/frontend';
import { transposeNestedArrays } from '../../util/array';
import { applyCompletionOffset, completeQueryStringParametersFromTable } from '../../util/completion';
import { completeHttpPath } from '../../util/http_path_completion';
import { isNotFoundError, responseJson } from '../../util/http_request';
import { parseArray, parseFixedLengthArray, parseQueryStringParameters, verifyObject, verifyObjectProperty, verifyOptionalObjectProperty, verifyString } from '../../util/json';
import { createIdentity } from '../../util/matrix';
import { parseNumpyDtype } from '../../util/numpy_dtype';
import { getObjectId } from '../../util/object_id';
import { cancellableFetchSpecialOk, parseSpecialUrl } from '../../util/special_protocol_request';
class ZarrVolumeChunkSource extends WithParameters(WithCredentialsProvider()(VolumeChunkSource), VolumeChunkSourceParameters) {}
function parseDimensionSeparator(obj) {
    return verifyOptionalObjectProperty(obj, 'dimension_separator', value => {
        if (value !== '.' && value !== '/') {
            throw new Error(`Expected "." or "/", but received: ${_JSON$stringify(value)}`);
        }
        return value;
    });
}
function parseZarrMetadata(obj) {
    try {
        verifyObject(obj);
        verifyObjectProperty(obj, 'zarr_format', zarrFormat => {
            if (zarrFormat !== 2) {
                throw new Error(`Expected 2 but received: ${_JSON$stringify(zarrFormat)}`);
            }
        });
        const shape = verifyObjectProperty(obj, 'shape', shape => parseArray(shape, x => {
            if (typeof x !== 'number' || !_Number$isInteger(x) || x < 0) {
                throw new Error(`Expected non-negative integer, but received: ${_JSON$stringify(x)}`);
            }
            return x;
        }));
        const chunks = verifyObjectProperty(obj, 'chunks', chunks => parseFixedLengthArray(new Array(shape.length), chunks, x => {
            if (typeof x !== 'number' || !_Number$isInteger(x) || x <= 0) {
                throw new Error(`Expected positive integer, but received: ${_JSON$stringify(x)}`);
            }
            return x;
        }));
        const order = verifyObjectProperty(obj, 'order', order => {
            if (order !== 'C' && order !== 'F') {
                throw new Error(`Expected "C" or "F", but received: ${_JSON$stringify(order)}`);
            }
            return order;
        });
        const dimensionSeparator = parseDimensionSeparator(obj);
        const numpyDtype = verifyObjectProperty(obj, 'dtype', dtype => parseNumpyDtype(verifyString(dtype)));
        const compressor = verifyObjectProperty(obj, 'compressor', compressor => {
            if (compressor === null) return ZarrCompressor.RAW;
            verifyObject(compressor);
            const id = verifyObjectProperty(compressor, 'id', verifyString);
            switch (id) {
                case 'blosc':
                    return ZarrCompressor.BLOSC;
                case 'gzip':
                    return ZarrCompressor.GZIP;
                case 'zlib':
                    return ZarrCompressor.GZIP;
                default:
                    throw new Error(`Unsupported compressor: ${_JSON$stringify(id)}`);
            }
        });
        return {
            rank: shape.length,
            shape,
            chunks,
            order,
            dataType: numpyDtype.dataType,
            encoding: { compressor, endianness: numpyDtype.endianness },
            dimensionSeparator
        };
    } catch (e) {
        throw new Error(`Error parsing zarr metadata: ${e.message}`);
    }
}
export class MultiscaleVolumeChunkSource extends GenericMultiscaleVolumeChunkSource {
    constructor(chunkManager, credentialsProvider, url, separator, metadata, attrs) {
        super(chunkManager);
        this.credentialsProvider = credentialsProvider;
        this.url = url;
        this.separator = separator;
        this.metadata = metadata;
        this.attrs = attrs;
        this.dataType = metadata.dataType;
        this.volumeType = VolumeType.IMAGE;
        let names = verifyOptionalObjectProperty(attrs, '_ARRAY_DIMENSIONS', names => parseFixedLengthArray(new Array(metadata.rank), names, verifyString));
        if (names === undefined) {
            names = _Array$from(metadata.shape, (_, i) => `d${i}`);
        }
        this.modelSpace = makeCoordinateSpace({
            names,
            scales: Float64Array.from(metadata.shape, () => 1),
            units: _Array$from(metadata.shape, () => ''),
            boundingBoxes: [makeIdentityTransformedBoundingBox({
                lowerBounds: new Float64Array(metadata.rank),
                upperBounds: Float64Array.from(metadata.shape)
            })]
        });
    }
    get rank() {
        return this.metadata.rank;
    }
    getSources(volumeSourceOptions) {
        const metadata = this.metadata;
        const rank = metadata.rank,
              chunks = metadata.chunks,
              shape = metadata.shape;

        let permutedChunkShape;
        let permutedDataShape;
        let transform;
        if (metadata.order === 'F') {
            permutedChunkShape = Uint32Array.from(chunks);
            permutedDataShape = Float32Array.from(shape);
            transform = createIdentity(Float32Array, rank + 1);
        } else {
            permutedChunkShape = new Uint32Array(rank);
            permutedDataShape = new Float32Array(rank);
            transform = new Float32Array((rank + 1) ** 2);
            transform[(rank + 1) ** 2 - 1] = 1;
            for (let i = 0; i < rank; ++i) {
                permutedChunkShape[i] = chunks[rank - 1 - i];
                permutedDataShape[i] = shape[rank - 1 - i];
                transform[i + (rank - 1 - i) * (rank + 1)] = 1;
            }
        }
        return transposeNestedArrays([makeDefaultVolumeChunkSpecifications({
            rank,
            chunkToMultiscaleTransform: transform,
            dataType: metadata.dataType,
            upperVoxelBound: permutedDataShape,
            volumeType: this.volumeType,
            chunkDataSizes: [permutedChunkShape],
            volumeSourceOptions
        }).map(spec => ({
            chunkSource: this.chunkManager.getChunkSource(ZarrVolumeChunkSource, {
                credentialsProvider: this.credentialsProvider,
                spec,
                parameters: {
                    url: this.url,
                    encoding: metadata.encoding,
                    separator: this.separator
                }
            }),
            chunkToMultiscaleTransform: transform
        }))]);
    }
}
function getAttributes(chunkManager, credentialsProvider, url) {
    return chunkManager.memoize.getUncounted({ type: 'zarr:.zattrs json', url, credentialsProvider: getObjectId(credentialsProvider) }, async () => {
        try {
            const json = await cancellableFetchSpecialOk(credentialsProvider, url + '/.zattrs', {}, responseJson);
            verifyObject(json);
            return json;
        } catch (e) {
            if (isNotFoundError(e)) return {};
            throw e;
        }
    });
}
function getMetadata(chunkManager, credentialsProvider, url) {
    return chunkManager.memoize.getUncounted({ type: 'zarr:.zarray json', url, credentialsProvider: getObjectId(credentialsProvider) }, async () => {
        const json = await cancellableFetchSpecialOk(credentialsProvider, url + '/.zarray', {}, responseJson);
        return parseZarrMetadata(json);
    });
}
const supportedQueryParameters = [{
    key: { value: 'dimension_separator', description: 'Dimension separator in chunk keys' },
    values: [{ value: '.', description: '(default)' }, { value: '/', description: '' }]
}];
export class ZarrDataSource extends DataSourceProvider {
    get description() {
        return 'Zarr data source';
    }
    get(options) {
        // Pattern is infallible.
        var _options$providerUrl$ = options.providerUrl.match(/([^?]*)(?:\?(.*))?$/),
            _options$providerUrl$2 = _slicedToArray(_options$providerUrl$, 3);

        let providerUrl = _options$providerUrl$2[1],
            query = _options$providerUrl$2[2];

        const parameters = parseQueryStringParameters(query || '');
        verifyObject(parameters);
        const dimensionSeparator = parseDimensionSeparator(parameters);
        if (providerUrl.endsWith('/')) {
            providerUrl = providerUrl.substring(0, providerUrl.length - 1);
        }
        return options.chunkManager.memoize.getUncounted({ 'type': 'zarr:MultiscaleVolumeChunkSource', providerUrl, dimensionSeparator }, async () => {
            var _parseSpecialUrl = parseSpecialUrl(providerUrl, options.credentialsManager);

            const url = _parseSpecialUrl.url,
                  credentialsProvider = _parseSpecialUrl.credentialsProvider;

            var _ref = await _Promise.all([getMetadata(options.chunkManager, credentialsProvider, url), getAttributes(options.chunkManager, credentialsProvider, url)]),
                _ref2 = _slicedToArray(_ref, 2);

            const metadata = _ref2[0],
                  attrs = _ref2[1];

            if (metadata.dimensionSeparator !== undefined && dimensionSeparator !== undefined && metadata.dimensionSeparator !== dimensionSeparator) {
                throw new Error(`Explicitly specified dimension separator ` + `${_JSON$stringify(dimensionSeparator)} does not match value ` + `in .zarray ${_JSON$stringify(metadata.dimensionSeparator)}`);
            }
            const volume = new MultiscaleVolumeChunkSource(options.chunkManager, credentialsProvider, url, dimensionSeparator || metadata.dimensionSeparator || '.', metadata, attrs);
            return {
                modelTransform: makeIdentityTransform(volume.modelSpace),
                subsources: [{
                    id: 'default',
                    default: true,
                    url: undefined,
                    subsource: { volume }
                }, {
                    id: 'bounds',
                    default: true,
                    url: undefined,
                    subsource: {
                        staticAnnotations: makeDataBoundsBoundingBoxAnnotationSet(volume.modelSpace.bounds)
                    }
                }]
            };
        });
    }
    async completeUrl(options) {
        // Pattern is infallible.
        var _options$providerUrl$3 = options.providerUrl.match(/([^?]*)(?:\?(.*))?$/),
            _options$providerUrl$4 = _slicedToArray(_options$providerUrl$3, 3);

        let query = _options$providerUrl$4[2];

        if (query !== undefined) {
            return applyCompletionOffset(options.providerUrl.length - query.length, (await completeQueryStringParametersFromTable(query, supportedQueryParameters)));
        }
        return await completeHttpPath(options.credentialsManager, options.providerUrl, options.cancellationToken);
    }
}
//# sourceMappingURL=frontend.js.map