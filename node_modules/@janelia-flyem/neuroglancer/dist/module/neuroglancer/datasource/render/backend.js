import _JSON$stringify from "babel-runtime/core-js/json/stringify";
import _Map from "babel-runtime/core-js/map";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import { decodeJpeg } from "../../async_computation/decode_jpeg_request";
import { requestAsyncComputation } from "../../async_computation/request";
import { WithParameters } from "../../chunk_manager/backend";
import { TileChunkSourceParameters } from "./base";
import { postProcessRawData } from "../../sliceview/backend_chunk_decoders/postprocess";
import { decodeRawChunk } from "../../sliceview/backend_chunk_decoders/raw";
import { VolumeChunkSource } from "../../sliceview/volume/backend";
import { Endianness } from "../../util/endian";
import { vec3 } from "../../util/geom";
import { cancellableFetchOk, responseArrayBuffer } from "../../util/http_request";
import { registerSharedObject } from "../../worker_rpc";
const chunkDecoders = new _Map();
chunkDecoders.set('jpg', async (chunk, cancellationToken, response) => {
    const chunkDataSize = chunk.chunkDataSize;
    const decoded = await requestAsyncComputation(decodeJpeg, cancellationToken, [response], new Uint8Array(response), chunkDataSize[0], chunkDataSize[1] * chunkDataSize[2], 3, true);
    await postProcessRawData(chunk, cancellationToken, decoded);
});
chunkDecoders.set('raw16', (chunk, cancellationToken, response) => {
    return decodeRawChunk(chunk, cancellationToken, response, Endianness.BIG);
});
let TileChunkSource = class TileChunkSource extends WithParameters(VolumeChunkSource, TileChunkSourceParameters) {
    constructor() {
        super(...arguments);
        this.chunkDecoder = chunkDecoders.get(this.parameters.encoding);
        this.queryString = (() => {
            let parameters = this.parameters;

            let query_params = [];
            if (parameters.channel !== undefined) {
                query_params.push('channels=' + parameters.channel);
            }
            if (parameters.minIntensity !== undefined) {
                query_params.push(`minIntensity=${_JSON$stringify(parameters.minIntensity)}`);
            }
            if (parameters.maxIntensity !== undefined) {
                query_params.push(`maxIntensity=${_JSON$stringify(parameters.maxIntensity)}`);
            }
            if (parameters.maxTileSpecsToRender !== undefined) {
                query_params.push(`maxTileSpecsToRender=${_JSON$stringify(parameters.maxTileSpecsToRender)}`);
            }
            if (parameters.filter !== undefined) {
                query_params.push(`filter=${_JSON$stringify(parameters.filter)}`);
            }
            return query_params.join('&');
        })();
    }
    async download(chunk, cancellationToken) {
        let parameters = this.parameters;
        let chunkGridPosition = chunk.chunkGridPosition;
        // Calculate scale.

        let scale = 1.0 / Math.pow(2, parameters.level);
        // Needed by JPEG decoder.
        chunk.chunkDataSize = this.spec.chunkDataSize;
        let xTileSize = chunk.chunkDataSize[0] * Math.pow(2, parameters.level);
        let yTileSize = chunk.chunkDataSize[1] * Math.pow(2, parameters.level);
        // Convert grid position to global coordinates position.
        let chunkPosition = vec3.create();
        chunkPosition[0] = chunkGridPosition[0] * xTileSize;
        chunkPosition[1] = chunkGridPosition[1] * yTileSize;
        chunkPosition[2] = chunkGridPosition[2];
        // GET
        // /v1/owner/{owner}/project/{project}/stack/{stack}/z/{z}/box/{x},{y},{width},{height},{scale}/jpeg-image
        let imageMethod;
        if (parameters.encoding === 'raw16') {
            imageMethod = 'raw16-image';
        } else {
            imageMethod = 'jpeg-image';
        }
        let path = `/render-ws/v1/owner/${parameters.owner}/project/${parameters.project}/stack/${parameters.stack}/z/${chunkPosition[2]}/box/${chunkPosition[0]},${chunkPosition[1]},${xTileSize},${yTileSize},${scale}/${imageMethod}`;
        const response = await cancellableFetchOk(`${parameters.baseUrl}${path}?${this.queryString}`, {}, responseArrayBuffer, cancellationToken);
        await this.chunkDecoder(chunk, cancellationToken, response);
    }
};
TileChunkSource = __decorate([registerSharedObject()], TileChunkSource);
export { TileChunkSource };
//# sourceMappingURL=backend.js.map