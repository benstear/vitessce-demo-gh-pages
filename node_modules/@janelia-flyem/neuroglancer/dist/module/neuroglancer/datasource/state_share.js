import _JSON$stringify from "babel-runtime/core-js/json/stringify";
import _Object$entries from "babel-runtime/core-js/object/entries";
import _slicedToArray from "babel-runtime/helpers/slicedToArray";
import _Object$values from "babel-runtime/core-js/object/values";
import _Object$keys from "babel-runtime/core-js/object/keys";
import { RefCounted } from "../util/disposable";
import { defaultCredentialsManager } from "../credentials_provider/default_manager";
import { StatusMessage } from "../status";
import { responseJson } from "../util/http_request";
import { cancellableFetchSpecialOk, parseSpecialUrl } from "../util/special_protocol_request";
import { makeIcon } from "../widget/icon";
export const stateShareEnabled = typeof STATE_SERVERS !== 'undefined' && _Object$keys(STATE_SERVERS).length > 0;
export class StateShare extends RefCounted {
    constructor(viewer) {
        super();
        this.element = document.createElement('div');
        this.button = makeIcon({ text: 'Share', title: 'Share State' });
        if (typeof STATE_SERVERS === 'undefined') {
            throw new Error("Cannot construct StateSare without defining STATE_SERVERS");
        }
        // if more than one state server, add UI so users can select the state server to use
        if (_Object$keys(STATE_SERVERS).length > 1) {
            const selectEl = document.createElement('select');
            selectEl.style.marginRight = '5px';
            this.registerDisposer(viewer.selectedStateServer.changed.add(() => {
                const valueFromState = viewer.selectedStateServer.value;
                if (_Object$values(STATE_SERVERS).map(s => s.url).includes(valueFromState)) {
                    selectEl.value = valueFromState;
                }
            }));
            this.registerEventListener(selectEl, 'change', () => {
                viewer.selectedStateServer.value = selectEl.value;
            });
            for (let _ref of _Object$entries(STATE_SERVERS)) {
                var _ref2 = _slicedToArray(_ref, 2);

                let name = _ref2[0];
                let stateServer = _ref2[1];

                const option = document.createElement('option');
                option.textContent = name;
                option.value = stateServer.url;
                option.selected = !!stateServer.default;
                selectEl.appendChild(option);
            }
            this.element.appendChild(selectEl);
            this.selectStateServerElement = selectEl;
        }
        this.element.appendChild(this.button);
        this.registerEventListener(this.button, 'click', () => {
            const selectedStateServer = this.selectStateServerElement ? this.selectStateServerElement.value : _Object$values(STATE_SERVERS)[0].url;
            const protocol = new URL(selectedStateServer).protocol;

            var _parseSpecialUrl = parseSpecialUrl(selectedStateServer, defaultCredentialsManager);

            const parsedUrl = _parseSpecialUrl.url,
                  credentialsProvider = _parseSpecialUrl.credentialsProvider;

            StatusMessage.forPromise(cancellableFetchSpecialOk(credentialsProvider, parsedUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: _JSON$stringify(viewer.state.toJSON())
            }, responseJson).then(res => {
                const stateUrl = new URL(res);
                stateUrl.protocol = protocol; // copy protocol in case it contains authentication type
                const link = `${window.location.origin}/#!${stateUrl}`;
                navigator.clipboard.writeText(link).then(() => {
                    StatusMessage.showTemporaryMessage('Share link copied to clipboard');
                });
            }).catch(() => {
                StatusMessage.showTemporaryMessage(`Could not access state server.`, 4000);
            }), {
                initialMessage: `Posting state to ${selectedStateServer}.`,
                delay: true,
                errorPrefix: ''
            });
        });
    }
    disposed() {
        this.element.remove();
        super.disposed();
    }
}
//# sourceMappingURL=state_share.js.map