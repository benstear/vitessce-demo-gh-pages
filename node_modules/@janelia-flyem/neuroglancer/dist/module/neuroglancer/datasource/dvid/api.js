import _Object$assign from 'babel-runtime/core-js/object/assign';
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { fetchWithCredentials } from '../../credentials_provider/http_request';
import { uncancelableToken } from '../../util/cancellation';
import { cancellableFetchOk, responseArrayBuffer, responseJson } from '../../util/http_request';
export const credentialsKey = 'DVID';
export class DVIDInstance {
    constructor(baseUrl, nodeKey) {
        this.baseUrl = baseUrl;
        this.nodeKey = nodeKey;
    }
    getNodeApiUrl(path = '') {
        return `${this.baseUrl}/api/node/${this.nodeKey}${path}`;
    }
    getRepoInfoUrl() {
        return `${this.baseUrl}/api/repos/info`;
    }
    getKeyValueUrl(dataName, key) {
        return `${this.getNodeApiUrl()}/${dataName}/key/${key}`;
    }
    getKeyValueRangeUrl(dataName, startKey, endKey) {
        return `${this.getNodeApiUrl()}/${dataName}/keyrange/${startKey}/${endKey}`;
    }
    getKeyValuesUrl(dataName) {
        return `${this.getNodeApiUrl()}/${dataName}/keyvalues?jsontar=false`;
    }
}
export function appendQueryString(url, name, value) {
    return `${url}${url.includes('?') ? '&' : '?'}${name}=${value}`;
}
export function appendQueryStringForDvid(url, user) {
    let newUrl = appendQueryString(url, 'app', 'Neuroglancer');
    /*
    if (url.includes('?')) {
      url += '&';
    } else {
      url += '?';
    }
    url += 'app=Neuroglancer';
    */
    if (user) {
        newUrl += `&u=${user}`;
    }
    return newUrl;
}
export function responseText(response) {
    return response.text();
}
export function makeRequest(httpCall, cancellationToken = uncancelableToken) {
    const requestInfo = `${httpCall.url}`;
    const init = { method: httpCall.method, body: httpCall.payload };
    if (httpCall.responseType === '') {
        return cancellableFetchOk(requestInfo, init, responseText, cancellationToken);
    } else if (httpCall.responseType === 'arraybuffer') {
        return cancellableFetchOk(requestInfo, init, responseArrayBuffer, cancellationToken);
    }
    {
        return cancellableFetchOk(requestInfo, init, responseJson, cancellationToken);
    }
}
export function makeRequestWithCredentials(credentialsProvider, httpCall, cancellationToken = uncancelableToken) {
    return fetchWithDVIDCredentials(credentialsProvider, httpCall.url, { method: httpCall.method, body: httpCall.payload }, httpCall.responseType === '' ? responseText : httpCall.responseType === 'json' ? responseJson : responseArrayBuffer, cancellationToken);
}
export function fetchWithDVIDCredentials(credentialsProvider, input, init, transformResponse, cancellationToken = uncancelableToken) {
    return fetchWithCredentials(credentialsProvider, input, init, transformResponse, (credentials, init) => {
        const newInit = _Object$assign({}, init);
        if (credentials.token) {
            newInit.headers = _Object$assign(_Object$assign({}, newInit.headers), { Authorization: `Bearer ${credentials}` });
        }
        return newInit;
    }, error => {
        const status = error.status;

        if (status === 403 || status === 401) {
            // Authorization needed.  Retry with refreshed token.
            // return 'refresh';
        }
        if (status === 504) {
            // Gateway timeout can occur if the server takes too long to reply.  Retry.
            return 'retry';
        }
        throw error;
    }, cancellationToken);
}
export function fetchMeshDataFromService(parameters, fragmentId, cancellationToken) {
    const dvidService = parameters.dvidService;

    if (dvidService) {
        const serviceUrl = `${dvidService}/small-mesh?dvid=${parameters.baseUrl}&uuid=${parameters.nodeKey}&body=${fragmentId}&segmentation=${parameters.segmentationName}${parameters.user ? `&u=${parameters.user}` : ''}${parameters.supervoxels ? '&supervoxels=true' : ''}`;
        // console.log('Fetching mesh from ' + serviceUrl);
        return makeRequest({
            method: 'GET',
            url: serviceUrl,
            responseType: 'arraybuffer'
        }, cancellationToken);
    } else {
        throw new Error('No mesh service available');
    }
}
//# sourceMappingURL=api.js.map