import _Object$assign from "babel-runtime/core-js/object/assign";
import _Object$keys from "babel-runtime/core-js/object/keys";
import _Promise from "babel-runtime/core-js/promise";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import { WithParameters } from "../../chunk_manager/backend";
import { MeshSourceParameters, SkeletonSourceParameters, VolumeChunkEncoding, VolumeChunkSourceParameters, AnnotationSourceParameters, AnnotationChunkSourceParameters } from "./base";
import { assignMeshFragmentData, decodeTriangleVertexPositionsAndIndices, MeshSource } from "../../mesh/backend";
import { SkeletonSource } from "../../skeleton/backend";
import { decodeSwcSkeletonChunk } from "../../skeleton/decode_swc_skeleton";
import { decodeCompressedSegmentationChunk } from "../../sliceview/backend_chunk_decoders/compressed_segmentation";
import { decodeJpegChunk } from "../../sliceview/backend_chunk_decoders/jpeg";
import { VolumeChunkSource } from "../../sliceview/volume/backend";
import { Endianness } from "../../util/endian";
import { registerSharedObject } from "../../worker_rpc";
import { WithSharedCredentialsProviderCounterpart } from "../../credentials_provider/shared_counterpart";
import { DVIDInstance, makeRequestWithCredentials, appendQueryStringForDvid, fetchMeshDataFromService, appendQueryString } from "./api";
import { DVIDAnnotationFacade } from "./utils";
import { verifyObject, verifyObjectProperty, verifyString, parseIntVec } from "../../util/json";
import { vec3 } from "../../util/geom";
import { AnnotationSerializer, makeAnnotationPropertySerializers, AnnotationType } from "../../annotation";
import { AnnotationGeometryData, AnnotationSource, AnnotationGeometryChunkSourceBackend } from "../../annotation/backend";
import { Uint64 } from "../../util/uint64";
function DVIDSource(Base, parametersConstructor) {
    return WithParameters(WithSharedCredentialsProviderCounterpart()(Base), parametersConstructor);
}
let DVIDSkeletonSource = class DVIDSkeletonSource extends DVIDSource(SkeletonSource, SkeletonSourceParameters) {
    download(chunk, cancellationToken) {
        const parameters = this.parameters;

        if (parameters.supervoxels) {
            return _Promise.reject();
        }
        let bodyid = `${chunk.objectId}`;
        const url = `${parameters.baseUrl}/api/node/${parameters['nodeKey']}` + `/${parameters['dataInstanceKey']}/key/` + bodyid + '_swc';
        return makeRequestWithCredentials(this.credentialsProvider, {
            method: 'GET',
            url: appendQueryStringForDvid(url, parameters.user),
            responseType: 'arraybuffer'
        }, cancellationToken).then(response => {
            let enc = new TextDecoder('utf-8');
            decodeSwcSkeletonChunk(chunk, enc.decode(response));
        });
    }
};
DVIDSkeletonSource = __decorate([registerSharedObject()], DVIDSkeletonSource);
export { DVIDSkeletonSource };
export function decodeFragmentChunk(chunk, response) {
    let dv = new DataView(response);
    let numVertices = dv.getUint32(0, true);
    assignMeshFragmentData(chunk, decodeTriangleVertexPositionsAndIndices(response, Endianness.LITTLE, /*vertexByteOffset=*/4, numVertices));
}
let DVIDMeshSource = class DVIDMeshSource extends DVIDSource(MeshSource, MeshSourceParameters) {
    download(chunk) {
        // Note: The conditional supervoxels parameter check was removed to allow
        // the small-mesh service to load meshes. Code in the downloadFragment
        // method was altered to force the use of the small mesh service if the
        // supervoxels parameter is true.
        // DVID does not currently store meshes chunked, the main
        // use-case is for low-resolution 3D views.
        // for now, fragmentId is the body id
        chunk.fragmentIds = [`${chunk.objectId}`];
        return _Promise.resolve(undefined);
    }
    downloadFragment(chunk, cancellationToken) {
        const fragmentId = chunk.fragmentId;

        if (fragmentId) {
            const parameters = this.parameters;

            const dvidInstance = new DVIDInstance(parameters.baseUrl, parameters.nodeKey);
            const meshUrl = dvidInstance.getKeyValueUrl(parameters.dataInstanceKey, `${fragmentId}.ngmesh`);
            const forceDvidService = parameters.forceDvidService,
                  supervoxels = parameters.supervoxels;
            // DVID should never load meshes for supervoxels, so if that parameter is
            // true, then we should always use the small mesh service.

            if (forceDvidService || supervoxels) {
                return fetchMeshDataFromService(parameters, fragmentId, cancellationToken).then(response => decodeFragmentChunk(chunk, response)).catch(error => {
                    console.log(error);
                });
            }
            return makeRequestWithCredentials(this.credentialsProvider, {
                method: 'GET',
                url: appendQueryStringForDvid(meshUrl, parameters.user),
                responseType: 'arraybuffer'
            }, cancellationToken).catch(() => fetchMeshDataFromService(parameters, fragmentId, cancellationToken)).then(response => decodeFragmentChunk(chunk, response)).catch(error => {
                console.log(error);
            });
        }
        throw new Error('Invalid mesh fragment ID.');
    }
};
DVIDMeshSource = __decorate([registerSharedObject()], DVIDMeshSource);
export { DVIDMeshSource };
function parseUint64ToArray(out, v) {
    if (v) {
        out.push(Uint64.parseString(v));
    }
    return out;
}
function parsePointAnnotation(entry, kind) {
    let prop = {};
    const propertiesObj = verifyObjectProperty(entry, 'Prop', verifyObject);
    const corner = verifyObjectProperty(entry, 'Pos', x => parseIntVec(vec3.create(), x));
    // let segments: Array<Uint64> = new Array<Uint64>();
    let relatedSegments = [[]];
    prop = propertiesObj;
    if (kind === 'Note') {
        relatedSegments[0] = verifyObjectProperty(propertiesObj, 'body ID', x => parseUint64ToArray(Array(), x));
    }
    let annotation = {
        point: corner,
        type: AnnotationType.POINT,
        properties: [],
        kind,
        id: `${corner[0]}_${corner[1]}_${corner[2]}`,
        relatedSegments,
        prop: {}
    };
    let annotationRef = new DVIDAnnotationFacade(annotation);
    annotationRef.prop = prop;
    annotationRef.update();
    let description = annotationRef.description;
    if (description) {
        annotation.description = description;
    }
    return annotation;
}
export function parseAnnotation(entry) {
    if (entry) {
        const kind = verifyObjectProperty(entry, 'Kind', verifyString);
        if (kind !== 'Unknown') {
            return parsePointAnnotation(entry, kind);
        }
    }
    return null;
}
let DVIDAnnotationGeometryChunkSource = class DVIDAnnotationGeometryChunkSource extends DVIDSource(AnnotationGeometryChunkSourceBackend, AnnotationChunkSourceParameters) {
    // private getElementsPath() {
    //   return `/${this.parameters.dataInstanceKey}/elements`;
    // }
    // Use block API for better performance
    getBlocksPath() {
        return `/${this.parameters.dataInstanceKey}/blocks`;
    }
    getPath(position, size) {
        return `${this.getBlocksPath()}/${size[0]}_${size[1]}_${size[2]}/${position[0]}_${position[1]}_${position[2]}`;
    }
    async download(chunk, cancellationToken) {
        const parameters = this.parameters;

        if (chunk.source.spec.upperChunkBound[0] <= chunk.source.spec.lowerChunkBound[0]) {
            return _Promise.resolve(parseAnnotations(this, chunk, [], parameters.properties, true));
        }
        const chunkDataSize = this.parameters.chunkDataSize;
        const chunkPosition = chunk.chunkGridPosition.map((x, index) => x * chunkDataSize[index]);
        let dataInstance = new DVIDInstance(parameters.baseUrl, parameters.nodeKey);
        return makeRequestWithCredentials(this.credentialsProvider, {
            method: 'GET',
            url: appendQueryStringForDvid(dataInstance.getNodeApiUrl(this.getPath(chunkPosition, chunkDataSize)), parameters.user),
            payload: undefined,
            responseType: 'json'
        }, cancellationToken).then(values => {
            parseAnnotations(this, chunk, values, parameters.properties, false);
        });
    }
};
DVIDAnnotationGeometryChunkSource = __decorate([registerSharedObject() //
], DVIDAnnotationGeometryChunkSource);
export { DVIDAnnotationGeometryChunkSource };
let DVIDAnnotationSource = class DVIDAnnotationSource extends DVIDSource(AnnotationSource, AnnotationSourceParameters) {
    constructor(rpc, options) {
        super(rpc, options);
        // updateAnnotationTypeHandler();
    }
    getElementsPath() {
        return `/${this.parameters.dataInstanceKey}/elements`;
    }
    getPathByBodyId(segmentation, bodyId) {
        return `/${segmentation}/label/${bodyId}`;
    }
    getPathByAnnotationId(annotationId) {
        return `${this.getElementsPath()}/1_1_1/${annotationId}`;
    }
    downloadSegmentFilteredGeometry(chunk, _relationshipIndex, cancellationToken) {
        const parameters = this.parameters;

        if (parameters.syncedLabel) {
            let dataInstance = new DVIDInstance(parameters.baseUrl, parameters.nodeKey);
            return makeRequestWithCredentials(this.credentialsProvider, {
                method: 'GET',
                url: appendQueryStringForDvid(dataInstance.getNodeApiUrl(this.getPathByBodyId(parameters.dataInstanceKey, chunk.objectId)), parameters.user),
                payload: undefined,
                responseType: 'json'
            }, cancellationToken).then(values => {
                parseAnnotations(this, chunk, values, parameters.properties, false);
            });
        } else {
            throw Error('Synced label missing');
        }
    }
    requestPointMetaData(id, cancellationToken) {
        const parameters = this.parameters;

        let dataInstance = new DVIDInstance(parameters.baseUrl, parameters.nodeKey);
        return makeRequestWithCredentials(this.credentialsProvider, {
            method: 'GET',
            url: appendQueryStringForDvid(dataInstance.getNodeApiUrl(this.getPathByAnnotationId(id)), parameters.user),
            responseType: 'json'
        }, cancellationToken).then(response => {
            if (response && response.length > 0) {
                return response[0];
            } else {
                return response;
            }
        });
    }
    requestMetadata(chunk, cancellationToken) {
        const id = chunk.key;
        return this.requestPointMetaData(id, cancellationToken);
    }
    downloadMetadata(chunk, cancellationToken) {
        return this.requestMetadata(chunk, cancellationToken).then(response => {
            if (response) {
                chunk.annotation = parseAnnotation(response);
            } else {
                chunk.annotation = null;
            }
        });
    }
};
DVIDAnnotationSource = __decorate([registerSharedObject()], DVIDAnnotationSource);
export { DVIDAnnotationSource };
function parseAnnotations(source, chunk, responses, propSpec, emittingAddSignal) {
    const annotationPropertySerializers = makeAnnotationPropertySerializers(3, propSpec);
    const serializer = new AnnotationSerializer(annotationPropertySerializers);
    if (responses) {
        let itemList = [];
        if (!Array.isArray(responses)) {
            itemList = _Object$keys(responses).reduce((acc, key) => [...acc, ...responses[key]], []);
        } else {
            itemList = responses;
        }
        itemList.forEach(response => {
            if (response) {
                try {
                    let annotation = parseAnnotation(response);
                    if (annotation) {
                        serializer.add(annotation);
                        if (emittingAddSignal) {
                            console.log('To be implemented: ', source, emittingAddSignal);
                        }
                    }
                } catch (e) {
                    throw new Error(`Error parsing annotation: ${e.message}`);
                }
            }
        });
    }
    chunk.data = _Object$assign(new AnnotationGeometryData(), serializer.serialize());
}
let DVIDVolumeChunkSource = class DVIDVolumeChunkSource extends DVIDSource(VolumeChunkSource, VolumeChunkSourceParameters) {
    async download(chunk, cancellationToken) {
        let params = this.parameters;
        let path;
        {
            // chunkPosition must not be captured, since it will be invalidated by the next call to
            // computeChunkBounds.
            let chunkPosition = this.computeChunkBounds(chunk);
            let chunkDataSize = chunk.chunkDataSize;
            // if the volume is an image, get a jpeg
            path = this.getPath(chunkPosition, chunkDataSize);
            if (params.supervoxels) {
                path = appendQueryString(path, 'supervoxels', 'true');
            }
        }
        const decoder = this.getDecoder(params);
        const response = await makeRequestWithCredentials(this.credentialsProvider, {
            method: 'GET',
            url: appendQueryStringForDvid(`${params.baseUrl}${path}`, params.user),
            responseType: 'arraybuffer'
        }, cancellationToken);
        await decoder(chunk, cancellationToken, params.encoding === VolumeChunkEncoding.JPEG ? response.slice(16) : response);
    }
    getPath(chunkPosition, chunkDataSize) {
        let params = this.parameters;
        if (params.encoding === VolumeChunkEncoding.JPEG) {
            return `/api/node/${params['nodeKey']}/${params['dataInstanceKey']}/subvolblocks/` + `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` + `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}`;
        } else if (params.encoding === VolumeChunkEncoding.RAW) {
            return `/api/node/${params['nodeKey']}/${params['dataInstanceKey']}/raw/0_1_2/` + `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` + `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}/jpeg`;
        } else if (params.encoding === VolumeChunkEncoding.COMPRESSED_SEGMENTATIONARRAY) {
            return `/api/node/${params['nodeKey']}/${params['dataInstanceKey']}/raw/0_1_2/` + `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` + `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}?compression=googlegzip&scale=${params['dataScale']}`;
        } else {
            // encoding is COMPRESSED_SEGMENTATION
            return `/api/node/${params['nodeKey']}/${params['dataInstanceKey']}/raw/0_1_2/` + `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` + `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}?compression=googlegzip`;
        }
    }
    getDecoder(params) {
        if (params.encoding === VolumeChunkEncoding.JPEG || params.encoding === VolumeChunkEncoding.RAW) {
            return decodeJpegChunk;
        } else {
            // encoding is COMPRESSED_SEGMENTATION
            return decodeCompressedSegmentationChunk;
        }
    }
};
DVIDVolumeChunkSource = __decorate([registerSharedObject()], DVIDVolumeChunkSource);
export { DVIDVolumeChunkSource };
//# sourceMappingURL=backend.js.map