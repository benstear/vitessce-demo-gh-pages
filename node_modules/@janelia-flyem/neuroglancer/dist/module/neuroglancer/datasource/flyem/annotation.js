import _Object$assign from 'babel-runtime/core-js/object/assign';
import { registerRPC } from '../../worker_rpc';
import { AnnotationType, fixAnnotationAfterStructuredCloning } from '../../annotation';
export const ANNOTAIION_COMMIT_ADD_SIGNAL_RPC_ID = 'annotation.add.signal';
registerRPC(ANNOTAIION_COMMIT_ADD_SIGNAL_RPC_ID, function (x) {
    const source = this.get(x.id);
    const newAnnotation = fixAnnotationAfterStructuredCloning(x.newAnnotation);
    if (newAnnotation) {
        source.parent.updateReference(newAnnotation);
        source.parent.childAdded.dispatch(newAnnotation);
    }
});
export function WithFlyEMProp(Base) {
    class C extends Base {
        constructor(...args) {
            super(...args);
        }
    }
    return C;
}
class TAnnotationBase {}
class TPoint extends TAnnotationBase {}
class TLine extends TAnnotationBase {}
class TSphere extends TAnnotationBase {}
export class PointAnnotation extends WithFlyEMProp(TPoint) {}
export class LineAnnotation extends WithFlyEMProp(TLine) {}
export class SphereAnnotation extends WithFlyEMProp(TSphere) {}
export class AnnotationFacade {
    constructor(annotation) {
        this.annotation = annotation;
    }
    get renderingAttribute() {
        if (this.kind === 'Atlas') {
            if (!this.title) {
                return -1;
            } else if (this.checked) {
                return 1;
            }
        } else {
            if (this.bookmarkType === 'False Split') {
                return 2;
            } else if (this.bookmarkType === 'False Merge') {
                return 3;
            }
        }
        return 0;
    }
    get confidence() {
        return 0;
    }
    updateProperties() {
        this.annotation.properties = [this.renderingAttribute, this.confidence];
    }
    get ext() {
        if (this.annotation.ext === undefined) {
            this.annotation.ext = {};
        }
        return this.annotation.ext;
    }
    get prop() {
        return this.annotation.prop;
    }
    set prop(value) {
        this.annotation.prop = value;
    }
    get bookmarkType() {
        if (this.prop) {
            switch (this.prop.type) {
                case 'Split':
                    return 'False Merge';
                case 'Merge':
                    return 'False Split';
                default:
                    break;
            }
        }
        return 'Other';
    }
    get type() {
        return this.annotation.type;
    }
    get kind() {
        return this.annotation.kind;
    }
    set kind(value) {
        this.annotation.kind = value;
        this.update();
    }
    roundPos() {
        if (this.annotation.type === AnnotationType.POINT) {
            this.annotation.point = this.annotation.point.map(x => Math.round(x));
        } else if (this.annotation.type === AnnotationType.LINE || this.annotation.type === AnnotationType.SPHERE) {
            this.annotation.pointA = this.annotation.pointA.map(x => Math.round(x));
            this.annotation.pointB = this.annotation.pointB.map(x => Math.round(x));
        }
    }
    setProp(prop) {
        this.prop = _Object$assign(_Object$assign({}, this.prop), prop);
    }
    get user() {
        return this.prop && this.prop.user;
    }
    set user(value) {
        this.setProp({ user: value });
    }
    get comment() {
        return this.prop && this.prop.comment;
    }
    get description() {
        return this.comment;
    }
    updatePresentation() {
        if (this.title) {
            this.annotation.description = this.title + ": ";
        } else {
            this.annotation.description = '';
        }
        if (this.description) {
            this.annotation.description += this.description;
        }
    }
    update() {
        this.updatePresentation();
        this.updateProperties();
    }
    set comment(s) {
        this.setProp({ comment: s });
        this.updatePresentation();
    }
    updateComment() {
        this.comment = this.annotation.description || '';
        this.annotation.description = undefined;
    }
    get title() {
        return this.prop && this.prop.title;
    }
    set title(s) {
        this.setProp({ title: s });
        this.updatePresentation();
    }
    get timestamp() {
        return this.prop && this.prop.timestamp ? Number(this.prop.timestamp) : 0;
    }
    addTimeStamp() {
        this.setProp({ timestamp: String(Date.now()) });
    }
    get checked() {
        return this.ext && this.ext.verified || this.prop && this.prop.checked || false;
    }
    set checked(c) {
        this.setProp({ checked: c });
    }
    get presentation() {
        this.updatePresentation();
        return this.annotation.description || '';
    }
    set presentation(value) {
        this.annotation.description = value;
    }
}
export function typeOfAnnotationId(id) {
    if (id.match(/^-?\d+_-?\d+_-?\d+[\[]?/) || id.match(/^Pt-?\d+_-?\d+_-?\d+/)) {
        return AnnotationType.POINT;
    } else if (id.match(/^-?\d+_-?\d+_-?\d+--?\d+_-?\d+_-?\d+-Line$/) || id.match(/^Ln-?\d+_-?\d+_-?\d+_?\d+_-?\d+_-?\d+/)) {
        return AnnotationType.LINE;
    } else if (id.match(/^-?\d+_-?\d+_-?\d+--?\d+_-?\d+_-?\d+-Sphere$/) || id.match(/^Sp-?\d+_-?\d+_-?\d+_?\d+_-?\d+_-?\d+/)) {
        return AnnotationType.SPHERE;
    }
    {
        console.log(`Invalid annotation ID for DVID: ${id}`);
        return null;
    }
}
function getAnnotationUser(annotation) {
    return annotation.ext && annotation.ext.user || annotation.prop && annotation.prop.user;
}
export function getAnnotationKey(annotation, keyHandle) {
    let key = keyHandle || annotation.key;
    if (!key) {
        switch (annotation.type) {
            case AnnotationType.POINT:
                key = `Pt${annotation.point[0]}_${annotation.point[1]}_${annotation.point[2]}`;
                break;
            case AnnotationType.LINE:
                key = `Ln${annotation.pointA[0]}_${annotation.pointA[1]}_${annotation.pointA[2]}_${annotation.pointB[0]}_${annotation.pointB[1]}_${annotation.pointB[2]}`;
                break;
            case AnnotationType.SPHERE:
                key = `Sp${annotation.pointA[0]}_${annotation.pointA[1]}_${annotation.pointA[2]}_${annotation.pointB[0]}_${annotation.pointB[1]}_${annotation.pointB[2]}`;
                break;
        }
    }
    return key;
}
export function getAnnotationId(annotation, keyHandle) {
    return `${getAnnotationKey(annotation, keyHandle)}[user:${getAnnotationUser(annotation)}]`;
}
export function parseAnnotationId(id) {
    const matched = id.match(/(.*)\[user:(.*)\]/);
    return matched && { key: matched[1], user: matched[2] };
}
export function isAnnotationIdValid(id) {
    return typeOfAnnotationId(id) !== null;
}
// Adapted from https://stackoverflow.com/questions/38552003/how-to-decode-jwt-token-in-javascript-without-using-a-library
function parseToken(token) {
    const base64Url = token.split('.')[1];
    if (base64Url) {
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        const jsonPayload = decodeURIComponent(window.atob(base64).split('').map(function (c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
        return JSON.parse(jsonPayload);
    }
}
export function getUserFromToken(token, defaultUser) {
    let tokenUser = undefined;
    const obj = parseToken(token);
    if (obj) {
        if ('user' in obj) {
            tokenUser = obj['user'];
        } else if ('email' in obj) {
            tokenUser = obj['email'];
        }
    }
    if (tokenUser) {
        if (defaultUser && defaultUser !== tokenUser) {
            return undefined;
        }
    } else {
        tokenUser = defaultUser;
    }
    return tokenUser;
}
export const defaultJsonSchema = {
    "definitions": {},
    "type": "object",
    "required": ["Prop"],
    "properties": {
        "Prop": {
            "$id": "#/properties/Prop",
            "type": "object",
            "title": "Properties",
            "required": ["comment"],
            "properties": {
                "comment": {
                    "$id": "#/properties/Prop/properties/comment",
                    "type": "string",
                    "title": "Comment",
                    "default": ""
                }
            }
        }
    }
};
//# sourceMappingURL=annotation.js.map