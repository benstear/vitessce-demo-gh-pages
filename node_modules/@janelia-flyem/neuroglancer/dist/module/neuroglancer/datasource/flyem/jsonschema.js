import _Symbol$iterator from 'babel-runtime/core-js/symbol/iterator';
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
;
export function isJsonArray(obj) {
    return Array.isArray(obj);
}
export function isJsonObject(obj) {
    if (isJsonArray(obj) || obj === null) {
        return false;
    } else {
        return typeof obj === 'object';
    }
}
export class PropertyTreeNode {
    constructor(name) {
        this.name = name;
        this.childNodeList = new Array();
        this.parentNode = null;
    }
    isRoot() {
        return this.parentNode === null;
    }
    isLeaf() {
        return this.childNodeList.length === 0;
    }
    *[_Symbol$iterator]() {
        function* helper(node) {
            yield node;
            for (let child of node.childNodeList) {
                yield* helper(child);
            }
        }
        yield* helper(this);
    }
    *leafNodes() {
        for (let node of this) {
            if (node.childNodeList.length === 0) {
                yield node;
            }
        }
    }
    get fullName() {
        let finalName = this.name;
        let pn = this.parentNode;
        while (pn) {
            finalName = pn.name + "/" + finalName;
            pn = pn.parentNode;
        }
        return finalName;
    }
    get nameArray() {
        let keyArray = new Array();
        if (!this.isRoot()) {
            keyArray.push(this.name);
            let pn = this.parentNode;
            while (pn && !pn.isRoot()) {
                // console.log(pn);
                keyArray.push(pn.name);
                pn = pn.parentNode;
            }
        }
        return keyArray;
    }
    getPropertyValue(obj) {
        if (!this.isRoot() && obj) {
            let keyArray = this.nameArray;
            // console.log('input object:', obj);
            let subobj = obj;
            for (let i = keyArray.length - 1; i >= 0; --i) {
                if (isJsonObject(subobj)) {
                    let key = keyArray[i];
                    subobj = subobj[key];
                } else {
                    return subobj;
                }
            }
            return subobj;
        }
    }
}
export function buildJsonSchemaTree(schema, currentNode) {
    // console.log(schema);
    if (schema.type == 'object') {
        if (currentNode.properties == undefined) {
            currentNode.properties = {};
        }
        currentNode.properties['title'] = schema['title'];
        let required = schema.required;
        if (isJsonArray(required)) {
            required.forEach(prop => {
                let node = new PropertyTreeNode(prop);
                node.parentNode = currentNode;
                currentNode.childNodeList.push(node);
                let properties = schema['properties'];
                let property = properties[prop];
                buildJsonSchemaTree(property, node);
            });
        }
    } else {
        currentNode.properties = schema;
    }
}
export function getJsonSchemaProperties(schema, rootName) {
    let root = new PropertyTreeNode(rootName);
    buildJsonSchemaTree(schema, root);
    return root;
}
//# sourceMappingURL=jsonschema.js.map