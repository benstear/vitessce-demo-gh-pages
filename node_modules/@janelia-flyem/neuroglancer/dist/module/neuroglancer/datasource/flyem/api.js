import _Promise from 'babel-runtime/core-js/promise';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import { CANCELED, CancellationTokenSource, uncancelableToken } from '../../util/cancellation';
import { responseJson, cancellableFetchOk, responseArrayBuffer } from '../../util/http_request';
import { fetchWithCredentials } from '../../credentials_provider/http_request';
import { CredentialsProvider, /*makeUncachedCredentialsGetter as */makeCredentialsGetter } from '../../credentials_provider';
import { StatusMessage } from '../../status';
export function responseText(response) {
    return response.text();
}
export function makeRequest(httpCall, cancellationToken = uncancelableToken) {
    let requestInfo = `${httpCall.url}`;
    let init = { method: httpCall.method, body: httpCall.payload };
    if (httpCall.responseType === '') {
        return cancellableFetchOk(requestInfo, init, responseText, cancellationToken);
    } else if (httpCall.responseType === 'arraybuffer') {
        return cancellableFetchOk(requestInfo, init, responseArrayBuffer, cancellationToken);
    }
    {
        return cancellableFetchOk(requestInfo, init, responseJson, cancellationToken);
    }
}
export function makeRequestWithCredentials(credentialsProvider, tokenRefreshable, httpCall, cancellationToken = uncancelableToken) {
    const requestInit = { method: httpCall.method, body: httpCall.payload };
    if (requestInit.method === 'POST') {
        //Only supports posting json
        requestInit.headers = {
            'Content-Type': 'application/json'
        };
    }
    return fetchWithFlyEMCredentials(credentialsProvider, tokenRefreshable, httpCall.url, requestInit, httpCall.responseType === '' ? responseText : httpCall.responseType === 'json' ? responseJson : responseArrayBuffer, cancellationToken);
}
function applyCredentials(input) {
    return (credentials, init) => {
        let newInit = _Object$assign({}, init);
        if (credentials) {
            newInit.headers = _Object$assign(_Object$assign({}, newInit.headers), { Authorization: `Bearer ${credentials}` });
        } else if (input.startsWith('https:')) {
            // DVID https without credentials provided expects credentials stored in the browser
            newInit.credentials = 'include';
        }
        return newInit;
    };
}
function fetchWithFlyEMCredentials(credentialsProvider, tokenRefreshable, input, init, transformResponse, cancellationToken = uncancelableToken) {
    return fetchWithCredentials(credentialsProvider, input, init, transformResponse, applyCredentials(input), error => {
        const status = error.status;

        if (status === 403 || status === 401) {
            // Authorization needed.  Retry with refreshed token.
            if (tokenRefreshable) {
                return 'refresh';
            }
        }
        if (status === 504) {
            // Gateway timeout can occur if the server takes too long to reply.  Retry.
            return 'retry';
        }
        throw error;
    }, cancellationToken);
}
const DEBUG_NEUROHUB_CREDENTIALS = false;
const mockWindow = {
    neurohub: {
        clio: {
            auth: {
                getAuthResponse: () => {
                    return { id_token: "<test-token>" };
                }
            }
        }
    }
};
function getNeurohubToken(w) {
    if ('neurohub' in w) {
        return _Promise.resolve(w.neurohub.clio.auth.getAuthResponse().id_token);
    } else {
        return _Promise.resolve('');
    }
}
export class FlyEMCredentialsProvider extends CredentialsProvider {
    constructor(authServer, retry) {
        super();
        this.authServer = authServer;
        this.retry = retry;
        this.get = makeCredentialsGetter(cancellationToken => {
            const status = new StatusMessage( /*delay=*/true);
            let cancellationSource;
            return new _Promise((resolve, reject) => {
                const dispose = () => {
                    cancellationSource = undefined;
                    status.dispose();
                };
                cancellationToken.add(() => {
                    if (cancellationSource !== undefined) {
                        cancellationSource.cancel();
                        cancellationSource = undefined;
                        status.dispose();
                        reject(CANCELED);
                    }
                });
                const writeLoginStatus = (msg = 'Authorization required.', linkMessage = 'Request authorization.') => {
                    status.setText(msg + ' ');
                    if (this.retry) {
                        let button = document.createElement('button');
                        button.textContent = linkMessage;
                        status.element.appendChild(button);
                        button.addEventListener('click', this.retry);
                    }
                    status.setVisible(true);
                };
                let authServer = this.authServer;
                const login = () => {
                    if (cancellationSource !== undefined) {
                        cancellationSource.cancel();
                    }
                    cancellationSource = new CancellationTokenSource();
                    writeLoginStatus('Waiting for authorization...', 'Retry');
                    this.getAuthToken(authServer, cancellationSource).then(token => {
                        if (cancellationSource !== undefined) {
                            dispose();
                            resolve(token);
                        }
                    }, reason => {
                        if (cancellationSource !== undefined) {
                            cancellationSource = undefined;
                            writeLoginStatus(`Authorization failed: ${reason}.`, 'Retry');
                        }
                    });
                };
                login();
            });
        });
    }
    getAuthToken(authServer, cancellationToken = uncancelableToken) {
        // console.log('getAuthToken:', authServer);
        if (!authServer) {
            // throw Error('token failure test');
            return _Promise.resolve('');
        } else if (authServer.startsWith('token:')) {
            return _Promise.resolve(authServer.substring(6));
        } else if (authServer == 'neurohub') {
            return getNeurohubToken(DEBUG_NEUROHUB_CREDENTIALS ? mockWindow : window);
        } else {
            const headers = new Headers();
            // headers.set('Access-Control-Allow-Origin', '*');
            return cancellableFetchOk(authServer, { 'method': 'GET', headers }, responseText, cancellationToken).catch(() => {
                return cancellableFetchOk(authServer, { 'method': 'GET' }, responseText, cancellationToken) /*.then(
                                                                                                            response => 'noinclude:' + response
                                                                                                            )*/;
            });
        }
    }
}
//# sourceMappingURL=api.js.map