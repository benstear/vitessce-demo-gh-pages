import _Object$assign from 'babel-runtime/core-js/object/assign';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Promise from 'babel-runtime/core-js/promise';
import _Set from 'babel-runtime/core-js/set';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import debounce from 'lodash/debounce';
import { CredentialsProvider, makeCredentialsGetter } from '../../credentials_provider';
import { fetchWithCredentials } from '../../credentials_provider/http_request';
import { DataSourceProvider } from './..';
import { NggraphCredentialsProvider } from './credentials_provider';
import { isBaseSegmentId, SegmentationGraphSource, SegmentationGraphSourceConnection, UNKNOWN_NEW_SEGMENT_ID, VisibleSegmentEquivalencePolicy } from '../../segmentation_graph/source';
import { StatusMessage } from '../../status';
import { uncancelableToken } from '../../util/cancellation';
import { getPrefixMatchesWithDescriptions } from '../../util/completion';
import { DisjointUint64Sets } from '../../util/disjoint_sets';
import { responseJson } from '../../util/http_request';
import { parseArray, verifyFiniteFloat, verifyInt, verifyObject, verifyObjectProperty, verifyString, verifyStringArray } from '../../util/json';
import { Uint64 } from '../../util/uint64';
const urlPattern = '^(https?://[^/]+)/(.*)$';
function parseGraphSegmentInfo(obj) {
    verifyObject(obj);
    return {
        id: verifyObjectProperty(obj, 'id', x => Uint64.parseString(verifyString(x))),
        baseSegments: verifyObjectProperty(obj, 'base_segment_ids', x => parseArray(x, y => Uint64.parseString(verifyString(y)))),
        baseSegmentParents: verifyObjectProperty(obj, 'base_segment_parent_ids', x => parseArray(x, y => Uint64.parseString(verifyString(y)))),
        name: verifyObjectProperty(obj, 'name', verifyString),
        tags: verifyObjectProperty(obj, 'tags', verifyStringArray),
        numVoxels: verifyObjectProperty(obj, 'num_voxels', verifyInt),
        bounds: verifyObjectProperty(obj, 'bounds', x => parseArray(x, y => verifyFiniteFloat(y))),
        lastLogId: verifyObjectProperty(obj, 'last_log_id', x => x == null ? null : Uint64.parseString(verifyString(x)))
    };
}
// Generation used for checking if segments have been seen.
let updateGeneration = 0;
class GraphConnection extends SegmentationGraphSourceConnection {
    constructor(graph, segmentsState) {
        super(graph, segmentsState);
        this.debouncedVisibleSegmentsChanged = this.registerCancellable(debounce(() => this.visibleSegmentsChanged(), 0));
        this.segmentQueries = new _Map();
        this.ignoreVisibleSegmentsChanged = false;
        this.segmentEquivalencesChanged = this.registerCancellable(debounce(() => {
            this.debouncedVisibleSegmentsChanged.flush();
            this.segmentEquivalencesChanged.cancel();
            const segmentQueries = this.segmentQueries;
            const segmentEquivalences = this.segmentsState.segmentEquivalences;

            segmentEquivalences.clear();
            for (const _ref of segmentQueries) {
                var _ref2 = _slicedToArray(_ref, 2);

                const segmentIdString = _ref2[0];
                const query = _ref2[1];

                segmentIdString;
                if (query.current === undefined || isBaseSegmentId(query.id)) continue;
                var _query$current = query.current;
                const id = _query$current.id,
                      baseSegments = _query$current.baseSegments;

                if (baseSegments.length > 0) {
                    for (const segmentId of baseSegments) {
                        segmentEquivalences.link(segmentId, id);
                    }
                    query.addedEquivalences = true;
                } else {
                    query.addedEquivalences = false;
                }
            }
        }, 0));
        const visibleSegmentsChanged = () => {
            if (!this.ignoreVisibleSegmentsChanged) {
                this.debouncedVisibleSegmentsChanged();
            }
        };
        this.registerDisposer(segmentsState.visibleSegments.changed.add(visibleSegmentsChanged));
        this.registerDisposer(segmentsState.temporaryVisibleSegments.changed.add(visibleSegmentsChanged));
        this.visibleSegmentsChanged();
    }
    computeSplit(include, exclude) {
        const segmentEquivalences = this.segmentsState.segmentEquivalences;

        const graphSegment = segmentEquivalences.get(include);
        if (isBaseSegmentId(graphSegment)) return undefined;
        if (!Uint64.equal(segmentEquivalences.get(exclude), graphSegment)) return undefined;
        const query = this.segmentQueries.get(graphSegment.toString());
        if (query === undefined) return undefined;
        const current = query.current;

        if (current === undefined) return undefined;
        const baseSegments = current.baseSegments,
              baseSegmentParents = current.baseSegmentParents;

        let length = baseSegmentParents.length;
        const ds = new DisjointUint64Sets();
        for (let i = 0; i < length; ++i) {
            let baseSegment = baseSegments[i];
            let parent = baseSegmentParents[i];
            if (Uint64.equal(baseSegment, exclude) || Uint64.equal(parent, exclude)) continue;
            ds.link(baseSegment, parent);
            console.log(`Linking ${baseSegment} - ${parent} == ${include}? ${Uint64.equal(include, baseSegment)} ${Uint64.equal(include, parent)} :: unioned with include = ${Uint64.equal(include, ds.get(baseSegment))}, with exclude = ${Uint64.equal(exclude, ds.get(baseSegment))}`);
        }
        const includeSegments = [];
        const excludeSegments = [];
        const includeRep = ds.get(include);
        for (const segment of baseSegments) {
            if (Uint64.equal(ds.get(segment), includeRep)) {
                includeSegments.push(segment);
            } else {
                excludeSegments.push(segment);
            }
        }
        console.log('include = ' + includeSegments.map(x => x.toString()).join(','));
        console.log('exclude = ' + excludeSegments.map(x => x.toString()).join(','));
        return {
            includeRepresentative: graphSegment,
            includeBaseSegments: includeSegments,
            excludeRepresentative: UNKNOWN_NEW_SEGMENT_ID,
            excludeBaseSegments: excludeSegments
        };
    }
    registerVisibleSegment(segmentId) {
        const query = {
            id: segmentId,
            current: undefined,
            addedEquivalences: false,
            seenGeneration: updateGeneration,
            disposer: this.graph.watchSegment(segmentId, info => this.handleSegmentUpdate(query.id.toString(), info))
        };
        const segmentIdString = segmentId.toString();
        this.segmentQueries.set(segmentIdString, query);
        console.log(`adding to segmentQueries: ${segmentIdString}`);
    }
    handleSegmentUpdate(segmentIdString, update) {
        console.log(`handleSegmentUpdate: ${segmentIdString}`);
        const query = this.segmentQueries.get(segmentIdString);
        if (update === 'invalid') {
            query.disposer();
            console.log(`removing from segmentQueries: ${segmentIdString} due to invalid`);
            this.segmentQueries.delete(segmentIdString);
            try {
                this.ignoreVisibleSegmentsChanged = true;
                this.segmentsState.visibleSegments.delete(query.id);
                this.segmentsState.temporaryVisibleSegments.delete(query.id);
            } finally {
                this.ignoreVisibleSegmentsChanged = false;
            }
            if (query.addedEquivalences) {
                this.segmentEquivalencesChanged();
            }
            return;
        }
        if (update === 'error') {
            query.current = undefined;
            if (query.addedEquivalences) {
                this.segmentEquivalencesChanged();
            }
            console.log(`Error from ${this.graph.serverUrl}/${this.graph.entityName}` + ` watching segment ${segmentIdString}`);
            return;
        }
        query.current = update;
        const oldId = query.id;
        const newId = update.id;
        if (!Uint64.equal(newId, oldId)) {
            query.id = newId;
            let newSegmentIdString = newId.toString();
            let newQuery = this.segmentQueries.get(newSegmentIdString);
            console.log(`removing from segmentQueries: ${segmentIdString} due to rename -> ${newId}`);
            this.segmentQueries.delete(segmentIdString);
            try {
                this.ignoreVisibleSegmentsChanged = true;
                if (this.segmentsState.visibleSegments.has(oldId)) {
                    this.segmentsState.visibleSegments.delete(oldId);
                    this.segmentsState.visibleSegments.add(newId);
                }
                if (this.segmentsState.temporaryVisibleSegments.has(oldId)) {
                    this.segmentsState.temporaryVisibleSegments.delete(oldId);
                    this.segmentsState.temporaryVisibleSegments.add(newId);
                }
            } finally {
                this.ignoreVisibleSegmentsChanged = false;
            }
            if (newQuery === undefined) {
                console.log(`adding to segmentQueries due to rename -> ${newId}`);
                this.segmentQueries.set(newSegmentIdString, query);
                this.segmentEquivalencesChanged();
            } else {
                if (update.lastLogId !== null && (typeof newQuery.current !== 'object' || newQuery.current.lastLogId === null || Uint64.less(newQuery.current.lastLogId, update.lastLogId))) {
                    newQuery.current = update;
                    this.segmentEquivalencesChanged();
                }
                query.disposer();
            }
        } else {
            query.current = update;
            if (!isBaseSegmentId(query.id)) {
                this.segmentEquivalencesChanged();
            }
        }
    }
    visibleSegmentsChanged() {
        const segmentsState = this.segmentsState;
        const segmentQueries = this.segmentQueries;

        const generation = ++updateGeneration;
        const processVisibleSegments = visibleSegments => {
            for (const segmentId of visibleSegments.unsafeKeys()) {
                if (Uint64.equal(segmentId, UNKNOWN_NEW_SEGMENT_ID)) continue;
                const segmentIdString = segmentId.toString();
                const existingQuery = segmentQueries.get(segmentIdString);
                if (existingQuery !== undefined) {
                    existingQuery.seenGeneration = generation;
                    continue;
                }
                this.registerVisibleSegment(segmentId.clone());
            }
        };
        processVisibleSegments(segmentsState.visibleSegments);
        processVisibleSegments(segmentsState.temporaryVisibleSegments);
        for (const _ref3 of segmentQueries) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const segmentIdString = _ref4[0];
            const query = _ref4[1];

            if (query.seenGeneration !== generation) {
                console.log(`removing from segmentQueries due to seenGeneration: ${segmentIdString}`);
                segmentQueries.delete(segmentIdString);
                query.disposer();
                if (query.addedEquivalences) {
                    this.segmentEquivalencesChanged();
                }
            }
        }
    }
}
export class NggraphSegmentationGraphSource extends SegmentationGraphSource {
    constructor(chunkManager, serverUrl, entityName) {
        super();
        this.chunkManager = chunkManager;
        this.serverUrl = serverUrl;
        this.entityName = entityName;
        this.startingWebsocket = false;
        this.websocket = undefined;
        this.watchesById = new _Map();
        this.watches = new _Set();
        this.nextWatchId = 0;
        this.numOpenFailures = 0;
    }
    get visibleSegmentEquivalencePolicy() {
        return VisibleSegmentEquivalencePolicy.MAX_REPRESENTATIVE | VisibleSegmentEquivalencePolicy.REPRESENTATIVE_EXCLUDED;
    }
    startWebsocket() {
        if (this.startingWebsocket) return;
        if (this.watches.size === 0) return;
        this.startingWebsocket = true;
        let status = new StatusMessage(this.numOpenFailures ? false : true);
        status.setText(`Opening websocket connection for nggraph://${this.serverUrl}/${this.entityName}`);
        (async () => {
            const numOpenFailures = this.numOpenFailures;

            if (numOpenFailures > 1) {
                const delay = 1000 * Math.min(16, 2 ** numOpenFailures);
                await new _Promise(resolve => setTimeout(resolve, delay));
            }
            const credentials = (await getEntityCredentialsProvider(this.chunkManager, this.serverUrl, this.entityName).get()).credentials;
            let url = new URL('/graph/watch/' + encodeURIComponent(credentials.token), this.serverUrl);
            url.protocol = url.protocol.replace('http', 'ws');
            const websocket = new WebSocket(url.href);
            websocket.onclose = () => {
                if (status !== undefined) {
                    status.dispose();
                    status = undefined;
                }
                ++this.numOpenFailures;
                this.websocket = undefined;
                this.startingWebsocket = false;
                this.watchesById.clear();
                this.startWebsocket();
            };
            websocket.onopen = () => {
                if (status !== undefined) {
                    status.dispose();
                    status = undefined;
                }
                this.numOpenFailures = 0;
                this.websocket = websocket;
                this.nextWatchId = 0;
                try {
                    for (const watchInfo of this.watches) {
                        websocket.send(_JSON$stringify({ 'watch': { 'segment_id': watchInfo.segment.toString() } }));
                        let watchId = this.nextWatchId++;
                        watchInfo.watchId = watchId;
                        this.watchesById.set(watchId, watchInfo);
                    }
                } catch (_a) {
                    // Ignore send error, which indicates the connection has been closed.  The close handler
                    // already deals with this case.
                }
            };
            websocket.onmessage = ev => {
                let update;
                let watchInfo;
                try {
                    const msg = JSON.parse(ev.data);
                    verifyObject(msg);
                    const watchId = verifyObjectProperty(msg, 'watch_id', verifyInt);
                    const w = this.watchesById.get(watchId);
                    if (w === undefined) {
                        // Watch has already been cancelled.
                        return;
                    }
                    watchInfo = w;
                    const state = verifyObjectProperty(msg, 'state', verifyString);
                    if (state === 'invalid' || state === 'error') {
                        update = state;
                    } else {
                        update = verifyObjectProperty(msg, 'info', parseGraphSegmentInfo);
                    }
                } catch (e) {
                    console.log(`Received unexpected websocket message from ${this.serverUrl}:`, ev.data, e);
                    return;
                }
                console.log('got update', update);
                watchInfo.callback(update);
            };
        })();
    }
    connect(segmentsState) {
        return new GraphConnection(this, segmentsState);
    }
    trackSegment(id, callback) {
        return this.watchSegment(id, info => {
            if (info === 'invalid') {
                callback(null);
            } else if (info === 'error') {
                // Ignore errors.
                return;
            } else {
                callback(info.id);
            }
        });
    }
    watchSegment(segment, callback) {
        let watchInfo = {
            callback,
            segment,
            watchId: -1
        };
        this.watches.add(watchInfo);
        const websocket = this.websocket;

        if (websocket !== undefined) {
            try {
                websocket.send(_JSON$stringify({ 'watch': { 'segment_id': segment.toString() } }));
                let watchId = this.nextWatchId++;
                watchInfo.watchId = watchId;
                this.watchesById.set(watchId, watchInfo);
            } catch (_a) {
                // Ignore send error, which indicates the connection has been closed.  The close handler
                // already deals with this case.
            }
        } else {
            this.startWebsocket();
        }
        const disposer = () => {
            const websocket = this.websocket;

            if (websocket !== undefined && websocket.readyState === WebSocket.OPEN) {
                const watchId = watchInfo.watchId;
                this.watchesById.delete(watchId);
                try {
                    websocket.send(_JSON$stringify({ 'unwatch': { 'watch_id': watchId } }));
                } catch (_a) {
                    // Ignore send error, which indicates the connection has been closed.  The close handler
                    // already deals with this case.
                }
            }
            this.watches.delete(watchInfo);
        };
        return disposer;
    }
    async merge(a, b) {
        let response = await nggraphGraphFetch(this.chunkManager, this.serverUrl, this.entityName, '/graph/mutate', {
            body: _JSON$stringify({
                merge: { anchor: a.toString(), other: b.toString() }
            }),
            headers: { 'Content-Type': 'application/json' },
            method: 'POST'
        });
        verifyObject(response);
        return verifyObjectProperty(response, 'merged', x => Uint64.parseString(x));
    }
    async split(include, exclude) {
        let response = await nggraphGraphFetch(this.chunkManager, this.serverUrl, this.entityName, '/graph/mutate', {
            body: _JSON$stringify({
                split: { include: include.toString(), exclude: exclude.toString() }
            }),
            headers: { 'Content-Type': 'application/json' },
            method: 'POST'
        });
        verifyObject(response);
        return {
            include: verifyObjectProperty(response, 'include', x => Uint64.parseString(x)),
            exclude: verifyObjectProperty(response, 'exclude', x => Uint64.parseString(x))
        };
    }
}
function parseNggraphUrl(providerUrl) {
    const m = providerUrl.match(urlPattern);
    if (m === null) {
        throw new Error(`Invalid nggraph url: ${_JSON$stringify(providerUrl)}`);
    }
    return { serverUrl: m[1], id: m[2] };
}
function fetchWithNggraphCredentials(credentialsProvider, serverUrl, path, init, cancellationToken = uncancelableToken) {
    return fetchWithCredentials(credentialsProvider, `${serverUrl}${path}`, init, responseJson, (credentials, init) => {
        const headers = new Headers(init.headers);
        headers.set('Authorization', credentials.token);
        return _Object$assign(_Object$assign({}, init), { headers });
    }, error => {
        const status = error.status;

        if (status === 401) return 'refresh';
        throw error;
    }, cancellationToken);
}
function nggraphServerFetch(chunkManager, serverUrl, path, init, cancellationToken = uncancelableToken) {
    return fetchWithNggraphCredentials(getCredentialsProvider(chunkManager, serverUrl), serverUrl, path, init, cancellationToken);
}
class NggraphEntityCredentialsProvider extends CredentialsProvider {
    constructor(parentCredentialsProvider, serverUrl, entityName) {
        super();
        this.parentCredentialsProvider = parentCredentialsProvider;
        this.serverUrl = serverUrl;
        this.entityName = entityName;
        this.get = makeCredentialsGetter(async () => {
            let response = await fetchWithNggraphCredentials(this.parentCredentialsProvider, this.serverUrl, '/entity_token', {
                body: _JSON$stringify({ entity: this.entityName }),
                headers: { 'Content-Type': 'application/json' },
                method: 'POST'
            });
            return { token: response['token'], entityType: response['entity_type'], role: response['role'] };
        });
    }
}
function getCredentialsProvider(chunkManager, serverUrl) {
    return chunkManager.memoize.getUncounted({ 'type': 'nggraph:credentialsProvider', serverUrl }, () => new NggraphCredentialsProvider(serverUrl));
}
function getEntityCredentialsProvider(chunkManager, serverUrl, entityName) {
    return chunkManager.memoize.getUncounted({ 'type': 'nggraph:entityCredentialsProvider', serverUrl, entityName }, () => new NggraphEntityCredentialsProvider(getCredentialsProvider(chunkManager, serverUrl), serverUrl, entityName));
}
function nggraphGraphFetch(chunkManager, serverUrl, entityName, path, init, cancellationToken = uncancelableToken) {
    return fetchWithNggraphCredentials(getEntityCredentialsProvider(chunkManager, serverUrl, entityName), serverUrl, path, init, cancellationToken);
}
function parseListResponse(response) {
    verifyObject(response);
    return verifyObjectProperty(response, 'entities', entries => parseArray(entries, entry => {
        verifyObject(entry);
        const id = verifyObjectProperty(entry, 'entity', verifyString);
        const entityType = verifyObjectProperty(entry, 'entity_type', verifyString);
        const accessRole = verifyObjectProperty(entry, 'access_role', verifyString);
        return { id, entityType, accessRole };
    }));
}
export class NggraphDataSource extends DataSourceProvider {
    get description() {
        return 'nggraph data source';
    }
    get(options) {
        var _parseNggraphUrl = parseNggraphUrl(options.providerUrl);

        const serverUrl = _parseNggraphUrl.serverUrl,
              id = _parseNggraphUrl.id;

        return options.chunkManager.memoize.getUncounted({ 'type': 'nggraph:get', serverUrl, id }, async () => {
            let entityCredentialsProvider = getEntityCredentialsProvider(options.chunkManager, serverUrl, id);
            const entityType = (await entityCredentialsProvider.get()).credentials.entityType;

            if (entityType != 'graph') {
                throw new Error(`Unsupported entity type: ${_JSON$stringify(entityType)}`);
            }

            var _ref5 = await nggraphGraphFetch(options.chunkManager, serverUrl, id, '/graph/config', { method: 'POST' });

            const baseSegmentation = _ref5.datasource_url;

            let baseSegmentationDataSource = await options.registry.get(_Object$assign(_Object$assign({}, options), { url: baseSegmentation }));
            const segmentationGraph = new NggraphSegmentationGraphSource(options.chunkManager, serverUrl, id);
            const subsources = [...baseSegmentationDataSource.subsources, {
                id: 'graph',
                default: true,
                subsource: { segmentationGraph }
            }];
            const dataSource = {
                modelTransform: baseSegmentationDataSource.modelTransform,
                subsources
            };
            return dataSource;
        });
    }
    async completeUrl(options) {
        var _parseNggraphUrl2 = parseNggraphUrl(options.providerUrl);

        const serverUrl = _parseNggraphUrl2.serverUrl,
              id = _parseNggraphUrl2.id;

        const list = await options.chunkManager.memoize.getUncounted({ 'type': 'nggraph:list', serverUrl }, async () => {
            return parseListResponse((await nggraphServerFetch(options.chunkManager, serverUrl, '/list', { method: 'POST' })));
        });
        return {
            offset: serverUrl.length + 1,
            completions: getPrefixMatchesWithDescriptions(id, list, entry => entry.id, entry => `${entry.entityType} (${entry.accessRole})`)
        };
    }
}
//# sourceMappingURL=frontend.js.map