import _JSON$stringify from "babel-runtime/core-js/json/stringify";
import _Promise from "babel-runtime/core-js/promise";
import _Object$assign from "babel-runtime/core-js/object/assign";
import _Object$keys from "babel-runtime/core-js/object/keys";
import _Map from "babel-runtime/core-js/map";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import { WithParameters } from "../../chunk_manager/backend";
import { registerSharedObject } from "../../worker_rpc";
import { Uint64 } from "../../util/uint64";
import { AnnotationSerializer, makeAnnotationPropertySerializers, AnnotationType } from "../../annotation";
import { AnnotationGeometryData, AnnotationSource, AnnotationGeometryChunkSourceBackend } from "../../annotation/backend";
import { WithSharedCredentialsProviderCounterpart } from "../../credentials_provider/shared_counterpart";
import { AnnotationSourceParameters, AnnotationChunkSourceParameters, isAuthRefreshable } from "./base";
import { makeRequestWithCredentials, ClioInstance } from "./api";
import { ClioAnnotationFacade, makeEncoders } from "./utils";
import { ANNOTAIION_COMMIT_ADD_SIGNAL_RPC_ID, getAnnotationKey, getAnnotationId, parseAnnotationId, typeOfAnnotationId, isAnnotationIdValid } from "../flyem/annotation";
import { StringMemoize } from "../../util/memoize";
import { RefCounted } from "../../util/disposable";
class AnnotationStore extends RefCounted {
    constructor() {
        super(...arguments);
        this.store = new _Map();
    }
    clear() {
        this.store.clear();
    }
    add(id, value) {
        if (id) {
            this.store.set(id, value);
        }
    }
    remove(id) {
        this.store.delete(id);
    }
    update(id, value) {
        this.add(id, value);
    }
    getValue(id) {
        return this.store.get(id);
    }
}
let memoize = new StringMemoize();
function getAnnotationStore(parameters) {
    const instance = new ClioInstance(parameters);
    return memoize.get(instance.getAllAnnotationsUrl(), () => {
        return new AnnotationStore();
    });
}
// let annotationStore = new AnnotationStore;
function ClioSource(Base, parametersConstructor) {
    return WithParameters(WithSharedCredentialsProviderCounterpart()(Base), parametersConstructor);
}
export function parseUint64ToArray(out, v) {
    if (v) {
        out.push(Uint64.parseString(v));
    }
    return out;
}
// const annotationPropertySerializer = new AnnotationPropertySerializer(3, []);
function parseAnnotations(source, chunk, responses, propSpec, emittingAddSignal) {
    const annotationPropertySerializers = makeAnnotationPropertySerializers(3, propSpec);
    const serializer = new AnnotationSerializer(annotationPropertySerializers);
    if (responses) {
        let parseSingleAnnotation = (key, response, index, lastIndex) => {
            if (response) {
                try {
                    let annotation = source.decodeAnnotation(key, response);
                    if (annotation) {
                        if (index === lastIndex) {
                            annotation.source = `downloaded:last`;
                        } else {
                            annotation.source = `downloaded:${index}/${lastIndex}`;
                        }
                        getAnnotationStore(source.parameters).add(getAnnotationId(annotation), response);
                        serializer.add(annotation);
                        if (emittingAddSignal) {
                            source.rpc.invoke(ANNOTAIION_COMMIT_ADD_SIGNAL_RPC_ID, {
                                id: source.rpcId,
                                newAnnotation: annotation
                            });
                        }
                    }
                } catch (e) {
                    console.log(`Error parsing annotation: ${e.message}`);
                }
            }
        };
        const parameters = source.parameters;

        const annotationCount = _Object$keys(responses).length;
        _Object$keys(responses).forEach((key, index) => {
            let response = responses[key];
            if (response) {
                if (!('Kind' in response)) {
                    response['Kind'] = parameters.kind;
                }
            }
            parseSingleAnnotation(response.key || key, response, index, annotationCount - 1);
        });
    }
    chunk.data = _Object$assign(new AnnotationGeometryData(), serializer.serialize());
}
// function getTopUrl(parameters: ClioSourceParameters) {
//   return `${parameters.baseUrl}`;
// }
// function getClioUrl(parameters: ClioSourceParameters, path: string) {
//   return getTopUrl(parameters) + path;
// }
/*
function getAnnotationEndpoint(parameters: ClioSourceParameters) {
  return parameters.kind === 'Atlas' ? 'atlas' : 'annotations';
}

function getElementsPath(parameters: ClioSourceParameters) {
  return `/${getAnnotationEndpoint(parameters)}/${parameters.dataset}`;
}

function getAnnotationPath(parameters: ClioSourceParameters, position: ArrayLike<number|string>) {
  return `${getElementsPath(parameters)}?x=${position[0]}&y=${position[1]}&z=${position[2]}`;
}

function getAnnotationUrl(parameters: ClioSourceParameters, position: ArrayLike<number|string>) {
  return getClioUrl(parameters, getAnnotationPath(parameters, position));
}
*/
let ClioAnnotationGeometryChunkSource = class ClioAnnotationGeometryChunkSource extends ClioSource(AnnotationGeometryChunkSourceBackend, AnnotationChunkSourceParameters) {
    constructor() {
        super(...arguments);
        this.encoder = makeEncoders(this.parameters.api, this.parameters.kind);
    }
    decodeAnnotation(key, entry) {
        const type = typeOfAnnotationId(key);
        if (type !== null) {
            return this.encoder[type].decode(key, entry);
        }
        return null;
    }
    async download(chunk, cancellationToken) {
        // let values: any[] = [];
        getAnnotationStore(this.parameters).clear();
        const clioInstance = new ClioInstance(this.parameters);
        let pointAnnotationValues = await makeRequestWithCredentials(this.credentialsProvider, isAuthRefreshable(this.parameters), {
            method: 'GET',
            url: clioInstance.getAllAnnotationsUrl(),
            payload: undefined,
            responseType: 'json'
        }, cancellationToken);
        // values = [...pointAnnotationValues];
        return parseAnnotations(this, chunk, pointAnnotationValues, this.parameters.properties, true);
    }
};
ClioAnnotationGeometryChunkSource = __decorate([registerSharedObject() //
], ClioAnnotationGeometryChunkSource);
export { ClioAnnotationGeometryChunkSource };
let ClioAnnotationSource = class ClioAnnotationSource extends ClioSource(AnnotationSource, AnnotationSourceParameters) {
    constructor(rpc, options) {
        super(rpc, options);
        this.encoders = makeEncoders(this.parameters.api, this.parameters.kind);
        // updateAnnotationTypeHandler();
    }
    requestLineMetaData(id, _) {
        return _Promise.resolve(getAnnotationStore(this.parameters).getValue(id));
    }
    requestSphereMetaData(id, _) {
        return _Promise.resolve(getAnnotationStore(this.parameters).getValue(id));
    }
    requestPointMetaData(id, _) {
        return _Promise.resolve(getAnnotationStore(this.parameters).getValue(id));
        /*
        const { parameters } = this;
        return makeRequestWithCredentials(
          this.credentialsProvider,
          {
            method: 'GET',
            url: getAnnotationUrl(parameters, id.split('_')),
            responseType: 'json',
          },
          cancellationToken).then(
            response => {
              if (response && response.length > 0) {
                return response[0];
              } else {
                return response;
              }
            }
          );
          */
    }
    requestMetadata(chunk, cancellationToken) {
        const id = chunk.key;
        switch (typeOfAnnotationId(id)) {
            case AnnotationType.POINT:
                return this.requestPointMetaData(id, cancellationToken);
            case AnnotationType.LINE:
                return this.requestLineMetaData(id, cancellationToken);
            case AnnotationType.SPHERE:
                return this.requestSphereMetaData(id, cancellationToken);
            default:
                throw new Error(`Invalid annotation ID for DVID: ${id}`);
        }
    }
    downloadMetadata(chunk, cancellationToken) {
        return this.requestMetadata(chunk, cancellationToken).then(response => {
            if (response) {
                chunk.annotation = this.decodeAnnotation(chunk.key, response);
            } else {
                chunk.annotation = null;
            }
        });
    }
    uploadable(annotation) {
        const encoder = this.getEncoder(annotation);
        if (encoder) {
            return encoder.uploadable(typeof annotation === 'string' ? encoder.decode(annotation, getAnnotationStore(this.parameters).getValue(annotation)) : annotation);
        }
        return false;
    }
    decodeAnnotation(key, entry) {
        const type = typeOfAnnotationId(key);
        if (type) {
            return this.encoders[type].decode(key, entry);
        }
        return null;
    }
    getEncoder(annotation) {
        let type = null;
        if (typeof annotation === 'string') {
            type = typeOfAnnotationId(annotation);
        } else {
            type = annotation.type;
        }
        if (type !== null) {
            return this.encoders[type];
        }
        return undefined;
    }
    encodeAnnotation(annotation) {
        const encoder = this.getEncoder(annotation);
        if (encoder) {
            return encoder.encode(annotation);
        }
        return null;
    }
    updateAnnotation(annotation, overwrite) {
        try {
            const parameters = this.parameters;

            if (!parameters.user) {
                throw Error('Cannot upload an annotation without a user');
            }
            new ClioAnnotationFacade(annotation).user = parameters.user;
            const encoded = this.encodeAnnotation(annotation);
            if (encoded === null) {
                throw new Error('Unable to encode the annotation');
            }
            if (!overwrite && getAnnotationStore(this.parameters).getValue(getAnnotationId(annotation))) {
                throw new Error('Cannot overwrite existing annotation');
            }
            let value = _JSON$stringify(encoded);
            getAnnotationStore(this.parameters).update(getAnnotationId(annotation), encoded);
            if (this.uploadable(annotation)) {
                const clioInstance = new ClioInstance(parameters);
                return makeRequestWithCredentials(this.credentialsProvider, isAuthRefreshable(parameters), {
                    method: 'POST',
                    url: clioInstance.getPostAnnotationUrl(annotation.point),
                    payload: value,
                    responseType: 'json'
                });
            } else {
                return _Promise.resolve(getAnnotationKey(annotation));
            }
        } catch (e) {
            return _Promise.reject(e);
        }
    }
    addAnnotation(annotation) {
        return this.updateAnnotation(annotation, false).then(response => {
            let key = undefined;
            if (typeof response === 'string' && response.length > 0) {
                key = response;
            } else {
                key = response.key;
            }
            return getAnnotationId(annotation, key);
        }).catch(e => {
            throw new Error(e);
        });
    }
    add(annotation) {
        return this.addAnnotation(annotation);
    }
    update(id, annotation) {
        if (getAnnotationId(annotation) !== id) {
            delete annotation.key; //TODO: may need a safer way to handle id difference
        }
        return this.updateAnnotation(annotation, true);
    }
    deleteAnnotation(id) {
        const clioInstance = new ClioInstance(this.parameters);
        if (this.uploadable(id)) {
            const cachedAnnotation = getAnnotationStore(this.parameters).getValue(id);
            if (cachedAnnotation) {
                const user = cachedAnnotation.user;

                if (user && user !== this.parameters.user) {
                    throw new Error(`Unable to delete annotation owned by ${user}.`);
                }
            }
            const idInfo = parseAnnotationId(id);
            const key = idInfo ? idInfo.key : id;
            return makeRequestWithCredentials(this.credentialsProvider, isAuthRefreshable(this.parameters), {
                method: 'DELETE',
                url: clioInstance.getDeleteAnnotationUrl(key),
                // url: getAnnotationUrl(parameters, id.split('_')),
                responseType: ''
            }).then(() => {
                getAnnotationStore(this.parameters).remove(id);
            });
        } else {
            getAnnotationStore(this.parameters).remove(id);
            return _Promise.resolve();
        }
    }
    delete(id) {
        if (isAnnotationIdValid(id)) {
            try {
                return this.deleteAnnotation(id);
            } catch (e) {
                return _Promise.reject(e);
            }
        } else {
            return _Promise.resolve();
        }
    }
};
ClioAnnotationSource = __decorate([registerSharedObject()], ClioAnnotationSource);
export { ClioAnnotationSource };
//# sourceMappingURL=backend.js.map