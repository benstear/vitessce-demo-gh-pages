import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Symbol$iterator from 'babel-runtime/core-js/symbol/iterator';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Promise from 'babel-runtime/core-js/promise';
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { MultiscaleAnnotationSource, AnnotationGeometryChunkSource } from '../../annotation/frontend_source';
import { WithParameters } from '../../chunk_manager/frontend';
import { WithCredentialsProvider } from '../../credentials_provider/chunk_source_frontend';
import { AnnotationType } from '../../annotation';
import { Signal } from '../../util/signal';
import { makeSliceViewChunkSpecification } from '../../sliceview/base';
import { mat4 } from '../../util/geom';
import { makeCoordinateSpace, makeIdentityTransform, makeIdentityTransformedBoundingBox } from '../../coordinate_transform';
// import {parseArray, parseFixedLengthArray, parseQueryStringParameters, verifyEnumString, verifyFinitePositiveFloat, verifyInt, verifyObject, verifyObjectProperty, verifyOptionalObjectProperty, verifyPositiveInt, verifyString} from 'neuroglancer/util/json';
import { parseQueryStringParameters, verifyObject, verifyObjectProperty, verifyString } from '../../util/json';
import { DataSourceProvider } from './..';
import { getUserFromToken } from '../flyem/annotation';
import { ClioAnnotationFacade, parseDescription } from './utils';
import { makeRequest } from '../dvid/api';
import { StatusMessage } from '../../status';
import { vec3 } from '../../util/geom';
import { VolumeInfo } from '../flyem/datainfo';
import { makeAnnotationEditWidget } from '../flyem/widgets';
import { defaultAnnotationSchema, defaultAtlasSchema } from './utils';
import { credentialsKey, makeRequestWithCredentials, getGrayscaleInfoUrl, ClioInstance, parseGrayscaleUrl } from './api';
import { AnnotationSourceParameters, AnnotationChunkSourceParameters, isAuthRefreshable } from './base';
class ClioAnnotationChunkSource extends WithParameters(WithCredentialsProvider()(AnnotationGeometryChunkSource), AnnotationChunkSourceParameters) {}
async function getAnnotationDataInfo(parameters) {
    const grayscale = parameters.grayscale;

    if (grayscale) {
        let u = parseGrayscaleUrl(grayscale);
        return makeRequest({
            'method': 'GET',
            'url': getGrayscaleInfoUrl(u),
            responseType: 'json'
        }).then(response => {
            return new VolumeInfo(response, u.protocol === 'https' ? 'gs' : u.protocol);
        });
    } else {
        return _Promise.resolve({
            numChannels: 1,
            voxelSize: vec3.fromValues(8, 8, 8),
            lowerVoxelBound: vec3.fromValues(0, 0, 0),
            upperVoxelBound: vec3.fromValues(50000, 50000, 50000),
            blockSize: vec3.fromValues(64, 64, 64),
            numLevels: 1
        });
        // throw Error('No volume information provided.');
    }
}
function makeAnnotationGeometrySourceSpecifications(dataInfo) {
    const rank = 3;
    let makeSpec = info => {
        const chunkDataSize = info.upperVoxelBound;
        let spec = makeSliceViewChunkSpecification({
            rank,
            chunkDataSize: Uint32Array.from(chunkDataSize),
            lowerVoxelBound: info.lowerVoxelBound,
            upperVoxelBound: info.upperVoxelBound
        });
        return { spec, chunkToMultiscaleTransform: mat4.create() };
    };
    return [[makeSpec(dataInfo)]];
}
const MultiscaleAnnotationSourceBase = WithParameters(WithCredentialsProvider()(MultiscaleAnnotationSource), AnnotationSourceParameters);
export class ClioAnnotationSource extends MultiscaleAnnotationSourceBase {
    constructor(chunkManager, options) {
        super(chunkManager, _Object$assign({ rank: 3, relationships: ['segments'], properties: options.parameters.properties }, options));
        this.readonly = false;
        this.parameters = options.parameters;
        this.dataInfo = options.dataInfo;
        this.childAdded = this.childAdded || new Signal();
        this.childUpdated = this.childUpdated || new Signal();
        this.childDeleted = this.childDeleted || new Signal();
        this.makeEditWidget = reference => {
            const getFacade = annotation => {
                return new ClioAnnotationFacade(annotation);
            };
            const getProp = annotation => {
                return _Object$assign(_Object$assign({}, annotation.prop), annotation.ext);
            };
            const setProp = (annotation, prop) => {
                const annotationRef = new ClioAnnotationFacade(annotation);
                if (prop.title) {
                    annotationRef.title = prop.title;
                }
                if (prop.description) {
                    annotationRef.description = prop.description;
                }
            };
            return makeAnnotationEditWidget(reference, this.parameters.schema, this, getFacade, getProp, setProp);
        };
        this.getUser = () => this.parameters.user;
    }
    getSources(_options) {
        let sourceSpecifications = makeAnnotationGeometrySourceSpecifications(this.dataInfo);
        let limit = 0;
        if (sourceSpecifications[0].length > 1) {
            limit = 10;
        }
        return sourceSpecifications.map(alternatives => alternatives.map(({ spec, chunkToMultiscaleTransform }) => ({
            chunkSource: this.chunkManager.getChunkSource(ClioAnnotationChunkSource, {
                spec: _Object$assign({ limit, chunkToMultiscaleTransform }, spec),
                parent: this,
                credentialsProvider: this.credentialsProvider,
                parameters: this.parameters
            }),
            chunkToMultiscaleTransform
        })));
    }
    *[_Symbol$iterator]() {
        for (let reference of this.references) {
            if (reference[1].value) {
                yield reference[1].value;
            }
        }
    }
    commit(reference) {
        if (reference.value && (reference.value.type === AnnotationType.LINE || reference.value.type === AnnotationType.SPHERE)) {
            reference.value.pointA = reference.value.pointA.map(x => Math.round(x));
            reference.value.pointB = reference.value.pointB.map(x => Math.round(x));
        }
        super.commit(reference);
    }
    add(annotation, commit = true) {
        if (this.readonly) {
            let errorMessage = 'Permission denied for changing annotations.';
            StatusMessage.showTemporaryMessage(errorMessage);
            throw Error(errorMessage);
        }
        const clioAnnotation = new ClioAnnotationFacade(annotation);
        clioAnnotation.addTimeStamp();
        if (this.parameters.user) {
            clioAnnotation.user = this.parameters.user;
        }
        if (annotation.type === AnnotationType.POINT) {
            clioAnnotation.kind = this.parameters.kind || 'Note';
            if (annotation.description) {
                let defaultProp = parseDescription(annotation.description);
                if (defaultProp) {
                    clioAnnotation.setProp(defaultProp);
                }
            }
        }
        clioAnnotation.roundPos();
        clioAnnotation.update();
        return super.add(annotation, commit);
    }
    update(reference, newAnnotation) {
        const annotationRef = new ClioAnnotationFacade(newAnnotation);
        annotationRef.roundPos();
        annotationRef.update();
        super.update(reference, newAnnotation);
    }
    invalidateCache() {
        this.references.forEach(ref => {
            ref.dispose();
        });
        this.references.clear();
        this.childRefreshed.dispatch();
        this.metadataChunkSource.invalidateCache();
        for (let sources1 of this.getSources({
            multiscaleToViewTransform: new Float32Array(),
            displayRank: 1,
            modelChannelDimensionIndices: []
        })) {
            for (let source of sources1) {
                source.chunkSource.invalidateCache();
            }
        }
        for (let source of this.segmentFilteredSources) {
            source.invalidateCache();
        }
        // this.childRefreshed.dispatch();
    }
}
async function getAnnotationChunkSource(options, sourceParameters, dataInfo, credentialsProvider) {
    let getChunkSource = (dataInfo, parameters) => options.chunkManager.getChunkSource(ClioAnnotationSource, {
        parameters,
        credentialsProvider,
        dataInfo
    });
    return getChunkSource(dataInfo, sourceParameters);
}
async function getAnnotationSource(options, sourceParameters, credentialsProvider) {
    const dataInfo = await getAnnotationDataInfo(sourceParameters);
    const box = {
        lowerBounds: new Float64Array(dataInfo.lowerVoxelBound),
        upperBounds: Float64Array.from(dataInfo.upperVoxelBound)
    };
    const modelSpace = makeCoordinateSpace({
        rank: 3,
        names: ['x', 'y', 'z'],
        units: ['m', 'm', 'm'],
        scales: Float64Array.from(dataInfo.voxelSize, x => x / 1e9),
        boundingBoxes: [makeIdentityTransformedBoundingBox(box)]
    });
    const annotation = await getAnnotationChunkSource(options, sourceParameters, dataInfo, credentialsProvider);
    const dataSource = {
        modelTransform: makeIdentityTransform(modelSpace),
        subsources: [{
            id: 'default',
            subsource: { annotation },
            default: true
        }]
    };
    return dataSource;
}
//https://us-east4-flyem-private.cloudfunctions.net/mb20?query=value
const urlPattern = /^([^\/]+:\/\/[^\/]+)\/(?:([^\/\?#]+)\/)?([^\/\?#]+)(?:(?:\?|#)(.*))?$/;
// const urlPattern = /^((?:http|https):\/\/[^\/]+)\/([^\/]+)\/([^\/\?#]+)(?:(?:\?|#)(.*))?$/;
function parseSourceUrl(url) {
    let match = url.match(urlPattern);
    if (match === null) {
        throw new Error(`Invalid Clio URL: ${_JSON$stringify(url)}.`);
    }
    let sourceParameters = {
        baseUrl: match[1],
        api: match[2],
        dataset: match[3]
    };
    let queryString = match[4];
    if (queryString) {
        let parameters = parseQueryStringParameters(queryString);
        if (parameters.token) {
            sourceParameters.authToken = parameters.token;
            sourceParameters.authServer = 'token:' + parameters.token;
        } else if (parameters.auth) {
            sourceParameters.authServer = parameters.auth;
        }
        if (parameters.user) {
            sourceParameters.user = parameters.user;
        } else if (sourceParameters.authToken) {
            sourceParameters.user = getUserFromToken(sourceParameters.authToken);
        }
        if (parameters.kind) {
            if (parameters.kind === 'atlas') {
                sourceParameters.kind = 'Atlas';
            } else {
                sourceParameters.kind = parameters.kind;
            }
        } else {
            sourceParameters.kind = 'Normal';
        }
        if (parameters.groups) {
            sourceParameters.groups = parameters.groups;
        }
    }
    return sourceParameters;
}
async function completeSourceParameters(sourceParameters, getCredentialsProvider) {
    const clioInstance = new ClioInstance(sourceParameters);
    return makeRequestWithCredentials(getCredentialsProvider(sourceParameters.authServer), isAuthRefreshable(sourceParameters), {
        url: clioInstance.getDatasetsUrl(),
        method: 'GET',
        responseType: 'json'
    }).then(response => {
        const grayscaleInfo = verifyObjectProperty(response, sourceParameters.dataset, verifyObject);
        if ('location' in grayscaleInfo) {
            sourceParameters.grayscale = verifyObjectProperty(grayscaleInfo, 'location', verifyString);
        } else if ('mainLayer' in grayscaleInfo) {
            const mainLayer = verifyObjectProperty(grayscaleInfo, 'mainLayer', verifyString);
            const neuroglancer = verifyObjectProperty(grayscaleInfo, 'neuroglancer', verifyObject);
            const layers = neuroglancer.layers;
            const layer = layers.find(layer => layer.name === mainLayer);
            if (layer.source && layer.source.url) {
                sourceParameters.grayscale = verifyObjectProperty(layer.source, 'url', verifyString);
            } else {
                sourceParameters.grayscale = verifyObjectProperty(layer, 'source', verifyString);
            }
        }
        return sourceParameters;
    });
}
async function getDataSource(options, getCredentialsProvider) {
    let sourceParameters = parseSourceUrl(options.providerUrl);
    if (!sourceParameters.user && sourceParameters.authServer) {
        let credentials = getCredentialsProvider(sourceParameters.authServer).get();
        sourceParameters.authToken = (await credentials).credentials;
        sourceParameters.user = getUserFromToken(sourceParameters.authToken);
    }
    return options.chunkManager.memoize.getUncounted(_Object$assign({ type: 'clio:MultiscaleVolumeChunkSource' }, sourceParameters), async () => {
        sourceParameters = await completeSourceParameters(sourceParameters, getCredentialsProvider);
        let annotationSourceParameters = _Object$assign(_Object$assign({}, new AnnotationSourceParameters()), sourceParameters);
        // annotationSourceParameters.schema = getSchema(annotationSourceParameters);
        if (sourceParameters.kind === 'Atlas') {
            annotationSourceParameters.schema = defaultAtlasSchema;
        } else {
            annotationSourceParameters.schema = defaultAnnotationSchema;
        }
        annotationSourceParameters.properties = [{
            identifier: 'rendering_attribute',
            description: 'rendering attribute',
            type: 'int32',
            default: 0,
            min: 0,
            max: 5,
            step: 1
        }];
        // let credentials = sourceParameters.authToken;
        const credentialsProvider = getCredentialsProvider(sourceParameters.authServer);
        return getAnnotationSource(options, annotationSourceParameters, credentialsProvider);
    });
}
async function completeHttpPath(_1) {
    return _Promise.resolve({
        offset: 0,
        completions: [{ value: '' }]
    });
}
//Clio data source provider
export class ClioDataSource extends DataSourceProvider {
    constructor(credentialsManager) {
        super();
        this.credentialsManager = credentialsManager;
        this.description = 'Clio';
    }
    getCredentialsProvider(authServer) {
        let parameters = '';
        if (authServer) {
            parameters = authServer;
        }
        return this.credentialsManager.getCredentialsProvider(credentialsKey, parameters);
    }
    get(options) {
        return getDataSource(options, this.getCredentialsProvider.bind(this));
    }
    completeUrl(options) {
        return completeHttpPath(options.providerUrl);
    }
}
//# sourceMappingURL=frontend.js.map