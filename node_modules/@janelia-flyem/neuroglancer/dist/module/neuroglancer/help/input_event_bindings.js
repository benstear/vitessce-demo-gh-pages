import _Array$from from 'babel-runtime/core-js/array/from';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Map from 'babel-runtime/core-js/map';
import _Object$assign from 'babel-runtime/core-js/object/assign';

import { SidePanel } from '../ui/side_panel'; /**
                                               * @license
                                               * Copyright 2016 Google Inc.
                                               * Licensed under the Apache License, Version 2.0 (the "License");
                                               * you may not use this file except in compliance with the License.
                                               * You may obtain a copy of the License at
                                               *
                                               *      http://www.apache.org/licenses/LICENSE-2.0
                                               *
                                               * Unless required by applicable law or agreed to in writing, software
                                               * distributed under the License is distributed on an "AS IS" BASIS,
                                               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                               * See the License for the specific language governing permissions and
                                               * limitations under the License.
                                               */

import { DEFAULT_SIDE_PANEL_LOCATION, TrackableSidePanelLocation } from '../ui/side_panel_location';
import { animationFrameDebounce } from '../util/animation_frame_debounce';
import { removeChildren } from '../util/dom';
import { emptyToUndefined } from '../util/json';
export function formatKeyName(name) {
    if (name.startsWith('key')) {
        return name.substring(3);
    }
    if (name.startsWith('digit')) {
        return name.substring(5);
    }
    if (name.startsWith('arrow')) {
        return name.substring(5);
    }
    return name;
}
export function formatKeyStroke(stroke) {
    let parts = stroke.split('+');
    return parts.map(formatKeyName).join('+');
}
const DEFAULT_HELP_PANEL_LOCATION = _Object$assign(_Object$assign({}, DEFAULT_SIDE_PANEL_LOCATION), { side: 'left', row: 1 });
export class HelpPanelState {
    constructor() {
        this.location = new TrackableSidePanelLocation(DEFAULT_HELP_PANEL_LOCATION);
    }
    get changed() {
        return this.location.changed;
    }
    toJSON() {
        return emptyToUndefined(this.location.toJSON());
    }
    reset() {
        this.location.reset();
    }
    restoreState(obj) {
        this.location.restoreState(obj);
    }
}
export class InputEventBindingHelpDialog extends SidePanel {
    constructor(sidePanelManager, state, bindings, layerManager, toolBinder) {
        super(sidePanelManager, state.location);
        this.bindings = bindings;
        this.toolBinder = toolBinder;
        this.scroll = document.createElement('div');
        this.addTitleBar({ title: 'Help' });
        const body = document.createElement('div');
        body.classList.add('neuroglancer-help-body');
        const scroll = this.scroll;

        scroll.classList.add('neuroglancer-help-scroll-container');
        body.appendChild(scroll);
        this.addBody(body);
        const debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateView()));
        this.registerDisposer(toolBinder.changed.add(debouncedUpdateView));
        this.registerDisposer(layerManager.layersChanged.add(debouncedUpdateView));
        this.updateView();
    }
    updateView() {
        const scroll = this.scroll,
              bindings = this.bindings,
              toolBinder = this.toolBinder;

        removeChildren(scroll);
        const uniqueMaps = new _Map();
        function addEntries(eventMap, entries) {
            for (const parent of eventMap.parents) {
                if (parent.label !== undefined) {
                    addMap(parent.label, parent);
                } else {
                    addEntries(parent, entries);
                }
            }
            for (const _ref of eventMap.bindings.entries()) {
                var _ref2 = _slicedToArray(_ref, 2);

                const event = _ref2[0];
                const eventAction = _ref2[1];

                const firstColon = event.indexOf(':');
                const suffix = event.substring(firstColon + 1);
                entries.set(suffix, eventAction.action);
            }
        }
        function addMap(label, map) {
            if (uniqueMaps.has(map)) {
                return;
            }
            const list = {
                label,
                entries: new _Map()
            };
            addEntries(map, list.entries);
            uniqueMaps.set(map, list);
        }
        for (const _ref3 of bindings) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const label = _ref4[0];
            const eventMap = _ref4[1];

            addMap(label, eventMap);
        }
        const addGroup = (title, entries) => {
            let header = document.createElement('h2');
            header.textContent = title;
            scroll.appendChild(header);
            for (const _ref5 of entries) {
                var _ref6 = _slicedToArray(_ref5, 2);

                const event = _ref6[0];
                const action = _ref6[1];

                let dt = document.createElement('div');
                dt.className = 'dt';
                dt.textContent = formatKeyStroke(event);
                let dd = document.createElement('div');
                dd.className = 'dd';
                dd.textContent = action;
                scroll.appendChild(dt);
                scroll.appendChild(dd);
            }
        };
        const layerToolBindingsMap = new _Map();
        for (const _ref7 of toolBinder.bindings) {
            var _ref8 = _slicedToArray(_ref7, 2);

            const key = _ref8[0];
            const tool = _ref8[1];

            let layerBindings = layerToolBindingsMap.get(tool.layer);
            if (layerBindings === undefined) {
                layerBindings = [];
                layerToolBindingsMap.set(tool.layer, layerBindings);
            }
            layerBindings.push([`shift+key${key.toLowerCase()}`, tool.description]);
        }
        const layerToolBindings = _Array$from(layerToolBindingsMap.entries());
        if (layerToolBindings.length > 0) {
            layerToolBindings[0][0].manager.root.layerManager.updateNonArchivedLayerIndices();
            layerToolBindings.sort((a, b) => a[0].managedLayer.nonArchivedLayerIndex - b[0].managedLayer.nonArchivedLayerIndex);
        }
        for (const _ref9 of layerToolBindings) {
            var _ref10 = _slicedToArray(_ref9, 2);

            const layer = _ref10[0];
            const bindings = _ref10[1];

            bindings.sort();
            addGroup(`Tool bindings for layer ${layer.managedLayer.nonArchivedLayerIndex + 1}: ${layer.managedLayer.name}`, bindings);
        }
        for (const list of uniqueMaps.values()) {
            addGroup(list.label, list.entries);
        }
    }
}
//# sourceMappingURL=input_event_bindings.js.map