/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { SingleTextureChunkFormat, SingleTextureVolumeChunk } from './single_texture_chunk_format';
import { DataType } from './volume/base';
import { registerChunkFormatHandler } from './volume/frontend';
import { RefCounted } from '../util/disposable';
import { Uint64 } from '../util/uint64';
import { getShaderType } from '../webgl/shader_lib';
import { computeTextureFormat, setThreeDimensionalTextureData, setTwoDimensionalTextureData, TextureAccessHelper } from '../webgl/texture_access';
class TextureLayout extends RefCounted {
    constructor(gl, chunkDataSize, textureDims) {
        super();
        this.chunkDataSize = chunkDataSize;
        this.textureDims = textureDims;
        this.textureShape = new Uint32Array(this.textureDims);
        const rank = chunkDataSize.length;
        let numRemainingDims = 0;
        for (const size of chunkDataSize) {
            if (size !== 1) ++numRemainingDims;
        }
        const strides = this.strides = new Uint32Array(rank * textureDims);
        const maxTextureSize = textureDims === 3 ? gl.max3dTextureSize : gl.maxTextureSize;
        let textureDim = 0;
        let textureDimSize = 1;
        const textureShape = this.textureShape;

        textureShape.fill(1);
        for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
            const size = chunkDataSize[chunkDim];
            if (size === 1) continue;
            const newSize = size * textureDimSize;
            let stride;
            if (newSize > maxTextureSize || textureDimSize !== 1 && textureDim + numRemainingDims < textureDims) {
                ++textureDim;
                textureDimSize = size;
                stride = 1;
            } else {
                stride = textureDimSize;
                textureDimSize = newSize;
            }
            strides[textureDims * chunkDim + textureDim] = stride;
            textureShape[textureDim] = textureDimSize;
        }
    }
    static get(gl, chunkSizeInVoxels, textureDims) {
        return gl.memoize.get(`sliceview.UncompressedTextureLayout:${chunkSizeInVoxels.join()}:${textureDims}`, () => new TextureLayout(gl, chunkSizeInVoxels, textureDims));
    }
}
let tempStridesUniform = new Uint32Array(3 * 5);
export class ChunkFormat extends SingleTextureChunkFormat {
    constructor(_gl, dataType, key, textureDims) {
        super(key, dataType);
        this.textureDims = textureDims;
        computeTextureFormat(this, dataType);
        this.shaderSamplerType = `${this.samplerPrefix}sampler${textureDims}D`;
        this.textureAccessHelper = new TextureAccessHelper('chunkData', textureDims);
    }
    static get(gl, dataType, textureDims) {
        const key = `sliceview.UncompressedChunkFormat:${dataType}:${textureDims}`;
        return gl.memoize.get(key, () => new ChunkFormat(gl, dataType, key, textureDims));
    }
    defineShader(builder, numChannelDimensions) {
        super.defineShader(builder, numChannelDimensions);
        const textureDims = this.textureDims;

        const textureVecType = `ivec${this.textureDims}`;
        let textureAccessHelper = this.textureAccessHelper;

        const stridesUniformLength = (4 + numChannelDimensions) * textureDims;
        if (tempStridesUniform.length < stridesUniformLength) {
            tempStridesUniform = new Uint32Array(stridesUniformLength);
        }
        builder.addUniform(`highp ${textureVecType}`, 'uVolumeChunkStrides', 4 + numChannelDimensions);
        builder.addFragmentCode(textureAccessHelper.getAccessor('readVolumeData', 'uVolumeChunkSampler', this.dataType));
        const shaderType = getShaderType(this.dataType);
        let code = `
${shaderType} getDataValueAt(highp ivec3 p`;
        for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
            code += `, highp int channelIndex${channelDim}`;
        }
        code += `) {
  highp ${textureVecType} offset = uVolumeChunkStrides[0]
                     + p.x * uVolumeChunkStrides[1]
                     + p.y * uVolumeChunkStrides[2]
                     + p.z * uVolumeChunkStrides[3];
`;
        for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
            code += `
  offset += channelIndex${channelDim} * uVolumeChunkStrides[${4 + channelDim}];
`;
        }
        code += `
  return readVolumeData(offset);
}
`;
        builder.addFragmentCode(code);
    }
    /**
     * Called each time textureLayout changes while drawing chunks.
     */
    setupTextureLayout(gl, shader, textureLayout, fixedChunkPosition, chunkDisplaySubspaceDimensions, channelDimensions) {
        const stridesUniform = tempStridesUniform;
        const numChannelDimensions = channelDimensions.length;
        const strides = textureLayout.strides;

        const rank = fixedChunkPosition.length;
        const textureDims = this.textureDims;

        for (let i = 0; i < textureDims; ++i) {
            let sum = 0;
            for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
                sum += fixedChunkPosition[chunkDim] * strides[chunkDim * textureDims + i];
            }
            stridesUniform[i] = sum;
        }
        for (let i = 0; i < 3; ++i) {
            const chunkDim = chunkDisplaySubspaceDimensions[i];
            if (chunkDim >= rank) continue;
            for (let j = 0; j < textureDims; ++j) {
                stridesUniform[(i + 1) * textureDims + j] = strides[chunkDim * textureDims + j];
            }
        }
        for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
            const chunkDim = channelDimensions[channelDim];
            if (chunkDim === -1) {
                stridesUniform.fill(0, (4 + channelDim) * textureDims, (4 + channelDim + 1) * textureDims);
            } else {
                for (let i = 0; i < textureDims; ++i) {
                    stridesUniform[(4 + channelDim) * textureDims + i] = strides[chunkDim * textureDims + i];
                }
            }
        }
        const uniformDataSize = (4 + numChannelDimensions) * textureDims;
        if (textureDims === 3) {
            gl.uniform3iv(shader.uniform('uVolumeChunkStrides'), stridesUniform, 0, uniformDataSize);
        } else {
            gl.uniform2iv(shader.uniform('uVolumeChunkStrides'), stridesUniform, 0, uniformDataSize);
        }
    }
    getTextureLayout(gl, chunkDataSize) {
        return TextureLayout.get(gl, chunkDataSize, this.textureDims);
    }
    setTextureData(gl, textureLayout, data) {
        const textureShape = textureLayout.textureShape;

        (this.textureDims === 3 ? setThreeDimensionalTextureData : setTwoDimensionalTextureData)(gl, this, data, textureShape[0], textureShape[1], textureShape[2]);
    }
}
export class UncompressedVolumeChunk extends SingleTextureVolumeChunk {
    setTextureData(gl) {
        let source = this.source;
        let chunkFormatHandler = source.chunkFormatHandler;
        let chunkFormat = chunkFormatHandler.chunkFormat;

        let textureLayout;
        if (this.chunkDataSize === source.spec.chunkDataSize) {
            this.textureLayout = textureLayout = chunkFormatHandler.textureLayout.addRef();
        } else {
            this.textureLayout = textureLayout = chunkFormat.getTextureLayout(gl, this.chunkDataSize);
        }
        this.chunkFormat.setTextureData(gl, textureLayout, this.data);
    }
    getValueAt(dataPosition) {
        let chunkFormat = this.chunkFormat;
        const chunkDataSize = this.chunkDataSize;

        let index = 0;
        let stride = 1;
        const rank = dataPosition.length;
        for (let i = 0; i < rank; ++i) {
            index += stride * dataPosition[i];
            stride *= chunkDataSize[i];
        }
        let dataType = chunkFormat.dataType;
        let data = this.data;
        switch (dataType) {
            case DataType.UINT8:
            case DataType.INT8:
            case DataType.FLOAT32:
            case DataType.UINT16:
            case DataType.INT16:
            case DataType.UINT32:
            case DataType.INT32:
                return data[index];
            case DataType.UINT64:
                {
                    let index2 = index * 2;
                    return new Uint64(data[index2], data[index2 + 1]);
                }
        }
    }
}
export class UncompressedChunkFormatHandler extends RefCounted {
    constructor(gl, spec) {
        super();
        let numDims = 0;
        for (const x of spec.chunkDataSize) {
            if (x > 1) ++numDims;
        }
        this.chunkFormat = this.registerDisposer(ChunkFormat.get(gl, spec.dataType, numDims >= 3 ? 3 : 2));
        this.textureLayout = this.registerDisposer(this.chunkFormat.getTextureLayout(gl, spec.chunkDataSize));
    }
    getChunk(source, x) {
        return new UncompressedVolumeChunk(source, x);
    }
}
registerChunkFormatHandler((gl, spec) => {
    if (spec.compressedSegmentationBlockSize == null) {
        return new UncompressedChunkFormatHandler(gl, spec);
    }
    return null;
});
//# sourceMappingURL=uncompressed_chunk_format.js.map