import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { chunkFormatTest } from './chunk_format_testing';
import { ChunkFormat } from './uncompressed_chunk_format';
import { DataType } from '../util/data_type';
import { prod4 } from '../util/geom';
import { getRandomValues } from '../util/random';
function fillSequential(array) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        array[i] = i;
    }
}
describe('sliceview/uncompressed_chunk_format', () => {
    describe('data access', () => {
        for (let volumeSize of [Uint32Array.of(64, 64, 64, 1), Uint32Array.of(36, 36, 36, 1)]) {
            const numElements = prod4(volumeSize);
            let data = new Float32Array(numElements);
            fillSequential(data);
            const dataType = DataType.FLOAT32;
            chunkFormatTest(dataType, volumeSize, gl => {
                let chunkFormat = ChunkFormat.get(gl, dataType, 3);
                let textureLayout = chunkFormat.getTextureLayout(gl, volumeSize);
                return [chunkFormat, textureLayout];
            }, data, data);
        }
        for (let volumeSize of [Uint32Array.of(13, 17, 23, 1), Uint32Array.of(13, 17, 23, 2)]) {
            const numElements = prod4(volumeSize);
            for (let _ref of [[DataType.UINT8, Uint8Array], [DataType.UINT16, Uint16Array], [DataType.UINT32, Uint32Array], [DataType.UINT64, Uint32Array]]) {
                var _ref2 = _slicedToArray(_ref, 2);

                let dataType = _ref2[0];
                let arrayConstructor = _ref2[1];

                let texelsPerElement = dataType === DataType.UINT64 ? 2 : 1;
                let data = new arrayConstructor(numElements * texelsPerElement);
                getRandomValues(data);
                chunkFormatTest(dataType, volumeSize, gl => {
                    let chunkFormat = ChunkFormat.get(gl, dataType, 3);
                    let textureLayout = chunkFormat.getTextureLayout(gl, volumeSize);
                    return [chunkFormat, textureLayout];
                }, data, data);
            }
        }
    });
});
//# sourceMappingURL=uncompressed_chunk_format.spec.js.map