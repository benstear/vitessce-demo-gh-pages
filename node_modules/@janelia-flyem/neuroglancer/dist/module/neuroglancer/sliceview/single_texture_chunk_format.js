import _Symbol from 'babel-runtime/core-js/symbol';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { VolumeChunk } from './volume/frontend';
import { RefCounted } from '../util/disposable';
import { textureTargetForSamplerType } from '../webgl/shader';
const textureUnitSymbol = _Symbol('SingleTextureVolumeChunk.textureUnit');
const textureLayoutSymbol = _Symbol('SingleTextureVolumeChunk.textureLayout');
export class SingleTextureChunkFormat extends RefCounted {
    constructor(shaderKey, dataType) {
        super();
        this.shaderKey = shaderKey;
        this.dataType = dataType;
    }
    defineShader(builder, numChannelDimensions) {
        numChannelDimensions;
        builder.addTextureSampler(this.shaderSamplerType, 'uVolumeChunkSampler', textureUnitSymbol);
    }
    beginDrawing(gl, shader) {
        let textureUnit = shader.textureUnit(textureUnitSymbol);
        gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + textureUnit);
        shader[textureLayoutSymbol] = null;
    }
    endDrawing(gl, shader) {
        gl.bindTexture(textureTargetForSamplerType[this.shaderSamplerType], null);
        shader[textureLayoutSymbol] = null;
    }
    bindChunk(gl, shader, chunk, fixedChunkPosition, chunkDisplaySubspaceDimensions, channelDimensions, newSource) {
        let textureLayout = chunk.textureLayout;
        let existingTextureLayout = shader[textureLayoutSymbol];
        if (existingTextureLayout !== textureLayout || newSource) {
            shader[textureLayoutSymbol] = textureLayout;
            this.setupTextureLayout(gl, shader, textureLayout, fixedChunkPosition, chunkDisplaySubspaceDimensions, channelDimensions);
        }
        gl.bindTexture(textureTargetForSamplerType[this.shaderSamplerType], chunk.texture);
    }
    /**
     * Does nothing, but may be overridden by subclass.
     */
    beginSource(_gl, _shader) {}
}
export class SingleTextureVolumeChunk extends VolumeChunk {
    constructor(source, x) {
        super(source, x);
        this.texture = null;
        this.data = x['data'];
    }
    copyToGPU(gl) {
        super.copyToGPU(gl);
        let texture = this.texture = gl.createTexture();
        const textureTarget = textureTargetForSamplerType[this.chunkFormat.shaderSamplerType];
        gl.bindTexture(textureTarget, texture);
        this.setTextureData(gl);
        gl.bindTexture(textureTarget, null);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        gl.deleteTexture(this.texture);
        this.texture = null;
        this.textureLayout.dispose();
        this.textureLayout = null;
    }
}
//# sourceMappingURL=single_texture_chunk_format.js.map