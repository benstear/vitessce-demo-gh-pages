import _Array$from from "babel-runtime/core-js/array/from";
import _slicedToArray from "babel-runtime/helpers/slicedToArray";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import debounce from 'lodash/debounce';
import { ChunkState } from "../chunk_manager/base";
import { Chunk, ChunkSource } from "../chunk_manager/frontend";
import { applyRenderViewportToProjectionMatrix } from "../display_context";
import { updateProjectionParametersFromInverseViewAndProjection } from "../projection_parameters";
import { getChunkDisplayTransformParameters, getChunkTransformParameters, getLayerDisplayDimensionMapping } from "../render_coordinate_transform";
import { DerivedProjectionParameters, SharedProjectionParameters } from "../renderlayer";
import { forEachPlaneIntersectingVolumetricChunk, getNormalizedChunkLayout, SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID, SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID, SLICEVIEW_RPC_ID, SliceViewBase, SliceViewProjectionParameters } from "./base";
import { ChunkLayout } from "./chunk_layout";
import { SliceViewRenderLayer } from "./renderlayer";
import { invokeDisposers, RefCounted } from "../util/disposable";
import { kOneVec, kZeroVec4, mat4, vec3 } from "../util/geom";
import { MessageList, MessageSeverity } from "../util/message_list";
import { getObjectId } from "../util/object_id";
import { NullarySignal } from "../util/signal";
import { withSharedVisibility } from "../visibility_priority/frontend";
import { TextureHistogramGenerator } from "../webgl/empirical_cdf";
import { DepthTextureBuffer, FramebufferConfiguration, makeTextureBuffers } from "../webgl/offscreen";
import { ShaderBuilder } from "../webgl/shader";
import { getSquareCornersBuffer } from "../webgl/square_corners_buffer";
import { registerSharedObjectOwner } from "../worker_rpc";
class FrontendSliceViewBase extends SliceViewBase {}
const Base = withSharedVisibility(FrontendSliceViewBase);
function serializeTransformedSource(tsource) {
    return {
        source: tsource.source.addCounterpartRef(),
        effectiveVoxelSize: tsource.effectiveVoxelSize,
        layerRank: tsource.layerRank,
        nonDisplayLowerClipBound: tsource.nonDisplayLowerClipBound,
        nonDisplayUpperClipBound: tsource.nonDisplayUpperClipBound,
        lowerClipBound: tsource.lowerClipBound,
        upperClipBound: tsource.upperClipBound,
        lowerClipDisplayBound: tsource.lowerClipDisplayBound,
        upperClipDisplayBound: tsource.upperClipDisplayBound,
        chunkDisplayDimensionIndices: tsource.chunkDisplayDimensionIndices,
        lowerChunkDisplayBound: tsource.lowerChunkDisplayBound,
        upperChunkDisplayBound: tsource.upperChunkDisplayBound,
        fixedLayerToChunkTransform: tsource.fixedLayerToChunkTransform,
        combinedGlobalLocalToChunkTransform: tsource.combinedGlobalLocalToChunkTransform,
        chunkLayout: tsource.chunkLayout.toObject()
    };
}
export function serializeAllTransformedSources(allSources) {
    return allSources.map(scales => scales.map(serializeTransformedSource));
}
function disposeTransformedSources(layer, allSources) {
    for (const scales of allSources) {
        for (const _ref of scales) {
            const source = _ref.source;

            layer.removeSource(source);
            source.dispose();
        }
    }
}
let SliceView = class SliceView extends Base {
    constructor(chunkManager, layerManager, navigationState, wireFrame) {
        super(new DerivedProjectionParameters({
            parametersConstructor: SliceViewProjectionParameters,
            navigationState,
            update: (out, navigationState) => {
                const invViewMatrix = out.invViewMatrix,
                      centerDataPosition = out.centerDataPosition;

                navigationState.toMat4(invViewMatrix);
                var _out$displayDimension = out.displayDimensionRenderInfo;
                const canonicalVoxelFactors = _out$displayDimension.canonicalVoxelFactors,
                      voxelPhysicalScales = _out$displayDimension.voxelPhysicalScales;

                for (let i = 0; i < 3; ++i) {
                    centerDataPosition[i] = invViewMatrix[12 + i];
                }
                const logicalWidth = out.logicalWidth,
                      logicalHeight = out.logicalHeight,
                      projectionMat = out.projectionMat,
                      viewportNormalInGlobalCoordinates = out.viewportNormalInGlobalCoordinates,
                      viewportNormalInCanonicalCoordinates = out.viewportNormalInCanonicalCoordinates;
                const relativeDepthRange = navigationState.relativeDepthRange;

                mat4.ortho(projectionMat, -logicalWidth / 2, logicalWidth / 2, logicalHeight / 2, -logicalHeight / 2, -relativeDepthRange, relativeDepthRange);
                applyRenderViewportToProjectionMatrix(out, projectionMat);
                updateProjectionParametersFromInverseViewAndProjection(out);
                const viewMatrix = out.viewMatrix;

                for (let i = 0; i < 3; ++i) {
                    const x = viewportNormalInGlobalCoordinates[i] = viewMatrix[i * 4 + 2];
                    viewportNormalInCanonicalCoordinates[i] = x / canonicalVoxelFactors[i];
                }
                vec3.normalize(viewportNormalInGlobalCoordinates, viewportNormalInGlobalCoordinates);
                vec3.normalize(viewportNormalInCanonicalCoordinates, viewportNormalInCanonicalCoordinates);
                let newPixelSize = 0;
                for (let i = 0; i < 3; ++i) {
                    const s = voxelPhysicalScales[i];
                    const x = invViewMatrix[i];
                    newPixelSize += (s * x) ** 2;
                }
                newPixelSize = Math.sqrt(newPixelSize);
                out.pixelSize = newPixelSize;
            }
        }));
        this.chunkManager = chunkManager;
        this.layerManager = layerManager;
        this.navigationState = navigationState;
        this.wireFrame = wireFrame;
        this.gl = this.chunkManager.gl;
        this.viewChanged = new NullarySignal();
        this.renderingStale = true;
        this.visibleChunksStale = true;
        this.visibleLayerList = new Array();
        this.offscreenFramebuffer = this.registerDisposer(new FramebufferConfiguration(this.gl, {
            colorBuffers: makeTextureBuffers(this.gl, 1),
            depthBuffer: new DepthTextureBuffer(this.gl)
        }));
        this.histogramInputTextures = [];
        this.offscreenFramebuffersWithHistograms = [this.offscreenFramebuffer];
        this.histogramGenerator = TextureHistogramGenerator.get(this.gl);
        this.updateVisibleLayers = this.registerCancellable(debounce(() => {
            this.updateVisibleLayersNow();
        }, 0));
        this.registerDisposer(navigationState);
        this.registerDisposer(this.projectionParameters);
        this.registerDisposer(this.projectionParameters.changed.add((oldValue, newValue) => {
            if (oldValue.displayDimensionRenderInfo !== newValue.displayDimensionRenderInfo) {
                this.updateVisibleLayers();
            }
        }));
        const rpc = this.chunkManager.rpc;
        const sharedProjectionParameters = this.sharedProjectionParameters = this.registerDisposer(new SharedProjectionParameters(rpc, this.projectionParameters));
        this.initializeCounterpart(rpc, {
            chunkManager: chunkManager.rpcId,
            projectionParameters: sharedProjectionParameters.rpcId
        });
        this.registerDisposer(layerManager.layersChanged.add(() => {
            this.updateVisibleLayers();
        }));
        this.wireFrame.changed.add(this.viewChanged.dispatch);
        this.viewChanged.add(() => {
            this.renderingStale = true;
        });
        this.registerDisposer(chunkManager.chunkQueueManager.visibleChunksChanged.add(this.viewChanged.dispatch));
        this.updateVisibleLayers();
    }
    get displayDimensionRenderInfo() {
        return this.navigationState.displayDimensionRenderInfo;
    }
    computeHistograms(count, histogramSpecifications) {
        this.histogramGenerator.compute(count, this.offscreenFramebuffer.depthBuffer.texture, this.histogramInputTextures, histogramSpecifications, this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
    }
    flushBackendProjectionParameters() {
        this.sharedProjectionParameters.flush();
    }
    forEachVisibleChunk(tsource, chunkLayout, callback) {
        forEachPlaneIntersectingVolumetricChunk(this.projectionParameters.value, tsource.renderLayer.localPosition.value, tsource, chunkLayout, () => {
            callback(tsource.curPositionInChunks.join());
        });
    }
    isReady() {
        if (!this.navigationState.valid) {
            return false;
        }
        this.updateVisibleLayers.flush();
        this.updateVisibleSources();
        let numValidChunks = 0;
        let totalChunks = 0;
        for (const _ref2 of this.visibleLayers.values()) {
            const visibleSources = _ref2.visibleSources;

            for (const tsource of visibleSources) {
                const chunkLayout = getNormalizedChunkLayout(this.projectionParameters.value, tsource.chunkLayout);
                const source = tsource.source;
                const chunks = source.chunks;

                this.forEachVisibleChunk(tsource, chunkLayout, key => {
                    const chunk = chunks.get(key);
                    ++totalChunks;
                    if (chunk && chunk.state === ChunkState.GPU_MEMORY) {
                        ++numValidChunks;
                    }
                });
            }
        }
        return numValidChunks === totalChunks;
    }
    invalidateVisibleSources() {
        super.invalidateVisibleSources();
        this.viewChanged.dispatch();
    }
    bindVisibleRenderLayer(renderLayer, disposers) {
        disposers.push(renderLayer.localPosition.changed.add(() => this.invalidateVisibleChunks()));
        disposers.push(renderLayer.redrawNeeded.add(this.viewChanged.dispatch));
        disposers.push(renderLayer.transform.changed.add(this.updateVisibleLayers));
        disposers.push(renderLayer.renderScaleTarget.changed.add(() => this.invalidateVisibleSources()));
        const renderScaleHistogram = renderLayer.renderScaleHistogram;

        if (renderScaleHistogram !== undefined) {
            disposers.push(renderScaleHistogram.visibility.add(this.visibility));
        }
        disposers.push(renderLayer.dataHistogramSpecifications.producerVisibility.add(this.visibility));
    }
    updateVisibleLayersNow() {
        if (this.wasDisposed) {
            return false;
        }
        if (!this.navigationState.valid) return false;
        // Used to determine which layers are no longer visible.
        const curUpdateGeneration = Date.now();
        const visibleLayers = this.visibleLayers,
              visibleLayerList = this.visibleLayerList;
        const displayDimensionRenderInfo = this.projectionParameters.value.displayDimensionRenderInfo;

        let rpc = this.rpc;
        let rpcMessage = { 'id': this.rpcId };
        let changed = false;
        visibleLayerList.length = 0;
        for (let renderLayer of this.layerManager.readyRenderLayers()) {
            if (renderLayer instanceof SliceViewRenderLayer) {
                visibleLayerList.push(renderLayer);
                let layerInfo = visibleLayers.get(renderLayer);
                if (layerInfo === undefined) {
                    const disposers = [];
                    const messages = new MessageList();
                    layerInfo = {
                        messages,
                        allSources: this.getTransformedSources(renderLayer, messages),
                        transformGeneration: renderLayer.transform.changed.count,
                        visibleSources: [],
                        disposers,
                        lastSeenGeneration: curUpdateGeneration,
                        displayDimensionRenderInfo
                    };
                    disposers.push(renderLayer.messages.addChild(layerInfo.messages));
                    visibleLayers.set(renderLayer.addRef(), layerInfo);
                    this.bindVisibleRenderLayer(renderLayer, disposers);
                } else {
                    layerInfo.lastSeenGeneration = curUpdateGeneration;
                    const curTransformGeneration = renderLayer.transform.changed.count;
                    if (layerInfo.transformGeneration === curTransformGeneration && layerInfo.displayDimensionRenderInfo === displayDimensionRenderInfo) {
                        continue;
                    }
                    const allSources = layerInfo.allSources;
                    layerInfo.allSources = this.getTransformedSources(renderLayer, layerInfo.messages);
                    disposeTransformedSources(renderLayer, allSources);
                    layerInfo.visibleSources.length = 0;
                    layerInfo.displayDimensionRenderInfo = displayDimensionRenderInfo;
                    layerInfo.transformGeneration = curTransformGeneration;
                }
                rpcMessage['layerId'] = renderLayer.rpcId;
                rpcMessage['sources'] = serializeAllTransformedSources(layerInfo.allSources);
                this.flushBackendProjectionParameters();
                rpc.invoke(SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID, rpcMessage);
                changed = true;
            }
        }
        for (const _ref3 of visibleLayers) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const renderLayer = _ref4[0];
            const layerInfo = _ref4[1];

            if (layerInfo.lastSeenGeneration === curUpdateGeneration) continue;
            rpcMessage['layerId'] = renderLayer.rpcId;
            rpc.invoke(SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID, rpcMessage);
            visibleLayers.delete(renderLayer);
            disposeTransformedSources(renderLayer, layerInfo.allSources);
            invokeDisposers(layerInfo.disposers);
            renderLayer.dispose();
            changed = true;
        }
        if (changed) {
            this.visibleSourcesStale = true;
        }
        // Unconditionally call viewChanged, because layers may have been reordered even if the set of
        // sources is the same.
        this.viewChanged.dispatch();
        return changed;
    }
    invalidateVisibleChunks() {
        super.invalidateVisibleChunks();
        this.viewChanged.dispatch();
    }
    get valid() {
        return this.navigationState.valid;
    }
    getOffscreenFramebufferWithHistograms(count) {
        const offscreenFramebuffersWithHistograms = this.offscreenFramebuffersWithHistograms;

        let framebuffer = offscreenFramebuffersWithHistograms[count];
        if (framebuffer === undefined) {
            const gl = this.gl,
                  histogramInputTextures = this.histogramInputTextures,
                  offscreenFramebuffer = this.offscreenFramebuffer;

            if (histogramInputTextures.length < count) {
                histogramInputTextures.push(...makeTextureBuffers(gl, count - histogramInputTextures.length, WebGL2RenderingContext.R8, WebGL2RenderingContext.RED));
            }
            let colorBuffers = [offscreenFramebuffer.colorBuffers[0].addRef()];
            for (let i = 0; i < count; ++i) {
                colorBuffers.push(histogramInputTextures[i].addRef());
            }
            framebuffer = this.registerDisposer(new FramebufferConfiguration(gl, { colorBuffers, depthBuffer: offscreenFramebuffer.depthBuffer.addRef() }));
            offscreenFramebuffersWithHistograms[count] = framebuffer;
        }
        return framebuffer;
    }
    updateRendering() {
        const projectionParameters = this.projectionParameters.value;
        const width = projectionParameters.width,
              height = projectionParameters.height;

        if (!this.renderingStale || !this.valid || width === 0 || height === 0) {
            return;
        }
        this.renderingStale = false;
        this.updateVisibleLayers.flush();
        this.updateVisibleSources();
        let gl = this.gl,
            offscreenFramebuffer = this.offscreenFramebuffer;

        offscreenFramebuffer.bind(width, height);
        gl.disable(gl.SCISSOR_TEST);
        gl.clearColor(0, 0, 0, 0);
        gl.colorMask(true, true, true, true);
        gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
        let renderLayerNum = 0;
        const wireFrame = this.wireFrame.value;
        const renderContext = { sliceView: this, projectionParameters, wireFrame };
        for (let renderLayer of this.visibleLayerList) {
            const histogramCount = wireFrame ? 0 : renderLayer.getDataHistogramCount();
            let framebuffer = this.getOffscreenFramebufferWithHistograms(histogramCount);
            framebuffer.bind(width, height);
            for (let i = 0; i < histogramCount; ++i) {
                gl.clearBufferfv(WebGL2RenderingContext.COLOR, 1 + i, kZeroVec4);
            }
            gl.enable(WebGL2RenderingContext.DEPTH_TEST);
            gl.depthFunc(WebGL2RenderingContext.LESS);
            gl.clearDepth(1);
            gl.clear(WebGL2RenderingContext.DEPTH_BUFFER_BIT);
            renderLayer.setGLBlendMode(gl, renderLayerNum);
            renderLayer.draw(renderContext);
            ++renderLayerNum;
        }
        gl.disable(WebGL2RenderingContext.BLEND);
        gl.disable(WebGL2RenderingContext.DEPTH_TEST);
        offscreenFramebuffer.unbind();
    }
    disposed() {
        for (const _ref5 of this.visibleLayers) {
            var _ref6 = _slicedToArray(_ref5, 2);

            const renderLayer = _ref6[0];
            const layerInfo = _ref6[1];

            disposeTransformedSources(renderLayer, layerInfo.allSources);
            invokeDisposers(layerInfo.disposers);
            renderLayer.dispose();
        }
        this.visibleLayers.clear();
        this.visibleLayerList.length = 0;
    }
    getTransformedSources(layer, messages) {
        const transformedSources = getVolumetricTransformedSources(this.projectionParameters.value.displayDimensionRenderInfo, layer.transform.value, options => layer.getSources(options), messages, layer);
        for (const scales of transformedSources) {
            for (const tsource of scales) {
                layer.addSource(tsource.source, tsource.chunkTransform);
            }
        }
        return transformedSources;
    }
};
SliceView = __decorate([registerSharedObjectOwner(SLICEVIEW_RPC_ID)], SliceView);
export { SliceView };
export class SliceViewChunkSource extends ChunkSource {
    constructor(chunkManager, options) {
        super(chunkManager, options);
        this.spec = options.spec;
    }
    static encodeSpec(spec) {
        return {
            chunkDataSize: _Array$from(spec.chunkDataSize),
            lowerVoxelBound: _Array$from(spec.lowerVoxelBound),
            upperVoxelBound: _Array$from(spec.upperVoxelBound)
        };
    }
    static encodeOptions(options) {
        const encoding = super.encodeOptions(options);
        encoding.spec = this.encodeSpec(options.spec);
        return encoding;
    }
    initializeCounterpart(rpc, options) {
        options['spec'] = this.spec;
        super.initializeCounterpart(rpc, options);
    }
}
export class SliceViewChunk extends Chunk {
    constructor(source, x) {
        super(source);
        this.chunkGridPosition = x['chunkGridPosition'];
        this.state = ChunkState.SYSTEM_MEMORY;
    }
}
/**
 * Helper for rendering a SliceView that has been pre-rendered to a texture.
 */
export class SliceViewRenderHelper extends RefCounted {
    constructor(gl, emitter) {
        super();
        this.gl = gl;
        this.copyVertexPositionsBuffer = getSquareCornersBuffer(this.gl);
        this.textureCoordinateAdjustment = new Float32Array(4);
        let builder = new ShaderBuilder(gl);
        builder.addVarying('vec2', 'vTexCoord');
        builder.addUniform('sampler2D', 'uSampler');
        builder.addInitializer(shader => {
            gl.uniform1i(shader.uniform('uSampler'), 0);
        });
        builder.addUniform('vec4', 'uColorFactor');
        builder.addUniform('vec4', 'uBackgroundColor');
        builder.addUniform('mat4', 'uProjectionMatrix');
        builder.addUniform('vec4', 'uTextureCoordinateAdjustment');
        builder.require(emitter);
        builder.setFragmentMain(`
vec4 sampledColor = texture(uSampler, vTexCoord);
if (sampledColor.a == 0.0) {
  sampledColor = uBackgroundColor;
}
emit(sampledColor * uColorFactor, 0u);
`);
        builder.addAttribute('vec4', 'aVertexPosition');
        builder.setVertexMain(`
vTexCoord = uTextureCoordinateAdjustment.xy + 0.5 * (aVertexPosition.xy + 1.0) * uTextureCoordinateAdjustment.zw;
gl_Position = uProjectionMatrix * aVertexPosition;
`);
        this.shader = this.registerDisposer(builder.build());
    }
    draw(texture, projectionMatrix, colorFactor, backgroundColor, xStart, yStart, xEnd, yEnd) {
        let gl = this.gl,
            shader = this.shader,
            textureCoordinateAdjustment = this.textureCoordinateAdjustment;

        textureCoordinateAdjustment[0] = xStart;
        textureCoordinateAdjustment[1] = yStart;
        textureCoordinateAdjustment[2] = xEnd - xStart;
        textureCoordinateAdjustment[3] = yEnd - yStart;
        shader.bind();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.disable(WebGL2RenderingContext.BLEND);
        gl.uniformMatrix4fv(shader.uniform('uProjectionMatrix'), false, projectionMatrix);
        gl.uniform4fv(shader.uniform('uColorFactor'), colorFactor);
        gl.uniform4fv(shader.uniform('uBackgroundColor'), backgroundColor);
        gl.uniform4fv(shader.uniform('uTextureCoordinateAdjustment'), textureCoordinateAdjustment);
        let aVertexPosition = shader.attribute('aVertexPosition');
        this.copyVertexPositionsBuffer.bindToVertexAttrib(aVertexPosition, /*components=*/2);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        gl.disableVertexAttribArray(aVertexPosition);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    static get(gl, emitter) {
        return gl.memoize.get(`sliceview/SliceViewRenderHelper:${getObjectId(emitter)}`, () => new SliceViewRenderHelper(gl, emitter));
    }
}
export class MultiscaleSliceViewChunkSource {
    constructor(chunkManager) {
        this.chunkManager = chunkManager;
    }
}
export function getVolumetricTransformedSources(displayDimensionRenderInfo, transform, getSources, messages, layer) {
    messages.clearMessages();
    const returnError = message => {
        messages.addMessage({
            severity: MessageSeverity.error,
            message
        });
        return [];
    };
    if (transform.error !== undefined) {
        return returnError(transform.error);
    }
    const layerRank = transform.rank;
    const chunkRank = transform.unpaddedRank;
    const displayDimensionIndices = displayDimensionRenderInfo.displayDimensionIndices,
          displayRank = displayDimensionRenderInfo.displayRank,
          canonicalVoxelFactors = displayDimensionRenderInfo.canonicalVoxelFactors;

    const layerDisplayDimensionMapping = getLayerDisplayDimensionMapping(transform, displayDimensionIndices);
    const displayToLayerDimensionIndices = layerDisplayDimensionMapping.displayToLayerDimensionIndices;

    const multiscaleToViewTransform = new Float32Array(displayRank * chunkRank);
    const modelToRenderLayerTransform = transform.modelToRenderLayerTransform;

    for (let displayDim = 0; displayDim < displayRank; ++displayDim) {
        const layerDim = displayToLayerDimensionIndices[displayDim];
        if (layerDim === -1) continue;
        const factor = canonicalVoxelFactors[displayDim];
        for (let chunkDim = 0; chunkDim < chunkRank; ++chunkDim) {
            multiscaleToViewTransform[displayRank * chunkDim + displayDim] = modelToRenderLayerTransform[(layerRank + 1) * chunkDim + layerDim] * factor;
        }
    }
    const allSources = getSources({
        displayRank: displayRank,
        multiscaleToViewTransform: multiscaleToViewTransform,
        modelChannelDimensionIndices: transform.channelToRenderLayerDimensions
    });
    const globalScales = displayDimensionRenderInfo.voxelPhysicalScales;

    try {
        const getTransformedSource = singleResolutionSource => {
            const source = singleResolutionSource.chunkSource;
            const spec = source.spec;
            var _singleResolutionSour = singleResolutionSource.lowerClipBound;
            const lowerClipBound = _singleResolutionSour === undefined ? spec.lowerVoxelBound : _singleResolutionSour;
            var _singleResolutionSour2 = singleResolutionSource.upperClipBound;
            const upperClipBound = _singleResolutionSour2 === undefined ? spec.upperVoxelBound : _singleResolutionSour2;

            const chunkTransform = getChunkTransformParameters(transform, singleResolutionSource.chunkToMultiscaleTransform);
            const chunkDataSize = spec.chunkDataSize;
            const channelToChunkDimensionIndices = chunkTransform.channelToChunkDimensionIndices;

            const nonDisplayLowerClipBound = new Float32Array(chunkRank);
            const nonDisplayUpperClipBound = new Float32Array(chunkRank);
            nonDisplayLowerClipBound.set(lowerClipBound);
            nonDisplayUpperClipBound.set(upperClipBound);
            const channelRank = channelToChunkDimensionIndices.length;
            const channelSpaceShape = transform.channelSpaceShape;

            for (let channelDim = 0; channelDim < channelRank; ++channelDim) {
                const chunkDim = channelToChunkDimensionIndices[channelDim];
                if (chunkDim === -1) continue;
                const size = channelSpaceShape[channelDim];
                if (chunkDataSize[chunkDim] !== size) {
                    throw new Error(`Channel dimension ` + transform.layerDimensionNames[transform.channelToRenderLayerDimensions[channelDim]] + ` has extent ${size} but corresponding chunk dimension has extent ` + `${chunkDataSize[chunkDim]}`);
                }
                nonDisplayLowerClipBound[chunkDim] = Number.NEGATIVE_INFINITY;
                nonDisplayUpperClipBound[chunkDim] = Number.POSITIVE_INFINITY;
            }
            const chunkDisplayTransform = getChunkDisplayTransformParameters(chunkTransform, layerDisplayDimensionMapping);
            // Compute `chunkDisplaySize`, and `{lower,upper}ChunkDisplayBound`.
            const lowerChunkDisplayBound = vec3.create();
            const upperChunkDisplayBound = vec3.create();
            const lowerClipDisplayBound = vec3.create();
            const upperClipDisplayBound = vec3.create();
            // Size of chunk in "display" coordinate space.
            const chunkDisplaySize = vec3.create();
            const numChunkDisplayDims = chunkDisplayTransform.numChunkDisplayDims,
                  chunkDisplayDimensionIndices = chunkDisplayTransform.chunkDisplayDimensionIndices;
            const combinedGlobalLocalToChunkTransform = chunkTransform.combinedGlobalLocalToChunkTransform,
                  layerRank = chunkTransform.layerRank,
                  combinedGlobalLocalRank = chunkTransform.combinedGlobalLocalRank;

            const fixedLayerToChunkTransform = new Float32Array(combinedGlobalLocalToChunkTransform);
            for (let chunkDisplayDimIndex = 0; chunkDisplayDimIndex < numChunkDisplayDims; ++chunkDisplayDimIndex) {
                const chunkDim = chunkDisplayDimensionIndices[chunkDisplayDimIndex];
                for (let i = 0; i <= combinedGlobalLocalRank; ++i) {
                    fixedLayerToChunkTransform[chunkDim + i * layerRank] = 0;
                }
                if (chunkDim < chunkRank) {
                    chunkDisplaySize[chunkDisplayDimIndex] = spec.chunkDataSize[chunkDim];
                    lowerChunkDisplayBound[chunkDisplayDimIndex] = spec.lowerChunkBound[chunkDim];
                    upperChunkDisplayBound[chunkDisplayDimIndex] = spec.upperChunkBound[chunkDim];
                    lowerClipDisplayBound[chunkDisplayDimIndex] = lowerClipBound[chunkDim];
                    upperClipDisplayBound[chunkDisplayDimIndex] = upperClipBound[chunkDim];
                    nonDisplayLowerClipBound[chunkDim] = Number.NEGATIVE_INFINITY;
                    nonDisplayUpperClipBound[chunkDim] = Number.POSITIVE_INFINITY;
                } else {
                    chunkDisplaySize[chunkDisplayDimIndex] = 1;
                    lowerChunkDisplayBound[chunkDisplayDimIndex] = 0;
                    upperChunkDisplayBound[chunkDisplayDimIndex] = 1;
                    lowerClipDisplayBound[chunkDisplayDimIndex] = 0;
                    upperClipDisplayBound[chunkDisplayDimIndex] = 1;
                }
            }
            chunkDisplaySize.fill(1, numChunkDisplayDims);
            lowerChunkDisplayBound.fill(0, numChunkDisplayDims);
            upperChunkDisplayBound.fill(1, numChunkDisplayDims);
            lowerClipDisplayBound.fill(0, numChunkDisplayDims);
            upperClipDisplayBound.fill(1, numChunkDisplayDims);
            const chunkLayout = new ChunkLayout(chunkDisplaySize, chunkDisplayTransform.displaySubspaceModelMatrix, numChunkDisplayDims);
            // This is an approximation of the voxel size (exact only for permutation/scaling
            // transforms).  It would be better to model the voxel as an ellipsiod and find the
            // lengths of the axes.
            const effectiveVoxelSize = chunkLayout.localSpatialVectorToGlobal(vec3.create(), /*baseVoxelSize=*/kOneVec);
            for (let i = 0; i < displayRank; ++i) {
                effectiveVoxelSize[i] = Math.abs(effectiveVoxelSize[i] * globalScales[i]);
            }
            effectiveVoxelSize.fill(1, displayRank);
            return {
                layerRank,
                lowerClipBound,
                upperClipBound,
                nonDisplayLowerClipBound,
                nonDisplayUpperClipBound,
                renderLayer: layer,
                source,
                lowerChunkDisplayBound,
                upperChunkDisplayBound,
                lowerClipDisplayBound,
                upperClipDisplayBound,
                effectiveVoxelSize,
                chunkLayout,
                chunkDisplayDimensionIndices,
                fixedLayerToChunkTransform,
                curPositionInChunks: new Float32Array(chunkRank),
                combinedGlobalLocalToChunkTransform: chunkTransform.combinedGlobalLocalToChunkTransform,
                fixedPositionWithinChunk: new Uint32Array(chunkRank),
                chunkTransform,
                chunkDisplayTransform
            };
        };
        return allSources.map(scales => scales.map(s => getTransformedSource(s)));
    } catch (e) {
        // Ensure references are released in the case of an exception.
        for (const scales of allSources) {
            for (const _ref7 of scales) {
                const source = _ref7.chunkSource;

                source.dispose();
            }
        }
        const globalDimensionNames = displayDimensionRenderInfo.globalDimensionNames;

        const dimensionDesc = _Array$from(displayDimensionRenderInfo.displayDimensionIndices.filter(i => i !== -1), i => globalDimensionNames[i]).join(',\u00a0');
        const message = `Cannot render (${dimensionDesc}) cross section: ${e.message}`;
        return returnError(message);
    }
}
//# sourceMappingURL=frontend.js.map