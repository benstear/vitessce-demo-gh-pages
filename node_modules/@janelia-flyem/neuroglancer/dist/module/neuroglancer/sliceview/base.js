import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Math$log from 'babel-runtime/core-js/math/log2';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ProjectionParameters } from '../projection_parameters';
import { getChunkPositionFromCombinedGlobalLocalPositions } from '../render_coordinate_transform';
import { ChunkLayout } from './chunk_layout';
import { DATA_TYPE_BYTES, DataType } from '../util/data_type';
import { getFrustrumPlanes, getViewFrustrumDepthRange, isAABBIntersectingPlane, isAABBVisible, mat4, vec3 } from '../util/geom';
import * as matrix from '../util/matrix';
import * as vector from '../util/vector';
import { SharedObject } from '../worker_rpc';
export { DATA_TYPE_BYTES, DataType };
const DEBUG_VISIBLE_SOURCES = false;
const DEBUG_CHUNK_VISIBILITY = false;
const tempMat4 = mat4.create();
/**
 * Average cross-sectional area contained within a chunk of the specified size and rotation.
 *
 * This is estimated by taking the total volume of the chunk and dividing it by the total length of
 * the chunk along the z axis.
 */
export function estimateSliceAreaPerChunk(chunkLayout, viewMatrix) {
    // Compute the length of the projection of the chunk along the z axis in view space.
    //
    // Each chunk dimension `i` can independently affect the z projection by the dot product of column
    // `i` of `chunkLayout.transform` and row 2 of `viewMatrix`.
    let viewZProjection = 0;
    let chunkVolume = Math.abs(chunkLayout.detTransform);
    const transform = chunkLayout.transform,
          size = chunkLayout.size;

    for (let i = 0; i < 3; ++i) {
        let sum = 0;
        for (let j = 0; j < 3; ++j) {
            sum += viewMatrix[j * 4 + 2] * transform[4 * i + j];
        }
        const s = size[i];
        viewZProjection += Math.abs(sum) * s;
        chunkVolume *= s;
    }
    return chunkVolume / viewZProjection;
}
function updateFixedCurPositionInChunks(tsource, globalPosition, localPosition) {
    const curPositionInChunks = tsource.curPositionInChunks,
          fixedPositionWithinChunk = tsource.fixedPositionWithinChunk;
    const nonDisplayLowerClipBound = tsource.nonDisplayLowerClipBound,
          nonDisplayUpperClipBound = tsource.nonDisplayUpperClipBound;
    var _tsource$source$spec = tsource.source.spec;
    const rank = _tsource$source$spec.rank,
          chunkDataSize = _tsource$source$spec.chunkDataSize;

    if (!getChunkPositionFromCombinedGlobalLocalPositions(curPositionInChunks, globalPosition, localPosition, tsource.layerRank, tsource.fixedLayerToChunkTransform)) {
        return false;
    }
    for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
        const x = curPositionInChunks[chunkDim];
        if (x < nonDisplayLowerClipBound[chunkDim] || x >= nonDisplayUpperClipBound[chunkDim]) {
            if (DEBUG_VISIBLE_SOURCES) {
                console.log('excluding source', tsource, `because of chunkDim=${chunkDim}, sum=${x}`, nonDisplayLowerClipBound, nonDisplayUpperClipBound, tsource.fixedLayerToChunkTransform);
            }
            return false;
        }
        const chunkSize = chunkDataSize[chunkDim];
        const chunk = curPositionInChunks[chunkDim] = Math.floor(x / chunkSize);
        fixedPositionWithinChunk[chunkDim] = x - chunk * chunkSize;
    }
    return true;
}
function pickBestAlternativeSource(viewMatrix, alternatives) {
    let numAlternatives = alternatives.length;
    let bestAlternativeIndex = 0;
    if (DEBUG_VISIBLE_SOURCES) {
        console.log(alternatives);
    }
    if (numAlternatives > 1) {
        let bestSliceArea = 0;
        for (let alternativeIndex = 0; alternativeIndex < numAlternatives; ++alternativeIndex) {
            let alternative = alternatives[alternativeIndex];
            const chunkLayout = alternative.chunkLayout;

            let sliceArea = estimateSliceAreaPerChunk(chunkLayout, viewMatrix);
            if (DEBUG_VISIBLE_SOURCES) {
                console.log(`chunksize = ${chunkLayout.size}, sliceArea = ${sliceArea}`);
            }
            if (sliceArea > bestSliceArea) {
                bestSliceArea = sliceArea;
                bestAlternativeIndex = alternativeIndex;
            }
        }
    }
    return bestAlternativeIndex;
}
const tempChunkLayout = new ChunkLayout(vec3.create(), mat4.create(), 0);
export class SliceViewProjectionParameters extends ProjectionParameters {
    constructor() {
        super(...arguments);
        /**
         * Normal vector of cross section in (non-isotropic) global voxel coordinates.
         */
        this.viewportNormalInGlobalCoordinates = vec3.create();
        /**
         * Normal vector of cross section in isotropic global canonical voxel coordinates.
         */
        this.viewportNormalInCanonicalCoordinates = vec3.create();
        this.centerDataPosition = vec3.create();
        /**
         * Size in physical units of a single pixel.
         */
        this.pixelSize = 0;
    }
}
function visibleSourcesInvalidated(oldValue, newValue) {
    if (oldValue.displayDimensionRenderInfo !== newValue.displayDimensionRenderInfo) return true;
    if (oldValue.pixelSize !== newValue.pixelSize) return true;
    const oldViewMatrix = oldValue.viewMatrix;
    const newViewMatrix = newValue.viewMatrix;

    for (let i = 0; i < 12; ++i) {
        if (oldViewMatrix[i] !== newViewMatrix[i]) return true;
    }
    return false;
}
export class SliceViewBase extends SharedObject {
    constructor(projectionParameters) {
        super();
        this.projectionParameters = projectionParameters;
        this.visibleLayers = new _Map();
        this.visibleSourcesStale = true;
        this.registerDisposer(projectionParameters.changed.add((oldValue, newValue) => {
            if (visibleSourcesInvalidated(oldValue, newValue)) {
                this.invalidateVisibleSources();
            }
            this.invalidateVisibleChunks();
        }));
    }
    invalidateVisibleSources() {
        this.visibleSourcesStale = true;
    }
    invalidateVisibleChunks() {}
    /**
     * Computes the list of sources to use for each visible layer, based on the
     * current pixelSize.
     */
    updateVisibleSources() {
        if (!this.visibleSourcesStale) {
            return;
        }
        this.visibleSourcesStale = false;
        const curDisplayDimensionRenderInfo = this.projectionParameters.value.displayDimensionRenderInfo;
        const visibleLayers = this.visibleLayers;

        for (const _ref of visibleLayers) {
            var _ref2 = _slicedToArray(_ref, 2);

            const renderLayer = _ref2[0];
            var _ref2$ = _ref2[1];
            const allSources = _ref2$.allSources;
            const visibleSources = _ref2$.visibleSources;
            const displayDimensionRenderInfo = _ref2$.displayDimensionRenderInfo;

            visibleSources.length = 0;
            if (displayDimensionRenderInfo !== curDisplayDimensionRenderInfo || allSources.length === 0) {
                continue;
            }
            const preferredOrientationIndex = pickBestAlternativeSource(this.projectionParameters.value.viewMatrix, allSources.map(x => x[0]));
            const sources = allSources[preferredOrientationIndex];
            for (const source of renderLayer.filterVisibleSources(this, sources)) {
                visibleSources.push(source);
            }
            // Reverse visibleSources list since we added sources from coarsest to finest resolution, but
            // we want them ordered from finest to coarsest.
            visibleSources.reverse();
            if (DEBUG_VISIBLE_SOURCES) {
                console.log('visible sources chosen', visibleSources);
            }
        }
    }
}
/**
 * By default, choose a chunk size with at most 2^18 = 262144 voxels.
 */
export const DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 = 18;
/**
 * Determines a near-isotropic (in camera view space) block size.  All dimensions will be
 * powers of 2, and will not exceed upperVoxelBound - lowerVoxelBound.  The total number of voxels
 * will not exceed maxVoxelsPerChunkLog2.
 */
export function getNearIsotropicBlockSize(options) {
    let rank = options.rank,
        upperVoxelBound = options.upperVoxelBound;
    var _options$maxVoxelsPer = options.maxVoxelsPerChunkLog2;
    let maxVoxelsPerChunkLog2 = _options$maxVoxelsPer === undefined ? DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 : _options$maxVoxelsPer,
        chunkToViewTransform = options.chunkToViewTransform,
        displayRank = options.displayRank,
        minBlockSize = options.minBlockSize,
        maxBlockSize = options.maxBlockSize;
    var _options$lowerVoxelBo = options.lowerVoxelBound;
    const lowerVoxelBound = _options$lowerVoxelBo === undefined ? new Uint32Array(rank) : _options$lowerVoxelBo;
    // Adjust voxelSize by effective scaling factor.

    const effectiveVoxelSize = new Float32Array(rank);
    for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
        let factor = 0;
        for (let displayDim = 0; displayDim < displayRank; ++displayDim) {
            const c = chunkToViewTransform[chunkDim * displayRank + displayDim];
            factor += c * c;
        }
        effectiveVoxelSize[chunkDim] = Math.sqrt(factor);
    }
    const chunkDataSize = new Uint32Array(rank);
    if (minBlockSize !== undefined) {
        chunkDataSize.set(minBlockSize);
    } else {
        chunkDataSize.fill(1);
    }
    const chunkDataSizeUpperBound = new Array(rank);
    for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
        let bound = Number.POSITIVE_INFINITY;
        if (effectiveVoxelSize[chunkDim] === 0) {
            bound = chunkDataSize[chunkDim];
        } else {
            if (upperVoxelBound !== undefined) {
                bound = Math.pow(2, Math.floor(_Math$log(upperVoxelBound[chunkDim] - lowerVoxelBound[chunkDim])));
            }
            if (maxBlockSize !== undefined) {
                bound = Math.min(bound, maxBlockSize[chunkDim]);
            }
        }
        chunkDataSizeUpperBound[chunkDim] = bound;
    }
    // Determine the dimension in which chunkDataSize should be increased.  This is the smallest
    // dimension (in nanometers) that is < maxChunkDataSize (in voxels).
    //
    // Returns -1 if there is no such dimension.
    function findNextDimension() {
        let minSize = Infinity;
        let minDimension = -1;
        for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
            if (chunkDataSize[chunkDim] >= chunkDataSizeUpperBound[chunkDim]) {
                continue;
            }
            let size = chunkDataSize[chunkDim] * effectiveVoxelSize[chunkDim];
            if (size < minSize) {
                minSize = size;
                minDimension = chunkDim;
            }
        }
        return minDimension;
    }
    maxVoxelsPerChunkLog2 -= _Math$log(vector.prod(chunkDataSize));
    for (let i = 0; i < maxVoxelsPerChunkLog2; ++i) {
        let nextDim = findNextDimension();
        if (nextDim === -1) {
            break;
        }
        chunkDataSize[nextDim] *= 2;
    }
    return chunkDataSize;
}
/**
 * Returns an array of [xy, yz, xz] 2-dimensional block sizes, where [x, y, z] refer to the view
 * dimensions.
 */
export function getTwoDimensionalBlockSizes(options) {
    const chunkDataSizes = [];
    const displayRank = options.displayRank,
          chunkToViewTransform = options.chunkToViewTransform,
          rank = options.rank;

    if (displayRank > 3) {
        throw new Error('Unsupported view transform');
    }
    if (displayRank < 3) {
        return [getNearIsotropicBlockSize(options)];
    }
    for (let i = 0; i < 3; ++i) {
        const excludedDim = (i + 2) % 3;
        const restrictedTransform = new Float32Array(chunkToViewTransform);
        for (let j = 0; j < rank; ++j) {
            restrictedTransform[j * displayRank + excludedDim] = 0;
        }
        chunkDataSizes[i] = getNearIsotropicBlockSize(_Object$assign(_Object$assign({}, options), { chunkToViewTransform: restrictedTransform }));
    }
    return chunkDataSizes;
}
export var ChunkLayoutPreference;
(function (ChunkLayoutPreference) {
    /**
     * Indicates that isotropic chunks are desired.
     */
    ChunkLayoutPreference[ChunkLayoutPreference["ISOTROPIC"] = 0] = "ISOTROPIC";
    /**
     * Indicates that 2-D chunks are desired.
     */
    ChunkLayoutPreference[ChunkLayoutPreference["FLAT"] = 1] = "FLAT";
})(ChunkLayoutPreference || (ChunkLayoutPreference = {}));
export function getCombinedTransform(rank, bToC, aToB) {
    if (aToB === undefined) {
        return bToC;
    } else {
        return matrix.multiply(new Float32Array((rank + 1) * (rank + 1)), rank + 1, bToC, rank + 1, aToB, rank + 1, rank + 1, rank + 1, rank + 1);
    }
}
export function getChunkDataSizes(options) {
    if (options.chunkDataSizes !== undefined) {
        return options.chunkDataSizes;
    }
    var _options$chunkLayoutP = options.chunkLayoutPreference;
    const chunkLayoutPreference = _options$chunkLayoutP === undefined ? ChunkLayoutPreference.ISOTROPIC : _options$chunkLayoutP;

    switch (chunkLayoutPreference) {
        case ChunkLayoutPreference.ISOTROPIC:
            return [getNearIsotropicBlockSize(options)];
        case ChunkLayoutPreference.FLAT:
            return getTwoDimensionalBlockSizes(options);
    }
}
export function makeSliceViewChunkSpecification(options) {
    const rank = options.rank,
          chunkDataSize = options.chunkDataSize,
          upperVoxelBound = options.upperVoxelBound;
    var _options$lowerVoxelBo2 = options.lowerVoxelBound;
    const lowerVoxelBound = _options$lowerVoxelBo2 === undefined ? new Float32Array(rank) : _options$lowerVoxelBo2;

    const lowerChunkBound = new Float32Array(rank);
    const upperChunkBound = new Float32Array(rank);
    for (let i = 0; i < rank; ++i) {
        lowerChunkBound[i] = Math.floor(lowerVoxelBound[i] / chunkDataSize[i]);
        upperChunkBound[i] = Math.floor((upperVoxelBound[i] - 1) / chunkDataSize[i] + 1);
    }
    return {
        rank,
        chunkDataSize,
        lowerChunkBound,
        upperChunkBound,
        lowerVoxelBound,
        upperVoxelBound
    };
}
export function* filterVisibleSources(sliceView, renderLayer, sources) {
    // Increase pixel size by a small margin.
    const pixelSize = sliceView.projectionParameters.value.pixelSize * 1.1;
    // At the smallest scale, all alternative sources must have the same voxel size, which is
    // considered to be the base voxel size.
    const smallestVoxelSize = sources[0].effectiveVoxelSize;
    const renderScaleTarget = renderLayer.renderScaleTarget.value;
    /**
     * Determines whether we should continue to look for a finer-resolution source *after* one
     * with the specified voxelSize.
     */
    const canImproveOnVoxelSize = voxelSize => {
        const targetSize = pixelSize * renderScaleTarget;
        for (let i = 0; i < 3; ++i) {
            const size = voxelSize[i];
            // If size <= pixelSize, no need for improvement.
            // If size === smallestVoxelSize, also no need for improvement.
            if (size > targetSize && size > 1.01 * smallestVoxelSize[i]) {
                return true;
            }
        }
        return false;
    };
    const improvesOnPrevVoxelSize = (voxelSize, prevVoxelSize) => {
        const targetSize = pixelSize * renderScaleTarget;
        for (let i = 0; i < 3; ++i) {
            const size = voxelSize[i];
            const prevSize = prevVoxelSize[i];
            if (Math.abs(targetSize - size) < Math.abs(targetSize - prevSize) && size < 1.01 * prevSize) {
                return true;
            }
        }
        return false;
    };
    let scaleIndex = sources.length - 1;
    let prevVoxelSize;
    while (true) {
        const transformedSource = sources[scaleIndex];
        if (prevVoxelSize !== undefined && !improvesOnPrevVoxelSize(transformedSource.effectiveVoxelSize, prevVoxelSize)) {
            break;
        }
        yield transformedSource;
        if (scaleIndex === 0 || !canImproveOnVoxelSize(transformedSource.effectiveVoxelSize)) {
            break;
        }
        prevVoxelSize = transformedSource.effectiveVoxelSize;
        --scaleIndex;
    }
}
export const SLICEVIEW_RPC_ID = 'SliceView';
export const SLICEVIEW_RENDERLAYER_RPC_ID = 'sliceview/RenderLayer';
export const SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID = 'SliceView.addVisibleLayer';
export const SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID = 'SliceView.removeVisibleLayer';
const tempVisibleVolumetricChunkLower = new Float32Array(3);
const tempVisibleVolumetricChunkUpper = new Float32Array(3);
const tempVisibleVolumetricModelViewProjection = mat4.create();
const tempVisibleVolumetricClippingPlanes = new Float32Array(24);
function forEachVolumetricChunkWithinFrustrum(clippingPlanes, transformedSource, callback, predicate) {
    const lower = tempVisibleVolumetricChunkLower;
    const upper = tempVisibleVolumetricChunkUpper;
    const lowerChunkDisplayBound = transformedSource.lowerChunkDisplayBound,
          upperChunkDisplayBound = transformedSource.upperChunkDisplayBound;

    for (let i = 0; i < 3; ++i) {
        lower[i] = Math.max(lower[i], lowerChunkDisplayBound[i]);
        upper[i] = Math.min(upper[i], upperChunkDisplayBound[i]);
    }
    const curPositionInChunks = transformedSource.curPositionInChunks,
          chunkDisplayDimensionIndices = transformedSource.chunkDisplayDimensionIndices;

    function recurse() {
        if (!predicate(lower[0], lower[1], lower[2], upper[0], upper[1], upper[2], clippingPlanes)) {
            return;
        }
        let splitDim = 0;
        let splitSize = Math.max(0, upper[0] - lower[0]);
        let volume = splitSize;
        for (let i = 1; i < 3; ++i) {
            const size = Math.max(0, upper[i] - lower[i]);
            volume *= size;
            if (size > splitSize) {
                splitSize = size;
                splitDim = i;
            }
        }
        if (volume === 0) return;
        if (volume === 1) {
            curPositionInChunks[chunkDisplayDimensionIndices[0]] = lower[0];
            curPositionInChunks[chunkDisplayDimensionIndices[1]] = lower[1];
            curPositionInChunks[chunkDisplayDimensionIndices[2]] = lower[2];
            callback(lower, clippingPlanes);
            return;
        }
        const prevLower = lower[splitDim];
        const prevUpper = upper[splitDim];
        const splitPoint = Math.floor(0.5 * (prevLower + prevUpper));
        upper[splitDim] = splitPoint;
        recurse();
        upper[splitDim] = prevUpper;
        lower[splitDim] = splitPoint;
        recurse();
        lower[splitDim] = prevLower;
    }
    recurse();
}
export function forEachVisibleVolumetricChunk(projectionParameters, localPosition, transformedSource, callback) {
    if (!updateFixedCurPositionInChunks(transformedSource, projectionParameters.globalPosition, localPosition)) {
        return;
    }
    const chunkSize = transformedSource.chunkLayout.size;

    const modelViewProjection = mat4.multiply(tempVisibleVolumetricModelViewProjection, projectionParameters.viewProjectionMat, transformedSource.chunkLayout.transform);
    for (let i = 0; i < 3; ++i) {
        const s = chunkSize[i];
        for (let j = 0; j < 4; ++j) {
            modelViewProjection[4 * i + j] *= s;
        }
    }
    const clippingPlanes = tempVisibleVolumetricClippingPlanes;
    getFrustrumPlanes(clippingPlanes, modelViewProjection);
    const lower = tempVisibleVolumetricChunkLower;
    const upper = tempVisibleVolumetricChunkUpper;
    lower.fill(Number.NEGATIVE_INFINITY);
    upper.fill(Number.POSITIVE_INFINITY);
    forEachVolumetricChunkWithinFrustrum(clippingPlanes, transformedSource, callback, isAABBVisible);
}
export function forEachPlaneIntersectingVolumetricChunk(projectionParameters, localPosition, transformedSource, chunkLayout, callback) {
    if (!updateFixedCurPositionInChunks(transformedSource, projectionParameters.globalPosition, localPosition)) {
        return;
    }
    const chunkSize = chunkLayout.size;

    const modelViewProjection = mat4.multiply(tempVisibleVolumetricModelViewProjection, projectionParameters.viewProjectionMat, chunkLayout.transform);
    for (let i = 0; i < 3; ++i) {
        const s = chunkSize[i];
        for (let j = 0; j < 4; ++j) {
            modelViewProjection[4 * i + j] *= s;
        }
    }
    const invModelViewProjection = tempMat4;
    mat4.invert(invModelViewProjection, modelViewProjection);
    const lower = tempVisibleVolumetricChunkLower;
    const upper = tempVisibleVolumetricChunkUpper;
    const epsilon = 1e-3;
    for (let i = 0; i < 3; ++i) {
        // Add small offset of `epsilon` voxels to bias towards the higher coordinate if very close to a
        // voxel boundary.
        const c = invModelViewProjection[12 + i] + epsilon / chunkSize[i];
        const xCoeff = Math.abs(invModelViewProjection[i]);
        const yCoeff = Math.abs(invModelViewProjection[4 + i]);
        lower[i] = Math.floor(c - xCoeff - yCoeff);
        upper[i] = Math.floor(c + xCoeff + yCoeff + 1);
    }
    const clippingPlanes = tempVisibleVolumetricClippingPlanes;
    for (let i = 0; i < 3; ++i) {
        const xCoeff = modelViewProjection[4 * i];
        const yCoeff = modelViewProjection[4 * i + 1];
        const zCoeff = modelViewProjection[4 * i + 2];
        clippingPlanes[i] = xCoeff;
        clippingPlanes[4 + i] = -xCoeff;
        clippingPlanes[8 + i] = +yCoeff;
        clippingPlanes[12 + i] = -yCoeff;
        clippingPlanes[16 + i] = +zCoeff;
        clippingPlanes[20 + i] = -zCoeff;
    }
    {
        const i = 3;
        const xCoeff = modelViewProjection[4 * i];
        const yCoeff = modelViewProjection[4 * i + 1];
        const zCoeff = modelViewProjection[4 * i + 2];
        clippingPlanes[i] = 1 + xCoeff;
        clippingPlanes[4 + i] = 1 - xCoeff;
        clippingPlanes[8 + i] = 1 + yCoeff;
        clippingPlanes[12 + i] = 1 - yCoeff;
        clippingPlanes[16 + i] = zCoeff;
        clippingPlanes[20 + i] = -zCoeff;
    }
    if (DEBUG_CHUNK_VISIBILITY) {
        console.log('clippingPlanes', clippingPlanes);
        console.log('modelViewProjection', modelViewProjection.join(','));
        console.log(`lower=${lower.join(',')}, upper=${upper.join(',')}`);
    }
    forEachVolumetricChunkWithinFrustrum(clippingPlanes, transformedSource, callback, isAABBIntersectingPlane);
}
/**
 * For chunk layouts with finiteRank < 3, returns an adjusted chunk layout where chunk 0 in each
 * non-finite dimension is guaranteed to cover the viewport.
 */
export function getNormalizedChunkLayout(projectionParameters, chunkLayout) {
    const finiteRank = chunkLayout.finiteRank;

    if (finiteRank === 3) return chunkLayout;
    tempChunkLayout.finiteRank = finiteRank;
    vec3.copy(tempChunkLayout.size, chunkLayout.size);
    const transform = mat4.copy(tempChunkLayout.transform, chunkLayout.transform);
    const invTransform = mat4.copy(tempChunkLayout.invTransform, chunkLayout.invTransform);
    tempChunkLayout.detTransform = chunkLayout.detTransform;
    const invViewMatrix = projectionParameters.invViewMatrix,
          width = projectionParameters.width,
          height = projectionParameters.height;

    const depth = getViewFrustrumDepthRange(projectionParameters.projectionMat);
    for (let chunkRenderDim = finiteRank; chunkRenderDim < 3; ++chunkRenderDim) {
        // we want to ensure chunk [0] fully covers the viewport
        const offset = invViewMatrix[12 + chunkRenderDim];
        let lower = offset,
            upper = offset;
        const xc = Math.abs(invViewMatrix[chunkRenderDim] * width);
        lower -= xc;
        upper += xc;
        const yc = Math.abs(invViewMatrix[chunkRenderDim + 4] * height);
        lower -= yc;
        upper += yc;
        const zc = Math.abs(invViewMatrix[chunkRenderDim + 8] * depth);
        lower -= zc;
        upper += zc;
        const scaleFactor = Math.max(1, upper - lower);
        transform[12 + chunkRenderDim] = lower;
        transform[5 * chunkRenderDim] = scaleFactor;
    }
    mat4.invert(invTransform, transform);
    return tempChunkLayout;
}
//# sourceMappingURL=base.js.map