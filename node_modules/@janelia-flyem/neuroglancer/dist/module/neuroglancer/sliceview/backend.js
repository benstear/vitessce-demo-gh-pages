import _Number$isFinite from "babel-runtime/core-js/number/is-finite";
import _slicedToArray from "babel-runtime/helpers/slicedToArray";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import "../render_layer_backend";
import { Chunk, ChunkSource, getNextMarkGeneration, withChunkManager } from "../chunk_manager/backend";
import { ChunkPriorityTier, ChunkState } from "../chunk_manager/base";
import { filterVisibleSources, forEachPlaneIntersectingVolumetricChunk, SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID, SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID, SLICEVIEW_RENDERLAYER_RPC_ID, SLICEVIEW_RPC_ID, SliceViewBase, getNormalizedChunkLayout } from "./base";
import { ChunkLayout } from "./chunk_layout";
import { erf } from "../util/erf";
import { vec3, vec3Key } from "../util/geom";
import { VelocityEstimator } from "../util/velocity_estimation";
import { getBasePriority, getPriorityTier, withSharedVisibility } from "../visibility_priority/backend";
import { registerRPC, registerSharedObject, SharedObjectCounterpart } from "../worker_rpc";
export const BASE_PRIORITY = -1e12;
export const SCALE_PRIORITY_MULTIPLIER = 1e9;
// Temporary values used by SliceView.updateVisibleChunk
const tempChunkPosition = vec3.create();
const tempCenter = vec3.create();
const tempChunkSize = vec3.create();
class SliceViewCounterpartBase extends SliceViewBase {
    constructor(rpc, options) {
        super(rpc.get(options.projectionParameters));
        this.initializeSharedObject(rpc, options['id']);
    }
}
function disposeTransformedSources(allSources) {
    for (const scales of allSources) {
        for (const tsource of scales) {
            tsource.source.dispose();
        }
    }
}
const SliceViewIntermediateBase = withSharedVisibility(withChunkManager(SliceViewCounterpartBase));
let SliceViewBackend = class SliceViewBackend extends SliceViewIntermediateBase {
    constructor(rpc, options) {
        super(rpc, options);
        this.velocityEstimator = new VelocityEstimator();
        this.handleLayerChanged = () => {
            this.chunkManager.scheduleUpdateChunkPriorities();
        };
        this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => {
            this.updateVisibleChunks();
        }));
        this.registerDisposer(this.projectionParameters.changed.add(() => {
            this.velocityEstimator.addSample(this.projectionParameters.value.globalPosition);
        }));
    }
    invalidateVisibleChunks() {
        super.invalidateVisibleChunks();
        this.chunkManager.scheduleUpdateChunkPriorities();
    }
    updateVisibleChunks() {
        const projectionParameters = this.projectionParameters.value;
        let chunkManager = this.chunkManager;
        const visibility = this.visibility.value;
        if (visibility === Number.NEGATIVE_INFINITY) {
            return;
        }
        this.updateVisibleSources();
        const centerDataPosition = projectionParameters.centerDataPosition;

        const priorityTier = getPriorityTier(visibility);
        let basePriority = getBasePriority(visibility);
        basePriority += BASE_PRIORITY;
        const localCenter = tempCenter;
        const chunkSize = tempChunkSize;
        const curVisibleChunks = [];
        this.velocityEstimator.addSample(this.projectionParameters.value.globalPosition);
        for (const _ref of this.visibleLayers) {
            var _ref2 = _slicedToArray(_ref, 2);

            const layer = _ref2[0];
            const visibleLayerSources = _ref2[1];

            chunkManager.registerLayer(layer);
            const visibleSources = visibleLayerSources.visibleSources;

            for (let i = 0, numVisibleSources = visibleSources.length; i < numVisibleSources; ++i) {
                const tsource = visibleSources[i];
                const prefetchOffsets = chunkManager.queueManager.enablePrefetch.value ? getPrefetchChunkOffsets(this.velocityEstimator, tsource) : [];
                const chunkLayout = tsource.chunkLayout;

                chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);
                const size = chunkLayout.size,
                      finiteRank = chunkLayout.finiteRank;

                vec3.copy(chunkSize, size);
                for (let i = finiteRank; i < 3; ++i) {
                    chunkSize[i] = 0;
                    localCenter[i] = 0;
                }
                const priorityIndex = i;
                const sourceBasePriority = basePriority + SCALE_PRIORITY_MULTIPLIER * priorityIndex;
                curVisibleChunks.length = 0;
                const curMarkGeneration = getNextMarkGeneration();
                forEachPlaneIntersectingVolumetricChunk(projectionParameters, tsource.renderLayer.localPosition.value, tsource, getNormalizedChunkLayout(projectionParameters, tsource.chunkLayout), positionInChunks => {
                    vec3.multiply(tempChunkPosition, positionInChunks, chunkSize);
                    let priority = -vec3.distance(localCenter, tempChunkPosition);
                    const curPositionInChunks = tsource.curPositionInChunks;

                    let chunk = tsource.source.getChunk(curPositionInChunks);
                    chunkManager.requestChunk(chunk, priorityTier, sourceBasePriority + priority);
                    ++layer.numVisibleChunksNeeded;
                    if (chunk.state === ChunkState.GPU_MEMORY) {
                        ++layer.numVisibleChunksAvailable;
                    }
                    curVisibleChunks.push(chunk);
                    // Mark visible chunks to avoid duplicate work when prefetching.  Once we hit a
                    // visible chunk, we don't continue prefetching in the same direction.
                    chunk.markGeneration = curMarkGeneration;
                });
                if (prefetchOffsets.length !== 0) {
                    const curPositionInChunks = tsource.curPositionInChunks;

                    for (const visibleChunk of curVisibleChunks) {
                        curPositionInChunks.set(visibleChunk.chunkGridPosition);
                        for (let j = 0, length = prefetchOffsets.length; j < length;) {
                            const chunkDim = prefetchOffsets[j];
                            const minChunk = prefetchOffsets[j + 2];
                            const maxChunk = prefetchOffsets[j + 3];
                            const newPriority = prefetchOffsets[j + 4];
                            const jumpOffset = prefetchOffsets[j + 5];
                            const oldIndex = curPositionInChunks[chunkDim];
                            const newIndex = oldIndex + prefetchOffsets[j + 1];
                            if (newIndex < minChunk || newIndex > maxChunk) {
                                j = jumpOffset;
                                continue;
                            }
                            curPositionInChunks[chunkDim] = newIndex;
                            const chunk = tsource.source.getChunk(curPositionInChunks);
                            curPositionInChunks[chunkDim] = oldIndex;
                            if (chunk.markGeneration === curMarkGeneration) {
                                j = jumpOffset;
                                continue;
                            }
                            if (!_Number$isFinite(newPriority)) {
                                debugger;
                            }
                            chunkManager.requestChunk(chunk, ChunkPriorityTier.PREFETCH, sourceBasePriority + newPriority);
                            ++layer.numPrefetchChunksNeeded;
                            if (chunk.state === ChunkState.GPU_MEMORY) {
                                ++layer.numPrefetchChunksAvailable;
                            }
                            j += PREFETCH_ENTRY_SIZE;
                        }
                    }
                }
            }
        }
    }
    removeVisibleLayer(layer) {
        const visibleLayers = this.visibleLayers;

        const layerInfo = visibleLayers.get(layer);
        visibleLayers.delete(layer);
        disposeTransformedSources(layerInfo.allSources);
        layer.renderScaleTarget.changed.remove(this.invalidateVisibleSources);
        layer.localPosition.changed.remove(this.handleLayerChanged);
        this.invalidateVisibleSources();
    }
    addVisibleLayer(layer, allSources) {
        const displayDimensionRenderInfo = this.projectionParameters.value.displayDimensionRenderInfo;

        let layerInfo = this.visibleLayers.get(layer);
        if (layerInfo === undefined) {
            layerInfo = {
                allSources,
                visibleSources: [],
                displayDimensionRenderInfo: displayDimensionRenderInfo
            };
            this.visibleLayers.set(layer, layerInfo);
            layer.renderScaleTarget.changed.add(() => this.invalidateVisibleSources());
            layer.localPosition.changed.add(this.handleLayerChanged);
        } else {
            disposeTransformedSources(layerInfo.allSources);
            layerInfo.allSources = allSources;
            layerInfo.visibleSources.length = 0;
            layerInfo.displayDimensionRenderInfo = displayDimensionRenderInfo;
        }
        this.invalidateVisibleSources();
    }
    disposed() {
        for (let layer of this.visibleLayers.keys()) {
            this.removeVisibleLayer(layer);
        }
        super.disposed();
    }
    invalidateVisibleSources() {
        super.invalidateVisibleSources();
        this.chunkManager.scheduleUpdateChunkPriorities();
    }
};
SliceViewBackend = __decorate([registerSharedObject(SLICEVIEW_RPC_ID)], SliceViewBackend);
export { SliceViewBackend };
export function deserializeTransformedSources(rpc, serializedSources, layer) {
    const sources = serializedSources.map(scales => scales.map(serializedSource => {
        const source = rpc.getRef(serializedSource.source);
        const chunkLayout = serializedSource.chunkLayout;
        const rank = source.spec.rank;

        const tsource = {
            renderLayer: layer,
            source,
            chunkLayout: ChunkLayout.fromObject(chunkLayout),
            layerRank: serializedSource.layerRank,
            nonDisplayLowerClipBound: serializedSource.nonDisplayLowerClipBound,
            nonDisplayUpperClipBound: serializedSource.nonDisplayUpperClipBound,
            lowerClipBound: serializedSource.lowerClipBound,
            upperClipBound: serializedSource.upperClipBound,
            lowerClipDisplayBound: serializedSource.lowerClipDisplayBound,
            upperClipDisplayBound: serializedSource.upperClipDisplayBound,
            lowerChunkDisplayBound: serializedSource.lowerChunkDisplayBound,
            upperChunkDisplayBound: serializedSource.upperChunkDisplayBound,
            effectiveVoxelSize: serializedSource.effectiveVoxelSize,
            chunkDisplayDimensionIndices: serializedSource.chunkDisplayDimensionIndices,
            fixedLayerToChunkTransform: serializedSource.fixedLayerToChunkTransform,
            combinedGlobalLocalToChunkTransform: serializedSource.combinedGlobalLocalToChunkTransform,
            curPositionInChunks: new Float32Array(rank),
            fixedPositionWithinChunk: new Uint32Array(rank)
        };
        return tsource;
    }));
    return sources;
}
registerRPC(SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID, function (x) {
    const obj = this.get(x['id']);
    const layer = this.get(x['layerId']);
    const sources = deserializeTransformedSources(this, x.sources, layer);
    obj.addVisibleLayer(layer, sources);
});
registerRPC(SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID, function (x) {
    let obj = this.get(x['id']);
    let layer = this.get(x['layerId']);
    obj.removeVisibleLayer(layer);
});
export class SliceViewChunk extends Chunk {
    constructor() {
        super();
        this.source = null;
    }
    initializeVolumeChunk(key, chunkGridPosition) {
        super.initialize(key);
        this.chunkGridPosition = Float32Array.from(chunkGridPosition);
    }
    serialize(msg, transfers) {
        super.serialize(msg, transfers);
        msg['chunkGridPosition'] = this.chunkGridPosition;
    }
    downloadSucceeded() {
        super.downloadSucceeded();
    }
    freeSystemMemory() {}
    toString() {
        return this.source.toString() + ':' + vec3Key(this.chunkGridPosition);
    }
}
export class SliceViewChunkSourceBackend extends ChunkSource {
    constructor(rpc, options) {
        super(rpc, options);
        this.spec = options.spec;
    }
    getChunk(chunkGridPosition) {
        const key = chunkGridPosition.join();
        let chunk = this.chunks.get(key);
        if (chunk === undefined) {
            chunk = this.getNewChunk_(this.chunkConstructor);
            chunk.initializeVolumeChunk(key, chunkGridPosition);
            this.addChunk(chunk);
        }
        return chunk;
    }
}
let SliceViewRenderLayerBackend = class SliceViewRenderLayerBackend extends SharedObjectCounterpart {
    constructor(rpc, options) {
        super(rpc, options);
        this.renderScaleTarget = rpc.get(options.renderScaleTarget);
        this.localPosition = rpc.get(options.localPosition);
        this.numVisibleChunksNeeded = 0;
        this.numVisibleChunksAvailable = 0;
        this.numPrefetchChunksAvailable = 0;
        this.numPrefetchChunksNeeded = 0;
        this.chunkManagerGeneration = -1;
    }
    filterVisibleSources(sliceView, sources) {
        return filterVisibleSources(sliceView, this, sources);
    }
};
SliceViewRenderLayerBackend = __decorate([registerSharedObject(SLICEVIEW_RENDERLAYER_RPC_ID)], SliceViewRenderLayerBackend);
export { SliceViewRenderLayerBackend };
const PREFETCH_MS = 2000;
const MAX_PREFETCH_VELOCITY = 0.1; // voxels per millisecond
const MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS = 32; // Maximum number of chunks to prefetch in a single direction.
// If the probability under the model of needing a chunk within `PREFETCH_MS` is less than this
// probability, skip prefetching it.
const PREFETCH_PROBABILITY_CUTOFF = 0.05;
const PREFETCH_ENTRY_SIZE = 6;
function getPrefetchChunkOffsets(velocityEstimator, tsource) {
    const offsets = [];
    const globalRank = velocityEstimator.rank;
    const combinedGlobalLocalToChunkTransform = tsource.combinedGlobalLocalToChunkTransform,
          layerRank = tsource.layerRank;
    var _tsource$source$spec = tsource.source.spec;
    const chunkRank = _tsource$source$spec.rank,
          chunkDataSize = _tsource$source$spec.chunkDataSize;
    const meanVec = velocityEstimator.mean,
          varianceVec = velocityEstimator.variance;

    for (let chunkDim = 0; chunkDim < chunkRank; ++chunkDim) {
        const isDisplayDimension = tsource.chunkDisplayDimensionIndices.includes(chunkDim);
        let mean = 0;
        let variance = 0;
        for (let globalDim = 0; globalDim < globalRank; ++globalDim) {
            const meanValue = meanVec[globalDim];
            const varianceValue = varianceVec[globalDim];
            const coeff = combinedGlobalLocalToChunkTransform[globalDim * layerRank + chunkDim];
            mean += coeff * meanValue;
            variance += coeff * coeff * varianceValue;
        }
        if (mean > MAX_PREFETCH_VELOCITY) {
            continue;
        }
        const chunkSize = chunkDataSize[chunkDim];
        const initialFraction = isDisplayDimension ? 0 : tsource.fixedPositionWithinChunk[chunkDim] / chunkSize;
        const adjustedMean = mean / chunkSize * PREFETCH_MS;
        let adjustedStddevTimesSqrt2 = Math.sqrt(2 * variance) / chunkSize * PREFETCH_MS;
        if (Math.abs(adjustedMean) < 1e-3 && adjustedStddevTimesSqrt2 < 1e-3) {
            continue;
        }
        adjustedStddevTimesSqrt2 = Math.max(1e-6, adjustedStddevTimesSqrt2);
        const cdf = x => 0.5 * (1 + erf((x - adjustedMean) / adjustedStddevTimesSqrt2));
        const curChunk = tsource.curPositionInChunks[chunkDim];
        const minChunk = Math.floor(tsource.lowerClipBound[chunkDim] / chunkSize);
        const maxChunk = Math.ceil(tsource.upperClipBound[chunkDim] / chunkSize) - 1;
        let groupStart = offsets.length;
        for (let i = 1; i <= MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS; ++i) {
            if (!isDisplayDimension && curChunk + i > maxChunk) break;
            const probability = 1 - cdf(i - initialFraction);
            // Probability that chunk `curChunk + i` will be needed within `PREFETCH_MS`.
            if (probability < PREFETCH_PROBABILITY_CUTOFF) break;
            offsets.push(chunkDim, i, minChunk, maxChunk, probability, 0);
        }
        let newGroupStart = offsets.length;
        for (let i = groupStart, end = offsets.length; i < end; i += PREFETCH_ENTRY_SIZE) {
            offsets[i + PREFETCH_ENTRY_SIZE - 1] = newGroupStart;
        }
        groupStart = newGroupStart;
        for (let i = 1; i <= MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS; ++i) {
            if (!isDisplayDimension && curChunk - i < minChunk) break;
            const probability = cdf(-i + 1 - initialFraction);
            // Probability that chunk `curChunk - i` will be needed within `PREFETCH_MS`.
            if (probability < PREFETCH_PROBABILITY_CUTOFF) break;
            offsets.push(chunkDim, -i, minChunk, maxChunk, probability, 0);
        }
        newGroupStart = offsets.length;
        for (let i = groupStart, end = offsets.length; i < end; i += PREFETCH_ENTRY_SIZE) {
            offsets[i + PREFETCH_ENTRY_SIZE - 1] = newGroupStart;
        }
    }
    return offsets;
}
//# sourceMappingURL=backend.js.map