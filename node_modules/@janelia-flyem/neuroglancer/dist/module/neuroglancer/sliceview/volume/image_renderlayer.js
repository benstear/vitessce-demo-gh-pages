import _Object$assign from 'babel-runtime/core-js/object/assign';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { SliceViewVolumeRenderLayer } from './renderlayer';
import { BLEND_FUNCTIONS, BLEND_MODES } from '../../trackable_blend';
import { WatchableValue } from '../../trackable_value';
import { glsl_COLORMAPS } from '../../webgl/colormaps';
import { makeTrackableFragmentMain, shaderCodeWithLineDirective } from '../../webgl/dynamic_shader';
import { addControlsToBuilder, getFallbackBuilderState, parseShaderUiControls, setControlsInShader } from '../../webgl/shader_ui_controls';
const DEFAULT_FRAGMENT_MAIN = `#uicontrol invlerp normalized
void main() {
  emitGrayscale(normalized());
}
`;
export function getTrackableFragmentMain(value = DEFAULT_FRAGMENT_MAIN) {
    return makeTrackableFragmentMain(value);
}
export function defineImageLayerShader(builder, shaderBuilderState) {
    builder.addFragmentCode(`
#define VOLUME_RENDERING false

void emitRGBA(vec4 rgba) {
  emit(vec4(rgba.rgb, rgba.a * uOpacity));
}
void emitRGB(vec3 rgb) {
  emit(vec4(rgb, uOpacity));
}
void emitGrayscale(float value) {
  emit(vec4(value, value, value, uOpacity));
}
void emitTransparent() {
  emit(vec4(0.0, 0.0, 0.0, 0.0));
}
`);
    builder.addFragmentCode(glsl_COLORMAPS);
    addControlsToBuilder(shaderBuilderState, builder);
    builder.setFragmentMainFunction(shaderCodeWithLineDirective(shaderBuilderState.parseResult.code));
}
export class ImageRenderLayer extends SliceViewVolumeRenderLayer {
    constructor(multiscaleSource, options) {
        var _a, _b, _c;
        const opacity = options.opacity,
              blendMode = options.blendMode,
              shaderControlState = options.shaderControlState;

        super(multiscaleSource, _Object$assign(_Object$assign({}, options), { fallbackShaderParameters: new WatchableValue(getFallbackBuilderState(parseShaderUiControls(DEFAULT_FRAGMENT_MAIN, {
                imageData: {
                    dataType: multiscaleSource.dataType,
                    channelRank: (_c = (_b = (_a = options.channelCoordinateSpace) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.rank) !== null && _c !== void 0 ? _c : 0
                }
            }))), encodeShaderParameters: p => p.key, shaderParameters: shaderControlState.builderState, dataHistogramSpecifications: shaderControlState.histogramSpecifications }));
        this.shaderControlState = shaderControlState;
        this.opacity = opacity;
        this.blendMode = blendMode;
        this.registerDisposer(opacity.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(blendMode.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(shaderControlState.changed.add(this.redrawNeeded.dispatch));
    }
    defineShader(builder, shaderBuilderState) {
        if (shaderBuilderState.parseResult.errors.length !== 0) {
            throw new Error('Invalid UI control specification');
        }
        builder.addUniform('highp float', 'uOpacity');
        defineImageLayerShader(builder, shaderBuilderState);
    }
    initializeShader(_sliceView, shader, parameters) {
        const gl = this.gl;

        gl.uniform1f(shader.uniform('uOpacity'), this.opacity.value);
        setControlsInShader(gl, shader, this.shaderControlState, parameters.parseResult.controls);
    }
    setGLBlendMode(gl, renderLayerNum) {
        const blendModeValue = this.blendMode.value;
        if (blendModeValue === BLEND_MODES.ADDITIVE || renderLayerNum > 0) {
            gl.enable(gl.BLEND);
            BLEND_FUNCTIONS.get(blendModeValue)(gl);
        } else {
            gl.disable(WebGL2RenderingContext.BLEND);
        }
    }
}
//# sourceMappingURL=image_renderlayer.js.map