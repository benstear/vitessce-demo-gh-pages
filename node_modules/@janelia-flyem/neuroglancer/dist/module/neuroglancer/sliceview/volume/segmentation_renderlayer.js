import _Object$assign from 'babel-runtime/core-js/object/assign';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { HashMapUint64 } from '../../gpu_hash/hash_table';
import { GPUHashTable, HashMapShaderManager, HashSetShaderManager } from '../../gpu_hash/shader';
import { SegmentColorShaderManager, SegmentStatedColorShaderManager } from '../../segment_color';
import { getVisibleSegments } from '../../segmentation_display_state/base';
import { registerRedrawWhenSegmentationDisplayStateChanged } from '../../segmentation_display_state/frontend';
import { SliceViewVolumeRenderLayer } from './renderlayer';
import { AggregateWatchableValue, makeCachedDerivedWatchableValue } from '../../trackable_value';
export class EquivalencesHashMap {
    constructor(disjointSets) {
        this.disjointSets = disjointSets;
        this.generation = Number.NaN;
        this.hashMap = new HashMapUint64();
    }
    update() {
        let disjointSets = this.disjointSets;
        const generation = disjointSets.generation;

        if (this.generation !== generation) {
            this.generation = generation;
            let hashMap = this.hashMap;

            hashMap.clear();
            for (let _ref of disjointSets.mappings()) {
                var _ref2 = _slicedToArray(_ref, 2);

                let objectId = _ref2[0];
                let minObjectId = _ref2[1];

                hashMap.set(objectId, minObjectId);
            }
        }
    }
}
export class SegmentationRenderLayer extends SliceViewVolumeRenderLayer {
    constructor(multiscaleSource, displayState) {
        super(multiscaleSource, {
            shaderParameters: new AggregateWatchableValue(refCounted => ({
                hasEquivalences: refCounted.registerDisposer(makeCachedDerivedWatchableValue(x => x.size !== 0, [displayState.segmentationGroupState.value.segmentEquivalences])),
                hasSegmentStatedColors: refCounted.registerDisposer(makeCachedDerivedWatchableValue(x => x.size !== 0, [displayState.segmentStatedColors])),
                hasSegmentDefaultColor: refCounted.registerDisposer(makeCachedDerivedWatchableValue(x => x !== undefined, [displayState.segmentDefaultColor])),
                hideSegmentZero: displayState.hideSegmentZero,
                baseSegmentColoring: displayState.baseSegmentColoring
            })),
            transform: displayState.transform,
            renderScaleHistogram: displayState.renderScaleHistogram,
            renderScaleTarget: displayState.renderScaleTarget,
            localPosition: displayState.localPosition
        });
        this.displayState = displayState;
        this.segmentationGroupState = this.displayState.segmentationGroupState.value;
        this.segmentColorShaderManager = new SegmentColorShaderManager('segmentColorHash');
        this.segmentStatedColorShaderManager = new SegmentStatedColorShaderManager('segmentStatedColor');
        this.hashTableManager = new HashSetShaderManager('visibleSegments');
        this.gpuHashTable = this.registerDisposer(GPUHashTable.get(this.gl, this.segmentationGroupState.visibleSegments.hashTable));
        this.gpuTemporaryHashTable = GPUHashTable.get(this.gl, this.segmentationGroupState.temporaryVisibleSegments.hashTable);
        this.equivalencesShaderManager = new HashMapShaderManager('equivalences');
        this.equivalencesHashMap = new EquivalencesHashMap(this.segmentationGroupState.segmentEquivalences.disjointSets);
        this.temporaryEquivalencesHashMap = new EquivalencesHashMap(this.segmentationGroupState.temporarySegmentEquivalences.disjointSets);
        this.gpuEquivalencesHashTable = this.registerDisposer(GPUHashTable.get(this.gl, this.equivalencesHashMap.hashMap));
        this.gpuTemporaryEquivalencesHashTable = this.registerDisposer(GPUHashTable.get(this.gl, this.temporaryEquivalencesHashMap.hashMap));
        this.registerDisposer(this.shaderParameters);
        registerRedrawWhenSegmentationDisplayStateChanged(displayState, this);
        this.registerDisposer(displayState.selectedAlpha.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(displayState.notSelectedAlpha.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(displayState.ignoreNullVisibleSet.changed.add(this.redrawNeeded.dispatch));
    }
    disposed() {
        var _a;
        (_a = this.gpuSegmentStatedColorHashTable) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    getSources(options) {
        return this.multiscaleSource.getSources(_Object$assign(_Object$assign({}, options), { discreteValues: true }));
    }
    defineShader(builder, parameters) {
        this.hashTableManager.defineShader(builder);
        let getUint64Code = `
uint64_t getUint64DataValue() {
  uint64_t x = toUint64(getDataValue());
`;
        getUint64Code += `return x;
}
`;
        builder.addFragmentCode(getUint64Code);
        if (parameters.hasEquivalences) {
            this.equivalencesShaderManager.defineShader(builder);
            builder.addFragmentCode(`
uint64_t getMappedObjectId(uint64_t value) {
  uint64_t mappedValue;
  if (${this.equivalencesShaderManager.getFunctionName}(value, mappedValue)) {
    return mappedValue;
  }
  return value;
}
`);
        } else {
            builder.addFragmentCode(`
uint64_t getMappedObjectId(uint64_t value) {
  return value;
}
`);
        }
        builder.addUniform('highp uvec2', 'uSelectedSegment');
        builder.addUniform('highp uint', 'uShowAllSegments');
        builder.addUniform('highp float', 'uSelectedAlpha');
        builder.addUniform('highp float', 'uNotSelectedAlpha');
        builder.addUniform('highp float', 'uSaturation');
        let fragmentMain = `
  uint64_t baseValue = getUint64DataValue();
  uint64_t value = getMappedObjectId(baseValue);
  uint64_t valueForColor = ${parameters.baseSegmentColoring ? 'baseValue' : 'value'};

  float alpha = uSelectedAlpha;
  float saturation = uSaturation;
`;
        if (parameters.hideSegmentZero) {
            fragmentMain += `
  if (value.value[0] == 0u && value.value[1] == 0u) {
    emit(vec4(vec4(0, 0, 0, 0)));
    return;
  }
`;
        }
        fragmentMain += `
  bool has = uShowAllSegments != 0u ? true : ${this.hashTableManager.hasFunctionName}(value);
  if (uSelectedSegment == value.value) {
    float adjustment = has ? 0.5 : 0.75;
    if (saturation > adjustment) {
      saturation -= adjustment;
    } else {
      saturation += adjustment;
    }
  } else if (!has) {
    alpha = uNotSelectedAlpha;
  }
`;
        let getMappedIdColor = `vec3 getMappedIdColor(uint64_t value) {
`;
        // If the value has a mapped color, use it; otherwise, compute the color.
        if (parameters.hasSegmentStatedColors) {
            this.segmentStatedColorShaderManager.defineShader(builder);
            getMappedIdColor += `
  vec3 rgb;
  if (${this.segmentStatedColorShaderManager.getFunctionName}(value, rgb)) {
    return rgb;
  }
`;
        }
        if (parameters.hasSegmentDefaultColor) {
            builder.addUniform('highp vec3', 'uSegmentDefaultColor');
            getMappedIdColor += `  return uSegmentDefaultColor;
`;
        } else {
            this.segmentColorShaderManager.defineShader(builder);
            getMappedIdColor += `  return segmentColorHash(value);
`;
        }
        getMappedIdColor += `
}
`;
        builder.addFragmentCode(getMappedIdColor);
        fragmentMain += `
  vec3 rgb = getMappedIdColor(valueForColor);
  emit(vec4(mix(vec3(1.0,1.0,1.0), rgb, saturation), alpha));
`;
        builder.setFragmentMain(fragmentMain);
    }
    initializeShader(_sliceView, shader, parameters) {
        const gl = this.gl;
        const displayState = this.displayState,
              segmentationGroupState = this.segmentationGroupState;
        const segmentSelectionState = this.displayState.segmentSelectionState;
        var _displayState = this.displayState;
        const segmentDefaultColor = _displayState.segmentDefaultColor.value,
              segmentColorHash = _displayState.segmentColorHash.value;

        const visibleSegments = getVisibleSegments(segmentationGroupState);
        const ignoreNullSegmentSet = this.displayState.ignoreNullVisibleSet.value;
        let selectedSegmentLow = 0,
            selectedSegmentHigh = 0;
        if (segmentSelectionState.hasSelectedSegment) {
            let seg = segmentSelectionState.selectedSegment;
            selectedSegmentLow = seg.low;
            selectedSegmentHigh = seg.high;
        }
        gl.uniform1f(shader.uniform('uSelectedAlpha'), displayState.selectedAlpha.value);
        gl.uniform1f(shader.uniform('uSaturation'), displayState.saturation.value);
        gl.uniform1f(shader.uniform('uNotSelectedAlpha'), displayState.notSelectedAlpha.value);
        gl.uniform2ui(shader.uniform('uSelectedSegment'), selectedSegmentLow, selectedSegmentHigh);
        gl.uniform1ui(shader.uniform('uShowAllSegments'), visibleSegments.hashTable.size || !ignoreNullSegmentSet ? 0 : 1);
        this.hashTableManager.enable(gl, shader, segmentationGroupState.useTemporaryVisibleSegments.value ? this.gpuTemporaryHashTable : this.gpuHashTable);
        if (parameters.hasEquivalences) {
            const useTemp = segmentationGroupState.useTemporarySegmentEquivalences.value;
            (useTemp ? this.temporaryEquivalencesHashMap : this.equivalencesHashMap).update();
            this.equivalencesShaderManager.enable(gl, shader, useTemp ? this.gpuTemporaryEquivalencesHashTable : this.gpuEquivalencesHashTable);
        }
        if (segmentDefaultColor === undefined) {
            this.segmentColorShaderManager.enable(gl, shader, segmentColorHash);
        } else {
            gl.uniform3fv(shader.uniform('uSegmentDefaultColor'), segmentDefaultColor);
        }
        if (parameters.hasSegmentStatedColors) {
            const segmentStatedColors = this.displayState.segmentStatedColors.value;
            let gpuSegmentStatedColorHashTable = this.gpuSegmentStatedColorHashTable;

            if (gpuSegmentStatedColorHashTable === undefined || gpuSegmentStatedColorHashTable.hashTable !== segmentStatedColors.hashTable) {
                gpuSegmentStatedColorHashTable === null || gpuSegmentStatedColorHashTable === void 0 ? void 0 : gpuSegmentStatedColorHashTable.dispose();
                this.gpuSegmentStatedColorHashTable = gpuSegmentStatedColorHashTable = GPUHashTable.get(gl, segmentStatedColors.hashTable);
            }
            this.segmentStatedColorShaderManager.enable(gl, shader, gpuSegmentStatedColorHashTable);
        }
    }
    endSlice(sliceView, shader, parameters) {
        const gl = this.gl;

        this.hashTableManager.disable(gl, shader);
        if (parameters.hasEquivalences) {
            this.equivalencesShaderManager.disable(gl, shader);
        }
        if (parameters.hasSegmentStatedColors) {
            this.segmentStatedColorShaderManager.disable(gl, shader);
        }
        super.endSlice(sliceView, shader, parameters);
    }
}
//# sourceMappingURL=segmentation_renderlayer.js.map