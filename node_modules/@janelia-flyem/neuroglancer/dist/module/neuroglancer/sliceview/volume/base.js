import _Object$assign from 'babel-runtime/core-js/object/assign';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { getChunkDataSizes, getNearIsotropicBlockSize, makeSliceViewChunkSpecification } from '../base';
import { DATA_TYPE_BYTES, DataType } from '../../util/data_type';
import { getDependentTransformInputDimensions } from '../../util/geom';
import * as matrix from '../../util/matrix';
import * as vector from '../../util/vector';
export { DATA_TYPE_BYTES, DataType };
/**
 * Specifies the interpretation of volumetric data.
 */
export var VolumeType;
(function (VolumeType) {
    VolumeType[VolumeType["UNKNOWN"] = 0] = "UNKNOWN";
    VolumeType[VolumeType["IMAGE"] = 1] = "IMAGE";
    VolumeType[VolumeType["SEGMENTATION"] = 2] = "SEGMENTATION";
})(VolumeType || (VolumeType = {}));
/**
 * By default, choose a chunk size with at most 2^18 = 262144 voxels.
 */
export const DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 = 18;
export function makeVolumeChunkSpecification(options) {
    const rank = options.rank,
          dataType = options.dataType,
          compressedSegmentationBlockSize = options.compressedSegmentationBlockSize;
    var _options$baseVoxelOff = options.baseVoxelOffset;
    const baseVoxelOffset = _options$baseVoxelOff === undefined ? new Float32Array(rank) : _options$baseVoxelOff;

    return _Object$assign(_Object$assign({}, makeSliceViewChunkSpecification(options)), { compressedSegmentationBlockSize,
        baseVoxelOffset,
        dataType });
}
function shouldTranscodeToCompressedSegmentation(options) {
    if (options.compressedSegmentationBlockSize !== undefined) return false;
    if (options.volumeType !== VolumeType.SEGMENTATION && !options.volumeSourceOptions.discreteValues) {
        return false;
    }
    switch (options.dataType) {
        case DataType.UINT32:
        case DataType.UINT64:
            break;
        default:
            return false;
    }
    switch (options.rank) {
        case 3:
            return true;
        case 4:
            {
                // precomputed format always uses 4-d chunks, even if there is a single channel.  We still
                // want to allow transcoding in that case.  In fact the compressed_segmentation format
                // supports transcoding even for arbitrary 4-d chunks, but it is not clear it would be a good
                // default encoding in that case.
                const chunkDataSize = options.chunkDataSize;

                if (chunkDataSize[3] !== 1) return false;
                return true;
            }
        default:
            return false;
    }
}
/**
 * Returns a VolumeChunkSpecification with default compression specified if suitable for the
 * volumeType.
 */
export function makeVolumeChunkSpecificationWithDefaultCompression(options) {
    let rank = options.rank,
        lowerVoxelBound = options.lowerVoxelBound,
        upperVoxelBound = options.upperVoxelBound;

    if (!shouldTranscodeToCompressedSegmentation(options)) {
        return makeVolumeChunkSpecification(options);
    }
    var _options$volumeSource = options.volumeSourceOptions;
    let displayRank = _options$volumeSource.displayRank,
        multiscaleToViewTransform = _options$volumeSource.multiscaleToViewTransform,
        chunkToMultiscaleTransform = options.chunkToMultiscaleTransform,
        chunkToViewTransform = options.chunkToViewTransform;

    if (chunkToViewTransform === undefined) {
        chunkToViewTransform = matrix.multiply(new Float32Array(rank * displayRank), displayRank, //
        multiscaleToViewTransform, displayRank, //
        chunkToMultiscaleTransform, rank + 1, //
        displayRank, rank, rank);
    }
    const maxCompressedSegmentationBlockSize = options.maxCompressedSegmentationBlockSize,
          chunkDataSize = options.chunkDataSize;

    return makeVolumeChunkSpecification(_Object$assign(_Object$assign({}, options), { compressedSegmentationBlockSize: Float32Array.from(getNearIsotropicBlockSize({
            rank,
            chunkToViewTransform,
            displayRank,
            lowerVoxelBound,
            upperVoxelBound,
            maxVoxelsPerChunkLog2: 9,
            maxBlockSize: maxCompressedSegmentationBlockSize === undefined ? chunkDataSize : vector.min(new Uint32Array(rank), chunkDataSize, maxCompressedSegmentationBlockSize)
        })) }));
}
export function makeDefaultVolumeChunkSpecifications(options) {
    const rank = options.rank;
    var _options$volumeSource2 = options.volumeSourceOptions;
    const displayRank = _options$volumeSource2.displayRank,
          multiscaleToViewTransform = _options$volumeSource2.multiscaleToViewTransform,
          modelChannelDimensionIndices = _options$volumeSource2.modelChannelDimensionIndices,
          chunkToMultiscaleTransform = options.chunkToMultiscaleTransform;

    const chunkToViewTransform = matrix.multiply(new Float32Array(displayRank * rank), displayRank, //
    multiscaleToViewTransform, displayRank, //
    chunkToMultiscaleTransform, rank + 1, //
    displayRank, rank, rank);
    let minBlockSize = options.minBlockSize;

    if (minBlockSize === undefined) {
        minBlockSize = new Uint32Array(rank);
        minBlockSize.fill(1);
    } else {
        minBlockSize = new Uint32Array(minBlockSize);
    }
    const lowerVoxelBound = options.lowerVoxelBound,
          upperVoxelBound = options.upperVoxelBound;

    if (modelChannelDimensionIndices.length !== 0) {
        for (const chunkDim of getDependentTransformInputDimensions(chunkToMultiscaleTransform, rank, modelChannelDimensionIndices)) {
            let size = upperVoxelBound[chunkDim];
            if (lowerVoxelBound !== undefined) {
                size -= lowerVoxelBound[chunkDim];
            }
            minBlockSize[chunkDim] = size;
        }
    }
    var _options$chunkDataSiz = options.chunkDataSizes;
    const chunkDataSizes = _options$chunkDataSiz === undefined ? getChunkDataSizes(_Object$assign(_Object$assign({}, options), { minBlockSize,
        chunkToViewTransform,
        displayRank })) : _options$chunkDataSiz;

    return chunkDataSizes.map(chunkDataSize => makeVolumeChunkSpecificationWithDefaultCompression(_Object$assign(_Object$assign({}, options), { chunkDataSize: chunkDataSize, chunkToViewTransform })));
}
export const VOLUME_RPC_ID = 'volume';
//# sourceMappingURL=base.js.map