import _Array$from from 'babel-runtime/core-js/array/from';
import _Object$assign from 'babel-runtime/core-js/object/assign';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { MultiscaleSliceViewChunkSource, SliceViewChunk, SliceViewChunkSource } from '../frontend';
import { getShaderType, glsl_mixLinear } from '../../webgl/shader_lib';
export function defineChunkDataShaderAccess(builder, chunkFormat, numChannelDimensions, getPositionWithinChunkExpr) {
    const dataType = chunkFormat.dataType;

    chunkFormat.defineShader(builder, numChannelDimensions);
    let dataAccessChannelParams = ``;
    let dataAccessChannelArgs = ``;
    if (numChannelDimensions === 0) {
        dataAccessChannelParams += `highp int ignoredChannelIndex`;
    } else {
        for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
            if (channelDim !== 0) dataAccessChannelParams += `, `;
            dataAccessChannelParams += `highp int channelIndex${channelDim}`;
            dataAccessChannelArgs += `, channelIndex${channelDim}`;
        }
    }
    builder.addFragmentCode(glsl_mixLinear);
    let dataAccessCode = `
${getShaderType(dataType)} getDataValue(${dataAccessChannelParams}) {
  highp ivec3 p = ivec3(max(vec3(0.0, 0.0, 0.0), min(floor(${getPositionWithinChunkExpr}), uChunkDataSize - 1.0)));
  return getDataValueAt(p${dataAccessChannelArgs});
}
${getShaderType(dataType)} getInterpolatedDataValue(${dataAccessChannelParams}) {
  highp vec3 positionWithinChunk = ${getPositionWithinChunkExpr};
  highp ivec3[2] points;
  points[0] = ivec3(max(vec3(0.0, 0.0, 0.0), min(floor(positionWithinChunk - 0.5), uChunkDataSize - 1.0)));
  points[1] = ivec3(max(vec3(0.0, 0.0, 0.0), min(ceil(positionWithinChunk - 0.5), uChunkDataSize - 1.0)));
  highp vec3 mixCoeff = fract(positionWithinChunk - 0.5);
  ${getShaderType(dataType)} xvalues[2];
  for (int ix = 0; ix < 2; ++ix) {
    ${getShaderType(dataType)} yvalues[2];
    for (int iy = 0; iy < 2; ++iy) {
      ${getShaderType(dataType)} zvalues[2];
      for (int iz = 0; iz < 2; ++iz) {
        zvalues[iz] = getDataValueAt(ivec3(points[ix].x, points[iy].y, points[iz].z)
                                     ${dataAccessChannelArgs});
      }
      yvalues[iy] = mixLinear(zvalues[0], zvalues[1], mixCoeff.z);
    }
    xvalues[ix] = mixLinear(yvalues[0], yvalues[1], mixCoeff.y);
  }
  return mixLinear(xvalues[0], xvalues[1], mixCoeff.x);
}
`;
    builder.addFragmentCode(dataAccessCode);
    if (numChannelDimensions <= 1) {
        builder.addFragmentCode(`
${getShaderType(dataType)} getDataValue() { return getDataValue(0); }
${getShaderType(dataType)} getInterpolatedDataValue() { return getInterpolatedDataValue(0); }
`);
    }
}
var chunkFormatHandlers = new Array();
export function registerChunkFormatHandler(factory) {
    chunkFormatHandlers.push(factory);
}
export function getChunkFormatHandler(gl, spec) {
    for (let handler of chunkFormatHandlers) {
        let result = handler(gl, spec);
        if (result != null) {
            return result;
        }
    }
    throw new Error('No chunk format handler found.');
}
export class VolumeChunkSource extends SliceViewChunkSource {
    constructor(chunkManager, options) {
        super(chunkManager, options);
        this.chunkFormatHandler = this.registerDisposer(getChunkFormatHandler(chunkManager.chunkQueueManager.gl, this.spec));
        const rank = this.spec.upperVoxelBound.length;
        this.tempChunkGridPosition = new Float32Array(rank);
        this.tempPositionWithinChunk = new Uint32Array(rank);
    }
    static encodeSpec(spec) {
        const s = spec;
        return _Object$assign(_Object$assign({}, super.encodeSpec(spec)), { dataType: s.dataType, compressedSegmentationBlockSize: s.compressedSegmentationBlockSize && _Array$from(s.compressedSegmentationBlockSize), baseVoxelOffset: _Array$from(s.baseVoxelOffset) });
    }
    get chunkFormat() {
        return this.chunkFormatHandler.chunkFormat;
    }
    getValueAt(chunkPosition, channelAccess) {
        const rank = this.spec.rank;
        const chunkGridPosition = this.tempChunkGridPosition;
        const positionWithinChunk = this.tempPositionWithinChunk;
        const spec = this.spec;

        {
            const chunkDataSize = spec.chunkDataSize;

            for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
                const voxel = chunkPosition[chunkDim];
                const chunkSize = chunkDataSize[chunkDim];
                const chunk = Math.floor(voxel / chunkSize);
                chunkGridPosition[chunkDim] = chunk;
                positionWithinChunk[chunkDim] = Math.floor(voxel - chunkSize * chunk);
            }
        }
        const chunk = this.chunks.get(chunkGridPosition.join());
        if (chunk === undefined) {
            return null;
        }
        const chunkDataSize = chunk.chunkDataSize;
        for (let i = 0; i < 3; ++i) {
            if (positionWithinChunk[i] >= chunkDataSize[i]) {
                return undefined;
            }
        }
        if (channelAccess.channelSpaceShape.length === 0) {
            // Return a single value.
            return chunk.getValueAt(positionWithinChunk);
        }
        const numChannels = channelAccess.numChannels,
              chunkChannelCoordinates = channelAccess.chunkChannelCoordinates,
              chunkChannelDimensionIndices = channelAccess.chunkChannelDimensionIndices;

        const chunkChannelRank = chunkChannelDimensionIndices.length;
        let offset = 0;
        const values = new Array(numChannels);
        for (let channelIndex = 0; channelIndex < numChannels; ++channelIndex) {
            for (let i = 0; i < chunkChannelRank; ++i) {
                positionWithinChunk[chunkChannelDimensionIndices[i]] = chunkChannelCoordinates[offset++];
            }
            values[channelIndex] = chunk.getValueAt(positionWithinChunk);
        }
        return values;
    }
    getChunk(x) {
        return this.chunkFormatHandler.getChunk(this, x);
    }
}
export class VolumeChunk extends SliceViewChunk {
    constructor(source, x) {
        super(source, x);
        this.chunkDataSize = x['chunkDataSize'] || source.spec.chunkDataSize;
    }
    get chunkFormat() {
        return this.source.chunkFormat;
    }
}
export class MultiscaleVolumeChunkSource extends MultiscaleSliceViewChunkSource {}
//# sourceMappingURL=frontend.js.map