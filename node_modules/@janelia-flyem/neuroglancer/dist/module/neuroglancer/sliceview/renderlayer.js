import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ChunkRenderLayerFrontend } from '../chunk_manager/frontend';
import { trackableRenderScaleTarget } from '../render_scale_statistics';
import { RenderLayer, VisibilityTrackedRenderLayer } from '../renderlayer';
import { SharedWatchableValue } from '../shared_watchable_value';
import { filterVisibleSources, SLICEVIEW_RENDERLAYER_RPC_ID } from './base';
import { constantWatchableValue } from '../trackable_value';
import { HistogramSpecifications } from '../webgl/empirical_cdf';
export class SliceViewRenderLayer extends RenderLayer {
    constructor(chunkManager, multiscaleSource, options) {
        var _a;
        super();
        this.chunkManager = chunkManager;
        this.multiscaleSource = multiscaleSource;
        this.rpcId = null;
        this.rpcTransfer = {};
        /**
         * Currently visible sources for this render layer.
         */
        this.visibleSources = new _Map();
        /**
         * Cached list of sources in `visibleSources`, ordered by voxel size.
         *
         * Truncated to zero length when `visibleSources` changes to indicate that it is invalid.
         */
        this.visibleSourcesList_ = [];
        var _options$renderScaleT = options.renderScaleTarget;
        const renderScaleTarget = _options$renderScaleT === undefined ? trackableRenderScaleTarget(1) : _options$renderScaleT;

        this.renderScaleTarget = renderScaleTarget;
        this.renderScaleHistogram = options.renderScaleHistogram;
        this.transform = options.transform;
        this.localPosition = options.localPosition;
        this.rpcTransfer = options.rpcTransfer || {};
        this.dataHistogramSpecifications = this.registerDisposer((_a = options.dataHistogramSpecifications) !== null && _a !== void 0 ? _a : new HistogramSpecifications(constantWatchableValue([]), constantWatchableValue([])));
        this.registerDisposer(this.dataHistogramSpecifications.visibility.changed.add(this.redrawNeeded.dispatch));
    }
    getDataHistogramCount() {
        const dataHistogramSpecifications = this.dataHistogramSpecifications;

        if (!dataHistogramSpecifications.visibility.visible) return 0;
        return dataHistogramSpecifications.bounds.value.length;
    }
    getSources(options) {
        return this.multiscaleSource.getSources(options);
    }
    addSource(source, chunkTransform) {
        const visibleSources = this.visibleSources;

        const info = visibleSources.get(source);
        if (info !== undefined) {
            ++info.refCount;
            info.chunkTransform = chunkTransform;
        } else {
            visibleSources.set(source, { source, refCount: 1, chunkTransform });
            this.visibleSourcesList_.length = 0;
        }
    }
    removeSource(source) {
        const visibleSources = this.visibleSources;

        const info = visibleSources.get(source);
        if (info.refCount !== 1) {
            --info.refCount;
        } else {
            visibleSources.delete(source);
            this.visibleSourcesList_.length = 0;
        }
    }
    get visibleSourcesList() {
        const visibleSources = this.visibleSources,
              visibleSourcesList_ = this.visibleSourcesList_;

        if (visibleSourcesList_.length === 0 && visibleSources.size !== 0) {
            for (const info of visibleSources.values()) {
                visibleSourcesList_.push(info);
            }
            // Sort by volume scaling factor.
            visibleSourcesList_.sort((a, b) => {
                return a.chunkTransform.chunkToLayerTransformDet - b.chunkTransform.chunkToLayerTransformDet;
            });
        }
        return visibleSourcesList_;
    }
    initializeCounterpart() {
        const sharedObject = this.registerDisposer(new ChunkRenderLayerFrontend(this.layerChunkProgressInfo));
        const rpc = this.chunkManager.rpc;
        sharedObject.RPC_TYPE_ID = this.RPC_TYPE_ID;
        sharedObject.initializeCounterpart(rpc, _Object$assign({ localPosition: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.localPosition)).rpcId, renderScaleTarget: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.renderScaleTarget)).rpcId }, this.rpcTransfer));
        this.rpcId = sharedObject.rpcId;
    }
    get gl() {
        return this.chunkManager.chunkQueueManager.gl;
    }
    setGLBlendMode(gl, renderLayerNum) {
        // Default blend mode for non-blend-mode-aware layers
        if (renderLayerNum > 0) {
            gl.enable(WebGL2RenderingContext.BLEND);
            gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
        } else {
            gl.disable(WebGL2RenderingContext.BLEND);
        }
    }
    filterVisibleSources(sliceView, sources) {
        return filterVisibleSources(sliceView, this, sources);
    }
}
SliceViewRenderLayer.prototype.RPC_TYPE_ID = SLICEVIEW_RENDERLAYER_RPC_ID;
export class SliceViewPanelRenderLayer extends VisibilityTrackedRenderLayer {
    draw(renderContext, attachment) {
        renderContext;
        attachment;
        // Must be overridden by subclasses.
    }
    isReady(renderContext, attachment) {
        renderContext;
        attachment;
        return true;
    }
}
//# sourceMappingURL=renderlayer.js.map