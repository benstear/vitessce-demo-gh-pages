import _Set from "babel-runtime/core-js/set";
import _Map from "babel-runtime/core-js/map";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { RefCounted } from "../util/disposable";
const DEBUG_SHADER = false;
export var ShaderType;
(function (ShaderType) {
    ShaderType[ShaderType["VERTEX"] = WebGL2RenderingContext.VERTEX_SHADER] = "VERTEX";
    ShaderType[ShaderType["FRAGMENT"] = WebGL2RenderingContext.FRAGMENT_SHADER] = "FRAGMENT";
})(ShaderType || (ShaderType = {}));
/**
 * Parses the output of getShaderInfoLog into a list of messages.
 */
export function parseShaderErrors(log) {
    log = log.replace('\0', '');
    let result = [];
    for (let line of log.split('\n')) {
        let m = line.match(/^ERROR:\s*(\d+):(\d+)\s*(.+)$/);
        if (m !== null) {
            result.push({ message: m[3].trim(), file: parseInt(m[1], 10), line: parseInt(m[2], 10) });
        } else {
            m = line.match(/^ERROR:\s*(.+)$/);
            if (m !== null) {
                result.push({ message: m[1] });
            } else {
                line = line.trim();
                if (line) {
                    result.push({ message: line });
                }
            }
        }
    }
    return result;
}
export class ShaderCompilationError extends Error {
    constructor(shaderType, source, log, errorMessages) {
        const message = `Error compiling ${ShaderType[shaderType].toLowerCase()} shader: ${log}`;
        super(message);
        this.name = 'ShaderCompilationError';
        this.log = log;
        this.message = message;
        this.shaderType = shaderType;
        this.source = source;
        this.errorMessages = errorMessages;
    }
}
export class ShaderLinkError extends Error {
    constructor(vertexSource, fragmentSource, log) {
        const message = `Error linking shader: ${log}`;
        super(message);
        this.name = 'ShaderLinkError';
        this.log = log;
        this.message = message;
        this.vertexSource = vertexSource;
        this.fragmentSource = fragmentSource;
    }
}
export function getShader(gl, source, shaderType) {
    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        let log = gl.getShaderInfoLog(shader) || '';
        if (DEBUG_SHADER) {
            let lines = source.replace('<', '&lt;').replace('>', '&gt;').split('\n');
            let s = '<pre>';
            s += log.replace('<', '&lt;').replace('>', '&gt;') + '\n';
            lines.forEach((line, i) => {
                s += `${i + 1}: ${line}\n`;
            });
            s += `\n</pre>`;
            console.log(s);
            let w = window.open('about:blank', '_blank');
            if (w !== null) {
                try {
                    w.document.write(s);
                } catch (writeError) {}
            }
        }
        throw new ShaderCompilationError(shaderType, source, log, parseShaderErrors(log));
    }
    return shader;
}
let curShader;
export class ShaderProgram extends RefCounted {
    constructor(gl, vertexSource, fragmentSource, uniformNames, attributeNames, vertexDebugOutputs) {
        super();
        this.gl = gl;
        this.vertexSource = vertexSource;
        this.fragmentSource = fragmentSource;
        this.attributes = new _Map();
        this.uniforms = new _Map();
        this.vertexShaderInputBinders = {};
        let vertexShader = this.vertexShader = getShader(gl, vertexSource, gl.VERTEX_SHADER);
        let fragmentShader = this.fragmentShader = getShader(gl, fragmentSource, gl.FRAGMENT_SHADER);
        let shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        if (DEBUG_SHADER && (vertexDebugOutputs === null || vertexDebugOutputs === void 0 ? void 0 : vertexDebugOutputs.length)) {
            gl.transformFeedbackVaryings(shaderProgram, vertexDebugOutputs.map(x => x.name), WebGL2RenderingContext.INTERLEAVED_ATTRIBS);
            this.vertexDebugOutputs = vertexDebugOutputs;
        }
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            let log = gl.getProgramInfoLog(shaderProgram) || '';
            // DEBUG
            // {
            //   let combinedSource = 'VERTEX SHADER\n\n' + vertexSource + '\n\n\nFRAGMENT SHADER\n\n' +
            //   fragmentSource + '\n';
            //   let w = window.open("about:blank", "_blank");
            //   w.document.write('<pre>' + combinedSource.replace('<', '&lt;').replace('>', '&gt;') +
            //   '</pre>');
            // }
            throw new ShaderLinkError(vertexSource, fragmentSource, log);
        }
        this.program = shaderProgram;
        let uniforms = this.uniforms,
            attributes = this.attributes;

        if (uniformNames) {
            for (let name of uniformNames) {
                uniforms.set(name, gl.getUniformLocation(shaderProgram, name));
            }
        }
        if (attributeNames) {
            for (let name of attributeNames) {
                attributes.set(name, gl.getAttribLocation(shaderProgram, name));
            }
        }
    }
    uniform(name) {
        return this.uniforms.get(name);
    }
    attribute(name) {
        return this.attributes.get(name);
    }
    textureUnit(symbol) {
        return this.textureUnits.get(symbol);
    }
    bind() {
        curShader = this;
        this.gl.useProgram(this.program);
    }
    disposed() {
        let gl = this.gl;

        gl.deleteShader(this.vertexShader);
        this.vertexShader = undefined;
        gl.deleteShader(this.fragmentShader);
        this.fragmentShader = undefined;
        gl.deleteProgram(this.program);
        this.program = undefined;
        this.gl = undefined;
        this.attributes = undefined;
        this.uniforms = undefined;
    }
}
export function drawArraysInstanced(gl, mode, first, count, instanceCount) {
    gl.drawArraysInstanced(mode, first, count, instanceCount);
    if (!DEBUG_SHADER || !(curShader === null || curShader === void 0 ? void 0 : curShader.vertexDebugOutputs)) {
        return;
    }
    var _curShader = curShader;
    const vertexDebugOutputs = _curShader.vertexDebugOutputs;

    let bytesPerVertex = 0;
    for (const debugOutput of vertexDebugOutputs) {
        bytesPerVertex += DEBUG_OUTPUT_TYPE_TO_BYTES[debugOutput.typeName];
    }
    const buffer = gl.createBuffer();
    const totalBytes = bytesPerVertex * count * instanceCount;
    gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, buffer);
    gl.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, totalBytes, WebGL2RenderingContext.DYNAMIC_DRAW);
    gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
    gl.bindBufferBase(WebGL2RenderingContext.TRANSFORM_FEEDBACK_BUFFER, 0, buffer);
    gl.beginTransformFeedback(WebGL2RenderingContext.POINTS);
    gl.enable(WebGL2RenderingContext.RASTERIZER_DISCARD);
    gl.drawArraysInstanced(WebGL2RenderingContext.POINTS, first, count, instanceCount);
    gl.disable(WebGL2RenderingContext.RASTERIZER_DISCARD);
    gl.endTransformFeedback();
    gl.bindBufferBase(WebGL2RenderingContext.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, buffer);
    const array = new Uint8Array(totalBytes);
    gl.getBufferSubData(WebGL2RenderingContext.ARRAY_BUFFER, 0, array, 0, totalBytes);
    gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
    gl.deleteBuffer(buffer);
    let offset = 0;
    const floatView = new Float32Array(array.buffer);
    for (let instance = 0; instance < instanceCount; ++instance) {
        for (let vertex = 0; vertex < count; ++vertex) {
            let msg = `i=${instance} v=${vertex}:`;
            for (const debugOutput of vertexDebugOutputs) {
                msg += ` ${debugOutput.name}=`;
                switch (debugOutput.typeName) {
                    case 'float':
                        msg += `${floatView[offset++]}`;
                        break;
                    case 'vec2':
                        msg += `${floatView[offset++]},${floatView[offset++]}`;
                        break;
                    case 'vec3':
                        msg += `${floatView[offset++]},${floatView[offset++]},${floatView[offset++]}`;
                        break;
                    case 'vec4':
                        msg += `${floatView[offset++]},${floatView[offset++]},${floatView[offset++]},${floatView[offset++]}`;
                        break;
                }
            }
            console.log(msg);
        }
    }
}
export class ShaderCode {
    constructor() {
        this.code = '';
        this.parts = new _Set();
    }
    add(x) {
        if (this.parts.has(x)) {
            return;
        }
        this.parts.add(x);
        switch (typeof x) {
            case 'string':
                this.code += x;
                break;
            case 'function':
                this.add(x());
                break;
            default:
                if (Array.isArray(x)) {
                    for (let y of x) {
                        this.add(y);
                    }
                } else {
                    console.log('Invalid code type', x);
                    throw new Error('Invalid code type');
                }
        }
    }
    toString() {
        return this.code;
    }
}
export const textureTargetForSamplerType = {
    'sampler2D': WebGL2RenderingContext.TEXTURE_2D,
    'isampler2D': WebGL2RenderingContext.TEXTURE_2D,
    'usampler2D': WebGL2RenderingContext.TEXTURE_2D,
    'sampler3D': WebGL2RenderingContext.TEXTURE_3D,
    'isampler3D': WebGL2RenderingContext.TEXTURE_3D,
    'usampler3D': WebGL2RenderingContext.TEXTURE_3D
};
const DEBUG_OUTPUT_TYPE_TO_BYTES = {
    'float': 4,
    'vec2': 8,
    'vec3': 12,
    'vec4': 16
};
export class ShaderBuilder {
    constructor(gl) {
        this.gl = gl;
        this.nextSymbolID = 0;
        this.nextTextureUnit = 0;
        this.uniformsCode = '';
        this.attributesCode = '';
        this.varyingsCodeVS = '';
        this.varyingsCodeFS = '';
        this.fragmentExtensionsSet = new _Set();
        this.fragmentExtensions = '';
        this.vertexCode = new ShaderCode();
        this.vertexMain = '';
        this.fragmentCode = new ShaderCode();
        this.outputBufferCode = '';
        this.fragmentMain = '';
        this.required = new _Set();
        this.uniforms = new Array();
        this.attributes = new Array();
        this.initializers = [];
        this.textureUnits = new _Map();
        this.vertexDebugOutputs = [];
    }
    addVertexPositionDebugOutput() {
        this.vertexDebugOutputs.push({ typeName: 'vec4', name: 'gl_Position' });
    }
    addVertexDebugOutput(typeName, name) {
        this.addVarying(typeName, name);
        this.vertexDebugOutputs.push({ typeName, name });
    }
    allocateTextureUnit(symbol, count = 1) {
        if (this.textureUnits.has(symbol)) {
            throw new Error('Duplicate texture unit symbol: ' + symbol.toString());
        }
        let old = this.nextTextureUnit;
        this.nextTextureUnit += count;
        this.textureUnits.set(symbol, old);
        return old;
    }
    addTextureSampler(samplerType, name, symbol, extent) {
        let textureUnit = this.allocateTextureUnit(symbol, extent);
        this.addUniform(`highp ${samplerType}`, name, extent);
        this.addInitializer(shader => {
            if (extent) {
                let textureUnits = new Int32Array(extent);
                for (let i = 0; i < extent; ++i) {
                    textureUnits[i] = i + textureUnit;
                }
                shader.gl.uniform1iv(shader.uniform(name), textureUnits);
            } else {
                shader.gl.uniform1i(shader.uniform(name), textureUnit);
            }
        });
        return textureUnit;
    }
    symbol(name) {
        return name + this.nextSymbolID++;
    }
    addAttribute(typeName, name, location) {
        this.attributes.push(name);
        if (location !== undefined) this.attributesCode += `layout(location = ${location})`;
        this.attributesCode += `in ${typeName} ${name};\n`;
        return name;
    }
    addVarying(typeName, name, interpolationMode = '') {
        this.varyingsCodeVS += `${interpolationMode} out ${typeName} ${name};\n`;
        this.varyingsCodeFS += `${interpolationMode} in ${typeName} ${name};\n`;
    }
    addOutputBuffer(typeName, name, location) {
        if (location !== null) {
            this.outputBufferCode += `layout(location = ${location}) `;
        }
        this.outputBufferCode += `out ${typeName} ${name};\n`;
    }
    addUniform(typeName, name, extent) {
        this.uniforms.push(name);
        if (extent != null) {
            this.uniformsCode += `uniform ${typeName} ${name}[${extent}];\n`;
        } else {
            this.uniformsCode += `uniform ${typeName} ${name};\n`;
        }
        return name;
    }
    addFragmentExtension(name) {
        if (this.fragmentExtensionsSet.has(name)) {
            return;
        }
        this.fragmentExtensionsSet.add(name);
        this.fragmentExtensions += `#extension ${name} : require\n`;
    }
    addVertexCode(code) {
        this.vertexCode.add(code);
    }
    addFragmentCode(code) {
        this.fragmentCode.add(code);
    }
    setVertexMain(code) {
        this.vertexMain = code;
    }
    addVertexMain(code) {
        this.vertexMain = (this.vertexMain || '') + code;
    }
    setFragmentMain(code) {
        this.fragmentMain = `void main() {
${code}
}
`;
    }
    setFragmentMainFunction(code) {
        this.fragmentMain = code;
    }
    addInitializer(f) {
        this.initializers.push(f);
    }
    require(f) {
        if (this.required.has(f)) {
            return;
        }
        this.required.add(f);
        f(this);
    }
    build() {
        let vertexSource = `#version 300 es
precision highp float;
precision highp int;
${this.uniformsCode}
${this.attributesCode}
${this.varyingsCodeVS}
${this.vertexCode}
void main() {
${this.vertexMain}
}
`;
        let fragmentSource = `#version 300 es
${this.fragmentExtensions}
precision highp float;
precision highp int;
${this.uniformsCode}
${this.varyingsCodeFS}
${this.outputBufferCode}
${this.fragmentCode}
${this.fragmentMain}
`;
        let shader = new ShaderProgram(this.gl, vertexSource, fragmentSource, this.uniforms, this.attributes, this.vertexDebugOutputs);
        shader.textureUnits = this.textureUnits;
        let initializers = this.initializers;

        if (initializers.length > 0) {
            shader.bind();
            for (let initializer of initializers) {
                initializer(shader);
            }
        }
        return shader;
    }
}
export function shaderContainsIdentifiers(code, identifiers) {
    let found = new _Set();
    for (let identifier of identifiers) {
        let pattern = new RegExp(`(?:^|[^a-zA-Z0-9_])${identifier}[^a-zA-Z0-9_])`);
        if (code.match(pattern) !== null) {
            found.add(identifier);
        }
    }
    return found;
}
//# sourceMappingURL=shader.js.map