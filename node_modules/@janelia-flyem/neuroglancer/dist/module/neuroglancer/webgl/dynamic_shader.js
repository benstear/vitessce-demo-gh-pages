import _Object$assign from 'babel-runtime/core-js/object/assign';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { constantWatchableValue, WatchableValue } from '../trackable_value';
import { TrackableValue } from '../trackable_value';
import { stableStringify, verifyString } from '../util/json';
import { getObjectId } from '../util/object_id';
import { ShaderBuilder } from './shader';
export function makeWatchableShaderError() {
    return new WatchableValue(undefined);
}
export function makeTrackableFragmentMain(value) {
    return new TrackableValue(value, verifyString);
}
export function parameterizedContextDependentShaderGetter(refCounted, gl, options) {
    const shaders = new _Map();
    const parameters = options.parameters,
          fallbackParameters = options.fallbackParameters,
          shaderError = options.shaderError;
    var _options$encodeParame = options.encodeParameters;
    const encodeParameters = _options$encodeParame === undefined ? p => p : _options$encodeParame;
    var _options$extraParamet = options.extraParameters;
    const extraParameters = _options$extraParamet === undefined ? constantWatchableValue(undefined) : _options$extraParamet;
    var _options$encodeExtraP = options.encodeExtraParameters;
    const encodeExtraParameters = _options$encodeExtraP === undefined ? p => p : _options$encodeExtraP,
          getContextKey = options.getContextKey,
          defineShader = options.defineShader;

    if (shaderError !== undefined) {
        shaderError.value = undefined;
    }
    var _options$encodeContex = options.encodeContext;
    const encodeContext = _options$encodeContex === undefined ? getContextKey : _options$encodeContex;

    const stringMemoizeKey = stableStringify(options.memoizeKey);
    function getNewShader(context, parameters, extraParameters) {
        const key = _JSON$stringify({
            id: stringMemoizeKey,
            context: encodeContext(context),
            parameters: encodeParameters(parameters),
            extraParameters: encodeExtraParameters(extraParameters)
        });
        return gl.memoize.get(key, () => {
            const builder = new ShaderBuilder(gl);
            defineShader(builder, context, parameters, extraParameters);
            return builder.build();
        });
    }
    function getter(context) {
        const contextKey = getContextKey(context);
        let entry = shaders.get(contextKey);
        if (entry === undefined) {
            entry = {
                parametersGeneration: -1,
                extraParametersGeneration: -1,
                shader: null,
                fallback: false,
                parameters: parameters.value,
                extraParameters: extraParameters.value
            };
            shaders.set(contextKey, entry);
        }
        const parametersGeneration = parameters.changed.count;
        const extraParametersGeneration = extraParameters.changed.count;
        if (parametersGeneration === entry.parametersGeneration && extraParametersGeneration === entry.extraParametersGeneration) {
            return entry;
        }
        const parametersValue = entry.parameters = parameters.value;
        const extraParametersValue = entry.extraParameters = extraParameters.value;
        const oldShader = entry.shader;
        entry.parametersGeneration = parametersGeneration;
        entry.extraParametersGeneration = extraParametersGeneration;
        let newShader = null;
        try {
            newShader = getNewShader(context, parametersValue, extraParametersValue);
            entry.fallback = false;
            if (fallbackParameters !== undefined) {
                fallbackParameters.value = parametersValue;
            }
            if (shaderError !== undefined) {
                shaderError.value = null;
            }
        } catch (e) {
            if (shaderError !== undefined) {
                shaderError.value = e;
            }
            if (fallbackParameters !== undefined) {
                try {
                    const fallbackParametersValue = fallbackParameters.value;
                    newShader = getNewShader(context, fallbackParametersValue, extraParametersValue);
                    entry.parameters = fallbackParametersValue;
                    entry.fallback = true;
                } catch (_a) {}
            }
        }
        if (oldShader !== null) {
            oldShader.dispose();
        }
        entry.shader = newShader;
        return entry;
    }
    refCounted.registerDisposer(() => {
        for (const entry of shaders.values()) {
            const shader = entry.shader;

            if (shader !== null) {
                shader.dispose();
            }
        }
    });
    return getter;
}
export function parameterizedEmitterDependentShaderGetter(refCounted, gl, options) {
    return parameterizedContextDependentShaderGetter(refCounted, gl, _Object$assign(_Object$assign({}, options), { getContextKey: emitter => emitter, encodeContext: emitter => getObjectId(emitter), defineShader: (builder, emitter, parameters, extraParameters) => {
            builder.require(emitter);
            return options.defineShader(builder, parameters, extraParameters);
        } }));
}
export function shaderCodeWithLineDirective(code, sourceStringNumber = 1, line = 0) {
    return `\n#line ${line} ${sourceStringNumber}\n` + code;
}
//# sourceMappingURL=dynamic_shader.js.map