/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { RefCounted } from '../util/disposable';
import { identityMat4 } from '../util/geom';
import { getObjectId } from '../util/object_id';
import { getSquareCornersBuffer } from './square_corners_buffer';
import { resizeTexture } from './texture';
import { defineCopyFragmentShader, elementWiseTextureShader } from './trivial_shaders';
export class SizeManaged extends RefCounted {
    constructor() {
        super(...arguments);
        this.width = Number.NaN;
        this.height = Number.NaN;
    }
    hasSize(width, height) {
        return this.width === width && this.height === height;
    }
    resize(width, height) {
        if (this.hasSize(width, height)) {
            return;
        }
        this.width = width;
        this.height = height;
        this.performResize();
    }
}
export class Renderbuffer extends SizeManaged {
    constructor(gl, internalformat) {
        super();
        this.gl = gl;
        this.internalformat = internalformat;
        this.renderbuffer = null;
        this.renderbuffer = gl.createRenderbuffer();
    }
    performResize() {
        let gl = this.gl;

        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, this.internalformat, this.width, this.height);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
    disposed() {
        this.gl.deleteRenderbuffer(this.renderbuffer);
    }
    attachToFramebuffer(attachment) {
        let gl = this.gl;

        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, this.renderbuffer);
    }
}
export class DepthRenderbuffer extends Renderbuffer {
    constructor(gl, includeStencilBuffer = false) {
        super(gl, includeStencilBuffer ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT16);
        this.gl = gl;
        this.includeStencilBuffer = includeStencilBuffer;
    }
    attachToFramebuffer() {
        let gl = this.gl;

        super.attachToFramebuffer(this.includeStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
    }
}
export class DepthStencilRenderbuffer extends DepthRenderbuffer {
    constructor(gl) {
        super(gl, /*includeStencilBuffer=*/true);
    }
}
export const StencilRenderbuffer = DepthStencilRenderbuffer;
export class Framebuffer extends RefCounted {
    constructor(gl) {
        super();
        this.gl = gl;
        this.framebuffer = this.gl.createFramebuffer();
    }
    disposed() {
        let gl = this.gl;

        gl.deleteFramebuffer(this.framebuffer);
    }
    bind() {
        let gl = this.gl;

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    }
    unbind() {
        let gl = this.gl;

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
}
export class TextureBuffer extends SizeManaged {
    constructor(gl, internalFormat, format, dataType) {
        super();
        this.gl = gl;
        this.internalFormat = internalFormat;
        this.format = format;
        this.dataType = dataType;
        this.texture = gl.createTexture();
    }
    performResize() {
        resizeTexture(this.gl, this.texture, this.width, this.height, this.internalFormat, this.format, this.dataType);
    }
    disposed() {
        this.gl.deleteTexture(this.texture);
    }
    attachToFramebuffer(attachment) {
        let gl = this.gl;

        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, this.texture, /*level=*/0);
    }
}
export class DepthTextureBuffer extends TextureBuffer {
    constructor(gl, internalFormat = WebGL2RenderingContext.DEPTH_COMPONENT16, format = WebGL2RenderingContext.DEPTH_COMPONENT, dataType = WebGL2RenderingContext.UNSIGNED_SHORT) {
        super(gl, internalFormat, format, dataType);
    }
    attachToFramebuffer() {
        super.attachToFramebuffer(this.format === WebGL2RenderingContext.DEPTH_COMPONENT ? WebGL2RenderingContext.DEPTH_ATTACHMENT : WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT);
    }
}
export function makeTextureBuffers(gl, count, internalFormat = WebGL2RenderingContext.RGBA8, format = WebGL2RenderingContext.RGBA, dataType = WebGL2RenderingContext.UNSIGNED_BYTE) {
    let result = new Array();
    for (let i = 0; i < count; ++i) {
        result[i] = new TextureBuffer(gl, internalFormat, format, dataType);
    }
    return result;
}
export class FramebufferConfiguration extends RefCounted {
    constructor(gl, configuration) {
        super();
        this.gl = gl;
        this.width = Number.NaN;
        this.height = Number.NaN;
        this.fullAttachmentList = new Array();
        this.attachmentVerified = false;
        this.singleAttachmentList = [this.gl.COLOR_ATTACHMENT0];
        var _configuration$frameb = configuration.framebuffer;
        let framebuffer = _configuration$frameb === undefined ? new Framebuffer(gl) : _configuration$frameb,
            colorBuffers = configuration.colorBuffers,
            depthBuffer = configuration.depthBuffer;

        this.framebuffer = this.registerDisposer(framebuffer);
        this.colorBuffers = colorBuffers;
        this.depthBuffer = depthBuffer;
        if (depthBuffer !== undefined) {
            this.registerDisposer(depthBuffer);
        }
        let fullAttachmentList = this.fullAttachmentList;

        colorBuffers.forEach((buffer, i) => {
            this.registerDisposer(buffer);
            fullAttachmentList[i] = gl.COLOR_ATTACHMENT0 + i;
        });
    }
    hasSize(width, height) {
        return this.width === width && this.height === height;
    }
    bind(width, height) {
        this.width = width;
        this.height = height;
        this.framebuffer.bind();
        let gl = this.gl,
            depthBuffer = this.depthBuffer;

        if (depthBuffer !== undefined) {
            depthBuffer.resize(width, height);
            depthBuffer.attachToFramebuffer();
        } else {
            gl.framebufferRenderbuffer(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT, WebGL2RenderingContext.RENDERBUFFER, null);
        }
        this.colorBuffers.forEach((buffer, i) => {
            buffer.resize(width, height);
            buffer.attachToFramebuffer(gl.COLOR_ATTACHMENT0 + i);
        });
        gl.drawBuffers(this.fullAttachmentList);
        this.verifyAttachment();
        gl.viewport(0, 0, width, height);
    }
    bindSingle(textureIndex) {
        let gl = this.gl;

        this.framebuffer.bind();
        // If this texture is still be bound to color attachment textureIndex, the attachment will fail
        // (at least on some browsers).  Therefore, if textureIndex is not 0, we clear the attachment.
        // In the case that textureIndex is 0, the attachment will be overridden anyway.
        if (textureIndex !== 0) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + textureIndex, gl.TEXTURE_2D, null, /*level=*/0);
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        this.colorBuffers[textureIndex].attachToFramebuffer(gl.COLOR_ATTACHMENT0);
        gl.drawBuffers(this.singleAttachmentList);
    }
    unbind() {
        this.framebuffer.unbind();
    }
    readPixelFloat32IntoBuffer(textureIndex, glWindowX, glWindowY, offset, width = 1, height = 1) {
        let gl = this.gl;

        try {
            this.bindSingle(textureIndex);
            // Reading just the red channel using a format of RED fails with certain WebGL
            // implementations.  Using RGBA seems to have better compatibility.
            gl.readPixels(glWindowX, glWindowY, width, height, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, offset);
        } finally {
            this.framebuffer.unbind();
        }
    }
    verifyAttachment() {
        if (this.attachmentVerified) {
            return;
        }
        let gl = this.gl;

        let framebufferStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (framebufferStatus !== gl.FRAMEBUFFER_COMPLETE) {
            throw new Error(`Framebuffer configuration not supported: ${framebufferStatus}`);
        }
        this.attachmentVerified = true;
    }
}
export class OffscreenCopyHelper extends RefCounted {
    constructor(gl, shader) {
        super();
        this.gl = gl;
        this.shader = shader;
        this.copyVertexPositionsBuffer = getSquareCornersBuffer(this.gl);
        this.copyTexCoordsBuffer = getSquareCornersBuffer(this.gl, 0, 0, 1, 1);
        this.registerDisposer(shader);
    }
    draw(...textures) {
        let gl = this.gl,
            shader = this.shader;

        shader.bind();
        let numTextures = textures.length;
        for (let i = 0; i < numTextures; ++i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, textures[i]);
        }
        gl.uniformMatrix4fv(shader.uniform('uProjectionMatrix'), false, identityMat4);
        let aVertexPosition = shader.attribute('aVertexPosition');
        this.copyVertexPositionsBuffer.bindToVertexAttrib(aVertexPosition, /*components=*/2);
        let aTexCoord = shader.attribute('aTexCoord');
        this.copyTexCoordsBuffer.bindToVertexAttrib(aTexCoord, /*components=*/2);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        gl.disableVertexAttribArray(aVertexPosition);
        gl.disableVertexAttribArray(aTexCoord);
        for (let i = 0; i < numTextures; ++i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }
    static get(gl, shaderModule = defineCopyFragmentShader, numTextures = 1) {
        return gl.memoize.get(`OffscreenCopyHelper:${numTextures}:${getObjectId(shaderModule)}`, () => new OffscreenCopyHelper(gl, elementWiseTextureShader(gl, shaderModule, numTextures)));
    }
}
//# sourceMappingURL=offscreen.js.map