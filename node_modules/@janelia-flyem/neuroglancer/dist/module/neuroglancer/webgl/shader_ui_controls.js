import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Number$isInteger from 'babel-runtime/core-js/number/is-integer';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { TrackableBoolean } from '../trackable_boolean';
import { constantWatchableValue, makeCachedDerivedWatchableValue, makeCachedLazyDerivedWatchableValue, TrackableValue } from '../trackable_value';
import { arraysEqual, arraysEqualWithPredicate } from '../util/array';
import { parseRGBColorSpecification, TrackableRGB } from '../util/color';
import { RefCounted } from '../util/disposable';
import { parseFixedLengthArray, verifyFiniteFloat, verifyInt, verifyObject, verifyOptionalObjectProperty } from '../util/json';
import { dataTypeIntervalToJson, defaultDataTypeRange, normalizeDataTypeInterval, parseDataTypeInterval, validateDataTypeInterval } from '../util/lerp';
import { NullarySignal } from '../util/signal';
import { HistogramSpecifications } from './empirical_cdf';
import { defineInvlerpShaderFunction, enableLerpShaderFunction } from './lerp';
// Strips comments from GLSL code.  Also handles string literals since they are used in ui control
// directives.
export function stripComments(code) {
    // https://stackoverflow.com/a/241506
    const commentPattern = /\/\/.*?$|\/\*(?:.|\n)*?\*\/|'(?:\\.|[^\\'])*'|"(?:\\.|[^\\"])*"/mg;
    return code.replace(commentPattern, m => {
        if (m.startsWith('/')) {
            return m.replace(/[^\s]/g, ' ');
        }
        return m;
    });
}
// Returns the length of the prefix that may be a valid directive parameter.
function matchDirectiveParameterValue(input) {
    const valueTokenPattern = /^(?:-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?|"(?:\\.|[^\\"])*"|true|false|:|\s+|,|\[|\]|\{|\})/;
    let depth = 0;
    let initialInput = input;
    outerLoop: while (input.length) {
        const m = input.match(valueTokenPattern);
        if (m === null) break;
        const token = m[0];
        switch (token.charAt(0)) {
            case '[':
            case '{':
                ++depth;
                break;
            case ']':
            case '}':
                if (--depth < 0) return -1;
                break;
            case ',':
                if (depth === 0) break outerLoop;
                break;
            default:
                if (depth === 0) {
                    input = input.substring(token.length);
                    break outerLoop;
                }
                break;
        }
        input = input.substring(token.length);
    }
    if (depth !== 0) return -1;
    return initialInput.length - input.length;
}
export function parseDirectiveParameters(input) {
    let errors = [];
    let parameters = new _Map();
    if (input === undefined) {
        return { errors, parameters };
    }
    const startPattern = /^([_a-z][_a-zA-Z0-9]*)[ \t]*=/;
    while (true) {
        input = input.trim();
        if (input.length == 0) break;
        const m = input.match(startPattern);
        if (m === null) {
            errors.push('Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...');
            break;
        }
        const name = m[1];
        input = input.substring(m[0].length);
        let valueLength = matchDirectiveParameterValue(input);
        if (valueLength <= 0) {
            errors.push('Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...');
            break;
        }
        let value;
        try {
            value = JSON.parse(input.substring(0, valueLength));
        } catch (_a) {
            errors.push(`Invalid #uicontrol parameter value for ${name}: ${value}`);
            break;
        }
        if (parameters.has(name)) {
            errors.push(`Duplicate #uicontrol parameter: ${name}`);
        } else {
            parameters.set(name, value);
        }
        input = input.substring(valueLength);
        input = input.trim();
        if (input.length > 0 && !input.startsWith(',')) {
            errors.push('Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...');
        }
        input = input.substring(1);
    }
    return { parameters, errors };
}
function parseSliderDirective(valueType, parameters) {
    let min;
    let max;
    let step;
    let defaultValue;
    let errors = [];
    if (valueType !== 'float' && valueType !== 'uint' && valueType !== 'int') {
        errors.push('type must be float, int, or uint');
    }
    for (const _ref of parameters) {
        var _ref2 = _slicedToArray(_ref, 2);

        const key = _ref2[0];
        const value = _ref2[1];

        const getValue = () => {
            if (typeof value !== 'number') {
                errors.push(`Expected ${key} argument to be a number`);
                return undefined;
            }
            if (valueType === 'int' || valueType === 'uint') {
                if (!_Number$isInteger(value)) {
                    errors.push(`Expected ${key} argument to be an integer`);
                }
                if (valueType === 'uint' && value < 0) {
                    errors.push(`Expected ${key} argument to be an unsigned integer`);
                }
            }
            return value;
        };
        if (key === 'min') {
            min = getValue();
        } else if (key === 'max') {
            max = getValue();
        } else if (key === 'default') {
            defaultValue = getValue();
        } else if (key === 'step') {
            step = getValue();
        } else {
            errors.push(`Invalid parameter: ${key}`);
        }
    }
    if (min === undefined) {
        errors.push('min must be specified');
    }
    if (max === undefined) {
        errors.push('max must be specified');
    }
    if (min !== undefined && max !== undefined) {
        if (min > max) {
            errors.push('min must be less than max');
        }
        if (step === undefined) {
            if (valueType === 'float') {
                step = (max - min) / 100;
            } else {
                step = 1;
            }
        }
        if (defaultValue !== undefined) {
            if (defaultValue < min || defaultValue > max) {
                errors.push('default must be within valid range');
            }
        } else {
            if (valueType === 'float') {
                defaultValue = (min + max) / 2;
            } else {
                defaultValue = min;
            }
        }
    }
    if (errors.length > 0) {
        return { errors };
    } else {
        return {
            control: { type: 'slider', valueType, min, max, step, default: defaultValue },
            errors: undefined
        };
    }
}
function parseCheckboxDirective(valueType, parameters) {
    let defaultValue = false;
    let errors = [];
    if (valueType !== 'bool') {
        errors.push('type must be bool');
    }
    for (const _ref3 of parameters) {
        var _ref4 = _slicedToArray(_ref3, 2);

        const key = _ref4[0];
        const value = _ref4[1];

        if (key === 'default') {
            if (typeof value !== 'boolean') {
                errors.push(`Expected ${key} argument to be a boolean`);
                continue;
            }
            defaultValue = value;
        } else {
            errors.push(`Invalid parameter: ${key}`);
        }
    }
    if (errors.length > 0) {
        return { errors };
    } else {
        return {
            control: { type: 'checkbox', valueType, default: defaultValue },
            errors: undefined
        };
    }
}
function parseColorDirective(valueType, parameters) {
    let defaultColor = 'white';
    let errors = [];
    if (valueType !== 'vec3') {
        errors.push('type must be vec3');
    }
    for (const _ref5 of parameters) {
        var _ref6 = _slicedToArray(_ref5, 2);

        const key = _ref6[0];
        const value = _ref6[1];

        if (key === 'default') {
            if (typeof value !== 'string') {
                errors.push(`Expected default argument to be a string`);
            } else {
                defaultColor = value;
            }
        } else {
            errors.push(`Invalid parameter: ${key}`);
        }
    }
    if (errors.length > 0) {
        return { errors };
    }
    return {
        control: {
            type: 'color',
            valueType,
            defaultString: defaultColor,
            default: parseRGBColorSpecification(defaultColor)
        },
        errors: undefined
    };
}
function parseInvlerpChannel(value, rank) {
    if (typeof value === 'number') {
        value = [value];
    }
    const channel = new Array(rank);
    parseFixedLengthArray(channel, value, x => {
        if (!_Number$isInteger(x) || x < 0) {
            throw new Error(`Expected non-negative integer, but received: ${_JSON$stringify(x)}`);
        }
        return x;
    });
    return channel;
}
function parseInvlerpDirective(valueType, parameters, dataContext) {
    let errors = [];
    const imageData = dataContext.imageData;

    if (imageData === undefined) {
        errors.push('invlerp control not supported');
        return { errors };
    }
    if (valueType !== 'invlerp') {
        errors.push('type must be invlerp');
    }
    let channel = new Array(imageData.channelRank).fill(0);
    const dataType = imageData.dataType;

    let clamp = true;
    let range = defaultDataTypeRange[dataType];
    let window;
    for (let _ref7 of parameters) {
        var _ref8 = _slicedToArray(_ref7, 2);

        let key = _ref8[0];
        let value = _ref8[1];

        try {
            switch (key) {
                case 'range':
                    {
                        range = parseDataTypeInterval(value, dataType);
                        break;
                    }
                case 'window':
                    {
                        window = validateDataTypeInterval(parseDataTypeInterval(value, dataType));
                        break;
                    }
                case 'clamp':
                    {
                        if (typeof value !== 'boolean') {
                            errors.push(`Invalid clamp value: ${_JSON$stringify(value)}`);
                        } else {
                            clamp = value;
                        }
                        break;
                    }
                case 'channel':
                    {
                        channel = parseInvlerpChannel(value, channel.length);
                        break;
                    }
                default:
                    errors.push(`Invalid parameter: ${key}`);
                    break;
            }
        } catch (e) {
            errors.push(`Invalid ${key} value: ${e.message}`);
        }
    }
    if (errors.length > 0) {
        return { errors };
    }
    return {
        control: {
            type: 'invlerp',
            dataType,
            clamp,
            default: { range, window: window !== null && window !== void 0 ? window : normalizeDataTypeInterval(range), channel }
        },
        errors: undefined
    };
}
const controlParsers = new _Map([['slider', parseSliderDirective], ['color', parseColorDirective], ['invlerp', parseInvlerpDirective], ['checkbox', parseCheckboxDirective]]);
export function parseShaderUiControls(code, dataContext = {}) {
    code = stripComments(code);
    // Matches any #uicontrols directive.  Syntax errors in the directive are handled later.
    const directivePattern = /^[ \t]*#[ \t]*uicontrol[ \t]+(.*)$/mg;
    const innerPattern = /^([_a-zA-Z][_a-zA-Z0-9]*)[ \t]+([a-z][a-zA-Z0-9_]*)(?:[ \t]+([a-z]+))?[ \t]*(?:\([ \t]*(.*)\)[ \t]*)?/;
    let errors = [];
    const controls = new _Map();
    const newCode = code.replace(directivePattern, (_match, innerPart, offset) => {
        var _a;
        const m = innerPart.match(innerPattern);
        const getLineNumber = () => {
            return Math.max(0, code.substring(0, offset).split('\n').length - 1);
        };
        if (m === null) {
            errors.push({
                line: getLineNumber(),
                message: 'Invalid #uicontrol syntax, expected: #uicontrol <type> <name> <control>(<param>=<value>, ...)'
            });
            return '';
        }
        const typeName = m[1];
        const variableName = m[2];
        const controlName = (_a = m[3]) !== null && _a !== void 0 ? _a : typeName;
        const parameterText = m[4];

        var _parseDirectiveParame = parseDirectiveParameters(parameterText);

        const parameters = _parseDirectiveParame.parameters,
              innerErrors = _parseDirectiveParame.errors;

        for (const error of innerErrors) {
            errors.push({ line: getLineNumber(), message: error });
        }
        if (controls.has(variableName)) {
            errors.push({ line: getLineNumber(), message: `Duplicate definition for control ${variableName}` });
        }
        if (innerErrors.length > 0) {
            return '';
        }
        const parser = controlParsers.get(controlName);
        if (parser === undefined) {
            errors.push({ line: getLineNumber(), message: `Invalid control type ${controlName}` });
            return '';
        }
        const result = parser(typeName, parameters, dataContext);
        if (result.errors !== undefined) {
            for (const error of result.errors) {
                errors.push({ line: getLineNumber(), message: error });
            }
            return '';
        }
        controls.set(variableName, result.control);
        return '';
    });
    return { source: code, code: newCode, errors, controls };
}
function uniformName(controlName) {
    return `u_shaderControl_${controlName}`;
}
export function addControlsToBuilder(builderState, builder) {
    const builderValues = builderState.builderValues;

    for (const _ref9 of builderState.parseResult.controls) {
        var _ref10 = _slicedToArray(_ref9, 2);

        const name = _ref10[0];
        const control = _ref10[1];

        const uName = uniformName(name);
        const builderValue = builderValues[name];
        switch (control.type) {
            case 'invlerp':
                {
                    const code = [defineInvlerpShaderFunction(builder, uName, control.dataType, control.clamp), `
float ${uName}() {
  return ${uName}(getDataValue(${builderValue.channel.join(',')}));
}
`];
                    builder.addFragmentCode(code);
                    builder.addFragmentCode(`#define ${name} ${uName}\n`);
                    break;
                }
            case 'checkbox':
                {
                    const code = `#define ${name} ${builderValue.value}\n`;
                    builder.addFragmentCode(code);
                    builder.addVertexCode(code);
                    break;
                }
            default:
                {
                    builder.addUniform(`highp ${control.valueType}`, uName);
                    builder.addVertexCode(`#define ${name} ${uName}\n`);
                    builder.addFragmentCode(`#define ${name} ${uName}\n`);
                    break;
                }
        }
    }
}
function objectFromEntries(entries) {
    const obj = {};
    for (const _ref11 of entries) {
        var _ref12 = _slicedToArray(_ref11, 2);

        const key = _ref12[0];
        const value = _ref12[1];

        obj[key] = value;
    }
    return obj;
}
function encodeControls(controls) {
    if (controls === undefined) return undefined;
    return _JSON$stringify(objectFromEntries(controls));
}
export class WatchableShaderUiControls {
    constructor() {
        this.changed = new NullarySignal();
        this.controls = undefined;
    }
    get value() {
        return this.controls;
    }
    set value(newControls) {
        if (encodeControls(newControls) === encodeControls(this.controls)) {
            return;
        }
        this.controls = newControls;
        this.changed.dispatch();
    }
}
function parseInvlerpParameters(obj, dataType, defaultValue) {
    if (obj === undefined) return defaultValue;
    verifyObject(obj);
    return {
        range: verifyOptionalObjectProperty(obj, 'range', x => parseDataTypeInterval(x, dataType), defaultValue.range),
        window: verifyOptionalObjectProperty(obj, 'window', x => validateDataTypeInterval(parseDataTypeInterval(x, dataType)), defaultValue.window),
        channel: verifyOptionalObjectProperty(obj, 'channel', x => parseInvlerpChannel(x, defaultValue.channel.length), defaultValue.channel)
    };
}
class TrackableInvlerpParameters extends TrackableValue {
    constructor(dataType, defaultValue) {
        super(defaultValue, obj => parseInvlerpParameters(obj, dataType, defaultValue));
        this.dataType = dataType;
        this.defaultValue = defaultValue;
    }
    toJSON() {
        var _value = this.value;
        const range = _value.range,
              window = _value.window,
              channel = _value.channel,
              dataType = this.dataType,
              defaultValue = this.defaultValue;

        const rangeJson = dataTypeIntervalToJson(range, dataType, defaultValue.range);
        const windowJson = dataTypeIntervalToJson(window, dataType, defaultValue.window);
        const channelJson = arraysEqual(defaultValue.channel, channel) ? undefined : channel;
        if (rangeJson === undefined && windowJson === undefined && channelJson === undefined) {
            return undefined;
        }
        return { range: rangeJson, window: windowJson, channel: channelJson };
    }
}
function getControlTrackable(control) {
    switch (control.type) {
        case 'slider':
            return {
                trackable: new TrackableValue(control.default, x => {
                    let v;
                    if (control.valueType === 'float') {
                        v = verifyFiniteFloat(x);
                    } else {
                        v = verifyInt(x);
                    }
                    if (v < control.min || v > control.max) {
                        throw new Error(`${_JSON$stringify(x)} is outside valid range [${control.min}, ${control.max}]`);
                    }
                    return v;
                }),
                getBuilderValue: () => null
            };
        case 'color':
            return { trackable: new TrackableRGB(control.default), getBuilderValue: () => null };
        case 'invlerp':
            return {
                trackable: new TrackableInvlerpParameters(control.dataType, control.default),
                getBuilderValue: value => ({ channel: value.channel, dataType: control.dataType })
            };
        case 'checkbox':
            return {
                trackable: new TrackableBoolean(control.default),
                getBuilderValue: value => ({ value })
            };
    }
}
function encodeBuilderStateKey(builderValues, parseResult) {
    return _JSON$stringify(builderValues) + '\0' + parseResult.source;
}
export function getFallbackBuilderState(parseResult) {
    const builderValues = {};
    for (const _ref13 of parseResult.controls) {
        var _ref14 = _slicedToArray(_ref13, 2);

        const key = _ref14[0];
        const control = _ref14[1];

        var _getControlTrackable = getControlTrackable(control);

        const trackable = _getControlTrackable.trackable,
              getBuilderValue = _getControlTrackable.getBuilderValue;

        builderValues[key] = getBuilderValue(trackable.value);
    }
    return { builderValues, parseResult, key: encodeBuilderStateKey(builderValues, parseResult) };
}
export class ShaderControlState extends RefCounted {
    constructor(fragmentMain, dataContext = constantWatchableValue({}), channelCoordinateSpaceCombiner) {
        super();
        this.fragmentMain = fragmentMain;
        this.dataContext = dataContext;
        this.channelCoordinateSpaceCombiner = channelCoordinateSpaceCombiner;
        this.changed = new NullarySignal();
        this.controls = new WatchableShaderUiControls();
        this.fragmentMainGeneration = -1;
        this.dataContextGeneration = -1;
        this.parseErrors_ = [];
        this.processedFragmentMain_ = '';
        this.controlsGeneration = -1;
        this.parseResultChanged = new NullarySignal();
        this.state_ = new _Map();
        this.unparsedJson = undefined;
        this.registerDisposer(fragmentMain.changed.add(() => this.handleFragmentMainChanged()));
        this.registerDisposer(this.controls.changed.add(() => this.handleControlsChanged()));
        this.registerDisposer(this.dataContext.changed.add(() => this.handleFragmentMainChanged()));
        this.handleFragmentMainChanged();
        const self = this;
        this.parseErrors = {
            changed: this.parseResultChanged,
            get value() {
                self.handleFragmentMainChanged();
                return self.parseErrors_;
            }
        };
        this.processedFragmentMain = {
            changed: this.parseResultChanged,
            get value() {
                self.handleFragmentMainChanged();
                return self.processedFragmentMain_;
            }
        };
        this.parseResult = {
            changed: this.parseResultChanged,
            get value() {
                return self.parseResult_;
            }
        };
        this.builderState = makeCachedDerivedWatchableValue((parseResult, state) => {
            const builderValues = {};
            for (const _ref15 of state) {
                var _ref16 = _slicedToArray(_ref15, 2);

                const key = _ref16[0];
                var _ref16$ = _ref16[1];
                const trackable = _ref16$.trackable;
                const getBuilderValue = _ref16$.getBuilderValue;

                const builderValue = getBuilderValue(trackable.value);
                builderValues[key] = builderValue;
            }
            return {
                key: encodeBuilderStateKey(builderValues, parseResult),
                parseResult,
                builderValues
            };
        }, [this.parseResult, this], (a, b) => a.key === b.key);
        const histogramChannels = makeCachedDerivedWatchableValue(state => {
            const channels = [];
            for (const _ref17 of state.values()) {
                const control = _ref17.control;
                const trackable = _ref17.trackable;

                if (control.type !== 'invlerp') continue;
                channels.push({ channel: trackable.value.channel });
            }
            return channels;
        }, [this], (a, b) => arraysEqualWithPredicate(a, b, (ca, cb) => arraysEqual(ca.channel, cb.channel)));
        const histogramBounds = makeCachedLazyDerivedWatchableValue(state => {
            const bounds = [];
            for (const _ref18 of state.values()) {
                const control = _ref18.control;
                const trackable = _ref18.trackable;

                if (control.type !== 'invlerp') continue;
                bounds.push(trackable.value.window);
            }
            return bounds;
        }, this);
        this.histogramSpecifications = this.registerDisposer(new HistogramSpecifications(histogramChannels, histogramBounds));
    }
    handleFragmentMainChanged() {
        const generation = this.fragmentMain.changed.count;
        const dataContextGeneration = this.dataContext.changed.count;
        if (generation === this.fragmentMainGeneration && dataContextGeneration === this.dataContextGeneration) {
            return;
        }
        this.fragmentMainGeneration = generation;
        this.dataContextGeneration = dataContextGeneration;
        const dataContext = this.dataContext.value;
        if (dataContext === null) {
            this.parseResult_ = {
                source: '',
                code: '',
                controls: new _Map(),
                errors: [{ line: 0, message: 'Loading' }]
            };
            this.parseErrors_ = [];
            this.processedFragmentMain_ = '';
            this.controls.value = undefined;
        } else {
            const result = this.parseResult_ = parseShaderUiControls(this.fragmentMain.value, dataContext);
            this.parseErrors_ = result.errors;
            this.processedFragmentMain_ = result.code;
            if (result.errors.length === 0) {
                this.controls.value = result.controls;
            }
        }
        this.parseResultChanged.dispatch();
    }
    handleControlsChanged() {
        const generation = this.controls.changed.count;
        if (generation === this.controlsGeneration) {
            return;
        }
        this.controlsGeneration = generation;
        const controls = this.controls.value;
        if (controls === undefined) {
            return;
        }
        let changed = false;
        const state_ = this.state_,
              unparsedJson = this.unparsedJson;
        // Remove values in `state` not in `controls`.

        for (const _ref19 of state_) {
            var _ref20 = _slicedToArray(_ref19, 2);

            const name = _ref20[0];
            const controlState = _ref20[1];

            const control = controls.get(name);
            if (control === undefined) {
                controlState.trackable.changed.remove(this.changed.dispatch);
                state_.delete(name);
                changed = true;
                continue;
            }
        }
        for (const _ref21 of controls) {
            var _ref22 = _slicedToArray(_ref21, 2);

            const name = _ref22[0];
            const control = _ref22[1];

            let controlState = state_.get(name);
            if (controlState !== undefined && _JSON$stringify(controlState.control) !== _JSON$stringify(control)) {
                controlState.trackable.changed.remove(this.changed.dispatch);
                controlState = undefined;
            }
            if (controlState === undefined) {
                var _getControlTrackable2 = getControlTrackable(control);

                const trackable = _getControlTrackable2.trackable,
                      getBuilderValue = _getControlTrackable2.getBuilderValue;

                controlState = { control, trackable, getBuilderValue };
                controlState.trackable.changed.add(this.changed.dispatch);
                state_.set(name, controlState);
                changed = true;
            }
            if (unparsedJson !== undefined && unparsedJson.hasOwnProperty(name)) {
                changed = true;
                try {
                    controlState.trackable.restoreState(unparsedJson[name]);
                } catch (_a) {
                    // Ignore error
                }
            }
        }
        if (unparsedJson !== undefined) {
            changed = true;
        }
        this.unparsedJson = undefined;
        if (changed) {
            this.changed.dispatch();
        }
    }
    get state() {
        if (this.controls.changed.count !== this.controlsGeneration) {
            this.handleControlsChanged();
        }
        return this.state_;
    }
    get value() {
        return this.state;
    }
    restoreState(value) {
        if (value === undefined) return;
        const state = this.state;

        verifyObject(value);
        const controls = this.controls.value;
        if (controls === undefined) {
            this.unparsedJson = value;
            this.changed.dispatch();
            return;
        }
        for (const _ref23 of state) {
            var _ref24 = _slicedToArray(_ref23, 2);

            const key = _ref24[0];
            const controlState = _ref24[1];
            const trackable = controlState.trackable;

            trackable.reset();
            if (value.hasOwnProperty(key)) {
                try {
                    trackable.restoreState(value[key]);
                } catch (_a) {
                    // Ignore error
                }
            }
        }
        this.unparsedJson = undefined;
    }
    reset() {
        for (const controlState of this.state.values()) {
            controlState.trackable.reset();
        }
        if (this.unparsedJson !== undefined) {
            this.unparsedJson = undefined;
            this.changed.dispatch();
        }
    }
    toJSON() {
        const state = this.state;
        const unparsedJson = this.unparsedJson;

        if (unparsedJson !== undefined) return unparsedJson;
        const obj = {};
        let empty = true;
        for (const _ref25 of state) {
            var _ref26 = _slicedToArray(_ref25, 2);

            const key = _ref26[0];
            const value = _ref26[1];

            const valueJson = value.trackable.toJSON();
            ;
            if (valueJson !== undefined) {
                obj[key] = valueJson;
                empty = false;
            }
        }
        if (empty) return undefined;
        return obj;
    }
}
function setControlInShader(gl, shader, name, control, value) {
    const uName = uniformName(name);
    const uniform = shader.uniform(uName);
    switch (control.type) {
        case 'slider':
            switch (control.valueType) {
                case 'int':
                case 'uint':
                    gl.uniform1i(uniform, value);
                    break;
                case 'float':
                    gl.uniform1f(uniform, value);
            }
            break;
        case 'color':
            gl.uniform3fv(uniform, value);
            break;
        case 'invlerp':
            enableLerpShaderFunction(shader, uName, control.dataType, value.range);
            break;
        case 'checkbox':
            // Value is hard-coded in shader.
            break;
    }
}
export function setControlsInShader(gl, shader, shaderControlState, controls) {
    const state = shaderControlState.state;

    if (shaderControlState.controls.value === controls) {
        // Case when shader doesn't have any errors.
        for (const _ref27 of state) {
            var _ref28 = _slicedToArray(_ref27, 2);

            const name = _ref28[0];
            const controlState = _ref28[1];

            setControlInShader(gl, shader, name, controlState.control, controlState.trackable.value);
        }
    } else {
        // Case when shader does have errors and we are using the fallback shader, which may have a
        // different/incompatible set of controls.
        for (const _ref29 of controls) {
            var _ref30 = _slicedToArray(_ref29, 2);

            const name = _ref30[0];
            const control = _ref30[1];

            const controlState = state.get(name);
            const value = controlState !== undefined && _JSON$stringify(controlState.control) === _JSON$stringify(control) ? controlState.trackable.value : control.default;
            setControlInShader(gl, shader, name, control, value);
        }
    }
}
//# sourceMappingURL=shader_ui_controls.js.map