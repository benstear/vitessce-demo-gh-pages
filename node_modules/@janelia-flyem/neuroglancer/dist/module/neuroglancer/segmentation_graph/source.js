/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { RefCounted } from '../util/disposable';
import { Uint64 } from '../util/uint64';
export var VisibleSegmentEquivalencePolicy;
(function (VisibleSegmentEquivalencePolicy) {
    VisibleSegmentEquivalencePolicy[VisibleSegmentEquivalencePolicy["MIN_REPRESENTATIVE"] = 0] = "MIN_REPRESENTATIVE";
    VisibleSegmentEquivalencePolicy[VisibleSegmentEquivalencePolicy["MAX_REPRESENTATIVE"] = 1] = "MAX_REPRESENTATIVE";
    VisibleSegmentEquivalencePolicy[VisibleSegmentEquivalencePolicy["REPRESENTATIVE_EXCLUDED"] = 2] = "REPRESENTATIVE_EXCLUDED";
    VisibleSegmentEquivalencePolicy[VisibleSegmentEquivalencePolicy["NONREPRESENTATIVE_EXCLUDED"] = 4] = "NONREPRESENTATIVE_EXCLUDED";
})(VisibleSegmentEquivalencePolicy || (VisibleSegmentEquivalencePolicy = {}));
export class SegmentationGraphSource {}
export class SegmentationGraphSourceConnection extends RefCounted {
    constructor(graph, segmentsState, transform) {
        super();
        this.graph = graph;
        this.segmentsState = segmentsState;
        this.transform = transform;
    }
    createRenderLayers(chunkManager, displayState, localPosition) {
        chunkManager;
        displayState;
        localPosition;
        return [];
    }
}
export function trackWatchableValueSegment(graph, watchable) {
    let lastId;
    let watchDisposer = undefined;
    const handleLocalChange = () => {
        const value = watchable.value;

        if (value === undefined) {
            if (watchDisposer !== undefined) {
                watchDisposer();
                watchDisposer = undefined;
                lastId = undefined;
            }
            return;
        }
        if (lastId != null && Uint64.equal(lastId, value)) {
            return;
        }
        if (watchDisposer !== undefined) {
            watchDisposer();
            watchDisposer = undefined;
            lastId = undefined;
        }
        watchDisposer = graph.trackSegment(value, newId => {
            lastId = newId;
            watchable.value = newId !== null && newId !== void 0 ? newId : undefined;
        });
    };
    handleLocalChange();
    const signalDisposer = watchable.changed.add(handleLocalChange);
    const disposer = () => {
        signalDisposer();
        if (watchDisposer !== undefined) {
            watchDisposer();
            watchDisposer = undefined;
        }
    };
    return disposer;
}
// Returns `true` if `segmentId` is a base segment id, rather than a segment id added to the graph.
export function isBaseSegmentId(segmentId) {
    return segmentId.high >>> 31 ? false : true;
}
export const UNKNOWN_NEW_SEGMENT_ID = new Uint64(0xffffffff, 0xffffffff);
//# sourceMappingURL=source.js.map