import _Object$assign from "babel-runtime/core-js/object/assign";
import _Promise from "babel-runtime/core-js/promise";
import _slicedToArray from "babel-runtime/helpers/slicedToArray";
import _Map from "babel-runtime/core-js/map";
import _JSON$stringify from "babel-runtime/core-js/json/stringify";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import { CHUNK_LAYER_STATISTICS_RPC_ID, CHUNK_MANAGER_RPC_ID, CHUNK_QUEUE_MANAGER_RPC_ID, CHUNK_SOURCE_INVALIDATE_RPC_ID, ChunkState, REQUEST_CHUNK_STATISTICS_RPC_ID } from "./base";
import { SharedWatchableValue } from "../shared_watchable_value";
import { TrackableBoolean } from "../trackable_boolean";
import { TrackableValue } from "../trackable_value";
import { CANCELED } from "../util/cancellation";
import { stableStringify } from "../util/json";
import { StringMemoize } from "../util/memoize";
import { getObjectId } from "../util/object_id";
import { NullarySignal } from "../util/signal";
import { registerPromiseRPC, registerRPC, registerSharedObjectOwner, SharedObject } from "../worker_rpc";
const DEBUG_CHUNK_UPDATES = false;
export class Chunk {
    constructor(source) {
        this.source = source;
        this.state = ChunkState.SYSTEM_MEMORY;
    }
    get gl() {
        return this.source.gl;
    }
    copyToGPU(_gl) {
        this.state = ChunkState.GPU_MEMORY;
    }
    freeGPUMemory(_gl) {
        this.state = ChunkState.SYSTEM_MEMORY;
    }
}
function validateLimitValue(x) {
    if (typeof x !== 'number' || x < 0) {
        throw new Error(`Expected non-negative number as limit, but received: ${_JSON$stringify(x)}`);
    }
    return x;
}
export class CapacitySpecification {
    constructor({ defaultItemLimit = Number.POSITIVE_INFINITY, defaultSizeLimit = Number.POSITIVE_INFINITY } = {}) {
        this.sizeLimit = new TrackableValue(defaultSizeLimit, validateLimitValue);
        this.itemLimit = new TrackableValue(defaultItemLimit, validateLimitValue);
    }
}
let ChunkQueueManager = class ChunkQueueManager extends SharedObject {
    constructor(rpc, gl, frameNumberCounter, capacities) {
        super();
        this.gl = gl;
        this.frameNumberCounter = frameNumberCounter;
        this.capacities = capacities;
        this.visibleChunksChanged = new NullarySignal();
        this.pendingChunkUpdates = null;
        this.pendingChunkUpdatesTail = null;
        /**
         * If non-null, deadline in milliseconds since epoch after which chunk copies to the GPU may not
         * start (until the next frame).
         */
        this.chunkUpdateDeadline = null;
        this.chunkUpdateDelay = 30;
        this.enablePrefetch = new TrackableBoolean(true, true);
        const makeCapacityCounterparts = capacity => {
            return {
                itemLimit: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, capacity.itemLimit)).rpcId,
                sizeLimit: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, capacity.sizeLimit)).rpcId
            };
        };
        this.initializeCounterpart(rpc, {
            'gpuMemoryCapacity': makeCapacityCounterparts(capacities.gpuMemory),
            'systemMemoryCapacity': makeCapacityCounterparts(capacities.systemMemory),
            'downloadCapacity': makeCapacityCounterparts(capacities.download),
            'computeCapacity': makeCapacityCounterparts(capacities.compute),
            'enablePrefetch': this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.enablePrefetch)).rpcId
        });
    }
    scheduleChunkUpdate() {
        let deadline = this.chunkUpdateDeadline;
        let delay;
        if (deadline === null || Date.now() < deadline) {
            delay = 0;
        } else {
            delay = this.chunkUpdateDelay;
        }
        setTimeout(this.processPendingChunkUpdates.bind(this), delay);
    }
    processPendingChunkUpdates(flush = false) {
        let deadline = this.chunkUpdateDeadline;
        if (!flush && deadline === null) {
            deadline = Date.now() + 30;
        }
        let visibleChunksChanged = false;
        let numUpdates = 0;
        while (true) {
            if (!flush && Date.now() > deadline) {
                // No time to perform chunk update now, we will wait some more.
                this.chunkUpdateDeadline = null;
                setTimeout(() => this.processPendingChunkUpdates(), this.chunkUpdateDelay);
                break;
            }
            let update = this.pendingChunkUpdates;
            if (update == null) break;
            if (this.applyChunkUpdate(update)) {
                visibleChunksChanged = true;
            }
            ++numUpdates;
            let nextUpdate = this.pendingChunkUpdates = update.nextUpdate;
            if (nextUpdate == null) {
                this.pendingChunkUpdatesTail = null;
                break;
            }
        }
        if (visibleChunksChanged) {
            this.visibleChunksChanged.dispatch();
        }
        return numUpdates;
    }
    handleFetch_(source, update) {
        var _update$promise = update['promise'];
        const resolve = _update$promise.resolve,
              reject = _update$promise.reject,
              cancellationToken = _update$promise.cancellationToken;

        if (cancellationToken.isCanceled) {
            reject(CANCELED);
            return;
        }
        const key = update['key'];
        const chunk = source.chunks.get(key);
        if (!chunk) {
            reject(new Error(`No chunk found at ${key} for source ${source.constructor.name}`));
            return;
        }
        const data = chunk['data'];
        if (!data) {
            reject(new Error(`At ${key} for source ${source.constructor.name}: chunk has no data`));
            return;
        }
        resolve({ value: data });
    }
    applyChunkUpdate(update) {
        let visibleChunksChanged = false;
        let rpc = this.rpc;

        const source = rpc.get(update['source']);
        if (DEBUG_CHUNK_UPDATES) {
            console.log(`${Date.now()} Chunk.update processed: ${source.rpcId} ` + `${update['id']} ${update['state']}`);
        }
        if (update['promise'] !== undefined) {
            this.handleFetch_(source, update);
        } else if (update['id'] === undefined) {
            // Invalidate source.
            for (const chunkKey of source.chunks.keys()) {
                source.deleteChunk(chunkKey);
            }
            visibleChunksChanged = true;
        } else {
            let newState = update['state'];
            if (newState === ChunkState.EXPIRED) {
                // FIXME: maybe use freeList for chunks here
                source.deleteChunk(update['id']);
            } else {
                let chunk;
                let key = update['id'];
                if (update['new']) {
                    chunk = source.getChunk(update);
                    source.addChunk(key, chunk);
                } else {
                    chunk = source.chunks.get(key);
                }
                let oldState = chunk.state;
                if (newState !== oldState) {
                    switch (newState) {
                        case ChunkState.GPU_MEMORY:
                            // console.log("Copying to GPU", chunk);
                            chunk.copyToGPU(this.gl);
                            visibleChunksChanged = true;
                            break;
                        case ChunkState.SYSTEM_MEMORY:
                            chunk.freeGPUMemory(this.gl);
                            break;
                        default:
                            throw new Error(`INTERNAL ERROR: Invalid chunk state: ${ChunkState[newState]}`);
                    }
                }
            }
        }
        return visibleChunksChanged;
    }
    flushPendingChunkUpdates() {
        return this.processPendingChunkUpdates(true);
    }
    async getStatistics() {
        const rpc = this.rpc;
        const rawData = await rpc.promiseInvoke(REQUEST_CHUNK_STATISTICS_RPC_ID, { queue: this.rpcId });
        const data = new _Map();
        for (const _ref of rawData) {
            var _ref2 = _slicedToArray(_ref, 2);

            const id = _ref2[0];
            const statistics = _ref2[1];

            const source = rpc.get(id);
            if (source === undefined) continue;
            data.set(source, statistics);
        }
        return data;
    }
};
ChunkQueueManager = __decorate([registerSharedObjectOwner(CHUNK_QUEUE_MANAGER_RPC_ID)], ChunkQueueManager);
export { ChunkQueueManager };
function updateChunk(rpc, x) {
    let source = rpc.get(x['source']);
    if (DEBUG_CHUNK_UPDATES) {
        console.log(`${Date.now()} Chunk.update received: ` + `${source.rpcId} ${x['id']} ${x['state']} with chunkDataSize ${x['chunkDataSize']}`);
    }
    let queueManager = source.chunkManager.chunkQueueManager;
    if (source.immediateChunkUpdates) {
        if (queueManager.applyChunkUpdate(x)) {
            queueManager.visibleChunksChanged.dispatch();
        }
        return;
    }
    let pendingTail = queueManager.pendingChunkUpdatesTail;
    if (pendingTail == null) {
        queueManager.pendingChunkUpdates = x;
        queueManager.pendingChunkUpdatesTail = x;
        queueManager.scheduleChunkUpdate();
    } else {
        pendingTail.nextUpdate = x;
        queueManager.pendingChunkUpdatesTail = x;
    }
}
registerRPC('Chunk.update', function (x) {
    updateChunk(this, x);
});
registerPromiseRPC('Chunk.retrieve', function (x, cancellationToken) {
    return new _Promise((resolve, reject) => {
        x['promise'] = { resolve, reject, cancellationToken };
        updateChunk(this, x);
    });
});
registerRPC(CHUNK_LAYER_STATISTICS_RPC_ID, function (x) {
    const chunkManager = this.get(x.id);
    for (const stats of chunkManager.prevStatisticsLayers) {
        stats.numVisibleChunksNeeded = 0;
        stats.numVisibleChunksAvailable = 0;
        stats.numPrefetchChunksNeeded = 0;
        stats.numPrefetchChunksAvailable = 0;
    }
    chunkManager.prevStatisticsLayers.length = 0;
    for (const layerUpdate of x.layers) {
        const layer = this.get(layerUpdate.id);
        if (layer === undefined) continue;
        const stats = layer.layerChunkProgressInfo;
        stats.numVisibleChunksAvailable = layerUpdate.numVisibleChunksAvailable;
        stats.numVisibleChunksNeeded = layerUpdate.numVisibleChunksNeeded;
        stats.numPrefetchChunksAvailable = layerUpdate.numPrefetchChunksAvailable;
        stats.numPrefetchChunksNeeded = layerUpdate.numPrefetchChunksNeeded;
        chunkManager.prevStatisticsLayers.push(stats);
    }
    chunkManager.layerChunkStatisticsUpdated.dispatch();
});
let ChunkManager = class ChunkManager extends SharedObject {
    constructor(chunkQueueManager) {
        super();
        this.chunkQueueManager = chunkQueueManager;
        this.memoize = new StringMemoize();
        this.prevStatisticsLayers = [];
        this.layerChunkStatisticsUpdated = new NullarySignal();
        this.registerDisposer(chunkQueueManager.addRef());
        this.initializeCounterpart(chunkQueueManager.rpc, { 'chunkQueueManager': chunkQueueManager.rpcId });
    }
    get gl() {
        return this.chunkQueueManager.gl;
    }
    getChunkSource(constructorFunction, options) {
        const keyObject = constructorFunction.encodeOptions(options);
        keyObject['constructorId'] = getObjectId(constructorFunction);
        const key = stableStringify(keyObject);
        return this.memoize.get(key, () => {
            const newSource = new constructorFunction(this, options);
            newSource.initializeCounterpart(this.rpc, {});
            newSource.key = keyObject;
            return newSource;
        });
    }
};
ChunkManager = __decorate([registerSharedObjectOwner(CHUNK_MANAGER_RPC_ID)], ChunkManager);
export { ChunkManager };
export class ChunkSource extends SharedObject {
    constructor(chunkManager, _options = {}) {
        super();
        this.chunkManager = chunkManager;
        this.chunks = new _Map();
        /**
         * If set to true, chunk updates will be applied to this source immediately, rather than queueing
         * them.  Sources that dynamically update chunks and need to ensure a consistent order of
         * processing relative to other messages between the frontend and worker should set this to true.
         */
        this.immediateChunkUpdates = false;
    }
    initializeCounterpart(rpc, options) {
        options['chunkManager'] = this.chunkManager.rpcId;
        super.initializeCounterpart(rpc, options);
    }
    get gl() {
        return this.chunkManager.chunkQueueManager.gl;
    }
    deleteChunk(key) {
        const chunk = this.chunks.get(key);
        if (chunk.state === ChunkState.GPU_MEMORY) {
            chunk.freeGPUMemory(this.gl);
        }
        this.chunks.delete(key);
    }
    addChunk(key, chunk) {
        this.chunks.set(key, chunk);
    }
    /**
     * Default implementation for use with backendOnly chunk sources.
     */
    getChunk(_x) {
        throw new Error('Not implemented.');
    }
    /**
     * Invalidates the chunk cache.  Operates asynchronously.
     */
    invalidateCache() {
        this.rpc.invoke(CHUNK_SOURCE_INVALIDATE_RPC_ID, { 'id': this.rpcId });
    }
    static encodeOptions(_options) {
        return {};
    }
}
export function WithParameters(Base, parametersConstructor) {
    let C = class C extends Base {
        constructor(...args) {
            super(...args);
            const options = args[1];
            this.parameters = options.parameters;
        }
        initializeCounterpart(rpc, options) {
            options['parameters'] = this.parameters;
            super.initializeCounterpart(rpc, options);
        }
        static encodeOptions(options) {
            return _Object$assign({ parameters: options.parameters }, super.encodeOptions(options));
        }
    };
    C = __decorate([registerSharedObjectOwner(parametersConstructor.RPC_ID)], C);
    return C;
}
export class ChunkRenderLayerFrontend extends SharedObject {
    constructor(layerChunkProgressInfo) {
        super();
        this.layerChunkProgressInfo = layerChunkProgressInfo;
    }
}
//# sourceMappingURL=frontend.js.map