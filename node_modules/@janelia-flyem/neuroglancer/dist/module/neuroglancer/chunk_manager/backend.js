import _Promise from "babel-runtime/core-js/promise";
import _Number$isFinite from "babel-runtime/core-js/number/is-finite";
import _Set from "babel-runtime/core-js/set";
import _Map from "babel-runtime/core-js/map";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import throttle from 'lodash/throttle';
import { CHUNK_LAYER_STATISTICS_RPC_ID, CHUNK_MANAGER_RPC_ID, CHUNK_QUEUE_MANAGER_RPC_ID, CHUNK_SOURCE_INVALIDATE_RPC_ID, ChunkDownloadStatistics, ChunkMemoryStatistics, ChunkPriorityTier, ChunkState, getChunkDownloadStatisticIndex, getChunkStateStatisticIndex, numChunkMemoryStatistics, numChunkStatistics, REQUEST_CHUNK_STATISTICS_RPC_ID } from "./base";
import { CancellationTokenSource } from "../util/cancellation";
import { RefCounted } from "../util/disposable";
import LinkedList0 from "../util/linked_list.0";
import LinkedList1 from "../util/linked_list.1";
import { StringMemoize } from "../util/memoize";
import PairingHeap0 from "../util/pairing_heap.0";
import PairingHeap1 from "../util/pairing_heap.1";
import { NullarySignal } from "../util/signal";
import { initializeSharedObjectCounterpart, registerPromiseRPC, registerRPC, registerSharedObject, registerSharedObjectOwner, SharedObject, SharedObjectCounterpart } from "../worker_rpc";
const DEBUG_CHUNK_UPDATES = false;
let nextMarkGeneration = 0;
export function getNextMarkGeneration() {
    return ++nextMarkGeneration;
}
export class Chunk {
    constructor() {
        // Node properties used for eviction/promotion heaps and LRU linked lists.
        this.child0 = null;
        this.next0 = null;
        this.prev0 = null;
        this.child1 = null;
        this.next1 = null;
        this.prev1 = null;
        this.source = null;
        this.key = null;
        this.state_ = ChunkState.NEW;
        this.error = null;
        // Used by layers for marking chunks for various purposes.
        this.markGeneration = -1;
        /**
         * Specifies existing priority within priority tier.  Only meaningful if priorityTier in
         * CHUNK_ORDERED_PRIORITY_TIERS.  Higher numbers mean higher priority.
         */
        this.priority = 0;
        /**
         * Specifies updated priority within priority tier, not yet reflected in priority queue state.
         * Only meaningful if newPriorityTier in CHUNK_ORDERED_PRIORITY_TIERS.
         */
        this.newPriority = 0;
        this.priorityTier = ChunkPriorityTier.RECENT;
        /**
         * Specifies updated priority tier, not yet reflected in priority queue state.
         */
        this.newPriorityTier = ChunkPriorityTier.RECENT;
        this.systemMemoryBytes_ = 0;
        this.gpuMemoryBytes_ = 0;
        this.downloadSlots_ = 1;
        this.backendOnly = false;
        this.isComputational = false;
        this.newlyRequestedToFrontend = false;
        this.requestedToFrontend = false;
        /**
         * Cancellation token used to cancel the pending download.  Set to undefined except when state !==
         * DOWNLOADING.  This should not be accessed by code outside this module.
         */
        this.downloadCancellationToken = undefined;
    }
    initialize(key) {
        this.key = key;
        this.priority = Number.NEGATIVE_INFINITY;
        this.priorityTier = ChunkPriorityTier.RECENT;
        this.newPriority = Number.NEGATIVE_INFINITY;
        this.newPriorityTier = ChunkPriorityTier.RECENT;
        this.error = null;
        this.state = ChunkState.NEW;
        this.requestedToFrontend = false;
        this.newlyRequestedToFrontend = false;
    }
    /**
     * Sets this.priority{Tier,} to this.newPriority{Tier,}, and resets this.newPriorityTier to
     * ChunkPriorityTier.RECENT.
     *
     * This does not actually update any queues to reflect this change.
     */
    updatePriorityProperties() {
        this.priorityTier = this.newPriorityTier;
        this.priority = this.newPriority;
        this.newPriorityTier = ChunkPriorityTier.RECENT;
        this.newPriority = Number.NEGATIVE_INFINITY;
        this.requestedToFrontend = this.newlyRequestedToFrontend;
    }
    dispose() {
        this.source = null;
        this.error = null;
    }
    get chunkManager() {
        return this.source.chunkManager;
    }
    get queueManager() {
        return this.source.chunkManager.queueManager;
    }
    downloadFailed(error) {
        this.error = error;
        this.queueManager.updateChunkState(this, ChunkState.FAILED);
    }
    downloadSucceeded() {
        this.queueManager.updateChunkState(this, ChunkState.SYSTEM_MEMORY_WORKER);
    }
    freeSystemMemory() {}
    serialize(msg, _transfers) {
        msg['id'] = this.key;
        msg['source'] = this.source.rpcId;
        msg['new'] = true;
    }
    toString() {
        return this.key;
    }
    set state(newState) {
        if (newState === this.state_) {
            return;
        }
        const oldState = this.state_;
        this.state_ = newState;
        this.source.chunkStateChanged(this, oldState);
    }
    get state() {
        return this.state_;
    }
    set systemMemoryBytes(bytes) {
        updateChunkStatistics(this, -1);
        this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);
        this.systemMemoryBytes_ = bytes;
        this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);
        updateChunkStatistics(this, 1);
        this.chunkManager.queueManager.scheduleUpdate();
    }
    get systemMemoryBytes() {
        return this.systemMemoryBytes_;
    }
    set gpuMemoryBytes(bytes) {
        updateChunkStatistics(this, -1);
        this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);
        this.gpuMemoryBytes_ = bytes;
        this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);
        updateChunkStatistics(this, 1);
        this.chunkManager.queueManager.scheduleUpdate();
    }
    get gpuMemoryBytes() {
        return this.gpuMemoryBytes_;
    }
    get downloadSlots() {
        return this.downloadSlots_;
    }
    set downloadSlots(count) {
        if (count === this.downloadSlots_) return;
        updateChunkStatistics(this, -1);
        this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);
        this.downloadSlots_ = count;
        this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);
        updateChunkStatistics(this, 1);
        this.chunkManager.queueManager.scheduleUpdate();
    }
    registerListener(listener) {
        if (!this.source) {
            return false;
        }
        return this.source.registerChunkListener(this.key, listener);
    }
    unregisterListener(listener) {
        if (!this.source) {
            return false;
        }
        return this.source.unregisterChunkListener(this.key, listener);
    }
    static priorityLess(a, b) {
        return a.priority < b.priority;
    }
    static priorityGreater(a, b) {
        return a.priority > b.priority;
    }
}
const numSourceQueueLevels = 2;
/**
 * Base class inherited by both ChunkSource, for implementing the backend part of chunk sources that
 * also have a frontend-part, as well as other chunk sources, such as the GenericFileSource, that
 * has only a backend part.
 */
export class ChunkSourceBase extends SharedObject {
    constructor(chunkManager) {
        super();
        this.chunkManager = chunkManager;
        this.listeners_ = new _Map();
        this.chunks = new _Map();
        this.freeChunks = new Array();
        this.statistics = new Float64Array(numChunkStatistics);
        /**
         * sourceQueueLevel must be greater than the sourceQueueLevel of any ChunkSource whose download
         * method depends on chunks from this source.  A normal ChunkSource with no other dependencies
         * should have a level of 0.
         */
        this.sourceQueueLevel = 0;
        chunkManager.queueManager.sources.add(this);
    }
    disposed() {
        this.chunkManager.queueManager.sources.delete(this);
        super.disposed();
    }
    getNewChunk_(chunkType) {
        let freeChunks = this.freeChunks;
        let freeChunksLength = freeChunks.length;
        if (freeChunksLength > 0) {
            let chunk = freeChunks[freeChunksLength - 1];
            freeChunks.length = freeChunksLength - 1;
            chunk.source = this;
            return chunk;
        }
        let chunk = new chunkType();
        chunk.source = this;
        return chunk;
    }
    /**
     * Adds the specified chunk to the chunk cache.
     *
     * If the chunk cache was previously empty, also call this.addRef() to increment the reference
     * count.
     */
    addChunk(chunk) {
        let chunks = this.chunks;

        if (chunks.size === 0) {
            this.addRef();
        }
        chunks.set(chunk.key, chunk);
        updateChunkStatistics(chunk, 1);
    }
    /**
     * Remove the specified chunk from the chunk cache.
     *
     * If the chunk cache becomes empty, also call this.dispose() to decrement the reference count.
     */
    removeChunk(chunk) {
        let chunks = this.chunks,
            freeChunks = this.freeChunks;

        chunks.delete(chunk.key);
        chunk.dispose();
        freeChunks[freeChunks.length] = chunk;
        if (chunks.size === 0) {
            this.dispose();
        }
    }
    registerChunkListener(key, listener) {
        if (!this.listeners_.has(key)) {
            this.listeners_.set(key, [listener]);
        } else {
            this.listeners_.get(key).push(listener);
        }
        return true;
    }
    unregisterChunkListener(key, listener) {
        if (!this.listeners_.has(key)) {
            return false;
        }
        const keyListeners = this.listeners_.get(key);
        const idx = keyListeners.indexOf(listener);
        if (idx < 0) {
            return false;
        }
        keyListeners.splice(idx, 1);
        if (keyListeners.length === 0) {
            this.listeners_.delete(key);
        }
        return true;
    }
    chunkStateChanged(chunk, oldState) {
        if (!chunk.key) {
            return;
        }
        if (!this.listeners_.has(chunk.key)) {
            return;
        }
        for (const listener of [...this.listeners_.get(chunk.key)]) {
            listener.stateChanged(chunk, oldState);
        }
    }
}
function updateChunkStatistics(chunk, sign) {
    const statistics = chunk.source.statistics;
    const systemMemoryBytes = chunk.systemMemoryBytes,
          gpuMemoryBytes = chunk.gpuMemoryBytes;

    const index = getChunkStateStatisticIndex(chunk.state, chunk.priorityTier);
    statistics[index * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks] += sign;
    statistics[index * numChunkMemoryStatistics + ChunkMemoryStatistics.systemMemoryBytes] += sign * systemMemoryBytes;
    statistics[index * numChunkMemoryStatistics + ChunkMemoryStatistics.gpuMemoryBytes] += sign * gpuMemoryBytes;
}
export class ChunkSource extends ChunkSourceBase {
    constructor(rpc, options) {
        // No need to add a reference, since the owner counterpart will hold a reference to the owner
        // counterpart of chunkManager.
        const chunkManager = rpc.get(options['chunkManager']);
        super(chunkManager);
        initializeSharedObjectCounterpart(this, rpc, options);
    }
}
function startChunkDownload(chunk) {
    const downloadCancellationToken = chunk.downloadCancellationToken = new CancellationTokenSource();
    const startTime = Date.now();
    chunk.source.download(chunk, downloadCancellationToken).then(() => {
        if (chunk.downloadCancellationToken === downloadCancellationToken) {
            chunk.downloadCancellationToken = undefined;
            const endTime = Date.now();
            const statistics = chunk.source.statistics;

            statistics[getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalTime)] += endTime - startTime;
            ++statistics[getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalChunks)];
            chunk.downloadSucceeded();
        }
    }, error => {
        if (chunk.downloadCancellationToken === downloadCancellationToken) {
            chunk.downloadCancellationToken = undefined;
            chunk.downloadFailed(error);
            console.log(`Error retrieving chunk ${chunk}: ${error}`);
        }
    });
}
function cancelChunkDownload(chunk) {
    const token = chunk.downloadCancellationToken;
    chunk.downloadCancellationToken = undefined;
    // token can be undefined because of a race condition when used in react-neuroglancer
    if (token) {
        token.cancel();
    } else {
        console.log('Unexpected undefined token in', chunk);
    }
}
class ChunkPriorityQueue {
    constructor(heapOperations, linkedListOperations) {
        this.heapOperations = heapOperations;
        this.linkedListOperations = linkedListOperations;
        /**
         * Heap roots for VISIBLE and PREFETCH priority tiers.
         */
        this.heapRoots = [null, null];
        /**
         * Head node for RECENT linked list.
         */
        this.recentHead = new Chunk();
        linkedListOperations.initializeHead(this.recentHead);
    }
    add(chunk) {
        let priorityTier = chunk.priorityTier;
        if (priorityTier === ChunkPriorityTier.RECENT) {
            this.linkedListOperations.insertAfter(this.recentHead, chunk);
        } else {
            let heapRoots = this.heapRoots;

            heapRoots[priorityTier] = this.heapOperations.meld(heapRoots[priorityTier], chunk);
        }
    }
    *candidates() {
        if (this.heapOperations.compare === Chunk.priorityLess) {
            // Start with least-recently used RECENT chunk.
            let linkedListOperations = this.linkedListOperations,
                recentHead = this.recentHead;

            while (true) {
                let chunk = linkedListOperations.back(recentHead);
                if (chunk == null) {
                    break;
                } else {
                    yield chunk;
                }
            }
            let heapRoots = this.heapRoots;

            for (let tier = ChunkPriorityTier.LAST_ORDERED_TIER; tier >= ChunkPriorityTier.FIRST_ORDERED_TIER; --tier) {
                while (true) {
                    let root = heapRoots[tier];
                    if (root == null) {
                        break;
                    } else {
                        yield root;
                    }
                }
            }
        } else {
            let heapRoots = this.heapRoots;
            for (let tier = ChunkPriorityTier.FIRST_ORDERED_TIER; tier <= ChunkPriorityTier.LAST_ORDERED_TIER; ++tier) {
                while (true) {
                    let root = heapRoots[tier];
                    if (root == null) {
                        break;
                    } else {
                        yield root;
                    }
                }
            }
            let linkedListOperations = this.linkedListOperations,
                recentHead = this.recentHead;

            while (true) {
                let chunk = linkedListOperations.front(recentHead);
                if (chunk == null) {
                    break;
                } else {
                    yield chunk;
                }
            }
        }
    }
    /**
     * Deletes a chunk from this priority queue.
     * @param chunk The chunk to delete from the priority queue.
     */
    delete(chunk) {
        let priorityTier = chunk.priorityTier;
        if (priorityTier === ChunkPriorityTier.RECENT) {
            this.linkedListOperations.pop(chunk);
        } else {
            let heapRoots = this.heapRoots;
            heapRoots[priorityTier] = this.heapOperations.remove(heapRoots[priorityTier], chunk);
        }
    }
}
function makeChunkPriorityQueue0(compare) {
    return new ChunkPriorityQueue(new PairingHeap0(compare), LinkedList0);
}
function makeChunkPriorityQueue1(compare) {
    return new ChunkPriorityQueue(new PairingHeap1(compare), LinkedList1);
}
function tryToFreeCapacity(size, capacity, priorityTier, priority, evictionCandidates, evict) {
    while (capacity.availableItems < 1 || capacity.availableSize < size) {
        let evictionCandidate = evictionCandidates.next().value;
        if (evictionCandidate === undefined) {
            // No eviction candidates available, promotions are done.
            return false;
        } else {
            let evictionTier = evictionCandidate.priorityTier;
            if (evictionTier < priorityTier || evictionTier === priorityTier && evictionCandidate.priority >= priority) {
                // Lowest priority eviction candidate has priority >= highest
                // priority promotion candidate.  No more promotions are
                // possible.
                return false;
            }
            evict(evictionCandidate);
        }
    }
    return true;
}
class AvailableCapacity extends RefCounted {
    constructor(itemLimit, sizeLimit) {
        super();
        this.itemLimit = itemLimit;
        this.sizeLimit = sizeLimit;
        this.currentSize = 0;
        this.currentItems = 0;
        this.capacityChanged = new NullarySignal();
        this.registerDisposer(itemLimit.changed.add(this.capacityChanged.dispatch));
        this.registerDisposer(sizeLimit.changed.add(this.capacityChanged.dispatch));
    }
    /**
     * Adjust available capacity by the specified amounts.
     */
    adjust(items, size) {
        this.currentItems -= items;
        this.currentSize -= size;
    }
    get availableSize() {
        return this.sizeLimit.value - this.currentSize;
    }
    get availableItems() {
        return this.itemLimit.value - this.currentItems;
    }
    toString() {
        return `bytes=${this.currentSize}/${this.sizeLimit.value},` + `items=${this.currentItems}/${this.itemLimit.value}`;
    }
}
let ChunkQueueManager = class ChunkQueueManager extends SharedObjectCounterpart {
    constructor(rpc, options) {
        super(rpc, options);
        /**
         * Set of chunk sources associated with this queue manager.
         */
        this.sources = new _Set();
        /**
         * Contains all chunks in QUEUED state pending download, for each sourceQueueLevel.
         */
        this.queuedDownloadPromotionQueue = [makeChunkPriorityQueue1(Chunk.priorityGreater), makeChunkPriorityQueue1(Chunk.priorityGreater)];
        /**
         * Contains all chunks in QUEUED state pending compute.
         */
        this.queuedComputePromotionQueue = makeChunkPriorityQueue1(Chunk.priorityGreater);
        /**
         * Contains all chunks in DOWNLOADING state, for each sourceQueueLevel.
         */
        this.downloadEvictionQueue = [makeChunkPriorityQueue1(Chunk.priorityLess), makeChunkPriorityQueue1(Chunk.priorityLess)];
        /**
         * Contains all chunks in COMPUTING state.
         */
        this.computeEvictionQueue = makeChunkPriorityQueue1(Chunk.priorityLess);
        /**
         * Contains all chunks that take up memory (DOWNLOADING, SYSTEM_MEMORY,
         * GPU_MEMORY).
         */
        this.systemMemoryEvictionQueue = makeChunkPriorityQueue0(Chunk.priorityLess);
        /**
         * Contains all chunks in SYSTEM_MEMORY state not in RECENT priority tier.
         */
        this.gpuMemoryPromotionQueue = makeChunkPriorityQueue1(Chunk.priorityGreater);
        /**
         * Contains all chunks in GPU_MEMORY state.
         */
        this.gpuMemoryEvictionQueue = makeChunkPriorityQueue1(Chunk.priorityLess);
        // Should be `number|null`, but marked `any` to work around @types/node being pulled in.
        this.updatePending = null;
        this.gpuMemoryChanged = new NullarySignal();
        this.numQueued = 0;
        this.numFailed = 0;
        this.gpuMemoryGeneration = 0;
        const getCapacity = capacity => {
            const result = this.registerDisposer(new AvailableCapacity(rpc.get(capacity['itemLimit']), rpc.get(capacity['sizeLimit'])));
            result.capacityChanged.add(() => this.scheduleUpdate());
            return result;
        };
        this.gpuMemoryCapacity = getCapacity(options['gpuMemoryCapacity']);
        this.systemMemoryCapacity = getCapacity(options['systemMemoryCapacity']);
        this.enablePrefetch = rpc.get(options['enablePrefetch']);
        this.downloadCapacity = [getCapacity(options['downloadCapacity']), getCapacity(options['downloadCapacity'])];
        this.computeCapacity = getCapacity(options['computeCapacity']);
    }
    scheduleUpdate() {
        if (this.updatePending === null) {
            this.updatePending = setTimeout(this.process.bind(this), 0);
        }
    }
    *chunkQueuesForChunk(chunk) {
        switch (chunk.state) {
            case ChunkState.QUEUED:
                if (chunk.isComputational) {
                    yield this.queuedComputePromotionQueue;
                } else {
                    yield this.queuedDownloadPromotionQueue[chunk.source.sourceQueueLevel];
                }
                break;
            case ChunkState.DOWNLOADING:
                if (chunk.isComputational) {
                    yield this.computeEvictionQueue;
                } else {
                    yield this.downloadEvictionQueue[chunk.source.sourceQueueLevel];
                    yield this.systemMemoryEvictionQueue;
                }
                break;
            case ChunkState.SYSTEM_MEMORY_WORKER:
            case ChunkState.SYSTEM_MEMORY:
                yield this.systemMemoryEvictionQueue;
                if (chunk.priorityTier !== ChunkPriorityTier.RECENT && !chunk.backendOnly && chunk.requestedToFrontend) {
                    yield this.gpuMemoryPromotionQueue;
                }
                break;
            case ChunkState.GPU_MEMORY:
                yield this.systemMemoryEvictionQueue;
                yield this.gpuMemoryEvictionQueue;
                break;
        }
    }
    adjustCapacitiesForChunk(chunk, add) {
        let factor = add ? -1 : 1;
        switch (chunk.state) {
            case ChunkState.FAILED:
                this.numFailed -= factor;
                break;
            case ChunkState.QUEUED:
                this.numQueued -= factor;
                break;
            case ChunkState.DOWNLOADING:
                (chunk.isComputational ? this.computeCapacity : this.downloadCapacity[chunk.source.sourceQueueLevel]).adjust(factor * chunk.downloadSlots, factor * chunk.systemMemoryBytes);
                this.systemMemoryCapacity.adjust(factor, factor * chunk.systemMemoryBytes);
                break;
            case ChunkState.SYSTEM_MEMORY:
            case ChunkState.SYSTEM_MEMORY_WORKER:
                this.systemMemoryCapacity.adjust(factor, factor * chunk.systemMemoryBytes);
                break;
            case ChunkState.GPU_MEMORY:
                this.systemMemoryCapacity.adjust(factor, factor * chunk.systemMemoryBytes);
                this.gpuMemoryCapacity.adjust(factor, factor * chunk.gpuMemoryBytes);
                break;
        }
    }
    removeChunkFromQueues_(chunk) {
        updateChunkStatistics(chunk, -1);
        for (let queue of this.chunkQueuesForChunk(chunk)) {
            queue.delete(chunk);
        }
    }
    // var freedChunks = 0;
    addChunkToQueues_(chunk) {
        if (chunk.state === ChunkState.QUEUED && chunk.priorityTier === ChunkPriorityTier.RECENT) {
            // Delete this chunk.
            let source = chunk.source;

            source.removeChunk(chunk);
            this.adjustCapacitiesForChunk(chunk, false);
            return false;
        } else {
            updateChunkStatistics(chunk, 1);
            for (let queue of this.chunkQueuesForChunk(chunk)) {
                queue.add(chunk);
            }
            return true;
        }
    }
    performChunkPriorityUpdate(chunk) {
        if (chunk.priorityTier === chunk.newPriorityTier && chunk.priority === chunk.newPriority) {
            chunk.newPriorityTier = ChunkPriorityTier.RECENT;
            chunk.newPriority = Number.NEGATIVE_INFINITY;
            return;
        }
        if (DEBUG_CHUNK_UPDATES) {
            console.log(`${chunk}: changed priority ${chunk.priorityTier}:` + `${chunk.priority} -> ${chunk.newPriorityTier}:${chunk.newPriority}`);
        }
        this.removeChunkFromQueues_(chunk);
        chunk.updatePriorityProperties();
        if (chunk.state === ChunkState.NEW) {
            chunk.state = ChunkState.QUEUED;
            this.adjustCapacitiesForChunk(chunk, true);
        }
        this.addChunkToQueues_(chunk);
    }
    updateChunkState(chunk, newState) {
        if (newState === chunk.state) {
            return;
        }
        if (DEBUG_CHUNK_UPDATES) {
            console.log(`${chunk}: changed state ${ChunkState[chunk.state]} -> ${ChunkState[newState]}`);
        }
        this.adjustCapacitiesForChunk(chunk, false);
        this.removeChunkFromQueues_(chunk);
        chunk.state = newState;
        this.adjustCapacitiesForChunk(chunk, true);
        this.addChunkToQueues_(chunk);
        this.scheduleUpdate();
    }
    processGPUPromotions_() {
        let queueManager = this;
        function evictFromGPUMemory(chunk) {
            queueManager.freeChunkGPUMemory(chunk);
            chunk.source.chunkManager.queueManager.updateChunkState(chunk, ChunkState.SYSTEM_MEMORY);
        }
        let promotionCandidates = this.gpuMemoryPromotionQueue.candidates();
        let evictionCandidates = this.gpuMemoryEvictionQueue.candidates();
        let capacity = this.gpuMemoryCapacity;
        while (true) {
            let promotionCandidate = promotionCandidates.next().value;
            if (promotionCandidate === undefined) {
                break;
            } else {
                let priorityTier = promotionCandidate.priorityTier;
                let priority = promotionCandidate.priority;
                if (!tryToFreeCapacity(promotionCandidate.gpuMemoryBytes, capacity, priorityTier, priority, evictionCandidates, evictFromGPUMemory)) {
                    break;
                }
                this.copyChunkToGPU(promotionCandidate);
                this.updateChunkState(promotionCandidate, ChunkState.GPU_MEMORY);
            }
        }
    }
    freeChunkGPUMemory(chunk) {
        ++this.gpuMemoryGeneration;
        this.rpc.invoke('Chunk.update', { 'id': chunk.key, 'state': ChunkState.SYSTEM_MEMORY, 'source': chunk.source.rpcId });
    }
    freeChunkSystemMemory(chunk) {
        if (chunk.state === ChunkState.SYSTEM_MEMORY_WORKER) {
            chunk.freeSystemMemory();
        } else {
            this.rpc.invoke('Chunk.update', { 'id': chunk.key, 'state': ChunkState.EXPIRED, 'source': chunk.source.rpcId });
        }
    }
    retrieveChunkData(chunk) {
        return this.rpc.promiseInvoke('Chunk.retrieve', { key: chunk.key, source: chunk.source.rpcId });
    }
    copyChunkToGPU(chunk) {
        ++this.gpuMemoryGeneration;
        let rpc = this.rpc;
        if (chunk.state === ChunkState.SYSTEM_MEMORY) {
            rpc.invoke('Chunk.update', { 'id': chunk.key, 'source': chunk.source.rpcId, 'state': ChunkState.GPU_MEMORY });
        } else {
            let msg = {};
            let transfers = [];
            chunk.serialize(msg, transfers);
            msg['state'] = ChunkState.GPU_MEMORY;
            rpc.invoke('Chunk.update', msg, transfers);
        }
    }
    processQueuePromotions_() {
        let queueManager = this;
        const evict = chunk => {
            switch (chunk.state) {
                case ChunkState.DOWNLOADING:
                    cancelChunkDownload(chunk);
                    break;
                case ChunkState.GPU_MEMORY:
                    queueManager.freeChunkGPUMemory(chunk);
                case ChunkState.SYSTEM_MEMORY_WORKER:
                case ChunkState.SYSTEM_MEMORY:
                    queueManager.freeChunkSystemMemory(chunk);
                    break;
            }
            // Note: After calling this, chunk may no longer be valid.
            this.updateChunkState(chunk, ChunkState.QUEUED);
        };
        const promotionLambda = (promotionCandidates, evictionCandidates, capacity) => {
            let systemMemoryEvictionCandidates = this.systemMemoryEvictionQueue.candidates();
            let systemMemoryCapacity = this.systemMemoryCapacity;
            while (true) {
                let promotionCandidateResult = promotionCandidates.next();
                if (promotionCandidateResult.done) {
                    return;
                }
                let promotionCandidate = promotionCandidateResult.value;
                const size = 0; /* unknown size, since it hasn't been downloaded yet. */
                let priorityTier = promotionCandidate.priorityTier;
                let priority = promotionCandidate.priority;
                // console.log("Download capacity: " + downloadCapacity);
                if (!tryToFreeCapacity(size, capacity, priorityTier, priority, evictionCandidates, evict)) {
                    return;
                }
                if (!tryToFreeCapacity(size, systemMemoryCapacity, priorityTier, priority, systemMemoryEvictionCandidates, evict)) {
                    return;
                }
                this.updateChunkState(promotionCandidate, ChunkState.DOWNLOADING);
                startChunkDownload(promotionCandidate);
            }
        };
        for (let sourceQueueLevel = 0; sourceQueueLevel < numSourceQueueLevels; ++sourceQueueLevel) {
            promotionLambda(this.queuedDownloadPromotionQueue[sourceQueueLevel].candidates(), this.downloadEvictionQueue[sourceQueueLevel].candidates(), this.downloadCapacity[sourceQueueLevel]);
        }
        promotionLambda(this.queuedComputePromotionQueue.candidates(), this.computeEvictionQueue.candidates(), this.computeCapacity);
    }
    process() {
        if (!this.updatePending) {
            return;
        }
        this.updatePending = null;
        const gpuMemoryGeneration = this.gpuMemoryGeneration;
        this.processGPUPromotions_();
        this.processQueuePromotions_();
        this.logStatistics();
        if (this.gpuMemoryGeneration !== gpuMemoryGeneration) {
            this.gpuMemoryChanged.dispatch();
        }
    }
    logStatistics() {
        if (DEBUG_CHUNK_UPDATES) {
            console.log(`[Chunk status] QUEUED: ${this.numQueued}, FAILED: ` + `${this.numFailed}, DOWNLOAD: ${this.downloadCapacity}, ` + `MEM: ${this.systemMemoryCapacity}, GPU: ${this.gpuMemoryCapacity}`);
        }
    }
    invalidateSourceCache(source) {
        for (const chunk of source.chunks.values()) {
            switch (chunk.state) {
                case ChunkState.DOWNLOADING:
                    cancelChunkDownload(chunk);
                    break;
                case ChunkState.SYSTEM_MEMORY_WORKER:
                    chunk.freeSystemMemory();
                    break;
            }
            // Note: After calling this, chunk may no longer be valid.
            this.updateChunkState(chunk, ChunkState.QUEUED);
        }
        this.rpc.invoke('Chunk.update', { 'source': source.rpcId });
        this.scheduleUpdate();
    }
};
ChunkQueueManager = __decorate([registerSharedObject(CHUNK_QUEUE_MANAGER_RPC_ID)], ChunkQueueManager);
export { ChunkQueueManager };
export class ChunkRenderLayerBackend extends SharedObjectCounterpart {
    constructor() {
        super(...arguments);
        this.chunkManagerGeneration = -1;
        this.numVisibleChunksNeeded = 0;
        this.numVisibleChunksAvailable = 0;
        this.numPrefetchChunksNeeded = 0;
        this.numPrefetchChunksAvailable = 0;
    }
}
const LAYER_CHUNK_STATISTICS_INTERVAL = 200;
let ChunkManager = class ChunkManager extends SharedObjectCounterpart {
    constructor(rpc, options) {
        super(rpc, options);
        /**
         * Array of chunks within each existing priority tier.
         */
        this.existingTierChunks = [];
        /**
         * Array of chunks whose new priorities have not yet been reflected in the
         * queue states.
         */
        this.newTierChunks = [];
        // Should be `number|null`, but marked `any` to workaround `@types/node` being pulled in.
        this.updatePending = null;
        this.recomputeChunkPriorities = new NullarySignal();
        /**
         * Dispatched immediately after recomputeChunkPriorities is dispatched.
         * This signal should be used for handlers that depend on the result of another handler.
         */
        this.recomputeChunkPrioritiesLate = new NullarySignal();
        this.memoize = new StringMemoize();
        this.layers = [];
        this.sendLayerChunkStatistics = this.registerCancellable(throttle(() => {
            this.rpc.invoke(CHUNK_LAYER_STATISTICS_RPC_ID, {
                id: this.rpcId,
                layers: this.layers.map(layer => ({
                    id: layer.rpcId,
                    numVisibleChunksAvailable: layer.numVisibleChunksAvailable,
                    numVisibleChunksNeeded: layer.numVisibleChunksNeeded,
                    numPrefetchChunksAvailable: layer.numPrefetchChunksAvailable,
                    numPrefetchChunksNeeded: layer.numPrefetchChunksNeeded
                }))
            });
        }, LAYER_CHUNK_STATISTICS_INTERVAL));
        this.queueManager = rpc.get(options['chunkQueueManager']).addRef();
        // Update chunk priorities periodically after GPU memory changes to ensure layer chunk
        // statistics are updated.
        this.registerDisposer(this.queueManager.gpuMemoryChanged.add(this.registerCancellable(throttle(() => this.scheduleUpdateChunkPriorities(), LAYER_CHUNK_STATISTICS_INTERVAL, { leading: false, trailing: true }))));
        for (let tier = ChunkPriorityTier.FIRST_TIER; tier <= ChunkPriorityTier.LAST_TIER; ++tier) {
            if (tier === ChunkPriorityTier.RECENT) {
                continue;
            }
            this.existingTierChunks[tier] = [];
        }
    }
    scheduleUpdateChunkPriorities() {
        if (this.updatePending === null) {
            this.updatePending = setTimeout(this.recomputeChunkPriorities_.bind(this), 0);
        }
    }
    registerLayer(layer) {
        const generation = this.recomputeChunkPriorities.count;
        if (layer.chunkManagerGeneration !== generation) {
            layer.chunkManagerGeneration = generation;
            this.layers.push(layer);
            layer.numVisibleChunksAvailable = 0;
            layer.numVisibleChunksNeeded = 0;
            layer.numPrefetchChunksAvailable = 0;
            layer.numPrefetchChunksNeeded = 0;
        }
    }
    recomputeChunkPriorities_() {
        this.updatePending = null;
        this.layers.length = 0;
        this.recomputeChunkPriorities.dispatch();
        this.recomputeChunkPrioritiesLate.dispatch();
        this.updateQueueState([ChunkPriorityTier.VISIBLE, ChunkPriorityTier.PREFETCH]);
        this.sendLayerChunkStatistics();
    }
    /**
     * @param chunk
     * @param tier New priority tier.  Must not equal ChunkPriorityTier.RECENT.
     * @param priority Priority within tier.
     * @param toFrontend true if the chunk should be moved to the frontend when ready.
     */
    requestChunk(chunk, tier, priority, toFrontend = true) {
        if (!_Number$isFinite(priority)) {
            // Non-finite priority indicates a bug.
            debugger;
            return;
        }
        if (tier === ChunkPriorityTier.RECENT) {
            throw new Error('Not going to request a chunk with the RECENT tier');
        }
        chunk.newlyRequestedToFrontend = chunk.newlyRequestedToFrontend || toFrontend;
        if (chunk.newPriorityTier === ChunkPriorityTier.RECENT) {
            this.newTierChunks.push(chunk);
        }
        const newPriorityTier = chunk.newPriorityTier;
        if (tier < newPriorityTier || tier === newPriorityTier && priority > chunk.newPriority) {
            chunk.newPriorityTier = tier;
            chunk.newPriority = priority;
        }
    }
    /**
     * Update queue state to reflect updated contents of the specified priority tiers.  Existing
     * chunks within those tiers not present in this.newTierChunks will be moved to the RECENT tier
     * (and removed if in the QUEUED state).
     */
    updateQueueState(tiers) {
        let existingTierChunks = this.existingTierChunks;
        let queueManager = this.queueManager;
        for (let tier of tiers) {
            let chunks = existingTierChunks[tier];
            if (DEBUG_CHUNK_UPDATES) {
                console.log(`existingTierChunks[${ChunkPriorityTier[tier]}].length=${chunks.length}`);
            }
            for (let chunk of chunks) {
                if (chunk.newPriorityTier === ChunkPriorityTier.RECENT) {
                    // Downgrade the priority of this chunk.
                    queueManager.performChunkPriorityUpdate(chunk);
                }
            }
            chunks.length = 0;
        }
        let newTierChunks = this.newTierChunks;
        for (let chunk of newTierChunks) {
            queueManager.performChunkPriorityUpdate(chunk);
            existingTierChunks[chunk.priorityTier].push(chunk);
        }
        if (DEBUG_CHUNK_UPDATES) {
            console.log(`updateQueueState: newTierChunks.length = ${newTierChunks.length}`);
        }
        newTierChunks.length = 0;
        this.queueManager.scheduleUpdate();
    }
};
ChunkManager = __decorate([registerSharedObject(CHUNK_MANAGER_RPC_ID)], ChunkManager);
export { ChunkManager };
/**
 * Mixin for adding a `parameters` member to a ChunkSource, and for registering the shared object
 * type based on the `RPC_ID` member of the Parameters class.
 */
export function WithParameters(Base, parametersConstructor) {
    let C = class C extends Base {
        constructor(...args) {
            super(...args);
            const options = args[1];
            this.parameters = options['parameters'];
        }
    };
    C = __decorate([registerSharedObjectOwner(parametersConstructor.RPC_ID)], C);
    return C;
}
/**
 * Mixin that adds a chunkManager property initialized from the RPC-supplied options.
 *
 * The resultant class implements `ChunkRequester`.
 */
export function withChunkManager(Base) {
    return class extends Base {
        constructor(...args) {
            super(...args);
            const rpc = args[0];
            const options = args[1];
            // We don't increment the reference count, because our owner owns a reference to the
            // ChunkManager.
            this.chunkManager = rpc.get(options['chunkManager']);
        }
    };
}
registerRPC(CHUNK_SOURCE_INVALIDATE_RPC_ID, function (x) {
    const source = this.get(x['id']);
    source.chunkManager.queueManager.invalidateSourceCache(source);
});
registerPromiseRPC(REQUEST_CHUNK_STATISTICS_RPC_ID, function (x) {
    const queue = this.get(x.queue);
    const results = new _Map();
    for (const source of queue.sources) {
        results.set(source.rpcId, source.statistics);
    }
    return _Promise.resolve({ value: results });
});
//# sourceMappingURL=backend.js.map