import _Set from 'babel-runtime/core-js/set';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Provides a simple way to request a file on the backend with priority integration.
 */
import { Chunk, ChunkSourceBase } from './backend';
import { ChunkPriorityTier, ChunkState } from './base';
import { CANCELED, makeCancelablePromise } from '../util/cancellation';
import { responseArrayBuffer } from '../util/http_request';
import { stableStringify } from '../util/json';
import { getObjectId } from '../util/object_id';
import { cancellableFetchSpecialOk } from '../util/special_protocol_request';
class GenericSharedDataChunk extends Chunk {
    constructor() {
        super(...arguments);
        this.backendOnly = true;
    }
    initialize(key) {
        super.initialize(key);
        this.requesters = new _Set();
    }
    downloadSucceeded() {
        super.downloadSucceeded();
        let requesters = this.requesters,
            data = this.data;

        this.requesters = undefined;
        for (let requester of requesters) {
            requester.resolve(data);
        }
    }
    downloadFailed(error) {
        super.downloadFailed(error);
        let requesters = this.requesters;

        this.requesters = undefined;
        for (let requester of requesters) {
            requester.reject(error);
        }
    }
    freeSystemMemory() {
        this.data = undefined;
    }
}
export class GenericSharedDataSource extends ChunkSourceBase {
    constructor(chunkManager, options) {
        super(chunkManager);
        this.registerDisposer(chunkManager);
        var _options$encodeKey = options.encodeKey;
        const encodeKey = _options$encodeKey === undefined ? stableStringify : _options$encodeKey;

        this.downloadFunction = options.download;
        this.encodeKeyFunction = encodeKey;
        var _options$sourceQueueL = options.sourceQueueLevel;
        const sourceQueueLevel = _options$sourceQueueL === undefined ? 0 : _options$sourceQueueL;

        this.sourceQueueLevel = sourceQueueLevel;
        // This source is unusual in that it updates its own chunk priorities.
        this.registerDisposer(this.chunkManager.recomputeChunkPrioritiesLate.add(() => {
            this.updateChunkPriorities();
        }));
    }
    updateChunkPriorities() {
        let chunkManager = this.chunkManager;

        for (let chunk of this.chunks.values()) {
            let requesters = chunk.requesters;

            if (requesters !== undefined) {
                for (let requester of requesters) {
                    var _requester$getPriorit = requester.getPriority();

                    const priorityTier = _requester$getPriorit.priorityTier,
                          priority = _requester$getPriorit.priority;

                    if (priorityTier === ChunkPriorityTier.RECENT) continue;
                    chunkManager.requestChunk(chunk, priorityTier, priority);
                }
            }
        }
    }
    async download(chunk, cancellationToken) {
        var _ref = await this.downloadFunction(chunk.decodedKey, cancellationToken);

        const size = _ref.size,
              data = _ref.data;

        chunk.systemMemoryBytes = size;
        chunk.data = data;
    }
    /**
     * Precondition: priorityTier <= ChunkPriorityTier.LAST_ORDERED_TIER
     */
    getData(key, getPriority, cancellationToken) {
        const encodedKey = this.encodeKeyFunction(key);
        let chunk = this.chunks.get(encodedKey);
        if (chunk === undefined) {
            chunk = this.getNewChunk_(GenericSharedDataChunk);
            chunk.decodedKey = key;
            chunk.initialize(encodedKey);
            this.addChunk(chunk);
        }
        return makeCancelablePromise(cancellationToken, (resolve, reject, token) => {
            // If the data is already available or the request has already failed, resolve/reject the
            // promise immediately.
            switch (chunk.state) {
                case ChunkState.FAILED:
                    reject(chunk.error);
                    return;
                case ChunkState.SYSTEM_MEMORY_WORKER:
                    resolve(chunk.data);
                    return;
            }
            const requester = { resolve, reject, getPriority };
            chunk.requesters.add(requester);
            token.add(() => {
                var _chunk = chunk;
                let requesters = _chunk.requesters;

                if (requesters !== undefined) {
                    requesters.delete(requester);
                    this.chunkManager.scheduleUpdateChunkPriorities();
                }
                reject(CANCELED);
            });
            this.chunkManager.scheduleUpdateChunkPriorities();
        });
    }
    static get(chunkManager, memoizeKey, options) {
        return chunkManager.memoize.get(`getFileSource:${memoizeKey}`, () => new GenericSharedDataSource(chunkManager.addRef(), options));
    }
    static getData(chunkManager, memoizeKey, options, key, getPriority, cancellationToken) {
        const source = GenericSharedDataSource.get(chunkManager, memoizeKey, options);
        const result = source.getData(key, getPriority, cancellationToken);
        source.dispose();
        return result;
    }
    static getUrl(chunkManager, credentialsProvider, decodeFunction, url, getPriority, cancellationToken) {
        return GenericSharedDataSource.getData(chunkManager, `${getObjectId(decodeFunction)}`, {
            download: (url, cancellationToken) => cancellableFetchSpecialOk(credentialsProvider, url, {}, responseArrayBuffer, cancellationToken).then(response => decodeFunction(response, cancellationToken))
        }, url, getPriority, cancellationToken);
    }
}
//# sourceMappingURL=generic_file_source.js.map