import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Array$from from 'babel-runtime/core-js/array/from';
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
import { TrackableValue } from '../trackable_value';
import { columnSpecifications, getChunkSourceIdentifier, getFormattedNames } from '../ui/statistics';
import { toBase64 } from '../util/base64';
import { RefCounted } from '../util/disposable';
import { convertEndian32, Endianness } from '../util/endian';
import { verifyOptionalString } from '../util/json';
import { Signal } from '../util/signal';
import { getCachedJson } from '../util/trackable';
import { numChunkStatistics } from '../chunk_manager/base';
export class ScreenshotHandler extends RefCounted {
    constructor(viewer) {
        super();
        this.viewer = viewer;
        this.sendScreenshotRequested = new Signal();
        this.sendStatisticsRequested = new Signal();
        this.requestState = new TrackableValue(undefined, verifyOptionalString);
        /**
         * To reduce the risk of taking a screenshot while deferred code is still registering layers,
         * require that the viewer be in a ready state once, and still remain ready while all pending
         * events are handled, before a screenshot is taken.
         */
        this.wasAlreadyVisible = false;
        this.previousRequest = undefined;
        this.debouncedMaybeSendScreenshot = this.registerCancellable(debounce(() => this.maybeSendScreenshot(), 0));
        this.statisticsRequested = false;
        this.throttledSendStatistics = this.registerCancellable(throttle(async requestId => {
            if (this.requestState.value !== requestId || this.previousRequest === requestId) return;
            this.throttledSendStatistics(requestId);
            if (this.statisticsRequested) return;
            this.statisticsRequested = true;
            const map = await this.viewer.chunkQueueManager.getStatistics();
            this.statisticsRequested = false;
            if (this.wasDisposed) return;
            if (this.requestState.value !== requestId || this.previousRequest === requestId) return;
            const formattedNames = getFormattedNames(_Array$from(map, x => getChunkSourceIdentifier(x[0])));
            let i = 0;
            const rows = [];
            let sumStatistics = new Float64Array(numChunkStatistics);
            for (const _ref of map) {
                var _ref2 = _slicedToArray(_ref, 2);

                const source = _ref2[0];
                const statistics = _ref2[1];

                for (let i = 0; i < numChunkStatistics; ++i) {
                    sumStatistics[i] += statistics[i];
                }
                const row = {};
                row.id = getChunkSourceIdentifier(source);
                row.distinctId = formattedNames[i];
                for (const column of columnSpecifications) {
                    row[column.key] = column.getter(statistics);
                }
                ++i;
                rows.push(row);
            }
            const total = {};
            for (const column of columnSpecifications) {
                total[column.key] = column.getter(sumStatistics);
            }
            const actionState = {
                viewerState: JSON.parse(_JSON$stringify(getCachedJson(this.viewer.state).value)),
                selectedValues: JSON.parse(_JSON$stringify(this.viewer.layerSelectedValues)),
                screenshotStatistics: { id: requestId, chunkSources: rows, total }
            };
            this.sendStatisticsRequested.dispatch(actionState);
        }, 1000, { leading: false, trailing: true }));
        this.requestState.changed.add(this.debouncedMaybeSendScreenshot);
        this.registerDisposer(viewer.display.updateFinished.add(this.debouncedMaybeSendScreenshot));
    }
    isReady() {
        const viewer = this.viewer;

        viewer.chunkQueueManager.flushPendingChunkUpdates();
        if (!viewer.display.isReady()) {
            return false;
        }
        for (const layer of viewer.layerManager.managedLayers) {
            if (!layer.isReady()) {
                return false;
            }
        }
        return true;
    }
    async maybeSendScreenshot() {
        const requestState = this.requestState.value;
        const previousRequest = this.previousRequest;
        const layerSelectedValues = this.viewer.layerSelectedValues;

        if (requestState === undefined || requestState === previousRequest) {
            this.wasAlreadyVisible = false;
            this.throttledSendStatistics.cancel();
            return;
        }
        const viewer = this.viewer;

        if (!this.isReady()) {
            this.wasAlreadyVisible = false;
            this.throttledSendStatistics(requestState);
            return;
        }
        if (!this.wasAlreadyVisible) {
            this.throttledSendStatistics(requestState);
            this.wasAlreadyVisible = true;
            this.debouncedMaybeSendScreenshot();
            return;
        }
        this.wasAlreadyVisible = false;
        this.previousRequest = requestState;
        this.throttledSendStatistics.cancel();
        viewer.display.draw();
        const screenshotData = viewer.display.canvas.toDataURL();
        var _viewer$display$canva = viewer.display.canvas;
        const width = _viewer$display$canva.width,
              height = _viewer$display$canva.height;

        const prefix = 'data:image/png;base64,';
        let imageType;
        let image;
        let depthData = undefined;
        if (!screenshotData.startsWith(prefix)) {
            imageType = '';
            image = '';
        } else {
            imageType = 'image/png';
            image = screenshotData.substring(prefix.length);
            if (requestState.endsWith('_includeDepth')) {
                const depthArray = viewer.display.getDepthArray();
                convertEndian32(depthArray, Endianness.LITTLE);
                depthData = await toBase64(depthArray);
            }
        }
        const actionState = {
            viewerState: JSON.parse(_JSON$stringify(getCachedJson(this.viewer.state).value)),
            selectedValues: JSON.parse(_JSON$stringify(layerSelectedValues)),
            screenshot: { id: requestState, image, imageType, depthData, width, height }
        };
        this.sendScreenshotRequested.dispatch(actionState);
    }
}
//# sourceMappingURL=screenshots.js.map