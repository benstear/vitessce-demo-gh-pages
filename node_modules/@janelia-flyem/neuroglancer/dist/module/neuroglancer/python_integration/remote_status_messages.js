import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facility for displaying remote status messages.
 */
import debounce from 'lodash/debounce';
import { StatusMessage } from '../status';
import { NullarySignal } from '../util/signal';
import { RefCounted } from '../util/disposable';
import { verifyObject, verifyString } from '../util/json';
export class TrackableBasedStatusMessages extends RefCounted {
    constructor() {
        super();
        this.existingMessages = new _Map();
        this.changed = new NullarySignal();
        this.messages = new _Map();
        this.changed.add(this.registerCancellable(debounce(() => this.updateMessages(), 0)));
    }
    reset() {
        this.messages.clear();
        this.changed.dispatch();
    }
    restoreState(obj) {
        verifyObject(obj);
        this.messages.clear();
        for (const key of _Object$keys(obj)) {
            const value = obj[key];
            const text = verifyString(value);
            this.messages.set(key, text);
        }
        this.changed.dispatch();
    }
    disposed() {
        for (const message of this.existingMessages.values()) {
            message.dispose();
        }
        this.existingMessages.clear();
    }
    updateMessages() {
        const existingMessages = this.existingMessages;

        const newMessages = this.messages;
        for (const _ref of existingMessages) {
            var _ref2 = _slicedToArray(_ref, 2);

            const key = _ref2[0];
            const existingMessage = _ref2[1];

            const newMessage = newMessages.get(key);
            if (newMessage === undefined) {
                existingMessage.dispose();
                existingMessages.delete(key);
            } else {
                existingMessage.setText(newMessage);
            }
        }
        for (const _ref3 of newMessages) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const key = _ref4[0];
            const newMessage = _ref4[1];

            if (existingMessages.has(key)) {
                // Already handled by previous loop.
                continue;
            }
            const existingMessage = new StatusMessage();
            existingMessage.setText(newMessage);
            existingMessages.set(key, existingMessage);
        }
    }
    toJSON() {
        const result = {};
        for (const _ref5 of this.messages) {
            var _ref6 = _slicedToArray(_ref5, 2);

            const key = _ref6[0];
            const value = _ref6[1];

            result[key] = value;
        }
        return result;
    }
}
//# sourceMappingURL=remote_status_messages.js.map