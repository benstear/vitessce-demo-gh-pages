import _Math$log from 'babel-runtime/core-js/math/log2';
import _Number$isNaN from 'babel-runtime/core-js/number/is-nan';
import _Object$is from 'babel-runtime/core-js/object/is';
import _Number$isFinite from 'babel-runtime/core-js/number/is-finite';
import _Math$sign from 'babel-runtime/core-js/math/sign';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import _Array$from from 'babel-runtime/core-js/array/from';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { dimensionNamesFromJson, emptyInvalidCoordinateSpace, getBoundingBoxCenter, getCenterBound } from './coordinate_transform';
import { arraysEqual } from './util/array';
import { RefCounted } from './util/disposable';
import { mat3, mat4, quat, vec3 } from './util/geom';
import { parseArray, parseFiniteVec, verifyFiniteFloat, verifyFinitePositiveFloat, verifyObject, verifyObjectProperty } from './util/json';
import { NullarySignal } from './util/signal';
import { optionallyRestoreFromJsonMember } from './util/trackable';
import { TrackableEnum } from './util/trackable_enum';
import * as vector from './util/vector';
export var NavigationLinkType;
(function (NavigationLinkType) {
    NavigationLinkType[NavigationLinkType["LINKED"] = 0] = "LINKED";
    NavigationLinkType[NavigationLinkType["RELATIVE"] = 1] = "RELATIVE";
    NavigationLinkType[NavigationLinkType["UNLINKED"] = 2] = "UNLINKED";
})(NavigationLinkType || (NavigationLinkType = {}));
export var NavigationSimpleLinkType;
(function (NavigationSimpleLinkType) {
    NavigationSimpleLinkType[NavigationSimpleLinkType["LINKED"] = 0] = "LINKED";
    NavigationSimpleLinkType[NavigationSimpleLinkType["UNLINKED"] = 2] = "UNLINKED";
})(NavigationSimpleLinkType || (NavigationSimpleLinkType = {}));
export class TrackableNavigationLink extends TrackableEnum {
    constructor(value = NavigationLinkType.LINKED) {
        super(NavigationLinkType, value);
    }
}
export class TrackableNavigationSimpleLink extends TrackableEnum {
    constructor(value = NavigationSimpleLinkType.LINKED) {
        super(NavigationSimpleLinkType, value);
    }
}
const tempVec3 = vec3.create();
const tempQuat = quat.create();
function makeLinked(self, peer, link, operations) {
    let updatingSelf = false;
    let updatingPeer = false;
    let selfMinusPeer;
    self.registerDisposer(peer);
    const handlePeerUpdate = () => {
        if (updatingPeer) {
            return;
        }
        updatingSelf = true;
        switch (link.value) {
            case NavigationLinkType.UNLINKED:
                if (operations.isValid(self)) {
                    break;
                } else {
                    // Fallthrough to LINKED case.
                }
            case NavigationLinkType.LINKED:
                operations.assign(self, peer);
                break;
            case NavigationLinkType.RELATIVE:
                operations.add(self, peer, selfMinusPeer);
                break;
        }
        updatingSelf = false;
    };
    const handleSelfUpdate = () => {
        if (updatingSelf) {
            return;
        }
        switch (link.value) {
            case NavigationLinkType.UNLINKED:
                break;
            case NavigationLinkType.LINKED:
                operations.assign(peer, self);
                break;
            case NavigationLinkType.RELATIVE:
                operations.subtract(peer, self, selfMinusPeer);
                break;
        }
    };
    let previousLinkValue = NavigationLinkType.UNLINKED;
    const handleLinkUpdate = () => {
        const linkValue = link.value;
        if (linkValue !== previousLinkValue) {
            switch (linkValue) {
                case NavigationLinkType.UNLINKED:
                    selfMinusPeer = undefined;
                    break;
                case NavigationLinkType.LINKED:
                    selfMinusPeer = undefined;
                    operations.assign(self, peer);
                    break;
                case NavigationLinkType.RELATIVE:
                    selfMinusPeer = operations.difference(self, peer);
                    break;
            }
        }
        previousLinkValue = linkValue;
        self.changed.dispatch();
    };
    self.registerDisposer(self.changed.add(handleSelfUpdate));
    self.registerDisposer(peer.changed.add(handlePeerUpdate));
    self.registerDisposer(link.changed.add(handleLinkUpdate));
    handleLinkUpdate();
    return self;
}
function makeSimpleLinked(self, peer, link, operations) {
    return makeLinked(self, peer, link, operations);
}
export class Position extends RefCounted {
    constructor(coordinateSpace) {
        super();
        this.coordinateSpace = coordinateSpace;
        this.coordinates_ = vector.kEmptyFloat32Vec;
        this.changed = new NullarySignal();
        this.registerDisposer(coordinateSpace.changed.add(() => {
            this.handleCoordinateSpaceChanged();
        }));
    }
    get valid() {
        return this.coordinateSpace.value.valid;
    }
    /**
     * Returns the position in voxels.
     */
    get value() {
        this.handleCoordinateSpaceChanged();
        return this.coordinates_;
    }
    reset() {
        this.curCoordinateSpace = undefined;
        this.coordinates_ = vector.kEmptyFloat32Vec;
        this.changed.dispatch();
    }
    set value(coordinates) {
        const curCoordinateSpace = this.curCoordinateSpace;

        if (curCoordinateSpace === undefined || !curCoordinateSpace.valid || curCoordinateSpace.rank !== coordinates.length) {
            return;
        }
        const coordinates_ = this.coordinates_;

        coordinates_.set(coordinates);
        this.changed.dispatch();
    }
    handleCoordinateSpaceChanged() {
        const coordinateSpace = this.coordinateSpace.value;
        const prevCoordinateSpace = this.curCoordinateSpace;
        if (coordinateSpace === prevCoordinateSpace) return;
        this.curCoordinateSpace = coordinateSpace;
        const rank = coordinateSpace.rank;

        if (!coordinateSpace.valid) return;
        if (prevCoordinateSpace === undefined || !prevCoordinateSpace.valid) {
            let coordinates_ = this.coordinates_;

            if (coordinates_ !== undefined && coordinates_.length === rank) {
                // Use the existing voxel coordinates if rank is the same.  Otherwise, ignore.
            } else {
                coordinates_ = this.coordinates_ = new Float32Array(rank);
                getBoundingBoxCenter(coordinates_, coordinateSpace.bounds);
                for (let i = 0; i < rank; ++i) {
                    coordinates_[i] = Math.floor(coordinates_[i]) + 0.5;
                }
            }
            this.changed.dispatch();
            return;
        }
        // Match dimensions by ID.
        const newCoordinates = new Float32Array(rank);
        const prevCoordinates = this.coordinates_;
        const ids = coordinateSpace.ids,
              newScales = coordinateSpace.scales;
        const prevDimensionIds = prevCoordinateSpace.ids,
              oldScales = prevCoordinateSpace.scales;

        for (let newDim = 0; newDim < rank; ++newDim) {
            const newDimId = ids[newDim];
            const oldDim = prevDimensionIds.indexOf(newDimId);
            if (oldDim === -1) {
                newCoordinates[newDim] = getCenterBound(coordinateSpace.bounds.lowerBounds[newDim], coordinateSpace.bounds.upperBounds[newDim]);
            } else {
                newCoordinates[newDim] = prevCoordinates[oldDim] * (oldScales[oldDim] / newScales[newDim]);
            }
        }
        this.coordinates_ = newCoordinates;
        this.changed.dispatch();
    }
    toJSON() {
        if (!this.valid && this.coordinates_.length === 0) return undefined;
        this.handleCoordinateSpaceChanged();
        const value = this.value;

        if (value.length === 0) return undefined;
        return _Array$from(value);
    }
    restoreState(obj) {
        if (obj === undefined) {
            this.reset();
            return;
        }
        this.curCoordinateSpace = undefined;
        this.coordinates_ = Float32Array.from(parseArray(obj, verifyFiniteFloat));
        this.handleCoordinateSpaceChanged();
        this.changed.dispatch();
    }
    snapToVoxel() {
        this.handleCoordinateSpaceChanged();
        const coordinates_ = this.coordinates_;

        const rank = coordinates_.length;
        for (let i = 0; i < rank; ++i) {
            coordinates_[i] = Math.floor(coordinates_[i]) + 0.5;
        }
        this.changed.dispatch();
    }
    assign(other) {
        other.handleCoordinateSpaceChanged();
        const curCoordinateSpace = other.curCoordinateSpace,
              coordinates_ = other.coordinates_;

        this.curCoordinateSpace = curCoordinateSpace;
        this.coordinates_ = Float32Array.from(coordinates_);
        this.changed.dispatch();
    }
    /**
     * Get the offset of `a` relative to `b`.
     */
    static getOffset(a, b) {
        const aCoordinates = a.coordinates_;
        const bCoordinates = b.coordinates_;
        const rank = aCoordinates.length;
        if (rank === bCoordinates.length) {
            return vector.subtract(new Float32Array(aCoordinates.length), aCoordinates, bCoordinates);
        }
        return undefined;
    }
    static addOffset(target, source, offset, scale = 1) {
        target.handleCoordinateSpaceChanged();
        const sourceCoordinates = source.value;

        if (offset !== undefined && sourceCoordinates.length === offset.length) {
            vector.scaleAndAdd(target.value, sourceCoordinates, offset, scale);
            target.changed.dispatch();
        }
    }
    get legacyJsonView() {
        const self = this;
        return {
            changed: self.changed,
            toJSON() {
                return self.toJSON();
            },
            reset() {
                self.reset();
            },
            restoreState(obj) {
                if (obj === undefined || Array.isArray(obj)) {
                    self.restoreState(obj);
                    return;
                }
                verifyObject(obj);
                optionallyRestoreFromJsonMember(obj, 'voxelCoordinates', self);
            }
        };
    }
}
function restoreLinkedFromJson(link, value, json) {
    if (json === undefined || _Object$keys(json).length === 0) {
        link.value = NavigationLinkType.LINKED;
        return;
    }
    verifyObject(json);
    link.value = NavigationLinkType.UNLINKED;
    verifyObjectProperty(json, 'value', x => {
        if (x !== undefined) {
            value.restoreState(x);
        }
    });
    verifyObjectProperty(json, 'link', x => link.restoreState(x));
}
class LinkedBase {
    constructor(peer, link = new TrackableNavigationLink()) {
        this.peer = peer;
        this.link = link;
    }
    get changed() {
        return this.value.changed;
    }
    toJSON() {
        const link = this.link;

        if (link.value === NavigationLinkType.LINKED) {
            return undefined;
        }
        return { link: link.toJSON(), value: this.getValueJson() };
    }
    getValueJson() {
        return this.value.toJSON();
    }
    reset() {
        this.link.value = NavigationLinkType.LINKED;
    }
    restoreState(obj) {
        restoreLinkedFromJson(this.link, this.value, obj);
    }
    copyToPeer() {
        if (this.link.value !== NavigationLinkType.LINKED) {
            this.link.value = NavigationLinkType.UNLINKED;
            this.peer.assign(this.value);
            this.link.value = NavigationLinkType.LINKED;
        }
    }
}
class SimpleLinkedBase extends LinkedBase {
    constructor(peer, link = new TrackableNavigationSimpleLink()) {
        super(peer, link);
    }
}
export class LinkedPosition extends LinkedBase {
    constructor() {
        super(...arguments);
        this.value = makeLinked(new Position(this.peer.coordinateSpace), this.peer, this.link, {
            assign: (a, b) => a.assign(b),
            isValid: a => {
                return a.valid;
            },
            difference: Position.getOffset,
            add: Position.addOffset,
            subtract: (target, source, amount) => {
                Position.addOffset(target, source, amount, -1);
            }
        });
    }
}
function quaternionIsIdentity(q) {
    return q[0] === 0 && q[1] === 0 && q[2] === 0 && q[3] === 1;
}
export class OrientationState extends RefCounted {
    constructor(orientation) {
        super();
        this.changed = new NullarySignal();
        if (orientation == null) {
            orientation = quat.create();
        }
        this.orientation = orientation;
    }
    toJSON() {
        let orientation = this.orientation;

        quat.normalize(this.orientation, this.orientation);
        if (quaternionIsIdentity(orientation)) {
            return undefined;
        }
        return Array.prototype.slice.call(this.orientation);
    }
    restoreState(obj) {
        try {
            parseFiniteVec(this.orientation, obj);
            quat.normalize(this.orientation, this.orientation);
        } catch (ignoredError) {
            quat.identity(this.orientation);
        }
        this.changed.dispatch();
    }
    reset() {
        quat.identity(this.orientation);
        this.changed.dispatch();
    }
    snap() {
        let mat = mat3.create();
        mat3.fromQuat(mat, this.orientation);
        let usedAxes = [false, false, false];
        for (let i = 0; i < 3; ++i) {
            let maxComponent = 0;
            let argmaxComponent = 0;
            for (let j = 0; j < 3; ++j) {
                let value = mat[i * 3 + j];
                mat[i * 3 + j] = 0;
                if (usedAxes[j]) {
                    continue;
                }
                if (Math.abs(value) > Math.abs(maxComponent)) {
                    maxComponent = value;
                    argmaxComponent = j;
                }
            }
            mat[i * 3 + argmaxComponent] = _Math$sign(maxComponent);
            usedAxes[argmaxComponent] = true;
        }
        quat.fromMat3(this.orientation, mat);
        this.changed.dispatch();
    }
    /**
     * Returns a new OrientationState with orientation fixed to peerToSelf * peer.orientation.  Any
     * changes to the returned OrientationState will cause a corresponding change in peer, and vice
     * versa.
     */
    static makeRelative(peer, peerToSelf) {
        let self = new OrientationState(quat.multiply(quat.create(), peer.orientation, peerToSelf));
        let updatingPeer = false;
        self.registerDisposer(peer.changed.add(() => {
            if (!updatingPeer) {
                updatingSelf = true;
                quat.multiply(self.orientation, peer.orientation, peerToSelf);
                self.changed.dispatch();
                updatingSelf = false;
            }
        }));
        let updatingSelf = false;
        const selfToPeer = quat.invert(quat.create(), peerToSelf);
        self.registerDisposer(self.changed.add(() => {
            if (!updatingSelf) {
                updatingPeer = true;
                quat.multiply(peer.orientation, self.orientation, selfToPeer);
                peer.changed.dispatch();
                updatingPeer = false;
            }
        }));
        return self;
    }
    assign(other) {
        quat.copy(this.orientation, other.orientation);
        this.changed.dispatch();
    }
}
export class LinkedOrientationState extends LinkedBase {
    constructor() {
        super(...arguments);
        this.value = makeLinked(new OrientationState(), this.peer, this.link, {
            assign: (a, b) => a.assign(b),
            isValid: () => true,
            difference: (a, b) => {
                const temp = quat.create();
                return quat.multiply(temp, quat.invert(temp, b.orientation), a.orientation);
            },
            add: (target, source, amount) => {
                quat.multiply(target.orientation, source.orientation, amount);
                target.changed.dispatch();
            },
            subtract: (target, source, amount) => {
                quat.multiply(target.orientation, source.orientation, quat.invert(tempQuat, amount));
                target.changed.dispatch();
            }
        });
    }
}
export class TrackableRelativeDisplayScales extends RefCounted {
    constructor(coordinateSpace) {
        super();
        this.coordinateSpace = coordinateSpace;
        this.changed = new NullarySignal();
        this.curCoordinateSpace = emptyInvalidCoordinateSpace;
        this.value_ = { factors: new Float64Array(0) };
        this.registerDisposer(coordinateSpace.changed.add(() => this.update()));
        this.update();
    }
    get value() {
        return this.update();
    }
    reset() {
        this.value_ = { factors: new Float64Array(0) };
        this.curCoordinateSpace = emptyInvalidCoordinateSpace;
        this.changed.dispatch();
    }
    toJSON() {
        const json = {};
        let nonEmpty = false;
        const value = this.value;
        const factors = value.factors;
        var _curCoordinateSpace = this.curCoordinateSpace;
        const names = _curCoordinateSpace.names,
              rank = _curCoordinateSpace.rank;

        for (let i = 0; i < rank; ++i) {
            const factor = factors[i];
            if (factor === 1) continue;
            json[names[i]] = factor;
            nonEmpty = true;
        }
        if (nonEmpty) return json;
        return undefined;
    }
    restoreState(json) {
        const coordinateSpace = this.coordinateSpace.value;
        const names = coordinateSpace.names,
              rank = coordinateSpace.rank;

        const factors = new Float64Array(rank);
        factors.fill(-1);
        if (json !== undefined) {
            const obj = verifyObject(json);
            for (let i = 0; i < rank; ++i) {
                factors[i] = verifyObjectProperty(obj, names[i], x => x === undefined ? 1 : verifyFinitePositiveFloat(x));
            }
        }
        this.value_ = { factors };
        this.curCoordinateSpace = coordinateSpace;
        this.changed.dispatch();
    }
    setFactors(factors) {
        const coordinateSpace = this.coordinateSpace.value;

        if (factors.length !== coordinateSpace.rank) return;
        this.value_ = { factors };
        this.curCoordinateSpace = coordinateSpace;
        this.changed.dispatch();
    }
    update() {
        const coordinateSpace = this.coordinateSpace.value;

        let value = this.value_;
        const curCoordinateSpace = this.curCoordinateSpace;

        if (curCoordinateSpace === coordinateSpace) return value;
        const oldDimensionIds = curCoordinateSpace.ids;
        const newDimensionIds = coordinateSpace.ids,
              rank = coordinateSpace.rank;

        const oldFactors = value.factors;
        const newFactors = new Float64Array(rank);
        newFactors.fill(1);
        for (let i = 0; i < rank; ++i) {
            const id = newDimensionIds[i];
            const oldIndex = oldDimensionIds.indexOf(id);
            if (oldIndex === -1) continue;
            newFactors[i] = oldFactors[oldIndex];
        }
        if (arraysEqual(newFactors, oldFactors)) return value;
        value = this.value_ = { factors: newFactors };
        this.curCoordinateSpace = coordinateSpace;
        this.changed.dispatch();
        return value;
    }
    assign(other) {
        this.setFactors(other.value.factors);
    }
}
function mapPerDimensionValues(arrayConstructor, input, oldCoordinateSpace, newCoordinateSpace, defaultValue) {
    if (oldCoordinateSpace === newCoordinateSpace) return input;
    const oldDimensionIds = oldCoordinateSpace.ids;
    const newRank = newCoordinateSpace.rank,
          newDimensionIds = newCoordinateSpace.ids;

    const output = new arrayConstructor(newRank);
    for (let newDim = 0; newDim < newRank; ++newDim) {
        const id = newDimensionIds[newDim];
        const oldDim = oldDimensionIds.indexOf(id);
        output[newDim] = oldDim === -1 ? defaultValue(newDim) : input[oldDim];
    }
    return output;
}
export class LinkedRelativeDisplayScales extends LinkedBase {
    constructor() {
        super(...arguments);
        this.value = makeLinked(new TrackableRelativeDisplayScales(this.peer.coordinateSpace), this.peer, this.link, {
            assign: (target, source) => target.assign(source),
            difference: (a, b) => {
                const fa = a.value.factors;

                const coordinateSpace = a.coordinateSpace.value;
                const fb = b.value.factors;
                return {
                    coordinateSpace,
                    offsets: vector.subtract(new Float64Array(fa.length), fa, fb)
                };
            },
            add: (target, source, delta) => {
                const newOffsets = mapPerDimensionValues(Float64Array, delta.offsets, delta.coordinateSpace, target.coordinateSpace.value, () => 0);
                target.setFactors(vector.add(new Float64Array(newOffsets.length), newOffsets, source.value.factors));
            },
            subtract: (target, source, delta) => {
                const newOffsets = mapPerDimensionValues(Float64Array, delta.offsets, delta.coordinateSpace, target.coordinateSpace.value, () => 0);
                target.setFactors(vector.subtract(new Float64Array(newOffsets.length), source.value.factors, newOffsets));
            },
            isValid: () => true
        });
    }
}
function getDisplayDimensionRenderInfo(coordinateSpace, displayDimensions, relativeDisplayScales) {
    const globalRank = coordinateSpace.rank,
          globalDimensionNames = coordinateSpace.names,
          units = coordinateSpace.units;
    const displayRank = displayDimensions.displayRank,
          displayDimensionIndices = displayDimensions.displayDimensionIndices;

    const canonicalVoxelFactors = new Float64Array(3);
    let voxelPhysicalScales = new Float64Array(3);
    let canonicalVoxelPhysicalSize;
    const factors = relativeDisplayScales.factors;

    const displayDimensionUnits = new Array(3);
    const displayDimensionScales = new Float64Array(3);
    canonicalVoxelFactors.fill(1);
    voxelPhysicalScales.fill(1);
    displayDimensionScales.fill(1);
    displayDimensionUnits.fill('');
    if (displayRank === 0) {
        canonicalVoxelPhysicalSize = 1;
    } else {
        canonicalVoxelPhysicalSize = Number.POSITIVE_INFINITY;
        const scales = coordinateSpace.scales;

        for (let i = 0; i < displayRank; ++i) {
            const dim = displayDimensionIndices[i];
            const s = voxelPhysicalScales[i] = factors[dim] * scales[dim];
            canonicalVoxelPhysicalSize = Math.min(canonicalVoxelPhysicalSize, s);
            displayDimensionUnits[i] = units[dim];
            displayDimensionScales[i] = scales[dim];
        }
        for (let i = 0; i < displayRank; ++i) {
            canonicalVoxelFactors[i] = voxelPhysicalScales[i] / canonicalVoxelPhysicalSize;
        }
    }
    return {
        globalRank,
        globalDimensionNames,
        displayRank,
        displayDimensionIndices,
        displayDimensionUnits,
        displayDimensionScales,
        canonicalVoxelFactors,
        voxelPhysicalScales,
        canonicalVoxelPhysicalSize
    };
}
export function displayDimensionRenderInfosEqual(a, b) {
    return arraysEqual(a.globalDimensionNames, b.globalDimensionNames) && arraysEqual(a.displayDimensionIndices, b.displayDimensionIndices) && arraysEqual(a.canonicalVoxelFactors, b.canonicalVoxelFactors) && arraysEqual(a.voxelPhysicalScales, b.voxelPhysicalScales) && a.canonicalVoxelPhysicalSize === b.canonicalVoxelPhysicalSize && arraysEqual(a.displayDimensionUnits, b.displayDimensionUnits) && arraysEqual(a.displayDimensionScales, b.displayDimensionScales);
}
export class WatchableDisplayDimensionRenderInfo extends RefCounted {
    constructor(relativeDisplayScales, displayDimensions) {
        super();
        this.relativeDisplayScales = relativeDisplayScales;
        this.displayDimensions = displayDimensions;
        this.changed = new NullarySignal();
        this.curRelativeDisplayScales = this.relativeDisplayScales.value;
        this.curDisplayDimensions = this.displayDimensions.value;
        this.curCoordinateSpace = this.relativeDisplayScales.coordinateSpace.value;
        this.value_ = getDisplayDimensionRenderInfo(this.curCoordinateSpace, this.curDisplayDimensions, this.curRelativeDisplayScales);
        this.registerDisposer(relativeDisplayScales);
        this.registerDisposer(displayDimensions);
        const maybeUpdateValue = () => {
            this.value;
        };
        this.registerDisposer(relativeDisplayScales.changed.add(maybeUpdateValue));
        this.registerDisposer(displayDimensions.changed.add(maybeUpdateValue));
    }
    get value() {
        var _relativeDisplayScale = this.relativeDisplayScales;
        const relativeDisplayScales = _relativeDisplayScale.value,
              coordinateSpace = _relativeDisplayScale.coordinateSpace.value,
              displayDimensions = this.displayDimensions.value,
              curRelativeDisplayScales = this.curRelativeDisplayScales,
              curDisplayDimensions = this.curDisplayDimensions,
              curCoordinateSpace = this.curCoordinateSpace;

        let value = this.value_;
        if (curRelativeDisplayScales !== relativeDisplayScales || curDisplayDimensions !== displayDimensions || curCoordinateSpace !== coordinateSpace) {
            this.curRelativeDisplayScales = relativeDisplayScales;
            this.curDisplayDimensions = displayDimensions;
            this.curCoordinateSpace = coordinateSpace;
            const newValue = getDisplayDimensionRenderInfo(coordinateSpace, displayDimensions, relativeDisplayScales);
            if (!displayDimensionRenderInfosEqual(value, newValue)) {
                this.value_ = value = newValue;
                this.changed.dispatch();
            }
        }
        return value;
    }
}
export class TrackableDisplayDimensions extends RefCounted {
    constructor(coordinateSpace) {
        super();
        this.coordinateSpace = coordinateSpace;
        this.changed = new NullarySignal();
        this.default_ = true;
        this.value_ = undefined;
        this.registerDisposer(this.coordinateSpace.changed.add(this.changed.dispatch));
        this.update();
    }
    get value() {
        this.update();
        return this.value_;
    }
    update() {
        const coordinateSpace = this.coordinateSpace.value;

        const value = this.value_;
        if (value !== undefined && value.coordinateSpace === coordinateSpace) {
            return;
        }
        if (value === undefined || this.default_) {
            this.setToDefault(coordinateSpace);
            return;
        }
        const newDimensionIndices = new Int32Array(3);
        const oldDimensionIds = value.coordinateSpace.ids;
        const newDimensionIds = coordinateSpace.ids;

        const oldDimensionIndices = value.displayDimensionIndices;
        const oldRank = value.displayRank;
        let newRank = 0;
        for (let i = 0; i < oldRank; ++i) {
            const newDim = newDimensionIds.indexOf(oldDimensionIds[oldDimensionIndices[i]]);
            if (newDim === -1) continue;
            newDimensionIndices[newRank] = newDim;
            ++newRank;
        }
        newDimensionIndices.fill(-1, newRank);
        if (newRank === 0) {
            this.default_ = true;
            this.setToDefault(coordinateSpace);
            return;
        }
        this.assignValue(coordinateSpace, newRank, newDimensionIndices);
        this.changed.dispatch();
    }
    setToDefault(coordinateSpace) {
        const displayRank = Math.min(coordinateSpace.rank, 3);
        const displayDimensionIndices = new Int32Array(3);
        displayDimensionIndices.fill(-1);
        for (let i = 0; i < displayRank; ++i) {
            displayDimensionIndices[i] = i;
        }
        this.assignValue(coordinateSpace, displayRank, displayDimensionIndices);
    }
    assignValue(coordinateSpace, displayRank, displayDimensionIndices) {
        this.value_ = {
            coordinateSpace,
            displayRank,
            displayDimensionIndices
        };
        this.changed.dispatch();
    }
    reset() {
        this.default_ = true;
        this.value_ = undefined;
        this.changed.dispatch();
    }
    restoreState(obj) {
        if (obj === undefined) {
            this.reset();
            return;
        }
        const displayDimensionNames = dimensionNamesFromJson(obj);
        if (displayDimensionNames.length > 3) {
            throw new Error('Number of spatial dimensions must be <= 3');
        }
        const coordinateSpace = this.coordinateSpace.value;

        const displayDimensionIndices = new Int32Array(3);
        displayDimensionIndices.fill(-1);
        const names = coordinateSpace.names;

        let displayRank = 0;
        for (const name of displayDimensionNames) {
            const index = names.indexOf(name);
            if (index === -1) continue;
            displayDimensionIndices[displayRank++] = index;
        }
        if (displayRank === 0) {
            this.reset();
            return;
        }
        this.default_ = false;
        this.assignValue(coordinateSpace, displayRank, displayDimensionIndices);
    }
    get default() {
        this.update();
        return this.default_;
    }
    set default(value) {
        if (this.default_ === value) return;
        if (value) {
            this.default_ = true;
            this.setToDefault(this.coordinateSpace.value);
        } else {
            this.default_ = false;
            this.changed.dispatch();
        }
    }
    setDimensionIndices(rank, dimensionIndices) {
        this.default_ = false;
        this.assignValue(this.coordinateSpace.value, rank, dimensionIndices);
    }
    toJSON() {
        if (this.default_) return undefined;
        const value = this.value;

        const displayDimensionNames = [];
        const displayRank = value.displayRank,
              displayDimensionIndices = value.displayDimensionIndices,
              names = value.coordinateSpace.names;

        if (displayRank === 0) return undefined;
        for (let i = 0; i < displayRank; ++i) {
            displayDimensionNames[i] = names[displayDimensionIndices[i]];
        }
        return displayDimensionNames;
    }
    assign(other) {
        if (other.default) {
            this.default = true;
        } else {
            var _other$value = other.value;
            const displayRank = _other$value.displayRank,
                  displayDimensionIndices = _other$value.displayDimensionIndices;

            this.setDimensionIndices(displayRank, displayDimensionIndices);
        }
    }
}
export class LinkedDisplayDimensions extends SimpleLinkedBase {
    constructor(peer) {
        super(peer);
        this.value = makeSimpleLinked(new TrackableDisplayDimensions(this.peer.coordinateSpace), this.peer, this.link, {
            assign: (target, source) => target.assign(source),
            isValid: () => true
        });
    }
}
export class DisplayPose extends RefCounted {
    constructor(position, displayDimensionRenderInfo, orientation) {
        super();
        this.position = position;
        this.displayDimensionRenderInfo = displayDimensionRenderInfo;
        this.orientation = orientation;
        this.changed = new NullarySignal();
        this.registerDisposer(position);
        this.registerDisposer(orientation);
        this.registerDisposer(displayDimensionRenderInfo);
        this.registerDisposer(position.changed.add(this.changed.dispatch));
        this.registerDisposer(orientation.changed.add(this.changed.dispatch));
        this.registerDisposer(displayDimensionRenderInfo.changed.add(this.changed.dispatch));
    }
    get displayDimensions() {
        return this.displayDimensionRenderInfo.displayDimensions;
    }
    get relativeDisplayScales() {
        return this.displayDimensionRenderInfo.relativeDisplayScales;
    }
    get valid() {
        return this.position.valid;
    }
    /**
     * Resets everything.
     */
    reset() {
        this.position.reset();
        this.orientation.reset();
        this.displayDimensions.reset();
    }
    updateDisplayPosition(fun, temp = tempVec3) {
        var _position = this.position;
        const coordinateSpace = _position.coordinateSpace.value,
              voxelCoordinates = _position.value;
        var _displayDimensions$va = this.displayDimensions.value;
        const displayDimensionIndices = _displayDimensions$va.displayDimensionIndices,
              displayRank = _displayDimensions$va.displayRank;

        if (coordinateSpace === undefined) return false;
        temp.fill(0);
        for (let i = 0; i < displayRank; ++i) {
            const dim = displayDimensionIndices[i];
            temp[i] = voxelCoordinates[dim];
        }
        if (fun(temp) !== false) {
            for (let i = 0; i < displayRank; ++i) {
                const dim = displayDimensionIndices[i];
                voxelCoordinates[dim] = temp[i];
            }
            this.position.changed.dispatch();
            return true;
        }
        return false;
    }
    // Transform from view coordinates to global spatial coordinates.
    toMat4(mat, zoom) {
        mat4.fromQuat(mat, this.orientation.orientation);
        const voxelCoordinates = this.position.value;
        var _displayDimensionRend = this.displayDimensionRenderInfo.value;
        const canonicalVoxelFactors = _displayDimensionRend.canonicalVoxelFactors,
              displayDimensionIndices = _displayDimensionRend.displayDimensionIndices;

        for (let i = 0; i < 3; ++i) {
            const dim = displayDimensionIndices[i];
            const scale = zoom / canonicalVoxelFactors[i];
            mat[i] *= scale;
            mat[4 + i] *= scale;
            mat[8 + i] *= scale;
            mat[12 + i] = voxelCoordinates[dim] || 0;
        }
    }
    toMat3(mat, zoom) {
        mat3.fromQuat(mat, this.orientation.orientation);
        var _displayDimensionRend2 = this.displayDimensionRenderInfo.value;
        const canonicalVoxelFactors = _displayDimensionRend2.canonicalVoxelFactors,
              displayRank = _displayDimensionRend2.displayRank;

        for (let i = 0; i < displayRank; ++i) {
            const scale = zoom / canonicalVoxelFactors[i];
            mat[i] *= scale;
            mat[3 + i] *= scale;
            mat[6 + i] *= scale;
        }
    }
    /**
     * Snaps the orientation to the nearest axis-aligned orientation, and
     * snaps the position to the nearest voxel.
     */
    snap() {
        this.orientation.snap();
        this.position.snapToVoxel();
        this.changed.dispatch();
    }
    translateDimensionRelative(dimensionIndex, adjustment) {
        if (!this.valid) {
            return;
        }
        const position = this.position;
        const voxelCoordinates = position.value;
        var _position$coordinateS = position.coordinateSpace.value.bounds;
        const lowerBounds = _position$coordinateS.lowerBounds,
              upperBounds = _position$coordinateS.upperBounds;

        let newValue = voxelCoordinates[dimensionIndex] + adjustment;
        if (adjustment > 0) {
            const bound = upperBounds[dimensionIndex];
            if (_Number$isFinite(bound)) {
                newValue = Math.min(newValue, Math.ceil(bound - 1));
            }
        } else {
            const bound = lowerBounds[dimensionIndex];
            if (_Number$isFinite(bound)) {
                newValue = Math.max(newValue, Math.floor(bound));
            }
        }
        voxelCoordinates[dimensionIndex] = newValue;
        position.changed.dispatch();
    }
    translateVoxelsRelative(translation, round = false) {
        if (!this.valid) {
            return;
        }
        const temp = vec3.transformQuat(tempVec3, translation, this.orientation.orientation);
        const position = this.position;
        const voxelCoordinates = position.value;
        var _displayDimensions$va2 = this.displayDimensions.value;
        const displayDimensionIndices = _displayDimensions$va2.displayDimensionIndices,
              displayRank = _displayDimensions$va2.displayRank;
        var _position$coordinateS2 = position.coordinateSpace.value.bounds;
        const lowerBounds = _position$coordinateS2.lowerBounds,
              upperBounds = _position$coordinateS2.upperBounds;

        for (let i = 0; i < displayRank; ++i) {
            const dim = displayDimensionIndices[i];
            const adjustment = temp[i];
            if (adjustment === 0) continue;
            let newValue = voxelCoordinates[dim] + adjustment;
            if (adjustment > 0) {
                const bound = upperBounds[dim];
                if (_Number$isFinite(bound)) {
                    newValue = Math.min(newValue, Math.ceil(bound - 1));
                }
            } else {
                const bound = lowerBounds[dim];
                if (_Number$isFinite(bound)) {
                    newValue = Math.max(newValue, Math.floor(bound));
                }
            }
            if (round) newValue = Math.floor(newValue) + 0.5;
            voxelCoordinates[dim] = newValue;
        }
        this.position.changed.dispatch();
    }
    rotateRelative(axis, angle) {
        var temp = quat.create();
        quat.setAxisAngle(temp, axis, angle);
        var orientation = this.orientation.orientation;
        quat.multiply(orientation, orientation, temp);
        this.orientation.changed.dispatch();
    }
    rotateAbsolute(axis, angle, fixedPoint) {
        var _position2 = this.position;
        const coordinateSpace = _position2.coordinateSpace.value,
              voxelCoordinates = _position2.value;

        if (coordinateSpace === undefined) return;
        const relativeDisplayScales = this.relativeDisplayScales.value.factors;
        var _displayDimensions$va3 = this.displayDimensions.value;
        const displayDimensionIndices = _displayDimensions$va3.displayDimensionIndices,
              displayRank = _displayDimensions$va3.displayRank;
        const scales = coordinateSpace.scales;

        const temp = quat.create();
        quat.setAxisAngle(temp, axis, angle);
        const orientation = this.orientation.orientation;
        // We want the coordinates in the transformed coordinate frame of the fixed point to remain
        // the same after the rotation.
        // We have the invariants:
        // oldOrienation * fixedPointLocal + oldPosition == fixedPoint.
        // newOrientation * fixedPointLocal + newPosition == fixedPoint.
        // Therefore, we compute fixedPointLocal by:
        // fixedPointLocal == inverse(oldOrientation) * (fixedPoint - oldPosition).
        const fixedPointLocal = tempVec3;
        tempVec3.fill(0);
        for (let i = 0; i < displayRank; ++i) {
            const dim = displayDimensionIndices[i];
            const diff = fixedPoint[dim] - voxelCoordinates[dim];
            fixedPointLocal[i] = diff * scales[dim] * relativeDisplayScales[dim];
        }
        const invOrientation = quat.invert(tempQuat, orientation);
        vec3.transformQuat(fixedPointLocal, fixedPointLocal, invOrientation);
        // We then compute the newPosition by:
        // newPosition := fixedPoint - newOrientation * fixedPointLocal.
        quat.multiply(orientation, temp, orientation);
        vec3.transformQuat(fixedPointLocal, fixedPointLocal, orientation);
        for (let i = 0; i < displayRank; ++i) {
            const dim = displayDimensionIndices[i];
            voxelCoordinates[dim] = fixedPoint[dim] - fixedPointLocal[i] / (scales[dim] * relativeDisplayScales[dim]);
        }
        this.position.changed.dispatch();
        this.orientation.changed.dispatch();
    }
    translateNonDisplayDimension(nonSpatialDimensionIndex, adjustment) {
        if (!this.valid) return;
        const displayDimensionIndices = this.displayDimensions.value.displayDimensionIndices;
        const position = this.position;

        const rank = position.coordinateSpace.value.rank;
        for (let i = 0; i < rank; ++i) {
            if (displayDimensionIndices.indexOf(i) !== -1) continue;
            if (nonSpatialDimensionIndex-- === 0) {
                this.translateDimensionRelative(i, adjustment);
                return;
            }
        }
    }
}
export class LinkedZoomState extends LinkedBase {
    constructor(peer, displayDimensionRenderInfo) {
        super(peer);
        this.value = (() => {
            const self = new peer.constructor(displayDimensionRenderInfo);
            const assign = (target, source) => {
                target.assign(source);
            };
            const difference = (a, b) => {
                return a.value / b.value * (a.canonicalVoxelPhysicalSize / b.canonicalVoxelPhysicalSize);
            };
            const add = (target, source, amount) => {
                target.setPhysicalScale(source.value * amount, source.canonicalVoxelPhysicalSize);
            };
            const subtract = (target, source, amount) => {
                target.setPhysicalScale(source.value / amount, source.canonicalVoxelPhysicalSize);
            };
            const isValid = x => x.coordinateSpaceValue.valid && x.canonicalVoxelPhysicalSize !== 0;
            makeLinked(self, this.peer, this.link, { assign, isValid, difference, add, subtract });
            return self;
        })();
    }
}
export function linkedStateLegacyJsonView(linked) {
    return {
        changed: linked.changed,
        toJSON() {
            return linked.toJSON();
        },
        restoreState(obj) {
            restoreLinkedFromJson(linked.link, linked.value.legacyJsonView, obj);
        },
        reset() {
            linked.reset();
        }
    };
}
class TrackableZoom extends RefCounted {
    constructor(displayDimensionRenderInfo) {
        super();
        this.displayDimensionRenderInfo = displayDimensionRenderInfo;
        this.changed = new NullarySignal();
        this.curCanonicalVoxelPhysicalSize = 0;
        this.value_ = Number.NaN;
        this.legacyValue_ = Number.NaN;
        this.registerDisposer(displayDimensionRenderInfo);
        this.registerDisposer(displayDimensionRenderInfo.changed.add(() => this.handleCoordinateSpaceChanged()));
        this.registerDisposer(displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace.changed.add(() => this.handleCoordinateSpaceChanged()));
        this.handleCoordinateSpaceChanged();
    }
    /**
     * Zoom factor.  For cross section views, in canonical voxels per viewport pixel.  For projection
     * views, in canonical voxels per viewport height (for orthographic projection).
     */
    get value() {
        this.handleCoordinateSpaceChanged();
        return this.value_;
    }
    set value(value) {
        const canonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;

        if (_Object$is(value, this.value_) && canonicalVoxelPhysicalSize === this.curCanonicalVoxelPhysicalSize) {
            return;
        }
        this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;
        this.legacyValue_ = Number.NaN;
        this.value_ = value;
        this.changed.dispatch();
    }
    get canonicalVoxelPhysicalSize() {
        return this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
    }
    get coordinateSpaceValue() {
        return this.displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace.value;
    }
    /**
     * Sets the zoom factor in the legacy units.  For cross section views, `1e-9` spatial units per
     * viewport pixel.  For projection views, `2 * 100 * Math.tan(Math.PI / 8) * 1e-9` spatial units
     * per viewport height (for orthographic projection).
     */
    set legacyValue(value) {
        if (_Object$is(value, this.legacyValue_)) return;
        this.value_ = Number.NaN;
        this.legacyValue_ = value;
        this.curCanonicalVoxelPhysicalSize = 0;
        this.changed.dispatch();
    }
    get legacyValue() {
        return this.legacyValue_;
    }
    handleCoordinateSpaceChanged() {
        const value_ = this.value_;
        var _displayDimensionRend3 = this.displayDimensionRenderInfo;
        const canonicalVoxelPhysicalSize = _displayDimensionRend3.value.canonicalVoxelPhysicalSize,
              coordinateSpace = _displayDimensionRend3.relativeDisplayScales.coordinateSpace.value;
        const curCanonicalVoxelPhysicalSize = this.curCanonicalVoxelPhysicalSize;

        if (!_Number$isNaN(value_) && canonicalVoxelPhysicalSize === curCanonicalVoxelPhysicalSize) {
            return;
        }
        if (!_Number$isNaN(value_)) {
            if (curCanonicalVoxelPhysicalSize !== 0) {
                this.value_ = value_ * (curCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize);
                this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;
                this.changed.dispatch();
            }
            return;
        }
        if (!coordinateSpace.valid || canonicalVoxelPhysicalSize === 0) {
            return;
        }
        this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;
        this.value_ = this.getDefaultValue();
        this.changed.dispatch();
    }
    toJSON() {
        const value = this.value;

        return _Number$isNaN(value) ? undefined : value;
    }
    restoreState(obj) {
        this.curCanonicalVoxelPhysicalSize = 0;
        this.legacyValue_ = Number.NaN;
        if (obj === undefined) {
            this.value_ = Number.NaN;
        } else {
            this.value_ = verifyFinitePositiveFloat(obj);
        }
        this.changed.dispatch();
    }
    reset() {
        this.curCanonicalVoxelPhysicalSize = 0;
        this.value_ = Number.NaN;
        this.legacyValue_ = Number.NaN;
        this.changed.dispatch();
    }
    get legacyJsonView() {
        const self = this;
        return {
            changed: self.changed,
            toJSON() {
                return self.toJSON();
            },
            reset() {
                return self.reset();
            },
            restoreState(obj) {
                self.legacyValue = verifyFinitePositiveFloat(obj);
            }
        };
    }
    setPhysicalScale(scaleInCanonicalVoxels, canonicalVoxelPhysicalSize) {
        const curCanonicalVoxelPhysicalSize = this.curCanonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;
        this.value = scaleInCanonicalVoxels * (canonicalVoxelPhysicalSize / curCanonicalVoxelPhysicalSize);
    }
    assign(source) {
        const legacyValue = source.legacyValue;

        if (!_Number$isNaN(legacyValue)) {
            this.legacyValue = legacyValue;
        } else {
            this.setPhysicalScale(source.value, source.canonicalVoxelPhysicalSize);
        }
    }
}
export class TrackableCrossSectionZoom extends TrackableZoom {
    getDefaultValue() {
        const legacyValue_ = this.legacyValue_;

        if (_Number$isNaN(legacyValue_)) {
            // Default is 1 voxel per viewport pixel.
            return 1;
        }
        const canonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;

        return this.legacyValue_ * 1e-9 / canonicalVoxelPhysicalSize;
    }
}
export class TrackableProjectionZoom extends TrackableZoom {
    getDefaultValue() {
        const legacyValue_ = this.legacyValue_;

        if (!_Number$isNaN(legacyValue_)) {
            this.legacyValue_ = Number.NaN;
            const canonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;

            return 2 * 100 * Math.tan(Math.PI / 8) * 1e-9 * legacyValue_ / canonicalVoxelPhysicalSize;
        }
        var _coordinateSpaceValue = this.coordinateSpaceValue.bounds;
        const lowerBounds = _coordinateSpaceValue.lowerBounds,
              upperBounds = _coordinateSpaceValue.upperBounds;
        var _displayDimensionRend4 = this.displayDimensionRenderInfo.value;
        const canonicalVoxelFactors = _displayDimensionRend4.canonicalVoxelFactors,
              displayDimensionIndices = _displayDimensionRend4.displayDimensionIndices;

        let value = canonicalVoxelFactors.reduce((x, factor, i) => {
            const dim = displayDimensionIndices[i];
            const extent = (upperBounds[dim] - lowerBounds[dim]) * factor;
            return Math.max(x, extent);
        }, 0);
        if (!_Number$isFinite(value)) {
            // Default to showing 1024 voxels if there is no bounds information.
            value = 1024;
        } else {
            value = 2 ** Math.ceil(_Math$log(value));
        }
        return value;
    }
}
export class TrackableDepthRange extends RefCounted {
    constructor(defaultValue, displayDimensionRenderInfo) {
        super();
        this.defaultValue = defaultValue;
        this.displayDimensionRenderInfo = displayDimensionRenderInfo;
        this.changed = new NullarySignal();
        this.value_ = defaultValue;
        this.canonicalVoxelPhysicalSize = displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
        this.registerDisposer(displayDimensionRenderInfo.changed.add(() => {
            this.value;
        }));
    }
    get value() {
        let value_ = this.value_;

        if (value_ > 0) {
            const canonicalVoxelPhysicalSize = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;

            const prevCanonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;
            if (canonicalVoxelPhysicalSize !== prevCanonicalVoxelPhysicalSize) {
                this.canonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;
                value_ = this.value_ = value_ = prevCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize;
                this.changed.dispatch();
            }
        }
        return value_;
    }
    set value(value) {
        if (value === this.value) return;
        this.value_ = value;
        const canonicalVoxelPhysicalSize = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;

        this.canonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;
        this.changed.dispatch();
    }
    toJSON() {
        const value = this.value;

        if (value === this.defaultValue) return undefined;
        return value;
    }
    reset() {
        this.value = this.defaultValue;
    }
    restoreState(obj) {
        if (typeof obj !== 'number' || !_Number$isFinite(obj) || obj === 0) {
            this.value = this.defaultValue;
        } else {
            this.value = obj;
        }
    }
    setValueAbsolute(value, sourceCanonicalVoxelPhysicalSize) {
        if (value > 0) {
            const canonicalVoxelPhysicalSize = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;

            value = value * (sourceCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize);
        }
        this.value = value;
    }
    assign(other) {
        this.setValueAbsolute(other.value, other.canonicalVoxelPhysicalSize);
    }
}
export class LinkedDepthRange extends SimpleLinkedBase {
    constructor(peer, displayDimensionRenderInfo) {
        super(peer);
        this.value = makeSimpleLinked(new TrackableDepthRange(peer.defaultValue, displayDimensionRenderInfo), this.peer, this.link, {
            assign: (target, source) => target.assign(source),
            isValid: () => true
        });
    }
}
export class NavigationState extends RefCounted {
    constructor(pose, zoomFactor, depthRange) {
        super();
        this.pose = pose;
        this.zoomFactor = zoomFactor;
        this.depthRange = depthRange;
        this.changed = new NullarySignal();
        this.registerDisposer(pose);
        this.registerDisposer(zoomFactor);
        this.registerDisposer(depthRange);
        this.registerDisposer(this.pose.changed.add(this.changed.dispatch));
        this.registerDisposer(this.zoomFactor.changed.add(this.changed.dispatch));
        this.registerDisposer(this.depthRange.changed.add(this.changed.dispatch));
    }
    get coordinateSpace() {
        return this.pose.position.coordinateSpace;
    }
    /**
     * Resets everything.
     */
    reset() {
        this.pose.reset();
        this.zoomFactor.reset();
    }
    get position() {
        return this.pose.position;
    }
    get displayDimensions() {
        return this.pose.displayDimensions;
    }
    get relativeDisplayScales() {
        return this.pose.relativeDisplayScales;
    }
    get displayDimensionRenderInfo() {
        return this.pose.displayDimensionRenderInfo;
    }
    toMat4(mat) {
        this.pose.toMat4(mat, this.zoomFactor.value);
    }
    toMat3(mat) {
        this.pose.toMat3(mat, this.zoomFactor.value);
    }
    get relativeDepthRange() {
        let depthRange = this.depthRange.value;
        if (depthRange > 0) {
            depthRange /= this.zoomFactor.value;
        } else {
            depthRange *= -1;
        }
        return depthRange;
    }
    get valid() {
        return this.pose.valid && !_Number$isNaN(this.zoomFactor.value);
    }
    zoomBy(factor) {
        this.zoomFactor.value *= factor;
    }
}
//# sourceMappingURL=navigation_state.js.map