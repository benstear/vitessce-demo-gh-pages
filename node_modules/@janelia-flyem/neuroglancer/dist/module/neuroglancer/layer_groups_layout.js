import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Array$from from 'babel-runtime/core-js/array/from';
import _Symbol$iterator from 'babel-runtime/core-js/symbol/iterator';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Set from 'babel-runtime/core-js/set';
import _Symbol from 'babel-runtime/core-js/symbol';

import debounce from 'lodash/debounce'; /**
                                         * @license
                                         * Copyright 2017 Google Inc.
                                         * Licensed under the Apache License, Version 2.0 (the "License");
                                         * you may not use this file except in compliance with the License.
                                         * You may obtain a copy of the License at
                                         *
                                         *      http://www.apache.org/licenses/LICENSE-2.0
                                         *
                                         * Unless required by applicable law or agreed to in writing, software
                                         * distributed under the License is distributed on an "AS IS" BASIS,
                                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                         * See the License for the specific language governing permissions and
                                         * limitations under the License.
                                         */
/**
 * @file Facilities for laying out multiple LayerGroupViewer instances.
 */

import { LayerSubsetSpecification } from './layer';
import { getViewerDropEffect, hasViewerDrag, LayerGroupViewer, viewerDragType } from './layer_group_viewer';
import { popDragStatus, pushDragStatus } from './ui/drag_and_drop';
import { endLayerDrag, getDropLayers, getLayerDragInfo, updateLayerDropEffect } from './ui/layer_drag_and_drop';
import { RefCounted } from './util/disposable';
import { removeFromParent } from './util/dom';
import { getDropEffect, setDropEffect } from './util/drag_and_drop';
import { parseArray, verifyObject, verifyObjectProperty, verifyString } from './util/json';
import { NullarySignal } from './util/signal';
const layoutComponentContainerSymbol = _Symbol('layoutComponentContainer');
/**
 * Container for a LayoutComponent.  The contained LayoutComponent may change.
 */
export class LayoutComponentContainer extends RefCounted {
    constructor(viewer, spec, parent) {
        super();
        this.viewer = viewer;
        this.parent = parent;
        this.changed = new NullarySignal();
        this.element = document.createElement('div');
        const element = this.element;

        element.style.display = 'flex';
        element.style.flex = '1';
        element.style.position = 'relative';
        element.style.alignItems = 'stretch';
        element[layoutComponentContainerSymbol] = this;
        this.setSpecification(spec);
        const dropZones = [];
        const makeDropZone = name => {
            const dropZone = document.createElement('div');
            dropZone.className = 'neuroglancer-layout-split-drop-zone';
            let direction;
            dropZone.style[name] = '0';
            switch (name) {
                case 'left':
                case 'right':
                    direction = 'row';
                    dropZone.style.width = '10px';
                    dropZone.style.height = '100%';
                    break;
                case 'top':
                case 'bottom':
                    direction = 'column';
                    dropZone.style.height = '10px';
                    dropZone.style.width = '100%';
                    break;
            }
            dropZone.style.display = 'none';
            dropZones.push({ element: dropZone, direction: direction, orientation: name });
            element.appendChild(dropZone);
            setupDropZone(dropZone, this.viewer.layerSpecification, () => this.split(name).newContainer.component, direction === 'row' ? 'column' : 'row');
        };
        makeDropZone('left');
        makeDropZone('right');
        makeDropZone('top');
        makeDropZone('bottom');
        let dropZonesVisible = false;
        element.addEventListener('dragenter', event => {
            if (dropZonesVisible) {
                return;
            }
            if (getLayerDragInfo(event) === undefined) {
                return;
            }
            dropZonesVisible = true;
            for (const _ref of dropZones) {
                const dropZone = _ref.element;
                const direction = _ref.direction;
                const orientation = _ref.orientation;

                if (parent !== undefined && direction === parent.direction) {
                    if ((orientation === 'left' || orientation === 'top') && parent.get(0) !== this || (orientation === 'bottom' || orientation === 'right') && parent.get(parent.length - 1) !== this) {
                        continue;
                    }
                }
                const component = this.component;

                if (component instanceof StackLayoutComponent && component.direction === direction) {
                    continue;
                }
                dropZone.style.display = 'block';
            }
        }, true);
        element.addEventListener('drop', _event => {
            if (!dropZonesVisible) {
                return;
            }
            dropZonesVisible = false;
            for (const _ref2 of dropZones) {
                const dropZone = _ref2.element;

                dropZone.style.display = 'none';
            }
        }, /*capture=*/true);
        element.addEventListener('dragleave', event => {
            const relatedTarget = event.relatedTarget;

            if (!dropZonesVisible) {
                return;
            }
            if (relatedTarget instanceof HTMLElement && this.element.contains(relatedTarget)) {
                return;
            }
            dropZonesVisible = false;
            for (const _ref3 of dropZones) {
                const dropZone = _ref3.element;

                dropZone.style.display = 'none';
            }
        }, true);
    }
    unsetComponent() {
        const oldComponent = this.componentValue;
        if (oldComponent !== undefined) {
            oldComponent.changed.remove(this.changed.dispatch);
            this.element.removeChild(oldComponent.element);
            oldComponent.dispose();
        }
    }
    get component() {
        return this.componentValue;
    }
    setComponent(component) {
        this.unsetComponent();
        this.componentValue = component;
        component.changed.add(this.changed.dispatch);
        this.element.appendChild(component.element);
        if (component instanceof LayerGroupViewer) {
            const layerManager = component.layerManager;

            const scheduleMaybeDelete = component.registerCancellable(debounce(() => {
                if (layerManager.managedLayers.length === 0) {
                    this.dispose();
                }
            }, 0));
            component.registerDisposer(layerManager.layersChanged.add(() => {
                if (layerManager.managedLayers.length === 0) {
                    scheduleMaybeDelete();
                }
            }));
            scheduleMaybeDelete();
        } else if (component instanceof StackLayoutComponent) {
            const scheduleMaybeDelete = component.registerCancellable(debounce(() => {
                const length = component.length;

                if (length === 0 && this.parent !== undefined) {
                    this.dispose();
                } else if (length === 1) {
                    const childComponent = component.get(0).component;
                    let spec;
                    if (this.parent === undefined && childComponent instanceof LayerGroupViewer) {
                        spec = childComponent.layout.specification.toJSON();
                        childComponent.viewerNavigationState.copyToParent();
                        const childManagedLayers = childComponent.layerManager.managedLayers;
                        const layersToKeep = new _Set(childManagedLayers);
                        const layerSpecification = childComponent.layerSpecification;
                        // Retain only layers that are part of the layer group, or are archived.

                        layerSpecification.rootLayers.filter(layer => layersToKeep.has(layer) || layer.archived);
                        // Permute the non-archived layers to match the order in the layer group.
                        const childLayerIndices = [];
                        const rootManagedLayers = layerSpecification.rootLayers.managedLayers;

                        for (let i = 0, count = rootManagedLayers.length; i < count; ++i) {
                            if (layersToKeep.has(rootManagedLayers[i])) {
                                childLayerIndices.push(i);
                            }
                        }
                        for (let i = 0, count = childManagedLayers.length; i < count; ++i) {
                            rootManagedLayers[childLayerIndices[i]] = childManagedLayers[i];
                        }
                        layerSpecification.rootLayers.layersChanged.dispatch();
                    } else {
                        spec = childComponent.toJSON();
                    }
                    this.setSpecification(spec);
                }
            }, 0));
            component.registerDisposer(component.changed.add(() => {
                if (component.length < 2) {
                    scheduleMaybeDelete();
                }
            }));
            scheduleMaybeDelete();
        }
        this.changed.dispatch();
    }
    toJSON() {
        return this.component.toJSON();
    }
    setSpecification(spec) {
        this.setComponent(makeComponent(this, spec));
    }
    static getFromElement(element) {
        return element[layoutComponentContainerSymbol];
    }
    disposed() {
        this.unsetComponent();
        this.componentValue = undefined;
        super.disposed();
    }
    split(side) {
        const newComponentSpec = {
            type: 'viewer'
        };
        const parent = this.parent;

        if (parent !== undefined) {
            if (side === 'left' && parent.direction === 'row' || side === 'top' && parent.direction === 'column') {
                return { newContainer: parent.insertChild(newComponentSpec, this), existingContainer: this };
            } else if (side === 'right' && parent.direction === 'row' || side === 'bottom' && parent.direction === 'column') {
                return { newContainer: parent.insertChild(newComponentSpec), existingContainer: this };
            }
        }
        let existingComponentSpec;
        const existingComponent = this.component;
        if (existingComponent instanceof SingletonLayerGroupViewer) {
            existingComponentSpec = existingComponent.layerGroupViewer.toJSON();
        } else {
            existingComponentSpec = existingComponent.toJSON();
        }
        let spec;
        let newIndex;
        const direction = side === 'left' || side === 'right' ? 'row' : 'column';
        switch (side) {
            case 'left':
            case 'top':
                spec = { type: direction, children: [newComponentSpec, existingComponentSpec] };
                newIndex = 0;
                break;
            case 'right':
            case 'bottom':
                spec = { type: direction, children: [existingComponentSpec, newComponentSpec] };
                newIndex = 1;
                break;
        }
        this.setSpecification(spec);
        const stackComponent = this.component;
        return {
            newContainer: stackComponent.get(newIndex),
            existingContainer: stackComponent.get(1 - newIndex)
        };
    }
}
function getCommonViewerState(viewer) {
    return {
        mouseState: viewer.mouseState,
        showAxisLines: viewer.showAxisLines,
        wireFrame: viewer.wireFrame,
        showScaleBar: viewer.showScaleBar,
        scaleBarOptions: viewer.scaleBarOptions,
        showPerspectiveSliceViews: viewer.showPerspectiveSliceViews,
        inputEventBindings: viewer.inputEventBindings,
        visibility: viewer.visibility,
        selectedLayer: viewer.selectedLayer,
        visibleLayerRoles: viewer.visibleLayerRoles,
        navigationState: viewer.navigationState.addRef(),
        perspectiveNavigationState: viewer.perspectiveNavigationState.addRef(),
        crossSectionBackgroundColor: viewer.crossSectionBackgroundColor,
        perspectiveViewBackgroundColor: viewer.perspectiveViewBackgroundColor
    };
}
export class SingletonLayerGroupViewer extends RefCounted {
    constructor(element, layout, viewer) {
        super();
        this.element = element;
        this.layerGroupViewer = this.registerDisposer(new LayerGroupViewer(element, _Object$assign({ display: viewer.display, layerSpecification: viewer.layerSpecification.addRef() }, getCommonViewerState(viewer)), {
            showLayerPanel: viewer.uiControlVisibility.showLayerPanel,
            showViewerMenu: false,
            showLayerHoverValues: viewer.uiControlVisibility.showLayerHoverValues
        }));
        this.layerGroupViewer.layout.restoreState(layout);
    }
    toJSON() {
        return this.layerGroupViewer.layout.specification.toJSON();
    }
    get changed() {
        return this.layerGroupViewer.layout.changed;
    }
}
function setupDropZone(dropZone, manager, makeLayerGroupViewer, direction) {
    dropZone.addEventListener('dragenter', event => {
        const dragInfo = getLayerDragInfo(event);
        if (dragInfo === undefined) {
            return;
        }
        dropZone.classList.add('neuroglancer-drag-over');
    });
    dropZone.addEventListener('dragleave', () => {
        popDragStatus(dropZone, 'drop');
        dropZone.classList.remove('neuroglancer-drag-over');
    });
    dropZone.addEventListener('dragover', event => {
        const allowDrag = (info, message) => {
            if (info.dropEffectMessage) message += ` (${info.dropEffectMessage})`;
            pushDragStatus(dropZone, 'drop', message);
            event.stopPropagation();
            event.preventDefault();
        };
        if (hasViewerDrag(event)) {
            const info = getViewerDropEffect(event, manager);
            setDropEffect(event, info.dropEffect);
            allowDrag(info, `Drop to ${info.dropEffect} layer group as new ${direction}`);
            return;
        }
        if (getLayerDragInfo(event) !== undefined) {
            const info = updateLayerDropEffect(event, manager, /*targetIsLayerListPanel=*/false, /*newTarget=*/true);
            allowDrag(info, `Drop to ${info.dropEffect} layer as new ${direction}`);
            return;
        }
    });
    dropZone.addEventListener('drop', event => {
        dropZone.classList.remove('neuroglancer-drag-over');
        popDragStatus(dropZone, 'drop');
        let dropLayers;
        let layoutSpec;
        if (hasViewerDrag(event)) {
            event.stopPropagation();
            try {
                layoutSpec = JSON.parse(event.dataTransfer.getData(viewerDragType));
            } catch (e) {
                return;
            }
            dropLayers = getDropLayers(event, manager, { forceCopy: false, newTarget: true });
            if (dropLayers === undefined) return;
        } else {
            dropLayers = getDropLayers(event, manager, { forceCopy: getDropEffect() === 'copy', newTarget: true });
            if (dropLayers === undefined) return;
            layoutSpec = dropLayers.layoutSpec;
        }
        if (!dropLayers.initializeExternalLayers(event)) {
            if (!dropLayers.moveSupported) {
                for (const layer of dropLayers.layers.keys()) {
                    layer.dispose();
                }
            }
            return;
        }
        event.preventDefault();
        const dropEffect = event.dataTransfer.dropEffect = getDropEffect();
        endLayerDrag(dropEffect);
        const layerGroupViewer = makeLayerGroupViewer();
        dropLayers.updateArchiveStates(event);
        for (const newLayer of dropLayers.layers.keys()) {
            layerGroupViewer.layerSpecification.add(newLayer);
        }
        try {
            layerGroupViewer.restoreState(layoutSpec);
        } catch (_a) {
            layerGroupViewer.layout.reset();
            // Ignore error restoring layout.
        }
    });
}
export class StackLayoutComponent extends RefCounted {
    constructor(element, direction, children, container) {
        super();
        this.element = element;
        this.direction = direction;
        this.container = container;
        this.changed = new NullarySignal();
        element.classList.add('neuroglancer-stack-layout');
        element.classList.add(`neuroglancer-stack-layout-${direction}`);
        element.style.display = 'flex';
        element.style.flexDirection = direction;
        element.appendChild(this.makeDropPlaceholder(this));
        for (const childSpec of children) {
            this.insertChild(childSpec);
        }
    }
    get length() {
        return (this.element.childElementCount - 1) / 2;
    }
    makeDropPlaceholder(refCounted) {
        const dropZone = document.createElement('div');
        dropZone.className = 'neuroglancer-stack-layout-drop-placeholder';
        setupDropZone(dropZone, this.viewer.layerSpecification, () => {
            const nextElement = dropZone.nextElementSibling;
            let nextChild;
            if (nextElement !== null) {
                nextChild = LayoutComponentContainer.getFromElement(nextElement);
            }
            const newChild = this.insertChild({ type: 'viewer', layers: [] }, nextChild);
            return newChild.component;
        }, this.direction === 'row' ? 'column' : 'row');
        refCounted.registerDisposer(() => {
            removeFromParent(dropZone);
        });
        return dropZone;
    }
    get viewer() {
        return this.container.viewer;
    }
    get(index) {
        return LayoutComponentContainer.getFromElement(this.element.children[index * 2 + 1]);
    }
    insertChild(spec, before) {
        const child = new LayoutComponentContainer(this.viewer, spec, this);
        const dropZone = this.makeDropPlaceholder(child);
        child.element.classList.add('neuroglancer-stack-layout-child');
        child.registerDisposer(child.changed.add(this.changed.dispatch));
        child.registerDisposer(() => {
            this.element.removeChild(child.element);
            this.changed.dispatch();
        });
        const beforeElement = before !== undefined ? before.element : null;
        this.element.insertBefore(child.element, beforeElement);
        this.element.insertBefore(dropZone, beforeElement);
        this.changed.dispatch();
        return child;
    }
    disposed() {
        this.clear();
        super.disposed();
    }
    clear() {
        while (this.length !== 0) {
            this.get(0).dispose();
        }
    }
    *[_Symbol$iterator]() {
        const length = this.length;

        for (let i = 0; i < length; ++i) {
            yield this.get(i);
        }
    }
    toJSON() {
        return {
            type: this.direction,
            children: _Array$from(this).map(x => x.toJSON())
        };
    }
}
function makeComponent(container, spec) {
    const element = document.createElement('div');
    element.style.flex = '1';
    element.style.width = '0px';
    if (typeof spec === 'string') {
        if (container.parent !== undefined) {
            throw new Error(`Invalid layout component specification: ${_JSON$stringify(spec)}`);
        }
        return new SingletonLayerGroupViewer(element, spec, container.viewer);
    }
    verifyObject(spec);
    const componentType = verifyObjectProperty(spec, 'type', verifyString);
    switch (componentType) {
        case 'row':
        case 'column':
            {
                return new StackLayoutComponent(element, componentType, verifyObjectProperty(spec, 'children', x => {
                    const children = parseArray(x, y => y);
                    if (container.parent === undefined && children.length === 0) {
                        throw new Error('Stack layout requires at least one child.');
                    }
                    return children;
                }), container);
            }
        case 'viewer':
            {
                const viewer = container.viewer;
                const layerSpecification = new LayerSubsetSpecification(viewer.layerSpecification.addRef());
                const layerGroupViewer = new LayerGroupViewer(element, _Object$assign({ display: viewer.display, layerSpecification }, getCommonViewerState(viewer)), {
                    showLayerPanel: viewer.uiControlVisibility.showLayerPanel,
                    showViewerMenu: true,
                    showLayerHoverValues: viewer.uiControlVisibility.showLayerHoverValues
                });
                try {
                    layerGroupViewer.restoreState(spec);
                } catch (e) {
                    layerGroupViewer.dispose();
                    throw e;
                }
                return layerGroupViewer;
            }
        default:
            {
                // Treat it as a singleton layer group.
                return new SingletonLayerGroupViewer(element, spec, container.viewer);
            }
    }
}
export class RootLayoutContainer extends RefCounted {
    constructor(viewer, defaultSpecification) {
        super();
        this.viewer = viewer;
        this.defaultSpecification = defaultSpecification;
        this.container = this.registerDisposer(new LayoutComponentContainer(this.viewer, this.defaultSpecification, undefined));
    }
    get changed() {
        return this.container.changed;
    }
    get element() {
        return this.container.element;
    }
    reset() {
        this.container.setSpecification(this.defaultSpecification);
    }
    restoreState(obj) {
        this.container.setSpecification(obj);
    }
    disposed() {
        super.disposed();
    }
    toJSON() {
        return this.container.toJSON();
    }
}
//# sourceMappingURL=layer_groups_layout.js.map