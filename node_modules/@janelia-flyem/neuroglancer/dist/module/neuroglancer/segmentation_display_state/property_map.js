import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Set from 'babel-runtime/core-js/set';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Math$log from 'babel-runtime/core-js/math/log2';
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ChunkSource } from '../chunk_manager/frontend';
import { mergeSequences } from '../util/array';
import { DataType } from '../util/data_type';
import { murmurHash3_x86_32Hash64Bits } from '../util/hash';
import { clampToInterval, dataTypeCompare, dataTypeIntervalEqual, dataTypeValueNextAfter, parseDataTypeValue } from '../util/lerp';
import { getObjectId } from '../util/object_id';
import { defaultStringCompare } from '../util/string';
import { Uint64 } from '../util/uint64';
export class IndexedSegmentPropertySource extends ChunkSource {
    constructor(chunkManager, options) {
        super(chunkManager, options);
        this.properties = options.properties;
    }
    static encodeOptions(options) {
        return { properties: options.properties };
    }
}
function insertIntoLinearChainingTable(table, hashCode, value) {
    const mask = table.length - 1;
    while (true) {
        hashCode = hashCode & mask;
        if (table[hashCode] === 0) {
            table[hashCode] = value;
            return;
        }
        ++hashCode;
    }
}
function makeIndicesArray(size, maxValue) {
    if (maxValue <= 0xff) {
        return new Uint8Array(size);
    }
    if (maxValue <= 0xffff) {
        return new Uint16Array(size);
    }
    return new Uint32Array(size);
}
function makeUint64PermutationHashMap(values) {
    // Use twice the next power of 2 as the size.  This ensures a load factor <= 0.5.
    const numEntries = values.length / 2;
    const hashCodeBits = Math.ceil(_Math$log(numEntries)) + 1;
    const size = 2 ** hashCodeBits;
    const table = makeIndicesArray(size, numEntries + 1);
    for (let i = 0; i < numEntries; ++i) {
        const low = values[2 * i];
        const high = values[2 * i + 1];
        insertIntoLinearChainingTable(table, murmurHash3_x86_32Hash64Bits( /*seed=*/0, low, high), i + 1);
    }
    return table;
}
function queryUint64PermutationHashMap(table, values, low, high) {
    let hashCode = murmurHash3_x86_32Hash64Bits( /*seed=*/0, low, high);
    const mask = table.length - 1;
    while (true) {
        hashCode = hashCode & mask;
        let index = table[hashCode];
        if (index === 0) return -1;
        --index;
        if (values[2 * index] === low && values[2 * index + 1] === high) {
            return index;
        }
        ++hashCode;
    }
}
export class SegmentPropertyMap {
    constructor(options) {
        this.inlineProperties = options.inlineProperties;
    }
}
export class PreprocessedSegmentPropertyMap {
    constructor(segmentPropertyMap) {
        var _a;
        this.segmentPropertyMap = segmentPropertyMap;
        const inlineProperties = segmentPropertyMap.inlineProperties;

        if (inlineProperties !== undefined) {
            this.inlineIdToIndex = makeUint64PermutationHashMap(inlineProperties.ids);
        }
        this.tags = inlineProperties === null || inlineProperties === void 0 ? void 0 : inlineProperties.properties.find(p => p.type === 'tags');
        this.labels = inlineProperties === null || inlineProperties === void 0 ? void 0 : inlineProperties.properties.find(p => p.type === 'label');
        this.numericalProperties = (_a = inlineProperties === null || inlineProperties === void 0 ? void 0 : inlineProperties.properties.filter(p => p.type === 'number')) !== null && _a !== void 0 ? _a : [];
    }
    getSegmentInlineIndex(id) {
        const inlineIdToIndex = this.inlineIdToIndex;

        if (inlineIdToIndex === undefined) return -1;
        return queryUint64PermutationHashMap(inlineIdToIndex, this.segmentPropertyMap.inlineProperties.ids, id.low, id.high);
    }
    getSegmentLabel(id) {
        const index = this.getSegmentInlineIndex(id);
        if (index === -1) return undefined;
        const labels = this.labels,
              tagsProperty = this.tags;

        let label = '';
        if (labels !== undefined) {
            label = labels.values[index];
        }
        if (tagsProperty !== undefined) {
            const tags = tagsProperty.tags,
                  values = tagsProperty.values;

            let tagIndices = values[index];
            for (let i = 0, length = tagIndices.length; i < length; ++i) {
                const tag = tags[tagIndices.charCodeAt(i)];
                if (label.length > 0) {
                    label += ' ';
                }
                label += '#';
                label += tag;
            }
        }
        if (label.length === 0) return undefined;
        return label;
    }
}
function remapArray(input, output, toMerged) {
    for (let i = 0, length = toMerged.length; i < length; ++i) {
        output[toMerged[i]] = input[i];
    }
}
function isIdArraySorted(ids) {
    const n = ids.length;
    if (n === 0) return true;
    let prevLow = ids[0],
        prevHigh = ids[1];
    for (let i = 0; i < n; i += 2) {
        const low = ids[i],
              high = ids[i + 1];
        if ((high - prevHigh || low - prevLow) <= 0) return false;
        prevLow = low;
        prevHigh = high;
    }
    return true;
}
export function normalizeInlineSegmentPropertyMap(inlineProperties) {
    // Check if ids are already sorted.
    const ids = inlineProperties.ids;

    if (isIdArraySorted(ids)) {
        return inlineProperties;
    }
    const length = ids.length / 2;
    const permutation = makeIndicesArray(length, length - 1);
    for (let i = 0; i < length; ++i) {
        permutation[i] = i;
    }
    permutation.sort((a, b) => {
        const aLow = ids[a * 2],
              aHigh = ids[a * 2 + 1];
        const bLow = ids[b * 2],
              bHigh = ids[b * 2 + 1];
        return aHigh - bHigh || aLow - bLow;
    });
    const newIds = new Uint32Array(length * 2);
    for (let newIndex = 0; newIndex < length; ++newIndex) {
        const oldIndex = permutation[newIndex];
        newIds[newIndex * 2] = ids[oldIndex * 2];
        newIds[newIndex * 2 + 1] = ids[oldIndex * 2 + 1];
    }
    const properties = inlineProperties.properties.map(property => {
        const values = property.values;

        const newValues = new values.constructor(length);
        for (let i = 0; i < length; ++i) {
            newValues[i] = values[permutation[i]];
        }
        return _Object$assign(_Object$assign({}, property), { values: newValues });
    });
    return { ids: newIds, properties };
}
function remapStringProperty(property, numMerged, toMerged) {
    const values = new Array(numMerged);
    values.fill('');
    remapArray(property.values, values, toMerged);
    return _Object$assign(_Object$assign({}, property), { values });
}
function remapNumericalProperty(property, numMerged, toMerged) {
    const values = new Float32Array(numMerged);
    values.fill(Number.NaN);
    remapArray(property.values, values, toMerged);
    return _Object$assign(_Object$assign({}, property), { values });
}
function remapProperty(property, numMerged, toMerged) {
    const type = property.type;

    if (type === 'label' || type === 'description' || type === 'string' || type === 'tags') {
        return remapStringProperty(property, numMerged, toMerged);
    }
    return remapNumericalProperty(property, numMerged, toMerged);
}
function mergeInlinePropertyMaps(a, b) {
    if (a === undefined) return b;
    if (b === undefined) return a;
    // Determine number of unique ids and mapping from `a` and `b` indices to joined indices.
    let numUnique = 0;
    const aCount = a.ids.length / 2;
    const bCount = b.ids.length / 2;
    const aToMerged = new Uint32Array(aCount),
          bToMerged = new Uint32Array(bCount);
    const aIds = a.ids,
          bIds = b.ids;
    mergeSequences(aCount, bCount, (a, b) => {
        const aHigh = aIds[2 * a + 1];
        const aLow = aIds[2 * a];
        const bHigh = bIds[2 * b + 1];
        const bLow = bIds[2 * b];
        return aHigh - bHigh || aLow - bLow;
    }, a => {
        aToMerged[a] = numUnique;
        ++numUnique;
    }, b => {
        bToMerged[b] = numUnique;
        ++numUnique;
    }, (a, b) => {
        aToMerged[a] = numUnique;
        bToMerged[b] = numUnique;
        ++numUnique;
    });
    let ids;
    if (numUnique === aCount) {
        ids = aIds;
    } else if (numUnique === bCount) {
        ids = bIds;
    } else {
        ids = new Uint32Array(numUnique * 2);
        for (let a = 0; a < aCount; ++a) {
            const i = aToMerged[a];
            ids[2 * i] = aIds[2 * a];
            ids[2 * i + 1] = aIds[2 * a + 1];
        }
        for (let b = 0; b < bCount; ++b) {
            const i = bToMerged[b];
            ids[2 * i] = bIds[2 * b];
            ids[2 * i + 1] = bIds[2 * b + 1];
        }
    }
    const properties = [];
    if (numUnique === aCount) {
        properties.push(...a.properties);
    } else {
        for (const property of a.properties) {
            properties.push(remapProperty(property, numUnique, aToMerged));
        }
    }
    if (numUnique === bCount) {
        properties.push(...b.properties);
    } else {
        for (const property of b.properties) {
            properties.push(remapProperty(property, numUnique, bToMerged));
        }
    }
    return { ids, properties };
}
function mergePropertyMaps(a, b) {
    return new SegmentPropertyMap({
        inlineProperties: mergeInlinePropertyMaps(a.inlineProperties, b.inlineProperties)
    });
}
export function mergeSegmentPropertyMaps(maps) {
    while (true) {
        if (maps.length === 0) return undefined;
        if (maps.length === 1) return maps[0];
        const merged = [];
        for (let i = 0, length = maps.length; i < length; i += 2) {
            if (i + 1 === length) {
                merged.push(maps[i]);
            } else {
                merged.push(mergePropertyMaps(maps[i], maps[i + 1]));
            }
        }
        maps = merged;
    }
}
export function getPreprocessedSegmentPropertyMap(chunkManager, maps) {
    return chunkManager.memoize.getUncounted({ id: 'getPreprocessedSegmentPropertyMap', maps: maps.map(m => getObjectId(m)) }, () => {
        const merged = mergeSegmentPropertyMaps(maps);
        if (merged === undefined) return undefined;
        return new PreprocessedSegmentPropertyMap(merged);
    });
}
const idPattern = /^[,\s]*[0-9]+(?:[,\s]+[0-9]+)*[,\s]*$/;
export function parseSegmentQuery(db, queryString) {
    var _a;
    if (queryString.match(idPattern) !== null) {
        const parts = queryString.split(/[\s,]+/);
        const ids = [];
        const idSet = new _Set();
        for (let i = 0, n = parts.length; i < n; ++i) {
            const part = parts[i];
            if (part === '') continue;
            const id = new Uint64();
            if (!id.tryParseString(part)) {
                continue;
            }
            const idString = id.toString();
            if (idSet.has(idString)) continue;
            idSet.add(idString);
            ids.push(id);
        }
        ids.sort(Uint64.compare);
        return { ids };
    }
    const parsed = {
        regexp: undefined,
        prefix: undefined,
        includeTags: [],
        excludeTags: [],
        numericalConstraints: [],
        sortBy: [],
        includeColumns: []
    };
    const properties = (_a = db === null || db === void 0 ? void 0 : db.segmentPropertyMap.inlineProperties) === null || _a === void 0 ? void 0 : _a.properties;
    const tags = db === null || db === void 0 ? void 0 : db.tags;
    const tagNames = (tags === null || tags === void 0 ? void 0 : tags.tags) || [];
    const lowerCaseTags = tagNames.map(x => x.toLowerCase());
    const labels = db === null || db === void 0 ? void 0 : db.labels;
    const errors = [];
    let nextStartIndex;
    for (let startIndex = 0; startIndex < queryString.length; startIndex = nextStartIndex) {
        let endIndex = queryString.indexOf(' ', startIndex);
        let word;
        if (endIndex === -1) {
            nextStartIndex = endIndex = queryString.length;
        } else {
            nextStartIndex = endIndex + 1;
        }
        word = queryString.substring(startIndex, endIndex);
        if (word.length === 0) continue;
        const checkTag = (tag, begin) => {
            const lowerCaseTag = tag.toLowerCase();
            const tagIndex = lowerCaseTags.indexOf(lowerCaseTag);
            if (tagIndex === -1) {
                errors.push({ begin, end: endIndex, message: `Invalid tag: ${tag}` });
                return undefined;
            }
            tag = tagNames[tagIndex];
            if (parsed.includeTags.includes(tag) || parsed.excludeTags.includes(tag)) {
                errors.push({ begin, end: endIndex, message: `Duplicate tag: ${tag}` });
                return undefined;
            }
            return tag;
        };
        if (word.startsWith('#')) {
            const tag = checkTag(word.substring(1), startIndex + 1);
            if (tag !== undefined) {
                parsed.includeTags.push(tag);
            }
            continue;
        }
        if (word.startsWith('-#')) {
            const tag = checkTag(word.substring(2), startIndex + 2);
            if (tag !== undefined) {
                parsed.excludeTags.push(tag);
            }
            continue;
        }
        if (word.startsWith('<') || word.startsWith('>')) {
            let fieldId = word.substring(1).toLowerCase();
            if (fieldId !== 'id' && fieldId !== 'label') {
                const property = properties === null || properties === void 0 ? void 0 : properties.find(p => p.id.toLowerCase() === fieldId && (p.type === 'number' || p.type === 'label' || p.type === 'string'));
                if (property === undefined) {
                    errors.push({ begin: startIndex + 1, end: endIndex, message: `Invalid field: ${fieldId}` });
                    continue;
                }
                fieldId = property.id;
            }
            if (parsed.sortBy.find(x => x.fieldId === fieldId) !== undefined) {
                errors.push({ begin: startIndex + 1, end: endIndex, message: `Duplicate sort field: ${fieldId}` });
                continue;
            }
            parsed.sortBy.push({ order: word[0], fieldId });
            continue;
        }
        if (word.startsWith('|')) {
            let fieldId = word.substring(1).toLowerCase();
            if (fieldId === 'id' || fieldId === 'label') continue;
            const property = properties === null || properties === void 0 ? void 0 : properties.find(p => p.id.toLowerCase() === fieldId && (p.type === 'number' || p.type === 'string'));
            if (property === undefined) {
                errors.push({ begin: startIndex + 1, end: endIndex, message: `Invalid field: ${fieldId}` });
                continue;
            }
            fieldId = property.id;
            if (parsed.sortBy.find(x => x.fieldId === fieldId) || parsed.includeColumns.find(x => x === fieldId)) {
                // Ignore duplicate column.
                continue;
            }
            parsed.includeColumns.push(fieldId);
            continue;
        }
        if (word.startsWith('/')) {
            if (parsed.regexp !== undefined) {
                errors.push({ begin: startIndex, end: endIndex, message: 'Only one regular expression allowed' });
                continue;
            }
            if (parsed.prefix !== undefined) {
                errors.push({
                    begin: startIndex,
                    end: endIndex,
                    message: 'Prefix cannot be combined with regular expression'
                });
                continue;
            }
            if (labels === undefined) {
                errors.push({ begin: startIndex, end: endIndex, message: 'No label property' });
                continue;
            }
            try {
                parsed.regexp = new RegExp(word.substring(1));
            } catch (e) {
                errors.push({ begin: startIndex, end: endIndex, message: 'Invalid regular expression syntax' });
            }
            continue;
        }
        const constraintMatch = word.match(/^([a-zA-Z][a-zA-Z0-9_]*)(<|<=|=|>=|>)([0-9.].*)$/);
        if (constraintMatch !== null) {
            let fieldId = constraintMatch[1].toLowerCase();
            const op = constraintMatch[2];
            const property = db === null || db === void 0 ? void 0 : db.numericalProperties.find(p => p.id.toLowerCase() === fieldId);
            if (property === undefined) {
                errors.push({
                    begin: startIndex,
                    end: startIndex + fieldId.length,
                    message: `Invalid numerical field: ${fieldId}`
                });
                continue;
            }
            fieldId = property.id;
            let value;
            try {
                value = parseDataTypeValue(property.dataType, constraintMatch[3]);
            } catch (e) {
                errors.push({
                    begin: startIndex + constraintMatch[1].length + constraintMatch[2].length,
                    end: endIndex,
                    message: e.message
                });
                continue;
            }
            let constraint = parsed.numericalConstraints.find(c => c.fieldId === fieldId);
            if (constraint === undefined) {
                constraint = { fieldId, bounds: property.bounds };
                parsed.numericalConstraints.push(constraint);
            }
            const origMin = clampToInterval(property.bounds, constraint.bounds[0]),
                  origMax = clampToInterval(property.bounds, constraint.bounds[1]);
            let newMax = origMax,
                newMin = origMin;
            switch (op) {
                case '<':
                    newMax = dataTypeValueNextAfter(property.dataType, value, -1);
                    break;
                case '<=':
                    newMax = value;
                    break;
                case '=':
                    newMax = newMin = value;
                    break;
                case '>=':
                    newMin = value;
                    break;
                case '>':
                    newMin = dataTypeValueNextAfter(property.dataType, value, +1);
                    break;
            }
            newMin = dataTypeCompare(origMin, newMin) > 0 ? origMin : newMin;
            newMax = dataTypeCompare(origMax, newMax) < 0 ? origMax : newMax;
            if (dataTypeCompare(newMin, newMax) > 0) {
                errors.push({ begin: startIndex, end: endIndex, message: 'Constraint would not match any values' });
                continue;
            }
            constraint.bounds = [newMin, newMax];
            continue;
        }
        if (parsed.regexp !== undefined) {
            errors.push({
                begin: startIndex,
                end: endIndex,
                message: 'Prefix cannot be combined with regular expression'
            });
            continue;
        }
        if (labels === undefined) {
            errors.push({ begin: startIndex, end: endIndex, message: 'No label property' });
            continue;
        }
        if (parsed.prefix !== undefined) {
            parsed.prefix += ` ${word}`;
        } else {
            parsed.prefix = word;
        }
    }
    if (errors.length > 0) {
        return { errors };
    }
    if (parsed.sortBy.length === 0) {
        // Add default sort order.
        parsed.sortBy.push({ fieldId: getDefaultSortField(db), order: '<' });
    }
    return parsed;
}
function regexpEscapeCharCode(code) {
    return '\\u' + code.toString(16).padStart(4, '0');
}
export function executeSegmentQuery(db, query) {
    var _a;
    if (query.errors !== undefined) {
        return { query, total: -1, count: 0, errors: query.errors };
    }
    if (query.ids !== undefined) {
        const ids = query.ids;

        return { query, total: -1, explicitIds: ids, count: ids.length };
    }
    const inlineProperties = (_a = db === null || db === void 0 ? void 0 : db.segmentPropertyMap) === null || _a === void 0 ? void 0 : _a.inlineProperties;
    if (inlineProperties === undefined) {
        return {
            query,
            count: 0,
            total: -1
        };
    }
    const properties = inlineProperties === null || inlineProperties === void 0 ? void 0 : inlineProperties.properties;
    const totalIds = inlineProperties.ids.length / 2;
    let indices = makeIndicesArray(totalIds, totalIds);
    for (let i = 0; i < totalIds; ++i) {
        indices[i] = i;
    }
    const filterIndices = predicate => {
        let length = indices.length;
        let outIndex = 0;
        for (let i = 0; i < length; ++i) {
            const index = indices[i];
            if (predicate(index)) {
                indices[outIndex] = index;
                ++outIndex;
            }
        }
        indices = indices.subarray(0, outIndex);
    };
    // Filter by label
    if (query.regexp !== undefined || query.prefix !== undefined) {
        const values = db.labels.values;
        const regexp = query.regexp,
              prefix = query.prefix;

        if (regexp !== undefined) {
            filterIndices(index => values[index].match(regexp) !== null);
        }
        if (prefix !== undefined) {
            filterIndices(index => values[index].startsWith(prefix));
        }
    }
    // Filter by tags
    const includeTags = query.includeTags,
          excludeTags = query.excludeTags;

    const tagsProperty = db.tags;
    if (includeTags.length > 0 || excludeTags.length > 0) {
        // Since query was already validated, tags property must exist if tags were specified.
        const values = tagsProperty.values,
              tags = tagsProperty.tags;

        const allTags = [];
        for (const tag of includeTags) {
            allTags.push([tags.indexOf(tag), 1]);
        }
        for (const tag of excludeTags) {
            allTags.push([tags.indexOf(tag), 0]);
        }
        allTags.sort((a, b) => a[0] - b[0]);
        let pattern = '^';
        let prevTagIndex = 0;
        const addSkipPattern = endCode => {
            if (endCode < prevTagIndex) return;
            pattern += `[${regexpEscapeCharCode(prevTagIndex)}-${regexpEscapeCharCode(endCode)}]*`;
        };
        for (const _ref of allTags) {
            var _ref2 = _slicedToArray(_ref, 2);

            const tagIndex = _ref2[0];
            const sign = _ref2[1];

            addSkipPattern(tagIndex - 1);
            if (sign) {
                pattern += regexpEscapeCharCode(tagIndex);
            }
            prevTagIndex = tagIndex + 1;
        }
        addSkipPattern(0xffff);
        pattern += '$';
        const regexp = new RegExp(pattern);
        filterIndices(index => values[index].match(regexp) !== null);
    }
    let intermediateIndicesMask;
    let intermediateIndices;
    // Filter by numerical properties.
    const numericalConstraints = query.numericalConstraints;

    if (numericalConstraints.length > 0) {
        const numericalProperties = db.numericalProperties;
        const numNumericalConstraints = numericalConstraints.length;
        const fullMask = 2 ** numNumericalConstraints - 1;
        intermediateIndicesMask = makeIndicesArray(indices.length, fullMask);
        for (let constraintIndex = 0; constraintIndex < numNumericalConstraints; ++constraintIndex) {
            const constraint = numericalConstraints[constraintIndex];
            const property = numericalProperties.find(p => p.id === constraint.fieldId);
            const values = property.values;

            const bit = 2 ** constraintIndex;

            var _constraint$bounds = _slicedToArray(constraint.bounds, 2);

            const min = _constraint$bounds[0],
                  max = _constraint$bounds[1];

            for (let i = 0, n = indices.length; i < n; ++i) {
                const value = values[indices[i]];
                intermediateIndicesMask[i] |= bit * (value >= min && value <= max);
            }
        }
        intermediateIndices = indices;
        indices = intermediateIndices.slice();
        let length = indices.length;
        let outIndex = 0;
        for (let i = 0; i < length; ++i) {
            if (intermediateIndicesMask[i] === fullMask) {
                indices[outIndex] = indices[i];
                ++outIndex;
            }
        }
        indices = indices.subarray(0, outIndex);
    }
    // Compute tag statistics.
    let tagStatistics = [];
    if (tagsProperty !== undefined) {
        const tagStatisticsInQuery = [];
        const tags = tagsProperty.tags,
              values = tagsProperty.values;

        const tagCounts = new Uint32Array(tags.length);
        for (let i = 0, n = indices.length; i < n; ++i) {
            const value = values[indices[i]];
            for (let j = 0, m = value.length; j < m; ++j) {
                ++tagCounts[value.charCodeAt(j)];
            }
        }
        for (let tagIndex = 0, numTags = tags.length; tagIndex < numTags; ++tagIndex) {
            const count = tagCounts[tagIndex];
            const tag = tags[tagIndex];
            const tagCount = { tag, tagIndex, count: tagCounts[tagIndex] };
            if (query.includeTags.includes(tag) || query.excludeTags.includes(tag)) {
                tagStatisticsInQuery.push(tagCount);
            } else if (count > 0) {
                tagStatistics.push(tagCount);
            }
        }
        tagStatisticsInQuery.push(...tagStatistics);
        tagStatistics = tagStatisticsInQuery;
    }
    const sortByProperty = (property, orderCoeff) => {
        if (property.type !== 'number') {
            const values = property.values;

            indices.sort((a, b) => defaultStringCompare(values[a], values[b]) * orderCoeff);
        } else {
            const values = property.values;
            indices.sort((a, b) => (values[a] - values[b]) * orderCoeff);
        }
    };
    const sortByLabel = orderCoeff => {
        // Sort by tags and then by label.
        if (tagsProperty !== undefined) {
            sortByProperty(tagsProperty, orderCoeff);
        }
        const labelsProperty = db === null || db === void 0 ? void 0 : db.labels;
        if (labelsProperty !== undefined) {
            sortByProperty(labelsProperty, orderCoeff);
        }
    };
    // Sort.  Apply the sort orders in reverse order to achieve the desired composite ordering, given
    // that JavaScript's builtin sort is stable.
    const sortBy = query.sortBy;

    for (let i = sortBy.length - 1; i >= 0; --i) {
        var _sortBy$i = sortBy[i];
        const fieldId = _sortBy$i.fieldId,
              order = _sortBy$i.order;

        const orderCoeff = order === '<' ? 1 : -1;
        if (fieldId === 'id') {
            if (i + 1 === sortBy.length) {
                if (order === '<') {
                    // Default order, no need to sort.
                    continue;
                } else {
                    indices.reverse();
                    continue;
                }
            }
            indices.sort((a, b) => orderCoeff * (a - b));
            continue;
        } else if (fieldId === 'label') {
            sortByLabel(orderCoeff);
        } else {
            sortByProperty(properties.find(p => p.id === fieldId), orderCoeff);
        }
    }
    return {
        query,
        intermediateIndices,
        intermediateIndicesMask,
        indices,
        tags: tagStatistics,
        count: indices.length,
        total: totalIds
    };
}
function updatePropertyHistogram(queryResult, property, bounds) {
    const numBins = 256;
    const values = property.values;

    var _bounds = _slicedToArray(bounds, 2);

    const min = _bounds[0],
          max = _bounds[1];

    const multiplier = max <= min ? 0 : numBins / (max - min);
    const histogram = new Uint32Array(numBins + 2);
    const numericalConstraints = queryResult.query.numericalConstraints;

    const constraintIndex = numericalConstraints.findIndex(c => c.fieldId === property.id);
    if (constraintIndex === -1) {
        // Property is unconstrained, just compute histogram from final result set.
        const indices = queryResult.indices;
        for (let i = 0, n = indices.length; i < n; ++i) {
            const value = values[indices[i]];
            if (!isNaN(value)) {
                ++histogram[Math.min(numBins - 1, Math.max(-1, (value - min) * multiplier)) + 1 >>> 0];
            }
        }
    } else {
        // Property is constrained, compute histogram from intermediateIndices.
        const intermediateIndices = queryResult.intermediateIndices;
        const intermediateIndicesMask = queryResult.intermediateIndicesMask;
        const requiredBits = 2 ** numericalConstraints.length - 1 - 2 ** constraintIndex;
        for (let i = 0, n = intermediateIndices.length; i < n; ++i) {
            const mask = intermediateIndicesMask[i];
            if ((mask & requiredBits) == requiredBits) {
                const value = values[intermediateIndices[i]];
                if (!isNaN(value)) {
                    ++histogram[Math.min(numBins - 1, Math.max(-1, (value - min) * multiplier)) + 1 >>> 0];
                }
            }
        }
    }
    return { queryResult, histogram, window: bounds };
}
export function updatePropertyHistograms(db, queryResult, propertyHistograms, bounds) {
    if (db === undefined) {
        propertyHistograms.length = 0;
        bounds.length = 0;
        return;
    }
    const numericalProperties = db.numericalProperties;

    const numProperties = numericalProperties.length;
    const indices = queryResult === null || queryResult === void 0 ? void 0 : queryResult.indices;
    if (indices === undefined) {
        propertyHistograms.length = 0;
        return;
    }
    for (let i = 0; i < numProperties; ++i) {
        const propertyHistogram = propertyHistograms[i];
        const propertyBounds = bounds[i];
        const property = numericalProperties[i];
        if (propertyHistogram !== undefined && propertyHistogram.queryResult === queryResult && dataTypeIntervalEqual(property.dataType, propertyHistogram.window, propertyBounds)) {
            continue;
        }
        propertyHistograms[i] = updatePropertyHistogram(queryResult, property, propertyBounds);
    }
}
function getDefaultSortField(db) {
    return (db === null || db === void 0 ? void 0 : db.tags) || (db === null || db === void 0 ? void 0 : db.labels) ? 'label' : 'id';
}
export function unparseSegmentQuery(db, query) {
    var _query = query;
    const ids = _query.ids;

    if (ids !== undefined) {
        return ids.map(x => x.toString()).join(', ');
    }
    let queryString = '';
    query = query;
    var _query2 = query;
    const prefix = _query2.prefix,
          regexp = _query2.regexp;

    if (prefix !== undefined) {
        queryString = prefix;
    } else if (regexp !== undefined) {
        queryString = `/${regexp}`;
    }
    for (const tag of query.includeTags) {
        if (queryString.length > 0) queryString += ' ';
        queryString += `#${tag}`;
    }
    for (const tag of query.excludeTags) {
        if (queryString.length > 0) queryString += ' ';
        queryString += `-#${tag}`;
    }
    for (const constraint of query.numericalConstraints) {
        const fieldId = constraint.fieldId,
              bounds = constraint.bounds;

        var _bounds2 = _slicedToArray(bounds, 2);

        const min = _bounds2[0],
              max = _bounds2[1];

        const property = db.numericalProperties.find(p => p.id === fieldId);
        if (dataTypeIntervalEqual(property.dataType, property.bounds, bounds)) {
            continue;
        }
        if (dataTypeCompare(min, max) === 0) {
            if (queryString.length > 0) queryString += ' ';
            queryString += `${fieldId}=${min}`;
            continue;
        }
        if (dataTypeCompare(min, property.bounds[0]) > 0) {
            if (queryString.length > 0) queryString += ' ';
            const beforeMin = dataTypeValueNextAfter(property.dataType, min, -1);
            const minString = min.toString();
            const beforeMinString = beforeMin.toString();
            if (property.dataType !== DataType.FLOAT32 || minString.length <= beforeMinString.length) {
                queryString += `${fieldId}>=${minString}`;
            } else {
                queryString += `${fieldId}>${beforeMinString}`;
            }
        }
        if (dataTypeCompare(max, property.bounds[1]) < 0) {
            if (queryString.length > 0) queryString += ' ';
            const afterMax = dataTypeValueNextAfter(property.dataType, max, +1);
            const maxString = max.toString();
            const afterMaxString = afterMax.toString();
            if (property.dataType !== DataType.FLOAT32 || maxString.length <= afterMaxString.length) {
                queryString += `${fieldId}<=${maxString}`;
            } else {
                queryString += `${fieldId}<${afterMaxString}`;
            }
        }
    }
    var _query3 = query;
    let sortBy = _query3.sortBy;

    if (sortBy.length === 1) {
        const s = sortBy[0];
        if (s.order === '<' && s.fieldId === getDefaultSortField(db)) {
            sortBy = [];
        }
    }
    for (const s of sortBy) {
        if (queryString.length > 0) queryString += ' ';
        queryString += `${s.order}${s.fieldId}`;
    }
    for (const fieldId of query.includeColumns) {
        if (queryString.length > 0) queryString += ' ';
        queryString += `|${fieldId}`;
    }
    return queryString;
}
const tempUint64 = new Uint64();
export function forEachQueryResultSegmentId(db, queryResult, callback) {
    if (queryResult === undefined) return;
    const explicitIds = queryResult.explicitIds;

    if (explicitIds !== undefined) {
        explicitIds.forEach(callback);
        return;
    }
    const indices = queryResult.indices;

    if (indices !== undefined) {
        var _ref3 = db === null || db === void 0 ? void 0 : db.segmentPropertyMap.inlineProperties;

        const ids = _ref3.ids;

        for (let i = 0, count = indices.length; i < count; ++i) {
            const propIndex = indices[i];
            tempUint64.low = ids[propIndex * 2];
            tempUint64.high = ids[propIndex * 2 + 1];
            callback(tempUint64, i);
        }
    }
}
export function findQueryResultIntersectionSize(db, queryResult, segmentSet) {
    if (segmentSet.size === 0) return 0;
    let count = 0;
    forEachQueryResultSegmentId(db, queryResult, id => {
        if (segmentSet.has(id)) ++count;
    });
    return count;
}
export function changeTagConstraintInSegmentQuery(query, tag, include, value) {
    const includeTags = query.includeTags.filter(x => x !== tag);
    const excludeTags = query.excludeTags.filter(x => x !== tag);
    if (value === true) {
        (include ? includeTags : excludeTags).push(tag);
    }
    return _Object$assign(_Object$assign({}, query), { includeTags, excludeTags });
}
export function isQueryUnconstrained(query) {
    if (query.ids !== undefined) return false;
    if (query.errors !== undefined) return true;
    if (query.numericalConstraints.length > 0) return false;
    if (query.includeTags.length > 0) return false;
    if (query.excludeTags.length > 0) return false;
    if (query.prefix) return false;
    if (query.regexp) return false;
    return true;
}
export function queryIncludesColumn(query, fieldId) {
    if (query === undefined) return false;
    if (query.ids !== undefined) return false;
    if (query.errors !== undefined) return false;
    const sortBy = query.sortBy,
          includeColumns = query.includeColumns;

    return sortBy.find(x => x.fieldId === fieldId) !== undefined || includeColumns.includes(fieldId);
}
//# sourceMappingURL=property_map.js.map