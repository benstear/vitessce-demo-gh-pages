import _WeakMap from 'babel-runtime/core-js/weak-map';
import _Object$assign from 'babel-runtime/core-js/object/assign';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ChunkRenderLayerFrontend } from '../chunk_manager/frontend';
import { getCssColor } from '../segment_color';
import { forEachVisibleSegment, onTemporaryVisibleSegmentsStateChanged, onVisibleSegmentsStateChanged, VISIBLE_SEGMENTS_STATE_PROPERTIES } from './base';
import { SharedWatchableValue } from '../shared_watchable_value';
import { observeWatchable, registerNestedSync } from '../trackable_value';
import { isWithinSelectionPanel } from '../ui/selection_details';
import { setClipboard } from '../util/clipboard';
import { useWhiteBackground } from '../util/color';
import { RefCounted } from '../util/disposable';
import { measureElementClone } from '../util/dom';
import { kOneVec, vec4 } from '../util/geom';
import { NullarySignal } from '../util/signal';
import { Uint64 } from '../util/uint64';
import { withSharedVisibility } from '../visibility_priority/frontend';
import { makeCopyButton } from '../widget/copy_button';
import { makeFilterButton } from '../widget/filter_button';
export class Uint64MapEntry {
    constructor(key, value, label) {
        this.key = key;
        this.value = value;
        this.label = label;
    }
    toString() {
        const key = this.key,
              value = this.value,
              label = this.label;

        let baseString;
        if (value === undefined) {
            baseString = `${key}`;
        } else {
            baseString = `${key}→${value}`;
        }
        if (label === undefined) return baseString;
        return `${baseString} ${label}`;
    }
}
export class SegmentSelectionState extends RefCounted {
    constructor() {
        super(...arguments);
        this.selectedSegment = new Uint64();
        this.baseSelectedSegment = new Uint64();
        this.hasSelectedSegment = false;
        this.changed = new NullarySignal();
    }
    get value() {
        return this.hasSelectedSegment ? this.selectedSegment : undefined;
    }
    get baseValue() {
        return this.hasSelectedSegment ? this.baseSelectedSegment : undefined;
    }
    set(value, hideSegmentZero = false) {
        const selectedSegment = this.selectedSegment,
              baseSelectedSegment = this.baseSelectedSegment;

        let newLow = 0,
            newHigh = 0,
            newBaseLow = 0,
            newBaseHigh = 0;
        let hasSelectedSegment;
        if (value == null) {
            hasSelectedSegment = false;
        } else if (typeof value === 'number') {
            newLow = newBaseLow = value >>> 0;
            newHigh = newBaseHigh = value < 0 ? 0xffffffff : 0;
            hasSelectedSegment = true;
        } else if (value instanceof Uint64MapEntry) {
            const valueMapped = value.value || value.key;
            newLow = valueMapped.low;
            newHigh = valueMapped.high;
            newBaseLow = value.key.low;
            newBaseHigh = value.key.high;
            hasSelectedSegment = true;
        } else if (value instanceof Uint64) {
            newLow = newBaseLow = value.low;
            newHigh = newBaseHigh = value.high;
            hasSelectedSegment = true;
        } else {
            hasSelectedSegment = false;
        }
        if (hideSegmentZero && newLow === 0 && newHigh === 0) {
            hasSelectedSegment = false;
        }
        if (!hasSelectedSegment) {
            if (this.hasSelectedSegment) {
                this.hasSelectedSegment = false;
                this.changed.dispatch();
            }
        } else if (hasSelectedSegment && (!this.hasSelectedSegment || selectedSegment.low !== newLow || selectedSegment.high !== newHigh || baseSelectedSegment.low !== newBaseLow || baseSelectedSegment.high !== newBaseHigh)) {
            selectedSegment.low = newLow;
            selectedSegment.high = newHigh;
            baseSelectedSegment.low = newBaseLow;
            baseSelectedSegment.high = newBaseHigh;
            this.hasSelectedSegment = true;
            this.changed.dispatch();
        }
    }
    isSelected(value) {
        return this.hasSelectedSegment && Uint64.equal(value, this.selectedSegment);
    }
    bindTo(layerSelectedValues, userLayer) {
        this.registerDisposer(layerSelectedValues.changed.add(() => {
            const state = layerSelectedValues.get(userLayer);
            let value = undefined;
            if (state !== undefined) {
                value = state.value;
            }
            this.set(value, userLayer.displayState.segmentationGroupState.value.hideSegmentZero.value);
        }));
    }
}
export function resetTemporaryVisibleSegmentsState(state) {
    state.useTemporarySegmentEquivalences.value = false;
    state.useTemporaryVisibleSegments.value = false;
    state.temporaryVisibleSegments.clear();
    state.temporarySegmentEquivalences.clear();
}
/// Converts a segment id to a Uint64MapEntry or Uint64 (if Uint64MapEntry would add no additional
/// information).
export function maybeAugmentSegmentId(displayState, value, mustCopy = false) {
    let id;
    let mappedValue;
    let mapped;
    let label;
    if (typeof value === 'number') {
        id = new Uint64(value >>> 0, value < 0 ? 0xffffffff : 0);
    } else if (typeof value === 'string') {
        id = Uint64.parseString(value);
    } else {
        id = mustCopy ? value.clone() : value;
    }
    if (displayState == null) return id;
    var _displayState$segment = displayState.segmentationGroupState.value;
    const segmentEquivalences = _displayState$segment.segmentEquivalences,
          segmentPropertyMap = _displayState$segment.segmentPropertyMap.value;

    if (segmentEquivalences.size !== 0) {
        mappedValue = segmentEquivalences.get(id);
        if (Uint64.equal(mappedValue, id)) {
            mapped = undefined;
        } else {
            mapped = mappedValue;
        }
    } else {
        mappedValue = id;
    }
    label = segmentPropertyMap === null || segmentPropertyMap === void 0 ? void 0 : segmentPropertyMap.getSegmentLabel(mappedValue);
    if (label === undefined && mapped == undefined) {
        return id;
    }
    return new Uint64MapEntry(id, mapped, label);
}
/// Converts a plain segment id to a Uint64MapEntry.
export function augmentSegmentId(displayState, value) {
    if (value instanceof Uint64MapEntry) return value;
    let newValue = maybeAugmentSegmentId(displayState, value);
    if (newValue instanceof Uint64) {
        return new Uint64MapEntry(newValue);
    }
    return newValue;
}
export function updateIdStringWidth(idStringWidth, idString) {
    const length = idString.length;

    if (idStringWidth.value < length) {
        idStringWidth.value = length;
    }
}
export function bindSegmentListWidth(displayState, element) {
    return observeWatchable(width => element.style.setProperty('--neuroglancer-segment-list-width', `${width}ch`), displayState.segmentationGroupState.value.maxIdLength);
}
const segmentWidgetTemplate = (() => {
    const template = document.createElement('div');
    template.classList.add('neuroglancer-segment-list-entry');
    const stickyContainer = document.createElement('div');
    stickyContainer.classList.add('neuroglancer-segment-list-entry-sticky');
    template.appendChild(stickyContainer);
    const copyButton = makeCopyButton({
        title: `Copy segment ID`
    });
    copyButton.classList.add('neuroglancer-segment-list-entry-copy');
    const copyContainer = document.createElement('div');
    copyContainer.classList.add('neuroglancer-segment-list-entry-copy-container');
    const copyIndex = copyContainer.childElementCount;
    copyContainer.appendChild(copyButton);
    const copyContainerIndex = stickyContainer.childElementCount;
    stickyContainer.appendChild(copyContainer);
    const visibleIndex = stickyContainer.childElementCount;
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.title = 'Toggle segment visibility';
    checkbox.classList.add('neuroglancer-segment-list-entry-visible-checkbox');
    stickyContainer.appendChild(checkbox);
    const idContainer = document.createElement('div');
    idContainer.classList.add('neuroglancer-segment-list-entry-id-container');
    const idContainerIndex = stickyContainer.childElementCount;
    stickyContainer.appendChild(idContainer);
    const idElement = document.createElement('div');
    idElement.classList.add('neuroglancer-segment-list-entry-id');
    const idIndex = idContainer.childElementCount;
    idContainer.appendChild(idElement);
    const nameElement = document.createElement('span');
    nameElement.classList.add('neuroglancer-segment-list-entry-name');
    const labelIndex = template.childElementCount;
    template.appendChild(nameElement);
    const filterElement = makeFilterButton({
        title: 'Filter by label'
    });
    filterElement.classList.add('neuroglancer-segment-list-entry-filter');
    const filterIndex = template.childElementCount;
    template.appendChild(filterElement);
    return {
        template,
        copyContainerIndex,
        copyIndex,
        visibleIndex,
        idContainerIndex,
        idIndex,
        labelIndex,
        filterIndex,
        unmappedIdIndex: -1,
        unmappedCopyIndex: -1
    };
})();
const segmentWidgetTemplateWithUnmapped = (() => {
    const t = segmentWidgetTemplate;
    const template = t.template.cloneNode( /*deep=*/true);
    const stickyContainer = template.children[0];
    const idContainer = stickyContainer.children[t.idContainerIndex];
    const unmappedIdIndex = idContainer.childElementCount;
    const unmappedIdElement = idContainer.children[t.idIndex].cloneNode( /*deep=*/true);
    unmappedIdElement.classList.add('neuroglancer-segment-list-entry-unmapped-id');
    idContainer.appendChild(unmappedIdElement);
    const copyContainer = stickyContainer.children[t.copyContainerIndex];
    const unmappedCopyIndex = copyContainer.childElementCount;
    copyContainer.appendChild(copyContainer.children[t.copyIndex].cloneNode( /*deep=*/true));
    return _Object$assign(_Object$assign({}, t), { template, unmappedIdIndex, unmappedCopyIndex });
})();
export function segmentWidgetTemplateWithExtraColumns(numExtraColumns) {
    let origTemplate = segmentWidgetTemplate;
    const templateElement = origTemplate.template.cloneNode( /*deep=*/true);
    const numericalPropertyIndices = [];
    for (let i = 0; i < numExtraColumns; ++i) {
        numericalPropertyIndices.push(templateElement.childElementCount);
        const child = document.createElement('div');
        child.classList.add('neuroglancer-segment-list-entry-extra-property');
        child.style.width = `max(var(--neuroglancer-column-${i}-width), var(--neuroglancer-column-${i}-label-width))`;
        templateElement.appendChild(child);
    }
    return _Object$assign(_Object$assign({}, origTemplate), { template: templateElement, numericalPropertyIndices });
}
const cachedRegisterSegmentWidgetEventHandlers = new _WeakMap();
function makeRegisterSegmentWidgetEventHandlers(displayState) {
    const onMouseEnter = event => {
        const entryElement = event.currentTarget;
        const idString = entryElement.dataset.id;
        const id = tempStatedColor;
        id.tryParseString(idString);
        displayState.segmentSelectionState.set(id);
        if (!isWithinSelectionPanel(entryElement)) {
            displayState.selectSegment(id, false);
        }
    };
    const selectHandler = event => {
        const entryElement = event.currentTarget;
        const idString = entryElement.dataset.id;
        const id = tempStatedColor;
        id.tryParseString(idString);
        displayState.selectSegment(id, isWithinSelectionPanel(entryElement) ? 'toggle' : true);
    };
    const onMouseLeave = () => {
        displayState.segmentSelectionState.set(null);
    };
    const getEntryElement = event => {
        return event.currentTarget.closest('.neuroglancer-segment-list-entry');
    };
    const copyHandler = event => {
        const entryElement = getEntryElement(event);
        setClipboard(entryElement.dataset.id);
        event.stopPropagation();
    };
    const unmappedCopyHandler = event => {
        const entryElement = getEntryElement(event);
        setClipboard(entryElement.dataset.unmappedId);
        event.stopPropagation();
    };
    const visibleCheckboxHandler = event => {
        const entryElement = getEntryElement(event);
        const idString = entryElement.dataset.id;
        const id = tempStatedColor;
        id.tryParseString(idString);
        const visibleSegments = displayState.segmentationGroupState.value.visibleSegments;

        visibleSegments.set(id, !visibleSegments.has(id));
        event.stopPropagation();
    };
    const filterHandler = event => {
        const entryElement = getEntryElement(event);
        const idString = entryElement.dataset.id;
        const id = tempStatedColor;
        id.tryParseString(idString);
        displayState.filterBySegmentLabel(id);
        event.stopPropagation();
    };
    const onMousedown = event => {
        if (event.button !== 2 || event.ctrlKey || event.altKey || event.metaKey || event.shiftKey) {
            return;
        }
        const entryElement = event.currentTarget;
        const idString = entryElement.dataset.id;
        const id = tempStatedColor;
        id.tryParseString(idString);
        displayState.moveToSegment(id);
    };
    return (element, template) => {
        const children = element.children;

        const stickyChildren = children[0].children;
        element.addEventListener('mousedown', onMousedown);
        const copyContainer = stickyChildren[template.copyContainerIndex];
        if (template.unmappedCopyIndex !== -1) {
            copyContainer.children[template.unmappedCopyIndex].addEventListener('click', unmappedCopyHandler);
        }
        copyContainer.children[template.copyIndex].addEventListener('click', copyHandler);
        element.addEventListener('mouseenter', onMouseEnter);
        element.addEventListener('mouseleave', onMouseLeave);
        stickyChildren[template.visibleIndex].addEventListener('click', visibleCheckboxHandler);
        children[template.filterIndex].addEventListener('click', filterHandler);
        element.addEventListener('action:select-position', selectHandler);
    };
}
export class SegmentWidgetFactory {
    constructor(displayState, template) {
        this.displayState = displayState;
        this.template = template;
        if (displayState !== undefined) {
            let r = cachedRegisterSegmentWidgetEventHandlers.get(displayState);
            if (r === undefined) {
                r = makeRegisterSegmentWidgetEventHandlers(displayState);
                cachedRegisterSegmentWidgetEventHandlers.set(displayState, r);
            }
            this.registerEventHandlers = r;
        }
    }
    static make(displayState, includeUnmapped) {
        return new SegmentWidgetFactory(displayState, includeUnmapped ? segmentWidgetTemplateWithUnmapped : segmentWidgetTemplate);
    }
    get(rawId) {
        const displayState = this.displayState;

        return this.getWithNormalizedId(augmentSegmentId(displayState, rawId));
    }
    getWithNormalizedId(normalizedId) {
        var _a, _b;
        const displayState = this.displayState;
        const template = this.template;

        const container = template.template.cloneNode( /*deep=*/true);
        const id = normalizedId.key;
        const mapped = (_a = normalizedId.value) !== null && _a !== void 0 ? _a : id;
        const mappedIdString = mapped.toString();
        container.dataset.id = mappedIdString;
        const children = container.children;

        const stickyChildren = children[0].children;
        const idContainer = stickyChildren[template.idContainerIndex];
        idContainer.children[template.idIndex].textContent = mappedIdString;
        const unmappedIdIndex = template.unmappedIdIndex;

        if (displayState !== undefined) {
            this.registerEventHandlers(container, template);
        } else {
            stickyChildren[template.visibleIndex].style.display = 'none';
        }
        if (unmappedIdIndex !== -1) {
            const unmappedIdElement = idContainer.children[unmappedIdIndex];
            if (!Uint64.equal(id, mapped)) {
                const unmappedIdString = id.toString();
                container.dataset.unmappedId = unmappedIdString;
                unmappedIdElement.textContent = unmappedIdString;
                if (displayState !== undefined) {
                    updateIdStringWidth(displayState.segmentationGroupState.value.maxIdLength, unmappedIdString);
                }
            } else {
                unmappedIdElement.style.display = 'none';
                const copyContainer = stickyChildren[template.copyContainerIndex];
                copyContainer.children[template.unmappedCopyIndex].style.display = 'none';
            }
        }
        children[template.labelIndex].textContent = (_b = normalizedId.label) !== null && _b !== void 0 ? _b : '';
        if (displayState !== undefined) {
            this.updateWithId(container, mapped);
            updateIdStringWidth(displayState.segmentationGroupState.value.maxIdLength, mappedIdString);
        }
        return container;
    }
    update(container) {
        const id = tempStatedColor;
        const idString = container.dataset.id;
        if (idString === undefined) return;
        id.parseString(idString);
        this.updateWithId(container, id);
    }
    updateWithId(container, mapped) {
        const children = container.children;

        const stickyChildren = children[0].children;
        const template = this.template;
        const displayState = this.displayState;
        const segmentSelectionState = displayState.segmentSelectionState;
        const visibleSegments = displayState.segmentationGroupState.value.visibleSegments;

        stickyChildren[template.visibleIndex].checked = visibleSegments.has(mapped);
        container.dataset.selected = (segmentSelectionState.hasSelectedSegment && Uint64.equal(segmentSelectionState.selectedSegment, mapped)).toString();
        const idContainer = stickyChildren[template.idContainerIndex];
        setSegmentIdElementStyle(idContainer.children[template.idIndex], getBaseObjectColor(this.displayState, mapped));
        const unmappedIdIndex = template.unmappedIdIndex;

        if (unmappedIdIndex !== -1) {
            let unmappedIdString;
            let color;
            if (displayState.baseSegmentColoring.value && (unmappedIdString = container.dataset.unmappedId) !== undefined) {
                const unmappedId = tempStatedColor;
                unmappedId.parseString(unmappedIdString);
                color = getBaseObjectColor(this.displayState, unmappedId);
            } else {
                color = kOneVec;
            }
            setSegmentIdElementStyle(idContainer.children[unmappedIdIndex], color);
        }
    }
}
function setSegmentIdElementStyle(element, color) {
    element.style.backgroundColor = getCssColor(color);
    element.style.color = useWhiteBackground(color) ? 'white' : 'black';
}
export class SegmentWidgetWithExtraColumnsFactory extends SegmentWidgetFactory {
    constructor(displayState, parentElement, includeProperty) {
        var _a;
        const segmentPropertyMap = displayState.segmentationGroupState.value.segmentPropertyMap.value;
        const numericalProperties = ((_a = segmentPropertyMap === null || segmentPropertyMap === void 0 ? void 0 : segmentPropertyMap.numericalProperties) !== null && _a !== void 0 ? _a : []).filter(includeProperty);
        const template = segmentWidgetTemplateWithExtraColumns(numericalProperties.length);
        super(displayState, template);
        this.parentElement = parentElement;
        this.segmentPropertyMap = segmentPropertyMap;
        this.numericalProperties = numericalProperties;
        const numericalPropertyWidths = this.numericalPropertyWidths = new Array(this.numericalProperties.length);
        numericalPropertyWidths.fill(0);
    }
    getWithNormalizedId(normalizedId) {
        var _a, _b, _c;
        const container = super.getWithNormalizedId(normalizedId);
        const numericalProperties = this.numericalProperties;
        const numericalPropertyIndices = this.template.numericalPropertyIndices;

        if (numericalPropertyIndices.length > 0) {
            const index = (_c = (_a = this.segmentPropertyMap) === null || _a === void 0 ? void 0 : _a.getSegmentInlineIndex((_b = normalizedId.value) !== null && _b !== void 0 ? _b : normalizedId.key)) !== null && _c !== void 0 ? _c : -1;
            if (index !== -1) {
                const numericalPropertyWidths = this.numericalPropertyWidths;

                for (let i = 0, n = numericalPropertyIndices.length; i < n; ++i) {
                    const value = numericalProperties[i].values[index];
                    if (!isNaN(value)) {
                        const s = value.toString();
                        const w = s.length;
                        if (w > numericalPropertyWidths[i]) {
                            numericalPropertyWidths[i] = w;
                            this.parentElement.style.setProperty(`--neuroglancer-column-${i}-width`, `${w}ch`);
                        }
                        container.children[numericalPropertyIndices[i]].textContent = s;
                    }
                }
            }
        }
        return container;
    }
    makeHeaderLabel(id, widthProperty, parent) {
        const label = document.createElement('span');
        label.textContent = id;
        label.classList.add('neuroglancer-segment-list-header-label');
        label.classList.add('neuroglancer-segment-list-header-label');
        if (id === 'label') {
            parent.style.textAlign = 'left';
        }
        const sortIcon = document.createElement('span');
        sortIcon.classList.add('neuroglancer-segment-list-header-label-sort');
        label.appendChild(sortIcon);
        sortIcon.textContent = '▲';
        const width = measureElementClone(label).width;
        this.parentElement.style.setProperty(widthProperty, `${width}px`);
        parent.appendChild(label);
        return { id, label, sortIcon };
    }
    getHeader() {
        const template = this.template;

        const container = template.template.cloneNode( /*deep=*/true);
        const children = container.children;

        const stickyChildren = children[0].children;
        const copyContainer = stickyChildren[template.copyContainerIndex];
        copyContainer.style.visibility = 'hidden';
        stickyChildren[template.visibleIndex].style.visibility = 'hidden';
        children[template.filterIndex].style.visibility = 'hidden';
        const idContainer = stickyChildren[template.idContainerIndex];
        const propertyLabels = [this.makeHeaderLabel('id', '--neuroglancer-id-column-label-width', idContainer.children[template.idIndex]), this.makeHeaderLabel('label', '--neuroglancer-label-column-label-width', children[template.labelIndex])];
        const numericalProperties = this.numericalProperties;
        const numericalPropertyIndices = this.template.numericalPropertyIndices;

        for (let i = 0, n = numericalPropertyIndices.length; i < n; ++i) {
            const property = numericalProperties[i];
            const headerLabel = this.makeHeaderLabel(property.id, `--neuroglancer-column-${i}-label-width`, container.children[numericalPropertyIndices[i]]);
            const description = property.description;

            if (description) {
                headerLabel.label.title = description;
            }
            propertyLabels.push(headerLabel);
        }
        return { container, propertyLabels };
    }
}
export function makeSegmentWidget(displayState, normalizedId) {
    const factory = SegmentWidgetFactory.make(displayState !== null && displayState !== void 0 ? displayState : undefined, /*includeUnmapped=*/true);
    return factory.getWithNormalizedId(normalizedId);
}
export function registerCallbackWhenSegmentationDisplayStateChanged(displayState, context, callback) {
    context.registerDisposer(registerNestedSync((c, groupState) => {
        onVisibleSegmentsStateChanged(c, groupState, callback);
    }, displayState.segmentationGroupState));
    context.registerDisposer(registerNestedSync((c, colorGroupState) => {
        c.registerDisposer(colorGroupState.segmentColorHash.changed.add(callback));
        c.registerDisposer(colorGroupState.segmentDefaultColor.changed.add(callback));
    }, displayState.segmentationColorGroupState));
    context.registerDisposer(displayState.saturation.changed.add(callback));
    context.registerDisposer(displayState.segmentSelectionState.changed.add(callback));
    context.registerDisposer(displayState.baseSegmentColoring.changed.add(callback));
}
export function registerRedrawWhenSegmentationDisplayStateChanged(displayState, renderLayer) {
    const callback = renderLayer.redrawNeeded.dispatch;
    registerCallbackWhenSegmentationDisplayStateChanged(displayState, renderLayer, callback);
    renderLayer.registerDisposer(registerNestedSync((c, groupState) => {
        onTemporaryVisibleSegmentsStateChanged(c, groupState, callback);
    }, displayState.segmentationGroupState));
}
export function registerRedrawWhenSegmentationDisplayStateWithAlphaChanged(displayState, renderLayer) {
    registerRedrawWhenSegmentationDisplayStateChanged(displayState, renderLayer);
    renderLayer.registerDisposer(displayState.objectAlpha.changed.add(renderLayer.redrawNeeded.dispatch));
}
export function registerRedrawWhenSegmentationDisplayState3DChanged(displayState, renderLayer) {
    registerRedrawWhenSegmentationDisplayStateWithAlphaChanged(displayState, renderLayer);
    renderLayer.registerDisposer(displayState.transform.changed.add(renderLayer.redrawNeeded.dispatch));
    renderLayer.registerDisposer(displayState.renderScaleTarget.changed.add(renderLayer.redrawNeeded.dispatch));
    renderLayer.registerDisposer(displayState.transparentPickEnabled.changed.add(renderLayer.redrawNeeded.dispatch));
}
/**
 * Temporary values used by getObjectColor.
 */
const tempColor = vec4.create();
const tempStatedColor = new Uint64();
export function getBaseObjectColor(displayState, objectId, color = tempColor) {
    if (displayState == null) {
        color.fill(1);
        return color;
    }
    ;
    const colorGroupState = displayState.segmentationColorGroupState.value;
    const segmentStatedColors = colorGroupState.segmentStatedColors;

    if (segmentStatedColors.size !== 0 && colorGroupState.segmentStatedColors.get(objectId, tempStatedColor)) {
        // If displayState maps the ID to a color, use it
        color[0] = (tempStatedColor.low & 0x0000ff) / 255.0;
        color[1] = ((tempStatedColor.low & 0x00ff00) >>> 8) / 255.0;
        color[2] = ((tempStatedColor.low & 0xff0000) >>> 16) / 255.0;
        return color;
    }
    const segmentDefaultColor = colorGroupState.segmentDefaultColor.value;
    if (segmentDefaultColor !== undefined) {
        color[0] = segmentDefaultColor[0];
        color[1] = segmentDefaultColor[1];
        color[2] = segmentDefaultColor[2];
        return color;
    }
    colorGroupState.segmentColorHash.compute(color, objectId);
    return color;
}
/**
 * Returns the alpha-premultiplied color to use.
 */
export function getObjectColor(displayState, objectId, alpha = 1) {
    const color = tempColor;
    color[3] = alpha;
    getBaseObjectColor(displayState, objectId, color);
    let saturation = displayState.saturation.value;
    if (displayState.segmentSelectionState.isSelected(objectId)) {
        if (saturation > 0.5) {
            saturation = saturation -= 0.5;
        } else {
            saturation += 0.5;
        }
    }
    for (let i = 0; i < 3; ++i) {
        color[i] = color[i] * saturation + (1 - saturation);
    }
    color[0] *= alpha;
    color[1] *= alpha;
    color[2] *= alpha;
    return color;
}
export function sendVisibleSegmentsState(state, options = {}) {
    for (const property of VISIBLE_SEGMENTS_STATE_PROPERTIES) {
        options[property] = state[property].rpcId;
    }
    return options;
}
const Base = withSharedVisibility(ChunkRenderLayerFrontend);
export class SegmentationLayerSharedObject extends Base {
    constructor(chunkManager, displayState, chunkRenderLayer) {
        super(chunkRenderLayer);
        this.chunkManager = chunkManager;
        this.displayState = displayState;
    }
    initializeCounterpartWithChunkManager(options) {
        let displayState = this.displayState;

        options['chunkManager'] = this.chunkManager.rpcId;
        sendVisibleSegmentsState(displayState.segmentationGroupState.value, options);
        options['transform'] = this.registerDisposer(SharedWatchableValue.makeFromExisting(this.chunkManager.rpc, this.displayState.transform)).rpcId;
        options['renderScaleTarget'] = this.registerDisposer(SharedWatchableValue.makeFromExisting(this.chunkManager.rpc, this.displayState.renderScaleTarget)).rpcId;
        super.initializeCounterpart(this.chunkManager.rpc, options);
    }
}
export function forEachVisibleSegmentToDraw(displayState, renderLayer, emitColor, pickIDs, callback) {
    const alpha = Math.min(1, displayState.objectAlpha.value);
    const baseSegmentColoring = displayState.baseSegmentColoring.value;
    forEachVisibleSegment(displayState.segmentationGroupState.value, (objectId, rootObjectId) => {
        let pickIndex = pickIDs === null || pickIDs === void 0 ? void 0 : pickIDs.registerUint64(renderLayer, objectId);
        let color = emitColor ? getObjectColor(displayState, baseSegmentColoring ? objectId : rootObjectId, alpha) : undefined;
        callback(objectId, color, pickIndex, rootObjectId);
    });
}
//# sourceMappingURL=frontend.js.map