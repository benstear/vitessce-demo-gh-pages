import _Map from 'babel-runtime/core-js/map';
import _Symbol from 'babel-runtime/core-js/symbol';
import _Set from 'babel-runtime/core-js/set';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ChunkState } from '../chunk_manager/base';
import { Chunk, ChunkSource, WithParameters } from '../chunk_manager/frontend';
import { getCredentialsProviderCounterpart, WithCredentialsProvider } from '../credentials_provider/chunk_source_frontend';
import { PerspectiveViewRenderLayer } from '../perspective_view/render_layer';
import { update3dRenderLayerAttachment } from '../renderlayer';
import { GET_SINGLE_MESH_INFO_RPC_ID, SINGLE_MESH_CHUNK_KEY, SINGLE_MESH_LAYER_RPC_ID, SingleMeshSourceParametersWithInfo } from './base';
import { WatchableValue } from '../trackable_value';
import { DataType } from '../util/data_type';
import { vec3 } from '../util/geom';
import { parseSpecialUrl } from '../util/special_protocol_request';
import { withSharedVisibility } from '../visibility_priority/frontend';
import { glsl_COLORMAPS } from '../webgl/colormaps';
import { makeTrackableFragmentMain, makeWatchableShaderError, parameterizedEmitterDependentShaderGetter, shaderCodeWithLineDirective } from '../webgl/dynamic_shader';
import { countingBufferShaderModule, disableCountingBuffer, getCountingBuffer, IndexBufferAttributeHelper, makeIndexBuffer } from '../webgl/index_emulation';
import { getShaderType } from '../webgl/shader_lib';
import { addControlsToBuilder, getFallbackBuilderState, parseShaderUiControls, setControlsInShader, ShaderControlState } from '../webgl/shader_ui_controls';
import { computeTextureFormat, getSamplerPrefixForDataType, OneDimensionalTextureAccessHelper, setOneDimensionalTextureData, TextureFormat } from '../webgl/texture_access';
import { SharedObject } from '../worker_rpc';
const DEFAULT_FRAGMENT_MAIN = `void main() {
  emitGray();
}
`;
export class SingleMeshDisplayState {
    constructor() {
        this.shaderError = makeWatchableShaderError();
        this.fragmentMain = makeTrackableFragmentMain(DEFAULT_FRAGMENT_MAIN);
        this.shaderControlState = new ShaderControlState(this.fragmentMain);
    }
}
export function getShaderAttributeType(info) {
    return getShaderType(info.dataType, info.numComponents);
}
const vertexAttributeSamplerSymbols = [];
const vertexPositionTextureFormat = computeTextureFormat(new TextureFormat(), DataType.FLOAT32, 3);
const vertexNormalTextureFormat = vertexPositionTextureFormat;
function makeValidIdentifier(x) {
    return x.split(/[^a-zA-Z0-9]+/).filter(y => y).join('_');
}
export function pickAttributeNames(existingNames) {
    const seenNames = new _Set();
    let result = [];
    for (let existingName of existingNames) {
        let name = makeValidIdentifier(existingName);
        let suffix = '';
        let suffixNumber = 0;
        while (seenNames.has(name + suffix)) {
            suffix = '' + ++suffixNumber;
        }
        result.push(name + suffix);
    }
    return result;
}
export class SingleMeshShaderManager {
    constructor(attributeNames, attributeInfo) {
        this.attributeNames = attributeNames;
        this.attributeInfo = attributeInfo;
        this.tempLightVec = new Float32Array(4);
        this.textureAccessHelper = new OneDimensionalTextureAccessHelper('vertexData');
        this.indexBufferHelper = new IndexBufferAttributeHelper('vertexIndex');
    }
    defineAttributeAccess(builder, vertexIndexVariable) {
        let textureAccessHelper = this.textureAccessHelper;

        textureAccessHelper.defineShader(builder);
        const attributeNames = this.attributeNames;

        let numAttributes = 2 + attributeNames.length;
        for (let j = vertexAttributeSamplerSymbols.length; j < numAttributes; ++j) {
            vertexAttributeSamplerSymbols[j] = _Symbol(`SingleMeshShaderManager.vertexAttributeTextureUnit${j}`);
        }
        numAttributes = 0;
        builder.addTextureSampler(`sampler2D`, 'uVertexAttributeSampler0', vertexAttributeSamplerSymbols[numAttributes++]);
        builder.addTextureSampler(`sampler2D`, 'uVertexAttributeSampler1', vertexAttributeSamplerSymbols[numAttributes++]);
        builder.addVertexCode(textureAccessHelper.getAccessor('readVertexPosition', 'uVertexAttributeSampler0', DataType.FLOAT32, 3));
        builder.addVertexCode(textureAccessHelper.getAccessor('readVertexNormal', 'uVertexAttributeSampler1', DataType.FLOAT32, 3));
        let vertexMain = `
vec3 vertexPosition = readVertexPosition(${vertexIndexVariable});
vec3 vertexNormal = readVertexNormal(${vertexIndexVariable});
`;
        this.attributeInfo.forEach((info, i) => {
            builder.addTextureSampler(`${getSamplerPrefixForDataType(info.dataType)}sampler2D`, `uVertexAttributeSampler${numAttributes}`, vertexAttributeSamplerSymbols[numAttributes]);
            const attributeType = getShaderAttributeType(info);
            builder.addVarying(`highp ${attributeType}`, `vCustom${i}`);
            builder.addFragmentCode(`
#define ${attributeNames[i]} vCustom${i}
`);
            builder.addVertexCode(textureAccessHelper.getAccessor(`readAttribute${i}`, `uVertexAttributeSampler${numAttributes}`, info.dataType, info.numComponents));
            vertexMain += `vCustom${i} = readAttribute${i}(${vertexIndexVariable});\n`;
            ++numAttributes;
        });
        builder.addVertexMain(vertexMain);
    }
    defineShader(builder) {
        builder.require(countingBufferShaderModule);
        this.indexBufferHelper.defineShader(builder);
        builder.addVarying('highp float', 'vLightingFactor');
        builder.addUniform('highp vec4', 'uLightDirection');
        builder.addUniform('highp vec4', 'uColor');
        builder.addUniform('highp mat4', 'uModelMatrix');
        builder.addUniform('highp mat4', 'uProjection');
        builder.addUniform('highp uint', 'uPickID');
        builder.addVarying('highp uint', 'vPickID', 'flat');
        builder.addVertexMain(`
uint triangleIndex = getPrimitiveIndex() / 3u;
vPickID = uPickID + triangleIndex;
`);
        builder.addFragmentCode(`
void emitPremultipliedRGBA(vec4 color) {
  emit(vec4(color.rgb * vLightingFactor, color.a), vPickID);
}
void emitRGBA(vec4 color) {
  color = clamp(color, 0.0, 1.0);
  color.xyz *= color.a;
  emitPremultipliedRGBA(color);
}
void emitRGB(vec3 color) {
  emitRGBA(vec4(color, 1.0));
}
void emitGray() {
  emitRGB(vec3(1.0, 1.0, 1.0));
}
`);
        builder.addFragmentCode(glsl_COLORMAPS);
        // Make sure defineAttributeAccess is the last thing that adds fragment code prior to
        // this.fragmentMain, so that the #define attributes don't mess anything up.
        this.defineAttributeAccess(builder, 'vertexIndex');
        builder.addVertexMain(`
gl_Position = uProjection * (uModelMatrix * vec4(vertexPosition, 1.0));
vec3 normal = normalize((uModelMatrix * vec4(vertexNormal, 0.0)).xyz);
vLightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;
`);
    }
    beginLayer(gl, shader, renderContext) {
        const lightDirection = renderContext.lightDirection,
              ambientLighting = renderContext.ambientLighting,
              directionalLighting = renderContext.directionalLighting,
              projectionParameters = renderContext.projectionParameters;
        const viewProjectionMat = projectionParameters.viewProjectionMat;

        gl.uniformMatrix4fv(shader.uniform('uProjection'), false, viewProjectionMat);
        let lightVec = this.tempLightVec;
        vec3.scale(lightVec, lightDirection, directionalLighting);
        lightVec[3] = ambientLighting;
        gl.uniform4fv(shader.uniform('uLightDirection'), lightVec);
    }
    setPickID(gl, shader, pickID) {
        gl.uniform1ui(shader.uniform('uPickID'), pickID);
    }
    beginObject(gl, shader, objectToDataMatrix) {
        gl.uniformMatrix4fv(shader.uniform('uModelMatrix'), false, objectToDataMatrix);
    }
    bindVertexData(gl, shader, data) {
        let index = 0;
        const bindTexture = texture => {
            const textureUnit = WebGL2RenderingContext.TEXTURE0 + shader.textureUnit(vertexAttributeSamplerSymbols[index]);
            gl.activeTexture(textureUnit);
            gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
            ++index;
        };
        bindTexture(data.vertexTexture);
        bindTexture(data.normalTexture);
        const attributeNames = this.attributeNames;

        data.vertexAttributeTextures.forEach((texture, i) => {
            if (attributeNames[i] !== undefined) {
                bindTexture(texture);
            }
        });
    }
    disableVertexData(gl, shader) {
        let numTextures = 2;
        let numVertexAttributes = this.attributeInfo.length;
        let attributeNames = this.attributeNames;

        for (let i = 0; i < numVertexAttributes; ++i) {
            if (attributeNames[i] !== undefined) {
                ++numTextures;
            }
        }
        for (let i = 0; i < numTextures; ++i) {
            let curTextureUnit = shader.textureUnit(vertexAttributeSamplerSymbols[i]) + WebGL2RenderingContext.TEXTURE0;
            gl.activeTexture(curTextureUnit);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }
    drawFragment(gl, shader, chunk, countingBuffer) {
        countingBuffer.ensure(chunk.numIndices).bind(shader);
        this.bindVertexData(gl, shader, chunk.vertexData);
        this.indexBufferHelper.bind(chunk.indexBuffer, shader);
        gl.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, chunk.numIndices);
    }
    endLayer(gl, shader) {
        disableCountingBuffer(gl, shader);
        this.indexBufferHelper.disable(shader);
        this.disableVertexData(gl, shader);
    }
}
export class VertexChunkData {
    copyToGPU(gl, attributeFormats) {
        const getBufferTexture = (data, format) => {
            let texture = gl.createTexture();
            gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
            setOneDimensionalTextureData(gl, format, data);
            return texture;
        };
        this.vertexTexture = getBufferTexture(this.vertexPositions, vertexPositionTextureFormat);
        this.normalTexture = getBufferTexture(this.vertexNormals, vertexNormalTextureFormat);
        this.vertexAttributeTextures = this.vertexAttributes.map((data, i) => getBufferTexture(data, attributeFormats[i]));
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
    }
    freeGPUMemory(gl) {
        gl.deleteTexture(this.vertexTexture);
        gl.deleteTexture(this.normalTexture);
        let vertexAttributeTextures = this.vertexAttributeTextures;

        for (const buffer of vertexAttributeTextures) {
            gl.deleteTexture(buffer);
        }
        vertexAttributeTextures.length = 0;
    }
}
export class SingleMeshChunk extends Chunk {
    constructor(source, x) {
        super(source);
        const vertexData = this.vertexData = new VertexChunkData();
        vertexData.vertexPositions = x['vertexPositions'];
        vertexData.vertexNormals = x['vertexNormals'];
        vertexData.vertexAttributes = x['vertexAttributes'];
        let indices = this.indices = x['indices'];
        this.numIndices = indices.length;
    }
    copyToGPU(gl) {
        super.copyToGPU(gl);
        this.vertexData.copyToGPU(gl, this.source.attributeTextureFormats);
        this.indexBuffer = makeIndexBuffer(gl, this.indices);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        this.vertexData.freeGPUMemory(gl);
        this.indexBuffer.dispose();
    }
}
export function getAttributeTextureFormats(vertexAttributes) {
    return vertexAttributes.map(x => computeTextureFormat(new TextureFormat(), x.dataType, x.numComponents));
}
export class SingleMeshSource extends WithParameters(WithCredentialsProvider()(ChunkSource), SingleMeshSourceParametersWithInfo) {
    constructor() {
        super(...arguments);
        this.attributeTextureFormats = getAttributeTextureFormats(this.info.vertexAttributes);
    }
    get info() {
        return this.parameters.info;
    }
    getChunk(x) {
        return new SingleMeshChunk(this, x);
    }
}
const SharedObjectWithSharedVisibility = withSharedVisibility(SharedObject);
class SingleMeshLayerSharedObject extends SharedObjectWithSharedVisibility {}
export class SingleMeshLayer extends PerspectiveViewRenderLayer {
    constructor(source, displayState, transform) {
        super();
        this.source = source;
        this.displayState = displayState;
        this.transform = transform;
        this.shaderManager = new SingleMeshShaderManager(pickAttributeNames(this.source.info.vertexAttributes.map(a => a.name)), this.source.info.vertexAttributes);
        this.shaders = new _Map();
        this.sharedObject = this.registerDisposer(new SingleMeshLayerSharedObject());
        this.shaderGetter = parameterizedEmitterDependentShaderGetter(this, this.gl, {
            memoizeKey: { t: `single_mesh/RenderLayer`, attributes: this.source.info.vertexAttributes },
            fallbackParameters: new WatchableValue(getFallbackBuilderState(parseShaderUiControls(DEFAULT_FRAGMENT_MAIN))),
            parameters: this.displayState.shaderControlState.builderState,
            encodeParameters: p => p.key,
            shaderError: this.displayState.shaderError,
            defineShader: (builder, shaderBuilderState) => {
                if (shaderBuilderState.parseResult.errors.length !== 0) {
                    throw new Error('Invalid UI control specification');
                }
                addControlsToBuilder(shaderBuilderState, builder);
                this.shaderManager.defineShader(builder);
                builder.setFragmentMainFunction(shaderCodeWithLineDirective(shaderBuilderState.parseResult.code));
            }
        });
        this.countingBuffer = this.registerDisposer(getCountingBuffer(this.gl));
        this.registerDisposer(displayState.shaderControlState.parseResult.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(displayState.shaderControlState.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(transform.changed.add(this.redrawNeeded.dispatch));
        const sharedObject = this.sharedObject;

        sharedObject.visibility.add(this.visibility);
        sharedObject.RPC_TYPE_ID = SINGLE_MESH_LAYER_RPC_ID;
        sharedObject.initializeCounterpart(source.chunkManager.rpc, {
            'chunkManager': source.chunkManager.rpcId,
            'source': source.addCounterpartRef()
        });
    }
    disposeShaders() {
        let shaders = this.shaders;

        for (let shader of shaders.values()) {
            if (shader !== null) {
                shader.dispose();
            }
        }
        shaders.clear();
    }
    disposed() {
        this.disposeShaders();
        super.disposed();
    }
    get isTransparent() {
        return this.displayState.fragmentMain.value.match(/emitRGBA|emitPremultipliedRGBA/) !== null;
    }
    get gl() {
        return this.source.gl;
    }
    isReady() {
        let chunk = this.source.chunks.get(SINGLE_MESH_CHUNK_KEY);
        if (chunk === undefined || chunk.state !== ChunkState.GPU_MEMORY) {
            return false;
        }
        return true;
    }
    draw(renderContext, attachment) {
        if (!renderContext.emitColor && renderContext.alreadyEmittedPickID) {
            // No need for a separate pick ID pass.
            return;
        }
        const modelMatrix = update3dRenderLayerAttachment(this.transform.value, renderContext.projectionParameters.displayDimensionRenderInfo, attachment);
        if (modelMatrix === undefined) return;
        let chunk = this.source.chunks.get(SINGLE_MESH_CHUNK_KEY);
        if (chunk === undefined || chunk.state !== ChunkState.GPU_MEMORY) {
            return;
        }
        const shaderResult = this.shaderGetter(renderContext.emitter);
        const shader = shaderResult.shader,
              parameters = shaderResult.parameters;

        if (shader === null) {
            return;
        }
        const gl = this.gl;

        const shaderManager = this.shaderManager;
        shader.bind();
        shaderManager.beginLayer(gl, shader, renderContext);
        setControlsInShader(gl, shader, this.displayState.shaderControlState, parameters.parseResult.controls);
        let pickIDs = renderContext.pickIDs;

        shaderManager.beginObject(gl, shader, modelMatrix);
        if (renderContext.emitPickID) {
            shaderManager.setPickID(gl, shader, pickIDs.register(this, chunk.numIndices / 3));
        }
        shaderManager.drawFragment(gl, shader, chunk, this.countingBuffer);
        shaderManager.endLayer(gl, shader);
    }
    transformPickedValue(pickState) {
        const pickedOffset = pickState.pickedOffset;

        let chunk = this.source.chunks.get(SINGLE_MESH_CHUNK_KEY);
        if (chunk === undefined) {
            return undefined;
        }
        let startIndex = pickedOffset * 3;
        let indices = chunk.indices;

        if (startIndex >= indices.length) {
            return undefined;
        }
        // FIXME: compute closest vertex position.  For now just use first vertex.
        let vertexIndex = indices[startIndex];
        let values = [];
        const attributeNames = this.shaderManager.attributeNames;

        chunk.vertexData.vertexAttributes.forEach((attributes, i) => {
            const attributeName = attributeNames[i];
            if (attributeName !== undefined) {
                values.push(`${attributeName}=${attributes[vertexIndex].toPrecision(6)}`);
            }
        });
        return values.join(', ');
    }
}
function getSingleMeshInfo(chunkManager, credentialsManager, url) {
    return chunkManager.memoize.getUncounted({ type: 'single_mesh:getMeshInfo', url }, async () => {
        var _parseSpecialUrl = parseSpecialUrl(url, credentialsManager);

        const parsedUrl = _parseSpecialUrl.url,
              credentialsProvider = _parseSpecialUrl.credentialsProvider;

        const info = await chunkManager.rpc.promiseInvoke(GET_SINGLE_MESH_INFO_RPC_ID, {
            'chunkManager': chunkManager.addCounterpartRef(),
            credentialsProvider: getCredentialsProviderCounterpart(chunkManager, credentialsProvider),
            'parameters': { meshSourceUrl: parsedUrl }
        });
        return { info, url: parsedUrl, credentialsProvider };
    });
}
export async function getSingleMeshSource(chunkManager, credentialsManager, url) {
    var _ref = await getSingleMeshInfo(chunkManager, credentialsManager, url);

    const info = _ref.info,
          parsedUrl = _ref.url,
          credentialsProvider = _ref.credentialsProvider;

    return chunkManager.getChunkSource(SingleMeshSource, { credentialsProvider, parameters: { meshSourceUrl: parsedUrl, info } });
}
//# sourceMappingURL=frontend.js.map