import _slicedToArray from "babel-runtime/helpers/slicedToArray";
import _JSON$stringify from "babel-runtime/core-js/json/stringify";
import _Map from "babel-runtime/core-js/map";
import _Set from "babel-runtime/core-js/set";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import { Chunk, ChunkSource, withChunkManager, WithParameters } from "../chunk_manager/backend";
import { ChunkPriorityTier } from "../chunk_manager/base";
import { WithSharedCredentialsProviderCounterpart } from "../credentials_provider/shared_counterpart";
import { computeVertexNormals } from "../mesh/backend";
import { GET_SINGLE_MESH_INFO_RPC_ID, SINGLE_MESH_CHUNK_KEY, SINGLE_MESH_LAYER_RPC_ID, SingleMeshSourceParametersWithInfo } from "./base";
import { stableStringify } from "../util/json";
import { getBasePriority, getPriorityTier, withSharedVisibility } from "../visibility_priority/backend";
import { registerPromiseRPC, registerSharedObject, SharedObjectCounterpart } from "../worker_rpc";
const SINGLE_MESH_CHUNK_PRIORITY = 50;
/**
 * Chunk that contains the single mesh.
 */
export class SingleMeshChunk extends Chunk {
    constructor() {
        super();
        this.data = null;
    }
    freeSystemMemory() {
        this.data = null;
    }
    serialize(msg, transfers) {
        super.serialize(msg, transfers);
        var _data = this.data;
        let vertexPositions = _data.vertexPositions,
            indices = _data.indices,
            vertexNormals = _data.vertexNormals,
            vertexAttributes = _data.vertexAttributes;

        msg['vertexPositions'] = vertexPositions;
        msg['indices'] = indices;
        msg['vertexNormals'] = vertexNormals;
        msg['vertexAttributes'] = vertexAttributes;
        const transferSet = new _Set();
        transferSet.add(vertexPositions.buffer);
        transferSet.add(indices.buffer);
        transferSet.add(vertexNormals.buffer);
        for (const data of vertexAttributes) {
            transferSet.add(data.buffer);
        }
        transfers.push(...transferSet);
        this.data = null;
    }
    downloadSucceeded() {
        var _data2 = this.data;
        let vertexPositions = _data2.vertexPositions,
            indices = _data2.indices,
            vertexNormals = _data2.vertexNormals,
            vertexAttributes = _data2.vertexAttributes;

        let totalBytes = this.gpuMemoryBytes = vertexPositions.byteLength + indices.byteLength + vertexNormals.byteLength;
        for (const data of vertexAttributes) {
            totalBytes += data.byteLength;
        }
        this.systemMemoryBytes = this.gpuMemoryBytes = totalBytes;
        super.downloadSucceeded();
    }
}
const singleMeshFactories = new _Map();
export function registerSingleMeshFactory(name, factory) {
    singleMeshFactories.set(name, factory);
}
const protocolPattern = /^(?:([a-zA-Z-+_]+):\/\/)?(.*)$/;
function getDataSource(factories, url) {
    let m = url.match(protocolPattern);
    if (m === null || m[1] === undefined) {
        throw new Error(`Data source URL must have the form "<protocol>://<path>".`);
    }
    let dataSource = m[1];
    let factory = factories.get(dataSource);
    if (factory === undefined) {
        throw new Error(`Unsupported data source: ${_JSON$stringify(dataSource)}.`);
    }
    return [factory, m[2], dataSource];
}
export function getMesh(chunkManager, credentialsProvider, url, getPriority, cancellationToken) {
    var _getDataSource = getDataSource(singleMeshFactories, url),
        _getDataSource2 = _slicedToArray(_getDataSource, 2);

    let factory = _getDataSource2[0],
        path = _getDataSource2[1];

    return factory.getMesh(chunkManager, credentialsProvider, path, getPriority, cancellationToken);
}
export function getMinMax(array) {
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    for (let value of array) {
        min = Math.min(min, value);
        max = Math.max(max, value);
    }
    return [min, max];
}
export function getCombinedMesh(chunkManager, credentialsProvider, parameters, getPriority, cancellationToken) {
    return getMesh(chunkManager, credentialsProvider, parameters.meshSourceUrl, getPriority, cancellationToken);
}
let SingleMeshSource = class SingleMeshSource extends WithParameters(WithSharedCredentialsProviderCounterpart()(ChunkSource), SingleMeshSourceParametersWithInfo) {
    getChunk() {
        const key = SINGLE_MESH_CHUNK_KEY;
        let chunk = this.chunks.get(key);
        if (chunk === undefined) {
            chunk = this.getNewChunk_(SingleMeshChunk);
            chunk.initialize(key);
            this.addChunk(chunk);
        }
        return chunk;
    }
    download(chunk, cancellationToken) {
        const getPriority = () => ({ priorityTier: chunk.priorityTier, priority: chunk.priority });
        return getCombinedMesh(this.chunkManager, this.credentialsProvider, this.parameters, getPriority, cancellationToken).then(data => {
            if (stableStringify(data.info) !== stableStringify(this.parameters.info)) {
                throw new Error(`Mesh info has changed.`);
            }
            if (data.vertexNormals === undefined) {
                data.vertexNormals = computeVertexNormals(data.vertexPositions, data.indices);
            }
            chunk.data = data;
        });
    }
};
SingleMeshSource = __decorate([registerSharedObject()], SingleMeshSource);
export { SingleMeshSource };
const SingleMeshLayerBase = withSharedVisibility(withChunkManager(SharedObjectCounterpart));
let SingleMeshLayer = class SingleMeshLayer extends SingleMeshLayerBase {
    constructor(rpc, options) {
        super(rpc, options);
        this.source = this.registerDisposer(rpc.getRef(options['source']));
        this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => {
            this.updateChunkPriorities();
        }));
    }
    updateChunkPriorities() {
        const visibility = this.visibility.value;
        if (visibility === Number.NEGATIVE_INFINITY) {
            return;
        }
        const priorityTier = getPriorityTier(visibility);
        const basePriority = getBasePriority(visibility);
        const source = this.source,
              chunkManager = this.chunkManager;

        const chunk = source.getChunk();
        chunkManager.requestChunk(chunk, priorityTier, basePriority + SINGLE_MESH_CHUNK_PRIORITY);
    }
};
SingleMeshLayer = __decorate([registerSharedObject(SINGLE_MESH_LAYER_RPC_ID)], SingleMeshLayer);
export { SingleMeshLayer };
const INFO_PRIORITY = 1000;
registerPromiseRPC(GET_SINGLE_MESH_INFO_RPC_ID, async function (x, cancellationToken) {
    const chunkManager = this.getRef(x['chunkManager']);
    const credentialsProvider = this.getOptionalRef(x['credentialsProvider']);
    try {
        let parameters = x['parameters'];
        const mesh = await getCombinedMesh(chunkManager, credentialsProvider, parameters, () => ({ priorityTier: ChunkPriorityTier.VISIBLE, priority: INFO_PRIORITY }), cancellationToken);
        return { value: mesh.info };
    } finally {
        chunkManager.dispose();
        credentialsProvider === null || credentialsProvider === void 0 ? void 0 : credentialsProvider.dispose();
    }
});
//# sourceMappingURL=backend.js.map