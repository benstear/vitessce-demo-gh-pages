import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Object$entries from 'babel-runtime/core-js/object/entries';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import _Symbol$iterator from 'babel-runtime/core-js/symbol/iterator';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Map from 'babel-runtime/core-js/map';
import _WeakSet from 'babel-runtime/core-js/weak-set';
import _Set from 'babel-runtime/core-js/set';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Array$from from 'babel-runtime/core-js/array/from';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
import { CoordinateSpaceCombiner, coordinateTransformSpecificationFromLegacyJson, emptyInvalidCoordinateSpace, isGlobalDimension, isLocalDimension, isLocalOrChannelDimension, TrackableCoordinateSpace } from './coordinate_transform';
import { makeEmptyDataSourceSpecification } from './datasource';
import { LayerDataSource, layerDataSourceSpecificationFromJson } from './layer_data_source';
import { Position } from './navigation_state';
import { RENDERED_VIEW_ADD_LAYER_RPC_ID, RENDERED_VIEW_REMOVE_LAYER_RPC_ID } from './render_layer_common';
import { StatusMessage } from './status';
import { TrackableBoolean } from './trackable_boolean';
import { registerNested, WatchableValue } from './trackable_value';
import { LayerDataSourcesTab } from './ui/layer_data_sources_tab';
import { SELECTED_LAYER_SIDE_PANEL_DEFAULT_LOCATION, UserLayerSidePanelsState } from './ui/layer_side_panel_state';
import { DEFAULT_SIDE_PANEL_LOCATION, TrackableSidePanelLocation } from './ui/side_panel_location';
import { LayerToolBinder, SelectedLegacyTool } from './ui/tool';
import { gatherUpdate } from './util/array';
import { invokeDisposers, RefCounted } from './util/disposable';
import { emptyToUndefined, parseArray, parseFixedLengthArray, verifyBoolean, verifyFiniteFloat, verifyInt, verifyObject, verifyObjectProperty, verifyOptionalObjectProperty, verifyOptionalString, verifyString } from './util/json';
import { MessageList } from './util/message_list';
import { NullarySignal } from './util/signal';
import { addSignalBinding, removeSignalBinding } from './util/signal_binding_updater';
import { Uint64 } from './util/uint64';
import { kEmptyFloat32Vec } from './util/vector';
import { TabSpecification } from './widget/tab_view';
import { globalViewerConfig } from './viewer';
const TOOL_JSON_KEY = 'tool';
const TOOL_BINDINGS_JSON_KEY = 'toolBindings';
const LOCAL_POSITION_JSON_KEY = 'localPosition';
const LOCAL_COORDINATE_SPACE_JSON_KEY = 'localDimensions';
const SOURCE_JSON_KEY = 'source';
const TRANSFORM_JSON_KEY = 'transform';
const PICK_JSON_KEY = 'pick';
export class LayerActionContext {
    constructor() {
        this.callbacks = [];
    }
    defer(callback) {
        this.callbacks.push(callback);
    }
}
export class UserLayer extends RefCounted {
    constructor(managedLayer) {
        super();
        this.managedLayer = managedLayer;
        this.pick = new TrackableBoolean(true, true);
        this.layersChanged = new NullarySignal();
        this.readyStateChanged = new NullarySignal();
        this.specificationChanged = new NullarySignal();
        this.renderLayers = new Array();
        this.loadingCounter = 1;
        this.tabs = this.registerDisposer(new TabSpecification());
        this.panels = new UserLayerSidePanelsState(this);
        this.tool = this.registerDisposer(new SelectedLegacyTool(this));
        this.toolBinder = new LayerToolBinder(this);
        this.dataSourcesChanged = new NullarySignal();
        this.dataSources = [];
        this.allowingRefresh = false;
        this.localCoordinateSpaceCombiner.includeDimensionPredicate = isLocalOrChannelDimension;
        this.tabs.changed.add(this.specificationChanged.dispatch);
        this.panels.specificationChanged.add(this.specificationChanged.dispatch);
        this.tool.changed.add(this.specificationChanged.dispatch);
        this.toolBinder.changed.add(this.specificationChanged.dispatch);
        this.localPosition.changed.add(this.specificationChanged.dispatch);
        this.pick.changed.add(this.specificationChanged.dispatch);
        this.pick.changed.add(this.layersChanged.dispatch);
        this.dataSourcesChanged.add(this.specificationChanged.dispatch);
        this.dataSourcesChanged.add(() => this.updateDataSubsourceActivations());
        this.tabs.add('source', {
            label: 'Source',
            order: -100,
            getter: () => new LayerDataSourcesTab(this)
        });
    }
    get localPosition() {
        return this.managedLayer.localPosition;
    }
    get localCoordinateSpaceCombiner() {
        return this.managedLayer.localCoordinateSpaceCombiner;
    }
    get localCoordinateSpace() {
        return this.managedLayer.localCoordinateSpace;
    }
    get type() {
        return this.constructor.type;
    }
    initializeSelectionState(state) {
        state.generation = -1;
        state.localPositionValid = false;
        state.localPosition = kEmptyFloat32Vec;
        state.localCoordinateSpace = undefined;
        state.annotationId = undefined;
        state.annotationType = undefined;
        state.annotationBuffer = undefined;
        state.annotationIndex = undefined;
        state.annotationCount = undefined;
        state.annotationSourceIndex = undefined;
        state.annotationSubsource = undefined;
        state.annotationPartIndex = undefined;
        state.value = undefined;
    }
    resetSelectionState(state) {
        state.localPositionValid = false;
        state.annotationId = undefined;
        state.value = undefined;
    }
    selectionStateFromJson(state, json) {
        const localCoordinateSpace = state.localCoordinateSpace = this.localCoordinateSpace.value;
        const rank = localCoordinateSpace.rank;

        if (rank !== 0) {
            const localPosition = verifyOptionalObjectProperty(json, LOCAL_POSITION_JSON_KEY, positionObj => parseFixedLengthArray(new Float32Array(rank), positionObj, verifyFiniteFloat));
            if (localPosition === undefined) {
                state.localPositionValid = false;
            } else {
                state.localPositionValid = true;
                state.localPosition = localPosition;
            }
        }
        const annotationId = state.annotationId = verifyOptionalObjectProperty(json, 'annotationId', verifyString);
        if (annotationId !== undefined) {
            state.annotationSourceIndex = verifyOptionalObjectProperty(json, 'annotationSource', verifyInt, 0);
            state.annotationPartIndex = verifyOptionalObjectProperty(json, 'annotationPart', verifyInt);
            state.annotationSubsource = verifyOptionalObjectProperty(json, 'annotationSubsource', verifyString);
        }
        state.value = json.value;
    }
    // Derived classes should override.
    displaySelectionState(state, parent, context) {
        state;
        parent;
        context;
        return false;
    }
    selectionStateToJson(state, forPython) {
        forPython;
        const json = {};
        if (state.localPositionValid) {
            const localPosition = state.localPosition;

            if (localPosition.length > 0) {
                json.localPosition = _Array$from(localPosition);
            }
        }
        if (state.annotationId !== undefined) {
            json.annotationId = state.annotationId;
            json.annotationPart = state.annotationPartIndex;
            json.annotationSource = state.annotationSourceIndex;
            json.annotationSubsource = state.annotationSubsource;
        }
        if (state.value != null) {
            json.value = state.value;
        }
        return json;
    }
    captureSelectionState(state, mouseState) {
        state.localCoordinateSpace = this.localCoordinateSpace.value;
        const curLocalPosition = this.localPosition.value;
        let localPosition = state.localPosition;

        if (localPosition.length !== curLocalPosition.length) {
            state.localPosition = curLocalPosition.slice();
        } else {
            localPosition.set(curLocalPosition);
        }
        state.localPositionValid = true;
        state.value = this.getValueAt(mouseState.position, mouseState);
    }
    copySelectionState(dest, source) {
        dest.generation = source.generation;
        dest.localPositionValid = source.localPositionValid;
        dest.localCoordinateSpace = source.localCoordinateSpace;
        const curLocalPosition = source.localPosition;
        let localPosition = dest.localPosition;

        if (localPosition.length !== curLocalPosition.length) {
            dest.localPosition = curLocalPosition.slice();
        } else {
            dest.localPosition.set(curLocalPosition);
        }
        dest.annotationId = source.annotationId;
        dest.annotationType = source.annotationType;
        dest.annotationBuffer = source.annotationBuffer;
        dest.annotationIndex = source.annotationIndex;
        dest.annotationCount = source.annotationCount;
        dest.annotationSourceIndex = source.annotationSourceIndex;
        dest.annotationSubsource = source.annotationSubsource;
        dest.annotationPartIndex = source.annotationPartIndex;
        dest.value = source.value;
    }
    get isReady() {
        return this.loadingCounter === 0;
    }
    get manager() {
        return this.managedLayer.manager;
    }
    canAddDataSource() {
        return true;
    }
    addDataSource(spec) {
        const layerDataSource = new LayerDataSource(this, spec);
        this.dataSources.push(layerDataSource);
        this.dataSourcesChanged.dispatch();
        return layerDataSource;
    }
    // Should be overridden by derived classes.
    activateDataSubsources(subsources) {
        subsources;
    }
    updateDataSubsourceActivations() {
        function* getDataSubsources() {
            for (const dataSource of this.dataSources) {
                const loadState = dataSource.loadState;

                if (loadState === undefined || loadState.error !== undefined) continue;
                for (const subsource of loadState.subsources) {
                    if (subsource.enabled) {
                        yield subsource;
                    } else {
                        const activated = subsource.activated;

                        subsource.messages.clearMessages();
                        if (activated !== undefined) {
                            activated.dispose();
                            subsource.activated = undefined;
                            loadState.activatedSubsourcesChanged.dispatch();
                        }
                    }
                }
            }
        }
        this.activateDataSubsources(getDataSubsources.call(this));
    }
    decrementLoadingCounter() {
        if (--this.loadingCounter === 0) {
            this.readyStateChanged.dispatch();
        }
    }
    markLoading() {
        const localRetainer = this.localCoordinateSpaceCombiner.retain();
        const globalRetainer = this.manager.root.coordinateSpaceCombiner.retain();
        if (++this.loadingCounter === 1) {
            this.readyStateChanged.dispatch();
        }
        const disposer = () => {
            localRetainer();
            globalRetainer();
            this.decrementLoadingCounter();
        };
        return disposer;
    }
    addCoordinateSpace(coordinateSpace) {
        const globalBinding = this.manager.root.coordinateSpaceCombiner.bind(coordinateSpace);
        const localBinding = this.localCoordinateSpaceCombiner.bind(coordinateSpace);
        return () => {
            globalBinding();
            localBinding();
        };
    }
    initializationDone() {
        const selectionState = this.selectionState = {};
        this.initializeSelectionState(selectionState);
        this.decrementLoadingCounter();
    }
    getLegacyDataSourceSpecifications(sourceSpec, layerSpec, legacyTransform, explicitSpecs) {
        layerSpec;
        explicitSpecs;
        if (sourceSpec === undefined) return [];
        return [layerDataSourceSpecificationFromJson(sourceSpec, legacyTransform)];
    }
    getDataSourceSpecifications(layerSpec) {
        let legacySpec = undefined;
        let specs = verifyObjectProperty(layerSpec, SOURCE_JSON_KEY, sourcesObj => {
            if (Array.isArray(sourcesObj)) {
                return sourcesObj.map(source => layerDataSourceSpecificationFromJson(source));
            } else if (typeof sourcesObj === 'object') {
                return [layerDataSourceSpecificationFromJson(sourcesObj)];
            } else {
                legacySpec = sourcesObj;
                return [];
            }
        });
        const legacyTransform = verifyObjectProperty(layerSpec, TRANSFORM_JSON_KEY, coordinateTransformSpecificationFromLegacyJson);
        specs.push(...this.getLegacyDataSourceSpecifications(legacySpec, layerSpec, legacyTransform, specs));
        specs = specs.filter(spec => spec.url);
        if (specs.length === 0) {
            specs.push(makeEmptyDataSourceSpecification());
        }
        return specs;
    }
    restoreState(specification) {
        this.tool.restoreState(specification[TOOL_JSON_KEY]);
        this.toolBinder.restoreState(specification[TOOL_BINDINGS_JSON_KEY]);
        this.panels.restoreState(specification);
        this.localCoordinateSpace.restoreState(specification[LOCAL_COORDINATE_SPACE_JSON_KEY]);
        this.localPosition.restoreState(specification[LOCAL_POSITION_JSON_KEY]);
        if (this.constructor.supportsPickOption) {
            this.pick.restoreState(specification[PICK_JSON_KEY]);
        }
        for (const spec of this.getDataSourceSpecifications(specification)) {
            this.addDataSource(spec);
        }
    }
    addRenderLayer(layer) {
        this.renderLayers.push(layer);
        const layersChanged = this.layersChanged;

        layer.layerChanged.add(layersChanged.dispatch);
        layer.userLayer = this;
        layersChanged.dispatch();
        return () => this.removeRenderLayer(layer);
    }
    removeRenderLayer(layer) {
        const renderLayers = this.renderLayers,
              layersChanged = this.layersChanged;

        const index = renderLayers.indexOf(layer);
        if (index === -1) {
            throw new Error('Attempted to remove invalid RenderLayer');
        }
        renderLayers.splice(index, 1);
        layer.layerChanged.remove(layersChanged.dispatch);
        layer.userLayer = undefined;
        layer.dispose();
        layersChanged.dispatch();
    }
    disposed() {
        const layersChanged = this.layersChanged;

        invokeDisposers(this.dataSources);
        for (const layer of this.renderLayers) {
            layer.layerChanged.remove(layersChanged.dispatch);
            layer.dispose();
        }
        this.renderLayers.length = 0;
        super.disposed();
    }
    getValueAt(position, pickState) {
        let result;
        let renderLayers = this.renderLayers;
        let pickedRenderLayer = pickState.pickedRenderLayer;

        if (pickedRenderLayer !== null && renderLayers.indexOf(pickedRenderLayer) !== -1) {
            result = pickedRenderLayer.transformPickedValue(pickState);
            result = this.transformPickedValue(result);
            if (result != null) return result;
        }
        for (let layer of renderLayers) {
            result = layer.getValueAt(position);
            if (result != null) {
                break;
            }
        }
        return this.transformPickedValue(result);
    }
    transformPickedValue(value) {
        return value;
    }
    toJSON() {
        return _Object$assign({ type: this.type, [SOURCE_JSON_KEY]: dataSourcesToJson(this.dataSources), [TOOL_JSON_KEY]: this.tool.toJSON(), [TOOL_BINDINGS_JSON_KEY]: this.toolBinder.toJSON(), [LOCAL_COORDINATE_SPACE_JSON_KEY]: this.localCoordinateSpace.toJSON(), [LOCAL_POSITION_JSON_KEY]: this.localPosition.toJSON(), [PICK_JSON_KEY]: this.pick.toJSON() }, this.panels.toJSON());
    }
    // Derived classes should override.
    handleAction(_action, _context) {}
    selectedValueToJson(value) {
        return value;
    }
    selectedValueFromJson(json) {
        return json;
    }
    setLayerPosition(modelTransform, layerPosition) {
        const globalPosition = this.manager.root.globalPosition;
        const localPosition = this.localPosition;

        if (modelTransform) {
            gatherUpdate(globalPosition.value, layerPosition, modelTransform.globalToRenderLayerDimensions);
            gatherUpdate(localPosition.value, layerPosition, modelTransform.localToRenderLayerDimensions);
        } else {
            globalPosition.value.set(layerPosition);
            // localPosition.value.set(layerPosition);
        }
        localPosition.changed.dispatch();
        globalPosition.changed.dispatch();
    }
}
UserLayer.supportsPickOption = false;
function dataSourcesToJson(sources) {
    if (sources.length === 0) return undefined;
    if (sources.length === 1) return sources[0].toJSON();
    return sources.map(x => x.toJSON());
}
export class ManagedUserLayer extends RefCounted {
    /**
     * If layer is not null, tranfers ownership of a reference.
     */
    constructor(name, manager) {
        super();
        this.manager = manager;
        this.localCoordinateSpace = new TrackableCoordinateSpace();
        this.localCoordinateSpaceCombiner = new CoordinateSpaceCombiner(this.localCoordinateSpace, isLocalDimension);
        this.localPosition = this.registerDisposer(new Position(this.localCoordinateSpace));
        // Index of layer within root layer manager, counting only non-archived layers.  This is the layer
        // number shown in the layer bar and layer list panel.
        this.nonArchivedLayerIndex = -1;
        this.readyStateChanged = new NullarySignal();
        this.layerChanged = new NullarySignal();
        this.specificationChanged = new NullarySignal();
        this.containers = new _Set();
        this.layer_ = null;
        this.visible = true;
        this.archived = false;
        this.name_ = name;
    }
    get layer() {
        return this.layer_;
    }
    /**
     * If layer is not null, tranfers ownership of a reference.
     */
    set layer(layer) {
        let oldLayer = this.layer_;
        if (oldLayer != null) {
            this.unregisterUserLayer();
            oldLayer.dispose();
        }
        this.layer_ = layer;
        if (layer != null) {
            const removers = [layer.layersChanged.add(this.layerChanged.dispatch), layer.readyStateChanged.add(this.readyStateChanged.dispatch), layer.specificationChanged.add(this.specificationChanged.dispatch)];
            this.unregisterUserLayer = () => {
                removers.forEach(x => x());
            };
            this.readyStateChanged.dispatch();
            this.layerChanged.dispatch();
        }
    }
    isReady() {
        const layer = this.layer;

        return layer !== null && layer.isReady;
    }
    get name() {
        return this.name_;
    }
    set name(value) {
        if (value !== this.name_) {
            this.name_ = value;
            this.layerChanged.dispatch();
        }
    }
    get supportsPickOption() {
        const userLayer = this.layer;
        return userLayer !== null && userLayer.constructor.supportsPickOption;
    }
    get pickEnabled() {
        const userLayer = this.layer;
        return userLayer !== null && userLayer.constructor.supportsPickOption && userLayer.pick.value;
    }
    set pickEnabled(value) {
        const userLayer = this.layer;
        if (userLayer !== null && userLayer.constructor.supportsPickOption) {
            userLayer.pick.value = value;
        }
    }
    toJSON() {
        let userLayer = this.layer;
        if (userLayer === null) {
            return undefined;
        }
        let layerSpec = userLayer.toJSON();
        layerSpec.name = this.name;
        if (!this.visible) {
            if (this.archived) {
                layerSpec['archived'] = true;
            } else {
                layerSpec['visible'] = false;
            }
        }
        return layerSpec;
    }
    setVisible(value) {
        if (value === this.visible) return;
        if (value && this.archived) {
            this.visible = true;
            this.setArchived(false);
            return;
        }
        this.visible = value;
        this.layerChanged.dispatch();
    }
    setArchived(value) {
        if (this.archived === value) return;
        if (value === true) {
            this.visible = false;
            this.archived = true;
            for (const _ref of this.manager.root.subsets) {
                const layerManager = _ref.layerManager;

                if (!layerManager.has(this)) continue;
                layerManager.removeManagedLayer(this);
            }
        } else {
            for (const _ref2 of this.manager.root.subsets) {
                const layerManager = _ref2.layerManager;

                if (layerManager.has(this)) continue;
                layerManager.addManagedLayer(this.addRef());
            }
            this.archived = false;
        }
        this.layerChanged.dispatch();
    }
    disposed() {
        this.layer = null;
        super.disposed();
    }
}
export class LayerManager extends RefCounted {
    constructor() {
        super();
        this.managedLayers = new Array();
        this.layerSet = new _Set();
        this.layersChanged = new NullarySignal();
        this.readyStateChanged = new NullarySignal();
        this.specificationChanged = new NullarySignal();
        this.boundPositions = new _WeakSet();
        this.numDirectUsers = 0;
        this.nonArchivedLayerIndexGeneration = -1;
        this.renderLayerToManagedLayerMapGeneration = -1;
        this.renderLayerToManagedLayerMap_ = new _Map();
        this.scheduleRemoveLayersWithSingleRef = this.registerCancellable(debounce(() => this.removeLayersWithSingleRef(), 0));
        this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef);
    }
    updateNonArchivedLayerIndices() {
        const generation = this.layersChanged.count;
        if (generation === this.nonArchivedLayerIndexGeneration) return;
        this.nonArchivedLayerIndexGeneration = generation;
        let index = 0;
        for (const layer of this.managedLayers) {
            if (!layer.archived) {
                layer.nonArchivedLayerIndex = index++;
            }
        }
        for (const layer of this.managedLayers) {
            if (layer.archived) {
                layer.nonArchivedLayerIndex = index++;
            }
        }
    }
    getLayerByNonArchivedIndex(index) {
        let i = 0;
        for (const layer of this.managedLayers) {
            if (!layer.archived) {
                if (i === index) return layer;
                ++i;
            }
        }
        return undefined;
    }
    get renderLayerToManagedLayerMap() {
        const generation = this.layersChanged.count;
        const map = this.renderLayerToManagedLayerMap_;
        if (this.renderLayerToManagedLayerMapGeneration !== generation) {
            this.renderLayerToManagedLayerMapGeneration = generation;
            map.clear();
            for (const managedLayer of this.managedLayers) {
                const userLayer = managedLayer.layer;
                if (userLayer !== null) {
                    for (const renderLayer of userLayer.renderLayers) {
                        map.set(renderLayer, managedLayer);
                    }
                }
            }
        }
        return map;
    }
    filter(predicate) {
        let changed = false;
        this.managedLayers = this.managedLayers.filter(layer => {
            if (!predicate(layer)) {
                this.unbindManagedLayer(layer);
                this.layerSet.delete(layer);
                changed = true;
                return false;
            }
            return true;
        });
        if (changed) {
            this.layersChanged.dispatch();
        }
    }
    removeLayersWithSingleRef() {
        if (this.numDirectUsers > 0) {
            return;
        }
        this.filter(layer => layer.refCount !== 1 || layer.archived);
    }
    updateSignalBindings(layer, callback) {
        callback(layer.layerChanged, this.layersChanged.dispatch);
        callback(layer.readyStateChanged, this.readyStateChanged.dispatch);
        callback(layer.specificationChanged, this.specificationChanged.dispatch);
    }
    useDirectly() {
        if (++this.numDirectUsers === 1) {
            this.layersChanged.remove(this.scheduleRemoveLayersWithSingleRef);
        }
        return () => {
            if (--this.numDirectUsers === 0) {
                this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef);
                this.scheduleRemoveLayersWithSingleRef();
            }
        };
    }
    /**
     * Assumes ownership of an existing reference to managedLayer.
     */
    addManagedLayer(managedLayer, index) {
        this.updateSignalBindings(managedLayer, addSignalBinding);
        this.layerSet.add(managedLayer);
        managedLayer.containers.add(this);
        if (index === undefined) {
            index = this.managedLayers.length;
        }
        this.managedLayers.splice(index, 0, managedLayer);
        this.layersChanged.dispatch();
        this.readyStateChanged.dispatch();
        return managedLayer;
    }
    *readyRenderLayers() {
        for (let managedUserLayer of this.managedLayers) {
            if (!managedUserLayer.visible || !managedUserLayer.layer) {
                continue;
            }
            yield* managedUserLayer.layer.renderLayers;
        }
    }
    unbindManagedLayer(managedLayer) {
        this.updateSignalBindings(managedLayer, removeSignalBinding);
        managedLayer.containers.delete(this);
        // Also notify the root LayerManager, to ensures the layer is removed if this is the last direct
        // reference.
        managedLayer.manager.rootLayers.layersChanged.dispatch();
        managedLayer.dispose();
    }
    clear() {
        for (let managedLayer of this.managedLayers) {
            this.unbindManagedLayer(managedLayer);
        }
        this.managedLayers.length = 0;
        this.layerSet.clear();
        this.layersChanged.dispatch();
    }
    remove(index) {
        const layer = this.managedLayers[index];
        this.unbindManagedLayer(layer);
        this.managedLayers.splice(index, 1);
        this.layerSet.delete(layer);
        this.layersChanged.dispatch();
    }
    removeManagedLayer(managedLayer) {
        let index = this.managedLayers.indexOf(managedLayer);
        if (index === -1) {
            throw new Error(`Internal error: invalid managed layer.`);
        }
        this.remove(index);
    }
    reorderManagedLayer(oldIndex, newIndex) {
        const numLayers = this.managedLayers.length;
        if (oldIndex === newIndex || oldIndex < 0 || oldIndex >= numLayers || newIndex < 0 || newIndex >= numLayers) {
            // Don't do anything.
            return;
        }

        var _managedLayers$splice = this.managedLayers.splice(oldIndex, 1),
            _managedLayers$splice2 = _slicedToArray(_managedLayers$splice, 1);

        let oldLayer = _managedLayers$splice2[0];

        this.managedLayers.splice(newIndex, 0, oldLayer);
        this.layersChanged.dispatch();
    }
    disposed() {
        this.clear();
        super.disposed();
    }
    getLayerByName(name) {
        return this.managedLayers.find(x => x.name === name);
    }
    getUniqueLayerName(name) {
        let suggestedName = name;
        let suffix = 0;
        while (this.getLayerByName(suggestedName) !== undefined) {
            suggestedName = name + ++suffix;
        }
        return suggestedName;
    }
    has(layer) {
        return this.layerSet.has(layer);
    }
    get renderLayers() {
        let layerManager = this;
        return {
            *[_Symbol$iterator]() {
                for (let managedLayer of layerManager.managedLayers) {
                    if (managedLayer.layer === null) {
                        continue;
                    }
                    for (let renderLayer of managedLayer.layer.renderLayers) {
                        yield renderLayer;
                    }
                }
            }
        };
    }
    get visibleRenderLayers() {
        let layerManager = this;
        return {
            *[_Symbol$iterator]() {
                for (let managedLayer of layerManager.managedLayers) {
                    if (managedLayer.layer === null || !managedLayer.visible) {
                        continue;
                    }
                    for (let renderLayer of managedLayer.layer.renderLayers) {
                        yield renderLayer;
                    }
                }
            }
        };
    }
    invokeAction(action, appliedLayer) {
        const context = new LayerActionContext();
        for (let managedLayer of this.managedLayers) {
            if (managedLayer.layer === null || !managedLayer.visible) {
                continue;
            }
            if (appliedLayer !== undefined && managedLayer !== appliedLayer) {
                continue;
            }
            let userLayer = managedLayer.layer;
            userLayer.handleAction(action, context);
            for (let renderLayer of userLayer.renderLayers) {
                renderLayer.handleAction(action);
            }
        }
        for (const callback of context.callbacks) {
            callback();
        }
    }
}
export class MouseSelectionState {
    constructor() {
        this.changed = new NullarySignal();
        this.coordinateSpace = emptyInvalidCoordinateSpace;
        this.position = kEmptyFloat32Vec;
        this.unsnappedPosition = kEmptyFloat32Vec;
        this.active = false;
        this.displayDimensions = undefined;
        this.pickedRenderLayer = null;
        this.pickedValue = new Uint64(0, 0);
        this.pickedOffset = 0;
        this.pickedAnnotationLayer = undefined;
        this.pickedAnnotationId = undefined;
        this.pickedAnnotationBuffer = undefined;
        // Base offset into `pickedAnnotationBuffer` of the `pickedAnnotationCount` serialized annotations
        // of `pickedAnnotationType`.
        this.pickedAnnotationBufferBaseOffset = undefined;
        // Index (out of a total of `pickedAnnotationCount`) of the picked annotation.
        this.pickedAnnotationIndex = undefined;
        this.pickedAnnotationCount = undefined;
        this.pickedAnnotationType = undefined;
        this.forcerFunction = undefined;
    }
    removeForcer(forcer) {
        if (forcer === this.forcerFunction) {
            this.forcerFunction = undefined;
            this.setActive(false);
        }
    }
    setForcer(forcer) {
        this.forcerFunction = forcer;
        if (forcer === undefined) {
            this.setActive(false);
        }
    }
    updateUnconditionally() {
        const forcerFunction = this.forcerFunction;

        if (forcerFunction === undefined) {
            return false;
        }
        forcerFunction();
        return this.active;
    }
    setActive(value) {
        if (this.active !== value || value === true) {
            this.active = value;
            this.changed.dispatch();
        }
    }
}
export class LayerSelectedValues extends RefCounted {
    constructor(layerManager, mouseState) {
        super();
        this.layerManager = layerManager;
        this.mouseState = mouseState;
        this.changed = new NullarySignal();
        this.needsUpdate = true;
        this.registerDisposer(mouseState.changed.add(() => {
            this.handleChange();
        }));
        this.registerDisposer(layerManager.layersChanged.add(() => {
            this.handleLayerChange();
        }));
    }
    /**
     * This should be called when the layer data may have changed, due to the set of managed layers
     * changing or new data having been received.
     */
    handleLayerChange() {
        if (this.mouseState.active) {
            this.handleChange();
        }
    }
    handleChange() {
        this.needsUpdate = true;
        this.changed.dispatch();
    }
    update() {
        if (!this.needsUpdate) {
            return;
        }
        this.needsUpdate = false;
        let mouseState = this.mouseState;
        const generation = this.changed.count;
        if (mouseState.active) {
            for (const layer of this.layerManager.managedLayers) {
                const userLayer = layer.layer;
                if (layer.visible && userLayer !== null) {
                    const selectionState = userLayer.selectionState;

                    if (selectionState) {
                        userLayer.resetSelectionState(selectionState);
                        selectionState.generation = generation;
                        userLayer.captureSelectionState(selectionState, mouseState);
                    }
                }
            }
        }
    }
    get(userLayer) {
        this.update();
        const selectionState = userLayer.selectionState;

        if (selectionState && selectionState.generation !== this.changed.count) return undefined;
        return selectionState;
    }
    toJSON() {
        this.update();
        const result = {};
        for (const layer of this.layerManager.managedLayers) {
            const userLayer = layer.layer;
            if (userLayer) {
                const state = this.get(userLayer);
                if (state !== undefined) {
                    result[layer.name] = userLayer.selectionStateToJson(state, true);
                }
            }
        }
        return result;
    }
}
const maxSelectionHistorySize = 10;
const DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION = _Object$assign(_Object$assign({}, DEFAULT_SIDE_PANEL_LOCATION), { minSize: 150, row: 1 });
const DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION_VISIBLE = _Object$assign(_Object$assign({}, DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION), { visible: true });
export class TrackableDataSelectionState extends RefCounted {
    constructor(coordinateSpace, layerSelectedValues) {
        super();
        this.coordinateSpace = coordinateSpace;
        this.layerSelectedValues = layerSelectedValues;
        this.changed = new NullarySignal();
        this.history = [];
        this.historyIndex = 0;
        this.location = new TrackableSidePanelLocation(DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION);
        this.pin = new WatchableValue(true);
        this.registerDisposer(registerNested((context, pin) => {
            if (pin) return;
            this.capture(true);
            context.registerDisposer(layerSelectedValues.changed.add(context.registerCancellable(throttle(() => this.capture(true), 100, { leading: true, trailing: true }))));
        }, this.pin));
        this.pin.changed.add(this.changed.dispatch);
        this.location.changed.add(this.changed.dispatch);
    }
    get value() {
        return this.value_;
    }
    goBack() {
        const curIndex = this.pin.value ? this.historyIndex : this.history.length;
        if (curIndex > 0) {
            this.historyIndex = curIndex - 1;
            this.value_ = this.history[curIndex - 1];
            this.pin.value = true;
            this.changed.dispatch();
        }
    }
    canGoBack() {
        const curIndex = this.pin.value ? this.historyIndex : this.history.length;
        return curIndex > 0;
    }
    canGoForward() {
        if (!this.pin.value) return false;
        const curIndex = this.historyIndex;
        return curIndex + 1 < this.history.length;
    }
    goForward() {
        if (!this.pin.value) return;
        const curIndex = this.historyIndex;
        if (curIndex + 1 < this.history.length) {
            this.historyIndex = curIndex + 1;
            this.value_ = this.history[curIndex + 1];
            this.changed.dispatch();
        }
    }
    set value(value) {
        if (value !== this.value_) {
            this.value_ = value;
            if (value !== undefined && this.pin.value) {
                // Add to history
                const history = this.history;

                history.length = Math.min(history.length, this.historyIndex + 1);
                history.push(value);
                if (history.length > maxSelectionHistorySize) {
                    history.splice(0, history.length - maxSelectionHistorySize);
                }
                this.historyIndex = history.length - 1;
            }
            this.changed.dispatch();
        }
    }
    captureSingleLayerState(userLayer, capture, pin = true, forceShowingPanel = true) {
        if (pin === false && (!this.location.visible || this.pin.value)) return;
        const state = {};
        userLayer.initializeSelectionState(state);
        if (capture(state)) {
            if (forceShowingPanel) {
                this.location.visible = true;
            }
            if (pin === true) {
                this.pin.value = true;
            } else if (pin === 'toggle') {
                this.pin.value = !this.pin.value;
            }
            this.value = {
                layers: [{ layer: userLayer, state }],
                coordinateSpace: this.coordinateSpace.value,
                position: undefined
            };
        }
    }
    reset() {
        this.location.reset();
        this.pin.value = false;
        this.value = undefined;
    }
    toJSON() {
        // Default panel configuration, not visible: -> undefined
        // Default panel configuration, visible: -> {}
        // Non-default panel configuration, not visible: -> {side: 'left', ..., visible: false}}
        // Non-default panel configuration, visible: -> {side: 'left', ...}
        const value = this.value;

        let obj;
        if (this.location.visible) {
            obj = this.location.toJSON(_Object$assign(_Object$assign({}, DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION_VISIBLE), { visible: !globalViewerConfig.expectingExternalUI }));
            if (this.pin.value && value !== undefined) {
                const layersJson = {};
                for (const layerData of value.layers) {
                    const layer = layerData.layer;

                    let data = layer.selectionStateToJson(layerData.state, false);
                    if (_Object$keys(data).length === 0) data = undefined;
                    layersJson[layerData.layer.managedLayer.name] = data;
                }
                if (value.position !== undefined) {
                    obj.position = _Array$from(value.position);
                }
                obj.layers = layersJson;
            }
        } else {
            obj = this.location.toJSON(DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION);
            obj = emptyToUndefined(obj);
            if (obj !== undefined) {
                obj.visible = false;
            }
        }
        return obj;
    }
    select(panelOn = true) {
        const pin = this.pin;

        if (panelOn) {
            this.location.visible = true;
        }
        pin.value = !pin.value;
        if (pin.value) {
            this.capture();
        }
    }
    capture(canRetain = false) {
        const newValue = capturePersistentViewerSelectionState(this.layerSelectedValues);
        if (canRetain && newValue === undefined) return;
        this.value = newValue;
    }
    restoreState(obj) {
        if (obj === undefined) {
            this.pin.value = true;
            this.value = undefined;
            return;
        }
        if (obj === null) {
            // Support for old representation where `null` means visible but unpinned.
            this.pin.value = false;
            this.location.visible = true;
            this.value = undefined;
            return;
        }
        verifyObject(obj);
        // If the object is present, then visible by default.
        this.location.restoreState(obj, _Object$assign(_Object$assign({}, DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION_VISIBLE), { visible: !globalViewerConfig.expectingExternalUI }));
        const coordinateSpace = this.coordinateSpace.value;
        const position = coordinateSpace.rank > 0 ? verifyOptionalObjectProperty(obj, 'position', positionObj => parseFixedLengthArray(new Float32Array(coordinateSpace.rank), positionObj, verifyFiniteFloat)) : undefined;
        const layers = [];
        verifyOptionalObjectProperty(obj, 'layers', layersObj => {
            verifyObject(layersObj);
            const layerManager = this.layerSelectedValues.layerManager;

            for (const _ref3 of _Object$entries(layersObj)) {
                var _ref4 = _slicedToArray(_ref3, 2);

                const name = _ref4[0];
                const entry = _ref4[1];

                const managedLayer = layerManager.getLayerByName(name);
                if (managedLayer === undefined) return;
                const layer = managedLayer.layer;
                if (layer === null) return;
                verifyObject(entry);
                const state = {};
                layer.initializeSelectionState(state);
                layer.selectionStateFromJson(state, entry);
                layers.push({ layer, state });
            }
        });
        this.pin.value = layers.length > 0 || position !== undefined;
        this.value = { position, coordinateSpace, layers };
    }
}
export function capturePersistentViewerSelectionState(layerSelectedValues) {
    const mouseState = layerSelectedValues.mouseState;

    if (!mouseState.active) return undefined;
    const layers = [];
    for (const layer of layerSelectedValues.layerManager.managedLayers) {
        const userLayer = layer.layer;
        if (userLayer === null) continue;
        const state = layerSelectedValues.get(userLayer);
        if (state === undefined) continue;
        const stateCopy = {};
        userLayer.initializeSelectionState(stateCopy);
        userLayer.copySelectionState(stateCopy, state);
        layers.push({
            layer: userLayer,
            state: stateCopy
        });
    }
    return {
        position: mouseState.position.slice(),
        coordinateSpace: mouseState.coordinateSpace,
        layers
    };
}
export class VisibleLayerInfo extends RefCounted {
    constructor(view) {
        super();
        this.view = view;
        this.messages = new MessageList();
        this.seenGeneration = -1;
        this.state = undefined;
    }
}
let visibleLayerInfoGeneration = 0;
export class VisibleRenderLayerTracker extends RefCounted {
    constructor(layerManager, renderLayerType, view, roles, layerAdded, visibility) {
        super();
        this.layerManager = layerManager;
        this.renderLayerType = renderLayerType;
        this.view = view;
        this.roles = roles;
        this.layerAdded = layerAdded;
        this.visibility = visibility;
        /**
         * Maps a layer to the disposer to call when it is no longer visible.
         */
        this.visibleLayers_ = new _Map();
        this.debouncedUpdateVisibleLayers = this.registerCancellable(debounce(() => this.updateVisibleLayers(), 0));
        this.registerDisposer(layerManager.layersChanged.add(this.debouncedUpdateVisibleLayers));
        this.registerDisposer(roles.changed.add(this.debouncedUpdateVisibleLayers));
        this.updateVisibleLayers();
    }
    disposed() {
        this.visibleLayers.forEach(attachment => attachment.dispose());
        this.visibleLayers.clear();
        super.disposed();
    }
    updateVisibleLayers() {
        const curGeneration = ++visibleLayerInfoGeneration;
        const visibleLayers = this.visibleLayers_,
              renderLayerType = this.renderLayerType,
              layerAdded = this.layerAdded,
              roles = this.roles;

        for (let renderLayer of this.layerManager.readyRenderLayers()) {
            if (renderLayer instanceof renderLayerType && roles.has(renderLayer.role)) {
                let typedLayer = renderLayer;
                let info = visibleLayers.get(typedLayer);
                if (info === undefined) {
                    info = new VisibleLayerInfo(this.view);
                    info.registerDisposer(typedLayer.messages.addChild(info.messages));
                    info.registerDisposer(typedLayer.addRef());
                    info.registerDisposer(typedLayer.visibility.add(this.visibility));
                    visibleLayers.set(typedLayer, info);
                    layerAdded(typedLayer, info);
                    typedLayer.attach(info);
                }
                info.seenGeneration = curGeneration;
            }
        }
        for (const _ref5 of visibleLayers) {
            var _ref6 = _slicedToArray(_ref5, 2);

            const renderLayer = _ref6[0];
            const info = _ref6[1];

            if (info.seenGeneration !== curGeneration) {
                visibleLayers.delete(renderLayer);
                info.dispose();
            }
        }
    }
    get visibleLayers() {
        this.debouncedUpdateVisibleLayers.flush();
        return this.visibleLayers_;
    }
}
export function makeRenderedPanelVisibleLayerTracker(layerManager, renderLayerType, roles, panel, layerAdded) {
    return panel.registerDisposer(new VisibleRenderLayerTracker(layerManager, renderLayerType, panel, roles, (layer, info) => {
        info.registerDisposer(layer.redrawNeeded.add(() => panel.scheduleRedraw()));
        const backend = layer.backend;

        if (backend) {
            backend.rpc.invoke(RENDERED_VIEW_ADD_LAYER_RPC_ID, { layer: backend.rpcId, view: panel.rpcId });
            info.registerDisposer(() => backend.rpc.invoke(RENDERED_VIEW_REMOVE_LAYER_RPC_ID, { layer: backend.rpcId, view: panel.rpcId }));
        }
        if (layerAdded !== undefined) {
            layerAdded(layer, info);
        }
        panel.scheduleRedraw();
        info.registerDisposer(() => panel.scheduleRedraw());
    }, panel.visibility));
}
export class SelectedLayerState extends RefCounted {
    constructor(layerManager) {
        super();
        this.layerManager = layerManager;
        this.changed = new NullarySignal();
        this.location = new TrackableSidePanelLocation(SELECTED_LAYER_SIDE_PANEL_DEFAULT_LOCATION);
        this.registerDisposer(layerManager);
        this.location.changed.add(() => {
            var _a, _b;
            this.changed.dispatch();
            const userLayer = (_b = (_a = this.layer) === null || _a === void 0 ? void 0 : _a.layer) !== null && _b !== void 0 ? _b : undefined;
            if (userLayer !== undefined) {
                const curLocation = this.location.value;
                if (curLocation.visible) {
                    const panel = userLayer.panels.panels[0];
                    if (panel.location.value !== curLocation) {
                        panel.location.value = curLocation;
                        panel.location.locationChanged.dispatch();
                    }
                }
            }
        });
    }
    get layer() {
        return this.layer_;
    }
    get visible() {
        return this.location.visible;
    }
    toggle(layer) {
        if (this.layer === layer && this.visible) {
            this.visible = false;
        } else {
            this.layer = layer;
            this.visible = true;
        }
    }
    set visible(value) {
        let existingLayer = this.layer_;
        if (value === true && existingLayer === undefined) {
            // Check if there is a layer
            const managedLayers = this.layerManager.managedLayers;

            if (managedLayers.length > 0) {
                existingLayer = this.layer = managedLayers[0];
            } else {
                value = false;
            }
        }
        if (value === true && existingLayer !== undefined) {
            const userLayer = existingLayer.layer;
            if (userLayer === null || userLayer.panels.panels[0].tabs.length === 0) {
                value = false;
            }
        }
        if (this.visible !== value) {
            this.location.visible = value;
            if (!value && existingLayer !== undefined) {
                this.maybeDeleteNewLayer(existingLayer);
            }
            this.changed.dispatch();
        }
    }
    maybeDeleteNewLayer(existingLayer) {
        if (existingLayer.wasDisposed) return;
        const userLayer = existingLayer.layer;
        if (userLayer !== null && userLayer instanceof NewUserLayer) {
            if (!userLayer.dataSources.some(x => x.spec.url.length !== 0)) {
                deleteLayer(existingLayer);
            }
        }
    }
    set layer(layer) {
        if (layer === this.layer_) {
            return;
        }
        const existingLayer = this.layer_;
        if (existingLayer !== undefined) {
            this.existingLayerDisposer();
            this.existingLayerDisposer = undefined;
            this.maybeDeleteNewLayer(existingLayer);
        }
        this.layer_ = layer;
        if (layer !== undefined) {
            const layerDisposed = () => {
                this.layer_ = undefined;
                this.visible = false;
                this.existingLayerDisposer = undefined;
                this.changed.dispatch();
            };
            layer.registerDisposer(layerDisposed);
            const layerChangedDisposer = layer.specificationChanged.add(() => {
                this.changed.dispatch();
            });
            this.existingLayerDisposer = () => {
                const userLayer = layer.layer;
                if (userLayer !== null) {
                    const tool = userLayer.tool.value;
                    if (tool !== undefined) {
                        tool.deactivate();
                    }
                }
                layer.unregisterDisposer(layerDisposed);
                layerChangedDisposer();
            };
        } else {
            this.location.visible = false;
        }
        this.changed.dispatch();
    }
    toJSON() {
        const obj = this.location.toJSON();
        if (this.layer !== undefined) {
            obj.layer = this.layer.name;
        }
        return emptyToUndefined(obj);
    }
    restoreState(obj) {
        if (obj === undefined) {
            this.reset();
            return;
        }
        verifyObject(obj);
        this.location.restoreState(obj);
        const layerName = verifyObjectProperty(obj, 'layer', verifyOptionalString);
        const layer = layerName !== undefined ? this.layerManager.getLayerByName(layerName) : undefined;
        if (layer === undefined) {
            this.visible = false;
        }
        this.layer = layer;
    }
    reset() {
        this.location.reset();
        this.layer = undefined;
    }
}
export class LayerReference extends RefCounted {
    constructor(layerManager, filter) {
        super();
        this.layerManager = layerManager;
        this.filter = filter;
        this.changed = new NullarySignal();
        this.validate = debounce(() => {
            const layerName_ = this.layerName_;

            if (layerName_ !== undefined) {
                const layer = this.layerManager.getLayerByName(layerName_);
                if (layer !== undefined && this.filter(layer)) {
                    this.layer_ = layer;
                    this.changed.dispatch();
                } else {
                    this.layer_ = undefined;
                    this.layerName_ = undefined;
                    this.changed.dispatch();
                }
            }
        }, 0);
        this.registerDisposer(layerManager);
        this.registerDisposer(layerManager.specificationChanged.add(() => {
            const layer_ = this.layer_;

            if (layer_ !== undefined) {
                if (!this.layerManager.layerSet.has(layer_) || !this.filter(layer_)) {
                    this.layer_ = undefined;
                    this.layerName_ = undefined;
                    this.changed.dispatch();
                } else {
                    const name = layer_.name;

                    if (name !== this.layerName_) {
                        this.layerName_ = name;
                        this.changed.dispatch();
                    }
                }
            }
        }));
    }
    get layer() {
        return this.layer_;
    }
    get layerName() {
        return this.layerName_;
    }
    set layer(value) {
        if (this.layer_ === value) {
            return;
        }
        if (value !== undefined && this.layerManager.layerSet.has(value) && this.filter(value)) {
            this.layer_ = value;
            this.layerName_ = value.name;
        } else {
            this.layer_ = undefined;
            this.layerName_ = undefined;
        }
        this.changed.dispatch();
    }
    set layerName(value) {
        if (value === this.layerName_) {
            return;
        }
        this.layer_ = undefined;
        this.layerName_ = value;
        this.changed.dispatch();
        this.validate();
    }
    restoreState(obj) {
        const layerName = verifyOptionalString(obj);
        this.layerName = layerName;
    }
    toJSON() {
        const layer_ = this.layer_;

        if (layer_ !== undefined) {
            return layer_.name;
        }
        return this.layerName_;
    }
    reset() {
        this.layerName_ = undefined;
        this.layer_ = undefined;
        this.changed.dispatch();
    }
}
// Group of layers that share a set of properties, e.g. visible segment set.
export class LinkedLayerGroup extends RefCounted {
    constructor(layerManager, layer, predicate, getGroup) {
        super();
        this.layerManager = layerManager;
        this.layer = layer;
        this.predicate = predicate;
        this.getGroup = getGroup;
        // Only valid if `root_ == this.layer`.
        this.linkedLayers_ = new _Set();
        this.changed = new NullarySignal();
        this.linkedLayersChanged = new NullarySignal();
        this.root_ = layer;
        const self = this;
        this.root = {
            get value() {
                return self.root_;
            },
            changed: self.changed
        };
    }
    get linkedLayers() {
        return this.linkedLayers_;
    }
    get rootGroup() {
        return this.getGroup(this.root.value);
    }
    reset() {
        this.isolate();
    }
    restoreState(obj) {
        if (obj === undefined) return;
        const name = verifyString(obj);
        this.linkByName(name);
    }
    toJSON() {
        const root = this.root.value;

        if (root === this.layer) return undefined;
        return root.managedLayer.name;
    }
    isolate(notifyChanged = true) {
        const getGroup = this.getGroup,
              layer = this.layer,
              root = this.root_;

        if (root === layer) {
            const linkedLayers_ = this.linkedLayers_;

            if (linkedLayers_.size !== 0) {
                for (const otherLayer of linkedLayers_) {
                    const otherGroup = getGroup(otherLayer);
                    otherGroup.root_ = otherLayer;
                    otherGroup.changed.dispatch();
                }
                linkedLayers_.clear();
                this.linkedLayersChanged.dispatch();
            }
            return;
        }
        const rootGroup = getGroup(root);
        rootGroup.linkedLayers_.delete(layer);
        rootGroup.linkedLayersChanged.dispatch();
        this.root_ = layer;
        if (notifyChanged) {
            this.changed.dispatch();
        }
    }
    linkByName(otherLayerName) {
        const layer = this.layer;
        const managedLayer = layer.managedLayer;
        const layerManager = this.layerManager;

        const otherLayer = layerManager.getLayerByName(otherLayerName);
        if (otherLayer === undefined) return;
        if (otherLayer === managedLayer) return;
        const otherUserLayer = otherLayer.layer;
        if (otherUserLayer === null) return;
        if (!this.predicate(otherUserLayer)) return;
        this.linkToLayer(otherUserLayer);
    }
    linkToLayer(otherUserLayer) {
        if (otherUserLayer === this.layer) return;
        if (this.root_ === otherUserLayer) return;
        if (this.root_ !== this.layer) {
            this.isolate( /*notifyChanged=*/false);
        }
        const getGroup = this.getGroup;

        const newRoot = getGroup(otherUserLayer).root_;
        if (newRoot === this.layer) return;
        const rootGroup = getGroup(newRoot);
        rootGroup.linkedLayers_.add(this.layer);
        rootGroup.linkedLayersChanged.dispatch();
        this.root_ = newRoot;
        this.changed.dispatch();
    }
    disposed() {
        this.isolate( /*notifyChanged=*/false);
    }
}
function initializeLayerFromSpecNoRestoreState(managedLayer, spec) {
    const layerType = verifyOptionalObjectProperty(spec, 'type', verifyString, 'auto');
    managedLayer.archived = verifyOptionalObjectProperty(spec, 'archived', verifyBoolean, false);
    if (!managedLayer.archived) {
        managedLayer.visible = verifyOptionalObjectProperty(spec, 'visible', verifyBoolean, true);
    } else {
        managedLayer.visible = false;
    }
    const layerConstructor = layerTypes.get(layerType) || NewUserLayer;
    managedLayer.layer = new layerConstructor(managedLayer);
    return spec;
}
function completeUserLayerInitialization(managedLayer, spec) {
    try {
        const userLayer = managedLayer.layer;
        if (userLayer === null) return;
        userLayer.restoreState(spec);
        userLayer.initializationDone();
    } catch (e) {
        deleteLayer(managedLayer);
        throw e;
    }
}
export function initializeLayerFromSpec(managedLayer, spec) {
    try {
        verifyObject(spec);
        initializeLayerFromSpecNoRestoreState(managedLayer, spec);
        completeUserLayerInitialization(managedLayer, spec);
    } catch (e) {
        deleteLayer(managedLayer);
        throw e;
    }
}
export function initializeLayerFromSpecShowErrorStatus(managedLayer, spec) {
    try {
        initializeLayerFromSpec(managedLayer, spec);
    } catch (e) {
        const msg = new StatusMessage();
        msg.setErrorMessage(e instanceof Error ? e.message : '' + e);
    }
}
export function makeLayer(manager, name, spec) {
    const managedLayer = new ManagedUserLayer(name, manager);
    initializeLayerFromSpec(managedLayer, spec);
    return managedLayer;
}
export class LayerListSpecification extends RefCounted {
    constructor() {
        super(...arguments);
        this.changed = new NullarySignal();
    }
}
export class TopLevelLayerListSpecification extends LayerListSpecification {
    constructor(display, dataSourceProviderRegistry, layerManager, chunkManager, selectionState, selectedLayer, coordinateSpace, globalPosition, toolBinder) {
        super();
        this.display = display;
        this.dataSourceProviderRegistry = dataSourceProviderRegistry;
        this.layerManager = layerManager;
        this.chunkManager = chunkManager;
        this.selectionState = selectionState;
        this.selectedLayer = selectedLayer;
        this.coordinateSpace = coordinateSpace;
        this.globalPosition = globalPosition;
        this.toolBinder = toolBinder;
        this.coordinateSpaceCombiner = new CoordinateSpaceCombiner(this.coordinateSpace, isGlobalDimension);
        this.subsets = new _Set();
        this.layerSelectedValues = this.selectionState.layerSelectedValues;
        this.registerDisposer(layerManager.layersChanged.add(this.changed.dispatch));
        this.registerDisposer(layerManager.specificationChanged.add(this.changed.dispatch));
    }
    get rpc() {
        return this.chunkManager.rpc;
    }
    get root() {
        return this;
    }
    reset() {
        this.layerManager.clear();
    }
    restoreState(x) {
        this.layerManager.clear();
        let layerSpecs;
        if (!Array.isArray(x)) {
            verifyObject(x);
            layerSpecs = _Object$entries(x).map(([name, layerSpec]) => {
                if (typeof layerSpec === 'string') {
                    return { name, source: layerSpec };
                } else {
                    verifyObject(layerSpec);
                    return _Object$assign(_Object$assign({}, layerSpec), { name });
                }
            });
        } else {
            layerSpecs = x;
        }
        const layersToRestore = [];
        for (const layerSpec of layerSpecs) {
            verifyObject(layerSpec);
            const name = this.layerManager.getUniqueLayerName(verifyObjectProperty(layerSpec, 'name', verifyString));
            const managedLayer = new ManagedUserLayer(name, this);
            try {
                initializeLayerFromSpecNoRestoreState(managedLayer, layerSpec);
                this.layerManager.addManagedLayer(managedLayer);
                layersToRestore.push({ managedLayer, spec: layerSpec });
            } catch (e) {
                managedLayer.dispose();
                const msg = new StatusMessage();
                msg.setErrorMessage(`Error creating layer ${_JSON$stringify(name)}: ` + (e instanceof Error) ? e.message : '' + e);
            }
        }
        for (const _ref7 of layersToRestore) {
            const managedLayer = _ref7.managedLayer;
            const spec = _ref7.spec;

            try {
                completeUserLayerInitialization(managedLayer, spec);
            } catch (e) {
                const msg = new StatusMessage();
                msg.setErrorMessage(`Error creating layer ${_JSON$stringify(name)}: ` + (e instanceof Error) ? e.message : '' + e);
            }
        }
    }
    add(layer, index) {
        if (this.layerManager.managedLayers.indexOf(layer) === -1) {
            layer.name = this.layerManager.getUniqueLayerName(layer.name);
        }
        this.layerManager.addManagedLayer(layer, index);
    }
    toJSON() {
        const result = [];
        let numResults = 0;
        for (let managedLayer of this.layerManager.managedLayers) {
            const layerJson = managedLayer.toJSON();
            // A `null` layer specification is used to indicate a transient drag target, and should not be
            // serialized.
            if (layerJson != null) {
                result.push(layerJson);
                ++numResults;
            }
        }
        if (numResults === 0) {
            return undefined;
        }
        return result;
    }
    get rootLayers() {
        return this.layerManager;
    }
}
/**
 * Class for specifying a subset of a TopLevelLayerListsSpecification.
 */
export class LayerSubsetSpecification extends LayerListSpecification {
    constructor(master) {
        super();
        this.master = master;
        this.changed = new NullarySignal();
        this.layerManager = this.registerDisposer(new LayerManager());
        this.registerDisposer(master);
        const layerManager = this.layerManager;

        this.registerDisposer(layerManager.layersChanged.add(this.changed.dispatch));
        this.registerDisposer(layerManager.specificationChanged.add(this.changed.dispatch));
        master.subsets.add(this);
    }
    get rpc() {
        return this.master.rpc;
    }
    get dataSourceProviderRegistry() {
        return this.master.dataSourceProviderRegistry;
    }
    get chunkManager() {
        return this.master.chunkManager;
    }
    get layerSelectedValues() {
        return this.master.layerSelectedValues;
    }
    get root() {
        return this.master;
    }
    disposed() {
        super.disposed();
        this.master.subsets.delete(this);
    }
    reset() {
        this.layerManager.clear();
    }
    restoreState(x) {
        const masterLayerManager = this.master.layerManager;
        const layers = [];
        for (const name of new _Set(parseArray(x, verifyString))) {
            const layer = masterLayerManager.getLayerByName(name);
            if (layer === undefined) {
                throw new Error(`Undefined layer referenced in subset specification: ${_JSON$stringify(name)}`);
            }
            if (layer.archived) continue;
            layers.push(layer);
        }
        this.layerManager.clear();
        for (const layer of layers) {
            this.layerManager.addManagedLayer(layer.addRef());
        }
    }
    toJSON() {
        return this.layerManager.managedLayers.map(x => x.name);
    }
    add(layer, index) {
        if (this.master.layerManager.managedLayers.indexOf(layer) === -1) {
            layer.name = this.master.layerManager.getUniqueLayerName(layer.name);
            this.master.layerManager.addManagedLayer(layer.addRef());
        }
        this.layerManager.addManagedLayer(layer, index);
    }
    get rootLayers() {
        return this.master.rootLayers;
    }
}
export const layerTypes = new _Map();
const volumeLayerTypes = new _Map();
const layerTypeDetectors = [subsource => {
    const volume = subsource.volume;

    if (volume === undefined) return undefined;
    const layerConstructor = volumeLayerTypes.get(volume.volumeType);
    if (layerConstructor === undefined) return undefined;
    return { layerConstructor, priority: 0 };
}];
export function registerLayerType(layerConstructor, name = layerConstructor.type) {
    layerTypes.set(name, layerConstructor);
}
export function registerLayerTypeDetector(detector) {
    layerTypeDetectors.push(detector);
}
export function registerVolumeLayerType(volumeType, layerConstructor) {
    volumeLayerTypes.set(volumeType, layerConstructor);
}
export function changeLayerType(managedLayer, layerConstructor) {
    const userLayer = managedLayer.layer;
    if (userLayer === null) return;
    const spec = userLayer.toJSON();
    const newUserLayer = new layerConstructor(managedLayer);
    newUserLayer.restoreState(spec);
    newUserLayer.initializationDone();
    managedLayer.layer = newUserLayer;
}
export function changeLayerName(managedLayer, newName) {
    if (newName !== managedLayer.name) {
        newName = managedLayer.manager.root.layerManager.getUniqueLayerName(newName);
        managedLayer.name = newName;
        managedLayer.layerChanged.dispatch();
        return true;
    }
    return false;
}
export function deleteLayer(managedLayer) {
    if (managedLayer.wasDisposed) return;
    for (const layerManager of managedLayer.containers) {
        layerManager.removeManagedLayer(managedLayer);
    }
}
function getMaxPriorityGuess(a, b) {
    if (a === undefined) return b;
    if (b === undefined) return a;
    return a.priority < b.priority ? b : a;
}
export function detectLayerTypeFromDataSubsource(subsource) {
    let bestGuess;
    for (const detector of layerTypeDetectors) {
        bestGuess = getMaxPriorityGuess(bestGuess, detector(subsource));
    }
    const volume = subsource.volume;

    if (volume !== undefined) {
        const layerConstructor = volumeLayerTypes.get(volume.volumeType);
        if (layerConstructor !== undefined) {
            bestGuess = getMaxPriorityGuess(bestGuess, { layerConstructor, priority: 0 });
        }
    }
    return bestGuess;
}
export function detectLayerType(userLayer) {
    let guess;
    for (const dataSource of userLayer.dataSources) {
        const loadState = dataSource.loadState;

        if (loadState === undefined || loadState.error !== undefined) continue;
        for (const loadedSubsource of loadState.subsources) {
            const subsourceEntry = loadedSubsource.subsourceEntry;
            const subsource = subsourceEntry.subsource;

            if (!loadedSubsource.enabled) continue;
            guess = getMaxPriorityGuess(guess, detectLayerTypeFromDataSubsource(subsource));
        }
    }
    return guess === null || guess === void 0 ? void 0 : guess.layerConstructor;
}
function detectLayerTypeFromSubsources(subsources) {
    let guess;
    for (const loadedSubsource of subsources) {
        const subsourceEntry = loadedSubsource.subsourceEntry;
        const subsource = subsourceEntry.subsource;

        guess = getMaxPriorityGuess(guess, detectLayerTypeFromDataSubsource(subsource));
    }
    return guess;
}
/**
 * Special UserLayer type used when creating a new layer in the UI.
 */
export class NewUserLayer extends UserLayer {
    activateDataSubsources(subsources) {
        var _a;
        this.detectedLayerConstructor = (_a = detectLayerTypeFromSubsources(subsources)) === null || _a === void 0 ? void 0 : _a.layerConstructor;
    }
}
NewUserLayer.type = 'new';
NewUserLayer.typeAbbreviation = 'new';
/**
 * Special UserLayer type that automatically changes to the appropriate layer type.
 */
export class AutoUserLayer extends UserLayer {
    activateDataSubsources(subsources) {
        var _a;
        const layerConstructor = (_a = detectLayerTypeFromSubsources(subsources)) === null || _a === void 0 ? void 0 : _a.layerConstructor;
        if (layerConstructor !== undefined) {
            changeLayerType(this.managedLayer, layerConstructor);
        }
    }
}
AutoUserLayer.type = 'auto';
AutoUserLayer.typeAbbreviation = 'auto';
export function addNewLayer(manager, selectedLayer) {
    const layer = makeLayer(manager, 'new layer', { type: 'new' });
    manager.add(layer);
    selectedLayer.layer = layer;
    selectedLayer.visible = true;
}
registerLayerType(NewUserLayer);
registerLayerType(AutoUserLayer);
//# sourceMappingURL=layer.js.map