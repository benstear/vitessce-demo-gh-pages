import _Symbol$for from 'babel-runtime/core-js/symbol/for';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { NUM_ALTERNATIVES } from './hash_table';
import { DataType } from '../util/data_type';
import { RefCounted } from '../util/disposable';
import { glsl_equalUint64, glsl_uint64 } from '../webgl/shader_lib';
import { computeTextureFormat, OneDimensionalTextureAccessHelper, setOneDimensionalTextureData, TextureFormat } from '../webgl/texture_access';
// MumurHash, excluding the final mixing steps.
export const glsl_hashCombine = [glsl_uint64, `
highp uint hashCombine(highp uint state, highp uint value) {
  value *= 0xcc9e2d51u;
  value = (value << 15u) | (value >> 17u);
  value *= 0x1b873593u;
  state ^= value;
  state = (state << 13u) | (state >> 19u);
  state = (state * 5u) + 0xe6546b64u;
  return state;
}
highp uint hashCombine(highp uint state, uint64_t x) {
  state = hashCombine(state, x.value[0]);
  return hashCombine(state, x.value[1]);
}
`];
const textureFormat = computeTextureFormat(new TextureFormat(), DataType.UINT64, 1);
export class GPUHashTable extends RefCounted {
    constructor(gl, hashTable) {
        super();
        this.gl = gl;
        this.hashTable = hashTable;
        this.generation = -1;
        this.texture = null;
        // createTexture should never actually return null.
        this.texture = gl.createTexture();
    }
    copyToGPU() {
        let hashTable = this.hashTable;
        let generation = hashTable.generation;

        if (this.generation === generation) {
            return;
        }
        const gl = this.gl,
              texture = this.texture;

        this.generation = generation;
        gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + gl.tempTextureUnit);
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
        hashTable.tableWithMungedEmptyKey(table => {
            setOneDimensionalTextureData(this.gl, textureFormat, table);
        });
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
    }
    disposed() {
        let gl = this.gl;

        gl.deleteTexture(this.texture);
        this.texture = null;
        this.gl = undefined;
        this.hashTable = undefined;
        super.disposed();
    }
    static get(gl, hashTable) {
        return gl.memoize.get(hashTable, () => new this(gl, hashTable));
    }
}
export class HashSetShaderManager {
    constructor(prefix, numAlternatives = NUM_ALTERNATIVES) {
        this.prefix = prefix;
        this.numAlternatives = numAlternatives;
        this.textureUnitSymbol = _Symbol$for(`gpuhashtable:${this.prefix}`);
        this.accessHelper = new OneDimensionalTextureAccessHelper(`gpuhashtable_${this.prefix}`);
        this.samplerName = this.prefix + '_sampler';
        this.hashSeedsName = this.prefix + '_seeds';
        this.hashKeyMask = this.prefix + '_keyMask';
        this.readTable = this.prefix + '_readTable';
    }
    defineShader(builder) {
        let hashSeedsName = this.hashSeedsName,
            samplerName = this.samplerName,
            numAlternatives = this.numAlternatives,
            hashKeyMask = this.hashKeyMask;

        builder.addUniform('highp uint', hashSeedsName, numAlternatives);
        builder.addUniform('highp uint', hashKeyMask);
        builder.addTextureSampler('usampler2D', samplerName, this.textureUnitSymbol);
        builder.addFragmentCode(glsl_hashCombine);
        builder.addFragmentCode(glsl_uint64);
        builder.addFragmentCode(glsl_equalUint64);
        this.accessHelper.defineShader(builder);
        builder.addFragmentCode(this.accessHelper.getAccessor(this.readTable, this.samplerName, DataType.UINT64, 1));
        let s = '';
        s += `
bool ${this.hasFunctionName}(uint64_t x) {
`;
        for (let alt = 0; alt < numAlternatives; ++alt) {
            s += `
  {
    uint h = hashCombine(${hashSeedsName}[${alt}], x) & ${hashKeyMask};
    uint64_t key = ${this.readTable}(h);
    if (equals(key, x)) {
      return true;
    }
  }
`;
        }
        s += `
  return false;
}
`;
        builder.addFragmentCode(s);
    }
    get hasFunctionName() {
        return `${this.prefix}_has`;
    }
    enable(gl, shader, hashTable) {
        hashTable.copyToGPU();
        const textureUnit = shader.textureUnit(this.textureUnitSymbol);
        gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + textureUnit);
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, hashTable.texture);
        gl.uniform1ui(shader.uniform(this.hashKeyMask), hashTable.hashTable.tableSize - 1);
        gl.uniform1uiv(shader.uniform(this.hashSeedsName), hashTable.hashTable.hashSeeds);
    }
    disable(gl, shader) {
        const textureUnit = shader.textureUnit(this.textureUnitSymbol);
        gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + textureUnit);
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
    }
}
export class HashMapShaderManager extends HashSetShaderManager {
    defineShader(builder) {
        super.defineShader(builder);
        let numAlternatives = this.numAlternatives,
            hashSeedsName = this.hashSeedsName,
            hashKeyMask = this.hashKeyMask;

        let s = `
bool ${this.getFunctionName}(uint64_t x, out uint64_t value) {
`;
        for (let alt = 0; alt < numAlternatives; ++alt) {
            s += `
  {
    uint h = hashCombine(${hashSeedsName}[${alt}], x) & ${hashKeyMask};
    uint64_t key = ${this.readTable}(h * 2u);
    if (equals(key, x)) {
      value = ${this.readTable}(h * 2u + 1u);
      return true;
    }
  }
`;
        }
        s += `
  return false;
}
`;
        builder.addFragmentCode(s);
    }
    get getFunctionName() {
        return `${this.prefix}_get`;
    }
}
//# sourceMappingURL=shader.js.map