/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import debounce from 'lodash/debounce';
import { RefCounted } from './disposable';
import { isInputTextTarget } from './dom';
import LinkedListOperations from './linked_list.0';
class AutomaticFocusList {
    constructor() {
        LinkedListOperations.initializeHead(this);
    }
}
const automaticFocusList = new AutomaticFocusList();
const isTopLevel = window.top === window;
const maybeUpdateFocus = debounce(() => {
    if (!isTopLevel) return;
    var _document = document;
    const activeElement = _document.activeElement;

    if (activeElement === null || activeElement === document.body) {
        const node = LinkedListOperations.front(automaticFocusList);
        if (node !== null) {
            node.element.focus({ preventScroll: true });
        }
    }
});
window.addEventListener('focus', () => {
    maybeUpdateFocus();
}, true);
window.addEventListener('blur', () => {
    maybeUpdateFocus();
}, true);
export class AutomaticallyFocusedElement extends RefCounted {
    constructor(element) {
        super();
        this.element = element;
        this.prev0 = null;
        this.next0 = null;
        this.lastFocusedElement = null;
        this.scheduleUpdateFocus = this.registerCancellable(debounce(() => {
            var _document2 = document;
            const activeElement = _document2.activeElement;
            const element = this.element;

            if (element.contains(activeElement) || isInputTextTarget(activeElement)) {
                // Never steal focus from descendant or from text input element.
                return;
            }
            if (activeElement != null && (activeElement === this.lastFocusedElement || activeElement.contains(element))) {
                this.element.focus({ preventScroll: true });
            }
            this.lastFocusedElement = null;
        }, 0));
        element.tabIndex = -1;
        this.registerEventListener(element, 'pointerdown', event => {
            if (event.target !== element) return;
            this.lastFocusedElement = null;
            element.focus({ preventScroll: true });
        });
        this.registerEventListener(element, 'mouseenter', () => {
            this.lastFocusedElement = document.activeElement;
            this.scheduleUpdateFocus();
        });
        this.registerEventListener(element, 'mouseleave', () => {
            this.scheduleUpdateFocus.cancel();
        });
        // Insert at the end of the list.
        LinkedListOperations.insertBefore(automaticFocusList, this);
        this.registerEventListener(element, 'focus', () => {
            // Move to the beginning of the list.
            LinkedListOperations.pop(this);
            LinkedListOperations.insertAfter(automaticFocusList, this);
        });
        maybeUpdateFocus();
    }
    disposed() {
        LinkedListOperations.pop(this);
        super.disposed();
    }
}
//# sourceMappingURL=automatic_focus.js.map