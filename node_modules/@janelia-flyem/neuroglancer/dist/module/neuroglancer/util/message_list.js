import _Symbol$iterator from "babel-runtime/core-js/symbol/iterator";
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Message list framework for messages to be displayed in the UI.
 */
import { NullarySignal } from "./signal";
export var MessageSeverity;
(function (MessageSeverity) {
    MessageSeverity[MessageSeverity["info"] = 0] = "info";
    MessageSeverity[MessageSeverity["warning"] = 1] = "warning";
    MessageSeverity[MessageSeverity["error"] = 2] = "error";
})(MessageSeverity || (MessageSeverity = {}));
export class Message {}
export class MessageList {
    constructor() {
        this.changed = new NullarySignal();
        this.messages = [];
        this.children = [];
    }
    addMessage(message) {
        this.messages.push(message);
        this.changed.dispatch();
    }
    clearMessages() {
        const messages = this.messages;

        if (messages.length === 0) return;
        messages.length = 0;
        this.changed.dispatch();
    }
    isEmpty() {
        return this.messages.length === 0 && !this.children.some(x => !x.isEmpty());
    }
    addChild(list) {
        this.children.push(list);
        list.changed.add(this.changed.dispatch);
        if (!list.isEmpty()) {
            this.changed.dispatch();
        }
        return () => {
            const children = this.children;

            children.splice(children.indexOf(list), 1);
            list.changed.remove(this.changed.dispatch);
            if (!list.isEmpty()) {
                this.changed.dispatch();
            }
        };
    }
    *[_Symbol$iterator]() {
        yield* this.messages;
        for (const child of this.children) {
            yield* child;
        }
    }
}
//# sourceMappingURL=message_list.js.map