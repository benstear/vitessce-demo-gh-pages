import _Object$assign from 'babel-runtime/core-js/object/assign';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { uncancelableToken } from './cancellation';
import { Uint64 } from './uint64';
export class HttpError extends Error {
    constructor(url, status, statusText, response) {
        let message = `Fetching ${_JSON$stringify(url)} resulted in HTTP error ${status}`;
        if (statusText) {
            message += `: ${statusText}`;
        }
        message += '.';
        super(message);
        this.name = 'HttpError';
        this.message = message;
        this.url = url;
        this.status = status;
        this.statusText = statusText;
        if (response) {
            this.response = response;
        }
    }
    static fromResponse(response) {
        return new HttpError(response.url, response.status, response.statusText, response);
    }
    static fromRequestError(input, error) {
        if (error instanceof TypeError) {
            let url;
            if (typeof input === 'string') {
                url = input;
            } else {
                url = input.url;
            }
            return new HttpError(url, 0, 'Network or CORS error');
        }
        return error;
    }
}
/**
 * Issues a `fetch` request.
 *
 * If the request fails due to an HTTP status outside `[200, 300)`, throws an `HttpError`.  If the
 * request fails due to a network or CORS restriction, throws an `HttpError` with a `status` of `0`.
 */
export async function fetchOk(input, init) {
    let response;
    try {
        response = await fetch(input, init);
    } catch (error) {
        throw HttpError.fromRequestError(input, error);
    }
    if (!response.ok) throw HttpError.fromResponse(response);
    return response;
}
export function responseArrayBuffer(response) {
    return response.arrayBuffer();
}
export function responseJson(response) {
    return response.json();
}
/**
 * Issues a `fetch` request in the same way as `fetchOk`, and returns the result of the promise
 * returned by `transformResponse`.
 *
 * Additionally, the request may be cancelled through `cancellationToken`.
 *
 * The `transformResponse` function should not do anything with the `Response` object after its
 * result becomes ready; otherwise, cancellation may not work as expected.
 */
export async function cancellableFetchOk(input, init, transformResponse, cancellationToken = uncancelableToken) {
    if (cancellationToken === uncancelableToken) {
        const response = await fetchOk(input, init);
        return await transformResponse(response);
    }
    const abortController = new AbortController();
    const unregisterCancellation = cancellationToken.add(() => abortController.abort());
    try {
        const response = await fetchOk(input, _Object$assign(_Object$assign({}, init), { signal: abortController.signal }));
        return await transformResponse(response);
    } finally {
        unregisterCancellation();
    }
}
const tempUint64 = new Uint64();
export function getByteRangeHeader(startOffset, endOffset) {
    let endOffsetStr;
    if (typeof endOffset === 'number') {
        endOffsetStr = `${endOffset - 1}`;
    } else {
        Uint64.decrement(tempUint64, endOffset);
        endOffsetStr = tempUint64.toString();
    }
    return { 'Range': `bytes=${startOffset}-${endOffsetStr}` };
}
export function parseUrl(url) {
    const urlProtocolPattern = /^([^:\/]+):\/\/([^\/]+)((?:\/.*)?)$/;
    let match = url.match(urlProtocolPattern);
    if (match === null) {
        throw new Error(`Invalid URL: ${_JSON$stringify(url)}`);
    }
    return { protocol: match[1], host: match[2], path: match[3] };
}
export function isNotFoundError(e) {
    if (!(e instanceof HttpError)) return false;
    // Treat CORS errors (0) or 403 as not found.  S3 returns 403 if the file does not exist because
    // permissions are per-file.
    return e.status === 0 || e.status === 403 || e.status === 404;
}
//# sourceMappingURL=http_request.js.map