import _slicedToArray from "babel-runtime/helpers/slicedToArray";
import _Map from "babel-runtime/core-js/map";
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Maps string event identifiers to string action identifiers.
 *
 * When an event identifier is looked up in a given HierarchicalMap, it is resolved to a
 * corresponding action identifier in one of two ways:
 *
 * 1. via mappings defined directly on the HierarchicalMap.
 *
 * 2. via a recursive lookup on a "parent" HierarchicalMap that has been specified for the root
 *    HierarchicalMap on which the lookup was initiated.
 *
 * HierarchicalMap objects may be specified as "parents" of another HierarchicalMap along with a
 * specified numerical priority value, such that there is a directed graph of HierarchicalMap
 * objects.  Cycles in this graph may lead to infinite looping.
 *
 * Recursive lookups in parent HierarchicalMap objects are performed in order of decreasing
 * priority. The lookup stops as soon as a mapping is found.  Direct bindings have a priority of 0.
 * Therefore, parent maps with a priority higher than 0 take precedence over direct bindings.
 */
export class HierarchicalMap {
    /**
     * If an existing HierarchicalMap is specified, a shallow copy is made.
     *
     * @param existing Existing map to make a shallow copy of.
     */
    constructor(existing) {
        this.parents = new Array();
        this.parentPriorities = new Array();
        this.bindings = new _Map();
        if (existing !== undefined) {
            this.parents.push(...existing.parents);
            this.parentPriorities.push(...existing.parentPriorities);
            for (const _ref of existing.bindings) {
                var _ref2 = _slicedToArray(_ref, 2);

                const k = _ref2[0];
                const v = _ref2[1];

                this.bindings.set(k, v);
            }
        }
    }
    /**
     * Register `parent` as a parent map.  If `priority > 0`, this map will take precedence over
     * direct bindings.
     *
     * @returns A nullary function that unregisters the parent (and may be called at most once).
     */
    addParent(parent, priority) {
        const parents = this.parents,
              parentPriorities = this.parentPriorities;

        let index = 0;
        const length = parents.length;

        while (index < length && priority < parentPriorities[index]) {
            ++index;
        }
        parents.splice(index, 0, parent);
        parentPriorities.splice(index, 0, priority);
        return () => {
            this.removeParent(parent);
        };
    }
    /**
     * Unregisters `parent` as a parent.
     */
    removeParent(parent) {
        const index = this.parents.indexOf(parent);
        if (index === -1) {
            throw new Error(`Attempt to remove non-existent parent map.`);
        }
        this.parents.splice(index, 1);
        this.parentPriorities.splice(index, 1);
    }
    /**
     * Register a direct binding.
     */
    set(key, value) {
        this.bindings.set(key, value);
    }
    /**
     * Unregister a direct binding.
     */
    delete(key) {
        this.bindings.delete(key);
    }
    /**
     * Deletes all bindings, including parents.
     */
    clear() {
        this.bindings.clear();
        this.parents.length = 0;
        this.parentPriorities.length = 0;
    }
    /**
     * Lookup the highest priority value to which the specified key is mapped.
     */
    get(key) {
        const parents = this.parents,
              parentPriorities = this.parentPriorities;

        const numParents = parentPriorities.length;
        let parentIndex = 0;
        let value;
        for (; parentIndex < numParents && parentPriorities[parentIndex] > 0; ++parentIndex) {
            value = parents[parentIndex].get(key);
            if (value !== undefined) {
                return value;
            }
        }
        value = this.bindings.get(key);
        if (value !== undefined) {
            return value;
        }
        for (; parentIndex < numParents; ++parentIndex) {
            value = parents[parentIndex].get(key);
            if (value !== undefined) {
                return value;
            }
        }
        return undefined;
    }
    /**
     * Find all values to which the specified key is mapped.
     */
    *getAll(key) {
        const parents = this.parents,
              parentPriorities = this.parentPriorities;

        const numParents = parentPriorities.length;
        let parentIndex = 0;
        let value;
        while (parentIndex < numParents && parentPriorities[parentIndex] > 0) {
            value = parents[parentIndex].get(key);
            if (value !== undefined) {
                yield value;
            }
        }
        value = this.bindings.get(key);
        if (value !== undefined) {
            yield value;
        }
        while (parentIndex < numParents) {
            value = parents[parentIndex].get(key);
            if (value !== undefined) {
                yield value;
            }
        }
    }
    *entries() {
        const parents = this.parents,
              parentPriorities = this.parentPriorities;

        const numParents = parentPriorities.length;
        let parentIndex = 0;
        for (; parentIndex < numParents && parentPriorities[parentIndex] > 0; ++parentIndex) {
            yield* parents[parentIndex].entries();
        }
        yield* this.bindings.entries();
        for (; parentIndex < numParents; ++parentIndex) {
            yield* parents[parentIndex].entries();
        }
    }
}
//# sourceMappingURL=hierarchical_map.js.map