import _Map from 'babel-runtime/core-js/map';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { registerEventListener } from './disposable';
import { HierarchicalMap } from './hierarchical_map';
export var Modifiers;
(function (Modifiers) {
    Modifiers[Modifiers["CONTROL"] = 1] = "CONTROL";
    Modifiers[Modifiers["ALT"] = 2] = "ALT";
    Modifiers[Modifiers["META"] = 4] = "META";
    Modifiers[Modifiers["SHIFT"] = 8] = "SHIFT";
})(Modifiers || (Modifiers = {}));
export function getEventModifierMask(event) {
    return (event.ctrlKey ? 1 /* CONTROL */ : 0) | (event.altKey ? 2 /* ALT */ : 0) | (event.metaKey ? 4 /* META */ : 0) | (event.shiftKey ? 8 /* SHIFT */ : 0);
}
export function getStrokeIdentifier(keyName, modifiers) {
    let identifier = '';
    if (modifiers & 1 /* CONTROL */) {
            identifier += 'control+';
        }
    if (modifiers & 2 /* ALT */) {
            identifier += 'alt+';
        }
    if (modifiers & 4 /* META */) {
            identifier += 'meta+';
        }
    if (modifiers & 8 /* SHIFT */) {
            identifier += 'shift+';
        }
    identifier += keyName;
    return identifier;
}
function getStrokeIdentifierWithOptionalModifiers(keyName, modifiers, optionalModifiers) {
    let identifier = '';
    if (modifiers & 1 /* CONTROL */) {
            identifier += 'control+';
        }
    if (optionalModifiers & 1 /* CONTROL */) {
            identifier += 'control?+';
        }
    if (modifiers & 2 /* ALT */) {
            identifier += 'alt+';
        }
    if (optionalModifiers & 2 /* ALT */) {
            identifier += 'alt?+';
        }
    if (modifiers & 4 /* META */) {
            identifier += 'meta+';
        }
    if (optionalModifiers & 4 /* META */) {
            identifier += 'meta?+';
        }
    if (modifiers & 8 /* SHIFT */) {
            identifier += 'shift+';
        }
    if (optionalModifiers & 8 /* SHIFT */) {
            identifier += 'shift?+';
        }
    identifier += keyName;
    return identifier;
}
function parseEventIdentifier(identifier) {
    const firstColonOffset = identifier.indexOf(':');
    let phase;
    if (firstColonOffset !== -1) {
        phase = identifier.substring(0, firstColonOffset);
        // TODO(jbms): Support capture phase.
        if (phase !== 'at' && phase !== 'bubble') {
            throw new Error(`Invalid event phase: ${_JSON$stringify(phase)}`);
        }
    }
    const parts = identifier.substring(firstColonOffset + 1).split('+');
    let keyName;
    let modifiers = 0;
    let optionalModifiers = 0;
    loop: for (let part of parts) {
        switch (part) {
            case 'control':
                modifiers |= 1 /* CONTROL */;
                break;
            case 'control?':
                optionalModifiers |= 1 /* CONTROL */;
                break;
            case 'alt':
                modifiers |= 2 /* ALT */;
                break;
            case 'alt?':
                optionalModifiers |= 2 /* ALT */;
                break;
            case 'meta':
                modifiers |= 4 /* META */;
                break;
            case 'meta?':
                optionalModifiers |= 4 /* META */;
                break;
            case 'shift':
                modifiers |= 8 /* SHIFT */;
                break;
            case 'shift?':
                optionalModifiers |= 8 /* SHIFT */;
                break;
            default:
                if (keyName === undefined) {
                    keyName = part;
                } else {
                    keyName = undefined;
                    break loop;
                }
        }
    }
    if (keyName === undefined || modifiers & optionalModifiers) {
        throw new Error(`Invalid event identifier: ${_JSON$stringify(identifier)}`);
    }
    return { phase: phase, keyName, modifiers, optionalModifiers };
}
function* getNormalizedStrokeIdentifiers(keyName, modifiers, optionalModifiers) {
    if (optionalModifiers === 0) {
        yield getStrokeIdentifier(keyName, modifiers);
    }
    for (let m = 0; m < 16; ++m) {
        if ((m & (modifiers | optionalModifiers)) !== m) continue;
        if ((m & modifiers) !== modifiers) continue;
        yield getStrokeIdentifier(keyName, m);
    }
}
/**
 * Normalizes a user-specified EventIdentifier into a list of one or more corresponding
 * NormalizedEventIdentifier strings.
 */
function* getNormalizedEventIdentifiers(parsed) {
    const phase = parsed.phase;

    const strokeIdentifiers = getNormalizedStrokeIdentifiers(parsed.keyName, parsed.modifiers, parsed.optionalModifiers);
    if (phase === undefined) {
        for (const suffix of strokeIdentifiers) {
            yield `at:${suffix}`;
            yield `bubble:${suffix}`;
        }
    } else {
        for (const suffix of strokeIdentifiers) {
            yield `${phase}:${suffix}`;
        }
    }
}
/**
 * Normalizes an ActionOrEventAction into an EventAction.
 */
export function normalizeEventAction(parsed, action) {
    const identifier = getStrokeIdentifierWithOptionalModifiers(parsed.keyName, parsed.modifiers, parsed.optionalModifiers);
    if (typeof action === 'string') {
        return { action: action, originalEventIdentifier: identifier };
    }
    return _Object$assign(_Object$assign({}, action), { originalEventIdentifier: identifier });
}
/**
 * Hierarchical map of `EventIdentifier` specifications to `EventAction` specifications.  These maps
 * are used by KeyboardEventBinder and MouseEventBinder to dispatch an ActionEvent in response to an
 * input event.
 */
export class EventActionMap extends HierarchicalMap {
    /**
     * Returns a new EventActionMap with the specified bindings.
     *
     * The keys of the `bindings` object specify unnormalized event identifiers to be mapped to their
     * corresponding `ActionOrEventAction` values.
     */
    static fromObject(bindings, options = {}) {
        const map = new EventActionMap();
        map.label = options.label;
        if (options.parents !== undefined) {
            for (const _ref of options.parents) {
                var _ref2 = _slicedToArray(_ref, 2);

                const parent = _ref2[0];
                const priority = _ref2[1];

                map.addParent(parent, priority);
            }
        }
        for (const key of _Object$keys(bindings)) {
            map.set(key, bindings[key]);
        }
        return map;
    }
    setFromObject(bindings) {
        for (const key of _Object$keys(bindings)) {
            this.set(key, bindings[key]);
        }
    }
    /**
     * Maps the specified event `identifier` to the specified `action`.
     *
     * The `identifier` may be unnormalized; the actual mapping is created for each corresponding
     * normalized identifier.
     */
    set(identifier, action) {
        const parsedIdentifier = parseEventIdentifier(identifier);
        const normalizedAction = normalizeEventAction(parsedIdentifier, action);
        for (const normalizedIdentifier of getNormalizedEventIdentifiers(parsedIdentifier)) {
            super.set(normalizedIdentifier, normalizedAction);
        }
    }
    /**
     * Deletes the mapping for the specified `identifier`.
     *
     * The `identifier` may be unnormalized; the mapping is deleted for each corresponding normalized
     * identifier.
     */
    delete(identifier) {
        for (const normalizedIdentifier of getNormalizedEventIdentifiers(parseEventIdentifier(identifier))) {
            super.delete(normalizedIdentifier);
        }
    }
    describe() {
        const bindings = [];
        const uniqueBindings = new _Map();
        for (const _ref3 of this.entries()) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const value = _ref4[1];

            uniqueBindings.set(value.originalEventIdentifier, value.action);
        }
        for (const _ref5 of uniqueBindings) {
            var _ref6 = _slicedToArray(_ref5, 2);

            const key = _ref6[0];
            const value = _ref6[1];

            bindings.push(`${key}â†’${value}`);
        }
        return bindings.join(', ');
    }
}
export function dispatchEventAction(originalEvent, detail, eventAction) {
    if (eventAction === undefined) {
        return;
    }
    if (eventAction.stopPropagation !== false) {
        originalEvent.stopPropagation();
    }
    const actionEvent = new CustomEvent('action:' + eventAction.action, { 'bubbles': true, detail: detail, cancelable: true });
    const cancelled = !originalEvent.target.dispatchEvent(actionEvent);
    if (eventAction.preventDefault !== false || cancelled) {
        originalEvent.preventDefault();
    }
}
export const eventPhaseNames = [];
eventPhaseNames[Event.AT_TARGET] = 'at';
eventPhaseNames[Event.CAPTURING_PHASE] = 'capture';
eventPhaseNames[Event.BUBBLING_PHASE] = 'bubble';
export function dispatchEvent(baseIdentifier, originalEvent, eventPhase, detail, eventMap) {
    const eventIdentifier = eventPhaseNames[eventPhase] + ':' + baseIdentifier;
    const eventAction = eventMap.get(eventIdentifier);
    dispatchEventAction(originalEvent, detail, eventAction);
}
export function dispatchEventWithModifiers(baseIdentifier, originalEvent, detail, eventMap) {
    dispatchEvent(getStrokeIdentifier(baseIdentifier, getEventModifierMask(originalEvent)), originalEvent, originalEvent.eventPhase, detail, eventMap);
}
/**
 * Register an event listener for the specified `action`.
 *
 * There is no checking that the `TriggerEvent` type is suitable for use with the specified
 * `action`.
 *
 * @returns A nullary disposer function that unregisters the listener when called.
 */
export function registerActionListener(target, action, listener, options) {
    return registerEventListener(target, `action:${action}`, listener, options);
}
//# sourceMappingURL=event_action_map.js.map