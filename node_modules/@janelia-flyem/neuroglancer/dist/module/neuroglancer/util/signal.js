import _Set from "babel-runtime/core-js/set";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Simple signal dispatch mechanism.
 */
/**
 * This class provides a simple signal dispatch mechanism.  Handlers can be added, and then the
 * `dispatch` method calls all of them.
 *
 * If specified, Callable should be an interface containing only a callable signature returning
 * void.  Due to limitations in TypeScript, any interface containing a callable signature will be
 * accepted by the compiler, but the resultant signature of `dispatch` will not be correct.
 */
export class Signal {
    constructor() {
        this.handlers = new _Set();
        /**
         * Count of number of times this signal has been dispatched.  This is incremented each time
         * `dispatch` is called prior to invoking the handlers.
         */
        this.count = 0;
        const obj = this;
        this.dispatch = function () {
            ++obj.count;
            obj.handlers.forEach(handler => {
                handler.apply(this, arguments);
            });
        };
    }
    /**
     * Add a handler function.  If `dispatch` is currently be called, then the new handler will be
     * called before `dispatch` returns.
     *
     * @param handler The handler function to add.
     *
     * @return A function that unregisters the handler.
     */
    add(handler) {
        this.handlers.add(handler);
        return () => {
            return this.remove(handler);
        };
    }
    /**
     * Remove a handler function.  If `dispatch` is currently be called and the new handler has not
     * yet been called, then it will not be called.
     *
     * @param handler Handler to remove.
     * @return `true` if the handler was present, `false` otherwise.
     */
    remove(handler) {
        return this.handlers.delete(handler);
    }
    /**
     * Disposes of resources.  No methods, including `dispatch`, may be invoked afterwards.
     */
    dispose() {
        this.handlers = undefined;
    }
}
export function observeSignal(callback, ...signals) {
    callback();
    for (let i = 0, count = signals.length; i < count; ++i) {
        signals[i].add(callback);
    }
    return () => {
        for (let i = 0, count = signals.length; i < count; ++i) {
            signals[i].remove(callback);
        }
    };
}
/**
 * Simple specialization of Signal for the common case of a nullary handler signature.
 */
export class NullarySignal extends Signal {}
export const neverSignal = {
    count: 0,
    add(_handler) {
        return () => {};
    },
    remove(_handler) {
        return false;
    }
};
//# sourceMappingURL=signal.js.map