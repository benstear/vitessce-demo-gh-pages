import _WeakMap from 'babel-runtime/core-js/weak-map';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Defines a generic interface for a simple state tracking mechanism.
 */
import { RefCounted } from './disposable';
import { verifyObject, verifyOptionalObjectProperty } from './json';
import { NullarySignal } from './signal';
export function optionallyRestoreFromJsonMember(obj, member, restorable) {
    verifyOptionalObjectProperty(obj, member, x => restorable.restoreState(x));
}
export class CompoundTrackable extends RefCounted {
    constructor() {
        super(...arguments);
        this.children = new _Map();
        this.changed = new NullarySignal();
    }
    add(key, value) {
        const children = this.children;

        if (children.has(key)) {
            throw new Error(`Key ${_JSON$stringify(key)} already registered.`);
        }
        this.children.set(key, value);
        value.changed.add(this.changed.dispatch);
        this.changed.dispatch();
        return () => {
            this.remove(key);
        };
    }
    remove(key) {
        const children = this.children;

        if (children.has(key)) {
            throw new Error(`Key ${_JSON$stringify(key)} not registered.`);
        }
        const value = children.get(key);
        this.children.delete(key);
        value.changed.remove(this.changed.dispatch);
        this.changed.dispatch();
    }
    disposed() {
        const changed = this.changed;

        for (let value of this.children.values()) {
            value.changed.remove(changed.dispatch);
        }
        this.children = undefined;
        super.disposed();
    }
    toJSON() {
        const result = this.baseJSON();
        for (let _ref of this.children) {
            var _ref2 = _slicedToArray(_ref, 2);

            let key = _ref2[0];
            let value = _ref2[1];

            result[key] = value.toJSON();
        }
        return result;
    }
    baseJSON() {
        return {};
    }
    reset() {
        for (let value of this.children.values()) {
            value.reset();
        }
    }
    restoreState(x) {
        verifyObject(x);
        for (let _ref3 of this.children) {
            var _ref4 = _slicedToArray(_ref3, 2);

            let key = _ref4[0];
            let value = _ref4[1];

            try {
                if (x.hasOwnProperty(key)) {
                    const subValue = x[key];
                    if (subValue === undefined) {
                        continue;
                    }
                    value.restoreState(subValue);
                }
            } catch (restoreError) {
                throw new Error(`Error restoring property ${_JSON$stringify(key)}: ${restoreError.message}`);
            }
        }
    }
}
export class PersistentCompoundTrackable extends CompoundTrackable {
    constructor() {
        super(...arguments);
        this.lastState = {};
    }
    restoreState(x) {
        verifyObject(x);
        this.lastState = x;
        super.restoreState(x);
    }
    reset() {
        this.lastState = {};
        super.reset();
    }
    baseJSON() {
        const result = _Object$assign(super.baseJSON(), this.lastState);
        for (const key of this.children.keys()) {
            delete result[key];
        }
        return result;
    }
    toJSON() {
        const result = super.toJSON();
        this.lastState = result;
        return result;
    }
    add(key, value) {
        const result = super.add(key, value);
        const existingValue = this.lastState[key];
        if (existingValue !== undefined) {
            value.reset();
            value.restoreState(existingValue);
        }
        return result;
    }
}
/**
 * Cache used by getCachedJson.
 */
const jsonCache = new _WeakMap();
/**
 * Returns a JSON representation of a Trackable object.
 *
 * Recursively caches the result, such that it is only necessary to traverse the changed portions of
 * the object.
 *
 * The returned value must not be modified.
 */
export function getCachedJson(root) {
    let cacheState = jsonCache.get(root);
    const generation = root.changed.count;
    if (cacheState !== undefined) {
        if (cacheState.generation === generation) {
            return cacheState;
        }
    }
    let value;
    if (root instanceof CompoundTrackable) {
        value = root.baseJSON();
        for (let _ref5 of root.children) {
            var _ref6 = _slicedToArray(_ref5, 2);

            let k = _ref6[0];
            let v = _ref6[1];

            value[k] = getCachedJson(v).value;
        }
    } else {
        value = root.toJSON();
    }
    if (cacheState === undefined) {
        cacheState = { generation, value };
        jsonCache.set(root, cacheState);
    } else {
        cacheState.generation = generation;
        cacheState.value = value;
    }
    return cacheState;
}
//# sourceMappingURL=trackable.js.map