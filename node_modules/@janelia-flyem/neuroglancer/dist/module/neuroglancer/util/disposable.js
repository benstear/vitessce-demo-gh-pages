/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEBUG_REF_COUNTS = false;
export function invokeDisposer(disposer) {
    if (typeof disposer === 'object') {
        disposer.dispose();
    } else {
        disposer();
    }
}
export function invokeDisposers(disposers) {
    for (let i = disposers.length; i > 0; --i) {
        invokeDisposer(disposers[i - 1]);
    }
}
export function registerEventListener(target, type, listener, options) {
    target.addEventListener(type, listener, options);
    return () => target.removeEventListener(type, listener, options);
}
export class RefCounted {
    constructor() {
        this.refCount = 1;
    }
    addRef() {
        ++this.refCount;
        return this;
    }
    dispose() {
        if (DEBUG_REF_COUNTS) {
            if (this.refCount === 0) {
                debugger;
            }
            (this.disposedStacks = this.disposedStacks || []).push(new Error().stack);
        }
        if (--this.refCount !== 0) {
            return;
        }
        this.refCountReachedZero();
    }
    refCountReachedZero() {
        this.disposed();
        let disposers = this.disposers;

        if (disposers !== undefined) {
            invokeDisposers(disposers);
            this.disposers = undefined;
        }
        this.wasDisposed = true;
    }
    disposed() {}
    registerDisposer(f) {
        let disposers = this.disposers;

        if (disposers == null) {
            this.disposers = [f];
        } else {
            disposers.push(f);
        }
        return f;
    }
    unregisterDisposer(f) {
        let disposers = this.disposers;

        if (disposers != null) {
            let index = disposers.indexOf(f);
            if (index !== -1) {
                disposers.splice(index, 1);
            }
        }
        return f;
    }
    registerEventListener(target, type, listener, options) {
        this.registerDisposer(registerEventListener(target, type, listener, options));
    }
    registerCancellable(cancellable) {
        this.registerDisposer(() => {
            cancellable.cancel();
        });
        return cancellable;
    }
}
export class RefCountedValue extends RefCounted {
    constructor(value) {
        super();
        this.value = value;
    }
}
export function disposableOnce(value) {
    return () => {
        if (value !== undefined) {
            let x = value;
            value = undefined;
            invokeDisposer(x);
        }
    };
}
//# sourceMappingURL=disposable.js.map