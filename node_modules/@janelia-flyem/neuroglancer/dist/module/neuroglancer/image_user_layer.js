import _Object$assign from 'babel-runtime/core-js/object/assign';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';

import { CoordinateSpaceCombiner, isChannelDimension, isLocalDimension, TrackableCoordinateSpace } from './coordinate_transform'; /**
                                                                                                                                   * @license
                                                                                                                                   * Copyright 2016 Google Inc.
                                                                                                                                   * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                   * you may not use this file except in compliance with the License.
                                                                                                                                   * You may obtain a copy of the License at
                                                                                                                                   *
                                                                                                                                   *      http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                   *
                                                                                                                                   * Unless required by applicable law or agreed to in writing, software
                                                                                                                                   * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                   * See the License for the specific language governing permissions and
                                                                                                                                   * limitations under the License.
                                                                                                                                   */

import { registerLayerType, registerLayerTypeDetector, registerVolumeLayerType, UserLayer } from './layer';
import { Overlay } from './overlay';
import { getChannelSpace } from './render_coordinate_transform';
import { RenderScaleHistogram, trackableRenderScaleTarget } from './render_scale_statistics';
import { DataType, VolumeType } from './sliceview/volume/base';
import { MultiscaleVolumeChunkSource } from './sliceview/volume/frontend';
import { defineImageLayerShader, getTrackableFragmentMain, ImageRenderLayer } from './sliceview/volume/image_renderlayer';
import { trackableAlphaValue } from './trackable_alpha';
import { trackableBlendModeValue } from './trackable_blend';
import { TrackableBoolean } from './trackable_boolean';
import { makeCachedDerivedWatchableValue, makeCachedLazyDerivedWatchableValue, registerNested, WatchableValue } from './trackable_value';
import { UserLayerWithAnnotationsMixin } from './ui/annotations';
import { setClipboard } from './util/clipboard';
import { makeValueOrError } from './util/error';
import { verifyOptionalObjectProperty } from './util/json';
import { VolumeRenderingRenderLayer } from './volume_rendering/volume_render_layer';
import { makeWatchableShaderError } from './webgl/dynamic_shader';
import { setControlsInShader, ShaderControlState } from './webgl/shader_ui_controls';
import { ChannelDimensionsWidget } from './widget/channel_dimensions_widget';
import { makeCopyButton } from './widget/copy_button';
import { makeHelpButton } from './widget/help_button';
import { addLayerControlToOptionsTab, registerLayerControl } from './widget/layer_control';
import { checkboxLayerControl } from './widget/layer_control_checkbox';
import { enumLayerControl } from './widget/layer_control_enum';
import { rangeLayerControl } from './widget/layer_control_range';
import { makeMaximizeButton } from './widget/maximize_button';
import { renderScaleLayerControl } from './widget/render_scale_widget';
import { ShaderCodeWidget } from './widget/shader_code_widget';
import { registerLayerShaderControlsTool, ShaderControls } from './widget/shader_controls';
import { Tab } from './widget/tab_view';
const OPACITY_JSON_KEY = 'opacity';
const BLEND_JSON_KEY = 'blend';
const SHADER_JSON_KEY = 'shader';
const SHADER_CONTROLS_JSON_KEY = 'shaderControls';
const CROSS_SECTION_RENDER_SCALE_JSON_KEY = 'crossSectionRenderScale';
const CHANNEL_DIMENSIONS_JSON_KEY = 'channelDimensions';
const VOLUME_RENDERING_JSON_KEY = 'volumeRendering';
const VOLUME_RENDER_SCALE_JSON_KEY = 'volumeRenderScale';
const Base = UserLayerWithAnnotationsMixin(UserLayer);
export class ImageUserLayer extends Base {
    constructor(managedLayer) {
        super(managedLayer);
        this.opacity = trackableAlphaValue(0.5);
        this.blendMode = trackableBlendModeValue();
        this.fragmentMain = getTrackableFragmentMain();
        this.shaderError = makeWatchableShaderError();
        this.dataType = new WatchableValue(undefined);
        this.sliceViewRenderScaleHistogram = new RenderScaleHistogram();
        this.sliceViewRenderScaleTarget = trackableRenderScaleTarget(1);
        this.volumeRenderingRenderScaleHistogram = new RenderScaleHistogram();
        // unused
        this.volumeRenderingRenderScaleTarget = trackableRenderScaleTarget(1);
        this.channelCoordinateSpace = new TrackableCoordinateSpace();
        this.channelCoordinateSpaceCombiner = new CoordinateSpaceCombiner(this.channelCoordinateSpace, isChannelDimension);
        this.channelSpace = this.registerDisposer(makeCachedLazyDerivedWatchableValue(channelCoordinateSpace => makeValueOrError(() => getChannelSpace(channelCoordinateSpace)), this.channelCoordinateSpace));
        this.volumeRendering = new TrackableBoolean(false, false);
        this.shaderControlState = this.registerDisposer(new ShaderControlState(this.fragmentMain, this.registerDisposer(makeCachedDerivedWatchableValue((dataType, channelCoordinateSpace) => {
            if (dataType === undefined) return null;
            return { imageData: { dataType, channelRank: channelCoordinateSpace.rank } };
        }, [this.dataType, this.channelCoordinateSpace], (a, b) => _JSON$stringify(a) === _JSON$stringify(b))), this.channelCoordinateSpaceCombiner));
        this.localCoordinateSpaceCombiner.includeDimensionPredicate = isLocalDimension;
        this.blendMode.changed.add(this.specificationChanged.dispatch);
        this.opacity.changed.add(this.specificationChanged.dispatch);
        this.fragmentMain.changed.add(this.specificationChanged.dispatch);
        this.shaderControlState.changed.add(this.specificationChanged.dispatch);
        this.sliceViewRenderScaleTarget.changed.add(this.specificationChanged.dispatch);
        this.volumeRendering.changed.add(this.specificationChanged.dispatch);
        this.tabs.add('rendering', { label: 'Rendering', order: -100, getter: () => new RenderingOptionsTab(this) });
        this.tabs.default = 'rendering';
    }
    markLoading() {
        const baseDisposer = super.markLoading();
        const channelDisposer = this.channelCoordinateSpaceCombiner.retain();
        return () => {
            baseDisposer();
            channelDisposer();
        };
    }
    addCoordinateSpace(coordinateSpace) {
        const baseBinding = super.addCoordinateSpace(coordinateSpace);
        const channelBinding = this.channelCoordinateSpaceCombiner.bind(coordinateSpace);
        return () => {
            baseBinding();
            channelBinding();
        };
    }
    activateDataSubsources(subsources) {
        let dataType;
        for (const loadedSubsource of subsources) {
            if (this.addStaticAnnotations(loadedSubsource)) continue;
            const subsourceEntry = loadedSubsource.subsourceEntry;
            const subsource = subsourceEntry.subsource;
            const volume = subsource.volume;

            if (!(volume instanceof MultiscaleVolumeChunkSource)) {
                loadedSubsource.deactivate('Not compatible with image layer');
                continue;
            }
            if (dataType && volume.dataType !== dataType) {
                loadedSubsource.deactivate(`Data type must be ${DataType[volume.dataType].toLowerCase()}`);
                continue;
            }
            dataType = volume.dataType;
            loadedSubsource.activate(context => {
                loadedSubsource.addRenderLayer(new ImageRenderLayer(volume, {
                    opacity: this.opacity,
                    blendMode: this.blendMode,
                    shaderControlState: this.shaderControlState,
                    shaderError: this.shaderError,
                    transform: loadedSubsource.getRenderLayerTransform(this.channelCoordinateSpace),
                    renderScaleTarget: this.sliceViewRenderScaleTarget,
                    renderScaleHistogram: this.sliceViewRenderScaleHistogram,
                    localPosition: this.localPosition,
                    channelCoordinateSpace: this.channelCoordinateSpace
                }));
                const volumeRenderLayer = context.registerDisposer(new VolumeRenderingRenderLayer({
                    multiscaleSource: volume,
                    shaderControlState: this.shaderControlState,
                    shaderError: this.shaderError,
                    transform: loadedSubsource.getRenderLayerTransform(this.channelCoordinateSpace),
                    renderScaleTarget: this.volumeRenderingRenderScaleTarget,
                    renderScaleHistogram: this.volumeRenderingRenderScaleHistogram,
                    localPosition: this.localPosition,
                    channelCoordinateSpace: this.channelCoordinateSpace
                }));
                context.registerDisposer(loadedSubsource.messages.addChild(volumeRenderLayer.messages));
                context.registerDisposer(registerNested((context, volumeRendering) => {
                    if (!volumeRendering) return;
                    context.registerDisposer(this.addRenderLayer(volumeRenderLayer.addRef()));
                }, this.volumeRendering));
                this.shaderError.changed.dispatch();
            });
        }
        this.dataType.value = dataType;
    }
    restoreState(specification) {
        super.restoreState(specification);
        this.opacity.restoreState(specification[OPACITY_JSON_KEY]);
        verifyOptionalObjectProperty(specification, BLEND_JSON_KEY, blendValue => this.blendMode.restoreState(blendValue));
        this.fragmentMain.restoreState(specification[SHADER_JSON_KEY]);
        this.shaderControlState.restoreState(specification[SHADER_CONTROLS_JSON_KEY]);
        this.sliceViewRenderScaleTarget.restoreState(specification[CROSS_SECTION_RENDER_SCALE_JSON_KEY]);
        this.channelCoordinateSpace.restoreState(specification[CHANNEL_DIMENSIONS_JSON_KEY]);
        this.volumeRendering.restoreState(specification[VOLUME_RENDERING_JSON_KEY]);
    }
    toJSON() {
        const x = super.toJSON();
        x[OPACITY_JSON_KEY] = this.opacity.toJSON();
        x[BLEND_JSON_KEY] = this.blendMode.toJSON();
        x[SHADER_JSON_KEY] = this.fragmentMain.toJSON();
        x[SHADER_CONTROLS_JSON_KEY] = this.shaderControlState.toJSON();
        x[CROSS_SECTION_RENDER_SCALE_JSON_KEY] = this.sliceViewRenderScaleTarget.toJSON();
        x[CHANNEL_DIMENSIONS_JSON_KEY] = this.channelCoordinateSpace.toJSON();
        x[VOLUME_RENDERING_JSON_KEY] = this.volumeRendering.toJSON();
        return x;
    }
    displayImageSelectionState(state, parent) {
        const value = state.value;

        if (value == null) return false;
        const channelSpace = this.channelSpace.value;
        if (channelSpace.error !== undefined) return false;
        const numChannels = channelSpace.numChannels,
              coordinates = channelSpace.coordinates;
        var _channelSpace$channel = channelSpace.channelCoordinateSpace;
        const names = _channelSpace$channel.names,
              rank = _channelSpace$channel.rank;

        const grid = document.createElement('div');
        grid.classList.add('neuroglancer-selection-details-value-grid');
        let gridTemplateColumns = '[copy] 0fr ';
        if (rank !== 0) {
            gridTemplateColumns += `repeat(${rank}, [dim] 0fr [coord] 0fr) `;
        }
        gridTemplateColumns += `[value] 1fr`;
        grid.style.gridTemplateColumns = gridTemplateColumns;
        for (let channelIndex = 0; channelIndex < numChannels; ++channelIndex) {
            const x = rank === 0 ? value : value[channelIndex];
            // TODO(jbms): do data type-specific formatting
            const valueString = x == null ? '' : x.toString();
            const copyButton = makeCopyButton({
                title: `Copy value`,
                onClick: () => {
                    setClipboard(valueString);
                }
            });
            grid.appendChild(copyButton);
            for (let channelDim = 0; channelDim < rank; ++channelDim) {
                const dimElement = document.createElement('div');
                dimElement.classList.add('neuroglancer-selection-details-value-grid-dim');
                dimElement.textContent = names[channelDim];
                grid.appendChild(dimElement);
                const coordElement = document.createElement('div');
                coordElement.classList.add('neuroglancer-selection-details-value-grid-coord');
                coordElement.textContent = coordinates[channelIndex * rank + channelDim].toString();
                grid.appendChild(coordElement);
            }
            const valueElement = document.createElement('div');
            valueElement.classList.add('neuroglancer-selection-details-value-grid-value');
            valueElement.textContent = valueString;
            grid.appendChild(valueElement);
        }
        parent.appendChild(grid);
        return true;
    }
    displaySelectionState(state, parent, context) {
        let displayed = this.displayImageSelectionState(state, parent);
        if (super.displaySelectionState(state, parent, context)) displayed = true;
        return displayed;
    }
    getLegendShaderOptions() {
        return {
            memoizeKey: `ImageUserLayer`,
            parameters: this.shaderControlState.builderState,
            // fixme: support fallback
            encodeParameters: p => p.key,
            defineShader: (builder, shaderBuilderState) => {
                builder.addFragmentCode(`
#define uOpacity 1.0
`);
                defineImageLayerShader(builder, shaderBuilderState);
            },
            initializeShader: shaderResult => {
                const shader = shaderResult.shader;
                setControlsInShader(this.manager.root.display.gl, shader, this.shaderControlState, shaderResult.parameters.parseResult.controls);
            }
        };
    }
}
ImageUserLayer.type = 'image';
ImageUserLayer.typeAbbreviation = 'img';
function makeShaderCodeWidget(layer) {
    return new ShaderCodeWidget({
        shaderError: layer.shaderError,
        fragmentMain: layer.fragmentMain,
        shaderControlState: layer.shaderControlState
    });
}
const LAYER_CONTROLS = [_Object$assign({ label: 'Resolution (slice)', toolJson: CROSS_SECTION_RENDER_SCALE_JSON_KEY }, renderScaleLayerControl(layer => ({
    histogram: layer.sliceViewRenderScaleHistogram,
    target: layer.sliceViewRenderScaleTarget
}))), _Object$assign({ label: 'Blending', toolJson: BLEND_JSON_KEY }, enumLayerControl(layer => layer.blendMode)), _Object$assign({ label: 'Volume rendering (experimental)', toolJson: VOLUME_RENDERING_JSON_KEY }, checkboxLayerControl(layer => layer.volumeRendering)), _Object$assign({ label: 'Resolution (3d)', toolJson: VOLUME_RENDER_SCALE_JSON_KEY, isValid: layer => layer.volumeRendering }, renderScaleLayerControl(layer => ({
    histogram: layer.volumeRenderingRenderScaleHistogram,
    target: layer.volumeRenderingRenderScaleTarget
}))), _Object$assign({ label: 'Opacity', toolJson: OPACITY_JSON_KEY }, rangeLayerControl(layer => ({ value: layer.opacity })))];
for (const control of LAYER_CONTROLS) {
    registerLayerControl(ImageUserLayer, control);
}
class RenderingOptionsTab extends Tab {
    constructor(layer) {
        super();
        this.layer = layer;
        this.codeWidget = this.registerDisposer(makeShaderCodeWidget(this.layer));
        const element = this.element;

        element.classList.add('neuroglancer-image-dropdown');
        for (const control of LAYER_CONTROLS) {
            element.appendChild(addLayerControlToOptionsTab(this, layer, this.visibility, control));
        }
        let spacer = document.createElement('div');
        spacer.style.flex = '1';
        let topRow = document.createElement('div');
        topRow.className = 'neuroglancer-image-dropdown-top-row';
        topRow.appendChild(document.createTextNode('Shader'));
        topRow.appendChild(spacer);
        topRow.appendChild(makeMaximizeButton({
            title: 'Show larger editor view',
            onClick: () => {
                new ShaderCodeOverlay(this.layer);
            }
        }));
        topRow.appendChild(makeHelpButton({
            title: 'Documentation on image layer rendering',
            href: 'https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md'
        }));
        element.appendChild(topRow);
        element.appendChild(this.registerDisposer(new ChannelDimensionsWidget(layer.channelCoordinateSpaceCombiner)).element);
        element.appendChild(this.codeWidget.element);
        element.appendChild(this.registerDisposer(new ShaderControls(layer.shaderControlState, this.layer.manager.root.display, this.layer, {
            visibility: this.visibility,
            legendShaderOptions: this.layer.getLegendShaderOptions()
        })).element);
    }
}
class ShaderCodeOverlay extends Overlay {
    constructor(layer) {
        super();
        this.layer = layer;
        this.codeWidget = this.registerDisposer(makeShaderCodeWidget(this.layer));
        this.content.classList.add('neuroglancer-image-layer-shader-overlay');
        this.content.appendChild(this.codeWidget.element);
        this.codeWidget.textEditor.refresh();
    }
}
registerLayerType(ImageUserLayer);
registerVolumeLayerType(VolumeType.IMAGE, ImageUserLayer);
// Use ImageUserLayer as a fallback layer type if there is a `volume` subsource.
registerLayerTypeDetector(subsource => {
    const volume = subsource.volume;

    if (volume === undefined) return undefined;
    if (volume.volumeType !== VolumeType.UNKNOWN) return undefined;
    return { layerConstructor: ImageUserLayer, priority: -100 };
});
registerLayerShaderControlsTool(ImageUserLayer, layer => ({
    shaderControlState: layer.shaderControlState,
    legendShaderOptions: layer.getLegendShaderOptions()
}));
//# sourceMappingURL=image_user_layer.js.map