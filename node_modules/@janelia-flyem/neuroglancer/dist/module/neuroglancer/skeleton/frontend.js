import _Map from 'babel-runtime/core-js/map';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Object$values from 'babel-runtime/core-js/object/values';
import _Symbol from 'babel-runtime/core-js/symbol';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ChunkState, LayerChunkProgressInfo } from '../chunk_manager/base';
import { Chunk, ChunkSource } from '../chunk_manager/frontend';
import { PerspectiveViewRenderLayer } from '../perspective_view/render_layer';
import { update3dRenderLayerAttachment } from '../renderlayer';
import { forEachVisibleSegment, getObjectKey } from '../segmentation_display_state/base';
import { forEachVisibleSegmentToDraw, registerRedrawWhenSegmentationDisplayState3DChanged, SegmentationLayerSharedObject } from '../segmentation_display_state/frontend';
import { SKELETON_LAYER_RPC_ID } from './base';
import { SliceViewPanelRenderLayer } from '../sliceview/renderlayer';
import { TrackableValue, WatchableValue } from '../trackable_value';
import { DataType } from '../util/data_type';
import { RefCounted } from '../util/disposable';
import { mat4 } from '../util/geom';
import { verifyFinitePositiveFloat } from '../util/json';
import { NullarySignal } from '../util/signal';
import { CompoundTrackable } from '../util/trackable';
import { TrackableEnum } from '../util/trackable_enum';
import { Buffer } from '../webgl/buffer';
import { defineCircleShader, drawCircles, initializeCircleShader } from '../webgl/circles';
import { glsl_COLORMAPS } from '../webgl/colormaps';
import { makeTrackableFragmentMain, parameterizedEmitterDependentShaderGetter, shaderCodeWithLineDirective } from '../webgl/dynamic_shader';
import { defineLineShader, drawLines, initializeLineShader } from '../webgl/lines';
import { addControlsToBuilder, getFallbackBuilderState, parseShaderUiControls, setControlsInShader, ShaderControlState } from '../webgl/shader_ui_controls';
import { computeTextureFormat, getSamplerPrefixForDataType, OneDimensionalTextureAccessHelper, setOneDimensionalTextureData, TextureFormat } from '../webgl/texture_access';
import { defineVertexId, VertexIdHelper } from '../webgl/vertex_id';
const tempMat2 = mat4.create();
const DEFAULT_FRAGMENT_MAIN = `void main() {
  emitDefault();
}
`;
const vertexAttributeSamplerSymbols = [];
const vertexPositionTextureFormat = computeTextureFormat(new TextureFormat(), DataType.FLOAT32, 3);
class RenderHelper extends RefCounted {
    constructor(base, targetIsSliceView) {
        super();
        this.base = base;
        this.targetIsSliceView = targetIsSliceView;
        this.textureAccessHelper = new OneDimensionalTextureAccessHelper('vertexData');
        this.vertexIdHelper = this.registerDisposer(VertexIdHelper.get(this.gl));
        this.edgeShaderGetter = parameterizedEmitterDependentShaderGetter(this, this.gl, {
            memoizeKey: { type: 'skeleton/SkeletonShaderManager/edge', vertexAttributes: this.vertexAttributes },
            fallbackParameters: this.base.fallbackShaderParameters,
            parameters: this.base.displayState.skeletonRenderingOptions.shaderControlState.builderState,
            shaderError: this.base.displayState.shaderError,
            defineShader: (builder, shaderBuilderState) => {
                if (shaderBuilderState.parseResult.errors.length !== 0) {
                    throw new Error('Invalid UI control specification');
                }
                this.defineCommonShader(builder);
                this.defineAttributeAccess(builder);
                defineLineShader(builder);
                builder.addAttribute('highp uvec2', 'aVertexIndex');
                builder.addUniform('highp float', 'uLineWidth');
                let vertexMain = `
highp vec3 vertexA = readAttribute0(aVertexIndex.x);
highp vec3 vertexB = readAttribute0(aVertexIndex.y);
emitLine(uProjection, vertexA, vertexB, uLineWidth);
highp uint lineEndpointIndex = getLineEndpointIndex();
highp uint vertexIndex = aVertexIndex.x * lineEndpointIndex + aVertexIndex.y * (1u - lineEndpointIndex);
`;
                builder.addFragmentCode(`
vec4 segmentColor() {
  return uColor;
}
void emitRGB(vec3 color) {
  emit(vec4(color * uColor.a, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);
}
void emitDefault() {
  emit(vec4(uColor.rgb, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);
}
`);
                builder.addFragmentCode(glsl_COLORMAPS);
                const vertexAttributes = this.vertexAttributes;

                const numAttributes = vertexAttributes.length;
                for (let i = 1; i < numAttributes; ++i) {
                    const info = vertexAttributes[i];
                    builder.addVarying(`highp ${info.glslDataType}`, `vCustom${i}`);
                    vertexMain += `vCustom${i} = readAttribute${i}(vertexIndex);\n`;
                    builder.addFragmentCode(`#define ${info.name} vCustom${i}\n`);
                }
                builder.setVertexMain(vertexMain);
                addControlsToBuilder(shaderBuilderState, builder);
                builder.setFragmentMainFunction(shaderCodeWithLineDirective(shaderBuilderState.parseResult.code));
            }
        });
        this.nodeShaderGetter = parameterizedEmitterDependentShaderGetter(this, this.gl, {
            memoizeKey: { type: 'skeleton/SkeletonShaderManager/node', vertexAttributes: this.vertexAttributes },
            fallbackParameters: this.base.fallbackShaderParameters,
            parameters: this.base.displayState.skeletonRenderingOptions.shaderControlState.builderState,
            shaderError: this.base.displayState.shaderError,
            defineShader: (builder, shaderBuilderState) => {
                if (shaderBuilderState.parseResult.errors.length !== 0) {
                    throw new Error('Invalid UI control specification');
                }
                this.defineCommonShader(builder);
                this.defineAttributeAccess(builder);
                defineCircleShader(builder, /*crossSectionFade=*/this.targetIsSliceView);
                builder.addUniform('highp float', 'uNodeDiameter');
                let vertexMain = `
highp uint vertexIndex = uint(gl_InstanceID);
highp vec3 vertexPosition = readAttribute0(vertexIndex);
emitCircle(uProjection * vec4(vertexPosition, 1.0), uNodeDiameter, 0.0);
`;
                builder.addFragmentCode(`
vec4 segmentColor() {
  return uColor;
}
void emitRGBA(vec4 color) {
  vec4 borderColor = color;
  emit(getCircleColor(color, borderColor), uPickID);
}
void emitRGB(vec3 color) {
  emitRGBA(vec4(color, 1.0));
}
void emitDefault() {
  emitRGBA(uColor);
}
`);
                builder.addFragmentCode(glsl_COLORMAPS);
                const vertexAttributes = this.vertexAttributes;

                const numAttributes = vertexAttributes.length;
                for (let i = 1; i < numAttributes; ++i) {
                    const info = vertexAttributes[i];
                    builder.addVarying(`highp ${info.glslDataType}`, `vCustom${i}`);
                    vertexMain += `vCustom${i} = readAttribute${i}(vertexIndex);\n`;
                    builder.addFragmentCode(`#define ${info.name} vCustom${i}\n`);
                }
                builder.setVertexMain(vertexMain);
                addControlsToBuilder(shaderBuilderState, builder);
                builder.setFragmentMainFunction(shaderCodeWithLineDirective(shaderBuilderState.parseResult.code));
            }
        });
    }
    get vertexAttributes() {
        return this.base.vertexAttributes;
    }
    defineCommonShader(builder) {
        defineVertexId(builder);
        builder.addUniform('highp vec4', 'uColor');
        builder.addUniform('highp mat4', 'uProjection');
        builder.addUniform('highp uint', 'uPickID');
    }
    get gl() {
        return this.base.gl;
    }
    defineAttributeAccess(builder) {
        const textureAccessHelper = this.textureAccessHelper;

        textureAccessHelper.defineShader(builder);
        const numAttributes = this.vertexAttributes.length;
        for (let j = vertexAttributeSamplerSymbols.length; j < numAttributes; ++j) {
            vertexAttributeSamplerSymbols[j] = _Symbol(`SkeletonShader.vertexAttributeTextureUnit${j}`);
        }
        this.vertexAttributes.forEach((info, i) => {
            builder.addTextureSampler(`${getSamplerPrefixForDataType(info.dataType)}sampler2D`, `uVertexAttributeSampler${i}`, vertexAttributeSamplerSymbols[i]);
            builder.addVertexCode(textureAccessHelper.getAccessor(`readAttribute${i}`, `uVertexAttributeSampler${i}`, info.dataType, info.numComponents));
        });
    }
    getCrossSectionFadeFactor() {
        if (this.targetIsSliceView) {
            return `(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))`;
        } else {
            return `(1.0)`;
        }
    }
    beginLayer(gl, shader, renderContext, modelMatrix) {
        const viewProjectionMat = renderContext.projectionParameters.viewProjectionMat;

        let mat = mat4.multiply(tempMat2, viewProjectionMat, modelMatrix);
        gl.uniformMatrix4fv(shader.uniform('uProjection'), false, mat);
        this.vertexIdHelper.enable();
    }
    setColor(gl, shader, color) {
        gl.uniform4fv(shader.uniform('uColor'), color);
    }
    setPickID(gl, shader, pickID) {
        gl.uniform1ui(shader.uniform('uPickID'), pickID);
    }
    drawSkeleton(gl, edgeShader, nodeShader, skeletonChunk, projectionParameters) {
        const vertexAttributes = this.vertexAttributes;

        const numAttributes = vertexAttributes.length;
        const vertexAttributeTextures = skeletonChunk.vertexAttributeTextures;

        for (let i = 0; i < numAttributes; ++i) {
            const textureUnit = WebGL2RenderingContext.TEXTURE0 + edgeShader.textureUnit(vertexAttributeSamplerSymbols[i]);
            gl.activeTexture(textureUnit);
            gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, vertexAttributeTextures[i]);
        }
        // Draw edges
        {
            edgeShader.bind();
            const aVertexIndex = edgeShader.attribute('aVertexIndex');
            skeletonChunk.indexBuffer.bindToVertexAttribI(aVertexIndex, 2, WebGL2RenderingContext.UNSIGNED_INT);
            gl.vertexAttribDivisor(aVertexIndex, 1);
            initializeLineShader(edgeShader, projectionParameters, this.targetIsSliceView ? 1.0 : 0.0);
            drawLines(gl, 1, skeletonChunk.numIndices / 2);
            gl.vertexAttribDivisor(aVertexIndex, 0);
            gl.disableVertexAttribArray(aVertexIndex);
        }
        if (nodeShader !== null) {
            nodeShader.bind();
            initializeCircleShader(nodeShader, projectionParameters, { featherWidthInPixels: this.targetIsSliceView ? 1.0 : 0.0 });
            drawCircles(nodeShader.gl, 2, skeletonChunk.numVertices);
        }
    }
    endLayer(gl, shader) {
        const vertexAttributes = this.vertexAttributes;

        const numAttributes = vertexAttributes.length;
        for (let i = 0; i < numAttributes; ++i) {
            let curTextureUnit = shader.textureUnit(vertexAttributeSamplerSymbols[i]) + WebGL2RenderingContext.TEXTURE0;
            gl.activeTexture(curTextureUnit);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
        this.vertexIdHelper.disable();
    }
}
export var SkeletonRenderMode;
(function (SkeletonRenderMode) {
    SkeletonRenderMode[SkeletonRenderMode["LINES"] = 0] = "LINES";
    SkeletonRenderMode[SkeletonRenderMode["LINES_AND_POINTS"] = 1] = "LINES_AND_POINTS";
})(SkeletonRenderMode || (SkeletonRenderMode = {}));
export class TrackableSkeletonRenderMode extends TrackableEnum {
    constructor(value, defaultValue = value) {
        super(SkeletonRenderMode, value, defaultValue);
    }
}
export class TrackableSkeletonLineWidth extends TrackableValue {
    constructor(value, defaultValue = value) {
        super(value, verifyFinitePositiveFloat, defaultValue);
    }
}
export class SkeletonRenderingOptions {
    constructor() {
        this.compound = new CompoundTrackable();
        this.shader = makeTrackableFragmentMain(DEFAULT_FRAGMENT_MAIN);
        this.shaderControlState = new ShaderControlState(this.shader);
        this.params2d = {
            mode: new TrackableSkeletonRenderMode(SkeletonRenderMode.LINES_AND_POINTS),
            lineWidth: new TrackableSkeletonLineWidth(2)
        };
        this.params3d = {
            mode: new TrackableSkeletonRenderMode(SkeletonRenderMode.LINES),
            lineWidth: new TrackableSkeletonLineWidth(1)
        };
        const compound = this.compound;

        compound.add('shader', this.shader);
        compound.add('shaderControls', this.shaderControlState);
        compound.add('mode2d', this.params2d.mode);
        compound.add('lineWidth2d', this.params2d.lineWidth);
        compound.add('mode3d', this.params3d.mode);
        compound.add('lineWidth3d', this.params3d.lineWidth);
    }
    get changed() {
        return this.compound.changed;
    }
    reset() {
        this.compound.reset();
    }
    restoreState(obj) {
        if (obj === undefined) return;
        this.compound.restoreState(obj);
    }
    toJSON() {
        const obj = this.compound.toJSON();
        for (const v of _Object$values(obj)) {
            if (v !== undefined) return obj;
        }
        return undefined;
    }
}
export class SkeletonLayer extends RefCounted {
    constructor(chunkManager, source, displayState) {
        super();
        this.chunkManager = chunkManager;
        this.source = source;
        this.displayState = displayState;
        this.layerChunkProgressInfo = new LayerChunkProgressInfo();
        this.redrawNeeded = new NullarySignal();
        this.fallbackShaderParameters = new WatchableValue(getFallbackBuilderState(parseShaderUiControls(DEFAULT_FRAGMENT_MAIN)));
        registerRedrawWhenSegmentationDisplayState3DChanged(displayState, this);
        this.displayState.shaderError.value = undefined;
        const renderingOptions = displayState.skeletonRenderingOptions;

        this.registerDisposer(renderingOptions.shader.changed.add(() => {
            this.displayState.shaderError.value = undefined;
            this.redrawNeeded.dispatch();
        }));
        let sharedObject = this.sharedObject = this.registerDisposer(new SegmentationLayerSharedObject(chunkManager, displayState, this.layerChunkProgressInfo));
        sharedObject.RPC_TYPE_ID = SKELETON_LAYER_RPC_ID;
        sharedObject.initializeCounterpartWithChunkManager({
            'source': source.addCounterpartRef()
        });
        const vertexAttributes = this.vertexAttributes = [vertexPositionAttribute];
        for (let _ref of source.vertexAttributes) {
            var _ref2 = _slicedToArray(_ref, 2);

            let name = _ref2[0];
            let info = _ref2[1];

            vertexAttributes.push({
                name,
                dataType: info.dataType,
                numComponents: info.numComponents,
                webglDataType: getWebglDataType(info.dataType),
                glslDataType: info.numComponents > 1 ? `vec${info.numComponents}` : 'float'
            });
        }
    }
    get visibility() {
        return this.sharedObject.visibility;
    }
    get gl() {
        return this.chunkManager.chunkQueueManager.gl;
    }
    draw(renderContext, layer, renderHelper, renderOptions, attachment) {
        let lineWidth = renderOptions.lineWidth.value;
        const gl = this.gl,
              source = this.source,
              displayState = this.displayState;

        if (displayState.objectAlpha.value <= 0.0) {
            // Skip drawing.
            return;
        }
        const modelMatrix = update3dRenderLayerAttachment(displayState.transform.value, renderContext.projectionParameters.displayDimensionRenderInfo, attachment);
        if (modelMatrix === undefined) return;
        let pointDiameter;
        if (renderOptions.mode.value === SkeletonRenderMode.LINES_AND_POINTS) {
            pointDiameter = Math.max(5, lineWidth * 2);
        } else {
            pointDiameter = lineWidth;
        }
        const edgeShaderResult = renderHelper.edgeShaderGetter(renderContext.emitter);
        const nodeShaderResult = renderHelper.nodeShaderGetter(renderContext.emitter);
        const edgeShader = edgeShaderResult.shader,
              edgeShaderParameters = edgeShaderResult.parameters;
        const nodeShader = nodeShaderResult.shader,
              nodeShaderParameters = nodeShaderResult.parameters;

        if (edgeShader === null || nodeShader === null) {
            // Shader error, skip drawing.
            return;
        }
        const shaderControlState = this.displayState.skeletonRenderingOptions.shaderControlState;

        edgeShader.bind();
        renderHelper.beginLayer(gl, edgeShader, renderContext, modelMatrix);
        setControlsInShader(gl, edgeShader, shaderControlState, edgeShaderParameters.parseResult.controls);
        gl.uniform1f(edgeShader.uniform('uLineWidth'), lineWidth);
        nodeShader.bind();
        renderHelper.beginLayer(gl, nodeShader, renderContext, modelMatrix);
        gl.uniform1f(nodeShader.uniform('uNodeDiameter'), pointDiameter);
        setControlsInShader(gl, nodeShader, shaderControlState, nodeShaderParameters.parseResult.controls);
        const skeletons = source.chunks;
        forEachVisibleSegmentToDraw(displayState, layer, renderContext.emitColor, renderContext.emitPickID ? renderContext.pickIDs : undefined, (objectId, color, pickIndex) => {
            const key = getObjectKey(objectId);
            const skeleton = skeletons.get(key);
            if (skeleton === undefined || skeleton.state !== ChunkState.GPU_MEMORY) {
                return;
            }
            if (color !== undefined) {
                edgeShader.bind();
                renderHelper.setColor(gl, edgeShader, color);
                nodeShader.bind();
                renderHelper.setColor(gl, nodeShader, color);
            }
            if (pickIndex !== undefined) {
                edgeShader.bind();
                renderHelper.setPickID(gl, edgeShader, pickIndex);
                nodeShader.bind();
                renderHelper.setPickID(gl, nodeShader, pickIndex);
            }
            renderHelper.drawSkeleton(gl, edgeShader, nodeShader, skeleton, renderContext.projectionParameters);
        });
        renderHelper.endLayer(gl, edgeShader);
    }
    isReady() {
        const source = this.source,
              displayState = this.displayState;

        if (displayState.objectAlpha.value <= 0.0) {
            // Skip drawing.
            return true;
        }
        const skeletons = source.chunks;
        let ready = true;
        forEachVisibleSegment(displayState.segmentationGroupState.value, objectId => {
            const key = getObjectKey(objectId);
            const skeleton = skeletons.get(key);
            if (skeleton === undefined || skeleton.state !== ChunkState.GPU_MEMORY) {
                ready = false;
                return;
            }
        });
        return ready;
    }
}
export class PerspectiveViewSkeletonLayer extends PerspectiveViewRenderLayer {
    constructor(base) {
        super();
        this.base = base;
        this.renderHelper = this.registerDisposer(new RenderHelper(this.base, false));
        this.renderOptions = this.base.displayState.skeletonRenderingOptions.params3d;
        this.layerChunkProgressInfo = base.layerChunkProgressInfo;
        this.registerDisposer(base);
        this.registerDisposer(base.redrawNeeded.add(this.redrawNeeded.dispatch));
        const renderOptions = this.renderOptions;

        this.registerDisposer(renderOptions.mode.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(renderOptions.lineWidth.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(base.visibility.add(this.visibility));
    }
    get gl() {
        return this.base.gl;
    }
    get isTransparent() {
        return this.base.displayState.objectAlpha.value < 1.0;
    }
    draw(renderContext, attachment) {
        if (!renderContext.emitColor && renderContext.alreadyEmittedPickID) {
            // No need for a separate pick ID pass.
            return;
        }
        this.base.draw(renderContext, this, this.renderHelper, this.renderOptions, attachment);
    }
    isReady() {
        return this.base.isReady();
    }
}
export class SliceViewPanelSkeletonLayer extends SliceViewPanelRenderLayer {
    constructor(base) {
        super();
        this.base = base;
        this.renderHelper = this.registerDisposer(new RenderHelper(this.base, true));
        this.renderOptions = this.base.displayState.skeletonRenderingOptions.params2d;
        this.layerChunkProgressInfo = base.layerChunkProgressInfo;
        this.registerDisposer(base);
        const renderOptions = this.renderOptions;

        this.registerDisposer(renderOptions.mode.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(renderOptions.lineWidth.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(base.redrawNeeded.add(this.redrawNeeded.dispatch));
        this.registerDisposer(base.visibility.add(this.visibility));
    }
    get gl() {
        return this.base.gl;
    }
    draw(renderContext, attachment) {
        this.base.draw(renderContext, this, this.renderHelper, this.renderOptions, attachment);
    }
    isReady() {
        return this.base.isReady();
    }
}
function getWebglDataType(dataType) {
    switch (dataType) {
        case DataType.FLOAT32:
            return WebGL2RenderingContext.FLOAT;
        default:
            throw new Error(`Data type not supported by WebGL: ${DataType[dataType]}`);
    }
}
const vertexPositionAttribute = {
    dataType: DataType.FLOAT32,
    numComponents: 3,
    name: '',
    webglDataType: WebGL2RenderingContext.FLOAT,
    glslDataType: 'vec3'
};
export class SkeletonChunk extends Chunk {
    constructor(source, x) {
        super(source);
        this.vertexAttributes = x['vertexAttributes'];
        let indices = this.indices = x['indices'];
        this.numVertices = x['numVertices'];
        this.vertexAttributeOffsets = x['vertexAttributeOffsets'];
        this.numIndices = indices.length;
    }
    copyToGPU(gl) {
        super.copyToGPU(gl);
        const attributeTextureFormats = this.source.attributeTextureFormats;
        const vertexAttributes = this.vertexAttributes,
              vertexAttributeOffsets = this.vertexAttributeOffsets;

        const vertexAttributeTextures = this.vertexAttributeTextures = [];
        for (let i = 0, numAttributes = vertexAttributeOffsets.length; i < numAttributes; ++i) {
            const texture = gl.createTexture();
            gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
            setOneDimensionalTextureData(gl, attributeTextureFormats[i], vertexAttributes.subarray(vertexAttributeOffsets[i], i + 1 !== numAttributes ? vertexAttributeOffsets[i + 1] : vertexAttributes.length));
            vertexAttributeTextures[i] = texture;
        }
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
        this.indexBuffer = Buffer.fromData(gl, this.indices, WebGL2RenderingContext.ARRAY_BUFFER, WebGL2RenderingContext.STATIC_DRAW);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        const vertexAttributeTextures = this.vertexAttributeTextures;

        for (const texture of vertexAttributeTextures) {
            gl.deleteTexture(texture);
        }
        vertexAttributeTextures.length = 0;
        this.indexBuffer.dispose();
    }
}
const emptyVertexAttributes = new _Map();
function getAttributeTextureFormats(vertexAttributes) {
    const attributeTextureFormats = [vertexPositionTextureFormat];
    for (const info of vertexAttributes.values()) {
        attributeTextureFormats.push(computeTextureFormat(new TextureFormat(), info.dataType, info.numComponents));
    }
    return attributeTextureFormats;
}
export class SkeletonSource extends ChunkSource {
    constructor(chunkManager, options) {
        super(chunkManager, options);
    }
    get attributeTextureFormats() {
        let attributeTextureFormats = this.attributeTextureFormats_;
        if (attributeTextureFormats === undefined) {
            attributeTextureFormats = this.attributeTextureFormats_ = getAttributeTextureFormats(this.vertexAttributes);
        }
        return attributeTextureFormats;
    }
    getChunk(x) {
        return new SkeletonChunk(this, x);
    }
    get vertexAttributes() {
        return emptyVertexAttributes;
    }
}
//# sourceMappingURL=frontend.js.map