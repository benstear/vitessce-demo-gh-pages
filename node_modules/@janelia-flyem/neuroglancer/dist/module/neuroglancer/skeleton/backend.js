import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
import { Chunk, ChunkRenderLayerBackend, ChunkSource, withChunkManager } from "../chunk_manager/backend";
import { ChunkState } from "../chunk_manager/base";
import { decodeVertexPositionsAndIndices } from "../mesh/backend";
import { withSegmentationLayerBackendState } from "../segmentation_display_state/backend";
import { forEachVisibleSegment, getObjectKey } from "../segmentation_display_state/base";
import { SKELETON_LAYER_RPC_ID } from "./base";
import { Uint64 } from "../util/uint64";
import { getBasePriority, getPriorityTier } from "../visibility_priority/backend";
import { withSharedVisibility } from "../visibility_priority/backend";
import { registerSharedObject } from "../worker_rpc";
const SKELETON_CHUNK_PRIORITY = 60;
// Chunk that contains the skeleton of a single object.
export class SkeletonChunk extends Chunk {
    constructor() {
        super();
        this.objectId = new Uint64();
        this.vertexPositions = null;
        this.vertexAttributes = null;
        this.indices = null;
    }
    initializeSkeletonChunk(key, objectId) {
        super.initialize(key);
        this.objectId.assign(objectId);
    }
    freeSystemMemory() {
        this.vertexPositions = this.indices = null;
    }
    getVertexAttributeBytes() {
        let total = this.vertexPositions.byteLength;
        const vertexAttributes = this.vertexAttributes;

        if (vertexAttributes != null) {
            vertexAttributes.forEach(a => {
                total += a.byteLength;
            });
        }
        return total;
    }
    serialize(msg, transfers) {
        super.serialize(msg, transfers);
        const vertexPositions = this.vertexPositions;
        const indices = this.indices;
        msg['numVertices'] = vertexPositions.length / 3;
        msg['indices'] = indices;
        transfers.push(indices.buffer);
        const vertexAttributes = this.vertexAttributes;

        if (vertexAttributes != null && vertexAttributes.length > 0) {
            const vertexData = new Uint8Array(this.getVertexAttributeBytes());
            vertexData.set(new Uint8Array(vertexPositions.buffer, vertexPositions.byteOffset, vertexPositions.byteLength));
            let vertexAttributeOffsets = msg['vertexAttributeOffsets'] = new Uint32Array(vertexAttributes.length + 1);
            vertexAttributeOffsets[0] = 0;
            let offset = vertexPositions.byteLength;
            vertexAttributes.forEach((a, i) => {
                vertexAttributeOffsets[i + 1] = offset;
                vertexData.set(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), offset);
                offset += a.byteLength;
            });
            transfers.push(vertexData.buffer);
            msg['vertexAttributes'] = vertexData;
        } else {
            msg['vertexAttributes'] = new Uint8Array(vertexPositions.buffer, vertexPositions.byteOffset, vertexPositions.byteLength);
            msg['vertexAttributeOffsets'] = Uint32Array.of(0);
            if (vertexPositions.buffer !== transfers[0]) {
                transfers.push(vertexPositions.buffer);
            }
        }
        this.vertexPositions = this.indices = this.vertexAttributes = null;
    }
    downloadSucceeded() {
        this.systemMemoryBytes = this.gpuMemoryBytes = this.indices.byteLength + this.getVertexAttributeBytes();
        super.downloadSucceeded();
    }
}
export class SkeletonSource extends ChunkSource {
    getChunk(objectId) {
        const key = getObjectKey(objectId);
        let chunk = this.chunks.get(key);
        if (chunk === undefined) {
            chunk = this.getNewChunk_(SkeletonChunk);
            chunk.initializeSkeletonChunk(key, objectId);
            this.addChunk(chunk);
        }
        return chunk;
    }
}
let SkeletonLayer = class SkeletonLayer extends withSegmentationLayerBackendState(withSharedVisibility(withChunkManager(ChunkRenderLayerBackend))) {
    constructor(rpc, options) {
        super(rpc, options);
        this.source = this.registerDisposer(rpc.getRef(options['source']));
        this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => {
            this.updateChunkPriorities();
        }));
    }
    updateChunkPriorities() {
        const visibility = this.visibility.value;
        if (visibility === Number.NEGATIVE_INFINITY) {
            return;
        }
        this.chunkManager.registerLayer(this);
        const priorityTier = getPriorityTier(visibility);
        const basePriority = getBasePriority(visibility);
        const source = this.source,
              chunkManager = this.chunkManager;

        forEachVisibleSegment(this, objectId => {
            const chunk = source.getChunk(objectId);
            ++this.numVisibleChunksNeeded;
            if (chunk.state === ChunkState.GPU_MEMORY) {
                ++this.numVisibleChunksAvailable;
            }
            chunkManager.requestChunk(chunk, priorityTier, basePriority + SKELETON_CHUNK_PRIORITY);
        });
    }
};
SkeletonLayer = __decorate([registerSharedObject(SKELETON_LAYER_RPC_ID)], SkeletonLayer);
export { SkeletonLayer };
/**
 * Extracts vertex positions and edge vertex indices of the specified endianness from `data'.
 *
 * See documentation of decodeVertexPositionsAndIndices.
 */
export function decodeSkeletonVertexPositionsAndIndices(chunk, data, endianness, vertexByteOffset, numVertices, indexByteOffset, numEdges) {
    const meshData = decodeVertexPositionsAndIndices(
    /*verticesPerPrimitive=*/2, data, endianness, vertexByteOffset, numVertices, indexByteOffset, numEdges);
    chunk.vertexPositions = meshData.vertexPositions;
    chunk.indices = meshData.indices;
}
//# sourceMappingURL=backend.js.map