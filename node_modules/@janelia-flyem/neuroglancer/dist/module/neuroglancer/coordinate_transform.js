import _Set from 'babel-runtime/core-js/set';
import _Number$isInteger from 'babel-runtime/core-js/number/is-integer';
import _Number$isFinite from 'babel-runtime/core-js/number/is-finite';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Array$from from 'babel-runtime/core-js/array/from';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { WatchableValue } from './trackable_value';
import { arraysEqual, arraysEqualWithPredicate, getInsertPermutation } from './util/array';
import { getDependentTransformInputDimensions, mat4, quat, vec3 } from './util/geom';
import { expectArray, parseArray, parseFiniteVec, parseFixedLengthArray, verifyFiniteFloat, verifyFinitePositiveFloat, verifyIntegerArray, verifyObject, verifyObjectProperty, verifyOptionalObjectProperty, verifyString, verifyStringArray } from './util/json';
import * as matrix from './util/matrix';
import { scaleByExp10, supportedUnits, unitFromJson } from './util/si_units';
import { NullarySignal } from './util/signal';
import * as vector from './util/vector';
let nextDimensionId = 0;
export function newDimensionId() {
    return ++nextDimensionId;
}
export function boundingBoxesEqual(a, b) {
    return arraysEqual(a.lowerBounds, b.lowerBounds) && arraysEqual(a.upperBounds, b.upperBounds);
}
export function coordinateArraysEqual(a, b) {
    if (a === undefined) return b === undefined;
    if (b === undefined) return false;
    return a.explicit === b.explicit && arraysEqual(a.coordinates, b.coordinates) && arraysEqual(a.labels, b.labels);
}
export function normalizeCoordinateArray(coordinates, labels) {
    const map = new _Map();
    for (let i = 0, length = coordinates.length; i < length; ++i) {
        map.set(coordinates[i], labels[i]);
    }
    coordinates = _Array$from(map.keys());
    coordinates.sort((a, b) => a - b);
    labels = _Array$from(coordinates, x => map.get(x));
    return { coordinates, labels };
}
export function mergeCoordinateArrays(coordinateArrays) {
    if (coordinateArrays.length === 1) return coordinateArrays[0];
    const map = new _Map();
    let explicit = false;
    for (const x of coordinateArrays) {
        if (x.explicit) explicit = true;
        const coordinates = x.coordinates,
              labels = x.labels;

        for (let i = 0, length = coordinates.length; i < length; ++i) {
            map.set(coordinates[i], labels[i]);
        }
    }
    const coordinates = _Array$from(map.keys());
    coordinates.sort((a, b) => a - b);
    const labels = _Array$from(coordinates, x => map.get(x));
    return { explicit, coordinates, labels };
}
export function mergeOptionalCoordinateArrays(coordinateArrays) {
    coordinateArrays = coordinateArrays.filter(x => x !== undefined);
    if (coordinateArrays.length === 0) return undefined;
    return mergeCoordinateArrays(coordinateArrays);
}
export function transformedBoundingBoxesEqual(a, b) {
    return arraysEqual(a.transform, b.transform) && boundingBoxesEqual(a.box, b.box);
}
export function coordinateSpacesEqual(a, b) {
    return a.valid === b.valid && a.rank === b.rank && arraysEqual(a.names, b.names) && arraysEqual(a.ids, b.ids) && arraysEqual(a.timestamps, b.timestamps) && arraysEqual(a.units, b.units) && arraysEqual(a.scales, b.scales) && arraysEqualWithPredicate(a.boundingBoxes, b.boundingBoxes, transformedBoundingBoxesEqual) && arraysEqualWithPredicate(a.coordinateArrays, b.coordinateArrays, coordinateArraysEqual);
}
export function unitsFromJson(units, scaleExponents, obj) {
    parseFixedLengthArray(units, obj, (x, index) => {
        const result = unitFromJson(x);
        scaleExponents[index] = result.exponent;
        return result.unit;
    });
}
export function makeCoordinateSpace(space) {
    const names = space.names,
          units = space.units,
          scales = space.scales;
    var _space$valid = space.valid;
    const valid = _space$valid === undefined ? true : _space$valid;
    var _space$rank = space.rank;
    const rank = _space$rank === undefined ? names.length : _space$rank;
    var _space$timestamps = space.timestamps;
    const timestamps = _space$timestamps === undefined ? names.map(() => Number.NEGATIVE_INFINITY) : _space$timestamps;
    var _space$ids = space.ids;
    const ids = _space$ids === undefined ? names.map((_, i) => -i) : _space$ids;
    var _space$boundingBoxes = space.boundingBoxes;
    const boundingBoxes = _space$boundingBoxes === undefined ? [] : _space$boundingBoxes;
    var _space$coordinateArra = space.coordinateArrays;
    const coordinateArrays = _space$coordinateArra === undefined ? new Array(rank) : _space$coordinateArra;
    var _space$bounds = space.bounds;
    const bounds = _space$bounds === undefined ? computeCombinedBounds(boundingBoxes, rank) : _space$bounds;

    return {
        valid,
        rank,
        names,
        timestamps,
        ids,
        units,
        scales,
        boundingBoxes,
        bounds,
        coordinateArrays
    };
}
export const emptyInvalidCoordinateSpace = makeCoordinateSpace({
    valid: false,
    names: [],
    units: [],
    scales: vector.kEmptyFloat64Vec,
    boundingBoxes: []
});
export const emptyValidCoordinateSpace = makeCoordinateSpace({
    valid: true,
    names: [],
    units: [],
    scales: vector.kEmptyFloat64Vec,
    boundingBoxes: []
});
function unitAndScaleFromJson(obj) {
    var _expectArray = expectArray(obj, 2),
        _expectArray2 = _slicedToArray(_expectArray, 2);

    const scaleObj = _expectArray2[0],
          unitObj = _expectArray2[1];

    const scale = verifyFinitePositiveFloat(scaleObj);
    const unitString = verifyString(unitObj);
    const result = supportedUnits.get(unitString);
    if (result === undefined) throw new Error(`Invalid unit: ${_JSON$stringify(unitString)}`);
    return { unit: result.unit, scale: scaleByExp10(scale, result.exponent) };
}
export function coordinateSpaceFromJson(obj, allowNumericalDimensions = false) {
    if (obj === undefined) return emptyInvalidCoordinateSpace;
    verifyObject(obj);
    const names = dimensionNamesFromJson(_Object$keys(obj), allowNumericalDimensions);
    const rank = names.length;
    const units = new Array(rank);
    const scales = new Float64Array(rank);
    const coordinateArrays = new Array(rank);
    for (let i = 0; i < rank; ++i) {
        verifyObjectProperty(obj, names[i], mem => {
            if (Array.isArray(mem)) {
                // Normal unit-scale dimension.
                var _unitAndScaleFromJson = unitAndScaleFromJson(mem);

                const unit = _unitAndScaleFromJson.unit,
                      scale = _unitAndScaleFromJson.scale;

                units[i] = unit;
                scales[i] = scale;
            } else {
                // Coordinate array dimension.
                verifyObject(mem);
                let coordinates = verifyObjectProperty(mem, 'coordinates', verifyIntegerArray);
                let labels = verifyObjectProperty(mem, 'labels', verifyStringArray);
                let length = coordinates.length;
                if (length !== labels.length) {
                    throw new Error(`Length of coordinates array (${length}) ` + `does not match length of labels array (${labels.length})`);
                }
                units[i] = '';
                scales[i] = 1;
                coordinateArrays[i] = _Object$assign({ explicit: true }, normalizeCoordinateArray(coordinates, labels));
            }
        });
    }
    return makeCoordinateSpace({ valid: false, names, units, scales, coordinateArrays });
}
export function coordinateSpaceToJson(coordinateSpace) {
    const rank = coordinateSpace.rank;

    if (rank === 0) return undefined;
    const names = coordinateSpace.names,
          units = coordinateSpace.units,
          scales = coordinateSpace.scales,
          coordinateArrays = coordinateSpace.coordinateArrays;

    const json = {};
    for (let i = 0; i < rank; ++i) {
        const name = names[i];
        const coordinateArray = coordinateArrays[i];
        if (coordinateArray === null || coordinateArray === void 0 ? void 0 : coordinateArray.explicit) {
            json[name] = {
                coordinates: _Array$from(coordinateArray.coordinates),
                labels: coordinateArray.labels
            };
        } else {
            json[name] = [scales[i], units[i]];
        }
    }
    return json;
}
export class TrackableCoordinateSpace extends WatchableValue {
    constructor() {
        super(emptyInvalidCoordinateSpace);
    }
    toJSON() {
        return coordinateSpaceToJson(this.value);
    }
    reset() {
        this.value = emptyInvalidCoordinateSpace;
    }
    restoreState(obj) {
        this.value = coordinateSpaceFromJson(obj);
    }
}
export function getCenterBound(lower, upper) {
    let x = (lower + upper) / 2;
    if (!_Number$isFinite(x)) x = Math.min(Math.max(0, lower), upper);
    return x;
}
export function getBoundingBoxCenter(out, bounds) {
    const lowerBounds = bounds.lowerBounds,
          upperBounds = bounds.upperBounds;

    const rank = out.length;
    for (let i = 0; i < rank; ++i) {
        out[i] = getCenterBound(lowerBounds[i], upperBounds[i]);
    }
    return out;
}
export function makeIdentityTransformedBoundingBox(box) {
    const rank = box.lowerBounds.length;
    return { box, transform: matrix.createIdentity(Float64Array, rank, rank + 1) };
}
export function computeCombinedLowerUpperBound(boundingBox, outputDimension, outputRank) {
    var _boundingBox$box = boundingBox.box;
    const baseLowerBounds = _boundingBox$box.lowerBounds,
          baseUpperBounds = _boundingBox$box.upperBounds,
          transform = boundingBox.transform;

    const inputRank = baseLowerBounds.length;
    const stride = outputRank;
    const offset = transform[stride * inputRank + outputDimension];
    let targetLower = offset,
        targetUpper = offset;
    let hasCoefficient = false;
    for (let inputDim = 0; inputDim < inputRank; ++inputDim) {
        let c = transform[stride * inputDim + outputDimension];
        if (c === 0) continue;
        const lower = c * baseLowerBounds[inputDim];
        const upper = c * baseUpperBounds[inputDim];
        targetLower += Math.min(lower, upper);
        targetUpper += Math.max(lower, upper);
        hasCoefficient = true;
    }
    if (!hasCoefficient) return undefined;
    return { lower: targetLower, upper: targetUpper };
}
export function computeCombinedBounds(boundingBoxes, outputRank) {
    const lowerBounds = new Float64Array(outputRank);
    const upperBounds = new Float64Array(outputRank);
    lowerBounds.fill(Number.NEGATIVE_INFINITY);
    upperBounds.fill(Number.POSITIVE_INFINITY);
    for (const boundingBox of boundingBoxes) {
        for (let outputDim = 0; outputDim < outputRank; ++outputDim) {
            const result = computeCombinedLowerUpperBound(boundingBox, outputDim, outputRank);
            if (result === undefined) continue;
            const targetLower = result.lower,
                  targetUpper = result.upper;

            lowerBounds[outputDim] = lowerBounds[outputDim] === Number.NEGATIVE_INFINITY ? targetLower : Math.min(lowerBounds[outputDim], targetLower);
            upperBounds[outputDim] = upperBounds[outputDim] === Number.POSITIVE_INFINITY ? targetUpper : Math.max(upperBounds[outputDim], targetUpper);
        }
    }
    return { lowerBounds, upperBounds };
}
export function extendTransformedBoundingBox(boundingBox, newOutputRank, newOutputDims) {
    const oldTransform = boundingBox.transform,
          box = boundingBox.box;

    const oldOutputRank = newOutputDims.length;
    const inputRank = box.lowerBounds.length;
    const newTransform = new Float64Array((inputRank + 1) * newOutputRank);
    for (let oldOutputDim = 0; oldOutputDim < oldOutputRank; ++oldOutputDim) {
        const newOutputDim = newOutputDims[oldOutputDim];
        if (newOutputDim === -1) continue;
        for (let inputDim = 0; inputDim <= inputRank; ++inputDim) {
            newTransform[inputDim * newOutputRank + newOutputDim] = oldTransform[inputDim * oldOutputRank + oldOutputDim];
        }
    }
    return {
        transform: newTransform,
        box
    };
}
export function makeSingletonDimTransformedBoundingBox(outputRank, outputDim) {
    const box = { lowerBounds: Float64Array.of(0), upperBounds: Float64Array.of(1) };
    const transform = new Float64Array(2 * outputRank);
    transform[outputDim] = 1;
    return { transform, box };
}
export function extendTransformedBoundingBoxUpToRank(boundingBox, oldOutputRank, newOutputRank) {
    if (oldOutputRank === newOutputRank) return boundingBox;
    const box = boundingBox.box;

    const inputRank = box.lowerBounds.length;
    const transform = new Float64Array((inputRank + 1) * newOutputRank);
    matrix.copy(transform, newOutputRank, boundingBox.transform, oldOutputRank, oldOutputRank, inputRank + 1);
    return { box, transform };
}
export function coordinateSpaceTransformsEquivalent(defaultTransform, transform) {
    const rank = defaultTransform.rank,
          sourceRank = defaultTransform.sourceRank;

    if (rank !== transform.rank || sourceRank !== transform.sourceRank) return false;
    const defaultInputSpace = defaultTransform.inputSpace;
    const inputSpace = transform.inputSpace;

    if (!arraysEqual(inputSpace.scales, defaultInputSpace.scales) || !arraysEqual(inputSpace.units, defaultInputSpace.units) || !arraysEqual(transform.outputSpace.names, defaultTransform.outputSpace.names)) {
        return false;
    }
    return isTransformDerivableFromDefault(defaultTransform.transform, rank, defaultTransform.outputSpace.scales, transform.transform, rank, transform.outputSpace.scales);
}
export function makeIdentityTransform(inputSpace) {
    return {
        rank: inputSpace.rank,
        sourceRank: inputSpace.rank,
        inputSpace,
        outputSpace: inputSpace,
        transform: matrix.createIdentity(Float64Array, inputSpace.rank + 1)
    };
}
function transformBoundingBox(boundingBox, transform, sourceScales, targetScales) {
    let oldBoxTransform = boundingBox.transform,
        box = boundingBox.box;

    const inputRank = boundingBox.box.lowerBounds.length;
    const targetRank = targetScales.length;
    // transform is a column-major homogeneous `(rows=targetRank+1, cols=targetRank+1)` matrix.
    // oldBoxTransform is a column-major `(rows=targetRank, cols=inputRank+1)` matrix.
    // newBoxTransform is a column-major `(rows=targetRank, cols=inputRank+1)` matrix.
    const newBoxTransform = new Float64Array((inputRank + 1) * targetRank);
    for (let targetDim = 0; targetDim < targetRank; ++targetDim) {
        const targetScale = targetScales[targetDim];
        // Compute the rotation/scaling components
        for (let inputDim = 0; inputDim < inputRank; ++inputDim) {
            let sum = 0;
            for (let sourceDim = 0; sourceDim < targetRank; ++sourceDim) {
                const sourceScale = sourceScales[sourceDim];
                sum += transform[(targetRank + 1) * sourceDim + targetDim] * oldBoxTransform[targetRank * inputDim + sourceDim] * (sourceScale / targetScale);
            }
            newBoxTransform[targetRank * inputDim + targetDim] = sum;
        }
        // Compute the translation component
        let sum = transform[(targetRank + 1) * targetRank + targetDim];
        for (let sourceDim = 0; sourceDim < targetRank; ++sourceDim) {
            const sourceScale = sourceScales[sourceDim];
            sum += transform[(targetRank + 1) * sourceDim + targetDim] * oldBoxTransform[targetRank * inputRank + sourceDim] * (sourceScale / targetScale);
        }
        newBoxTransform[inputRank * targetRank + targetDim] = sum;
    }
    return {
        transform: newBoxTransform,
        box
    };
}
function getTransformedBoundingBoxes(inputSpace, transform, outputScales) {
    return inputSpace.boundingBoxes.map(boundingBox => transformBoundingBox(boundingBox, transform, inputSpace.scales, outputScales));
}
export function getOutputSpaceWithTransformedBoundingBoxes(inputSpace, transform, oldOutputSpace) {
    const newSpace = makeCoordinateSpace({
        valid: inputSpace.valid,
        rank: oldOutputSpace.rank,
        ids: oldOutputSpace.ids,
        names: oldOutputSpace.names,
        timestamps: oldOutputSpace.timestamps,
        scales: oldOutputSpace.scales,
        units: oldOutputSpace.units,
        boundingBoxes: getTransformedBoundingBoxes(inputSpace, transform, oldOutputSpace.scales),
        coordinateArrays: oldOutputSpace.coordinateArrays
    });
    if (coordinateSpacesEqual(newSpace, oldOutputSpace)) return oldOutputSpace;
    return newSpace;
}
export function isValidDimensionName(name, allowNumericalNames = false) {
    if (allowNumericalNames) {
        const n = Number(name);
        if (_Number$isInteger(n) && n >= 0) return true;
    }
    return name.match(/^[a-zA-Z][a-zA-Z_0-9]*['^]?$/) !== null;
}
export function validateDimensionNames(names, allowNumericalNames = false) {
    const seenNames = new _Set();
    for (const name of names) {
        if (!isValidDimensionName(name, allowNumericalNames)) return false;
        if (seenNames.has(name)) return false;
        seenNames.add(name);
    }
    return true;
}
export function getDimensionNameValidity(names) {
    const rank = names.length;
    const isValid = new Array(rank);
    isValid.fill(true);
    for (let i = 0; i < rank; ++i) {
        const name = names[i];
        if (!isValidDimensionName(name)) {
            isValid[i] = false;
            continue;
        }
        const otherIndex = names.indexOf(name, i + 1);
        if (otherIndex !== -1) {
            isValid[i] = false;
            isValid[otherIndex] = false;
        }
    }
    return isValid;
}
export function isLocalDimension(name) {
    return name.endsWith('\'');
}
export function isLocalOrChannelDimension(name) {
    return name.endsWith('\'') || name.endsWith('^');
}
export function isChannelDimension(name) {
    return name.endsWith('^');
}
export function isGlobalDimension(name) {
    return !isLocalOrChannelDimension(name);
}
export function convertTransformOutputScales(existingTransform, existingOutputScales, newOutputScales) {
    const newTransform = new Float64Array(existingTransform);
    const rank = existingOutputScales.length;
    const baseIndex = (rank + 1) * rank;
    for (let i = 0; i < rank; ++i) {
        newTransform[baseIndex + i] *= existingOutputScales[i] / newOutputScales[i];
    }
    return newTransform;
}
function isTransformDerivableFromDefault(defaultTransform, defaultRank, defaultOutputScales, newTransform, newRank, newOutputScales) {
    // Verify that matched linear portion is equal.
    if (!matrix.equal(defaultTransform, defaultRank + 1, newTransform, newRank + 1, defaultRank, defaultRank)) return false;
    // Verify that common translation is equivalent.
    for (let i = 0; i < defaultRank; ++i) {
        const aValue = defaultTransform[(defaultRank + 1) * defaultRank + i];
        const bValue = newTransform[(newRank + 1) * newRank + i];
        if (aValue * (defaultOutputScales[i] / newOutputScales[i]) !== bValue) return false;
    }
    // Verify that extended translation is 0.
    for (let i = defaultRank; i < newRank; ++i) {
        if (newTransform[(newRank + 1) * newRank + i] !== 0) return false;
    }
    // Verify that extended linear portion is identity.
    for (let i = defaultRank; i < newRank; ++i) {
        for (let j = 0; j < defaultRank; ++j) {
            if (newTransform[(newRank + 1) * j + i] !== 0) return false;
        }
        for (let j = 0; j < newRank; ++j) {
            const coeff = newTransform[(newRank + 1) * i + j];
            if (i === j) {
                if (coeff !== 1) return false;
            } else {
                if (coeff !== 0) return false;
            }
        }
    }
    return true;
}
export function makeDimensionNameUnique(name, existingNames) {
    if (!existingNames.includes(name)) return name;

    var _name$match = name.match(/^([^']*)('?)$/),
        _name$match2 = _slicedToArray(_name$match, 3);

    const prefix = _name$match2[1],
          suffix = _name$match2[2];

    for (let i = 0;; ++i) {
        const newName = `${prefix}${i}${suffix}`;
        if (!existingNames.includes(newName)) return newName;
    }
}
export function remapTransformInputSpace(old, inputSpace) {
    const oldInputSpace = old.inputSpace,
          oldTransform = old.transform;
    const oldInputDimensionIds = oldInputSpace.ids,
          oldRank = oldInputSpace.rank;
    const newRank = inputSpace.rank,
          newInputDimensionNames = inputSpace.names,
          newInputUnits = inputSpace.units,
          newInputScales = inputSpace.scales;

    const removedOldInputIndices = new Array(oldRank);
    removedOldInputIndices.fill(true);
    const addedInputDimensionIndices = [];
    const newToOldInputDimensionIndices = inputSpace.ids.map((id, i) => {
        const oldIndex = oldInputDimensionIds.indexOf(id);
        if (oldIndex !== -1) {
            removedOldInputIndices[oldIndex] = false;
        } else {
            addedInputDimensionIndices.push(i);
        }
        return oldIndex;
    });
    const oldOutputSpace = old.outputSpace;
    const oldOutputDimensionNames = oldOutputSpace.names,
          oldOutputUnits = oldOutputSpace.units,
          oldOutputScales = oldOutputSpace.scales,
          oldOutputDimensionIds = oldOutputSpace.ids,
          oldOutputTimestamps = oldOutputSpace.timestamps,
          oldOutputCoordinateArrays = oldOutputSpace.coordinateArrays;
    // For now just use a simple mapping.

    const removedOldOutputIndices = removedOldInputIndices;
    const outputDimensionNames = [];
    const outputUnits = [];
    const outputScales = new Float64Array(newRank);
    const outputDimensionIds = [];
    const outputDimensionTimestamps = [];
    const outputCoordinateArrays = new Array(newRank);
    let newOutputDim = 0;
    const newTransform = new Float64Array((newRank + 1) ** 2);
    newTransform[newTransform.length - 1] = 1;
    for (let oldOutputDim = 0; oldOutputDim < oldRank; ++oldOutputDim) {
        if (removedOldOutputIndices[oldOutputDim]) continue;
        outputDimensionNames[newOutputDim] = oldOutputDimensionNames[oldOutputDim];
        outputDimensionIds[newOutputDim] = oldOutputDimensionIds[oldOutputDim];
        outputUnits[newOutputDim] = oldOutputUnits[oldOutputDim];
        outputScales[newOutputDim] = oldOutputScales[oldOutputDim];
        outputDimensionTimestamps[newOutputDim] = oldOutputTimestamps[oldOutputDim];
        outputCoordinateArrays[newOutputDim] = oldOutputCoordinateArrays[oldOutputDim];
        for (let newInputDim = 0; newInputDim < newRank; ++newInputDim) {
            const oldInputDim = newToOldInputDimensionIndices[newInputDim];
            if (oldInputDim === -1) continue;
            newTransform[newInputDim * (newRank + 1) + newOutputDim] = oldTransform[oldInputDim * (oldRank + 1) + oldOutputDim];
        }
        newTransform[newRank * (newRank + 1) + newOutputDim] = oldTransform[oldRank * (oldRank + 1) + oldOutputDim];
        ++newOutputDim;
    }
    for (const newInputDim of addedInputDimensionIndices) {
        outputDimensionIds[newOutputDim] = newDimensionId();
        outputDimensionNames[newOutputDim] = makeDimensionNameUnique(newInputDimensionNames[newInputDim], outputDimensionNames);
        outputScales[newOutputDim] = newInputScales[newInputDim];
        outputUnits[newOutputDim] = newInputUnits[newInputDim];
        newTransform[newInputDim * (newRank + 1) + newOutputDim] = 1;
        ++newOutputDim;
    }
    const outputSpace = makeCoordinateSpace({
        valid: inputSpace.valid,
        rank: newRank,
        names: outputDimensionNames,
        ids: outputDimensionIds,
        timestamps: outputDimensionTimestamps,
        units: outputUnits,
        scales: outputScales,
        boundingBoxes: getTransformedBoundingBoxes(inputSpace, newTransform, outputScales),
        coordinateArrays: outputCoordinateArrays
    });
    return {
        rank: newRank,
        sourceRank: old.sourceRank,
        inputSpace,
        outputSpace,
        transform: newTransform
    };
}
function normalizeCoordinateSpaceTransform(value) {
    const outputSpace = getOutputSpaceWithTransformedBoundingBoxes(value.inputSpace, value.transform, value.outputSpace);
    if (outputSpace === value.outputSpace) return value;
    return {
        rank: value.rank,
        sourceRank: value.sourceRank,
        inputSpace: value.inputSpace,
        transform: value.transform,
        outputSpace
    };
}
export class WatchableCoordinateSpaceTransform {
    constructor(defaultTransform, mutableSourceRank = false) {
        this.mutableSourceRank = mutableSourceRank;
        this.value_ = undefined;
        this.changed = new NullarySignal();
        this.inputSpaceChanged = new NullarySignal();
        this.defaultTransform = normalizeCoordinateSpaceTransform(defaultTransform);
        const self = this;
        this.outputSpace = {
            changed: self.changed,
            get value() {
                return self.value.outputSpace;
            },
            set value(newOutputSpace) {
                const value = self.value;

                if (coordinateSpacesEqual(value.outputSpace, newOutputSpace)) return;
                if (value.rank !== newOutputSpace.rank) return;
                const transform = convertTransformOutputScales(value.transform, value.outputSpace.scales, newOutputSpace.scales);
                self.value_ = {
                    sourceRank: value.sourceRank,
                    rank: value.rank,
                    inputSpace: value.inputSpace,
                    outputSpace: getOutputSpaceWithTransformedBoundingBoxes(value.inputSpace, transform, newOutputSpace),
                    transform
                };
                self.changed.dispatch();
            }
        };
        this.inputSpace = {
            changed: self.inputSpaceChanged,
            get value() {
                return self.value.inputSpace;
            },
            set value(newInputSpace) {
                const value = self.value;

                if (coordinateSpacesEqual(value.inputSpace, newInputSpace)) return;
                self.value_ = remapTransformInputSpace(value, newInputSpace);
                self.inputSpaceChanged.dispatch();
                self.changed.dispatch();
            }
        };
    }
    set value(value) {
        const existingValue = this.value;
        if (value === existingValue) return;
        this.value_ = normalizeCoordinateSpaceTransform(value);
        if (value.inputSpace !== existingValue.inputSpace) {
            this.inputSpaceChanged.dispatch();
        }
        this.changed.dispatch();
    }
    get value() {
        let value = this.value_;

        if (value === undefined) {
            value = this.value_ = this.defaultTransform;
        }
        return value;
    }
    reset() {
        if (this.value_ === this.defaultTransform) return;
        this.value_ = this.defaultTransform;
        this.inputSpaceChanged.dispatch();
        this.changed.dispatch();
    }
    get defaultInputSpace() {
        return this.defaultTransform.inputSpace;
    }
    get spec() {
        const value = this.value;
        const rank = value.rank,
              transform = value.transform,
              inputSpace = value.inputSpace,
              outputSpace = value.outputSpace,
              sourceRank = value.sourceRank;
        const defaultTransform = this.defaultTransform,
              mutableSourceRank = this.mutableSourceRank;
        const defaultInputSpace = defaultTransform.inputSpace,
              defaultRank = defaultTransform.rank,
              defaultTransformMatrix = defaultTransform.transform,
              defaultOutputSpace = defaultTransform.outputSpace;
        const units = inputSpace.units,
              scales = inputSpace.scales;

        const inputSpaceSame = sourceRank === rank && arraysEqual(scales, mutableSourceRank ? outputSpace.scales : defaultInputSpace.scales) && arraysEqual(units, mutableSourceRank ? outputSpace.units : defaultInputSpace.units);
        const transformSame = isTransformDerivableFromDefault(defaultTransformMatrix, defaultRank, defaultOutputSpace.scales, transform, rank, outputSpace.scales);
        const outputNamesSame = arraysEqual(defaultOutputSpace.names, outputSpace.names);
        if (transformSame && outputNamesSame && inputSpaceSame) {
            return undefined;
        }
        return {
            sourceRank,
            transform: transformSame ? undefined : transform,
            outputSpace: value.outputSpace,
            inputSpace: inputSpaceSame ? undefined : inputSpace
        };
    }
    set transform(transform) {
        const value = this.value;
        const inputSpace = value.inputSpace;

        this.value_ = {
            rank: value.rank,
            sourceRank: value.sourceRank,
            inputSpace,
            transform,
            outputSpace: getOutputSpaceWithTransformedBoundingBoxes(inputSpace, transform, value.outputSpace)
        };
        this.changed.dispatch();
    }
    set spec(spec) {
        if (spec === undefined) {
            this.reset();
            return;
        }
        if (this.mutableSourceRank) {
            const origInputSpace = spec.inputSpace || spec.outputSpace;
            const rank = origInputSpace.rank;
            const inputSpace = makeCoordinateSpace({
                rank,
                names: origInputSpace.names.map((_, i) => `${i}`),
                units: origInputSpace.units,
                scales: origInputSpace.scales,
                coordinateArrays: origInputSpace.coordinateArrays
            });
            this.value = {
                rank,
                transform: spec.transform || matrix.createIdentity(Float64Array, rank + 1),
                sourceRank: spec.sourceRank,
                outputSpace: spec.outputSpace,
                inputSpace
            };
            return;
        }
        var _defaultTransform = this.defaultTransform;
        const defaultInputSpace = _defaultTransform.inputSpace,
              defaultSourceRank = _defaultTransform.sourceRank,
              defaultOutputSpace = _defaultTransform.outputSpace,
              defaultTransformMatrix = _defaultTransform.transform,
              defaultRank = _defaultTransform.rank;
        const specInputSpace = spec.inputSpace,
              specSourceRank = spec.sourceRank,
              specOutputSpace = spec.outputSpace,
              specTransformMatrix = spec.transform;

        const specRank = spec.outputSpace.rank;
        const defaultInputNames = defaultInputSpace.names;
        const specInputNames = specInputSpace !== undefined ? specInputSpace.names : defaultInputNames;
        const newToSpecDimensionIndices = new Array(defaultSourceRank);
        for (let defaultDim = 0; defaultDim < defaultSourceRank; ++defaultDim) {
            let specDim = specInputNames.indexOf(defaultInputNames[defaultDim]);
            if (specDim >= specSourceRank) specDim = -1;
            newToSpecDimensionIndices[defaultDim] = specDim;
        }
        const newRank = specRank - specSourceRank + defaultSourceRank;
        for (let i = specSourceRank; i < specRank; ++i) {
            newToSpecDimensionIndices[defaultSourceRank + i - specSourceRank] = i;
        }
        const newInputScales = new Float64Array(newRank);
        const newInputCoordinateArrays = new Array(newRank);
        const newInputUnits = [];
        for (let newDim = 0; newDim < defaultSourceRank; ++newDim) {
            const specDim = newToSpecDimensionIndices[newDim];
            if (specDim === -1 || specInputSpace === undefined) {
                newInputScales[newDim] = defaultInputSpace.scales[newDim];
                newInputUnits[newDim] = defaultInputSpace.units[newDim];
                newInputCoordinateArrays[newDim] = defaultInputSpace.coordinateArrays[newDim];
            } else {
                newInputScales[newDim] = specInputSpace.scales[specDim];
                newInputUnits[newDim] = specInputSpace.units[specDim];
                newInputCoordinateArrays[newDim] = mergeOptionalCoordinateArrays([defaultInputSpace.coordinateArrays[newDim], specInputSpace.coordinateArrays[specDim]]);
            }
        }
        const specInputOrOutputSpace = specInputSpace || specOutputSpace;
        const newInputNames = defaultInputNames.slice(0, defaultSourceRank);
        const newOutputNames = defaultOutputSpace.names.slice(0, defaultSourceRank);
        const newOutputCoordinateArrays = defaultOutputSpace.coordinateArrays.slice(0, defaultSourceRank);
        const newOutputScales = new Float64Array(newRank);
        const newOutputUnits = [];
        for (let newDim = 0; newDim < newRank; ++newDim) {
            const specDim = newToSpecDimensionIndices[newDim];
            if (specDim === -1) {
                newOutputScales[newDim] = defaultOutputSpace.scales[newDim];
                newOutputUnits[newDim] = defaultOutputSpace.units[newDim];
                newOutputCoordinateArrays[newDim] = defaultOutputSpace.coordinateArrays[newDim];
            } else {
                newOutputNames[newDim] = specOutputSpace.names[specDim];
                newOutputUnits[newDim] = specOutputSpace.units[specDim];
                newOutputScales[newDim] = specOutputSpace.scales[specDim];
                newOutputCoordinateArrays[newDim] = specOutputSpace.coordinateArrays[specDim];
            }
        }
        if (!validateDimensionNames(newOutputNames)) {
            // Spec is incompatible, ignore it.
            this.reset();
            return;
        }
        // Handle singleton dimensions.
        for (let newDim = defaultSourceRank; newDim < newRank; ++newDim) {
            const specDim = newDim - defaultSourceRank + specSourceRank;
            newInputScales[newDim] = specInputOrOutputSpace.scales[specDim];
            newInputUnits[newDim] = specInputOrOutputSpace.units[specDim];
            newInputNames[newDim] = `${newDim}`;
        }
        const newTransform = new Float64Array((newRank + 1) ** 2);
        newTransform[newTransform.length - 1] = 1;
        for (let newRow = 0; newRow < newRank; ++newRow) {
            const specRow = newToSpecDimensionIndices[newRow];
            let value;
            if (specRow === -1 || specTransformMatrix === undefined) {
                if (newRow >= defaultSourceRank) {
                    value = 0;
                } else {
                    value = defaultTransformMatrix[defaultRank * (defaultRank + 1) + newRow] * (defaultOutputSpace.scales[newRow] / newOutputScales[newRow]);
                }
            } else {
                value = specTransformMatrix[specRank * (specRank + 1) + specRow];
            }
            newTransform[newRank * (newRank + 1) + newRow] = value;
            for (let newCol = 0; newCol < newRank; ++newCol) {
                const specCol = newToSpecDimensionIndices[newCol];
                let value;
                if (specRow === -1 != (specCol === -1)) {
                    value = 0;
                } else if (specRow === -1 || specTransformMatrix === undefined) {
                    if (specRow >= defaultSourceRank || specCol >= defaultSourceRank) {
                        value = specRow === specCol ? 1 : 0;
                    } else {
                        value = defaultTransformMatrix[newCol * (defaultRank + 1) + newRow];
                    }
                } else {
                    value = specTransformMatrix[specCol * (specRank + 1) + specRow];
                }
                newTransform[newCol * (newRank + 1) + newRow] = value;
            }
        }
        const boundingBoxes = defaultInputSpace.boundingBoxes.map(boundingBox => extendTransformedBoundingBoxUpToRank(boundingBox, defaultRank, newRank));
        for (let i = defaultSourceRank; i < newRank; ++i) {
            boundingBoxes.push(makeSingletonDimTransformedBoundingBox(newRank, i));
        }
        // Propagate coordinate arrays from input dimensions to output dimensions.
        for (let outputDim = 0; outputDim < newRank; ++outputDim) {
            // Check if this output dimension is identity mapped from a single input dimension.
            const translation = newTransform[newRank * (newRank + 1) + outputDim];
            if (translation !== 0) continue;
            let singleInputDim = undefined;
            for (let inputDim = 0; inputDim < newRank; ++inputDim) {
                const factor = newTransform[inputDim * (newRank + 1) + outputDim];
                if (factor === 0) continue;
                if (factor === 1) {
                    if (singleInputDim === undefined) {
                        // First input dimension that maps to this output dimension.
                        singleInputDim = inputDim;
                    } else {
                        // Multiple input dimensions map to this output dimension.
                        singleInputDim = null;
                        break;
                    }
                } else {
                    // Non-identity mapping.
                    singleInputDim = null;
                    break;
                }
            }
            if (singleInputDim == null) continue;
            let coordinateArray = newInputCoordinateArrays[singleInputDim];
            if (coordinateArray === undefined) continue;
            if (coordinateArray.explicit) {
                coordinateArray = _Object$assign(_Object$assign({}, coordinateArray), { explicit: false });
            }
            newOutputCoordinateArrays[outputDim] = mergeOptionalCoordinateArrays([coordinateArray, newOutputCoordinateArrays[outputDim]]);
        }
        this.value = {
            rank: newRank,
            transform: newTransform,
            sourceRank: defaultSourceRank,
            outputSpace: makeCoordinateSpace({
                rank: newRank,
                names: newOutputNames,
                scales: newOutputScales,
                units: newOutputUnits,
                coordinateArrays: newOutputCoordinateArrays
            }),
            inputSpace: makeCoordinateSpace({
                rank: newRank,
                names: newInputNames,
                scales: newInputScales,
                units: newInputUnits,
                coordinateArrays: newInputCoordinateArrays,
                boundingBoxes
            })
        };
    }
    toJSON() {
        return coordinateTransformSpecificationToJson(this.spec);
    }
    restoreState(obj) {
        this.spec = coordinateTransformSpecificationFromJson(obj);
    }
}
export function expectDimensionName(obj, allowNumericalNames = false) {
    const name = verifyString(obj);
    if (!isValidDimensionName(name, allowNumericalNames)) {
        throw new Error(`Invalid dimension name: ${_JSON$stringify(name)}`);
    }
    return name;
}
export function dimensionNamesFromJson(obj, allowNumericalNames = false) {
    const dimensions = parseArray(obj, x => expectDimensionName(x, allowNumericalNames));
    if (!validateDimensionNames(dimensions, allowNumericalNames)) {
        throw new Error(`Invalid dimensions: ${_JSON$stringify(dimensions)}`);
    }
    return dimensions;
}
export class CoordinateSpaceCombiner {
    constructor(combined, includeDimensionPredicate) {
        this.combined = combined;
        this.bindings = new _Set();
        this.retainCount = 0;
        this.prevCombined = this.combined.value;
        this.dimensionRefCounts = new _Map();
        this.handleCombinedChanged = () => {
            if (this.combined.value === this.prevCombined) return;
            this.update();
        };
        this.includeDimensionPredicate_ = includeDimensionPredicate;
    }
    getRenameValidity(newNames) {
        const existingNames = this.combined.value.names;
        const validity = getDimensionNameValidity(newNames);
        const rank = newNames.length;
        for (let i = 0; i < rank; ++i) {
            if (!validity[i]) continue;
            const newName = newNames[i];
            if (existingNames.includes(newName)) continue;
            let valid = true;
            for (const binding of this.bindings) {
                const otherNames = binding.space.value.names;
                if (otherNames.includes(newName)) {
                    valid = false;
                    break;
                }
            }
            validity[i] = valid;
        }
        return validity;
    }
    get includeDimensionPredicate() {
        return this.includeDimensionPredicate_;
    }
    set includeDimensionPredicate(value) {
        this.includeDimensionPredicate_ = value;
        this.update();
    }
    update() {
        const combined = this.combined,
              bindings = this.bindings;

        const retainExisting = this.retainCount > 0 ? 1 : 0;
        if (bindings.size === 0 && !retainExisting) {
            combined.value = emptyInvalidCoordinateSpace;
            return;
        }
        const include = this.includeDimensionPredicate_;
        const existing = combined.value;
        let mergedNames = _Array$from(existing.names);
        let mergedUnits = _Array$from(existing.units);
        let mergedScales = _Array$from(existing.scales);
        let mergedIds = _Array$from(existing.ids);
        let mergedTimestamps = _Array$from(existing.timestamps);
        let dimensionRefs = existing.names.map(() => retainExisting ? 1 : 0);
        const bindingCombinedIndices = [];
        let valid = false;
        for (const binding of bindings) {
            const space = binding.space.value,
                  prevValue = binding.prevValue,
                  mappedDimensionIds = binding.mappedDimensionIds;

            valid = valid || space.valid;
            const names = space.names,
                  units = space.units,
                  scales = space.scales,
                  ids = space.ids,
                  timestamps = space.timestamps;

            const newMappedDimensionIds = [];
            const combinedIndices = [];
            bindingCombinedIndices.push(combinedIndices);
            binding.mappedDimensionIds = newMappedDimensionIds;
            binding.prevValue = space;
            const rank = names.length;
            for (let i = 0; i < rank; ++i) {
                const name = names[i];
                if (!include(name)) continue;
                if (prevValue !== undefined) {
                    const id = ids[i];
                    const prevIndex = prevValue.ids.indexOf(id);
                    if (prevIndex !== -1) {
                        const combinedId = mappedDimensionIds[prevIndex];
                        if (combinedId !== undefined) {
                            const combinedIndex = mergedIds.indexOf(combinedId);
                            if (combinedIndex !== -1) {
                                newMappedDimensionIds[i] = combinedId;
                                ++dimensionRefs[combinedIndex];
                                combinedIndices[i] = combinedIndex;
                                const timestamp = timestamps[i];
                                if (timestamp !== undefined && !(timestamp <= mergedTimestamps[combinedIndex])) {
                                    mergedNames[combinedIndex] = name;
                                    mergedScales[combinedIndex] = scales[i];
                                    mergedUnits[combinedIndex] = units[i];
                                    mergedTimestamps[combinedIndex] = timestamp;
                                }
                                continue;
                            }
                        }
                    }
                }
                let combinedIndex = mergedNames.indexOf(name);
                if (combinedIndex !== -1) {
                    newMappedDimensionIds[i] = mergedIds[combinedIndex];
                    ++dimensionRefs[combinedIndex];
                    combinedIndices[i] = combinedIndex;
                    continue;
                }
                combinedIndex = mergedNames.length;
                combinedIndices[i] = combinedIndex;
                dimensionRefs[combinedIndex] = 1 + retainExisting;
                mergedNames[combinedIndex] = name;
                mergedUnits[combinedIndex] = units[i];
                mergedScales[combinedIndex] = scales[i];
                mergedTimestamps[combinedIndex] = timestamps[i];
                const combinedId = newDimensionId();
                mergedIds[combinedIndex] = combinedId;
                newMappedDimensionIds[i] = combinedId;
            }
        }
        // Propagate names, units, and scales back
        const dimensionRefCounts = this.dimensionRefCounts;

        dimensionRefCounts.clear();
        let bindingIndex = 0;
        let newRank = mergedNames.length;
        for (const binding of bindings) {
            const space = binding.space.value;

            const combinedIndices = bindingCombinedIndices[bindingIndex++];
            const rank = space.rank;

            const names = _Array$from(space.names);
            const timestamps = _Array$from(space.timestamps);
            const scales = Float64Array.from(space.scales);
            const units = _Array$from(space.units);
            for (let i = 0; i < rank; ++i) {
                const combinedIndex = combinedIndices[i];
                if (combinedIndex === undefined) continue;
                units[i] = mergedUnits[combinedIndex];
                scales[i] = mergedScales[combinedIndex];
                timestamps[i] = mergedTimestamps[combinedIndex];
                names[i] = mergedNames[combinedIndex];
            }
            for (const name of names) {
                let count = dimensionRefCounts.get(name);
                if (count === undefined) {
                    count = 1;
                } else {
                    ++count;
                }
                dimensionRefCounts.set(name, count);
            }
            if (!arraysEqual(units, space.units) || !arraysEqual(scales, space.scales) || !arraysEqual(names, space.names) || !arraysEqual(timestamps, space.timestamps)) {
                const newSpace = makeCoordinateSpace({
                    valid: space.valid,
                    ids: space.ids,
                    scales,
                    units,
                    names,
                    timestamps,
                    boundingBoxes: space.boundingBoxes,
                    coordinateArrays: space.coordinateArrays
                });
                binding.prevValue = newSpace;
                binding.space.value = newSpace;
            }
        }
        {
            for (let i = 0; i < newRank; ++i) {
                if (!include(mergedNames[i])) {
                    dimensionRefs[i] = 0;
                }
            }
            const hasRefs = (_, i) => dimensionRefs[i] !== 0;
            mergedNames = mergedNames.filter(hasRefs);
            mergedUnits = mergedUnits.filter(hasRefs);
            mergedScales = mergedScales.filter(hasRefs);
            mergedIds = mergedIds.filter(hasRefs);
            mergedTimestamps = mergedTimestamps.filter(hasRefs);
            dimensionRefs = dimensionRefs.filter(hasRefs);
            newRank = mergedNames.length;
        }
        const mergedBoundingBoxes = [];
        const allCoordinateArrays = new Array(newRank);
        // Include any explicit coordinate arrays from `existing`.
        for (let i = 0, existingRank = existing.rank; i < existingRank; ++i) {
            const coordinateArray = existing.coordinateArrays[i];
            if (!(coordinateArray === null || coordinateArray === void 0 ? void 0 : coordinateArray.explicit)) continue;
            const newDim = mergedIds.indexOf(existing.ids[i]);
            if (newDim === -1) continue;
            allCoordinateArrays[newDim] = [coordinateArray];
        }
        for (const binding of bindings) {
            const space = binding.space.value;
            const rank = space.rank,
                  boundingBoxes = space.boundingBoxes,
                  coordinateArrays = space.coordinateArrays;

            const newDims = space.names.map(x => mergedNames.indexOf(x));
            for (const oldBoundingBox of boundingBoxes) {
                mergedBoundingBoxes.push(extendTransformedBoundingBox(oldBoundingBox, newRank, newDims));
            }
            for (let i = 0; i < rank; ++i) {
                const coordinateArray = coordinateArrays[i];
                if (coordinateArray === undefined) continue;
                const newDim = newDims[i];
                const mergedList = allCoordinateArrays[newDim];
                if (mergedList === undefined) {
                    allCoordinateArrays[newDim] = [coordinateArray];
                } else {
                    mergedList.push(coordinateArray);
                }
            }
        }
        const mergedCoordinateArrays = new Array(newRank);
        for (let i = 0; i < newRank; ++i) {
            const mergedList = allCoordinateArrays[i];
            if (mergedList === undefined) continue;
            mergedCoordinateArrays[i] = mergeCoordinateArrays(mergedList);
        }
        const newCombined = makeCoordinateSpace({
            valid,
            ids: mergedIds,
            names: mergedNames,
            units: mergedUnits,
            scales: new Float64Array(mergedScales),
            boundingBoxes: mergedBoundingBoxes,
            coordinateArrays: mergedCoordinateArrays
        });
        if (retainExisting) {
            for (let i = 0; i < newRank; ++i) {
                --dimensionRefs[i];
            }
        }
        if (!coordinateSpacesEqual(existing, newCombined)) {
            this.prevCombined = newCombined;
            combined.value = newCombined;
        }
    }
    retain() {
        ++this.retainCount;
        return () => {
            if (--this.retainCount === 0) {
                this.update();
            }
        };
    }
    bind(space) {
        const binding = { space, mappedDimensionIds: [], prevValue: undefined };
        const bindings = this.bindings;

        if (bindings.size === 0) {
            this.combined.changed.add(this.handleCombinedChanged);
        }
        bindings.add(binding);
        const changedDisposer = space.changed.add(() => {
            if (space.value === binding.prevValue) return;
            this.update();
        });
        const disposer = () => {
            changedDisposer();
            const bindings = this.bindings;

            bindings.delete(binding);
            if (bindings.size === 0) {
                this.combined.changed.remove(this.handleCombinedChanged);
            }
            this.update();
        };
        this.update();
        return disposer;
    }
}
export function homogeneousTransformSubmatrix(constructor, oldTransform, oldRank, oldRows, oldCols) {
    const newRank = oldCols.length;
    const newTransform = new constructor((newRank + 1) ** 2);
    newTransform[newTransform.length - 1] = 1;
    for (let newRow = 0; newRow < newRank; ++newRow) {
        const oldRow = oldRows[newRow];
        newTransform[(newRank + 1) * newRank + newRow] = oldTransform[(oldRank + 1) * oldRank + oldRow];
        for (let newCol = 0; newCol < newRank; ++newCol) {
            const oldCol = oldCols[newCol];
            newTransform[(newRank + 1) * newCol + newRow] = oldTransform[(oldRank + 1) * oldCol + oldRow];
        }
    }
    return newTransform;
}
export function coordinateTransformSpecificationFromLegacyJson(obj) {
    if (obj === undefined) return undefined;
    const transform = new Float64Array(16);
    if (Array.isArray(obj)) {
        if (obj.length === 16) {
            for (let i = 0; i < 4; ++i) {
                for (let j = 0; j < 4; ++j) {
                    transform[i * 4 + j] = verifyFiniteFloat(obj[j * 4 + i]);
                }
            }
        } else {
            expectArray(obj, 4);
            for (let i = 0; i < 4; ++i) {
                const row = expectArray(obj[i], 4);
                for (let j = 0; j < 4; ++j) {
                    transform[j * 4 + i] = verifyFiniteFloat(row[j]);
                }
            }
        }
    } else {
        verifyObject(obj);
        const rotation = quat.create();
        const translation = vec3.create();
        const scale = vec3.fromValues(1, 1, 1);
        verifyOptionalObjectProperty(obj, 'rotation', x => {
            parseFiniteVec(rotation, x);
            quat.normalize(rotation, rotation);
        });
        verifyOptionalObjectProperty(obj, 'translation', x => {
            parseFiniteVec(translation, x);
        });
        verifyOptionalObjectProperty(obj, 'scale', x => {
            parseFiniteVec(scale, x);
        });
        const tempMat4 = mat4.create();
        mat4.fromRotationTranslationScale(tempMat4, rotation, translation, scale);
        transform.set(tempMat4);
    }
    return {
        sourceRank: 3,
        transform,
        outputSpace: makeCoordinateSpace({
            valid: true,
            names: ['x', 'y', 'z'],
            units: ['m', 'm', 'm'],
            scales: Float64Array.of(1e-9, 1e-9, 1e-9)
        }),
        inputSpace: undefined
    };
}
export function coordinateTransformSpecificationFromJson(j) {
    if (j === undefined) return undefined;
    const obj = verifyObject(j);
    const outputSpace = verifyObjectProperty(obj, 'outputDimensions', coordinateSpaceFromJson);
    const rank = outputSpace.rank;
    const sourceRank = verifyObjectProperty(obj, 'sourceRank', rankObj => {
        if (rankObj === undefined) return rank;
        if (!_Number$isInteger(rankObj) || rankObj < 0 || rankObj > rank) {
            throw new Error(`Expected integer in range [0, ${rank}] but received: ${_JSON$stringify(rankObj)}`);
        }
        return rankObj;
    });
    const inputSpace = verifyOptionalObjectProperty(obj, 'inputDimensions', inputSpaceObj => {
        const space = coordinateSpaceFromJson(inputSpaceObj, true);
        if (space.rank !== rank) {
            throw new Error(`Expected rank of ${rank}, but received rank of: ${space.rank}`);
        }
        return space;
    });
    const transform = verifyOptionalObjectProperty(obj, 'matrix', x => {
        const transform = new Float64Array((rank + 1) ** 2);
        const a = expectArray(x, rank);
        transform[transform.length - 1] = 1;
        for (let i = 0; i < rank; ++i) {
            try {
                const row = expectArray(a[i], rank + 1);
                for (let j = 0; j <= rank; ++j) {
                    transform[(rank + 1) * j + i] = verifyFiniteFloat(row[j]);
                }
            } catch (e) {
                throw new Error(`Error in row ${i}: ${e.message}`);
            }
        }
        return transform;
    });
    return { transform, outputSpace, inputSpace, sourceRank };
}
export function coordinateTransformSpecificationToJson(spec) {
    if (spec === undefined) return undefined;
    const transform = spec.transform,
          outputSpace = spec.outputSpace,
          inputSpace = spec.inputSpace,
          sourceRank = spec.sourceRank;

    let m;
    const rank = outputSpace.rank;
    if (transform !== undefined) {
        m = [];
        for (let i = 0; i < rank; ++i) {
            const row = [];
            m[i] = row;
            for (let j = 0; j <= rank; ++j) {
                row[j] = transform[(rank + 1) * j + i];
            }
        }
    }
    return {
        sourceRank: sourceRank === rank ? undefined : sourceRank,
        matrix: m,
        outputDimensions: coordinateSpaceToJson(outputSpace),
        inputDimensions: inputSpace === undefined ? undefined : coordinateSpaceToJson(inputSpace)
    };
}
export function permuteTransformedBoundingBox(boundingBox, newToOld, oldOutputRank) {
    const box = boundingBox.box,
          transform = boundingBox.transform;

    const inputRank = boundingBox.box.lowerBounds.length;
    const outputRank = newToOld.length;
    const newTransform = new Float64Array((inputRank + 1) * outputRank);
    for (let outputDim = 0; outputDim < outputRank; ++outputDim) {
        for (let inputDim = 0; inputDim <= inputRank; ++inputDim) {
            const oldOutputDim = newToOld[outputDim];
            newTransform[outputDim + inputDim * outputRank] = transform[oldOutputDim + inputDim * oldOutputRank];
        }
    }
    if (newTransform.every(x => x === 0)) return undefined;
    return {
        transform: newTransform,
        box
    };
}
export function permuteCoordinateSpace(existing, newToOld) {
    const ids = existing.ids,
          names = existing.names,
          scales = existing.scales,
          units = existing.units,
          timestamps = existing.timestamps,
          coordinateArrays = existing.coordinateArrays;

    return makeCoordinateSpace({
        rank: newToOld.length,
        valid: existing.valid,
        ids: newToOld.map(i => ids[i]),
        names: newToOld.map(i => names[i]),
        timestamps: newToOld.map(i => timestamps[i]),
        scales: Float64Array.from(newToOld, i => scales[i]),
        units: newToOld.map(i => units[i]),
        coordinateArrays: newToOld.map(i => coordinateArrays[i]),
        boundingBoxes: existing.boundingBoxes.map(b => permuteTransformedBoundingBox(b, newToOld, existing.rank)).filter(b => b !== undefined)
    });
}
export function insertDimensionAt(existing, targetIndex, sourceIndex) {
    if (targetIndex === sourceIndex) return existing;
    return permuteCoordinateSpace(existing, getInsertPermutation(existing.rank, sourceIndex, targetIndex));
}
export function getInferredOutputScale(transform, outputDim) {
    const transformMatrix = transform.transform,
          rank = transform.rank;

    const inputDims = getDependentTransformInputDimensions(transformMatrix, rank, [outputDim]);
    if (inputDims.length !== 1) return undefined;

    var _inputDims = _slicedToArray(inputDims, 1);

    const inputDim = _inputDims[0];

    const coeff = Math.abs(transformMatrix[(rank + 1) * inputDim + outputDim]);
    const inputSpace = transform.inputSpace;

    return { scale: inputSpace.scales[inputDim] * coeff, unit: inputSpace.units[inputDim] };
}
export function getDefaultInputScale(transform, inputDim) {
    var _transform$defaultInp = transform.defaultInputSpace;
    const defaultScales = _transform$defaultInp.scales,
          defaultUnits = _transform$defaultInp.units;

    return inputDim < defaultScales.length ? { scale: defaultScales[inputDim], unit: defaultUnits[inputDim] } : undefined;
}
//# sourceMappingURL=coordinate_transform.js.map