import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import debounce from 'lodash/debounce';
import { registerLayerTool } from '../ui/tool';
import { RefCounted } from '../util/disposable';
import { removeChildren } from '../util/dom';
import { verifyObjectProperty, verifyString } from '../util/json';
import { addLayerControlToOptionsTab, LayerControlTool } from './layer_control';
import { channelInvlerpLayerControl } from './layer_control_channel_invlerp';
import { checkboxLayerControl } from './layer_control_checkbox';
import { colorLayerControl } from './layer_control_color';
import { rangeLayerControl } from './layer_control_range';
import { Tab } from './tab_view';
function getShaderLayerControlFactory(layerShaderControls, controlId) {
    const shaderControlState = layerShaderControls.shaderControlState;

    const controlState = shaderControlState.state.get(controlId);
    if (controlState === undefined) return undefined;
    const control = controlState.control;

    switch (control.type) {
        case 'slider':
            return rangeLayerControl(() => ({
                value: controlState.trackable,
                options: { min: control.min, max: control.max, step: control.step }
            }));
        case 'color':
            return colorLayerControl(() => controlState.trackable);
        case 'checkbox':
            return checkboxLayerControl(() => controlState.trackable);
        case 'invlerp':
            {
                let histogramIndex = 0;
                for (const _ref of shaderControlState.state) {
                    var _ref2 = _slicedToArray(_ref, 2);

                    const otherName = _ref2[0];
                    const otherType = _ref2[1].control.type;

                    if (otherName === controlId) break;
                    if (otherType === 'invlerp') ++histogramIndex;
                }
                return channelInvlerpLayerControl(() => ({
                    dataType: control.dataType,
                    defaultChannel: control.default.channel,
                    watchableValue: controlState.trackable,
                    channelCoordinateSpaceCombiner: shaderControlState.channelCoordinateSpaceCombiner,
                    histogramSpecifications: shaderControlState.histogramSpecifications,
                    histogramIndex,
                    legendShaderOptions: layerShaderControls.legendShaderOptions
                }));
            }
    }
}
function getShaderLayerControlDefinition(getter, toolId, controlId) {
    return {
        label: controlId,
        toolJson: shaderControlToolJson(controlId, toolId),
        makeControl: (layer, context, options) => {
            const layerShaderControls = getter(layer);
            return getShaderLayerControlFactory(layerShaderControls, controlId).makeControl(layer, context, options);
        },
        activateTool: (activation, control) => {
            const layerShaderControls = getter(activation.tool.layer);
            return getShaderLayerControlFactory(layerShaderControls, controlId).activateTool(activation, control);
        }
    };
}
export class ShaderControls extends Tab {
    constructor(state, display, layer, options = {}) {
        super(options.visibility);
        this.state = state;
        this.display = display;
        this.layer = layer;
        this.options = options;
        this.controlDisposer = undefined;
        var _options$toolId = options.toolId;
        const toolId = _options$toolId === undefined ? SHADER_CONTROL_TOOL_ID : _options$toolId;

        this.toolId = toolId;
        const element = this.element;

        element.style.display = 'contents';
        const controls = state.controls;

        this.registerDisposer(controls.changed.add(this.registerCancellable(debounce(() => this.updateControls(), 0))));
        this.updateControls();
    }
    updateControls() {
        const element = this.element;

        if (this.controlDisposer !== undefined) {
            this.controlDisposer.dispose();
            removeChildren(element);
        }
        const controlDisposer = this.controlDisposer = new RefCounted();
        const layerShaderControlsGetter = () => ({
            shaderControlState: this.state,
            legendShaderOptions: this.options.legendShaderOptions
        });
        for (const name of this.state.state.keys()) {
            element.appendChild(addLayerControlToOptionsTab(controlDisposer, this.layer, this.visibility, getShaderLayerControlDefinition(layerShaderControlsGetter, this.toolId, name)));
        }
    }
    disposed() {
        var _a;
        (_a = this.controlDisposer) === null || _a === void 0 ? void 0 : _a.dispose();
        super.disposed();
    }
}
export const SHADER_CONTROL_TOOL_ID = 'shaderControl';
const CONTROL_JSON_KEY = 'control';
function shaderControlToolJson(control, toolId) {
    return { type: toolId, [CONTROL_JSON_KEY]: control };
}
class ShaderControlTool extends LayerControlTool {
    constructor(layer, layerShaderControls, toolId, control) {
        super(layer, getShaderLayerControlDefinition(() => layerShaderControls, toolId, control));
        this.layerShaderControls = layerShaderControls;
        this.control = control;
        this.registerDisposer(layerShaderControls.shaderControlState.controls.changed.add(this.registerCancellable(debounce(() => {
            if (layerShaderControls.shaderControlState.state.get(control) === undefined) {
                this.unbind();
            }
        }))));
    }
    activate(activation) {
        const shaderControlState = this.layerShaderControls.shaderControlState;

        const controlState = shaderControlState.state.get(this.control);
        if (controlState === undefined) return;
        super.activate(activation);
    }
}
export function registerLayerShaderControlsTool(layerType, getter, toolId = SHADER_CONTROL_TOOL_ID) {
    registerLayerTool(layerType, toolId, (layer, options) => {
        const control = verifyObjectProperty(options, CONTROL_JSON_KEY, verifyString);
        return new ShaderControlTool(layer, getter(layer), toolId, control);
    });
}
//# sourceMappingURL=shader_controls.js.map