import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Math$log from 'babel-runtime/core-js/math/log10';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { TrackableValue } from '../trackable_value';
import { RefCounted } from '../util/disposable';
import { verifyFloat, verifyObjectProperty, verifyString } from '../util/json';
import { pickSiPrefix } from '../util/si_units';
import { OffscreenCopyHelper } from '../webgl/offscreen';
import { setTextureFromCanvas } from '../webgl/texture';
/**
 * Default set of allowed significand values.  1 is implicitly part of the set.
 */
const DEFAULT_ALLOWED_SIGNIFICANDS = [1.5, 2, 3, 5, 7.5, 10];
export const ALLOWED_UNITS = [{ unit: 'km', lengthInNanometers: 1e12 }, { unit: 'm', lengthInNanometers: 1e9 }, { unit: 'mm', lengthInNanometers: 1e6 }, { unit: 'Âµm', lengthInNanometers: 1e3 }, { unit: 'nm', lengthInNanometers: 1 }, { unit: 'pm', lengthInNanometers: 1e-3 }];
export function pickLengthUnit(lengthInNanometers) {
    const numAllowedUnits = ALLOWED_UNITS.length;
    let unit = ALLOWED_UNITS[numAllowedUnits - 1];
    for (let i = 0; i < numAllowedUnits; ++i) {
        const allowedUnit = ALLOWED_UNITS[i];
        if (lengthInNanometers >= allowedUnit.lengthInNanometers) {
            unit = allowedUnit;
            break;
        }
    }
    return unit;
}
export function pickVolumeUnit(volumeInCubicNanometers) {
    const numAllowedUnits = ALLOWED_UNITS.length;
    let unit = ALLOWED_UNITS[numAllowedUnits - 1];
    for (let i = 0; i < numAllowedUnits; ++i) {
        const allowedUnit = ALLOWED_UNITS[i];
        if (volumeInCubicNanometers >= Math.pow(allowedUnit.lengthInNanometers, 3)) {
            unit = allowedUnit;
            break;
        }
    }
    return unit;
}
export class ScaleBarDimensions {
    constructor() {
        /**
         * Allowed significand values.  1 is not included, but is always considered
         * part of the set.
         */
        this.allowedSignificands = DEFAULT_ALLOWED_SIGNIFICANDS;
        /**
         * The target length in pixels.  The closest
         */
        this.targetLengthInPixels = 0;
        /**
         * Pixel size in base physical units.
         */
        this.physicalSizePerPixel = 0;
        this.prevPhysicalSizePerPixel = 0;
        this.prevTargetLengthInPixels = 0;
        this.prevPhysicalUnit = '\0';
    }
    /**
     * Updates physicalLength, physicalUnit, and lengthInPixels to be the optimal values corresponding
     * to targetLengthInPixels and physicalSizePerPixel.
     *
     * @returns true if the scale bar has changed, false if it is unchanged.
     */
    update() {
        let physicalSizePerPixel = this.physicalSizePerPixel,
            targetLengthInPixels = this.targetLengthInPixels;

        if (this.prevPhysicalSizePerPixel === physicalSizePerPixel && this.prevTargetLengthInPixels === targetLengthInPixels && this.prevPhysicalUnit === this.physicalUnit) {
            return false;
        }
        this.prevPhysicalSizePerPixel = physicalSizePerPixel;
        this.prevTargetLengthInPixels = targetLengthInPixels;
        this.prevPhysicalUnit = this.physicalUnit;
        const targetPhysicalSize = targetLengthInPixels * physicalSizePerPixel;
        const exponent = Math.floor(_Math$log(targetPhysicalSize));
        const tenToThePowerExponent = 10 ** exponent;
        const targetSignificand = targetPhysicalSize / tenToThePowerExponent;
        // Determine significand value in this.allowedSignificands that is closest
        // to targetSignificand.
        let bestSignificand = 1;
        for (let allowedSignificand of this.allowedSignificands) {
            if (Math.abs(allowedSignificand - targetSignificand) < Math.abs(bestSignificand - targetSignificand)) {
                bestSignificand = allowedSignificand;
            } else {
                // If distance did not decrease, then it can only increase from here.
                break;
            }
        }
        const physicalSize = bestSignificand * tenToThePowerExponent;
        const siPrefix = pickSiPrefix(physicalSize);
        this.lengthInPixels = Math.round(physicalSize / physicalSizePerPixel);
        this.physicalUnit = `${siPrefix.prefix}${this.physicalBaseUnit}`;
        this.physicalLength = bestSignificand * 10 ** (exponent - siPrefix.exponent);
        return true;
    }
}
function makeScaleBarTexture(dimensions, gl, texture, label, options) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const textHeight = options.textHeightInPixels * options.scaleFactor;
    const font = `bold ${textHeight}px ${options.fontName}`;
    ctx.font = font;
    ctx.fillStyle = 'white';
    const text = `${label}${dimensions.physicalLength} ${dimensions.physicalUnit}`;
    const textMetrics = ctx.measureText(text);
    const innerWidth = Math.max(dimensions.lengthInPixels, textMetrics.width);
    const barHeight = options.barHeightInPixels * options.scaleFactor;
    const barTopMargin = options.barTopMarginInPixels * options.scaleFactor;
    const innerHeight = barHeight + barTopMargin + textHeight;
    const padding = options.paddingInPixels * options.scaleFactor;
    const totalHeight = innerHeight + 2 * padding;
    const totalWidth = innerWidth + 2 * padding;
    canvas.width = totalWidth;
    canvas.height = totalHeight;
    ctx.font = font;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(0, 0, totalWidth, totalHeight);
    ctx.fillStyle = 'white';
    ctx.fillText(text, totalWidth / 2, totalHeight - padding - barHeight - barTopMargin);
    ctx.fillRect(padding, totalHeight - padding - barHeight, dimensions.lengthInPixels, barHeight);
    setTextureFromCanvas(gl, texture, canvas);
    return { width: totalWidth, height: totalHeight };
}
export class ScaleBarTexture extends RefCounted {
    constructor(gl, dimensions = new ScaleBarDimensions()) {
        super();
        this.gl = gl;
        this.dimensions = dimensions;
        this.texture = null;
        this.width = 0;
        this.height = 0;
        this.label = '';
        this.factor = 1;
        this.priorOptions = undefined;
        this.prevLabel = '';
    }
    update(options) {
        const dimensions = this.dimensions,
              label = this.label;
        let texture = this.texture;

        if (!dimensions.update() && texture !== null && options === this.priorOptions && label == this.prevLabel) {
            return;
        }
        if (texture === null) {
            texture = this.texture = this.gl.createTexture();
        }

        var _makeScaleBarTexture = makeScaleBarTexture(dimensions, this.gl, texture, label, options);

        const width = _makeScaleBarTexture.width,
              height = _makeScaleBarTexture.height;

        this.priorOptions = options;
        this.prevLabel = label;
        this.width = width;
        this.height = height;
    }
    disposed() {
        this.gl.deleteTexture(this.texture);
        this.texture = null;
        super.disposed();
    }
}
export class MultipleScaleBarTextures extends RefCounted {
    constructor(gl) {
        super();
        this.gl = gl;
        this.scaleBarCopyHelper = this.registerDisposer(OffscreenCopyHelper.get(this.gl));
        this.scaleBars = [];
        for (let i = 0; i < 3; ++i) {
            this.scaleBars.push(this.registerDisposer(new ScaleBarTexture(gl)));
        }
    }
    draw(viewport, displayDimensionRenderInfo, relativeDisplayScales, effectiveZoom, options) {
        const scaleBars = this.scaleBars;
        const displayRank = displayDimensionRenderInfo.displayRank,
              displayDimensionIndices = displayDimensionRenderInfo.displayDimensionIndices,
              canonicalVoxelFactors = displayDimensionRenderInfo.canonicalVoxelFactors,
              globalDimensionNames = displayDimensionRenderInfo.globalDimensionNames,
              displayDimensionUnits = displayDimensionRenderInfo.displayDimensionUnits,
              displayDimensionScales = displayDimensionRenderInfo.displayDimensionScales;
        const factors = relativeDisplayScales.factors;

        const targetLengthInPixels = Math.min(options.maxWidthFraction * viewport.logicalWidth, options.maxWidthInPixels * options.scaleFactor);
        let numScaleBars = 0;
        for (let i = 0; i < displayRank; ++i) {
            const dim = displayDimensionIndices[i];
            const unit = displayDimensionUnits[i];
            const factor = factors[dim];
            let barIndex;
            let scaleBar;
            let scaleBarDimensions;
            for (barIndex = 0; barIndex < numScaleBars; ++barIndex) {
                scaleBar = scaleBars[barIndex];
                scaleBarDimensions = scaleBar.dimensions;
                if (scaleBarDimensions.physicalBaseUnit === unit && scaleBar.factor === factor) {
                    break;
                }
            }
            if (barIndex === numScaleBars) {
                ++numScaleBars;
                scaleBar = scaleBars[barIndex];
                scaleBar.label = '';
                scaleBarDimensions = scaleBar.dimensions;
                scaleBar.factor = factor;
                scaleBarDimensions.physicalBaseUnit = unit;
                scaleBarDimensions.targetLengthInPixels = targetLengthInPixels;
                scaleBarDimensions.physicalSizePerPixel = displayDimensionScales[i] * effectiveZoom / canonicalVoxelFactors[i];
            }
            scaleBar.label += `${globalDimensionNames[dim]} `;
        }
        const gl = this.gl,
              scaleBarCopyHelper = this.scaleBarCopyHelper;

        let bottomPixelOffset = options.bottomPixelOffset * options.scaleFactor;
        for (let barIndex = numScaleBars - 1; barIndex >= 0; --barIndex) {
            const scaleBar = scaleBars[barIndex];
            if (numScaleBars === 1) {
                scaleBar.label = '';
            } else {
                scaleBar.label += ': ';
            }
            scaleBar.update(options);
            gl.viewport(options.leftPixelOffset * options.scaleFactor - viewport.visibleLeftFraction * viewport.logicalWidth, bottomPixelOffset - (1 - (viewport.visibleTopFraction + viewport.visibleHeightFraction)) * viewport.logicalHeight, scaleBar.width, scaleBar.height);
            scaleBarCopyHelper.draw(scaleBar.texture);
            bottomPixelOffset += scaleBar.height + options.marginPixelsBetweenScaleBars * options.scaleFactor;
        }
    }
}
export const defaultScaleBarTextureOptions = {
    scaleFactor: 1,
    textHeightInPixels: 15,
    barHeightInPixels: 8,
    barTopMarginInPixels: 5,
    fontName: 'sans-serif',
    paddingInPixels: 2
};
export const defaultScaleBarOptions = _Object$assign(_Object$assign({}, defaultScaleBarTextureOptions), { maxWidthInPixels: 100, maxWidthFraction: 0.25, leftPixelOffset: 10, bottomPixelOffset: 10, marginPixelsBetweenScaleBars: 5 });
function parseScaleBarOptions(obj) {
    const result = _Object$assign({}, defaultScaleBarOptions);
    for (const k of ['textHeightInPixels', 'barTopMarginInPixels', 'barHeightInPixels', 'paddingInPixels', 'scaleFactor', 'maxWidthInPixels', 'maxWidthFraction', 'leftPixelOffset', 'bottomPixelOffset']) {
        verifyObjectProperty(obj, k, x => {
            if (x !== undefined) {
                result[k] = verifyFloat(x);
            }
        });
    }
    verifyObjectProperty(obj, 'fontName', x => {
        if (x !== undefined) {
            result.fontName = verifyString(x);
        }
    });
    return result;
}
export class TrackableScaleBarOptions extends TrackableValue {
    constructor() {
        super(defaultScaleBarOptions, parseScaleBarOptions);
    }
}
//# sourceMappingURL=scale_bar.js.map