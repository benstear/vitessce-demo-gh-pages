import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Map from 'babel-runtime/core-js/map';

import { animationFrameDebounce } from '../util/animation_frame_debounce'; /**
                                                                            * @license
                                                                            * Copyright 2018 Google Inc.
                                                                            * Licensed under the Apache License, Version 2.0 (the "License");
                                                                            * you may not use this file except in compliance with the License.
                                                                            * You may obtain a copy of the License at
                                                                            *
                                                                            *      http://www.apache.org/licenses/LICENSE-2.0
                                                                            *
                                                                            * Unless required by applicable law or agreed to in writing, software
                                                                            * distributed under the License is distributed on an "AS IS" BASIS,
                                                                            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                            * See the License for the specific language governing permissions and
                                                                            * limitations under the License.
                                                                            */
/**
 * @file Tabbed view widget.
 */

import { RefCounted } from '../util/disposable';
import { removeChildren, removeFromParent } from '../util/dom';
import { NullarySignal, Signal } from '../util/signal';
import { WatchableVisibilityPriority } from '../visibility_priority/frontend';
export class Tab extends RefCounted {
    constructor(visibility = new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE)) {
        super();
        this.visibility = visibility;
        this.element = document.createElement('div');
        const element = this.element;

        element.classList.add('neuroglancer-tab-content');
    }
    get visible() {
        return this.visibility.visible;
    }
    disposed() {
        removeFromParent(this.element);
        super.disposed();
    }
}
export class OptionSpecification extends RefCounted {
    constructor() {
        super(...arguments);
        this.changed = new NullarySignal();
        this.options = new _Map();
        this.optionsChanged = new NullarySignal();
        this.selectedValue = undefined;
        this.defaultValue = undefined;
        this.ready_ = true;
    }
    get value() {
        const selectedValue = this.selectedValue;

        if (selectedValue !== undefined) {
            return selectedValue;
        }
        return this.defaultValue;
    }
    set default(value) {
        if (this.defaultValue !== value) {
            this.defaultValue = value;
            this.changed.dispatch();
        }
    }
    get default() {
        return this.defaultValue;
    }
    set value(value) {
        if (value !== undefined && this.ready_ && !this.options.has(value)) {
            value = undefined;
        }
        const selectedValue = this.selectedValue;

        if (selectedValue !== value) {
            this.selectedValue = value;
            this.changed.dispatch();
        }
    }
    get validValue() {
        const value = this.selectedValue;
        if (value === undefined || !this.options.has(value)) {
            return this.defaultValue;
        }
        return value;
    }
    add(id, value) {
        const options = this.options;

        if (options.has(id)) {
            throw new Error(`Option already defined: ${_JSON$stringify(id)}.`);
        }
        options.set(id, value);
        this.optionsChanged.dispatch();
        if (this.defaultValue === undefined) {
            this.default = id;
        }
    }
    toJSON() {
        const value = this.value,
              defaultValue = this.defaultValue;

        if (value === defaultValue) {
            return undefined;
        }
        return value;
    }
    reset() {
        this.value = undefined;
    }
    /**
     * When `ready` is `false`, the selected `value` may be set to an unknown option.
     */
    get ready() {
        return this.ready_;
    }
    set ready(value) {
        if (value !== this.ready_) {
            this.ready_ = value;
            if (value) {
                this.value = this.value;
            }
            this.changed.dispatch();
        }
    }
    restoreState(obj) {
        if (typeof obj !== 'string') {
            obj = undefined;
        }
        this.value = obj;
    }
}
export class StackView extends RefCounted {
    constructor(getter, selected, visibility = new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE), invalidateByDefault = false) {
        super();
        this.getter = getter;
        this.selected = selected;
        this.visibility = visibility;
        this.invalidateByDefault = invalidateByDefault;
        this.element = document.createElement('div');
        this.tabs = new _Map();
        this.tabVisibilityChanged = new Signal();
        this.debouncedUpdateSelectedTab = this.registerCancellable(animationFrameDebounce(() => this.updateSelectedTab()));
        const element = this.element;

        element.className = 'neuroglancer-stack-view';
        this.registerDisposer(visibility.changed.add(this.debouncedUpdateSelectedTab));
        this.registerDisposer(selected.changed.add(this.debouncedUpdateSelectedTab));
        this.updateSelectedTab();
    }
    get visible() {
        return this.visibility.visible;
    }
    flush() {
        this.debouncedUpdateSelectedTab.flush();
    }
    invalidate(id) {
        const tabs = this.tabs;

        const tab = tabs.get(id);
        if (tab === undefined) {
            return;
        }
        tab.dispose();
        tabs.delete(id);
        if (id === this.displayedTab) {
            this.displayedTab = undefined;
            this.debouncedUpdateSelectedTab();
        }
    }
    hideTab(id) {
        const tab = this.tabs.get(id);
        if (tab !== undefined) {
            tab.visibility.value = WatchableVisibilityPriority.IGNORED;
            tab.element.style.display = 'none';
        }
        this.tabVisibilityChanged.dispatch(id, false);
    }
    showTab(id) {
        const tabs = this.tabs;

        let tab = tabs.get(id);
        if (tab === undefined) {
            tab = this.getter(id);
            this.element.appendChild(tab.element);
            tabs.set(id, tab);
        }
        tab.element.style.display = '';
        tab.visibility.value = WatchableVisibilityPriority.VISIBLE;
        this.tabVisibilityChanged.dispatch(id, true);
    }
    updateSelectedTab() {
        const displayedTab = this.displayedTab;

        const newTab = this.visible ? this.selected.value : undefined;
        if (newTab === displayedTab && (newTab === undefined || this.tabs.has(newTab))) {
            return;
        }
        if (displayedTab !== undefined) {
            this.hideTab(displayedTab);
        }
        if (this.invalidateByDefault) {
            this.invalidateAll();
        }
        this.displayedTab = newTab;
        if (newTab === undefined) {
            return;
        }
        this.showTab(newTab);
    }
    invalidateAll(predicate = undefined) {
        const tabs = this.tabs;

        for (const _ref of tabs) {
            var _ref2 = _slicedToArray(_ref, 2);

            const id = _ref2[0];
            const tab = _ref2[1];

            if (predicate !== undefined && predicate(id)) continue;
            tabs.delete(id);
            tab.dispose();
        }
        this.debouncedUpdateSelectedTab();
    }
    disposed() {
        this.invalidateAll();
        removeFromParent(this.element);
        super.disposed();
    }
}
export class TabSpecification extends OptionSpecification {}
function updateTabLabelVisibilityStyle(labelElement, visible) {
    const className = 'neuroglancer-selected-tab-label';
    if (visible) {
        labelElement.classList.add(className);
    } else {
        labelElement.classList.remove(className);
    }
}
export class TabView extends RefCounted {
    constructor(options, visibility = new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE)) {
        super();
        this.visibility = visibility;
        this.element = document.createElement('div');
        this.tabBar = document.createElement('div');
        this.tabLabels = new _Map();
        this.tabsGeneration = -1;
        this.debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateTabs()));
        this.tabs = options.tabs;
        this.selectedTab = options.selectedTab;
        this.handleTabElement = options.handleTabElement;
        const element = this.element,
              tabBar = this.tabBar;

        element.className = 'neuroglancer-tab-view';
        tabBar.className = 'neuroglancer-tab-view-bar';
        element.appendChild(tabBar);
        this.registerDisposer(visibility.changed.add(this.debouncedUpdateView));
        const stack = this.stack = this.registerDisposer(new StackView(options.makeTab, options.selectedTab, this.visibility));
        element.appendChild(stack.element);
        this.registerDisposer(options.tabs.changed.add(this.debouncedUpdateView));
        this.registerDisposer(options.selectedTab.changed.add(() => this.updateTabLabelStyles()));
        this.updateTabs();
    }
    get visible() {
        return this.visibility.visible;
    }
    updateTabLabelStyles() {
        const selectedId = this.selectedTab.value;
        for (const _ref3 of this.tabLabels) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const id = _ref4[0];
            const element = _ref4[1];

            updateTabLabelVisibilityStyle(element, id === selectedId);
        }
    }
    updateTabs() {
        if (this.tabsGeneration !== this.tabs.changed.count) {
            this.destroyTabs();
            if (this.visible) {
                this.makeTabs();
            }
        }
    }
    destroyTabs() {
        if (this.tabsGeneration === -1) {
            return;
        }
        this.tabLabels.clear();
        if (!this.visible) {
            this.stack.invalidateAll();
        } else {
            const tabs = this.tabs.value;
            this.stack.invalidateAll(existingId => tabs.find(({ id }) => id === existingId) !== undefined);
        }
        removeChildren(this.tabBar);
        this.tabsGeneration = -1;
    }
    makeTabs() {
        const tabBar = this.tabBar,
              tabLabels = this.tabLabels,
              handleTabElement = this.handleTabElement;

        for (const _ref5 of this.tabs.value) {
            const id = _ref5.id;
            const label = _ref5.label;

            const labelElement = document.createElement('div');
            labelElement.classList.add('neuroglancer-tab-label');
            labelElement.textContent = label;
            labelElement.addEventListener('click', () => {
                this.selectedTab.value = id;
            });
            if (handleTabElement !== undefined) {
                handleTabElement(id, labelElement);
            }
            tabLabels.set(id, labelElement);
            tabBar.appendChild(labelElement);
        }
        this.updateTabLabelStyles();
        this.tabsGeneration = this.tabs.changed.count;
    }
    disposed() {
        removeChildren(this.tabBar);
        this.tabLabels.clear();
        removeFromParent(this.element);
        super.disposed();
    }
}
//# sourceMappingURL=tab_view.js.map