import _Number$isInteger from 'babel-runtime/core-js/number/is-integer';
import _Symbol from 'babel-runtime/core-js/symbol';
import _Number$isFinite from 'babel-runtime/core-js/number/is-finite';
import _Object$assign from 'babel-runtime/core-js/object/assign';

import svg_arrowLeft from 'ikonate/icons/arrow-left.svg'; /**
                                                           * @license
                                                           * Copyright 2020 Google Inc.
                                                           * Licensed under the Apache License, Version 2.0 (the "License");
                                                           * you may not use this file except in compliance with the License.
                                                           * You may obtain a copy of the License at
                                                           *
                                                           *      http://www.apache.org/licenses/LICENSE-2.0
                                                           *
                                                           * Unless required by applicable law or agreed to in writing, software
                                                           * distributed under the License is distributed on an "AS IS" BASIS,
                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                           * See the License for the specific language governing permissions and
                                                           * limitations under the License.
                                                           */

import svg_arrowRight from 'ikonate/icons/arrow-right.svg';
import { IndirectRenderedPanel } from '../display_context';
import { animationFrameDebounce } from '../util/animation_frame_debounce';
import { RefCounted } from '../util/disposable';
import { updateInputFieldWidth } from '../util/dom';
import { EventActionMap, registerActionListener } from '../util/event_action_map';
import { computeInvlerp, computeLerp, dataTypeCompare, getClampedInterval, getClosestEndpoint, getIntervalBoundsEffectiveFraction, getIntervalBoundsEffectiveOffset, parseDataTypeValue } from '../util/lerp';
import { MouseEventBinder } from '../util/mouse_bindings';
import { startRelativeMouseDrag } from '../util/mouse_drag';
import { Uint64 } from '../util/uint64';
import { getWheelZoomAmount } from '../util/wheel_zoom';
import { getMemoizedBuffer } from '../webgl/buffer';
import { parameterizedEmitterDependentShaderGetter } from '../webgl/dynamic_shader';
import { defineLerpShaderFunction, enableLerpShaderFunction } from '../webgl/lerp';
import { defineLineShader, drawLines, initializeLineShader, VERTICES_PER_LINE } from '../webgl/lines';
import { ShaderBuilder } from '../webgl/shader';
import { getShaderType } from '../webgl/shader_lib';
import { getSquareCornersBuffer } from '../webgl/square_corners_buffer';
import { setRawTextureParameters } from '../webgl/texture';
import { makeIcon } from './icon';
import { Tab } from './tab_view';
const inputEventMap = EventActionMap.fromObject({
    'shift?+mousedown0': { action: 'set' },
    'shift?+alt+mousedown0': { action: 'adjust-window-via-drag' },
    'shift?+wheel': { action: 'zoom-via-wheel' }
});
export class CdfController extends RefCounted {
    constructor(element, dataType, getModel, setModel) {
        super();
        this.element = element;
        this.dataType = dataType;
        this.getModel = getModel;
        this.setModel = setModel;
        element.title = inputEventMap.describe();
        this.registerDisposer(new MouseEventBinder(element, inputEventMap));
        registerActionListener(element, 'set', actionEvent => {
            const mouseEvent = actionEvent.detail;
            const bounds = this.getModel();
            const value = this.getTargetValue(mouseEvent);
            if (value === undefined) return;
            const clampedRange = getClampedInterval(bounds.window, bounds.range);
            const endpoint = getClosestEndpoint(clampedRange, value);
            const setEndpoint = value => {
                const bounds = this.getModel();
                this.setModel(getUpdatedRangeAndWindowParameters(bounds, 'range', endpoint, value));
            };
            setEndpoint(value);
            startRelativeMouseDrag(mouseEvent, newEvent => {
                const value = this.getTargetValue(newEvent);
                if (value === undefined) return;
                setEndpoint(value);
            });
        });
        registerActionListener(element, 'adjust-window-via-drag', actionEvent => {
            // If user starts drag on left half, then right bound is fixed, and left bound is adjusted to
            // keep the value under the mouse fixed.  If user starts drag on right half, the left bound is
            // fixed and right bound is adjusted.
            const mouseEvent = actionEvent.detail;
            const initialRelativeX = this.getTargetFraction(mouseEvent);
            const initialValue = this.getWindowLerp(initialRelativeX);
            const endpointIndex = initialRelativeX < 0.5 ? 0 : 1;
            const setEndpoint = value => {
                const bounds = this.getModel();
                this.setModel(getUpdatedRangeAndWindowParameters(bounds, 'window', endpointIndex, value));
            };
            startRelativeMouseDrag(mouseEvent, newEvent => {
                const window = this.getModel().window;
                const relativeX = this.getTargetFraction(newEvent);
                if (endpointIndex === 0) {
                    // Need to find x such that: lerp([x, window[1]], relativeX) == initialValue
                    // Equivalently: lerp([initialValue, window[1]], -relativeX / ( 1 - relativeX))
                    setEndpoint(computeLerp([initialValue, window[1]], this.dataType, -relativeX / (1 - relativeX)));
                } else {
                    // Need to find x such that: lerp([window[0], x], relativeX) == initialValue
                    // Equivalently: lerp([window[0], initialValue], 1 / relativeX)
                    setEndpoint(computeLerp([window[0], initialValue], this.dataType, 1 / relativeX));
                }
            });
        });
        registerActionListener(element, 'zoom-via-wheel', actionEvent => {
            const wheelEvent = actionEvent.detail;
            const zoomAmount = getWheelZoomAmount(wheelEvent);
            const relativeX = this.getTargetFraction(wheelEvent);
            const dataType = this.dataType;

            const bounds = this.getModel();
            const newLower = computeLerp(bounds.window, dataType, relativeX * (1 - zoomAmount));
            const newUpper = computeLerp(bounds.window, dataType, (1 - relativeX) * zoomAmount + relativeX);
            this.setModel(_Object$assign(_Object$assign({}, bounds), { window: [newLower, newUpper], range: bounds.range }));
        });
    }
    getTargetFraction(event) {
        const clientRect = this.element.getBoundingClientRect();
        return (event.clientX - clientRect.left) / clientRect.width;
    }
    getWindowLerp(relativeX) {
        return computeLerp(this.getModel().window, this.dataType, relativeX);
    }
    getTargetValue(event) {
        const targetFraction = this.getTargetFraction(event);
        if (!_Number$isFinite(targetFraction)) return undefined;
        return this.getWindowLerp(targetFraction);
    }
}
const histogramSamplerTextureUnit = _Symbol('histogramSamplerTexture');
export function getUpdatedRangeAndWindowParameters(existingBounds, boundType, endpointIndex, newEndpoint, fitRangeInWindow = false) {
    const newBounds = _Object$assign({}, existingBounds);
    const existingInterval = existingBounds[boundType];
    newBounds[boundType] = [existingInterval[0], existingInterval[1]];
    newBounds[boundType][endpointIndex] = newEndpoint;
    if (boundType === 'window' && dataTypeCompare(newEndpoint, existingInterval[1 - endpointIndex]) * (2 * endpointIndex - 1) < 0) {
        newBounds[boundType][1 - endpointIndex] = newEndpoint;
    }
    if (boundType === 'range' && fitRangeInWindow) {
        // Also adjust `window` endpoint to contain the new endpoint.
        const newWindowInterval = [existingBounds.window[0], existingBounds.window[1]];
        for (let i = 0; i < 2; ++i) {
            if (dataTypeCompare(newEndpoint, newWindowInterval[i]) * (2 * i - 1) > 0) {
                newWindowInterval[i] = newEndpoint;
            }
        }
        newBounds.window = newWindowInterval;
    }
    return newBounds;
}
// 256 bins in total.  The first and last bin are for values below the lower bound/above the upper
// bound.
const NUM_HISTOGRAM_BINS_IN_RANGE = 254;
const NUM_CDF_LINES = NUM_HISTOGRAM_BINS_IN_RANGE + 1;
class CdfPanel extends IndirectRenderedPanel {
    constructor(parent) {
        super(parent.display, document.createElement('div'), parent.visibility);
        this.parent = parent;
        this.controller = this.registerDisposer(new CdfController(this.element, this.parent.dataType, () => this.parent.trackable.value, value => {
            this.parent.trackable.value = value;
        }));
        this.dataValuesBuffer = this.registerDisposer(getMemoizedBuffer(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, () => {
            const array = new Uint8Array(NUM_CDF_LINES * VERTICES_PER_LINE);
            for (let i = 0; i < NUM_CDF_LINES; ++i) {
                for (let j = 0; j < VERTICES_PER_LINE; ++j) {
                    array[i * VERTICES_PER_LINE + j] = i;
                }
            }
            return array;
        })).value;
        this.lineShader = this.registerDisposer((() => {
            const builder = new ShaderBuilder(this.gl);
            defineLineShader(builder);
            builder.addTextureSampler('sampler2D', 'uHistogramSampler', histogramSamplerTextureUnit);
            builder.addOutputBuffer('vec4', 'out_color', 0);
            builder.addAttribute('uint', 'aDataValue');
            builder.addUniform('float', 'uBoundsFraction');
            builder.addVertexCode(`
float getCount(int i) {
  return texelFetch(uHistogramSampler, ivec2(i, 0), 0).x;
}
vec4 getVertex(float cdf, int i) {
  float x;
  if (i == 0) {
    x = -1.0;
  } else if (i == 255) {
    x = 1.0;
  } else {
    x = float(i) / 254.0 * uBoundsFraction * 2.0 - 1.0;
  }
  return vec4(x, cdf * (2.0 - uLineParams.y) - 1.0 + uLineParams.y * 0.5, 0.0, 1.0);
}
`);
            builder.setVertexMain(`
int lineNumber = int(aDataValue);
int dataValue = lineNumber;
float cumSum = 0.0;
for (int i = 0; i <= dataValue; ++i) {
  cumSum += getCount(i);
}
float total = cumSum + getCount(dataValue + 1);
float cumSumEnd = dataValue == ${NUM_CDF_LINES - 1} ? cumSum : total;
if (dataValue == ${NUM_CDF_LINES - 1}) {
  cumSum + getCount(dataValue + 1);
}
for (int i = dataValue + 2; i < 256; ++i) {
  total += getCount(i);
}
total = max(total, 1.0);
float cdf1 = cumSum / total;
float cdf2 = cumSumEnd / total;
emitLine(getVertex(cdf1, lineNumber), getVertex(cdf2, lineNumber + 1), 1.0);
`);
            builder.setFragmentMain(`
out_color = vec4(0.0, 1.0, 1.0, getLineAlpha());
`);
            return builder.build();
        })());
        this.regionCornersBuffer = getSquareCornersBuffer(this.gl, 0, -1, 1, 1);
        this.regionShader = this.registerDisposer((() => {
            const builder = new ShaderBuilder(this.gl);
            builder.addAttribute('vec2', 'aVertexPosition');
            builder.addUniform('vec2', 'uBounds');
            builder.addUniform('vec4', 'uColor');
            builder.addOutputBuffer('vec4', 'out_color', 0);
            builder.setVertexMain(`
gl_Position = vec4(mix(uBounds[0], uBounds[1], aVertexPosition.x) * 2.0 - 1.0, aVertexPosition.y, 0.0, 1.0);
`);
            builder.setFragmentMain(`
out_color = uColor;
`);
            return builder.build();
        })());
        const element = this.element;

        element.classList.add('neuroglancer-invlerp-cdfpanel');
    }
    get drawOrder() {
        return 100;
    }
    drawIndirect() {
        const lineShader = this.lineShader,
              gl = this.gl,
              regionShader = this.regionShader;
        var _parent = this.parent;
        const dataType = _parent.dataType,
              bounds = _parent.trackable.value;

        this.setGLLogicalViewport();
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
        gl.enable(WebGL2RenderingContext.BLEND);
        gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
        gl.disable(WebGL2RenderingContext.DEPTH_TEST);
        gl.disable(WebGL2RenderingContext.STENCIL_TEST);
        {
            regionShader.bind();
            gl.uniform4f(regionShader.uniform('uColor'), 0.2, 0.2, 0.2, 1.0);
            const fraction0 = computeInvlerp(bounds.window, bounds.range[0]),
                  fraction1 = computeInvlerp(bounds.window, bounds.range[1]);
            const effectiveFraction = getIntervalBoundsEffectiveFraction(dataType, bounds.window);
            gl.uniform2f(regionShader.uniform('uBounds'), Math.min(fraction0, fraction1) * effectiveFraction, Math.max(fraction0, fraction1) * effectiveFraction + (1 - effectiveFraction));
            const aVertexPosition = regionShader.attribute('aVertexPosition');
            this.regionCornersBuffer.bindToVertexAttrib(aVertexPosition, /*componentsPerVertexAttribute=*/2,
            /*attributeType=*/WebGL2RenderingContext.FLOAT);
            gl.drawArrays(WebGL2RenderingContext.TRIANGLE_FAN, 0, 4);
            gl.disableVertexAttribArray(aVertexPosition);
        }
        if (this.parent.histogramSpecifications.producerVisibility.visible) {
            const renderViewport = this.renderViewport;

            lineShader.bind();
            initializeLineShader(lineShader, { width: renderViewport.logicalWidth, height: renderViewport.logicalHeight },
            /*featherWidthInPixels=*/1.0);
            const histogramTextureUnit = lineShader.textureUnit(histogramSamplerTextureUnit);
            gl.uniform1f(lineShader.uniform('uBoundsFraction'), getIntervalBoundsEffectiveFraction(dataType, bounds.window));
            gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + histogramTextureUnit);
            gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.parent.texture);
            setRawTextureParameters(gl);
            const aDataValue = lineShader.attribute('aDataValue');
            this.dataValuesBuffer.bindToVertexAttribI(aDataValue, /*componentsPerVertexAttribute=*/1,
            /*attributeType=*/WebGL2RenderingContext.UNSIGNED_BYTE);
            drawLines(gl, /*linesPerInstance=*/NUM_CDF_LINES, /*numInstances=*/1);
            gl.disableVertexAttribArray(aDataValue);
            gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
        }
        gl.disable(WebGL2RenderingContext.BLEND);
    }
    isReady() {
        return true;
    }
}
function dummyColorLegendShaderModule() {}
class ColorLegendPanel extends IndirectRenderedPanel {
    constructor(parent) {
        super(parent.display, document.createElement('div'), parent.visibility);
        this.parent = parent;
        this.cornersBuffer = getSquareCornersBuffer(this.gl, -1, -1, 1, 1);
        const element = this.element;

        element.classList.add('neuroglancer-invlerp-legend-panel');
        const shaderOptions = this.shaderOptions = parent.legendShaderOptions;
        this.shaderGetter = parameterizedEmitterDependentShaderGetter(this, this.gl, _Object$assign(_Object$assign({}, shaderOptions), { memoizeKey: { id: `colorLegendShader`, base: shaderOptions.memoizeKey }, defineShader: (builder, parameters, extraParameters) => {
                builder.addOutputBuffer('vec4', 'v4f_fragData0', 0);
                builder.addAttribute('vec2', 'aVertexPosition');
                builder.addUniform('float', 'uLegendOffset');
                builder.addVarying('float', 'vLinearPosition');
                builder.setVertexMain(`
gl_Position = vec4(aVertexPosition, 0.0, 1.0);
vLinearPosition = -uLegendOffset + ((aVertexPosition.x + 1.0) * 0.5) * (1.0 + 2.0 * uLegendOffset);
`);
                const dataType = this.parent.dataType;
                const shaderDataType = getShaderType(dataType);
                builder.addFragmentCode(defineLerpShaderFunction(builder, 'ng_colorLegendLerp', dataType));
                builder.addFragmentCode(`
void emit(vec4 v) {
  v4f_fragData0 = v;
}
${shaderDataType} getDataValue() {
  return ng_colorLegendLerp(vLinearPosition);
}
${shaderDataType} getDataValue(int dummyChannel) {
  return getDataValue();
}
${shaderDataType} getInterpolatedDataValue() {
  return getDataValue();
}
${shaderDataType} getInterpolatedDataValue(int dummyChannel) {
  return getDataValue();
}
`);
                shaderOptions.defineShader(builder, parameters, extraParameters);
            } }));
    }
    drawIndirect() {
        const shaderResult = this.shaderGetter(dummyColorLegendShaderModule);
        const shader = shaderResult.shader;

        if (shader === null) return;
        this.setGLLogicalViewport();
        const gl = this.gl;

        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
        shader.bind();
        this.shaderOptions.initializeShader(shaderResult);
        gl.enable(WebGL2RenderingContext.BLEND);
        var _parent2 = this.parent;
        const window = _parent2.trackable.value.window,
              dataType = _parent2.dataType;

        enableLerpShaderFunction(shader, 'ng_colorLegendLerp', this.parent.dataType, window);
        const legendOffset = getIntervalBoundsEffectiveOffset(dataType, window);
        gl.uniform1f(shader.uniform('uLegendOffset'), _Number$isFinite(legendOffset) ? legendOffset : 0);
        gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
        gl.disable(WebGL2RenderingContext.DEPTH_TEST);
        gl.disable(WebGL2RenderingContext.STENCIL_TEST);
        const aVertexPosition = shader.attribute('aVertexPosition');
        this.cornersBuffer.bindToVertexAttrib(aVertexPosition, /*componentsPerVertexAttribute=*/2,
        /*attributeType=*/WebGL2RenderingContext.FLOAT);
        gl.drawArrays(WebGL2RenderingContext.TRIANGLE_FAN, 0, 4);
        gl.disableVertexAttribArray(aVertexPosition);
    }
    isReady() {
        return true;
    }
}
function createRangeBoundInput(boundType, endpoint) {
    const e = document.createElement('input');
    e.addEventListener('focus', () => {
        e.select();
    });
    e.classList.add('neuroglancer-invlerp-widget-bound');
    e.classList.add(`neuroglancer-invlerp-widget-${boundType}-bound`);
    e.type = 'text';
    e.spellcheck = false;
    e.autocomplete = 'off';
    e.title = boundType === 'range' ? `Data value that maps to ${endpoint}` : `${endpoint === 0 ? 'Lower' : 'Upper'} bound for distribution`;
    return e;
}
function createRangeBoundInputs(boundType, dataType, model) {
    const container = document.createElement('div');
    container.classList.add('neuroglancer-invlerp-widget-bounds');
    container.classList.add(`neuroglancer-invlerp-widget-${boundType}-bounds`);
    const inputs = [createRangeBoundInput(boundType, 0), createRangeBoundInput(boundType, 1)];
    for (let endpointIndex = 0; endpointIndex < 2; ++endpointIndex) {
        const input = inputs[endpointIndex];
        input.addEventListener('input', () => {
            updateInputBoundWidth(input);
        });
        input.addEventListener('change', () => {
            const existingBounds = model.value;
            const existingInterval = existingBounds[boundType];
            try {
                const value = parseDataTypeValue(dataType, input.value);
                model.value = getUpdatedRangeAndWindowParameters(existingBounds, boundType, endpointIndex, value, /*fitRangeInWindow=*/true);
            } catch (_a) {
                updateInputBoundValue(input, existingInterval[endpointIndex]);
            }
        });
    }
    let spacers;
    container.appendChild(inputs[0]);
    container.appendChild(inputs[1]);
    if (boundType === 'range') {
        spacers = [document.createElement('div'), document.createElement('div'), document.createElement('div')];
        spacers[1].classList.add('neuroglancer-invlerp-widget-range-spacer');
        container.insertBefore(spacers[0], inputs[0]);
        container.insertBefore(spacers[1], inputs[1]);
        container.appendChild(spacers[2]);
    }
    return { container, inputs, spacers };
}
function updateInputBoundWidth(inputElement) {
    updateInputFieldWidth(inputElement, Math.max(1, inputElement.value.length + 0.1));
}
function updateInputBoundValue(inputElement, bound) {
    let boundString;
    if (bound instanceof Uint64 || _Number$isInteger(bound)) {
        boundString = bound.toString();
    } else {
        boundString = bound.toPrecision(6);
    }
    inputElement.value = boundString;
    updateInputBoundWidth(inputElement);
}
export function invertInvlerpRange(trackable) {
    const bounds = trackable.value;
    const range = bounds.range;

    trackable.value = _Object$assign(_Object$assign({}, bounds), { range: [range[1], range[0]] });
}
export function adjustInvlerpContrast(dataType, trackable, scaleFactor) {
    const bounds = trackable.value;
    const newLower = computeLerp(bounds.range, dataType, 0.5 - scaleFactor / 2);
    const newUpper = computeLerp(bounds.range, dataType, 0.5 + scaleFactor / 2);
    trackable.value = _Object$assign(_Object$assign({}, bounds), { range: [newLower, newUpper] });
}
export function adjustInvlerpBrightnessContrast(dataType, trackable, baseRange, brightnessAmount, contrastAmount) {
    const scaleFactor = Math.exp(contrastAmount);
    const bounds = trackable.value;
    const newLower = computeLerp(baseRange, dataType, 0.5 - scaleFactor / 2 + brightnessAmount);
    const newUpper = computeLerp(baseRange, dataType, 0.5 + scaleFactor / 2 + brightnessAmount);
    trackable.value = _Object$assign(_Object$assign({}, bounds), { range: [newLower, newUpper] });
}
export class InvlerpWidget extends Tab {
    constructor(visibility, display, dataType, trackable, histogramSpecifications, histogramIndex, legendShaderOptions) {
        super(visibility);
        this.display = display;
        this.dataType = dataType;
        this.trackable = trackable;
        this.histogramSpecifications = histogramSpecifications;
        this.histogramIndex = histogramIndex;
        this.legendShaderOptions = legendShaderOptions;
        this.cdfPanel = this.registerDisposer(new CdfPanel(this));
        this.boundElements = {
            range: createRangeBoundInputs('range', this.dataType, this.trackable),
            window: createRangeBoundInputs('window', this.dataType, this.trackable)
        };
        this.registerDisposer(histogramSpecifications.visibility.add(this.visibility));
        const element = this.element,
              boundElements = this.boundElements;

        if (legendShaderOptions !== undefined) {
            const legendPanel = this.registerDisposer(new ColorLegendPanel(this));
            element.appendChild(legendPanel.element);
        }
        const makeArrow = svg => {
            const icon = makeIcon({
                svg,
                title: 'Invert range',
                onClick: () => {
                    this.invertRange();
                }
            });
            boundElements.range.spacers[1].appendChild(icon);
            return icon;
        };
        this.invertArrows = [makeArrow(svg_arrowRight), makeArrow(svg_arrowLeft)];
        element.appendChild(boundElements.range.container);
        element.appendChild(this.cdfPanel.element);
        element.classList.add('neuroglancer-invlerp-widget');
        element.appendChild(boundElements.window.container);
        this.updateView();
        this.registerDisposer(trackable.changed.add(this.registerCancellable(animationFrameDebounce(() => this.updateView()))));
    }
    get texture() {
        return this.histogramSpecifications.getFramebuffers(this.display.gl)[this.histogramIndex].colorBuffers[0].texture;
    }
    invertRange() {
        invertInvlerpRange(this.trackable);
    }
    updateView() {
        const boundElements = this.boundElements;
        const bounds = this.trackable.value,
              dataType = this.dataType;

        for (let i = 0; i < 2; ++i) {
            updateInputBoundValue(boundElements.range.inputs[i], bounds.range[i]);
            updateInputBoundValue(boundElements.window.inputs[i], bounds.window[i]);
        }
        const reversed = dataTypeCompare(bounds.range[0], bounds.range[1]) > 0;
        boundElements.range.container.style.flexDirection = !reversed ? 'row' : 'row-reverse';
        const clampedRange = getClampedInterval(bounds.window, bounds.range);
        const spacers = boundElements.range.spacers;
        const effectiveFraction = getIntervalBoundsEffectiveFraction(dataType, bounds.window);
        const leftOffset = computeInvlerp(bounds.window, clampedRange[reversed ? 1 : 0]) * effectiveFraction;
        const rightOffset = computeInvlerp(bounds.window, clampedRange[reversed ? 0 : 1]) * effectiveFraction + (1 - effectiveFraction);
        spacers[reversed ? 2 : 0].style.width = `${leftOffset * 100}%`;
        spacers[reversed ? 0 : 2].style.width = `${(1 - rightOffset) * 100}%`;
        const invertArrows = this.invertArrows;

        invertArrows[reversed ? 1 : 0].style.display = '';
        invertArrows[reversed ? 0 : 1].style.display = 'none';
    }
}
//# sourceMappingURL=invlerp.js.map