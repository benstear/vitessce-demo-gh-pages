/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { animationFrameDebounce } from '../util/animation_frame_debounce';
import { spliceArray } from '../util/array';
import { RefCounted } from '../util/disposable';
import { removeFromParent, updateChildren } from '../util/dom';
// Must be a multiple of 2.
const defaultNumItemsToRender = 10;
const overRenderFraction = 0.5;
export class VirtualListState {
    constructor() {
        /**
         * Index of list element that serves as an anchor for positioning the rendered elements relative
         * to the scroll container.
         */
        this.anchorIndex = 0;
        /**
         * Offset of start of anchor item in pixels from the top of the visible content.  May be negative
         * to indicate that the anchor item starts before the visible viewport.
         */
        this.anchorClientOffset = 0;
    }
    splice(splices) {
        let anchorIndex = this.anchorIndex;

        let offset = 0;
        for (const splice of splices) {
            offset += splice.retainCount;
            if (anchorIndex < offset) break;
            const deleteCount = splice.deleteCount;

            if (anchorIndex < offset + deleteCount) {
                anchorIndex = offset;
                break;
            }
            const insertCount = splice.insertCount;

            anchorIndex = anchorIndex - deleteCount + insertCount;
            offset += insertCount - insertCount;
        }
        this.anchorIndex = anchorIndex;
    }
}
class RenderParameters {
    constructor() {
        this.startIndex = 0;
        this.endIndex = 0;
        this.anchorIndex = 0;
        this.anchorOffset = 0;
        this.scrollOffset = 0;
    }
}
class SizeEstimates {
    constructor() {
        /**
         * If height of item `i` has already been determined, it is set in `itemSize[i]`.  Otherwise,
         * `itemSize[i]` is `undefined`.
         */
        this.itemSize = [];
        /**
         * Sum of non-`undefined` values in `itemSize`.
         */
        this.totalKnownSize = 0;
        /**
         * Number of non-`undefined` values in `itemSize`.
         */
        this.numItemsInTotalKnownSize = 0;
    }
    get averageSize() {
        return this.totalKnownSize / this.numItemsInTotalKnownSize;
    }
    getEstimatedSize(index) {
        var _a;
        return (_a = this.itemSize[index]) !== null && _a !== void 0 ? _a : this.averageSize;
    }
    getEstimatedTotalSize() {
        return this.totalKnownSize / this.numItemsInTotalKnownSize * this.itemSize.length;
    }
    getEstimatedOffset(index, hintIndex = 0, hintOffset = 0) {
        for (; hintIndex < index; ++hintIndex) {
            hintOffset += this.getEstimatedSize(hintIndex);
        }
        for (; hintIndex > index; --hintIndex) {
            hintOffset -= this.getEstimatedSize(hintIndex - 1);
        }
        return hintOffset;
    }
    getRangeSize(begin, end) {
        var _a;
        let size = 0;
        const itemSize = this.itemSize,
              averageSize = this.averageSize;

        for (let i = begin; i < end; ++i) {
            size += (_a = itemSize[i]) !== null && _a !== void 0 ? _a : averageSize;
        }
        return size;
    }
    splice(splices) {
        let itemSize = this.itemSize;

        itemSize = this.itemSize = spliceArray(itemSize, splices);
        this.totalKnownSize = itemSize.reduce((a, b) => a + b, 0);
        this.numItemsInTotalKnownSize = itemSize.reduce(a => a + 1, 0);
    }
}
function updateRenderParameters(newParams, prevParams, numItems, viewportHeight, sizes, state) {
    let anchorIndex = state.anchorIndex,
        anchorClientOffset = state.anchorClientOffset;

    let anchorOffset = sizes.getEstimatedOffset(anchorIndex);
    let renderStartIndex;
    let renderEndIndex;
    let renderAnchorOffset;
    let renderScrollOffset;
    let renderAnchorIndex;
    if (viewportHeight === 0 || sizes.totalKnownSize === 0) {
        // Guess
        renderStartIndex = Math.max(0, anchorIndex - defaultNumItemsToRender / 2);
        renderEndIndex = Math.min(numItems, renderStartIndex + defaultNumItemsToRender);
        renderAnchorIndex = anchorIndex;
        renderAnchorOffset = 0;
        renderScrollOffset = anchorClientOffset;
    } else {
        const totalSize = sizes.getEstimatedTotalSize();
        const maxScrollOffset = Math.max(0, totalSize - viewportHeight);
        // Restrict anchorOffset and anchorClientOffset to be valid.
        renderScrollOffset = anchorOffset - anchorClientOffset;
        renderScrollOffset = Math.max(0, Math.min(maxScrollOffset, renderScrollOffset));
        const minStartOffset = renderScrollOffset - 2 * overRenderFraction * viewportHeight;
        const maxStartOffset = renderScrollOffset - overRenderFraction * viewportHeight;
        const minEndOffset = renderScrollOffset + viewportHeight + overRenderFraction * viewportHeight;
        const maxEndOffset = anchorOffset - anchorClientOffset + viewportHeight + 2 * overRenderFraction * viewportHeight;
        // Update renderStartIndex
        renderStartIndex = Math.min(numItems, prevParams.startIndex);
        let renderStartOffset = sizes.getEstimatedOffset(renderStartIndex, anchorIndex, anchorOffset);
        if (renderStartOffset < minStartOffset) {
            for (; renderStartIndex + 1 < numItems; ++renderStartIndex) {
                const itemSize = sizes.getEstimatedSize(renderStartIndex);
                if (renderStartOffset + itemSize >= maxStartOffset) break;
                renderStartOffset += itemSize;
            }
        }
        if (renderStartOffset >= maxStartOffset) {
            for (; renderStartOffset > minStartOffset && renderStartIndex > 0; --renderStartIndex) {
                const itemSize = sizes.getEstimatedSize(renderStartIndex - 1);
                renderStartOffset -= itemSize;
            }
        }
        // Update renderEndIndex
        renderEndIndex = Math.min(numItems, prevParams.endIndex);
        let renderEndOffset = sizes.getEstimatedOffset(renderEndIndex, anchorIndex, anchorOffset);
        if (renderEndOffset < minEndOffset) {
            for (; renderEndOffset <= maxEndOffset && renderEndIndex + 1 <= numItems; ++renderEndIndex) {
                const itemSize = sizes.getEstimatedSize(renderEndIndex);
                renderEndOffset += itemSize;
            }
        } else if (renderEndOffset >= maxEndOffset) {
            for (; renderEndIndex > renderStartIndex; --renderEndIndex) {
                const itemSize = sizes.getEstimatedSize(renderEndIndex - 1);
                if (renderEndOffset - itemSize < minEndOffset) break;
                renderEndOffset -= itemSize;
            }
        }
        // Update renderAnchorIndex and renderAnchorPixel
        renderAnchorIndex = anchorIndex;
        renderAnchorOffset = anchorOffset;
        for (; renderAnchorIndex < renderStartIndex; ++renderAnchorIndex) {
            const itemSize = sizes.getEstimatedSize(renderAnchorIndex);
            renderAnchorOffset += itemSize;
        }
        for (; renderAnchorIndex > renderEndIndex; --renderAnchorIndex) {
            const itemSize = sizes.getEstimatedSize(renderAnchorIndex - 1);
            renderAnchorOffset -= itemSize;
        }
    }
    newParams.startIndex = renderStartIndex;
    newParams.endIndex = renderEndIndex;
    newParams.anchorIndex = renderAnchorIndex;
    newParams.anchorOffset = renderAnchorOffset;
    newParams.scrollOffset = renderScrollOffset;
}
function normalizeRenderParams(p, sizes) {
    const anchorOffset = sizes.getEstimatedOffset(p.anchorIndex);
    const oldAnchorOffset = p.anchorOffset;
    p.anchorOffset = anchorOffset;
    p.scrollOffset += anchorOffset - oldAnchorOffset;
}
function rerenderNeeded(newParams, prevParams) {
    return newParams.startIndex < prevParams.startIndex || newParams.endIndex > prevParams.endIndex;
}
export class VirtualList extends RefCounted {
    constructor(options) {
        super();
        // Outer scrollable element
        this.element = document.createElement('div');
        // Inner element (not scrollable) that contains `header` and `body`.
        this.scrollContent = document.createElement('div');
        this.header = document.createElement('div');
        // Contains `topItems` and `bottomItems` as children.
        this.body = document.createElement('div');
        this.topItems = document.createElement('div');
        this.bottomItems = document.createElement('div');
        this.renderedItems = [];
        this.renderGeneration = -1;
        this.listGeneration = -1;
        this.newRenderedItems = [];
        this.state = new VirtualListState();
        this.renderParams = new RenderParameters();
        this.newRenderParams = new RenderParameters();
        this.sizes = new SizeEstimates();
        this.debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateView()));
        this.resizeObserver = new ResizeObserver(() => this.updateView());
        const selectedIndex = options.selectedIndex;

        if (selectedIndex !== undefined) {
            this.state.anchorIndex = selectedIndex;
            this.state.anchorClientOffset = 0;
        }
        const source = this.source = options.source;
        this.sizes.itemSize.length = source.length;
        const element = this.element,
              header = this.header,
              body = this.body,
              scrollContent = this.scrollContent,
              topItems = this.topItems,
              bottomItems = this.bottomItems;

        this.resizeObserver.observe(element);
        this.registerDisposer(() => this.resizeObserver.disconnect());
        element.appendChild(scrollContent);
        // The default scroll anchoring behavior of browsers interacts poorly with this virtual list
        // mechanism and is unnecessary.
        element.style.overflowAnchor = 'none';
        scrollContent.appendChild(header);
        scrollContent.appendChild(body);
        header.style.position = 'sticky';
        header.style.zIndex = '1';
        header.style.top = '0';
        if (options.horizontalScroll) {
            scrollContent.style.width = 'min-content';
            scrollContent.style.minWidth = '100%';
            header.style.width = 'min-content';
            header.style.minWidth = '100%';
            bottomItems.style.width = 'min-content';
            bottomItems.style.minWidth = '100%';
        } else {
            scrollContent.style.width = '100%';
            header.style.width = '100%';
            bottomItems.style.width = '100%';
        }
        body.appendChild(topItems);
        body.appendChild(bottomItems);
        topItems.style.width = 'min-content';
        topItems.style.position = 'relative';
        topItems.style.height = '0';
        topItems.style.minWidth = '100%';
        bottomItems.style.height = '0';
        bottomItems.style.position = 'relative';
        element.addEventListener('scroll', () => {
            const scrollOffset = element.scrollTop;
            this.state.anchorClientOffset = this.renderParams.anchorOffset - scrollOffset;
            this.renderParams.scrollOffset = scrollOffset;
            this.debouncedUpdateView();
        });
        if (source.changed !== undefined) {
            this.registerDisposer(source.changed.add(splices => {
                this.sizes.splice(splices);
                this.state.splice(splices);
                this.renderedItems.length = 0;
                this.debouncedUpdateView();
            }));
        }
        if (source.renderChanged !== undefined) {
            this.registerDisposer(source.renderChanged.add(this.debouncedUpdateView));
        }
    }
    updateView() {
        const element = this.element;

        if (element.offsetHeight === 0) {
            // Element not visible
            return;
        }
        const viewportHeight = element.clientHeight - this.header.offsetHeight;
        const source = this.source,
              state = this.state,
              sizes = this.sizes;

        const numItems = source.length;
        const body = this.body,
              topItems = this.topItems,
              bottomItems = this.bottomItems;
        const changed = source.changed,
              renderChanged = source.renderChanged;

        let renderParams;
        while (true) {
            renderParams = this.newRenderParams;
            const prevRenderParams = this.renderParams;
            updateRenderParameters(renderParams, prevRenderParams, numItems, viewportHeight, sizes, state);
            let forceRender;
            if (renderChanged !== undefined && renderChanged.count !== this.renderGeneration || changed !== undefined && changed.count !== this.listGeneration) {
                this.renderGeneration = renderChanged === undefined ? -1 : renderChanged.count;
                this.listGeneration = changed === undefined ? -1 : changed.count;
                forceRender = true;
                this.renderedItems.length = 0;
            } else {
                forceRender = false;
            }
            if (!forceRender && !rerenderNeeded(renderParams, prevRenderParams)) {
                prevRenderParams.scrollOffset = renderParams.scrollOffset;
                renderParams = prevRenderParams;
                break;
            }
            this.renderParams = renderParams;
            this.newRenderParams = prevRenderParams;
            const prevRenderedItems = this.renderedItems;
            const renderedItems = this.newRenderedItems;
            renderedItems.length = 0;
            this.renderedItems = renderedItems;
            this.newRenderedItems = prevRenderedItems;
            const source = this.source;
            const render = source.render;
            var _renderParams = renderParams;
            const curStartIndex = _renderParams.startIndex,
                  curEndIndex = _renderParams.endIndex,
                  anchorIndex = _renderParams.anchorIndex;

            function* getChildren(start, end) {
                for (let i = start; i < end; ++i) {
                    let item = prevRenderedItems[i];
                    if (item === undefined) {
                        item = render.call(source, i);
                    }
                    renderedItems[i] = item;
                    yield item;
                }
            }
            updateChildren(topItems, getChildren(curStartIndex, anchorIndex));
            updateChildren(bottomItems, getChildren(anchorIndex, curEndIndex));
            // Update item size estimates.
            for (let i = curStartIndex; i < curEndIndex; ++i) {
                const element = renderedItems[i];
                const bounds = element.getBoundingClientRect();
                const newSize = bounds.height;
                const existingSize = sizes.itemSize[i];
                if (existingSize !== undefined) {
                    sizes.totalKnownSize -= existingSize;
                    --sizes.numItemsInTotalKnownSize;
                }
                sizes.itemSize[i] = newSize;
                sizes.totalKnownSize += newSize;
                ++sizes.numItemsInTotalKnownSize;
            }
        }
        normalizeRenderParams(renderParams, sizes);
        state.anchorIndex = renderParams.anchorIndex;
        state.anchorClientOffset = renderParams.anchorOffset - renderParams.scrollOffset;
        const topSize = sizes.getRangeSize(renderParams.startIndex, renderParams.anchorIndex);
        const totalHeight = sizes.getEstimatedTotalSize();
        body.style.height = `${totalHeight}px`;
        topItems.style.top = `${renderParams.anchorOffset - topSize}px`;
        bottomItems.style.top = `${renderParams.anchorOffset}px`;
        element.scrollTop = renderParams.scrollOffset;
    }
    getItemElement(index) {
        return this.renderedItems[index];
    }
    forEachRenderedItem(callback) {
        var _renderParams2 = this.renderParams;
        const startIndex = _renderParams2.startIndex,
              endIndex = _renderParams2.endIndex;
        const renderedItems = this.renderedItems;

        for (let i = startIndex; i < endIndex; ++i) {
            const item = renderedItems[i];
            if (item === undefined) continue;
            callback(item, i);
        }
    }
    scrollToTop() {
        this.state.anchorIndex = 0;
        this.state.anchorClientOffset = 0;
        this.debouncedUpdateView();
    }
    scrollItemIntoView(index) {
        const itemStartOffset = this.sizes.getEstimatedOffset(index);
        const itemEndOffset = itemStartOffset + this.sizes.getEstimatedSize(index);
        const startOffset = this.element.scrollTop;
        if (itemStartOffset < startOffset) {
            this.state.anchorIndex = index;
            this.state.anchorClientOffset = 0;
        } else if (itemStartOffset > startOffset && itemEndOffset > startOffset + this.element.offsetHeight) {
            this.state.anchorIndex = index + 1;
            this.state.anchorClientOffset = this.element.offsetHeight;
        } else {
            return;
        }
        this.debouncedUpdateView();
    }
    disposed() {
        removeFromParent(this.element);
    }
}
//# sourceMappingURL=virtual_list.js.map