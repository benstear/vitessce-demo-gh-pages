import _Object$assign from 'babel-runtime/core-js/object/assign';

import { insertDimensionAt } from '../coordinate_transform'; /**
                                                              * @license
                                                              * Copyright 2019 Google Inc.
                                                              * Licensed under the Apache License, Version 2.0 (the "License");
                                                              * you may not use this file except in compliance with the License.
                                                              * You may obtain a copy of the License at
                                                              *
                                                              *      http://www.apache.org/licenses/LICENSE-2.0
                                                              *
                                                              * Unless required by applicable law or agreed to in writing, software
                                                              * distributed under the License is distributed on an "AS IS" BASIS,
                                                              * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                              * See the License for the specific language governing permissions and
                                                              * limitations under the License.
                                                              */

import { animationFrameDebounce } from '../util/animation_frame_debounce';
import { arraysEqual } from '../util/array';
import { RefCounted } from '../util/disposable';
import { updateChildren, updateInputFieldWidth } from '../util/dom';
import { KeyboardEventBinder, registerActionListener } from '../util/keyboard_bindings';
import { EventActionMap } from '../util/mouse_bindings';
const inputEventMap = EventActionMap.fromObject({
    'arrowup': { action: 'tab-backward' },
    'arrowdown': { action: 'tab-forward' },
    'tab': { action: 'tab-forward' },
    'shift+tab': { action: 'tab-backward' },
    'enter': { action: 'commit' },
    'escape': { action: 'cancel' }
});
class DimensionWidget {
    constructor(id) {
        this.id = id;
        this.element = document.createElement('div');
        this.nameContainer = document.createElement('div');
        this.nameElement = document.createElement('input');
        this.lowerElement = document.createElement('div');
        this.upperElement = document.createElement('div');
        const element = this.element,
              nameContainer = this.nameContainer,
              nameElement = this.nameElement,
              lowerElement = this.lowerElement,
              upperElement = this.upperElement;

        element.classList.add('neuroglancer-channel-dimensions-widget-dim');
        nameContainer.classList.add('neuroglancer-channel-dimensions-widget-name-container');
        nameElement.classList.add('neuroglancer-channel-dimensions-widget-name');
        nameContainer.appendChild(nameElement);
        lowerElement.classList.add('neuroglancer-channel-dimensions-widget-lower');
        upperElement.classList.add('neuroglancer-channel-dimensions-widget-upper');
        element.appendChild(nameContainer);
        element.appendChild(lowerElement);
        element.appendChild(upperElement);
        nameContainer.draggable = true;
        nameElement.disabled = true;
        nameElement.spellcheck = false;
        nameElement.autocomplete = 'off';
        nameElement.required = true;
        nameElement.placeholder = ' ';
        nameContainer.title = `Drag to reorder, double click to rename.  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).`;
        nameContainer.addEventListener('dblclick', () => {
            nameElement.disabled = false;
            nameElement.focus();
            nameElement.select();
        });
        nameElement.addEventListener('focus', () => {
            nameElement.select();
        });
    }
}
export class ChannelDimensionsWidget extends RefCounted {
    constructor(combiner) {
        super();
        this.combiner = combiner;
        this.element = document.createElement('div');
        this.dimensionWidgets = [];
        this.curCoordinateSpace = undefined;
        this.dragSource = undefined;
        this.coordinateSpace = this.combiner.combined;
        const element = this.element;

        element.classList.add('neuroglancer-channel-dimensions-widget');
        const debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateView()));
        this.registerDisposer(combiner.combined.changed.add(debouncedUpdateView));
        const keyboardHandler = this.registerDisposer(new KeyboardEventBinder(element, inputEventMap));
        keyboardHandler.allShortcutsAreGlobal = true;
        this.registerDisposer(registerActionListener(element, 'cancel', event => {
            this.forceUpdateView();
            const target = event.target;

            if (target instanceof HTMLElement) {
                target.blur();
            }
        }));
        this.updateView();
    }
    reorderDimensionTo(targetIndex, sourceIndex) {
        if (targetIndex === sourceIndex) return;
        const coordinateSpace = this.coordinateSpace;

        coordinateSpace.value = insertDimensionAt(coordinateSpace.value, targetIndex, sourceIndex);
    }
    makeNewDimensionWidget(id) {
        const widget = new DimensionWidget(id);
        widget.nameContainer.addEventListener('dragstart', event => {
            this.dragSource = widget;
            event.stopPropagation();
            event.dataTransfer.setData('neuroglancer-dimension', '');
        });
        widget.nameContainer.addEventListener('dragenter', event => {
            const dragSource = this.dragSource;

            if (dragSource === undefined || dragSource === widget) return;
            const dimensionWidgets = this.dimensionWidgets;

            const sourceIndex = dimensionWidgets.indexOf(dragSource);
            const targetIndex = dimensionWidgets.indexOf(widget);
            if (sourceIndex === -1 || targetIndex === -1) return;
            event.preventDefault();
            this.reorderDimensionTo(targetIndex, sourceIndex);
        });
        widget.nameContainer.addEventListener('dragend', event => {
            event;
            if (this.dragSource === widget) {
                this.dragSource = undefined;
            }
        });
        widget.nameElement.addEventListener('blur', event => {
            widget.nameElement.disabled = true;
            const relatedTarget = event.relatedTarget;

            if (this.dimensionWidgets.some(widget => widget.nameElement === relatedTarget)) {
                return;
            }
            if (!this.updateNames()) {
                this.forceUpdateView();
            }
        });
        widget.nameElement.addEventListener('input', () => {
            const nameElement = widget.nameElement;

            updateInputFieldWidth(nameElement);
            this.updateNameValidity();
        });
        registerActionListener(widget.nameElement, 'commit', () => {
            this.updateNames();
        });
        registerActionListener(widget.nameElement, 'tab-forward', event => this.selectAdjacentField(event, widget, +1));
        registerActionListener(widget.nameElement, 'tab-backward', event => this.selectAdjacentField(event, widget, -1));
        return widget;
    }
    selectAdjacentField(event, widget, dir) {
        event.stopPropagation();
        const dimensionWidgets = this.dimensionWidgets;

        const dimIndex = dimensionWidgets.indexOf(widget);
        if (dimIndex === -1) return;
        const nextIndex = dimIndex + dir;
        if (nextIndex < 0 || nextIndex >= dimensionWidgets.length) return;
        const nextWidget = dimensionWidgets[nextIndex];
        nextWidget.nameElement.disabled = false;
        nextWidget.nameElement.focus();
        event.preventDefault();
    }
    updateNames() {
        const dimensionWidgets = this.dimensionWidgets,
              coordinateSpace = this.coordinateSpace;

        const existing = coordinateSpace.value;
        const names = dimensionWidgets.map(x => x.nameElement.value);
        if (this.combiner.getRenameValidity(names).includes(false)) return false;
        const existingNames = existing.names;
        if (arraysEqual(existingNames, names)) return false;
        const timestamps = existing.timestamps.map((t, i) => existingNames[i] === names[i] ? t : Date.now());
        const newSpace = _Object$assign(_Object$assign({}, existing), { names, timestamps });
        coordinateSpace.value = newSpace;
        return true;
    }
    updateNameValidity() {
        const dimensionWidgets = this.dimensionWidgets;

        const names = dimensionWidgets.map(w => w.nameElement.value);
        const rank = names.length;
        const isValid = this.combiner.getRenameValidity(names);
        for (let i = 0; i < rank; ++i) {
            dimensionWidgets[i].nameElement.dataset.isValid = isValid[i] === false ? 'false' : 'true';
        }
    }
    forceUpdateView() {
        this.curCoordinateSpace = undefined;
        this.updateView();
    }
    updateView() {
        const coordinateSpace = this.coordinateSpace.value;

        if (this.curCoordinateSpace === coordinateSpace) return;
        this.curCoordinateSpace = coordinateSpace;
        const element = this.element;

        const oldDimensionWidgets = this.dimensionWidgets;
        const dimensionWidgets = this.dimensionWidgets = coordinateSpace.ids.map(id => oldDimensionWidgets.find(x => x.id === id) || this.makeNewDimensionWidget(id));
        function* getChildren() {
            const names = coordinateSpace.names,
                  rank = coordinateSpace.rank;
            var _coordinateSpace$boun = coordinateSpace.bounds;
            const lowerBounds = _coordinateSpace$boun.lowerBounds,
                  upperBounds = _coordinateSpace$boun.upperBounds;

            for (let i = 0; i < rank; ++i) {
                const widget = dimensionWidgets[i];
                widget.nameElement.value = names[i];
                delete widget.nameElement.dataset.isValid;
                updateInputFieldWidth(widget.nameElement);
                widget.lowerElement.textContent = lowerBounds[i].toString();
                widget.upperElement.textContent = upperBounds[i].toString();
                yield widget.element;
            }
        }
        updateChildren(element, getChildren.call(this));
    }
}
//# sourceMappingURL=channel_dimensions_widget.js.map