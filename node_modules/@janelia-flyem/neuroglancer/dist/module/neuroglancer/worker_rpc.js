import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { CANCELED, CancellationTokenSource, makeCancelablePromise, uncancelableToken } from './util/cancellation';
import { RefCounted } from './util/disposable';
const IS_WORKER = !(typeof Window !== 'undefined' && self instanceof Window);
const DEBUG = false;
const DEBUG_MESSAGES = false;
const PROMISE_RESPONSE_ID = 'rpc.promise.response';
const PROMISE_CANCEL_ID = 'rpc.promise.cancel';
var handlers = new _Map();
export function registerRPC(key, handler) {
    handlers.set(key, handler);
}
export class RPCError extends Error {
    constructor(name, message) {
        super(message);
        this.name = name;
        this.message = message;
    }
}
export function registerPromiseRPC(key, handler) {
    registerRPC(key, function (x) {
        let id = x['id'];
        const cancellationToken = new CancellationTokenSource();
        let promise = handler.call(this, x, cancellationToken);
        this.set(id, { promise, cancellationToken });
        promise.then(({ value, transfers }) => {
            this.delete(id);
            this.invoke(PROMISE_RESPONSE_ID, { 'id': id, 'value': value }, transfers);
        }, error => {
            this.delete(id);
            this.invoke(PROMISE_RESPONSE_ID, { 'id': id, 'error': error.message, 'errorName': error.name });
        });
    });
}
registerRPC(PROMISE_CANCEL_ID, function (x) {
    let id = x['id'];
    const request = this.get(id);
    if (request !== undefined) {
        let cancellationToken = request.cancellationToken;

        cancellationToken.cancel();
    }
});
registerRPC(PROMISE_RESPONSE_ID, function (x) {
    let id = x['id'];

    var _get = this.get(id);

    let resolve = _get.resolve,
        reject = _get.reject;

    this.delete(id);
    if (x.hasOwnProperty('value')) {
        resolve(x['value']);
    } else {
        const errorName = x['errorName'];
        if (errorName === CANCELED.name) {
            reject(CANCELED);
        } else {
            reject(new RPCError(x['errorName'], x['error']));
        }
    }
});
const INITIAL_RPC_ID = IS_WORKER ? -1 : 0;
export class RPC {
    constructor(target) {
        this.target = target;
        this.objects = new _Map();
        this.nextId = INITIAL_RPC_ID;
        target.onmessage = e => {
            let data = e.data;
            if (DEBUG_MESSAGES) {
                console.log('Received message', data);
            }
            handlers.get(data.functionName).call(this, data);
        };
    }
    get numObjects() {
        return this.objects.size;
    }
    set(id, value) {
        this.objects.set(id, value);
    }
    delete(id) {
        this.objects.delete(id);
    }
    get(id) {
        return this.objects.get(id);
    }
    getRef(x) {
        let rpcId = x['id'];
        let obj = this.get(rpcId);
        obj.referencedGeneration = x['gen'];
        obj.addRef();
        return obj;
    }
    getOptionalRef(x) {
        if (x === undefined) return undefined;
        let rpcId = x['id'];
        let obj = this.get(rpcId);
        obj.referencedGeneration = x['gen'];
        obj.addRef();
        return obj;
    }
    invoke(name, x, transfers) {
        x.functionName = name;
        if (DEBUG_MESSAGES) {
            console.trace('Sending message', x);
        }
        this.target.postMessage(x, transfers);
    }
    promiseInvoke(name, x, cancellationToken = uncancelableToken, transfers) {
        return makeCancelablePromise(cancellationToken, (resolve, reject, token) => {
            const id = x['id'] = this.newId();
            this.set(id, { resolve, reject });
            this.invoke(name, x, transfers);
            token.add(() => {
                this.invoke(PROMISE_CANCEL_ID, { 'id': id });
            });
        });
    }
    newId() {
        return IS_WORKER ? this.nextId-- : this.nextId++;
    }
}
export class SharedObject extends RefCounted {
    constructor() {
        super(...arguments);
        this.rpc = null;
        this.rpcId = null;
    }
    initializeSharedObject(rpc, rpcId = rpc.newId()) {
        this.rpc = rpc;
        this.rpcId = rpcId;
        this.isOwner = false;
        rpc.set(rpcId, this);
    }
    initializeCounterpart(rpc, options = {}) {
        this.initializeSharedObject(rpc);
        this.unreferencedGeneration = 0;
        this.referencedGeneration = 0;
        this.isOwner = true;
        options['id'] = this.rpcId;
        options['type'] = this.RPC_TYPE_ID;
        rpc.invoke('SharedObject.new', options);
    }
    dispose() {
        super.dispose();
    }
    /**
     * Precondition: this.isOwner === true.
     */
    addCounterpartRef() {
        return { 'id': this.rpcId, 'gen': ++this.referencedGeneration };
    }
    refCountReachedZero() {
        if (this.isOwner === true) {
            if (this.referencedGeneration === this.unreferencedGeneration) {
                this.ownerDispose();
            }
        } else if (this.isOwner === false) {
            this.rpc.invoke('SharedObject.refCountReachedZero', { 'id': this.rpcId, 'gen': this.referencedGeneration });
        } else {
            super.refCountReachedZero();
        }
    }
    /**
     * Precondition: this.isOwner === true.
     */
    ownerDispose() {
        if (DEBUG) {
            console.log(`[${IS_WORKER}] #rpc object = ${this.rpc.numObjects}`);
        }
        let rpc = this.rpc,
            rpcId = this.rpcId;

        super.refCountReachedZero();
        rpc.delete(rpcId);
        rpc.invoke('SharedObject.dispose', { 'id': rpcId });
    }
    /**
     * Precondition: this.isOwner === true.
     *
     * This should be called when the counterpart's refCount is decremented and reaches zero.
     */
    counterpartRefCountReachedZero(generation) {
        this.unreferencedGeneration = generation;
        if (this.refCount === 0 && generation === this.referencedGeneration) {
            this.ownerDispose();
        }
    }
}
export function initializeSharedObjectCounterpart(obj, rpc, options = {}) {
    if (rpc != null) {
        obj.initializeSharedObject(rpc, options['id']);
    }
}
/**
 * Base class for defining a SharedObject type that will never be owned.
 */
export class SharedObjectCounterpart extends SharedObject {
    constructor(rpc, options = {}) {
        super();
        initializeSharedObjectCounterpart(this, rpc, options);
    }
}
registerRPC('SharedObject.dispose', function (x) {
    let obj = this.get(x['id']);
    if (obj.refCount !== 0) {
        throw new Error(`Attempted to dispose object with non-zero reference count.`);
    }
    if (DEBUG) {
        console.log(`[${IS_WORKER}] #rpc objects: ${this.numObjects}`);
    }
    obj.disposed();
    this.delete(obj.rpcId);
    obj.rpcId = null;
    obj.rpc = null;
});
// RPC ID used to request the other thread to create a worker.
//
// On Safari, workers cannot themselves create additional workers.  As a workaround, workers can
// send the main thread a worker URL and a `MessagePort` and the main thread will create the worker
// and send it the message port.
export const WORKER_RPC_ID = 'Worker';
registerRPC(WORKER_RPC_ID, function (x) {
    const port = x.port,
          path = x.path;

    const worker = new Worker(path);
    worker.postMessage({ port }, [port]);
});
registerRPC('SharedObject.refCountReachedZero', function (x) {
    let obj = this.get(x['id']);
    let generation = x['gen'];
    obj.counterpartRefCountReachedZero(generation);
});
const sharedObjectConstructors = new _Map();
/**
 * Register a class as a SharedObject owner type under the specified identifier.
 *
 * This is intended to be used as a decorator.
 */
export function registerSharedObjectOwner(identifier) {
    return constructorFunction => {
        constructorFunction.prototype.RPC_TYPE_ID = identifier;
    };
}
/**
 * Register a class as a SharedObject counterpart type under the specified identifier.
 *
 * This is intended to be used as a decorator.
 *
 * Also register the type as a SharedObject owner, which is useful if this type is also used as a
 * SharedObject owner.
 */
export function registerSharedObject(identifier) {
    return constructorFunction => {
        if (identifier !== undefined) {
            constructorFunction.prototype.RPC_TYPE_ID = identifier;
        } else {
            identifier = constructorFunction.prototype.RPC_TYPE_ID;
            if (identifier === undefined) {
                throw new Error('RPC_TYPE_ID should have already been defined');
            }
        }
        sharedObjectConstructors.set(identifier, constructorFunction);
    };
}
registerRPC('SharedObject.new', function (x) {
    let rpc = this;
    let typeName = x['type'];
    let constructorFunction = sharedObjectConstructors.get(typeName);
    let obj = new constructorFunction(rpc, x);
    // Counterpart objects start with a reference count of zero.
    --obj.refCount;
});
//# sourceMappingURL=worker_rpc.js.map