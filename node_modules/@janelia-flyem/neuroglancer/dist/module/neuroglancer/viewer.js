import _Object$assign from 'babel-runtime/core-js/object/assign';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import svg_controls_alt from 'ikonate/icons/controls-alt.svg';
import svg_layers from 'ikonate/icons/layers.svg';
import svg_list from 'ikonate/icons/list.svg';
import svg_settings from 'ikonate/icons/settings.svg';
import debounce from 'lodash/debounce';
import { CapacitySpecification, ChunkManager, ChunkQueueManager } from './chunk_manager/frontend';
import { makeCoordinateSpace, TrackableCoordinateSpace } from './coordinate_transform';
import { defaultCredentialsManager } from './credentials_provider/default_manager';
import { InputEventBindings as DataPanelInputEventBindings } from './data_panel_layout';
import { getDefaultDataSourceProvider } from './datasource/default_provider';
import { StateShare, stateShareEnabled } from './datasource/state_share';
import { TrackableWindowedViewport } from './display_context';
import { HelpPanelState, InputEventBindingHelpDialog } from './help/input_event_bindings';
import { addNewLayer, LayerManager, LayerSelectedValues, MouseSelectionState, SelectedLayerState, TopLevelLayerListSpecification, TrackableDataSelectionState } from './layer';
import { RootLayoutContainer } from './layer_groups_layout';
import { DisplayPose, NavigationState, OrientationState, Position, TrackableCrossSectionZoom, TrackableDepthRange, TrackableDisplayDimensions, TrackableProjectionZoom, TrackableRelativeDisplayScales, WatchableDisplayDimensionRenderInfo } from './navigation_state';
import { overlaysOpen } from './overlay';
import { allRenderLayerRoles, RenderLayerRole } from './renderlayer';
import { StatusMessage } from './status';
import { ElementVisibilityFromTrackableBoolean, TrackableBoolean } from './trackable_boolean';
import { makeDerivedWatchableValue, observeWatchable, TrackableValue } from './trackable_value';
import { LayerArchiveCountWidget, LayerListPanel, LayerListPanelState } from './ui/layer_list_panel';
import { LayerSidePanelManager } from './ui/layer_side_panel';
import { setupPositionDropHandlers } from './ui/position_drag_and_drop';
import { SelectionDetailsPanel } from './ui/selection_details';
import { SidePanelManager } from './ui/side_panel';
import { StateEditorDialog } from './ui/state_editor';
import { StatisticsDisplayState, StatisticsPanel } from './ui/statistics';
import { ToolBinder } from './ui/tool';
import { ViewerSettingsPanel, ViewerSettingsPanelState } from './ui/viewer_settings';
import { AutomaticallyFocusedElement } from './util/automatic_focus';
import { TrackableRGB } from './util/color';
import { RefCounted } from './util/disposable';
import { removeFromParent } from './util/dom';
import { registerActionListener } from './util/event_action_map';
import { vec3 } from './util/geom';
import { parseFixedLengthArray, verifyFinitePositiveFloat, verifyObject, verifyOptionalObjectProperty, verifyString } from './util/json';
import { EventActionMap, KeyboardEventBinder } from './util/keyboard_bindings';
import { NullarySignal } from './util/signal';
import { CompoundTrackable, optionallyRestoreFromJsonMember } from './util/trackable';
import { WatchableVisibilityPriority } from './visibility_priority/frontend';
import { AnnotationToolStatusWidget } from './widget/annotation_tool_status';
import { CheckboxIcon } from './widget/checkbox_icon';
import { makeIcon } from './widget/icon';
import { MousePositionWidget, PositionWidget } from './widget/position_widget';
import { TrackableScaleBarOptions } from './widget/scale_bar';
import { RPC } from './worker_rpc';
import { setClipboard } from './util/clipboard';
import { encodeFragment } from './ui/url_hash_binding';
import { makeCopyButton } from './widget/copy_button';
export class DataManagementContext extends RefCounted {
    constructor(gl, frameNumberCounter, bundleRoot = '') {
        super();
        this.gl = gl;
        this.frameNumberCounter = frameNumberCounter;
        const chunk_worker_url = bundleRoot + 'chunk_worker.bundle.js';
        this.worker = new Worker(chunk_worker_url);
        this.chunkQueueManager = this.registerDisposer(new ChunkQueueManager(new RPC(this.worker), this.gl, this.frameNumberCounter, {
            gpuMemory: new CapacitySpecification({ defaultItemLimit: 1e6, defaultSizeLimit: 1e9 }),
            systemMemory: new CapacitySpecification({ defaultItemLimit: 1e7, defaultSizeLimit: 2e9 }),
            download: new CapacitySpecification({ defaultItemLimit: 100, defaultSizeLimit: Number.POSITIVE_INFINITY }),
            compute: new CapacitySpecification({ defaultItemLimit: 128, defaultSizeLimit: 5e8 })
        }));
        this.chunkQueueManager.registerDisposer(() => this.worker.terminate());
        this.chunkManager = this.registerDisposer(new ChunkManager(this.chunkQueueManager));
    }
    get rpc() {
        return this.chunkQueueManager.rpc;
    }
}
export class InputEventBindings extends DataPanelInputEventBindings {
    constructor() {
        super(...arguments);
        this.global = new EventActionMap();
    }
}
export const VIEWER_TOP_ROW_CONFIG_OPTIONS = ['showHelpButton', 'showSettingsButton', 'showEditStateButton', 'showLayerListPanelButton', 'showSelectionPanelButton', 'showLayerSidePanelButton', 'showLocation', 'showAnnotationToolStatus'];
export const VIEWER_UI_CONTROL_CONFIG_OPTIONS = [...VIEWER_TOP_ROW_CONFIG_OPTIONS, 'showLayerPanel', 'showLayerHoverValues'];
export const VIEWER_UI_CONFIG_OPTIONS = [...VIEWER_UI_CONTROL_CONFIG_OPTIONS, 'showUIControls', 'showPanelBorders'];
export function makeViewerUIConfiguration() {
    return Object.fromEntries(VIEWER_UI_CONFIG_OPTIONS.map(key => [key, new TrackableBoolean(true)]));
}
function setViewerUiConfiguration(config, options) {
    for (const key of VIEWER_UI_CONFIG_OPTIONS) {
        const value = options[key];
        if (value !== undefined) {
            config[key].value = value;
        }
    }
}
const defaultViewerOptions = 'undefined' !== typeof NEUROGLANCER_OVERRIDE_DEFAULT_VIEWER_OPTIONS ? NEUROGLANCER_OVERRIDE_DEFAULT_VIEWER_OPTIONS : {
    showLayerDialog: true,
    resetStateWhenEmpty: true
};
class TrackableViewerState extends CompoundTrackable {
    constructor(viewer) {
        super();
        this.viewer = viewer;
        this.add('title', viewer.title);
        this.add('dimensions', viewer.coordinateSpace);
        this.add('relativeDisplayScales', viewer.relativeDisplayScales);
        this.add('displayDimensions', viewer.displayDimensions);
        this.add('position', viewer.position);
        this.add('crossSectionOrientation', viewer.crossSectionOrientation);
        this.add('crossSectionScale', viewer.crossSectionScale);
        this.add('crossSectionDepth', viewer.crossSectionDepthRange);
        this.add('projectionOrientation', viewer.projectionOrientation);
        this.add('projectionScale', viewer.projectionScale);
        this.add('projectionDepth', viewer.projectionDepthRange);
        this.add('layers', viewer.layerSpecification);
        this.add('showAxisLines', viewer.showAxisLines);
        this.add('wireFrame', viewer.wireFrame);
        this.add('showScaleBar', viewer.showScaleBar);
        this.add('showDefaultAnnotations', viewer.showDefaultAnnotations);
        this.add('showSlices', viewer.showPerspectiveSliceViews);
        this.add('gpuMemoryLimit', viewer.dataContext.chunkQueueManager.capacities.gpuMemory.sizeLimit);
        this.add('prefetch', viewer.dataContext.chunkQueueManager.enablePrefetch);
        this.add('systemMemoryLimit', viewer.dataContext.chunkQueueManager.capacities.systemMemory.sizeLimit);
        this.add('concurrentDownloads', viewer.dataContext.chunkQueueManager.capacities.download.itemLimit);
        this.add('selectedLayer', viewer.selectedLayer);
        this.add('crossSectionBackgroundColor', viewer.crossSectionBackgroundColor);
        this.add('projectionBackgroundColor', viewer.perspectiveViewBackgroundColor);
        this.add('layout', viewer.layout);
        this.add('statistics', viewer.statisticsDisplayState);
        this.add('helpPanel', viewer.helpPanelState);
        this.add('settingsPanel', viewer.settingsPanelState);
        this.add('selection', viewer.selectionDetailsState);
        this.add('layerListPanel', viewer.layerListPanelState);
        this.add('partialViewport', viewer.partialViewport);
        this.add('selectedStateServer', viewer.selectedStateServer);
    }
    restoreState(obj) {
        const viewer = this.viewer;

        super.restoreState(obj);
        // Handle legacy properties
        verifyOptionalObjectProperty(obj, 'navigation', navObj => {
            verifyObject(navObj);
            verifyOptionalObjectProperty(navObj, 'pose', poseObj => {
                verifyObject(poseObj);
                verifyOptionalObjectProperty(poseObj, 'position', positionObj => {
                    verifyObject(positionObj);
                    optionallyRestoreFromJsonMember(positionObj, 'voxelCoordinates', viewer.position);
                    verifyOptionalObjectProperty(positionObj, 'voxelSize', voxelSizeObj => {
                        // Handle legacy voxelSize representation
                        const voxelSize = parseFixedLengthArray(new Float64Array(3), voxelSizeObj, verifyFinitePositiveFloat);
                        for (let i = 0; i < 3; ++i) {
                            voxelSize[i] *= 1e-9;
                        }
                        viewer.coordinateSpace.value = makeCoordinateSpace({
                            valid: false,
                            names: ['x', 'y', 'z'],
                            units: ['m', 'm', 'm'],
                            scales: voxelSize
                        });
                    });
                });
                optionallyRestoreFromJsonMember(poseObj, 'orientation', viewer.crossSectionOrientation);
            });
            optionallyRestoreFromJsonMember(navObj, 'zoomFactor', viewer.crossSectionScale.legacyJsonView);
        });
        optionallyRestoreFromJsonMember(obj, 'perspectiveOrientation', viewer.projectionOrientation);
        optionallyRestoreFromJsonMember(obj, 'perspectiveZoom', viewer.projectionScale.legacyJsonView);
        optionallyRestoreFromJsonMember(obj, 'perspectiveViewBackgroundColor', viewer.perspectiveViewBackgroundColor);
    }
}
export const globalViewerConfig = {
    expectingExternalUI: false
};
export class Viewer extends RefCounted {
    constructor(display, options = {}) {
        super();
        this.display = display;
        this.title = new TrackableValue(undefined, verifyString);
        this.coordinateSpace = new TrackableCoordinateSpace();
        this.position = this.registerDisposer(new Position(this.coordinateSpace));
        this.relativeDisplayScales = this.registerDisposer(new TrackableRelativeDisplayScales(this.coordinateSpace));
        this.displayDimensions = this.registerDisposer(new TrackableDisplayDimensions(this.coordinateSpace));
        this.displayDimensionRenderInfo = this.registerDisposer(new WatchableDisplayDimensionRenderInfo(this.relativeDisplayScales.addRef(), this.displayDimensions.addRef()));
        this.crossSectionOrientation = this.registerDisposer(new OrientationState());
        this.crossSectionScale = this.registerDisposer(new TrackableCrossSectionZoom(this.displayDimensionRenderInfo.addRef()));
        this.projectionOrientation = this.registerDisposer(new OrientationState());
        this.crossSectionDepthRange = this.registerDisposer(new TrackableDepthRange(-10, this.displayDimensionRenderInfo));
        this.projectionDepthRange = this.registerDisposer(new TrackableDepthRange(-50, this.displayDimensionRenderInfo));
        this.projectionScale = this.registerDisposer(new TrackableProjectionZoom(this.displayDimensionRenderInfo.addRef()));
        this.navigationState = this.registerDisposer(new NavigationState(new DisplayPose(this.position.addRef(), this.displayDimensionRenderInfo.addRef(), this.crossSectionOrientation.addRef()), this.crossSectionScale.addRef(), this.crossSectionDepthRange.addRef()));
        this.perspectiveNavigationState = this.registerDisposer(new NavigationState(new DisplayPose(this.position.addRef(), this.displayDimensionRenderInfo.addRef(), this.projectionOrientation.addRef()), this.projectionScale.addRef(), this.projectionDepthRange.addRef()));
        this.mouseState = new MouseSelectionState();
        this.layerManager = this.registerDisposer(new LayerManager());
        this.selectedLayer = this.registerDisposer(new SelectedLayerState(this.layerManager.addRef()));
        this.showAxisLines = new TrackableBoolean(true, true);
        this.wireFrame = new TrackableBoolean(false, false);
        this.showScaleBar = new TrackableBoolean(true, true);
        this.showPerspectiveSliceViews = new TrackableBoolean(true, true);
        this.visibleLayerRoles = allRenderLayerRoles();
        this.showDefaultAnnotations = new TrackableBoolean(true, true);
        this.crossSectionBackgroundColor = new TrackableRGB(vec3.fromValues(0.5, 0.5, 0.5));
        this.perspectiveViewBackgroundColor = new TrackableRGB(vec3.fromValues(0, 0, 0));
        this.scaleBarOptions = new TrackableScaleBarOptions();
        this.partialViewport = new TrackableWindowedViewport();
        this.statisticsDisplayState = new StatisticsDisplayState();
        this.helpPanelState = new HelpPanelState();
        this.settingsPanelState = new ViewerSettingsPanelState();
        this.layerSelectedValues = this.registerDisposer(new LayerSelectedValues(this.layerManager, this.mouseState));
        this.selectionDetailsState = this.registerDisposer(new TrackableDataSelectionState(this.coordinateSpace, this.layerSelectedValues));
        this.selectedStateServer = new TrackableValue('', verifyString);
        this.layerListPanelState = new LayerListPanelState();
        this.resetInitiated = new NullarySignal();
        this.makeUrlFromState = state => {
            if (!globalViewerConfig.expectingExternalUI) {
                return window.location.toString();
            } else {
                return '/#!' + encodeFragment(_JSON$stringify(state));
            }
        };
        /**
         * Logical and of each `VIEWER_UI_CONTROL_CONFIG_OPTIONS` option with the value of showUIControls.
         */
        this.uiControlVisibility = {};
        this.visible = true;
        this.toolInputEventMapBinder = (inputEventMap, context) => {
            context.registerDisposer(this.inputEventBindings.sliceView.addParent(inputEventMap, Number.POSITIVE_INFINITY));
            context.registerDisposer(this.inputEventBindings.perspectiveView.addParent(inputEventMap, Number.POSITIVE_INFINITY));
        };
        this.toolBinder = this.registerDisposer(new ToolBinder(this.toolInputEventMapBinder));
        var _options$dataContext = options.dataContext;
        const dataContext = _options$dataContext === undefined ? new DataManagementContext(display.gl, display, options.bundleRoot) : _options$dataContext;
        var _options$visibility = options.visibility;
        const visibility = _options$visibility === undefined ? new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE) : _options$visibility;
        var _options$inputEventBi = options.inputEventBindings;
        const inputEventBindings = _options$inputEventBi === undefined ? {
            global: new EventActionMap(),
            sliceView: new EventActionMap(),
            perspectiveView: new EventActionMap()
        } : _options$inputEventBi;
        var _options$element = options.element;
        const element = _options$element === undefined ? display.makeCanvasOverlayElement() : _options$element;
        var _options$dataSourcePr = options.dataSourceProvider;
        const dataSourceProvider = _options$dataSourcePr === undefined ? getDefaultDataSourceProvider({ credentialsManager: defaultCredentialsManager }) : _options$dataSourcePr;
        var _options$uiConfigurat = options.uiConfiguration;
        const uiConfiguration = _options$uiConfigurat === undefined ? makeViewerUIConfiguration() : _options$uiConfigurat;

        this.visibility = visibility;
        this.inputEventBindings = inputEventBindings;
        this.element = element;
        this.dataSourceProvider = dataSourceProvider;
        this.uiConfiguration = uiConfiguration;
        this.registerDisposer(observeWatchable(value => {
            this.display.applyWindowedViewportToElement(element, value);
        }, this.partialViewport));
        this.registerDisposer(() => removeFromParent(this.element));
        this.dataContext = this.registerDisposer(dataContext);
        setViewerUiConfiguration(uiConfiguration, options);
        const optionsWithDefaults = _Object$assign(_Object$assign({}, defaultViewerOptions), options);
        const resetStateWhenEmpty = optionsWithDefaults.resetStateWhenEmpty,
              showLayerDialog = optionsWithDefaults.showLayerDialog;

        for (const key of VIEWER_UI_CONTROL_CONFIG_OPTIONS) {
            this.uiControlVisibility[key] = this.makeUiControlVisibilityState(key);
        }
        this.registerDisposer(this.uiConfiguration.showPanelBorders.changed.add(() => {
            this.updateShowBorders();
        }));
        this.showLayerDialog = showLayerDialog;
        this.resetStateWhenEmpty = resetStateWhenEmpty;
        this.layerSpecification = new TopLevelLayerListSpecification(this.display, this.dataSourceProvider, this.layerManager, this.chunkManager, this.selectionDetailsState, this.selectedLayer, this.navigationState.coordinateSpace, this.navigationState.pose.position, this.toolBinder);
        this.registerDisposer(display.updateStarted.add(() => {
            this.onUpdateDisplay();
        }));
        this.showDefaultAnnotations.changed.add(() => {
            if (this.showDefaultAnnotations.value) {
                this.visibleLayerRoles.add(RenderLayerRole.DEFAULT_ANNOTATION);
            } else {
                this.visibleLayerRoles.delete(RenderLayerRole.DEFAULT_ANNOTATION);
            }
        });
        this.registerDisposer(this.navigationState.changed.add(() => {
            this.handleNavigationStateChanged();
        }));
        // Debounce this call to ensure that a transient state does not result in the layer dialog being
        // shown.
        const maybeResetState = this.registerCancellable(debounce(() => {
            if (!this.wasDisposed && this.layerManager.managedLayers.length === 0 && this.resetStateWhenEmpty) {
                // No layers, reset state.
                this.navigationState.reset();
                this.perspectiveNavigationState.pose.orientation.reset();
                this.perspectiveNavigationState.zoomFactor.reset();
                this.resetInitiated.dispatch();
                if (!overlaysOpen && this.showLayerDialog && this.visibility.visible) {
                    addNewLayer(this.layerSpecification, this.selectedLayer);
                }
            }
        }));
        this.layerManager.layersChanged.add(maybeResetState);
        maybeResetState();
        this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(() => {
            this.layerSelectedValues.handleLayerChange();
        }));
        this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(() => {
            if (this.visible) {
                display.scheduleRedraw();
            }
        }));
        this.makeUI();
        this.updateShowBorders();
        this.registerActionListeners();
        this.registerEventActionBindings();
        this.registerDisposer(setupPositionDropHandlers(element, this.navigationState.position));
        this.state = new TrackableViewerState(this);
    }
    get chunkManager() {
        return this.dataContext.chunkManager;
    }
    get chunkQueueManager() {
        return this.dataContext.chunkQueueManager;
    }
    get expectingExternalUI() {
        return globalViewerConfig.expectingExternalUI;
    }
    set expectingExternalUI(on) {
        globalViewerConfig.expectingExternalUI = on;
    }
    makeUiControlVisibilityState(key) {
        const showUIControls = this.uiConfiguration.showUIControls;
        const option = this.uiConfiguration[key];
        return this.registerDisposer(makeDerivedWatchableValue((a, b) => a && b, showUIControls, option));
    }
    get inputEventMap() {
        return this.inputEventBindings.global;
    }
    updateShowBorders() {
        const element = this.element;

        const className = 'neuroglancer-show-panel-borders';
        if (this.uiConfiguration.showPanelBorders.value) {
            element.classList.add(className);
        } else {
            element.classList.remove(className);
        }
    }
    makeUI() {
        const gridContainer = this.element;
        gridContainer.classList.add('neuroglancer-viewer');
        gridContainer.classList.add('neuroglancer-noselect');
        gridContainer.style.display = 'flex';
        gridContainer.style.flexDirection = 'column';
        const topRow = document.createElement('div');
        topRow.classList.add('neuroglancer-viewer-top-row');
        topRow.style.display = 'flex';
        topRow.style.flexDirection = 'row';
        topRow.style.alignItems = 'stretch';
        const positionWidget = this.registerDisposer(new PositionWidget(this.navigationState.position, this.layerSpecification.coordinateSpaceCombiner));
        this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showLocation, positionWidget.element));
        topRow.appendChild(positionWidget.element);
        const mousePositionWidget = this.registerDisposer(new MousePositionWidget(document.createElement('div'), this.mouseState, this.navigationState.coordinateSpace));
        mousePositionWidget.element.style.flex = '1';
        mousePositionWidget.element.style.alignSelf = 'center';
        this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showLocation, mousePositionWidget.element));
        topRow.appendChild(mousePositionWidget.element);
        if (typeof NEUROGLANCER_CREDIT_LINK !== 'undefined') {
            let creditInfo = NEUROGLANCER_CREDIT_LINK;
            if (!Array.isArray(creditInfo)) {
                creditInfo = [creditInfo];
            }
            for (const _ref of creditInfo) {
                const url = _ref.url;
                const text = _ref.text;

                const creditLink = document.createElement('a');
                creditLink.style.marginRight = '5px';
                creditLink.href = url;
                creditLink.textContent = text;
                creditLink.style.fontFamily = 'sans-serif';
                creditLink.style.color = 'yellow';
                creditLink.target = '_blank';
                topRow.appendChild(creditLink);
            }
        }
        const annotationToolStatus = this.registerDisposer(new AnnotationToolStatusWidget(this.selectedLayer, this.toolBinder));
        topRow.appendChild(annotationToolStatus.element);
        this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showAnnotationToolStatus, annotationToolStatus.element));
        if (stateShareEnabled) {
            const stateShare = this.registerDisposer(new StateShare(this));
            topRow.appendChild(stateShare.element);
        }
        {
            const layerListPanelState = this.layerListPanelState;

            const button = this.registerDisposer(new CheckboxIcon(layerListPanelState.location.watchableVisible, {
                svg: svg_layers,
                backgroundScheme: 'dark',
                enableTitle: 'Show layer list panel',
                disableTitle: 'Hide layer list panel'
            }));
            button.element.insertAdjacentElement('afterbegin', this.registerDisposer(new LayerArchiveCountWidget(this.layerManager)).element);
            this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showLayerListPanelButton, button.element));
            topRow.appendChild(button.element);
        }
        {
            const selectionDetailsState = this.selectionDetailsState;

            const button = this.registerDisposer(new CheckboxIcon(selectionDetailsState.location.watchableVisible, {
                svg: svg_list,
                backgroundScheme: 'dark',
                enableTitle: 'Show selection details panel',
                disableTitle: 'Hide selection details panel'
            }));
            this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showSelectionPanelButton, button.element));
            topRow.appendChild(button.element);
        }
        {
            const selectedLayer = this.selectedLayer;

            const button = this.registerDisposer(new CheckboxIcon({
                get value() {
                    return selectedLayer.visible;
                },
                set value(visible) {
                    selectedLayer.visible = visible;
                },
                changed: selectedLayer.location.locationChanged
            }, {
                svg: svg_controls_alt,
                backgroundScheme: 'dark',
                enableTitle: 'Show layer side panel',
                disableTitle: 'Hide layer side panel'
            }));
            this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showLayerSidePanelButton, button.element));
            topRow.appendChild(button.element);
        }
        {
            const button = makeIcon({ text: '{}', title: 'Edit JSON state' });
            this.registerEventListener(button, 'click', () => {
                this.editJsonState();
            });
            this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showEditStateButton, button));
            topRow.appendChild(button);
        }
        {
            const button = makeCopyButton({
                title: 'Copy view URL to clipboard',
                onClick: () => {
                    const result = setClipboard(this.makeUrlFromState(this.state.toJSON()));
                    StatusMessage.showTemporaryMessage(result ? 'URL copied to clipboard' : 'Failed to copy URL to clipboard');
                }
            });
            topRow.appendChild(button);
        }
        {
            const helpPanelState = this.helpPanelState;

            const button = this.registerDisposer(new CheckboxIcon(helpPanelState.location.watchableVisible, {
                text: '?',
                backgroundScheme: 'dark',
                enableTitle: 'Show help panel',
                disableTitle: 'Hide help panel'
            }));
            this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showHelpButton, button.element));
            topRow.appendChild(button.element);
        }
        {
            const settingsPanelState = this.settingsPanelState;

            const button = this.registerDisposer(new CheckboxIcon(settingsPanelState.location.watchableVisible, {
                svg: svg_settings,
                backgroundScheme: 'dark',
                enableTitle: 'Show settings panel',
                disableTitle: 'Hide settings panel'
            }));
            this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showSettingsButton, button.element));
            topRow.appendChild(button.element);
        }
        this.registerDisposer(new ElementVisibilityFromTrackableBoolean(makeDerivedWatchableValue((...values) => values.reduce((a, b) => a || b, false), ...VIEWER_TOP_ROW_CONFIG_OPTIONS.map(key => this.uiControlVisibility[key])), topRow));
        gridContainer.appendChild(topRow);
        this.layout = this.registerDisposer(new RootLayoutContainer(this, '4panel'));
        this.sidePanelManager = this.registerDisposer(new SidePanelManager(this.display, this.layout.element, this.visibility));
        this.registerDisposer(this.sidePanelManager.registerPanel({
            location: this.layerListPanelState.location,
            makePanel: () => new LayerListPanel(this.sidePanelManager, this.layerSpecification, this.layerListPanelState)
        }));
        this.registerDisposer(new LayerSidePanelManager(this.sidePanelManager, this.selectedLayer.addRef()));
        this.registerDisposer(this.sidePanelManager.registerPanel({
            location: this.selectionDetailsState.location,
            makePanel: () => new SelectionDetailsPanel(this.sidePanelManager, this.selectionDetailsState, this.layerSpecification, this.selectedLayer)
        }));
        gridContainer.appendChild(this.sidePanelManager.element);
        this.closeSelectionTab = () => {
            for (const panel of this.sidePanelManager.registeredPanels) {
                if (panel.panel instanceof SelectionDetailsPanel) {
                    panel.panel.close();
                }
            }
        };
        this.registerDisposer(this.sidePanelManager.registerPanel({
            location: this.statisticsDisplayState.location,
            makePanel: () => new StatisticsPanel(this.sidePanelManager, this.chunkQueueManager, this.statisticsDisplayState)
        }));
        this.registerDisposer(this.sidePanelManager.registerPanel({
            location: this.helpPanelState.location,
            makePanel: () => {
                const inputEventBindings = this.inputEventBindings;

                return new InputEventBindingHelpDialog(this.sidePanelManager, this.helpPanelState, [['Global', inputEventBindings.global], ['Cross section view', inputEventBindings.sliceView], ['3-D projection view', inputEventBindings.perspectiveView]], this.layerManager, this.toolBinder);
            }
        }));
        this.registerDisposer(this.sidePanelManager.registerPanel({
            location: this.settingsPanelState.location,
            makePanel: () => new ViewerSettingsPanel(this.sidePanelManager, this.settingsPanelState, this)
        }));
        const updateVisibility = () => {
            const shouldBeVisible = this.visibility.visible;
            if (shouldBeVisible !== this.visible) {
                gridContainer.style.visibility = shouldBeVisible ? 'inherit' : 'hidden';
                this.visible = shouldBeVisible;
            }
        };
        updateVisibility();
        this.registerDisposer(this.visibility.changed.add(updateVisibility));
    }
    /**
     * Called once by the constructor to set up event handlers.
     */
    registerEventActionBindings() {
        const element = this.element;

        this.registerDisposer(new KeyboardEventBinder(element, this.inputEventMap));
        this.registerDisposer(new AutomaticallyFocusedElement(element));
    }
    bindAction(action, handler) {
        this.registerDisposer(registerActionListener(this.element, action, handler));
    }
    bindCallback(action, callback) {
        const handler = () => {
            callback(this);
        };
        this.registerDisposer(registerActionListener(this.element, action, handler));
    }
    /**
     * Called once by the constructor to register the action listeners.
     */
    registerActionListeners() {
        for (const action of ['recolor', 'clear-segments']) {
            this.bindAction(action, () => {
                this.layerManager.invokeAction(action);
                this.closeSelectionTab && this.closeSelectionTab();
            });
        }
        for (const action of ['select']) {
            this.bindAction(action, () => {
                this.mouseState.updateUnconditionally();
                this.layerManager.invokeAction(action);
            });
        }
        for (const action of ['copy-segment-id', 'add-copy-segment-id']) {
            this.bindAction(action, () => {
                this.mouseState.updateUnconditionally();
                this.layerManager.invokeAction(action, this.selectedLayer.layer);
            });
        }
        this.bindAction('help', () => this.toggleHelpPanel());
        for (let i = 1; i <= 9; ++i) {
            this.bindAction(`toggle-layer-${i}`, () => {
                const layer = this.layerManager.getLayerByNonArchivedIndex(i - 1);
                if (layer !== undefined) {
                    layer.setVisible(!layer.visible);
                }
            });
            this.bindAction(`toggle-pick-layer-${i}`, () => {
                const layer = this.layerManager.getLayerByNonArchivedIndex(i - 1);
                if (layer !== undefined) {
                    layer.pickEnabled = !layer.pickEnabled;
                }
            });
            this.bindAction(`select-layer-${i}`, () => {
                const layer = this.layerManager.getLayerByNonArchivedIndex(i - 1);
                if (layer !== undefined) {
                    this.selectedLayer.layer = layer;
                    this.selectedLayer.visible = true;
                }
            });
        }
        for (let i = 0; i < 26; ++i) {
            const uppercase = String.fromCharCode(65 + i);
            this.bindAction(`tool-${uppercase}`, () => {
                this.activateTool(uppercase);
            });
        }
        this.bindAction('annotate', () => {
            const selectedLayer = this.selectedLayer.layer;
            if (selectedLayer === undefined) {
                StatusMessage.showTemporaryMessage('The annotate command requires a layer to be selected.');
                return;
            }
            const userLayer = selectedLayer.layer;
            if (userLayer === null || userLayer.tool.value === undefined) {
                StatusMessage.showTemporaryMessage(`The selected layer (${_JSON$stringify(selectedLayer.name)}) does not have an active annotation tool.`);
                return;
            }
            userLayer.tool.value.trigger(this.mouseState);
        });
        this.bindAction('toggle-axis-lines', () => this.showAxisLines.toggle());
        this.bindAction('toggle-scale-bar', () => this.showScaleBar.toggle());
        this.bindAction('toggle-default-annotations', () => this.showDefaultAnnotations.toggle());
        this.bindAction('toggle-show-slices', () => this.showPerspectiveSliceViews.toggle());
        this.bindAction('toggle-show-statistics', () => this.showStatistics());
    }
    toggleHelpPanel() {
        this.helpPanelState.location.visible = !this.helpPanelState.location.visible;
    }
    activateTool(uppercase) {
        this.toolBinder.activate(uppercase);
    }
    editJsonState() {
        new StateEditorDialog(this);
    }
    copyJsonStateToUrl() {
        setClipboard(this.makeUrlFromState(this.state.toJSON()));
    }
    showStatistics(value = undefined) {
        if (value === undefined) {
            value = !this.statisticsDisplayState.location.visible;
        }
        this.statisticsDisplayState.location.visible = value;
    }
    get gl() {
        return this.display.gl;
    }
    onUpdateDisplay() {
        if (this.visible) {
            this.dataContext.chunkQueueManager.chunkUpdateDeadline = null;
        }
    }
    handleNavigationStateChanged() {
        if (this.visible) {
            let chunkQueueManager = this.dataContext.chunkQueueManager;

            if (chunkQueueManager.chunkUpdateDeadline === null) {
                chunkQueueManager.chunkUpdateDeadline = Date.now() + 10;
            }
        }
    }
}
//# sourceMappingURL=viewer.js.map