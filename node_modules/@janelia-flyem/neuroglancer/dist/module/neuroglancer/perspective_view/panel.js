import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AxesLineHelper, computeAxisLineMatrix } from '../axes_lines';
import { applyRenderViewportToProjectionMatrix } from '../display_context';
import { makeRenderedPanelVisibleLayerTracker } from '../layer';
import { PERSPECTIVE_VIEW_RPC_ID } from './base';
import { PerspectiveViewRenderLayer } from './render_layer';
import { updateProjectionParametersFromInverseViewAndProjection } from '../projection_parameters';
import { clearOutOfBoundsPickData, pickDiameter, pickOffsetSequence, pickRadius, RenderedDataPanel } from '../rendered_data_panel';
import { DerivedProjectionParameters, SharedProjectionParameters } from '../renderlayer';
import { SliceViewRenderHelper } from '../sliceview/frontend';
import { TrackableBooleanCheckbox } from '../trackable_boolean';
import { registerActionListener } from '../util/event_action_map';
import { kAxes, kZeroVec4, mat4, vec3, vec4 } from '../util/geom';
import { startRelativeMouseDrag } from '../util/mouse_drag';
import { WatchableMap } from '../util/watchable_map';
import { withSharedVisibility } from '../visibility_priority/frontend';
import { DepthStencilRenderbuffer, FramebufferConfiguration, makeTextureBuffers, OffscreenCopyHelper, TextureBuffer } from '../webgl/offscreen';
import { MultipleScaleBarTextures } from '../widget/scale_bar';
import { SharedObject } from '../worker_rpc';
export var OffscreenTextures;
(function (OffscreenTextures) {
    OffscreenTextures[OffscreenTextures["COLOR"] = 0] = "COLOR";
    OffscreenTextures[OffscreenTextures["Z"] = 1] = "Z";
    OffscreenTextures[OffscreenTextures["PICK"] = 2] = "PICK";
    OffscreenTextures[OffscreenTextures["NUM_TEXTURES"] = 3] = "NUM_TEXTURES";
})(OffscreenTextures || (OffscreenTextures = {}));
export const glsl_perspectivePanelEmit = `
void emit(vec4 color, highp uint pickId) {
  out_color = color;
  float zValue = 1.0 - gl_FragCoord.z;
  out_z = vec4(zValue, zValue, zValue, 1.0);
  float pickIdFloat = float(pickId);
  out_pickId = vec4(pickIdFloat, pickIdFloat, pickIdFloat, 1.0);
}
`;
/**
 * http://jcgt.org/published/0002/02/09/paper.pdf
 * http://casual-effects.blogspot.com/2015/03/implemented-weighted-blended-order.html
 */
export const glsl_computeOITWeight = `
float computeOITWeight(float alpha) {
  float a = min(1.0, alpha) * 8.0 + 0.01;
  float b = -gl_FragCoord.z * 0.95 + 1.0;
  return a * a * a * b * b * b;
}
`;
// Color must be premultiplied by alpha.
export const glsl_perspectivePanelEmitOIT = [glsl_computeOITWeight, `
void emit(vec4 color, highp uint pickId) {
  float weight = computeOITWeight(color.a);
  vec4 accum = color * weight;
  v4f_fragData0 = vec4(accum.rgb, color.a);
  v4f_fragData1 = vec4(accum.a, 0.0, 0.0, 0.0);
}
`];
export function perspectivePanelEmit(builder) {
    builder.addOutputBuffer('vec4', `out_color`, OffscreenTextures.COLOR);
    builder.addOutputBuffer('highp vec4', `out_z`, OffscreenTextures.Z);
    builder.addOutputBuffer('highp vec4', `out_pickId`, OffscreenTextures.PICK);
    builder.addFragmentCode(glsl_perspectivePanelEmit);
}
export function perspectivePanelEmitOIT(builder) {
    builder.addOutputBuffer('vec4', 'v4f_fragData0', 0);
    builder.addOutputBuffer('vec4', 'v4f_fragData1', 1);
    builder.addFragmentCode(glsl_perspectivePanelEmitOIT);
}
const tempVec3 = vec3.create();
const tempVec4 = vec4.create();
const tempMat4 = mat4.create();
function defineTransparencyCopyShader(builder) {
    builder.addOutputBuffer('vec4', 'v4f_fragColor', null);
    builder.setFragmentMain(`
vec4 v0 = getValue0();
vec4 v1 = getValue1();
vec4 accum = vec4(v0.rgb, v1.r);
float revealage = v0.a;

v4f_fragColor = vec4(accum.rgb / accum.a, revealage);
`);
}
const PerspectiveViewStateBase = withSharedVisibility(SharedObject);
class PerspectiveViewState extends PerspectiveViewStateBase {
    constructor(panel) {
        super();
        this.panel = panel;
    }
    initializeCounterpart(rpc, options) {
        this.sharedProjectionParameters = this.registerDisposer(new SharedProjectionParameters(rpc, this.panel.projectionParameters));
        options.projectionParameters = this.sharedProjectionParameters.rpcId;
        super.initializeCounterpart(rpc, options);
    }
}
export class PerspectivePanel extends RenderedDataPanel {
    constructor(context, element, viewer) {
        super(context, element, viewer);
        /**
         * If boolean value is true, sliceView is shown unconditionally, regardless of the value of
         * this.viewer.showSliceViews.value.
         */
        this.sliceViews = this.registerDisposer(new WatchableMap((context, _unconditional, sliceView) => {
            context.registerDisposer(sliceView);
            context.registerDisposer(sliceView.visibility.add(this.visibility));
        }));
        this.axesLineHelper = this.registerDisposer(AxesLineHelper.get(this.gl));
        this.sliceViewRenderHelper = this.registerDisposer(SliceViewRenderHelper.get(this.gl, perspectivePanelEmit));
        this.offscreenFramebuffer = this.registerDisposer(new FramebufferConfiguration(this.gl, {
            colorBuffers: [new TextureBuffer(this.gl, WebGL2RenderingContext.RGBA8, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE), new TextureBuffer(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT), new TextureBuffer(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT)],
            depthBuffer: new DepthStencilRenderbuffer(this.gl)
        }));
        this.offscreenCopyHelper = this.registerDisposer(OffscreenCopyHelper.get(this.gl));
        this.transparencyCopyHelper = this.registerDisposer(OffscreenCopyHelper.get(this.gl, defineTransparencyCopyShader, 2));
        this.scaleBars = this.registerDisposer(new MultipleScaleBarTextures(this.gl));
        this.projectionParameters = this.registerDisposer(new DerivedProjectionParameters({
            navigationState: this.navigationState,
            update: (out, navigationState) => {
                const invViewMatrix = out.invViewMatrix,
                      projectionMat = out.projectionMat,
                      logicalWidth = out.logicalWidth,
                      logicalHeight = out.logicalHeight;

                const widthOverHeight = logicalWidth / logicalHeight;
                const fovy = Math.PI / 4.0;
                let relativeDepthRange = navigationState.relativeDepthRange;

                const baseZoomFactor = navigationState.zoomFactor.value;
                let zoomFactor = baseZoomFactor / 2;
                if (this.viewer.orthographicProjection.value) {
                    // Pick orthographic projection to match perspective projection at plane parallel to image
                    // plane containing the center position.
                    const nearBound = Math.max(0.1, 1 - relativeDepthRange);
                    const farBound = 1 + relativeDepthRange;
                    mat4.ortho(projectionMat, -widthOverHeight, widthOverHeight, -1, 1, nearBound, farBound);
                } else {
                    const f = 1.0 / Math.tan(fovy / 2);
                    relativeDepthRange /= f;
                    const nearBound = Math.max(0.1, 1 - relativeDepthRange);
                    const farBound = 1 + relativeDepthRange;
                    zoomFactor *= f;
                    mat4.perspective(projectionMat, fovy, widthOverHeight, nearBound, farBound);
                }
                applyRenderViewportToProjectionMatrix(out, projectionMat);
                navigationState.pose.toMat4(invViewMatrix, zoomFactor);
                mat4.scale(invViewMatrix, invViewMatrix, vec3.set(tempVec3, 1, -1, -1));
                mat4.translate(invViewMatrix, invViewMatrix, kAxes[2]);
                updateProjectionParametersFromInverseViewAndProjection(out);
            }
        }));
        this.projectionParameters.changed.add(() => this.context.scheduleRedraw());
        const sharedObject = this.sharedObject = this.registerDisposer(new PerspectiveViewState(this));
        sharedObject.RPC_TYPE_ID = PERSPECTIVE_VIEW_RPC_ID;
        sharedObject.initializeCounterpart(viewer.rpc, {});
        sharedObject.visibility.add(this.visibility);
        this.visibleLayerTracker = makeRenderedPanelVisibleLayerTracker(this.viewer.layerManager, PerspectiveViewRenderLayer, this.viewer.visibleLayerRoles, this);
        registerActionListener(element, 'rotate-via-mouse-drag', e => {
            startRelativeMouseDrag(e.detail, (_event, deltaX, deltaY) => {
                this.navigationState.pose.rotateRelative(kAxes[1], deltaX / 4.0 * Math.PI / 180.0);
                this.navigationState.pose.rotateRelative(kAxes[0], -deltaY / 4.0 * Math.PI / 180.0);
            });
        });
        registerActionListener(element, 'rotate-in-plane-via-touchrotate', e => {
            const detail = e.detail;

            this.navigationState.pose.rotateRelative(kAxes[2], detail.angle - detail.prevAngle);
        });
        registerActionListener(element, 'rotate-out-of-plane-via-touchtranslate', e => {
            const detail = e.detail;

            this.navigationState.pose.rotateRelative(kAxes[1], detail.deltaX / 4.0 * Math.PI / 180.0);
            this.navigationState.pose.rotateRelative(kAxes[0], -detail.deltaY / 4.0 * Math.PI / 180.0);
        });
        if (viewer.showSliceViewsCheckbox) {
            let showSliceViewsCheckbox = this.registerDisposer(new TrackableBooleanCheckbox(viewer.showSliceViews));
            showSliceViewsCheckbox.element.className = 'perspective-panel-show-slice-views neuroglancer-noselect';
            let showSliceViewsLabel = document.createElement('label');
            showSliceViewsLabel.className = 'perspective-panel-show-slice-views neuroglancer-noselect';
            showSliceViewsLabel.appendChild(document.createTextNode('Sections'));
            showSliceViewsLabel.appendChild(showSliceViewsCheckbox.element);
            this.element.appendChild(showSliceViewsLabel);
        }
        this.registerDisposer(viewer.orthographicProjection.changed.add(() => {
            this.projectionParameters.update();
            this.scheduleRedraw();
        }));
        this.registerDisposer(viewer.showScaleBar.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.scaleBarOptions.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.showSliceViews.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.showAxisLines.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.crossSectionBackgroundColor.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.perspectiveViewBackgroundColor.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.wireFrame.changed.add(() => this.scheduleRedraw()));
        this.sliceViews.changed.add(() => this.scheduleRedraw());
    }
    get rpc() {
        return this.sharedObject.rpc;
    }
    get rpcId() {
        return this.sharedObject.rpcId;
    }
    get displayDimensionRenderInfo() {
        return this.navigationState.displayDimensionRenderInfo;
    }
    flushBackendProjectionParameters() {
        this.sharedObject.sharedProjectionParameters.flush();
    }
    translateByViewportPixels(deltaX, deltaY) {
        const temp = tempVec3;
        var _projectionParameters = this.projectionParameters.value;
        const viewProjectionMat = _projectionParameters.viewProjectionMat,
              invViewProjectionMat = _projectionParameters.invViewProjectionMat,
              logicalWidth = _projectionParameters.logicalWidth,
              logicalHeight = _projectionParameters.logicalHeight;
        const pose = this.viewer.navigationState.pose;

        pose.updateDisplayPosition(pos => {
            vec3.transformMat4(temp, pos, viewProjectionMat);
            temp[0] += -2 * deltaX / logicalWidth;
            temp[1] += 2 * deltaY / logicalHeight;
            vec3.transformMat4(pos, temp, invViewProjectionMat);
        });
    }
    get navigationState() {
        return this.viewer.navigationState;
    }
    ensureBoundsUpdated() {
        super.ensureBoundsUpdated();
        this.projectionParameters.setViewport(this.renderViewport);
    }
    isReady() {
        if (!this.visible) {
            return true;
        }
        for (const _ref of this.sliceViews) {
            var _ref2 = _slicedToArray(_ref, 2);

            const sliceView = _ref2[0];
            const unconditional = _ref2[1];

            if (unconditional || this.viewer.showSliceViews.value) {
                if (!sliceView.isReady()) {
                    return false;
                }
            }
        }
        this.ensureBoundsUpdated();
        var _renderViewport = this.renderViewport;
        const width = _renderViewport.width,
              height = _renderViewport.height;

        if (width === 0 || height === 0) {
            return true;
        }
        const projectionParameters = this.projectionParameters.value;
        const renderContext = {
            projectionParameters
        };
        const visibleLayers = this.visibleLayerTracker.visibleLayers;

        for (const _ref3 of visibleLayers) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const renderLayer = _ref4[0];
            const attachment = _ref4[1];

            if (!renderLayer.isReady(renderContext, attachment)) {
                return false;
            }
        }
        return true;
    }
    disposed() {
        this.sliceViews.clear();
        super.disposed();
    }
    getDepthArray() {
        if (!this.navigationState.valid) {
            return undefined;
        }
        const offscreenFramebuffer = this.offscreenFramebuffer;
        var _renderViewport2 = this.renderViewport;
        const width = _renderViewport2.width,
              height = _renderViewport2.height;

        const numPixels = width * height;
        const depthArrayRGBA = new Float32Array(numPixels * 4);
        try {
            offscreenFramebuffer.bindSingle(OffscreenTextures.Z);
            this.gl.readPixels(0, 0, width, height, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, depthArrayRGBA);
        } finally {
            offscreenFramebuffer.framebuffer.unbind();
        }
        const depthArray = new Float32Array(numPixels);
        for (let i = 0; i < numPixels; ++i) {
            depthArray[i] = depthArrayRGBA[i * 4];
        }
        return depthArray;
    }
    issuePickRequest(glWindowX, glWindowY) {
        const offscreenFramebuffer = this.offscreenFramebuffer;

        offscreenFramebuffer.readPixelFloat32IntoBuffer(OffscreenTextures.Z, glWindowX - pickRadius, glWindowY - pickRadius, 0, pickDiameter, pickDiameter);
        offscreenFramebuffer.readPixelFloat32IntoBuffer(OffscreenTextures.PICK, glWindowX - pickRadius, glWindowY - pickRadius, 4 * 4 * pickDiameter * pickDiameter, pickDiameter, pickDiameter);
    }
    completePickRequest(glWindowX, glWindowY, data, pickingData) {
        const mouseState = this.viewer.mouseState;

        mouseState.pickedRenderLayer = null;
        clearOutOfBoundsPickData(data, 0, 4, glWindowX, glWindowY, pickingData.viewportWidth, pickingData.viewportHeight);
        const numOffsets = pickOffsetSequence.length;
        for (let i = 0; i < numOffsets; ++i) {
            const offset = pickOffsetSequence[i];
            let zValue = data[4 * offset];
            if (zValue === 0) continue;
            const relativeX = offset % pickDiameter;
            const relativeY = (offset - relativeX) / pickDiameter;
            let glWindowZ = 1.0 - zValue;
            tempVec3[0] = 2.0 * (glWindowX + relativeX - pickRadius) / pickingData.viewportWidth - 1.0;
            tempVec3[1] = 2.0 * (glWindowY + relativeY - pickRadius) / pickingData.viewportHeight - 1.0;
            tempVec3[2] = 2.0 * glWindowZ - 1.0;
            vec3.transformMat4(tempVec3, tempVec3, pickingData.invTransform);
            let mousePosition = mouseState.position,
                unsnappedPosition = mouseState.unsnappedPosition;
            const voxelCoordinates = this.navigationState.position.value;

            const rank = voxelCoordinates.length;
            if (mousePosition.length !== rank) {
                mousePosition = mouseState.position = new Float32Array(rank);
            }
            if (unsnappedPosition.length !== rank) {
                unsnappedPosition = mouseState.unsnappedPosition = new Float32Array(rank);
            }
            mousePosition.set(voxelCoordinates);
            mouseState.coordinateSpace = this.navigationState.coordinateSpace.value;
            const displayDimensions = this.navigationState.pose.displayDimensions.value;
            const displayDimensionIndices = displayDimensions.displayDimensionIndices;

            for (let i = 0, spatialRank = displayDimensionIndices.length; i < spatialRank; ++i) {
                mousePosition[displayDimensionIndices[i]] = tempVec3[i];
            }
            unsnappedPosition.set(mousePosition);
            const pickValue = data[4 * pickDiameter * pickDiameter + 4 * offset];
            pickingData.pickIDs.setMouseState(mouseState, pickValue);
            mouseState.displayDimensions = displayDimensions;
            mouseState.setActive(true);
            return;
        }
        mouseState.setActive(false);
    }
    translateDataPointByViewportPixels(out, orig, deltaX, deltaY) {
        const temp = tempVec3;
        var _projectionParameters2 = this.projectionParameters.value;
        const viewProjectionMat = _projectionParameters2.viewProjectionMat,
              invViewProjectionMat = _projectionParameters2.invViewProjectionMat,
              width = _projectionParameters2.width,
              height = _projectionParameters2.height;

        vec3.transformMat4(temp, orig, viewProjectionMat);
        temp[0] += 2 * deltaX / width;
        temp[1] += -2 * deltaY / height;
        return vec3.transformMat4(out, temp, invViewProjectionMat);
    }
    get transparentConfiguration() {
        let transparentConfiguration = this.transparentConfiguration_;
        if (transparentConfiguration === undefined) {
            transparentConfiguration = this.transparentConfiguration_ = this.registerDisposer(new FramebufferConfiguration(this.gl, {
                colorBuffers: makeTextureBuffers(this.gl, 2, this.gl.RGBA32F, this.gl.RGBA, this.gl.FLOAT),
                depthBuffer: this.offscreenFramebuffer.depthBuffer.addRef()
            }));
        }
        return transparentConfiguration;
    }
    drawWithPicking(pickingData) {
        if (!this.navigationState.valid) {
            return false;
        }
        var _renderViewport3 = this.renderViewport;
        const width = _renderViewport3.width,
              height = _renderViewport3.height;

        const showSliceViews = this.viewer.showSliceViews.value;
        for (const _ref5 of this.sliceViews) {
            var _ref6 = _slicedToArray(_ref5, 2);

            const sliceView = _ref6[0];
            const unconditional = _ref6[1];

            if (unconditional || showSliceViews) {
                sliceView.updateRendering();
            }
        }
        let gl = this.gl;
        this.offscreenFramebuffer.bind(width, height);
        gl.disable(gl.SCISSOR_TEST);
        // Stencil buffer bit 0 indicates positions of framebuffer written by an opaque layer.
        //
        // Stencil buffer bit 1 indicates positions of framebuffer written by a transparent layer with
        // transparentPickEnabled=true.
        //
        // For a given xy framebuffer position, the pick id is chosen as the front-most position within
        // the highest *priority* class for which there is a fragment.  The 3 priority classes are:
        //
        // 1. Opaque layers
        // 2. Transparent layers with transparentPickEnabled==true
        // 3. Transparent layers with transparentPickEnabled==false
        //
        // For example, if a given ray passes first through an object from a transparent layer with
        // transparentPickEnabled=false, then through an object from a transparent layer with
        // transparentPickEnabled=true, the pick id will be for the object with
        // transparentPickEnabled=true, even though it is not the front-most object.
        //
        // We accomplish this priority scheme by writing to the pick buffer in 3 phases:
        //
        // 1. For opaque layers, we write to the pick buffer and depth buffer, and also set bit 0 of the
        // stencil buffer, at the same time as we render the color buffer.
        //
        // 2. For transparent layers, we write to the pick buffer as a separate rendering pass.  First,
        // we handle transparentPickEnabled=true layers: we write to the pick buffer and depth buffer,
        // and set the stencil buffer to `3`, but only at positions where the stencil buffer is unset.
        // Then, for transparentPickEnabled=false layers, we write to the pick buffer and depth buffer,
        // but only at positions where the stencil buffer is still unset.
        gl.enable(WebGL2RenderingContext.STENCIL_TEST);
        gl.stencilMask(0xffffffff);
        gl.clearStencil(0);
        gl.clear(WebGL2RenderingContext.STENCIL_BUFFER_BIT);
        // Write 1 to the stencil buffer unconditionally.  We set an always-pass stencil test in order
        // to be able to write to the stencil buffer.
        gl.stencilOp(
        /*sfail=*/WebGL2RenderingContext.KEEP,
        /*dpfail=*/WebGL2RenderingContext.KEEP, /*dppass=*/WebGL2RenderingContext.REPLACE);
        gl.stencilFunc(
        /*func=*/WebGL2RenderingContext.ALWAYS,
        /*ref=*/1, /*mask=*/1);
        const backgroundColor = this.viewer.perspectiveViewBackgroundColor.value;
        this.gl.clearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], 0.0);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        gl.clearBufferfv(WebGL2RenderingContext.COLOR, OffscreenTextures.COLOR, [backgroundColor[0], backgroundColor[1], backgroundColor[2], 0.0]);
        gl.clearBufferfv(WebGL2RenderingContext.COLOR, OffscreenTextures.Z, kZeroVec4);
        gl.clearBufferfv(WebGL2RenderingContext.COLOR, OffscreenTextures.PICK, kZeroVec4);
        gl.enable(gl.DEPTH_TEST);
        const projectionParameters = this.projectionParameters.value;
        // FIXME; avoid temporaries
        let lightingDirection = vec3.create();
        vec3.transformQuat(lightingDirection, kAxes[2], this.navigationState.pose.orientation.orientation);
        vec3.scale(lightingDirection, lightingDirection, -1);
        let ambient = 0.2;
        let directional = 1 - ambient;
        const renderContext = {
            wireFrame: this.viewer.wireFrame.value,
            projectionParameters,
            lightDirection: lightingDirection,
            ambientLighting: ambient,
            directionalLighting: directional,
            pickIDs: pickingData.pickIDs,
            emitter: perspectivePanelEmit,
            emitColor: true,
            emitPickID: true,
            alreadyEmittedPickID: false
        };
        mat4.copy(pickingData.invTransform, projectionParameters.invViewProjectionMat);
        const visibleLayers = this.visibleLayerTracker.visibleLayers;

        let hasTransparent = false;
        let hasAnnotation = false;
        // Draw fully-opaque layers first.
        for (const _ref7 of visibleLayers) {
            var _ref8 = _slicedToArray(_ref7, 2);

            const renderLayer = _ref8[0];
            const attachment = _ref8[1];

            if (!renderLayer.isTransparent) {
                if (!renderLayer.isAnnotation) {
                    renderLayer.draw(renderContext, attachment);
                } else {
                    hasAnnotation = true;
                }
            } else {
                hasTransparent = true;
            }
        }
        this.drawSliceViews(renderContext);
        if (hasAnnotation) {
            // Render annotations with blending enabled.
            gl.enable(WebGL2RenderingContext.BLEND);
            gl.depthFunc(WebGL2RenderingContext.LEQUAL);
            gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
            for (const _ref9 of visibleLayers) {
                var _ref10 = _slicedToArray(_ref9, 2);

                const renderLayer = _ref10[0];
                const attachment = _ref10[1];

                if (renderLayer.isAnnotation) {
                    renderLayer.draw(renderContext, attachment);
                }
            }
            gl.depthFunc(WebGL2RenderingContext.LESS);
            gl.disable(WebGL2RenderingContext.BLEND);
        }
        if (this.viewer.showAxisLines.value) {
            this.drawAxisLines();
        }
        // Disable stencil operations.
        gl.stencilOp(
        /*sfail=*/WebGL2RenderingContext.KEEP,
        /*dpfail=*/WebGL2RenderingContext.KEEP, /*dppass=*/WebGL2RenderingContext.KEEP);
        if (hasTransparent) {
            // Draw transparent objects.
            gl.depthMask(false);
            gl.enable(WebGL2RenderingContext.BLEND);
            // Compute accumulate and revealage textures.
            const transparentConfiguration = this.transparentConfiguration;

            transparentConfiguration.bind(width, height);
            this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
            renderContext.emitter = perspectivePanelEmitOIT;
            gl.blendFuncSeparate(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
            renderContext.emitPickID = false;
            for (const _ref11 of visibleLayers) {
                var _ref12 = _slicedToArray(_ref11, 2);

                const renderLayer = _ref12[0];
                const attachment = _ref12[1];

                if (renderLayer.isTransparent) {
                    renderLayer.draw(renderContext, attachment);
                }
            }
            // Copy transparent rendering result back to primary buffer.
            gl.disable(WebGL2RenderingContext.DEPTH_TEST);
            this.offscreenFramebuffer.bindSingle(OffscreenTextures.COLOR);
            gl.blendFunc(WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA, WebGL2RenderingContext.SRC_ALPHA);
            this.transparencyCopyHelper.draw(transparentConfiguration.colorBuffers[0].texture, transparentConfiguration.colorBuffers[1].texture);
            gl.depthMask(true);
            gl.disable(WebGL2RenderingContext.BLEND);
            gl.enable(WebGL2RenderingContext.DEPTH_TEST);
            // Restore framebuffer attachments.
            this.offscreenFramebuffer.bind(width, height);
            // Do picking only rendering pass for transparent layers.
            gl.enable(WebGL2RenderingContext.STENCIL_TEST);
            gl.drawBuffers([gl.NONE, gl.COLOR_ATTACHMENT1, gl.COLOR_ATTACHMENT2]);
            renderContext.emitter = perspectivePanelEmit;
            renderContext.emitPickID = true;
            renderContext.emitColor = false;
            // First, render `transparentPickEnabled=true` layers.
            // Only write to positions where the stencil buffer bit 0 is unset (i.e. the ray does not
            // intersect any opaque object), since opaque objects take precedence.  Set the stencil buffer
            // bit 1 to ensure those positions take precedence over `transparentPickEnabled=false` layers.
            gl.stencilFunc(
            /*func=*/WebGL2RenderingContext.NOTEQUAL,
            /*ref=*/3, /*mask=*/1);
            gl.stencilOp(
            /*sfail=*/WebGL2RenderingContext.KEEP,
            /*dpfail=*/WebGL2RenderingContext.KEEP, /*dppass=*/WebGL2RenderingContext.REPLACE);
            gl.stencilMask(2);
            for (const _ref13 of visibleLayers) {
                var _ref14 = _slicedToArray(_ref13, 2);

                const renderLayer = _ref14[0];
                const attachment = _ref14[1];

                if (!renderLayer.isTransparent || !renderLayer.transparentPickEnabled) {
                    continue;
                }
                renderLayer.draw(renderContext, attachment);
            }
            gl.stencilFunc(
            /*func=*/WebGL2RenderingContext.EQUAL,
            /*ref=*/0, /*mask=*/3);
            gl.stencilOp(
            /*sfail=*/WebGL2RenderingContext.KEEP,
            /*dpfail=*/WebGL2RenderingContext.KEEP, /*dppass=*/WebGL2RenderingContext.KEEP);
            gl.stencilMask(0);
            for (const _ref15 of visibleLayers) {
                var _ref16 = _slicedToArray(_ref15, 2);

                const renderLayer = _ref16[0];
                const attachment = _ref16[1];

                if (!renderLayer.isTransparent || renderLayer.transparentPickEnabled) {
                    continue;
                }
                renderLayer.draw(renderContext, attachment);
            }
        }
        gl.stencilMask(0xffffffff);
        gl.disable(WebGL2RenderingContext.STENCIL_TEST);
        if (this.viewer.showScaleBar.value && this.viewer.orthographicProjection.value) {
            // Only modify color buffer.
            gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
            gl.disable(WebGL2RenderingContext.DEPTH_TEST);
            gl.enable(WebGL2RenderingContext.BLEND);
            gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
            const scaleBars = this.scaleBars;

            const options = this.viewer.scaleBarOptions.value;
            scaleBars.draw(this.renderViewport, this.navigationState.displayDimensionRenderInfo.value, this.navigationState.relativeDisplayScales.value, this.navigationState.zoomFactor.value / this.renderViewport.logicalHeight, options);
            gl.disable(WebGL2RenderingContext.BLEND);
        }
        this.offscreenFramebuffer.unbind();
        // Draw the texture over the whole viewport.
        this.setGLClippedViewport();
        this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[OffscreenTextures.COLOR].texture);
        return true;
    }
    drawSliceViews(renderContext) {
        let sliceViewRenderHelper = this.sliceViewRenderHelper;
        let lightDirection = renderContext.lightDirection,
            ambientLighting = renderContext.ambientLighting,
            directionalLighting = renderContext.directionalLighting,
            viewProjectionMat = renderContext.projectionParameters.viewProjectionMat;

        const showSliceViews = this.viewer.showSliceViews.value;
        for (const _ref17 of this.sliceViews) {
            var _ref18 = _slicedToArray(_ref17, 2);

            const sliceView = _ref18[0];
            const unconditional = _ref18[1];

            if (!unconditional && !showSliceViews) {
                continue;
            }
            var _sliceView$projection = sliceView.projectionParameters.value;
            const sliceViewWidth = _sliceView$projection.width,
                  sliceViewHeight = _sliceView$projection.height,
                  sliceViewInvViewMatrix = _sliceView$projection.invViewMatrix,
                  viewportNormalInCanonicalCoordinates = _sliceView$projection.viewportNormalInCanonicalCoordinates;

            if (sliceViewWidth === 0 || sliceViewHeight === 0 || !sliceView.valid) {
                continue;
            }
            let scalar = Math.abs(vec3.dot(lightDirection, viewportNormalInCanonicalCoordinates));
            let factor = ambientLighting + scalar * directionalLighting;
            let mat = tempMat4;
            // Need a matrix that maps (+1, +1, 0) to projectionMat * (width, height, 0)
            mat4.identity(mat);
            mat[0] = sliceViewWidth / 2.0;
            mat[5] = -sliceViewHeight / 2.0;
            mat4.multiply(mat, sliceViewInvViewMatrix, mat);
            mat4.multiply(mat, viewProjectionMat, mat);
            const backgroundColor = tempVec4;
            const crossSectionBackgroundColor = this.viewer.crossSectionBackgroundColor.value;
            backgroundColor[0] = crossSectionBackgroundColor[0];
            backgroundColor[1] = crossSectionBackgroundColor[1];
            backgroundColor[2] = crossSectionBackgroundColor[2];
            backgroundColor[3] = 1;
            sliceViewRenderHelper.draw(sliceView.offscreenFramebuffer.colorBuffers[0].texture, mat, vec4.fromValues(factor, factor, factor, 1), tempVec4, 0, 0, 1, 1);
        }
    }
    drawAxisLines() {
        const zoom = this.viewer.navigationState.zoomFactor.value;

        const projectionParameters = this.projectionParameters.value;
        const axisRatio = Math.min(projectionParameters.logicalWidth, projectionParameters.logicalHeight) / this.renderViewport.logicalHeight / 4;
        const axisLength = zoom * axisRatio;
        const gl = this.gl;

        gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
        this.axesLineHelper.draw(computeAxisLineMatrix(projectionParameters, axisLength), /*blend=*/false);
    }
    zoomByMouse(factor) {
        this.navigationState.zoomBy(factor);
    }
}
//# sourceMappingURL=panel.js.map