import _Promise from 'babel-runtime/core-js/promise';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Generic facility for providing authentication/authorization credentials.
 */
import { MultipleConsumerCancellationTokenSource } from '../util/cancellation';
import { RefCounted } from '../util/disposable';
import { StringMemoize } from '../util/memoize';
export class CredentialsProvider extends RefCounted {}
export function makeCachedCredentialsGetter(getUncached) {
    let cachedCredentials;
    let pendingCredentials;
    let pendingCancellationToken;
    return (invalidCredentials, cancellationToken) => {
        if (pendingCredentials !== undefined && (cachedCredentials === undefined || invalidCredentials === undefined || cachedCredentials.generation !== invalidCredentials.generation)) {
            if (cachedCredentials === undefined) {
                pendingCancellationToken.addConsumer(cancellationToken);
            }
            return pendingCredentials;
        }
        cachedCredentials = undefined;
        pendingCancellationToken = new MultipleConsumerCancellationTokenSource();
        pendingCredentials = getUncached(invalidCredentials, pendingCancellationToken).then(credentials => {
            cachedCredentials = credentials;
            pendingCancellationToken = undefined;
            return credentials;
        }, reason => {
            if (pendingCancellationToken.isCanceled) {
                pendingCancellationToken = undefined;
                pendingCredentials = undefined;
            }
            throw reason;
        });
        return pendingCredentials;
    };
}
export function makeCredentialsGetter(getWithoutGeneration) {
    let generation = 0;
    return makeCachedCredentialsGetter((_invalidCredentials, cancellationToken) => getWithoutGeneration(cancellationToken).then(credentials => ({ generation: ++generation, credentials })));
}
/**
 * CredentialsManager that supports registration.
 */
export class MapBasedCredentialsManager {
    constructor() {
        this.providers = new _Map();
        this.topLevelManager = this;
    }
    register(key, providerGetter) {
        this.providers.set(key, providerGetter);
    }
    getCredentialsProvider(key, parameters) {
        const getter = this.providers.get(key);
        if (getter === undefined) {
            throw new Error(`No registered credentials provider: ${_JSON$stringify(key)}`);
        }
        return getter(parameters, this.topLevelManager);
    }
}
/**
 * CredentialsManager that wraps another and caches the CredentialsProvider objects.
 */
export class CachingCredentialsManager extends RefCounted {
    constructor(base) {
        super();
        this.base = base;
        this.memoize = new StringMemoize();
    }
    getCredentialsProvider(key, parameters) {
        return this.memoize.get({ key, parameters }, () => this.registerDisposer(this.base.getCredentialsProvider(key, parameters).addRef()));
    }
}
export class CachingMapBasedCredentialsManager extends CachingCredentialsManager {
    constructor() {
        super(new MapBasedCredentialsManager());
        this.base.topLevelManager = this;
    }
    register(key, providerGetter) {
        this.base.register(key, providerGetter);
    }
}
export class AnonymousFirstCredentialsProvider extends CredentialsProvider {
    constructor(baseProvider, anonymousCredentials) {
        super();
        this.baseProvider = baseProvider;
        this.anonymousCredentials = anonymousCredentials;
        this.anonymous = true;
        this.get = makeCachedCredentialsGetter(invalidCredentials => {
            if (this.anonymous && invalidCredentials === undefined) {
                return _Promise.resolve({ generation: -10, credentials: this.anonymousCredentials });
            }
            this.anonymous = false;
            return this.baseProvider.get(invalidCredentials);
        });
    }
}
//# sourceMappingURL=index.js.map