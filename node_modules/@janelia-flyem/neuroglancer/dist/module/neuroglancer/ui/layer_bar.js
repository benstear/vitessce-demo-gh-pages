import _Set from 'babel-runtime/core-js/set';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Map from 'babel-runtime/core-js/map';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import svg_plus from 'ikonate/icons/plus.svg';
import { addNewLayer, deleteLayer, makeLayer } from '../layer';
import { NavigationLinkType } from '../navigation_state';
import { registerLayerBarDragLeaveHandler, registerLayerBarDropHandlers, registerLayerDragHandlers } from './layer_drag_and_drop';
import { animationFrameDebounce } from '../util/animation_frame_debounce';
import { RefCounted } from '../util/disposable';
import { removeFromParent } from '../util/dom';
import { makeCloseButton, makeRefreshButton } from '../widget/close_button';
import { preventDrag } from '../util/drag_and_drop';
import { makeDeleteButton } from '../widget/delete_button';
import { makeIcon } from '../widget/icon';
import { PositionWidget } from '../widget/position_widget';
import { LoadedLayerDataSource } from '../layer_data_source';
class LayerWidget extends RefCounted {
    constructor(layer, panel) {
        var _a;
        super();
        this.layer = layer;
        this.panel = panel;
        this.element = document.createElement('div');
        this.layerNumberElement = document.createElement('div');
        this.labelElement = document.createElement('div');
        this.visibleProgress = document.createElement('div');
        this.prefetchProgress = document.createElement('div');
        this.labelElementText = document.createTextNode('');
        this.valueElement = document.createElement('div');
        this.maxLength = 0;
        this.prevValueText = '';
        const element = this.element,
              labelElement = this.labelElement,
              layerNumberElement = this.layerNumberElement,
              valueElement = this.valueElement,
              visibleProgress = this.visibleProgress,
              prefetchProgress = this.prefetchProgress,
              labelElementText = this.labelElementText;

        element.className = 'neuroglancer-layer-item neuroglancer-noselect';
        element.appendChild(visibleProgress);
        element.appendChild(prefetchProgress);
        labelElement.className = 'neuroglancer-layer-item-label';
        labelElement.appendChild(labelElementText);
        visibleProgress.className = 'neuroglancer-layer-item-visible-progress';
        prefetchProgress.className = 'neuroglancer-layer-item-prefetch-progress';
        layerNumberElement.className = 'neuroglancer-layer-item-number';
        valueElement.className = 'neuroglancer-layer-item-value';
        const valueContainer = document.createElement('div');
        valueContainer.className = 'neuroglancer-layer-item-value-container';
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'neuroglancer-layer-item-button-container';
        const closeElement = makeCloseButton();
        closeElement.title = 'Remove layer from this layer group';
        const refreshElement = makeRefreshButton();
        refreshElement.title = 'Refresh data';
        this.registerEventListener(refreshElement, 'click', event => {
            event.stopPropagation();
            const layer = this.layer.layer;
            if (layer && layer.dataSources && layer.dataSources[0].loadState) {
                const loadState = layer.dataSources[0].loadState;

                if (loadState instanceof LoadedLayerDataSource) {
                    const dataSource = loadState.dataSource;

                    if (dataSource && dataSource.subsources[0] && dataSource.subsources[0].subsource) {
                        const annotation = dataSource.subsources[0].subsource.annotation;

                        if (annotation === null || annotation === void 0 ? void 0 : annotation.invalidateCache) {
                            annotation.invalidateCache();
                        }
                    }
                }
            }
        });
        closeElement.addEventListener('click', event => {
            if (this.panel.layerManager === this.panel.manager.rootLayers) {
                // The layer bar corresponds to a TopLevelLayerListSpecification.  That means there is just
                // a single layer group, archive the layer unconditionally.
                this.layer.setArchived(true);
            } else {
                // The layer bar corresponds to a LayerSubsetSpecification.  The layer is always contained
                // in the root LayerManager, as well as the LayerManager for each LayerSubsetSpecification.
                if (this.layer.containers.size > 2) {
                    // Layer is contained in at least one other layer group, just remove it from this layer
                    // group.
                    this.panel.layerManager.removeManagedLayer(this.layer);
                } else {
                    // Layer is not contained in any other layer group.  Archive it.
                    this.layer.setArchived(true);
                }
            }
            event.stopPropagation();
        });
        const deleteElement = makeDeleteButton();
        deleteElement.title = 'Delete this layer';
        deleteElement.addEventListener('click', event => {
            deleteLayer(this.layer);
            event.stopPropagation();
        });
        element.appendChild(layerNumberElement);
        valueContainer.appendChild(valueElement);
        valueContainer.appendChild(buttonContainer);
        buttonContainer.appendChild(closeElement);
        buttonContainer.appendChild(deleteElement);
        element.appendChild(labelElement);
        if ((_a = layer.layer) === null || _a === void 0 ? void 0 : _a.allowingRefresh) {
            element.appendChild(refreshElement);
        }
        element.appendChild(valueContainer);
        const positionWidget = this.registerDisposer(new PositionWidget(layer.localPosition, layer.localCoordinateSpaceCombiner, { copyButton: false }));
        element.appendChild(positionWidget.element);
        positionWidget.element.addEventListener('click', event => {
            event.stopPropagation();
        });
        positionWidget.element.addEventListener('dblclick', event => {
            event.stopPropagation();
        });
        element.addEventListener('click', event => {
            if (event.ctrlKey) {
                panel.selectedLayer.toggle(layer);
            } else if (event.altKey) {
                layer.pickEnabled = !layer.pickEnabled;
            } else {
                layer.setVisible(!layer.visible);
            }
        });
        element.addEventListener('contextmenu', event => {
            panel.selectedLayer.layer = layer;
            panel.selectedLayer.visible = true;
            event.stopPropagation();
            event.preventDefault();
        });
        registerLayerDragHandlers(panel, element, layer, { getLayoutSpec: () => panel.getLayoutSpecForDrag() });
        registerLayerBarDropHandlers(this.panel, element, this.layer);
    }
    update() {
        const layer = this.layer,
              element = this.element;

        this.labelElementText.textContent = layer.name;
        element.dataset.visible = layer.visible.toString();
        element.dataset.selected = (layer === this.panel.selectedLayer.layer).toString();
        element.dataset.pick = layer.pickEnabled.toString();
        let title = `Click to ${layer.visible ? 'hide' : 'show'}, control+click to show side panel`;
        if (layer.supportsPickOption) {
            title += `, alt+click to ${layer.pickEnabled ? 'disable' : 'enable'} spatial object selection`;
        }
        title += `, drag to move, shift+drag to copy`;
        element.title = title;
    }
    disposed() {
        this.element.remove();
        super.disposed();
    }
}
export class LayerBar extends RefCounted {
    constructor(display, manager, viewerNavigationState, selectedLayer, getLayoutSpecForDrag, showLayerHoverValues) {
        super();
        this.display = display;
        this.manager = manager;
        this.viewerNavigationState = viewerNavigationState;
        this.selectedLayer = selectedLayer;
        this.getLayoutSpecForDrag = getLayoutSpecForDrag;
        this.showLayerHoverValues = showLayerHoverValues;
        this.layerWidgets = new _Map();
        this.element = document.createElement('div');
        this.layerUpdateNeeded = true;
        this.valueUpdateNeeded = false;
        this.layerWidgetInsertionPoint = document.createElement('div');
        this.positionWidget = this.registerDisposer(new PositionWidget(this.viewerNavigationState.position.value, this.manager.root.coordinateSpaceCombiner));
        this.dragEnterCount = 0;
        this.scheduleUpdate = this.registerCancellable(animationFrameDebounce(() => this.update()));
        this.registerDisposer(selectedLayer);
        const element = this.element;

        element.className = 'neuroglancer-layer-panel';
        this.registerDisposer(manager.layerSelectedValues.changed.add(() => {
            this.handleLayerValuesChanged();
        }));
        this.registerDisposer(manager.layerManager.layersChanged.add(() => {
            this.handleLayersChanged();
        }));
        this.registerDisposer(selectedLayer.changed.add(() => {
            this.handleLayersChanged();
        }));
        this.registerDisposer(showLayerHoverValues.changed.add(() => {
            this.handleLayerItemValueChanged();
        }));
        this.element.dataset.showHoverValues = this.showLayerHoverValues.value.toString();
        this.layerWidgetInsertionPoint.style.display = 'none';
        this.element.appendChild(this.layerWidgetInsertionPoint);
        let addButton = makeIcon({
            svg: svg_plus,
            title: 'Click to add layer, control+click/right click/⌘+click to add local annotation layer.'
        });
        addButton.classList.add('neuroglancer-layer-add-button');
        let dropZone = this.dropZone = document.createElement('div');
        dropZone.className = 'neuroglancer-layer-panel-drop-zone';
        const addLayer = event => {
            if (event.ctrlKey || event.metaKey || event.type === 'contextmenu') {
                const layer = makeLayer(this.manager, 'annotation', { type: 'annotation', 'source': 'local://annotations' });
                this.manager.add(layer);
                this.selectedLayer.layer = layer;
                this.selectedLayer.visible = true;
            } else {
                this.addLayerMenu();
            }
        };
        this.registerEventListener(addButton, 'click', addLayer);
        this.registerEventListener(addButton, 'contextmenu', addLayer);
        element.appendChild(addButton);
        element.appendChild(dropZone);
        this.registerDisposer(preventDrag(addButton));
        element.appendChild(this.positionWidget.element);
        const updatePositionWidgetVisibility = () => {
            const linkValue = this.viewerNavigationState.position.link.value;
            this.positionWidget.element.style.display = linkValue === NavigationLinkType.LINKED ? 'none' : '';
        };
        this.registerDisposer(this.viewerNavigationState.position.link.changed.add(updatePositionWidgetVisibility));
        updatePositionWidgetVisibility();
        this.update();
        this.updateChunkStatistics();
        registerLayerBarDragLeaveHandler(this);
        registerLayerBarDropHandlers(this, dropZone, undefined);
        // Ensure layer widgets are updated before WebGL drawing starts; we don't want the layout to
        // change after WebGL drawing or we will get flicker.
        this.registerDisposer(display.updateStarted.add(() => this.updateLayers()));
        this.registerDisposer(manager.chunkManager.layerChunkStatisticsUpdated.add(this.registerCancellable(animationFrameDebounce(() => this.updateChunkStatistics()))));
    }
    get layerManager() {
        return this.manager.layerManager;
    }
    disposed() {
        this.layerWidgets.forEach(x => x.dispose());
        this.layerWidgets = undefined;
        removeFromParent(this.element);
        super.disposed();
    }
    handleLayersChanged() {
        this.layerUpdateNeeded = true;
        this.handleLayerValuesChanged();
    }
    handleLayerValuesChanged() {
        if (!this.valueUpdateNeeded) {
            this.valueUpdateNeeded = true;
            this.scheduleUpdate();
        }
    }
    handleLayerItemValueChanged() {
        this.element.dataset.showHoverValues = this.showLayerHoverValues.value.toString();
    }
    update() {
        this.valueUpdateNeeded = false;
        this.updateLayers();
        if (this.showLayerHoverValues.value === false) {
            return;
        }
        let values = this.manager.layerSelectedValues;
        for (let _ref of this.layerWidgets) {
            var _ref2 = _slicedToArray(_ref, 2);

            let layer = _ref2[0];
            let widget = _ref2[1];

            let userLayer = layer.layer;
            let text = '';
            if (userLayer !== null) {
                let state = values.get(userLayer);
                if (state !== undefined) {
                    const value = state.value;

                    if (value !== undefined) {
                        text = '' + value;
                    }
                }
            }
            if (text === widget.prevValueText) continue;
            widget.prevValueText = text;
            if (text.length > widget.maxLength) {
                const length = widget.maxLength = text.length;
                widget.valueElement.style.width = `${length}ch`;
            }
            widget.valueElement.textContent = text;
        }
    }
    updateChunkStatistics() {
        for (const _ref3 of this.layerWidgets) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const layer = _ref4[0];
            const widget = _ref4[1];

            let numVisibleChunksNeeded = 0;
            let numVisibleChunksAvailable = 0;
            let numPrefetchChunksNeeded = 0;
            let numPrefetchChunksAvailable = 0;
            const userLayer = layer.layer;
            if (userLayer !== null) {
                for (const _ref5 of userLayer.renderLayers) {
                    const layerChunkProgressInfo = _ref5.layerChunkProgressInfo;

                    numVisibleChunksNeeded += layerChunkProgressInfo.numVisibleChunksNeeded;
                    numVisibleChunksAvailable += layerChunkProgressInfo.numVisibleChunksAvailable;
                    numPrefetchChunksNeeded += layerChunkProgressInfo.numPrefetchChunksNeeded;
                    numPrefetchChunksAvailable += layerChunkProgressInfo.numPrefetchChunksAvailable;
                }
            }
            widget.visibleProgress.style.width = `${numVisibleChunksAvailable / Math.max(1, numVisibleChunksNeeded) * 100}%`;
            widget.prefetchProgress.style.width = `${numPrefetchChunksAvailable / Math.max(1, numPrefetchChunksNeeded) * 100}%`;
        }
    }
    updateLayers() {
        var _a;
        if (!this.layerUpdateNeeded) {
            return;
        }
        this.layerUpdateNeeded = false;
        let container = this.element;
        let layers = new _Set();
        let nextChild = this.layerWidgetInsertionPoint.nextElementSibling;
        this.manager.rootLayers.updateNonArchivedLayerIndices();
        for (const layer of this.manager.layerManager.managedLayers) {
            if (layer.archived && !((_a = this.dropLayers) === null || _a === void 0 ? void 0 : _a.layers.has(layer))) continue;
            layers.add(layer);
            let widget = this.layerWidgets.get(layer);
            const layerIndex = layer.nonArchivedLayerIndex;
            if (widget === undefined) {
                widget = new LayerWidget(layer, this);
                this.layerWidgets.set(layer, widget);
            }
            widget.layerNumberElement.textContent = '' + (1 + layerIndex);
            widget.update();
            var _widget = widget;
            let element = _widget.element;

            if (element !== nextChild) {
                container.insertBefore(widget.element, nextChild);
            }
            nextChild = element.nextElementSibling;
        }
        for (let _ref6 of this.layerWidgets) {
            var _ref7 = _slicedToArray(_ref6, 2);

            let layer = _ref7[0];
            let widget = _ref7[1];

            if (!layers.has(layer)) {
                this.layerWidgets.delete(layer);
                widget.dispose();
            }
        }
    }
    addLayerMenu() {
        addNewLayer(this.manager, this.selectedLayer);
    }
}
//# sourceMappingURL=layer_bar.js.map