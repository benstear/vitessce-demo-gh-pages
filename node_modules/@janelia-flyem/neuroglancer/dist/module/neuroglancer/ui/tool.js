import _Object$entries from 'babel-runtime/core-js/object/entries';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Map from 'babel-runtime/core-js/map';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';

import debounce from 'lodash/debounce'; /**
                                         * @license
                                         * Copyright 2018 Google Inc.
                                         * Licensed under the Apache License, Version 2.0 (the "License");
                                         * you may not use this file except in compliance with the License.
                                         * You may obtain a copy of the License at
                                         *
                                         *      http://www.apache.org/licenses/LICENSE-2.0
                                         *
                                         * Unless required by applicable law or agreed to in writing, software
                                         * distributed under the License is distributed on an "AS IS" BASIS,
                                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                         * See the License for the specific language governing permissions and
                                         * limitations under the License.
                                         */
/**
 * @file Support for defining user-selectable tools.
 */

import { StatusMessage } from '../status';
import { animationFrameDebounce } from '../util/animation_frame_debounce';
import { RefCounted } from '../util/disposable';
import { registerActionListener } from '../util/event_action_map';
import { verifyObject, verifyObjectProperty, verifyString } from '../util/json';
import { Signal } from '../util/signal';
const TOOL_KEY_PATTERN = /^[A-Z]$/;
export class ToolActivation extends RefCounted {
    constructor(tool, inputEventMapBinder) {
        super();
        this.tool = tool;
        this.inputEventMapBinder = inputEventMapBinder;
    }
    bindAction(action, listener) {
        this.registerDisposer(registerActionListener(window, action, listener));
    }
    bindInputEventMap(inputEventMap) {
        this.inputEventMapBinder(inputEventMap, this);
    }
    cancel() {
        if (this == this.tool.layer.manager.root.toolBinder.activeTool_) {
            this.tool.layer.manager.root.toolBinder.deactivate_();
        }
    }
}
export class Tool extends RefCounted {
    constructor(layer, toggle = false) {
        super();
        this.layer = layer;
        this.toggle = toggle;
        this.changed = new Signal();
        this.keyBinding = undefined;
    }
    get mouseState() {
        return this.layer.manager.root.layerSelectedValues.mouseState;
    }
    unbind() {
        const layer = this.layer;
        const keyBinding = this.keyBinding;

        if (keyBinding !== undefined) {
            layer.toolBinder.set(keyBinding, undefined);
        }
    }
}
export class LegacyTool extends RefCounted {
    constructor(layer) {
        super();
        this.layer = layer;
        this.changed = new Signal();
    }
    get mouseState() {
        return this.layer.manager.root.layerSelectedValues.mouseState;
    }
    deactivate() {}
    unbind() {
        const layer = this.layer;

        if (layer.tool.value === this) {
            layer.tool.value = undefined;
        }
    }
}
export function restoreTool(layer, obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    if (typeof obj === 'string') {
        obj = { 'type': obj };
    }
    verifyObject(obj);
    const type = verifyObjectProperty(obj, 'type', verifyString);
    // First look for layer-specific tool.
    let getter = (_a = layerTools.get(layer.constructor)) === null || _a === void 0 ? void 0 : _a.get(type);
    if (getter === undefined) {
        // Look for layer-independent tool.
        getter = tools.get(type);
    }
    if (getter === undefined) {
        throw new Error(`Invalid tool type: ${_JSON$stringify(obj)}.`);
    }
    return getter(layer, obj);
}
export function restoreLegacyTool(layer, obj) {
    if (obj === undefined) {
        return undefined;
    }
    if (typeof obj === 'string') {
        obj = { 'type': obj };
    }
    verifyObject(obj);
    const type = verifyObjectProperty(obj, 'type', verifyString);
    const getter = legacyTools.get(type);
    if (getter === undefined) {
        throw new Error(`Invalid tool type: ${_JSON$stringify(obj)}.`);
    }
    return getter(layer, obj);
}
const legacyTools = new _Map();
const tools = new _Map();
const layerTools = new _Map();
export function registerLegacyTool(type, getter) {
    legacyTools.set(type, getter);
}
export function registerTool(type, getter) {
    tools.set(type, getter);
}
export function registerLayerTool(layerType, type, getter) {
    let tools = layerTools.get(layerType);
    if (tools === undefined) {
        tools = new _Map();
        layerTools.set(layerType, tools);
    }
    tools.set(type, getter);
}
export class SelectedLegacyTool extends RefCounted {
    constructor(layer) {
        super();
        this.layer = layer;
        this.changed = new Signal();
    }
    get value() {
        return this.value_;
    }
    set value(newValue) {
        if (newValue === this.value_) return;
        this.unregister();
        if (newValue !== undefined) {
            newValue.changed.add(this.changed.dispatch);
            this.value_ = newValue;
        }
        this.changed.dispatch();
    }
    unregister() {
        const existingValue = this.value_;
        if (existingValue !== undefined) {
            existingValue.changed.remove(this.changed.dispatch);
            existingValue.dispose();
            this.value_ = undefined;
        }
    }
    disposed() {
        this.unregister();
        super.disposed();
    }
    restoreState(obj) {
        this.value = restoreLegacyTool(this.layer, obj);
    }
    reset() {
        this.value = undefined;
    }
    toJSON() {
        const value = this.value_;
        if (value === undefined) return undefined;
        return value.toJSON();
    }
}
export class ToolBinder extends RefCounted {
    constructor(inputEventMapBinder) {
        super();
        this.inputEventMapBinder = inputEventMapBinder;
        this.bindings = new _Map();
        this.changed = new Signal();
        this.debounceDeactivate = this.registerCancellable(debounce(() => this.deactivate_(), 100));
        this.debounceReactivate = this.registerCancellable(debounce(() => this.reactivateQueuedTool(), 100));
    }
    get(key) {
        return this.bindings.get(key);
    }
    set(key, tool) {
        const bindings = this.bindings;

        const existingTool = bindings.get(key);
        if (existingTool !== undefined) {
            existingTool.keyBinding = undefined;
            bindings.delete(key);
            const layerToolBinder = existingTool.layer.toolBinder;
            layerToolBinder.bindings.delete(key);
            layerToolBinder.jsonToKey.delete(_JSON$stringify(existingTool.toJSON()));
            this.destroyTool(existingTool);
            layerToolBinder.changed.dispatch();
        }
        if (tool !== undefined) {
            const layerToolBinder = tool.layer.toolBinder;
            const json = _JSON$stringify(tool.toJSON());
            const existingKey = layerToolBinder.jsonToKey.get(json);
            if (existingKey !== undefined) {
                const existingTool = layerToolBinder.bindings.get(existingKey);
                existingTool.keyBinding = undefined;
                bindings.delete(existingKey);
                layerToolBinder.bindings.delete(existingKey);
                layerToolBinder.jsonToKey.delete(json);
                this.destroyTool(existingTool);
            }
            layerToolBinder.bindings.set(key, tool);
            tool.keyBinding = key;
            layerToolBinder.jsonToKey.set(json, key);
            bindings.set(key, tool);
            layerToolBinder.changed.dispatch();
        }
        this.changed.dispatch();
    }
    activate(key) {
        const tool = this.get(key);
        if (tool === undefined) {
            this.deactivate_();
            return;
        }
        this.debounceDeactivate.cancel();
        this.debounceReactivate.cancel();
        const activeTool = this.activeTool_;
        if (tool === (activeTool === null || activeTool === void 0 ? void 0 : activeTool.tool)) {
            if (tool.toggle) {
                this.deactivate_();
            }
            return;
        } else if (activeTool !== undefined) {
            if (activeTool.tool.toggle && !tool.toggle) {
                this.queuedTool = activeTool.tool;
            }
            this.deactivate_();
        }
        const activation = new ToolActivation(tool, this.inputEventMapBinder);
        this.activeTool_ = activation;
        if (!tool.toggle) {
            const expectedCode = `Key${key}`;
            activation.registerEventListener(window, 'keyup', event => {
                if (event.code === expectedCode) {
                    this.debounceDeactivate();
                    this.debounceReactivate();
                }
            });
            activation.registerEventListener(window, 'blur', () => {
                this.debounceDeactivate();
                this.debounceReactivate();
            });
        }
        tool.activate(activation);
        return tool;
    }
    reactivateQueuedTool() {
        if (this.queuedTool) {
            const activation = new ToolActivation(this.queuedTool, this.inputEventMapBinder);
            this.activeTool_ = activation;
            this.queuedTool.activate(activation);
            this.queuedTool = undefined;
        }
    }
    destroyTool(tool) {
        var _a;
        if (this.queuedTool === tool) {
            this.queuedTool = undefined;
        }
        if (((_a = this.activeTool_) === null || _a === void 0 ? void 0 : _a.tool) === tool) {
            this.deactivate_();
        }
        tool.dispose();
    }
    disposed() {
        this.deactivate_();
        super.disposed();
    }
    deactivate_() {
        // For internal use only- should only be called by ToolBinder and ToolActivation.cancel()
        this.debounceDeactivate.cancel();
        const activation = this.activeTool_;
        if (activation === undefined) return;
        this.activeTool_ = undefined;
        activation.dispose();
    }
}
export class LayerToolBinder {
    constructor(layer) {
        this.layer = layer;
        // Maps the the tool key (i.e. "A", "B", ...) to the bound tool.
        this.bindings = new _Map();
        // Maps the serialized json representation of the tool to the tool key.
        this.jsonToKey = new _Map();
        this.changed = new Signal();
        layer.registerDisposer(() => this.clear());
    }
    get globalBinder() {
        return this.layer.manager.root.toolBinder;
    }
    get(key) {
        return this.bindings.get(key);
    }
    set(key, tool) {
        this.globalBinder.set(key, tool);
    }
    setJson(key, toolJson) {
        const tool = restoreTool(this.layer, toolJson);
        if (tool === undefined) return;
        this.set(key, tool);
    }
    removeJsonString(toolJsonString) {
        const key = this.jsonToKey.get(toolJsonString);
        if (key === undefined) return;
        this.set(key, undefined);
    }
    toJSON() {
        const bindings = this.bindings;

        if (bindings.size === 0) return undefined;
        const obj = {};
        for (const _ref of bindings) {
            var _ref2 = _slicedToArray(_ref, 2);

            const key = _ref2[0];
            const value = _ref2[1];

            obj[key] = value.toJSON();
        }
        return obj;
    }
    clear() {
        const globalBinder = this.globalBinder,
              bindings = this.bindings;

        if (bindings.size !== 0) {
            for (const _ref3 of bindings) {
                var _ref4 = _slicedToArray(_ref3, 2);

                const key = _ref4[0];
                const tool = _ref4[1];

                tool.keyBinding = undefined;
                globalBinder.bindings.delete(key);
                globalBinder.destroyTool(tool);
            }
            bindings.clear();
            this.jsonToKey.clear();
            globalBinder.changed.dispatch();
            this.changed.dispatch();
        }
    }
    reset() {
        this.clear();
    }
    restoreState(obj) {
        if (obj === undefined) return;
        verifyObject(obj);
        for (const _ref5 of _Object$entries(obj)) {
            var _ref6 = _slicedToArray(_ref5, 2);

            const key = _ref6[0];
            const value = _ref6[1];

            if (!key.match(TOOL_KEY_PATTERN)) {
                throw new Error(`Invalid tool key: ${_JSON$stringify(key)}`);
            }
            const tool = restoreTool(this.layer, value);
            if (tool === undefined) return;
            this.set(key, tool);
        }
    }
}
export class ToolBindingWidget extends RefCounted {
    constructor(layer, toolJson) {
        super();
        this.layer = layer;
        this.toolJson = toolJson;
        this.element = document.createElement('div');
        this.toolJsonString = _JSON$stringify(this.toolJson);
        const element = this.element;

        element.classList.add('neuroglancer-tool-key-binding');
        this.registerDisposer(layer.toolBinder.changed.add(this.registerCancellable(animationFrameDebounce(() => this.updateView()))));
        this.updateView();
        element.title = 'click → bind key, dbclick → unbind';
        element.addEventListener('dblclick', () => {
            this.layer.toolBinder.removeJsonString(this.toolJsonString);
        });
        addToolKeyBindHandlers(this, element, key => this.layer.toolBinder.setJson(key, this.toolJson));
    }
    updateView() {
        const toolBinder = this.layer.toolBinder;

        const key = toolBinder.jsonToKey.get(this.toolJsonString);
        this.element.textContent = key !== null && key !== void 0 ? key : ' ';
    }
}
export function addToolKeyBindHandlers(context, element, bindKey) {
    let mousedownContext;
    element.addEventListener('mousedown', event => {
        if (event.button !== 0 || mousedownContext !== undefined) return;
        event.preventDefault();
        event.stopPropagation();
        mousedownContext = new RefCounted();
        context.registerDisposer(mousedownContext);
        const message = mousedownContext.registerDisposer(new StatusMessage(false));
        message.setText('Press A-Z to bind key');
        mousedownContext.registerEventListener(window, 'keydown', event => {
            const code = event.code;

            const m = code.match(/^Key([A-Z])$/);
            if (m === null) return;
            event.stopPropagation();
            event.preventDefault();
            const key = m[1];
            bindKey(key);
        }, { capture: true });
        mousedownContext.registerEventListener(window, 'mouseup', event => {
            if (event.button !== 0 || mousedownContext === undefined) return;
            event.preventDefault();
            event.stopPropagation();
            context.unregisterDisposer(mousedownContext);
            mousedownContext.dispose();
            mousedownContext = undefined;
        });
    });
    element.addEventListener('click', event => {
        event.preventDefault();
        event.stopPropagation();
    });
}
export function makeToolButton(context, layer, options) {
    const element = document.createElement('div');
    element.classList.add('neuroglancer-tool-button');
    element.appendChild(context.registerDisposer(new ToolBindingWidget(layer, options.toolJson)).element);
    const labelElement = document.createElement('div');
    labelElement.classList.add('neuroglancer-tool-button-label');
    labelElement.textContent = options.label;
    if (options.title) {
        labelElement.title = options.title;
    }
    element.appendChild(labelElement);
    return element;
}
export function makeToolActivationStatusMessage(activation) {
    const message = activation.registerDisposer(new StatusMessage(false));
    message.element.classList.add('neuroglancer-tool-status');
    const content = document.createElement('div');
    content.classList.add('neuroglancer-tool-status-content');
    message.element.appendChild(content);
    const inputEventMapBinder = activation.inputEventMapBinder;

    activation.inputEventMapBinder = (inputEventMap, context) => {
        const bindingHelp = document.createElement('div');
        bindingHelp.textContent = inputEventMap.describe();
        bindingHelp.classList.add('neuroglancer-tool-status-bindings');
        message.element.appendChild(bindingHelp);
        inputEventMapBinder(inputEventMap, context);
    };
    return { message, content };
}
export function makeToolActivationStatusMessageWithHeader(activation) {
    var _makeToolActivationSt = makeToolActivationStatusMessage(activation);

    const message = _makeToolActivationSt.message,
          content = _makeToolActivationSt.content;

    const header = document.createElement('div');
    header.classList.add('neuroglancer-tool-status-header');
    const headerContainer = document.createElement('div');
    headerContainer.classList.add('neuroglancer-tool-status-header-container');
    headerContainer.appendChild(header);
    content.appendChild(headerContainer);
    const body = document.createElement('div');
    body.classList.add('neuroglancer-tool-status-body');
    content.appendChild(body);
    return { message, body, header };
}
//# sourceMappingURL=tool.js.map