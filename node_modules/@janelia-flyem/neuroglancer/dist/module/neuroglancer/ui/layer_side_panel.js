import _Map from 'babel-runtime/core-js/map';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';

import svg_cursor from 'ikonate/icons/cursor.svg'; /**
                                                    * @license
                                                    * Copyright 2018 Google Inc.
                                                    * Licensed under the Apache License, Version 2.0 (the "License");
                                                    * you may not use this file except in compliance with the License.
                                                    * You may obtain a copy of the License at
                                                    *
                                                    *      http://www.apache.org/licenses/LICENSE-2.0
                                                    *
                                                    * Unless required by applicable law or agreed to in writing, software
                                                    * distributed under the License is distributed on an "AS IS" BASIS,
                                                    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                    * See the License for the specific language governing permissions and
                                                    * limitations under the License.
                                                    */
/**
 * @file Side panel for displaying/editing layer details.
 */

import { changeLayerName, changeLayerType, deleteLayer, layerTypes } from '../layer';
import { ElementVisibilityFromTrackableBoolean } from '../trackable_boolean';
import { CachedWatchableValue, observeWatchable } from '../trackable_value';
import { LAYER_SIDE_PANEL_DEFAULT_LOCATION } from './layer_side_panel_state';
import { popDragStatus, pushDragStatus } from './drag_and_drop';
import { DRAG_OVER_CLASSNAME, SidePanel } from './side_panel';
import { RefCounted } from '../util/disposable';
import { KeyboardEventBinder, registerActionListener } from '../util/keyboard_bindings';
import { EventActionMap } from '../util/mouse_bindings';
import { CheckboxIcon } from '../widget/checkbox_icon';
import { makeDeleteButton } from '../widget/delete_button';
import { TabView } from '../widget/tab_view';
const layerNameInputEventMap = EventActionMap.fromObject({
    'escape': { action: 'cancel' }
});
export class LayerNameWidget extends RefCounted {
    constructor(layer) {
        super();
        this.layer = layer;
        this.element = document.createElement('input');
        const element = this.element;

        element.classList.add('neuroglancer-layer-side-panel-name');
        element.spellcheck = false;
        element.autocomplete = 'off';
        const keyboardHandler = this.registerDisposer(new KeyboardEventBinder(element, layerNameInputEventMap));
        keyboardHandler.allShortcutsAreGlobal = true;
        registerActionListener(element, 'cancel', event => {
            this.updateView();
            element.blur();
            event.stopPropagation();
            event.preventDefault();
        });
        element.title = 'Rename layer';
        this.registerDisposer(layer.layerChanged.add(() => this.updateView()));
        element.addEventListener('change', () => this.updateModel());
        element.addEventListener('blur', () => this.updateModel());
        this.updateView();
    }
    updateView() {
        this.element.value = this.layer.name;
    }
    updateModel() {
        changeLayerName(this.layer, this.element.value);
    }
}
export class LayerTypeWidget extends RefCounted {
    constructor(layer) {
        super();
        this.layer = layer;
        this.element = document.createElement('select');
        this.measureElement = document.createElement('div');
        const element = this.element,
              measureElement = this.measureElement;

        element.classList.add('neuroglancer-layer-side-panel-type');
        measureElement.classList.add('neuroglancer-layer-side-panel-type-measure');
        element.title = 'Change layer type';
        document.body.appendChild(measureElement);
        for (const _ref of layerTypes) {
            var _ref2 = _slicedToArray(_ref, 2);

            const layerType = _ref2[0];
            const layerConstructor = _ref2[1];

            if (layerConstructor.type !== layerType) continue;
            const option = document.createElement('option');
            option.textContent = layerConstructor.typeAbbreviation;
            option.value = layerType;
            element.appendChild(option);
        }
        element.addEventListener('change', () => {
            const newType = element.value;
            const layerConstructor = layerTypes.get(newType);
            changeLayerType(this.layer.managedLayer, layerConstructor);
        });
        this.updateView();
    }
    updateView() {
        const selectedName = this.layer.type;
        const element = this.element,
              measureElement = this.measureElement;

        measureElement.textContent = this.layer.constructor.typeAbbreviation;
        element.value = selectedName;
        element.style.width = `${measureElement.offsetWidth}px`;
    }
    disposed() {
        this.measureElement.remove();
    }
}
class LayerSidePanel extends SidePanel {
    constructor(sidePanelManager, panelState) {
        super(sidePanelManager, panelState.location);
        this.panelState = panelState;
        const layer = this.layer = panelState.layer;
        const element = this.element;

        var _addTitleBar = this.addTitleBar({});

        const titleBar = _addTitleBar.titleBar;

        titleBar.classList.add('neuroglancer-layer-side-panel-title');
        titleBar.appendChild(this.registerDisposer(new LayerTypeWidget(layer)).element);
        titleBar.appendChild(this.registerDisposer(new LayerNameWidget(layer.managedLayer)).element);
        this.registerDisposer(observeWatchable(visible => {
            element.dataset.neuroglancerLayerVisible = visible.toString();
        }, {
            get value() {
                return layer.managedLayer.visible;
            },
            changed: layer.managedLayer.layerChanged
        }));
        const pickButton = this.registerDisposer(new CheckboxIcon({
            get value() {
                return layer.managedLayer.pickEnabled;
            },
            set value(value) {
                layer.managedLayer.pickEnabled = value;
            },
            changed: layer.managedLayer.layerChanged
        }, {
            svg: svg_cursor,
            enableTitle: 'Spatial object selection: disabled',
            disableTitle: 'Spatial object selection: enabled'
        }));
        this.registerDisposer(new ElementVisibilityFromTrackableBoolean({
            get value() {
                return layer.managedLayer.supportsPickOption;
            },
            changed: layer.managedLayer.layerChanged
        }, pickButton.element));
        titleBar.appendChild(pickButton.element);
        const pinWatchable = {
            get value() {
                return panelState !== layer.panels.panels[0];
            },
            set value(value) {
                if (value) {
                    panelState.pin();
                } else {
                    panelState.unpin();
                }
            },
            changed: layer.manager.root.layerManager.layersChanged
        };
        titleBar.appendChild(this.registerDisposer(new CheckboxIcon(pinWatchable, {
            // Note: \ufe0e forces text display, as otherwise the pin icon
            // may as an emoji with color.
            text: 'ðŸ“Œ\ufe0e',
            enableTitle: 'Pin panel to this layer',
            disableTitle: 'Unpin panel to this layer'
        })).element);
        this.registerDisposer(observeWatchable(pinned => {
            element.dataset.neuroglancerLayerPanelPinned = pinned.toString();
        }, pinWatchable));
        titleBar.appendChild(makeDeleteButton({
            title: 'Delete layer',
            onClick: () => {
                deleteLayer(this.layer.managedLayer);
            }
        }));
        this.tabView = new TabView({
            makeTab: id => layer.tabs.options.get(id).getter(),
            selectedTab: panelState.selectedTab,
            tabs: this.registerDisposer(new CachedWatchableValue({
                get value() {
                    return panelState.tabs.map(id => ({
                        id,
                        label: layer.tabs.options.get(id).label
                    }));
                },
                changed: panelState.tabsChanged
            })),
            handleTabElement: (id, element) => {
                element.draggable = true;
                element.addEventListener('dragstart', event => {
                    event.stopPropagation();
                    event.dataTransfer.setData('neuroglancer-side-panel', '');
                    let message = 'Drag tab to dock as new panel to the left/right/top/bottom of another panel';
                    const hasOtherPanel = panelState.panels.panels.find(p => p !== panelState && p.location.visible);
                    if (hasOtherPanel) {
                        message += `, or move tab to other ${_JSON$stringify(layer.managedLayer.name)} panel`;
                    }
                    pushDragStatus(element, 'drag', message);
                    this.sidePanelManager.startDrag({
                        dropAsNewPanel: location => {
                            this.panelState.splitOffTab(id, _Object$assign(_Object$assign({}, LAYER_SIDE_PANEL_DEFAULT_LOCATION), location));
                        },
                        canDropAsTabs: target => {
                            if (target instanceof LayerSidePanel && target.layer === this.layer && target !== this) {
                                return 1;
                            }
                            return 0;
                        },
                        dropAsTab: target => {
                            this.panelState.moveTabTo(id, target.panelState);
                        }
                    }, event);
                });
                element.addEventListener('dragend', event => {
                    event;
                    popDragStatus(element, 'drag');
                    this.sidePanelManager.endDrag();
                });
            }
        }, this.visibility);
        this.tabView.element.style.flex = '1';
        this.tabView.element.classList.add('neuroglancer-layer-side-panel-tab-view');
        this.tabView.element.style.position = 'relative';
        this.tabView.element.appendChild(this.makeTabDropZone());
        this.addBody(this.tabView.element);
        // Hide panel automatically if there are no tabs to display (because they have all been moved to
        // another panel).
        this.registerDisposer(panelState.tabsChanged.add(() => {
            if (panelState.tabs.length === 0) {
                this.location.visible = false;
            }
        }));
    }
    makeDragSource() {
        return _Object$assign(_Object$assign({}, super.makeDragSource()), { canDropAsTabs: target => {
                if (target instanceof LayerSidePanel && target.layer === this.layer && target !== this) {
                    return this.panelState.tabs.length;
                }
                return 0;
            }, dropAsTab: target => {
                this.panelState.mergeInto(target.panelState);
            } });
    }
    makeTabDropZone() {
        const element = document.createElement('div');
        element.className = 'neuroglancer-side-panel-drop-zone';
        element.style.position = 'absolute';
        element.style.left = '20px';
        element.style.right = '20px';
        element.style.bottom = '20px';
        element.style.top = '20px';
        element.addEventListener('dragenter', event => {
            var _a;
            const dragSource = this.sidePanelManager.dragSource;

            const numTabs = (_a = dragSource === null || dragSource === void 0 ? void 0 : dragSource.canDropAsTabs) === null || _a === void 0 ? void 0 : _a.call(dragSource, this);
            if (!numTabs) return;
            element.classList.add(DRAG_OVER_CLASSNAME);
            pushDragStatus(element, 'drop', `Move ${numTabs} ${numTabs === 1 ? 'tab' : 'tabs'} to this panel`);
            event.preventDefault();
        });
        element.addEventListener('dragleave', () => {
            popDragStatus(element, 'drop');
            element.classList.remove(DRAG_OVER_CLASSNAME);
        });
        element.addEventListener('dragover', event => {
            var _a;
            const dragSource = this.sidePanelManager.dragSource;

            if (!((_a = dragSource === null || dragSource === void 0 ? void 0 : dragSource.canDropAsTabs) === null || _a === void 0 ? void 0 : _a.call(dragSource, this))) return;
            event.preventDefault();
        });
        element.addEventListener('drop', event => {
            var _a;
            popDragStatus(element, 'drop');
            const dragSource = this.sidePanelManager.dragSource;

            if (!((_a = dragSource === null || dragSource === void 0 ? void 0 : dragSource.canDropAsTabs) === null || _a === void 0 ? void 0 : _a.call(dragSource, this))) return;
            element.classList.remove(DRAG_OVER_CLASSNAME);
            dragSource.dropAsTab(this);
            event.preventDefault();
            event.stopPropagation();
        });
        return element;
    }
}
export class LayerSidePanelManager extends RefCounted {
    constructor(sidePanelManager, selectedLayerState) {
        super();
        this.sidePanelManager = sidePanelManager;
        this.selectedLayerState = selectedLayerState;
        this.layerSidePanels = new _Map();
        this.generation = 0;
        this.layersNeedUpdate = true;
        const handleUpdate = () => {
            this.layersNeedUpdate = true;
            this.sidePanelManager.display.scheduleRedraw();
        };
        this.registerDisposer(selectedLayerState.changed.add(handleUpdate));
        this.registerDisposer(selectedLayerState.layerManager.layersChanged.add(handleUpdate));
        this.registerDisposer(sidePanelManager.beforeRender.add(() => this.update()));
    }
    getSelectedUserLayer() {
        var _a, _b;
        return (_b = (_a = this.selectedLayerState.layer) === null || _a === void 0 ? void 0 : _a.layer) !== null && _b !== void 0 ? _b : undefined;
    }
    update() {
        var _a;
        if (!this.layersNeedUpdate) return;
        const layerManager = this.selectedLayerState.layerManager;

        let generation = ++this.generation;
        this.layersNeedUpdate = false;
        const layerSidePanels = this.layerSidePanels;

        const ensurePanel = panelState => {
            let existing = layerSidePanels.get(panelState);
            if (existing === undefined) {
                existing = {
                    generation,
                    unregister: this.sidePanelManager.registerPanel({
                        location: panelState.location,
                        makePanel: () => new LayerSidePanel(this.sidePanelManager, panelState)
                    })
                };
                layerSidePanels.set(panelState, existing);
            } else {
                existing.generation = generation;
            }
        };
        // Add selected layer panel
        {
            const layer = this.getSelectedUserLayer();
            const location = this.selectedLayerState.location;

            if (layer === undefined || !location.visible) {
                if (this.placeholderSelectedLayerPanel === undefined) {
                    this.placeholderSelectedLayerPanel = this.sidePanelManager.registerPanel({ location, makePanel: () => new SidePanel(this.sidePanelManager, location) });
                }
            } else {
                (_a = this.placeholderSelectedLayerPanel) === null || _a === void 0 ? void 0 : _a.call(this);
                this.placeholderSelectedLayerPanel = undefined;
                const panelState = layer.panels.panels[0];
                panelState.location.value = location.value;
                ensurePanel(panelState);
            }
        }
        // Add extra layer panels
        for (const layer of layerManager.managedLayers) {
            const userLayer = layer.layer;
            if (userLayer === null) continue;
            const panels = userLayer.panels.panels;

            for (let i = 1, length = panels.length; i < length; ++i) {
                ensurePanel(panels[i]);
            }
        }
        for (const _ref3 of layerSidePanels) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const panelState = _ref4[0];
            const existing = _ref4[1];

            if (existing.generation === generation) continue;
            existing.unregister();
            layerSidePanels.delete(panelState);
        }
    }
    disposed() {
        var _a;
        (_a = this.placeholderSelectedLayerPanel) === null || _a === void 0 ? void 0 : _a.call(this);
        for (const _ref5 of this.layerSidePanels.values()) {
            const unregister = _ref5.unregister;

            unregister();
        }
    }
}
//# sourceMappingURL=layer_side_panel.js.map