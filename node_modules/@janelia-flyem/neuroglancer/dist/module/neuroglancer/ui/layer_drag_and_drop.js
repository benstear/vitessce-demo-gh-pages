import _Map from 'babel-runtime/core-js/map';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Set from 'babel-runtime/core-js/set';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { initializeLayerFromSpecShowErrorStatus, ManagedUserLayer } from '../layer';
import { popDragStatus, pushDragStatus } from './drag_and_drop';
import { decodeParametersFromDragTypeList, encodeParametersAsDragType, getDropEffect, setDropEffect } from '../util/drag_and_drop';
import { parseArray, verifyBoolean, verifyObjectProperty, verifyString } from '../util/json';
const layerDragTypePrefix = 'neuroglancer-layer\0';
let dragSource;
export function startLayerDrag(event, sourceInfo) {
    var _a;
    event.dataTransfer.setData(encodeParametersAsDragType(layerDragTypePrefix, sourceInfo.layers.map(layer => ({ name: layer.name, visible: layer.visible }))), _JSON$stringify({ layers: sourceInfo.layers.map(layer => layer.toJSON()), layout: sourceInfo.layoutSpec }));
    if (dragSource !== undefined) {
        dragSource.disposer();
    }
    let newDragSource;
    let disposer = () => {
        sourceInfo.manager.unregisterDisposer(disposer);
        for (const layer of sourceInfo.layers) {
            layer.dispose();
        }
        sourceInfo.manager.dispose();
        if (dragSource === newDragSource) {
            dragSource = undefined;
        }
    };
    dragSource = newDragSource = {
        manager: sourceInfo.manager.addRef(),
        layers: sourceInfo.layers.map(x => x.addRef()),
        layoutSpec: sourceInfo.layoutSpec,
        isLayerListPanel: (_a = sourceInfo.isLayerListPanel) !== null && _a !== void 0 ? _a : false,
        disposer
    };
}
export function endLayerDrag(dropEffect = 'none') {
    if (dragSource !== undefined) {
        if (dropEffect === 'move') {
            // Remove source layers since they have been moved.
            const removedLayers = new _Set(dragSource.layers);
            dragSource.manager.layerManager.filter(x => !removedLayers.has(x));
        }
        dragSource.disposer();
    }
}
export function getLayerDragInfo(event) {
    return decodeParametersFromDragTypeList(event.dataTransfer.types, layerDragTypePrefix);
}
function getCompatibleDragSource(manager) {
    if (dragSource !== undefined && dragSource.manager.rootLayers === manager.rootLayers) {
        return dragSource;
    }
    return undefined;
}
export class DropLayers {
    /**
     * Called in the 'drop' event handler to actually initialize the layers if they are external.
     * Returns false if any layers failed to initialized.
     */
    initializeExternalLayers(event) {
        const dragType = this.dragType;

        if (dragType !== undefined) {
            try {
                var _JSON$parse = JSON.parse(event.dataTransfer.getData(dragType));

                const spec = _JSON$parse.layers,
                      layout = _JSON$parse.layout;

                if (!Array.isArray(spec) || this.numSourceLayers !== spec.length) {
                    throw new Error('Invalid layer drop data');
                }
                this.layoutSpec = layout;
                for (const _ref of this.layers) {
                    var _ref2 = _slicedToArray(_ref, 2);

                    const layer = _ref2[0];
                    const index = _ref2[1];

                    initializeLayerFromSpecShowErrorStatus(layer, spec[index]);
                }
            } catch (_a) {
                return false;
            }
        }
        return true;
    }
    updateArchiveStates(event) {
        // If archived === false (i.e. drop target is a layer bar or new layer group location), set
        // all layers as non-archived, since those drop targets can only contain non-archived layers.
        //
        // If archived === true, drop target is the layer list panel.  If the layer would not be
        // logically present in any layer groups, set it to archived.
        const targetIsLayerListPanel = this.targetIsLayerListPanel;

        const dropEffect = event.dataTransfer.dropEffect;
        for (const layer of this.layers.keys()) {
            let shouldBeArchived = targetIsLayerListPanel;
            if (targetIsLayerListPanel && !layer.archived && dropEffect !== 'copy') {
                if (this.sourceIsLayerListPanel) {
                    shouldBeArchived = false;
                }
            }
            if (layer.archived !== shouldBeArchived || shouldBeArchived && layer.visible) {
                layer.archived = shouldBeArchived;
                if (shouldBeArchived) layer.visible = false;
                layer.layerChanged.dispatch();
            }
        }
    }
    get method() {
        if (this.sourceManager !== undefined) {
            if (this.manager === this.sourceManager && this.sourceIsLayerListPanel === this.targetIsLayerListPanel) {
                return 'move';
            } else {
                return 'link';
            }
        } else {
            return 'copy';
        }
    }
    compatibleWithMethod(otherMethod) {
        if (this.method === otherMethod) {
            return true;
        }
        if (this.forceCopy && otherMethod !== 'copy') {
            return false;
        }
        if (!this.moveSupported && otherMethod === 'move') {
            return true;
        }
        return false;
    }
}
export function getDropEffectFromModifiers(event, defaultDropEffect, moveAllowed) {
    let dropEffect;
    if (event.shiftKey) {
        dropEffect = 'copy';
    } else if (event.ctrlKey && moveAllowed) {
        dropEffect = 'move';
    } else {
        dropEffect = defaultDropEffect;
    }
    let message = '';
    const addMessage = msg => {
        if (message !== '') {
            message += ', ';
        }
        message += msg;
    };
    if (defaultDropEffect !== 'none' && dropEffect !== defaultDropEffect) {
        if (event.shiftKey) {
            addMessage(`release SHIFT to ${defaultDropEffect}`);
        } else {
            addMessage(`release CONTROL to ${defaultDropEffect}`);
        }
    }
    if (dropEffect !== 'copy') {
        addMessage('hold SHIFT to copy');
    }
    if (dropEffect !== 'move' && moveAllowed && defaultDropEffect !== 'move') {
        addMessage('hold CONTROL to move');
    }
    return { dropEffect, dropEffectMessage: message };
}
export function getLayerDropEffect(event, manager, targetIsLayerListPanel, newTarget) {
    const source = getCompatibleDragSource(manager);
    let moveAllowed = false;
    let defaultDropEffect;
    if (source === undefined) {
        defaultDropEffect = 'copy';
    } else {
        if (newTarget) {
            // We cannot "move" layers out of the layer list panel.
            if (!source.isLayerListPanel) {
                moveAllowed = true;
            }
            defaultDropEffect = 'link';
        } else {
            if (source.manager === manager && source.isLayerListPanel === targetIsLayerListPanel) {
                defaultDropEffect = 'move';
                moveAllowed = true;
            } else if (targetIsLayerListPanel) {
                defaultDropEffect = 'none';
            } else if (source.isLayerListPanel) {
                defaultDropEffect = 'link';
            } else {
                moveAllowed = true;
                defaultDropEffect = 'link';
            }
        }
    }
    return getDropEffectFromModifiers(event, defaultDropEffect, moveAllowed);
}
export function updateLayerDropEffect(event, manager, targetIsLayerListPanel, newTarget) {
    const result = getLayerDropEffect(event, manager, targetIsLayerListPanel, newTarget);
    setDropEffect(event, result.dropEffect);
    return result;
}
export function getDropLayers(event, manager, options) {
    const forceCopy = options.forceCopy,
          newTarget = options.newTarget;
    var _options$isLayerListP = options.isLayerListPanel;
    const isLayerListPanel = _options$isLayerListP === undefined ? false : _options$isLayerListP;

    const source = getCompatibleDragSource(manager);
    if (!forceCopy && source !== undefined) {
        const moveSupported = !newTarget && source.manager === manager && (source.isLayerListPanel === isLayerListPanel || source.isLayerListPanel);
        const result = new DropLayers();
        result.manager = manager;
        result.numSourceLayers = source.layers.length;
        result.sourceManager = source.manager;
        result.targetIsLayerListPanel = isLayerListPanel;
        result.sourceIsLayerListPanel = source.isLayerListPanel;
        result.moveSupported = moveSupported;
        result.layers = new _Map();
        result.forceCopy = false;
        result.layoutSpec = source.layoutSpec;
        if (moveSupported) {
            source.layers.forEach((layer, index) => {
                result.layers.set(layer, index);
            });
        } else {
            source.layers.forEach((layer, index) => {
                if (newTarget || !manager.layerManager.has(layer)) {
                    result.layers.set(layer.addRef(), index);
                }
            });
        }
        return result;
    }
    const info = getLayerDragInfo(event);
    if (info !== undefined) {
        try {
            const layers = parseArray(info.parameters, (layerInfo, index) => {
                const name = verifyObjectProperty(layerInfo, 'name', verifyString);
                let visible = verifyObjectProperty(layerInfo, 'visible', verifyBoolean);
                const newLayer = new ManagedUserLayer(name, manager);
                if (isLayerListPanel) visible = false;
                newLayer.visible = visible;
                newLayer.archived = isLayerListPanel;
                return [newLayer, index];
            });
            const result = new DropLayers();
            result.numSourceLayers = layers.length;
            result.targetIsLayerListPanel = isLayerListPanel;
            result.sourceIsLayerListPanel = false;
            result.sourceManager = undefined;
            result.moveSupported = false;
            result.forceCopy = source !== undefined;
            result.manager = manager;
            result.dragType = info.dragType;
            result.layers = new _Map(layers);
            return result;
        } catch (_a) {}
    }
    return undefined;
}
function destroyDropLayers(dropLayers, targetLayer) {
    if (dropLayers.moveSupported) {
        // Nothing to do.
        return false;
    }
    dropLayers.manager.layerManager.filter(layer => !dropLayers.layers.has(layer));
    return targetLayer !== undefined && dropLayers.layers.has(targetLayer);
}
export function registerLayerBarDropHandlers(panel, target, targetLayer, isLayerListPanel = false) {
    function update(event, updateDropEffect) {
        let dropLayers = panel.dropLayers;

        var _ref3 = updateDropEffect ? getLayerDropEffect(event, panel.manager, isLayerListPanel, /*newTarget=*/false) : { dropEffect: getDropEffect(), dropEffectMessage: '' };

        const dropEffect = _ref3.dropEffect,
              dropEffectMessage = _ref3.dropEffectMessage;

        if (dropEffect === undefined) return undefined;
        setDropEffect(event, dropEffect);
        let existingDropLayers = true;
        if (dropLayers !== undefined) {
            if (!dropLayers.compatibleWithMethod(dropEffect)) {
                panel.dropLayers = undefined;
                if (destroyDropLayers(dropLayers, targetLayer)) {
                    // We destroyed the layer for which we received the dragenter event.  Wait until we get
                    // another dragenter or drop event to do something.
                    return undefined;
                }
            }
        }
        if (dropLayers === undefined) {
            dropLayers = panel.dropLayers = getDropLayers(event, panel.manager, { forceCopy: dropEffect === 'copy', newTarget: false, isLayerListPanel });
            if (dropLayers === undefined) {
                return undefined;
            }
            existingDropLayers = dropLayers.method === 'move';
        }
        if (targetLayer !== undefined && dropLayers.layers.has(targetLayer)) {
            // Dragged onto itself, nothing to do.
            return { dropLayers, dropEffect, dropEffectMessage };
        }
        if (!existingDropLayers) {
            let newIndex;
            if (targetLayer !== undefined) {
                newIndex = panel.manager.layerManager.managedLayers.indexOf(targetLayer);
            }
            for (const newLayer of dropLayers.layers.keys()) {
                panel.manager.add(newLayer, newIndex);
            }
        } else {
            // Rearrange layers.
            const layerManager = panel.manager.layerManager;

            const existingLayers = new _Set();
            let firstRemovalIndex = Number.POSITIVE_INFINITY;
            const managedLayers = layerManager.managedLayers = layerManager.managedLayers.filter((x, index) => {
                if (dropLayers.layers.has(x)) {
                    if (firstRemovalIndex === Number.POSITIVE_INFINITY) {
                        firstRemovalIndex = index;
                    }
                    existingLayers.add(x);
                    return false;
                } else {
                    return true;
                }
            });
            let newIndex;
            if (targetLayer !== undefined) {
                newIndex = managedLayers.indexOf(targetLayer);
                if (firstRemovalIndex <= newIndex) {
                    ++newIndex;
                }
            } else {
                newIndex = managedLayers.length;
            }
            // Filter out layers that have been concurrently removed.
            for (const layer of dropLayers.layers.keys()) {
                if (!existingLayers.has(layer)) {
                    dropLayers.layers.delete(layer);
                }
            }
            managedLayers.splice(newIndex, 0, ...dropLayers.layers.keys());
            layerManager.layersChanged.dispatch();
        }
        return { dropLayers, dropEffect, dropEffectMessage };
    }
    target.addEventListener('dragenter', event => {
        if (update(event, /*updateDropEffect=*/true) !== undefined) {
            event.preventDefault();
        } else {
            popDragStatus(panel.element, 'drop');
        }
    });
    target.addEventListener('drop', event => {
        var _a;
        event.preventDefault();
        panel.dragEnterCount = 0;
        popDragStatus(panel.element, 'drop');
        const dropLayers = (_a = update(event, /*updateDropEffect=*/false)) === null || _a === void 0 ? void 0 : _a.dropLayers;
        panel.dropLayers = undefined;
        if (dropLayers === undefined) return;
        if (!dropLayers.initializeExternalLayers(event)) {
            destroyDropLayers(dropLayers);
            return;
        }
        dropLayers.updateArchiveStates(event);
        endLayerDrag(dropLayers.method === 'move' ? undefined : event.dataTransfer.dropEffect);
    });
    target.addEventListener('dragover', event => {
        const updateResult = update(event, /*updateDropEffect=*/true);
        if (updateResult === undefined) {
            popDragStatus(panel.element, 'drop');
            return;
        }
        const dropLayers = updateResult.dropLayers,
              dropEffect = updateResult.dropEffect,
              dropEffectMessage = updateResult.dropEffectMessage;

        const numLayers = dropLayers.layers.size;
        let message = '';
        const maybePlural = dropLayers.numSourceLayers === 1 ? '' : 's';
        const numSourceLayers = dropLayers.numSourceLayers;
        if (dropEffect === 'none') {
            message = `Cannot link dragged layer${maybePlural} here`;
        } else {
            const layerCountMessage = numSourceLayers === numLayers ? `${numSourceLayers}` : `${numLayers}/${numSourceLayers}`;
            message = `Drop to ${dropEffect} ${layerCountMessage} layer${maybePlural}`;
        }
        if (dropEffectMessage) {
            message += ` (${dropEffectMessage})`;
        }
        pushDragStatus(panel.element, 'drop', message);
        event.preventDefault();
        event.stopPropagation();
    });
}
export function registerLayerDragHandlers(panel, element, layer, options) {
    element.draggable = true;
    element.addEventListener('dragstart', event => {
        pushDragStatus(element, 'drag', 'Drag layer to another layer bar/panel (including in another Neuroglancer window), ' + 'or to the left/top/right/bottom edge of a layer group');
        startLayerDrag(event, {
            manager: panel.manager,
            layers: [layer],
            layoutSpec: options.getLayoutSpec(),
            isLayerListPanel: options.isLayerListPanel
        });
        event.stopPropagation();
    });
    element.addEventListener('dragend', () => {
        popDragStatus(element, 'drag');
        // This call to endLayerDrag is a no-op if a drag was completed successfully within the same
        // browser window, because it will already have been called by the `drop` handler.  This call
        // has an effect only for a cancelled drag or a successful cross-browser window drag.
        // Cross-browser window drags are always `copy` operations because Chrome does not properly
        // communicate the drag effect, so there is no way to signal a `move`.
        //
        // https://bugs.chromium.org/p/chromium/issues/detail?id=39399
        endLayerDrag();
    });
}
export function registerLayerBarDragLeaveHandler(panel) {
    panel.element.addEventListener('dragenter', () => {
        ++panel.dragEnterCount;
    });
    panel.element.addEventListener('dragleave', () => {
        if (--panel.dragEnterCount !== 0) return;
        popDragStatus(panel.element, 'drop');
        const dropLayers = panel.dropLayers;

        if (dropLayers !== undefined) {
            destroyDropLayers(dropLayers);
            panel.manager.layerManager.layersChanged.dispatch();
            panel.dropLayers = undefined;
        }
    });
}
//# sourceMappingURL=layer_drag_and_drop.js.map