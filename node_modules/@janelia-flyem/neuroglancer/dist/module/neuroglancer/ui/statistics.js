import _toArray from 'babel-runtime/helpers/toArray';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _Array$from from 'babel-runtime/core-js/array/from';
import _Set from 'babel-runtime/core-js/set';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import _Map from 'babel-runtime/core-js/map';

import debounce from 'lodash/debounce'; /**
                                         * @license
                                         * Copyright 2019 Google Inc.
                                         * Licensed under the Apache License, Version 2.0 (the "License");
                                         * you may not use this file except in compliance with the License.
                                         * You may obtain a copy of the License at
                                         *
                                         *      http://www.apache.org/licenses/LICENSE-2.0
                                         *
                                         * Unless required by applicable law or agreed to in writing, software
                                         * distributed under the License is distributed on an "AS IS" BASIS,
                                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                         * See the License for the specific language governing permissions and
                                         * limitations under the License.
                                         */

import { ChunkDownloadStatistics, ChunkMemoryStatistics, ChunkPriorityTier, ChunkState, getChunkDownloadStatisticIndex, getChunkStateStatisticIndex, numChunkMemoryStatistics, numChunkStates } from '../chunk_manager/base';
import { TrackableSidePanelLocation } from './side_panel_location';
import { removeChildren } from '../util/dom';
import { emptyToUndefined } from '../util/json';
import { SidePanel } from './side_panel';
const DEFAULT_STATISTICS_PANEL_LOCATION = {
    side: 'bottom',
    size: 100,
    minSize: 50,
    row: 0,
    col: 0,
    flex: 1,
    visible: false
};
export class StatisticsDisplayState {
    constructor() {
        this.location = new TrackableSidePanelLocation(DEFAULT_STATISTICS_PANEL_LOCATION);
    }
    get changed() {
        return this.location.changed;
    }
    restoreState(obj) {
        this.location.restoreState(obj);
    }
    reset() {
        this.location.reset();
    }
    toJSON() {
        return emptyToUndefined(this.location.toJSON());
    }
}
function getProperties(obj) {
    const map = new _Map();
    function handleObject(o, prefix) {
        if (typeof o !== 'object') {
            map.set(prefix, '' + o);
            return;
        }
        for (const key of _Object$keys(o)) {
            handleObject(o[key], prefix + '.' + key);
        }
    }
    handleObject(obj, '');
    return map;
}
function getDistinguishingProperties(properties) {
    const selected = new _Set();
    selected.add('.type');
    const allProps = new _Set();
    function areDistinguished(i, j) {
        for (const prop of selected) {
            if (properties[i].get(prop) !== properties[j].get(prop)) {
                return true;
            }
        }
        return false;
    }
    for (let i = 0, n = properties.length; i < n; ++i) {
        for (const prop of properties[i].keys()) {
            allProps.add(prop);
        }
        let matches = [];
        for (let j = 0; j < i; ++j) {
            if (!areDistinguished(i, j)) {
                matches.push(j);
            }
        }
        while (matches.length > 0) {
            let bestReducedMatches = matches;
            let bestProp = undefined;
            for (const prop of allProps) {
                if (selected.has(prop)) continue;
                const reducedMatches = [];
                for (const j of matches) {
                    if (properties[j].get(prop) === properties[i].get(prop)) {
                        reducedMatches.push(j);
                    }
                }
                if (reducedMatches.length < bestReducedMatches.length) {
                    bestReducedMatches = reducedMatches;
                    bestProp = prop;
                }
                if (reducedMatches.length === 0) break;
            }
            // Prevent infinite loop if there are no distinguishing properties.
            if (bestProp === undefined) break;
            matches = bestReducedMatches;
            selected.add(bestProp);
        }
    }
    return _Array$from(selected);
}
function getNameFromProps(properties, selected) {
    const result = {};
    for (const prop of selected) {
        const value = properties.get(prop);
        if (value === undefined) continue;
        if (prop === '') return value;
        result[prop] = value;
    }
    return _JSON$stringify(result);
}
export function getChunkSourceIdentifier(source) {
    return _Object$assign({ type: source.RPC_TYPE_ID }, source.key || {});
}
export function getFormattedNames(objects) {
    const properties = objects.map(getProperties);
    const selectedProps = getDistinguishingProperties(properties);
    return properties.map(p => getNameFromProps(p, selectedProps));
}
/**
 * Interval in ms at which to request new statistics from the backend thread.
 */
const requestDataInterval = 1000;
export const columnSpecifications = [{
    label: 'Visible chunks/T',
    key: 'visibleChunksTotal',
    getter: statistics => {
        let sum = 0;
        for (let state = 0; state < numChunkStates; ++state) {
            sum += statistics[getChunkStateStatisticIndex(state, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks];
        }
        return sum;
    }
}, {
    label: 'Visible chunks/D',
    key: 'visibleChunksDownloading',
    getter: statistics => {
        return statistics[getChunkStateStatisticIndex(ChunkState.DOWNLOADING, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks];
    }
}, {
    label: 'Visible chunks/M',
    key: 'visibleChunksSystemMemory',
    getter: statistics => {
        return statistics[getChunkStateStatisticIndex(ChunkState.SYSTEM_MEMORY, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks] + statistics[getChunkStateStatisticIndex(ChunkState.SYSTEM_MEMORY_WORKER, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks];
    }
}, {
    label: 'Visible chunks/G',
    key: 'visibleChunksGpuMemory',
    getter: statistics => {
        return statistics[getChunkStateStatisticIndex(ChunkState.GPU_MEMORY, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks];
    }
}, {
    label: 'Visible chunks/F',
    key: 'visibleChunksFailed',
    getter: statistics => {
        return statistics[getChunkStateStatisticIndex(ChunkState.FAILED, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks];
    }
}, {
    label: 'Visible memory',
    key: 'visibleGpuMemory',
    getter: statistics => {
        return statistics[getChunkStateStatisticIndex(ChunkState.GPU_MEMORY, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.gpuMemoryBytes];
    }
}, {
    label: 'Download latency',
    key: 'downloadLatency',
    getter: statistics => {
        return statistics[getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalTime)] / statistics[getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalChunks)];
    }
}];
export class StatisticsPanel extends SidePanel {
    constructor(sidePanelManager, chunkQueueManager, displayState) {
        super(sidePanelManager, displayState.location);
        this.chunkQueueManager = chunkQueueManager;
        this.displayState = displayState;
        this.data = undefined;
        this.requestDataTimerId = -1;
        this.dataRequested = false;
        this.body = document.createElement('div');
        this.debouncedUpdateView = this.registerCancellable(debounce(() => this.updateView(), 0));
        const body = this.body;

        body.classList.add('neuroglancer-statistics-panel-body');
        this.addTitleBar({ title: 'Chunk statistics' });
        this.addBody(body);
        this.requestData();
    }
    disposed() {
        window.clearTimeout(this.requestDataTimerId);
        super.disposed();
    }
    requestData() {
        if (this.dataRequested) return;
        const chunkQueueManager = this.chunkQueueManager;

        this.dataRequested = true;
        chunkQueueManager.getStatistics().then(data => {
            this.dataRequested = false;
            this.data = data;
            this.debouncedUpdateView();
            this.requestDataTimerId = window.setTimeout(() => {
                this.requestDataTimerId = -1;
                this.requestData();
            }, requestDataInterval);
        });
    }
    updateView() {
        const data = this.data;

        if (data === undefined) return;
        const table = document.createElement('table');
        const rows = [];
        for (const _ref of data) {
            var _ref2 = _slicedToArray(_ref, 2);

            const source = _ref2[0];
            const statistics = _ref2[1];

            const row = [source];
            for (const _ref3 of columnSpecifications) {
                const getter = _ref3.getter;

                row.push(getter(statistics));
            }
            rows.push(row);
        }
        const formattedNames = getFormattedNames(rows.map(x => getChunkSourceIdentifier(x[0])));
        const sourceFormattedNames = new _Map();
        formattedNames.forEach((name, i) => {
            sourceFormattedNames.set(rows[i][0], name);
        });
        {
            const thead = document.createElement('thead');
            let tr = document.createElement('tr');
            thead.appendChild(tr);
            const addHeaderColumn = label => {
                const td = document.createElement('td');
                td.textContent = label;
                tr.appendChild(td);
            };
            addHeaderColumn('Name');
            let prevPrefix = undefined;
            for (const _ref4 of columnSpecifications) {
                const column = _ref4.label;

                const sepIndex = column.indexOf('/');
                let prefix = column;
                if (sepIndex !== -1) {
                    prefix = column.substring(0, sepIndex);
                    if (prefix === prevPrefix) {
                        ++tr.lastElementChild.colSpan;
                        continue;
                    }
                    prevPrefix = prefix;
                }
                addHeaderColumn(prefix);
            }
            tr = document.createElement('tr');
            thead.appendChild(tr);
            {
                const td = document.createElement('td');
                tr.appendChild(td);
            }
            for (const _ref5 of columnSpecifications) {
                const column = _ref5.label;

                const sepIndex = column.indexOf('/');
                let suffix = '';
                if (sepIndex !== -1) {
                    suffix = column.substring(sepIndex + 1);
                }
                const td = document.createElement('td');
                td.textContent = suffix;
                tr.appendChild(td);
            }
            table.appendChild(thead);
        }
        const tbody = document.createElement('tbody');
        // TODO: sort rows
        for (const _ref6 of rows) {
            var _ref7 = _toArray(_ref6);

            const source = _ref7[0];

            const values = _ref7.slice(1);

            const tr = document.createElement('tr');
            const addColumn = label => {
                const td = document.createElement('td');
                td.textContent = label;
                tr.appendChild(td);
            };
            addColumn(sourceFormattedNames.get(source));
            for (const value of values) {
                addColumn('' + value);
            }
            tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        removeChildren(this.body);
        this.body.appendChild(table);
    }
}
//# sourceMappingURL=statistics.js.map