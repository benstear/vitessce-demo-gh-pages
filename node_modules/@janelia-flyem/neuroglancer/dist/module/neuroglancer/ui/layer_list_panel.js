import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _Map from 'babel-runtime/core-js/map';
import _Object$assign from 'babel-runtime/core-js/object/assign';

import svg_controls_alt from 'ikonate/icons/controls-alt.svg'; /**
                                                                * @license
                                                                * Copyright 2021 Google Inc.
                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                * you may not use this file except in compliance with the License.
                                                                * You may obtain a copy of the License at
                                                                *
                                                                *      http://www.apache.org/licenses/LICENSE-2.0
                                                                *
                                                                * Unless required by applicable law or agreed to in writing, software
                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                * See the License for the specific language governing permissions and
                                                                * limitations under the License.
                                                                */

import svg_eye_crossed from 'ikonate/icons/eye-crossed.svg';
import svg_eye from 'ikonate/icons/eye.svg';
import { deleteLayer } from '../layer';
import { TrackableBooleanCheckbox } from '../trackable_boolean';
import { registerLayerBarDragLeaveHandler, registerLayerBarDropHandlers, registerLayerDragHandlers } from './layer_drag_and_drop';
import { LayerNameWidget } from './layer_side_panel';
import { SidePanel } from './side_panel';
import { DEFAULT_SIDE_PANEL_LOCATION, TrackableSidePanelLocation } from './side_panel_location';
import { animationFrameDebounce } from '../util/animation_frame_debounce';
import { RefCounted } from '../util/disposable';
import { updateChildren } from '../util/dom';
import { emptyToUndefined } from '../util/json';
import { makeDeleteButton } from '../widget/delete_button';
import { makeIcon } from '../widget/icon';
import { CheckboxIcon } from '../widget/checkbox_icon';
const DEFAULT_LAYER_LIST_PANEL_LOCATION = _Object$assign(_Object$assign({}, DEFAULT_SIDE_PANEL_LOCATION), { side: 'left', row: 0 });
export class LayerListPanelState {
    constructor() {
        this.location = new TrackableSidePanelLocation(DEFAULT_LAYER_LIST_PANEL_LOCATION);
    }
    get changed() {
        return this.location.changed;
    }
    restoreState(obj) {
        if (obj === undefined) return;
        this.location.restoreState(obj);
    }
    reset() {
        this.location.reset();
    }
    toJSON() {
        return emptyToUndefined(this.location.toJSON());
    }
}
class LayerVisibilityWidget extends RefCounted {
    constructor(layer) {
        super();
        this.layer = layer;
        this.element = document.createElement('div');
        const element = this.element;

        const hideIcon = makeIcon({
            svg: svg_eye,
            title: 'Hide layer',
            onClick: () => {
                this.layer.setVisible(false);
            }
        });
        const showIcon = makeIcon({
            svg: svg_eye_crossed,
            title: 'Show layer',
            onClick: () => {
                this.layer.setVisible(true);
            }
        });
        element.appendChild(showIcon);
        element.appendChild(hideIcon);
        const updateView = () => {
            const visible = this.layer.visible;
            hideIcon.style.display = visible ? '' : 'none';
            showIcon.style.display = !visible ? '' : 'none';
        };
        updateView();
        this.registerDisposer(layer.layerChanged.add(updateView));
    }
}
function makeSelectedLayerSidePanelCheckboxIcon(layer) {
    const selectedLayer = layer.manager.root.selectedLayer;

    const icon = new CheckboxIcon({
        get value() {
            return selectedLayer.layer === layer && selectedLayer.visible;
        },
        set value(value) {
            if (value) {
                selectedLayer.layer = layer;
                selectedLayer.visible = true;
            } else {
                selectedLayer.visible = false;
            }
        },
        changed: selectedLayer.changed
    }, {
        backgroundScheme: 'dark',
        enableTitle: 'Show layer side panel',
        disableTitle: 'Hide layer side panel',
        svg: svg_controls_alt
    });
    icon.element.classList.add('neuroglancer-layer-list-panel-item-controls');
    return icon;
}
class LayerListItem extends RefCounted {
    constructor(panel, layer) {
        super();
        this.panel = panel;
        this.layer = layer;
        this.element = document.createElement('div');
        this.numberElement = document.createElement('div');
        this.generation = -1;
        const element = this.element,
              numberElement = this.numberElement;

        element.classList.add('neuroglancer-layer-list-panel-item');
        numberElement.classList.add('neuroglancer-layer-list-panel-item-number');
        element.appendChild(this.registerDisposer(new TrackableBooleanCheckbox({
            get value() {
                return !layer.archived;
            },
            set value(value) {
                layer.setArchived(!value);
            },
            changed: layer.layerChanged
        }, {
            enableTitle: 'Archive layer (disable and remove from layer groups)',
            disableTitle: 'Unarchive layer (enable and add to all layer groups)'
        })).element);
        element.appendChild(numberElement);
        element.appendChild(this.registerDisposer(new LayerVisibilityWidget(layer)).element);
        element.appendChild(this.registerDisposer(new LayerNameWidget(layer)).element);
        element.appendChild(this.registerDisposer(makeSelectedLayerSidePanelCheckboxIcon(layer)).element);
        const deleteButton = makeDeleteButton({
            title: 'Delete layer',
            onClick: () => {
                deleteLayer(this.layer);
            }
        });
        deleteButton.classList.add('neuroglancer-layer-list-panel-item-delete');
        element.appendChild(deleteButton);
        registerLayerDragHandlers(panel, element, layer, { isLayerListPanel: true, getLayoutSpec: () => undefined });
        registerLayerBarDropHandlers(panel, element, layer, /*allowArchived=*/true);
        element.addEventListener('click', event => {
            if (event.ctrlKey) {
                panel.selectedLayer.toggle(layer);
                event.preventDefault();
            } else if (event.altKey) {
                layer.pickEnabled = !layer.pickEnabled;
                event.preventDefault();
            }
        });
        element.addEventListener('contextmenu', event => {
            panel.selectedLayer.toggle(layer);
            event.stopPropagation();
            event.preventDefault();
        });
    }
}
export class LayerListPanel extends SidePanel {
    constructor(sidePanelManager, manager, state) {
        super(sidePanelManager, state.location);
        this.manager = manager;
        this.state = state;
        this.items = new _Map();
        this.itemContainer = document.createElement('div');
        this.layerDropZone = document.createElement('div');
        this.dragEnterCount = 0;
        this.generation = -1;
        const itemContainer = this.itemContainer,
              layerDropZone = this.layerDropZone;

        var _addTitleBar = this.addTitleBar({ title: '' });

        const titleElement = _addTitleBar.titleElement;

        this.titleElement = titleElement;
        itemContainer.classList.add('neuroglancer-layer-list-panel-items');
        this.addBody(itemContainer);
        layerDropZone.style.flex = '1';
        const debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.render()));
        this.visibility.changed.add(debouncedUpdateView);
        this.registerDisposer(this.layerManager.layersChanged.add(debouncedUpdateView));
        this.registerDisposer(this.selectedLayer.changed.add(debouncedUpdateView));
        registerLayerBarDragLeaveHandler(this);
        registerLayerBarDropHandlers(this, layerDropZone, undefined, /*allowArchived=*/true);
        this.render();
    }
    get layerManager() {
        return this.manager.layerManager;
    }
    get selectedLayer() {
        return this.manager.selectedLayer;
    }
    render() {
        const self = this;
        const selectedLayer = this.selectedLayer.layer;
        const generation = ++this.generation;
        let numVisible = 0;
        let numHidden = 0;
        let numArchived = 0;
        this.layerManager.updateNonArchivedLayerIndices();
        function* getItems() {
            const items = self.items;

            let numNonArchivedLayers = 0;
            for (const layer of self.layerManager.managedLayers) {
                if (!layer.archived) ++numNonArchivedLayers;
            }
            const numberElementWidth = `${(numNonArchivedLayers + 1).toString().length}ch`;
            for (const layer of self.layerManager.managedLayers) {
                if (layer.visible) {
                    ++numVisible;
                } else if (!layer.archived) {
                    ++numHidden;
                } else {
                    ++numArchived;
                }
                let item = items.get(layer);
                if (item === undefined) {
                    item = self.registerDisposer(new LayerListItem(self, layer));
                    items.set(layer, item);
                    item.generation = generation;
                } else {
                    item.generation = generation;
                }
                const nonArchivedLayerIndex = layer.nonArchivedLayerIndex;

                item.numberElement.style.width = numberElementWidth;
                if (nonArchivedLayerIndex === -1) {
                    item.numberElement.style.visibility = 'hidden';
                } else {
                    item.numberElement.style.visibility = '';
                    item.numberElement.textContent = `${nonArchivedLayerIndex + 1}`;
                }
                item.element.dataset.selected = (layer === selectedLayer).toString();
                item.element.dataset.archived = layer.archived.toString();
                yield item.element;
            }
            for (const _ref of items) {
                var _ref2 = _slicedToArray(_ref, 2);

                const userLayer = _ref2[0];
                const item = _ref2[1];

                if (generation !== item.generation) {
                    items.delete(userLayer);
                    self.unregisterDisposer(item);
                    item.dispose();
                }
            }
            yield self.layerDropZone;
        }
        updateChildren(this.itemContainer, getItems());
        let title = 'Layers';
        if (numVisible || numHidden || numArchived) {
            title += ' (';
            let sep = '';
            if (numVisible + numHidden) {
                title += `${numVisible}/${numHidden + numVisible} visible`;
                sep = ', ';
            }
            if (numArchived) {
                title += `${sep}${numArchived} archived`;
            }
            title += ')';
        }
        this.titleElement.textContent = title;
    }
}
export class LayerArchiveCountWidget extends RefCounted {
    constructor(layerManager) {
        super();
        this.layerManager = layerManager;
        this.element = document.createElement('div');
        const debouncedRender = this.registerCancellable(animationFrameDebounce(() => this.render()));
        this.registerDisposer(layerManager.layersChanged.add(debouncedRender));
        this.render();
    }
    render() {
        let numArchived = 0;
        const managedLayers = this.layerManager.managedLayers;

        for (const layer of managedLayers) {
            if (layer.archived) ++numArchived;
        }
        const element = this.element;

        if (numArchived !== 0) {
            const numLayers = managedLayers.length;
            element.textContent = `${numLayers - numArchived}/${numLayers}`;
        } else {
            element.textContent = '';
        }
    }
}
//# sourceMappingURL=layer_list_panel.js.map