import _Map from 'babel-runtime/core-js/map';
import _Set from 'babel-runtime/core-js/set';
import _Array$from from 'babel-runtime/core-js/array/from';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { TrackableValue } from './trackable_value';
import { animationFrameDebounce } from './util/animation_frame_debounce';
import { RefCounted } from './util/disposable';
import { parseFixedLengthArray, verifyFloat01 } from './util/json';
import { NullarySignal } from './util/signal';
import { initializeWebGL } from './webgl/context';
export class RenderViewport {
    constructor() {
        // Width of visible portion of panel in canvas pixels.
        this.width = 0;
        // Height of visible portion of panel in canvas pixels.
        this.height = 0;
        // Width in canvas pixels, including portions outside of the canvas (i.e. outside the "viewport"
        // window).
        this.logicalWidth = 0;
        // Height in canvas pixels, including portions outside of the canvas (i.e. outside the "viewport"
        // window).
        this.logicalHeight = 0;
        // Left edge of visible region within full (logical) panel, as fraction in [0, 1].
        this.visibleLeftFraction = 0;
        // Top edge of visible region within full (logical) panel, as fraction in [0, 1].
        this.visibleTopFraction = 0;
        // Fraction of logical width that is visible, equal to `widthInCanvasPixels / logicalWidth`.
        this.visibleWidthFraction = 0;
        // Fraction of logical height that is visible, equal to `heightInCanvasPixels / logicalHeight`.
        this.visibleHeightFraction = 0;
    }
}
export function applyRenderViewportToProjectionMatrix(viewport, projectionMatrix) {
    const xScale = 1 / viewport.visibleWidthFraction;
    const yScale = 1 / viewport.visibleHeightFraction;
    const xOffset = -1 - (-1 + 2 * viewport.visibleLeftFraction) * xScale;
    let yOffset = -1 - (-1 + 2 * viewport.visibleTopFraction) * yScale;
    yOffset = -yOffset;
    projectionMatrix[0] = projectionMatrix[0] * xScale + projectionMatrix[3] * xOffset;
    projectionMatrix[4] = projectionMatrix[4] * xScale + projectionMatrix[7] * xOffset;
    projectionMatrix[8] = projectionMatrix[8] * xScale + projectionMatrix[11] * xOffset;
    projectionMatrix[12] = projectionMatrix[12] * xScale + projectionMatrix[15] * xOffset;
    projectionMatrix[1] = projectionMatrix[1] * yScale + projectionMatrix[3] * yOffset;
    projectionMatrix[5] = projectionMatrix[5] * yScale + projectionMatrix[7] * yOffset;
    projectionMatrix[9] = projectionMatrix[9] * yScale + projectionMatrix[11] * yOffset;
    projectionMatrix[13] = projectionMatrix[13] * yScale + projectionMatrix[15] * yOffset;
}
export function renderViewportsEqual(a, b) {
    return a.width === b.width && a.height === b.height && a.logicalWidth === b.logicalWidth && a.logicalHeight === b.logicalHeight && a.visibleLeftFraction === b.visibleLeftFraction && a.visibleTopFraction === b.visibleTopFraction;
}
export class RenderedPanel extends RefCounted {
    constructor(context, element, visibility) {
        super();
        this.context = context;
        this.element = element;
        this.visibility = visibility;
        // Generation used to check whether the following bounds-related fields are up to date.
        this.boundsGeneration = -1;
        // Offset of visible portion of panel in canvas pixels from left side of canvas.
        this.canvasRelativeClippedLeft = 0;
        // Offset of visible portion of panel in canvas pixels from top of canvas.
        this.canvasRelativeClippedTop = 0;
        this.canvasRelativeLogicalLeft = 0;
        this.canvasRelativeLogicalTop = 0;
        this.renderViewport = new RenderViewport();
        this.boundsObserversRegistered = false;
        this.gl = context.gl;
        context.addPanel(this);
    }
    scheduleRedraw() {
        if (this.visible) {
            this.context.scheduleRedraw();
        }
    }
    ensureBoundsUpdated() {
        const context = this.context;

        context.ensureBoundsUpdated();
        const boundsGeneration = context.boundsGeneration;

        if (boundsGeneration === this.boundsGeneration) return;
        this.boundsGeneration = boundsGeneration;
        const element = this.element;

        if (!this.boundsObserversRegistered && context.monitorPanel(element)) {
            this.boundsObserversRegistered = true;
        }
        const clientRect = element.getBoundingClientRect();
        const root = context.container;
        const canvasRect = context.canvasRect;
        const canvas = context.canvas;
        const canvasPixelWidth = canvas.width,
              canvasPixelHeight = canvas.height;

        const screenToCanvasPixelScaleX = canvasPixelWidth / canvasRect.width;
        const screenToCanvasPixelScaleY = canvasPixelHeight / canvasRect.height;
        // Logical bounding rectangle in canvas/WebGL pixels (which may be a different size than screen
        // pixels when using a fixed canvas size via the Python integration).
        const canvasLeft = canvasRect.left,
              canvasTop = canvasRect.top;
        let logicalLeft = this.canvasRelativeLogicalLeft = Math.round((clientRect.left - canvasLeft) * screenToCanvasPixelScaleX + element.clientLeft),
            logicalTop = this.canvasRelativeLogicalTop = Math.round((clientRect.top - canvasTop) * screenToCanvasPixelScaleY + element.clientTop),
            logicalWidth = element.clientWidth,
            logicalHeight = element.clientHeight,
            logicalRight = logicalLeft + logicalWidth,
            logicalBottom = logicalTop + logicalHeight;
        // Clipped bounding rectangle in canvas/WebGL pixels.  The clipped bounding rectangle is the
        // portion actually visible and overlapping the canvas.
        let clippedTop = logicalTop,
            clippedLeft = logicalLeft,
            clippedRight = logicalRight,
            clippedBottom = logicalBottom;
        for (let parent = element.parentElement; parent !== null && parent !== root; parent = parent.parentElement) {
            const rect = parent.getBoundingClientRect();
            if (rect.x === 0 && rect.y === 0 && rect.width === 0 && rect.height === 0) {
                // Assume this is a `display: contents;` element.
                continue;
            }
            clippedLeft = Math.max(clippedLeft, (rect.left - canvasLeft) * screenToCanvasPixelScaleX);
            clippedTop = Math.max(clippedTop, (rect.top - canvasTop) * screenToCanvasPixelScaleY);
            clippedRight = Math.min(clippedRight, (rect.right - canvasLeft) * screenToCanvasPixelScaleX);
            clippedBottom = Math.min(clippedBottom, (rect.bottom - canvasTop) * screenToCanvasPixelScaleY);
        }
        clippedTop = this.canvasRelativeClippedTop = Math.round(Math.max(clippedTop, 0));
        clippedLeft = this.canvasRelativeClippedLeft = Math.round(Math.max(clippedLeft, 0));
        clippedRight = Math.round(Math.min(clippedRight, canvasPixelWidth));
        clippedBottom = Math.round(Math.min(clippedBottom, canvasPixelHeight));
        const viewport = this.renderViewport;
        const clippedWidth = viewport.width = Math.max(0, clippedRight - clippedLeft);
        const clippedHeight = viewport.height = Math.max(0, clippedBottom - clippedTop);
        viewport.logicalWidth = logicalWidth;
        viewport.logicalHeight = logicalHeight;
        viewport.visibleLeftFraction = (clippedLeft - logicalLeft) / logicalWidth;
        viewport.visibleTopFraction = (clippedTop - logicalTop) / logicalHeight;
        viewport.visibleWidthFraction = clippedWidth / logicalWidth;
        viewport.visibleHeightFraction = clippedHeight / logicalHeight;
    }
    // Sets the viewport to the clipped viewport.  Any drawing must take
    // `visible{Left,Top,Width,Height}Fraction` into account.  setGLClippedViewport() {
    setGLClippedViewport() {
        const gl = this.gl,
              canvasRelativeClippedTop = this.canvasRelativeClippedTop,
              canvasRelativeClippedLeft = this.canvasRelativeClippedLeft;
        var _renderViewport = this.renderViewport;
        const width = _renderViewport.width,
              height = _renderViewport.height;

        const bottom = canvasRelativeClippedTop + height;
        gl.enable(WebGL2RenderingContext.SCISSOR_TEST);
        let glBottom = this.context.canvas.height - bottom;
        gl.viewport(canvasRelativeClippedLeft, glBottom, width, height);
        gl.scissor(canvasRelativeClippedLeft, glBottom, width, height);
    }
    // Sets the viewport to the logical viewport, using the scissor test to constrain drawing to the
    // clipped viewport.  Drawing does not need to take `visible{Left,Top,Width,Height}Fraction` into
    // account.
    setGLLogicalViewport() {
        const gl = this.gl;
        var _renderViewport2 = this.renderViewport;
        const width = _renderViewport2.width,
              height = _renderViewport2.height,
              logicalWidth = _renderViewport2.logicalWidth,
              logicalHeight = _renderViewport2.logicalHeight;

        const canvasHeight = this.context.canvas.height;
        gl.enable(WebGL2RenderingContext.SCISSOR_TEST);
        gl.viewport(this.canvasRelativeLogicalLeft, canvasHeight - (this.canvasRelativeLogicalTop + logicalHeight), logicalWidth, logicalHeight);
        gl.scissor(this.canvasRelativeClippedLeft, canvasHeight - (this.canvasRelativeClippedTop + height), width, height);
    }
    disposed() {
        if (this.boundsObserversRegistered) {
            this.context.unmonitorPanel(this.element);
        }
        this.context.removePanel(this);
        super.disposed();
    }
    get visible() {
        return this.visibility.visible;
    }
    getDepthArray() {
        return undefined;
    }
    get shouldDraw() {
        if (!this.visible) return false;
        const element = this.element;

        if (element.clientWidth === 0 || element.clientHeight === 0 || element.offsetWidth === 0 || element.offsetHeight === 0) {
            // Skip drawing if the panel has zero client area.
            return false;
        }
        return true;
    }
    // Returns a number that determine the order in which panels are drawn. This is used by CdfPanel
    // to ensure it is drawn after other panels that update the histogram.
    //
    // A higher number -> later draw.
    get drawOrder() {
        return 0;
    }
}
export class IndirectRenderedPanel extends RenderedPanel {
    constructor(context, element, visibility) {
        super(context, element, visibility);
        this.canvas = document.createElement('canvas');
        this.canvasRenderingContext = this.canvas.getContext('2d');
        const canvas = this.canvas;

        element.appendChild(canvas);
        element.style.position = 'relative';
        canvas.style.position = 'absolute';
        canvas.style.left = '0';
        canvas.style.right = '0';
        canvas.style.top = '0';
        canvas.style.bottom = '0';
    }
    draw() {
        this.drawIndirect();
        const renderViewport = this.renderViewport,
              canvas = this.canvas;
        const logicalWidth = renderViewport.logicalWidth,
              logicalHeight = renderViewport.logicalHeight;

        canvas.width = logicalWidth;
        canvas.height = logicalHeight;
        const canvasRenderingContext = this.canvasRenderingContext;

        canvasRenderingContext === null || canvasRenderingContext === void 0 ? void 0 : canvasRenderingContext.drawImage(this.context.canvas, this.canvasRelativeLogicalLeft, this.canvasRelativeLogicalTop, logicalWidth, logicalHeight, 0, 0, logicalWidth, logicalHeight);
    }
}
// Specifies a rectangular sub-region of the full viewer area to actually be rendered on the canvas.
// This is used by the Python integration to produce large screenshots by tiling multiple
// screenshots.
//
// The value is: `[left, top, width, height]` where all values are in [0, 1].
export class TrackableWindowedViewport extends TrackableValue {
    constructor() {
        super(Float64Array.of(0, 0, 1, 1), obj => parseFixedLengthArray(new Float64Array(4), obj, verifyFloat01));
    }
    toJSON() {
        const value = this.value;

        var _value = _slicedToArray(value, 4);

        const left = _value[0],
              top = _value[1],
              width = _value[2],
              height = _value[3];

        if (left === 0 && top == 0 && width === 1 && height === 1) return undefined;
        return _Array$from(value);
    }
}
export class DisplayContext extends RefCounted {
    constructor(container) {
        super();
        this.container = container;
        this.canvas = document.createElement('canvas');
        this.updateStarted = new NullarySignal();
        this.updateFinished = new NullarySignal();
        this.changed = this.updateFinished;
        this.panels = new _Set();
        this.resizeGeneration = 0;
        this.boundsGeneration = -1;
        // Panels ordered by `drawOrder`.  If length is 0, needs to be recomputed.
        this.orderedPanels = [];
        /**
         * Unique number of the next frame.  Incremented once each time a frame is drawn.
         */
        this.frameNumber = 0;
        this.panelAncestors = new _Map();
        this.resizeCallback = () => {
            ++this.resizeGeneration;
            this.scheduleRedraw();
        };
        this.resizeObserver = new ResizeObserver(this.resizeCallback);
        this.scheduleRedraw = this.registerCancellable(animationFrameDebounce(() => this.draw()));
        const canvas = this.canvas,
              resizeObserver = this.resizeObserver;

        container.style.position = 'relative';
        canvas.style.position = 'absolute';
        canvas.style.top = '0px';
        canvas.style.left = '0px';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.zIndex = '0';
        resizeObserver.observe(canvas);
        container.appendChild(canvas);
        this.registerEventListener(canvas, 'webglcontextlost', event => {
            console.log(`Lost WebGL context: ${event.statusMessage}`);
            // Wait for context to be regained.
            event.preventDefault();
        });
        this.registerEventListener(canvas, 'webglcontextrestored', () => {
            console.log('WebGL context restored');
            // Simply reload Neuroglancer.
            window.location.reload();
        });
        this.gl = initializeWebGL(canvas);
    }
    monitorPanel(element) {
        const panelAncestors = this.panelAncestors,
              root = this.container;

        if (!root.contains(element)) return false;
        while (element !== root) {
            let entry = panelAncestors.get(element);
            if (entry !== undefined) {
                ++entry.count;
                break;
            }
            const parent = element.parentElement;
            entry = { parent, count: 1 };
            panelAncestors.set(element, entry);
            element.addEventListener('scroll', this.resizeCallback, { capture: true });
            this.resizeObserver.observe(element);
            element = parent;
        }
        return true;
    }
    unmonitorPanel(element) {
        const panelAncestors = this.panelAncestors,
              root = this.container;

        while (element !== root) {
            const entry = panelAncestors.get(element);
            if (entry.count !== 1) {
                --entry.count;
                break;
            }
            element.removeEventListener('scroll', this.resizeCallback, { capture: true });
            this.resizeObserver.unobserve(element);
            panelAncestors.delete(element);
            element = entry.parent;
        }
    }
    applyWindowedViewportToElement(element, value) {
        // These values specify the position of the canvas relative to the viewer.  However, we will
        // actually leave the canvas in place (such that it still fills the browser window) and move
        // the viewer.
        var _value2 = _slicedToArray(value, 4);

        const left = _value2[0],
              top = _value2[1],
              width = _value2[2],
              height = _value2[3];

        const totalWidth = 1 / width;
        const totalHeight = 1 / height;
        element.style.position = 'absolute';
        element.style.top = `${-totalHeight * top * 100}%`;
        element.style.left = `${-totalWidth * left * 100}%`;
        element.style.width = `${totalWidth * 100}%`;
        element.style.height = `${totalHeight * 100}%`;
        ++this.resizeGeneration;
        this.scheduleRedraw();
    }
    isReady() {
        for (const panel of this.panels) {
            if (!panel.visible) {
                continue;
            }
            if (!panel.isReady()) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns a child element that overlays the canvas.
     */
    makeCanvasOverlayElement() {
        const element = document.createElement('div');
        element.style.position = 'absolute';
        element.style.top = '0px';
        element.style.left = '0px';
        element.style.width = '100%';
        element.style.height = '100%';
        element.style.zIndex = '2';
        this.container.appendChild(element);
        return element;
    }
    disposed() {
        this.orderedPanels.length = 0;
        this.resizeObserver.disconnect();
    }
    addPanel(panel) {
        this.panels.add(panel);
        this.orderedPanels.length = 0;
        ++this.resizeGeneration;
        this.scheduleRedraw();
    }
    removePanel(panel) {
        this.panels.delete(panel);
        this.orderedPanels.length = 0;
        ++this.resizeGeneration;
        this.scheduleRedraw();
    }
    ensureBoundsUpdated() {
        const resizeGeneration = this.resizeGeneration;

        if (this.boundsGeneration === resizeGeneration) return;
        const canvas = this.canvas;

        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        this.canvasRect = canvas.getBoundingClientRect();
        this.boundsGeneration = resizeGeneration;
    }
    draw() {
        ++this.frameNumber;
        this.updateStarted.dispatch();
        let gl = this.gl;
        this.ensureBoundsUpdated();
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        const orderedPanels = this.orderedPanels,
              panels = this.panels;

        if (orderedPanels.length !== panels.size) {
            orderedPanels.push(...panels);
            orderedPanels.sort((a, b) => a.drawOrder - b.drawOrder);
        }
        for (const panel of orderedPanels) {
            if (!panel.shouldDraw) continue;
            panel.ensureBoundsUpdated();
            const renderViewport = panel.renderViewport;

            if (renderViewport.width === 0 || renderViewport.height === 0) continue;
            panel.draw();
        }
        // Ensure the alpha buffer is set to 1.
        gl.disable(gl.SCISSOR_TEST);
        this.gl.clearColor(1.0, 1.0, 1.0, 1.0);
        this.gl.colorMask(false, false, false, true);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.gl.colorMask(true, true, true, true);
        this.updateFinished.dispatch();
    }
    getDepthArray() {
        var _canvas = this.canvas;
        const width = _canvas.width,
              height = _canvas.height;

        const depthArray = new Float32Array(width * height);
        for (const panel of this.panels) {
            if (!panel.shouldDraw) continue;
            const panelDepthArray = panel.getDepthArray();
            if (panelDepthArray === undefined) continue;
            const canvasRelativeClippedTop = panel.canvasRelativeClippedTop,
                  canvasRelativeClippedLeft = panel.canvasRelativeClippedLeft;
            var _panel$renderViewport = panel.renderViewport;
            const width = _panel$renderViewport.width,
                  height = _panel$renderViewport.height;

            for (let y = 0; y < height; ++y) {
                const panelDepthArrayOffset = (height - 1 - y) * width;
                depthArray.set(panelDepthArray.subarray(panelDepthArrayOffset, panelDepthArrayOffset + width), (canvasRelativeClippedTop + y) * width + canvasRelativeClippedLeft);
            }
        }
        return depthArray;
    }
}
//# sourceMappingURL=display_context.js.map