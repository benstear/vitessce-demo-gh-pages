import _Object$assign from "babel-runtime/core-js/object/assign";
import _Object$getOwnPropertySymbols from "babel-runtime/core-js/object/get-own-property-symbols";
import _Object$defineProperty from "babel-runtime/core-js/object/define-property";
import _Object$getOwnPropertyDescriptor from "babel-runtime/core-js/object/get-own-property-descriptor";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
var __rest = this && this.__rest || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof _Object$getOwnPropertySymbols === "function") for (var i = 0, p = _Object$getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
import debounce from 'lodash/debounce';
import { LayerChunkProgressInfo } from "./chunk_manager/base";
import { RenderViewport, renderViewportsEqual } from "./display_context";
import { ProjectionParameters, projectionParametersEqual } from "./projection_parameters";
import { get3dModelToDisplaySpaceMatrix } from "./render_coordinate_transform";
import { PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID, PROJECTION_PARAMETERS_RPC_ID } from "./render_layer_common";
import { WatchableSet } from "./trackable_value";
import { RefCounted } from "./util/disposable";
import { mat4 } from "./util/geom";
import { MessageList, MessageSeverity } from "./util/message_list";
import { NullarySignal, Signal } from "./util/signal";
import { VisibilityPriorityAggregator } from "./visibility_priority/frontend";
import { registerSharedObjectOwner, SharedObject } from "./worker_rpc";
export var RenderLayerRole;
(function (RenderLayerRole) {
    RenderLayerRole[RenderLayerRole["DATA"] = 0] = "DATA";
    RenderLayerRole[RenderLayerRole["ANNOTATION"] = 1] = "ANNOTATION";
    RenderLayerRole[RenderLayerRole["DEFAULT_ANNOTATION"] = 2] = "DEFAULT_ANNOTATION";
})(RenderLayerRole || (RenderLayerRole = {}));
export function allRenderLayerRoles() {
    return new WatchableSet([RenderLayerRole.DATA, RenderLayerRole.ANNOTATION, RenderLayerRole.DEFAULT_ANNOTATION]);
}
export class RenderLayer extends RefCounted {
    constructor() {
        super(...arguments);
        this.role = RenderLayerRole.DATA;
        this.messages = new MessageList();
        this.layerChanged = new NullarySignal();
        this.redrawNeeded = new NullarySignal();
        this.layerChunkProgressInfo = new LayerChunkProgressInfo();
    }
    handleAction(_action) {
        // Do nothing by default.
    }
    getValueAt(_x) {
        return undefined;
    }
    /**
     * Transform the stored pickedValue and offset associated with the retrieved pick ID into the
     * actual value.
     */
    transformPickedValue(pickState) {
        return pickState.pickedValue;
    }
    /**
     * Optionally updates the mouse state based on the retrived pick information.  This might snap the
     * 3-d position to the center of the picked point.
     */
    updateMouseState(_mouseState, _pickedValue, _pickedOffset, _data) {}
}
/**
 * Extends RenderLayer with functionality for tracking the number of panels in which the layer is
 * visible.
 */
export class VisibilityTrackedRenderLayer extends RenderLayer {
    constructor() {
        super(...arguments);
        this.visibility = new VisibilityPriorityAggregator();
    }
    attach(attachment) {
        attachment;
    }
}
export function update3dRenderLayerAttachment(transform, displayDimensionRenderInfo, attachment) {
    let state = attachment.state;

    if (state === undefined || state.transform !== transform || state.displayDimensionRenderInfo !== displayDimensionRenderInfo) {
        attachment.messages.clearMessages();
        state = attachment.state = { transform, displayDimensionRenderInfo, modelTransform: undefined };
        if (transform.error !== undefined) {
            attachment.messages.addMessage({ severity: MessageSeverity.error, message: transform.error });
            return undefined;
        }
        try {
            const modelTransform = mat4.create();
            get3dModelToDisplaySpaceMatrix(modelTransform, displayDimensionRenderInfo, transform);
            state.modelTransform = modelTransform;
        } catch (e) {
            attachment.messages.addMessage({ severity: MessageSeverity.error, message: e.message });
        }
    }
    return state.modelTransform;
}
export class DerivedProjectionParameters extends RefCounted {
    constructor(options) {
        super();
        this.renderViewport = new RenderViewport();
        this.changed = new Signal();
        var _options$parametersCo = options.parametersConstructor;
        const parametersConstructor = _options$parametersCo === undefined ? ProjectionParameters : _options$parametersCo,
              navigationState = options.navigationState,
              update = options.update;
        var _options$isEqual = options.isEqual;
        const isEqual = _options$isEqual === undefined ? projectionParametersEqual : _options$isEqual;

        this.oldValue_ = new parametersConstructor();
        this.value_ = new parametersConstructor();
        const performUpdate = () => {
            const oldValue_ = this.oldValue_,
                  value_ = this.value_;

            oldValue_.displayDimensionRenderInfo = navigationState.displayDimensionRenderInfo.value;
            _Object$assign(oldValue_, this.renderViewport);
            let globalPosition = oldValue_.globalPosition;

            const newGlobalPosition = navigationState.position.value;
            const rank = newGlobalPosition.length;
            if (globalPosition.length !== rank) {
                oldValue_.globalPosition = globalPosition = new Float32Array(rank);
            }
            globalPosition.set(newGlobalPosition);
            update(oldValue_, navigationState);
            if (isEqual(oldValue_, value_)) return;
            this.value_ = oldValue_;
            this.oldValue_ = value_;
            this.changed.dispatch(value_, oldValue_);
        };
        const debouncedUpdate = this.update = this.registerCancellable(debounce(performUpdate, 0));
        this.registerDisposer(navigationState.changed.add(debouncedUpdate));
        performUpdate();
    }
    setViewport(viewport) {
        if (renderViewportsEqual(viewport, this.renderViewport)) return;
        _Object$assign(this.renderViewport, viewport);
        this.update();
    }
    get value() {
        this.update.flush();
        return this.value_;
    }
}
let SharedProjectionParameters = class SharedProjectionParameters extends SharedObject {
    constructor(rpc, base, updateInterval = 10) {
        super();
        this.base = base;
        this.updateInterval = updateInterval;
        this.prevDisplayDimensionRenderInfo = undefined;
        this.update = this.registerCancellable(debounce((_oldValue, newValue) => {
            // Note: Because we are using debouce, we cannot rely on `_oldValue`, since
            // `DerivedProjectionParameters` reuses the objects.
            let valueUpdate;
            if (newValue.displayDimensionRenderInfo !== this.prevDisplayDimensionRenderInfo) {
                valueUpdate = newValue;
                this.prevDisplayDimensionRenderInfo = newValue.displayDimensionRenderInfo;
            } else {
                const displayDimensionRenderInfo = newValue.displayDimensionRenderInfo,
                      remainder = __rest(newValue, ["displayDimensionRenderInfo"]);
                valueUpdate = remainder;
            }
            this.rpc.invoke(PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID, { id: this.rpcId, value: valueUpdate });
        }, this.updateInterval));
        this.initializeCounterpart(rpc, { value: base.value });
        this.registerDisposer(base.changed.add(this.update));
    }
    flush() {
        this.update.flush();
    }
};
SharedProjectionParameters = __decorate([registerSharedObjectOwner(PROJECTION_PARAMETERS_RPC_ID)], SharedProjectionParameters);
export { SharedProjectionParameters };
//# sourceMappingURL=renderlayer.js.map