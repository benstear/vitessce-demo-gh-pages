{
  "version": 3,
  "sources": ["../src/index.jsx"],
  "sourcesContent": ["import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { AnnotationUserLayer } from \"@janelia-flyem/neuroglancer/dist/module/neuroglancer/annotation/user_layer\";\nimport { getObjectColor } from \"@janelia-flyem/neuroglancer/dist/module/neuroglancer/segmentation_display_state/frontend\";\nimport { SegmentationUserLayer } from \"@janelia-flyem/neuroglancer/dist/module/neuroglancer/segmentation_user_layer\";\nimport { serializeColor } from \"@janelia-flyem/neuroglancer/dist/module/neuroglancer/util/color\";\nimport { setupDefaultViewer } from \"@janelia-flyem/neuroglancer\";\nimport { Uint64 } from \"@janelia-flyem/neuroglancer/dist/module/neuroglancer/util/uint64\";\nimport { urlSafeParse } from \"@janelia-flyem/neuroglancer/dist/module/neuroglancer/util/json\";\nimport { encodeFragment } from '@janelia-flyem/neuroglancer/dist/module/neuroglancer/ui/url_hash_binding';\n\nconst viewersKeyed = {};\nlet viewerNoKey;\n\n// Adopted from neuroglancer/ui/url_hash_binding.ts\nexport function parseUrlHash(url) {\n  let state = null;\n\n  let s = url.replace(/^[^#]+/, '');\n  if (s === '' || s === '#' || s === '#!') {\n    s = '#!{}';\n  }\n\n  if (s.startsWith('#!+')) {\n    s = s.slice(3);\n    // Firefox always %-encodes the URL even if it is not typed that way.\n    s = decodeURIComponent(s);\n    state = urlSafeParse(s);\n  } else if (s.startsWith('#!')) {\n    s = s.slice(2);\n    s = decodeURIComponent(s);\n    state = urlSafeParse(s);\n  } else {\n    throw new Error(`URL hash is expected to be of the form \"#!{...}\" or \"#!+{...}\".`);\n  }\n\n  return state;\n}\n\nexport function getNeuroglancerViewerState(key) {\n  const v = key ? viewersKeyed[key] : viewerNoKey;\n  return v ? v.state.toJSON() : {};\n}\n\nexport function getNeuroglancerColor(idStr, key) {\n  try {\n    const id = Uint64.parseString(idStr);\n    const v = key ? viewersKeyed[key] : viewerNoKey;\n    if (v) {\n      // eslint-disable-next-line no-restricted-syntax\n      for (const layer of v.layerManager.managedLayers) {\n        if (layer.layer instanceof SegmentationUserLayer) {\n          const { displayState } = layer.layer;\n          const colorVec = getObjectColor(displayState, id);\n\n          // To get the true color, undo how getObjectColor() indicates hovering.\n          if (displayState.segmentSelectionState.isSelected(id)) {\n            for (let i = 0; i < 3; i += 1) {\n              colorVec[i] = (colorVec[i] - 0.5) / 0.5;\n            }\n          }\n\n          const colorStr = serializeColor(colorVec);\n          return colorStr;\n        }\n      }\n    }\n  } catch {\n    // suppress eslint no-empty\n  }\n  return '';\n}\n\nexport function closeSelectionTab(key) {\n  const v = key ? viewersKeyed[key] : viewerNoKey;\n  if (v && v.closeSelectionTab) {\n    v.closeSelectionTab();\n  }\n}\n\nexport function getLayerManager(key) {\n  const v = key ? viewersKeyed[key] : viewerNoKey;\n  if (v) {\n    return v.layerManager;\n  }\n  return undefined;\n}\n\nexport function getManagedLayer(key, name) {\n  const layerManager = getLayerManager(key);\n  if (layerManager) {\n    return layerManager.managedLayers.filter(layer => layer.name === name)[0];\n  }\n  return undefined;\n}\n\nexport function getAnnotationLayer(key, name) {\n  const layer = getManagedLayer(key, name);\n  if (layer && layer.layer instanceof AnnotationUserLayer) {\n    return layer.layer;\n  }\n  return undefined;\n}\n\nexport function getAnnotationSource(key, name) {\n  const layer = getAnnotationLayer(key, name);\n  /* eslint-disable-next-line no-underscore-dangle */\n  if (layer && layer.dataSources && layer.dataSources[0].loadState_) {\n    /* eslint-disable-next-line no-underscore-dangle */\n    const { dataSource } = layer.dataSources[0].loadState_;\n    if (dataSource) {\n      return dataSource.subsources[0].subsource.annotation;\n    }\n  }\n  return undefined;\n}\n\nexport function addLayerSignalRemover(key, name, remover) {\n  const layerManager = getLayerManager(key);\n  if (layerManager && name && remover) {\n    if (!layerManager.customSignalHandlerRemovers) {\n      layerManager.customSignalHandlerRemovers = {};\n    }\n    if (!layerManager.customSignalHandlerRemovers[name]) {\n      layerManager.customSignalHandlerRemovers[name] = [];\n    }\n\n    layerManager.customSignalHandlerRemovers[name].push(remover);\n  }\n}\n\nexport function unsubscribeLayersChangedSignals(layerManager, signalKey) {\n  if (layerManager) {\n    if (layerManager.customSignalHandlerRemovers) {\n      if (layerManager.customSignalHandlerRemovers[signalKey]) {\n        layerManager.customSignalHandlerRemovers[signalKey].forEach(remover => {\n          remover();\n        });\n        delete layerManager.customSignalHandlerRemovers[signalKey];\n      }\n    }\n  }\n}\n\nexport function configureLayersChangedSignals(key, layerConfig) {\n  const layerManager = getLayerManager(key);\n  if (layerManager) {\n    const { layerName } = layerConfig;\n    unsubscribeLayersChangedSignals(layerManager, layerName);\n    if (layerConfig.process) {\n      const recordRemover = (remover) => addLayerSignalRemover(undefined, layerName, remover);\n      recordRemover(\n        layerManager.layersChanged.add(() => {\n          const layer = getManagedLayer(undefined, layerName);\n          if (layer) {\n            layerConfig.process(layer);\n          }\n        }));\n      const layer = getManagedLayer(undefined, layerName);\n      if (layer) {\n        layerConfig.process(layer);\n      }\n\n      return () =>  {\n        if (layerConfig.cancel) {\n          layerConfig.cancel();\n        }\n        unsubscribeLayersChangedSignals(layerManager, layerName);\n      }\n    }\n  }\n  return layerConfig.cancel;\n}\n\nfunction configureAnnotationSource(source, props, recordRemover) {\n  if (source && !source.signalReady) {\n    if (props.onAnnotationAdded) {\n      recordRemover(source.childAdded.add((annotation) => {\n        props.onAnnotationAdded(annotation);\n      }));\n    }\n    if (props.onAnnotationDeleted) {\n      recordRemover(source.childDeleted.add((id) => {\n        props.onAnnotationDeleted(id);\n      }));\n    }\n    if (props.onAnnotationUpdated) {\n      recordRemover(source.childUpdated.add((annotation => {\n        props.onAnnotationUpdated(annotation);\n      })));\n    }\n    if (props.onAnnotationChanged && source.referencesChanged) {\n      recordRemover(source.referencesChanged.add(props.onAnnotationChanged));\n    }\n\n    source.signalReady = true;\n    recordRemover(() => {\n      source.signalReady = false;\n    });\n  }\n}\n\nfunction getLoadedDataSource(layer) {\n  /* eslint-disable-next-line no-underscore-dangle */\n  if (layer.dataSources && layer.dataSources.length > 0 && layer.dataSources[0].loadState_ && layer.dataSources[0].loadState_.dataSource) {\n    /* eslint-disable-next-line no-underscore-dangle */\n    return layer.dataSources[0].loadState_.dataSource;\n  }\n}\n\nfunction getAnnotationSourceFromLayer(layer) {\n  const dataSource = getLoadedDataSource(layer);\n  if (dataSource) {\n    return dataSource.subsources[0].subsource.annotation;\n  }\n}\n\nfunction configureAnnotationSourceChange(annotationLayer, props, recordRemover) {\n  const configure = () => {\n    const source = getAnnotationSourceFromLayer(annotationLayer);\n    if (source) {\n      configureAnnotationSource(source, props, recordRemover);\n    }\n  }\n\n  const sourceChanged = annotationLayer.dataSourcesChanged;\n  if (sourceChanged && !sourceChanged.signalReady) {\n    recordRemover(sourceChanged.add(configure));\n    sourceChanged.signalReady = true;\n    recordRemover(() => {\n      sourceChanged.signalReady = false;\n    });\n    configure();\n  }\n}\n\nexport function configureAnnotationLayer(layer, props, recordRemover) {\n  if (layer) {\n    layer.expectingExternalTable = true;\n    if (layer.selectedAnnotation && !layer.selectedAnnotation.changed.signalReady) {\n      if (props.onAnnotationSelectionChanged) {\n        recordRemover(layer.selectedAnnotation.changed.add(() => {\n          props.onAnnotationSelectionChanged(layer.selectedAnnotation.value);\n        }));\n        recordRemover(() => {\n          layer.selectedAnnotation.changed.signalReady = false;\n        });\n        layer.selectedAnnotation.changed.signalReady = true;\n      }\n    }\n    configureAnnotationSourceChange(layer, props, recordRemover);\n  }\n}\n\nexport function configureAnnotationLayerChanged(layer, props, recordRemover) {\n  if (!layer.layerChanged.signalReady) {\n    const remover = layer.layerChanged.add(() => {\n      configureAnnotationLayer(layer.layer, props, recordRemover);\n    });\n    layer.layerChanged.signalReady = true;\n    recordRemover(remover);\n    recordRemover(() => {\n      layer.layerChanged.signalReady = false;\n    });\n\n    configureAnnotationLayer(layer.layer, props, recordRemover);\n  }\n}\n\nexport function getAnnotationSelectionHost(key) {\n  const viewer = key ? viewersKeyed[key] : viewerNoKey;\n  if (viewer) {\n    if (viewer.selectionDetailsState) {\n      return 'viewer';\n    }\n    return 'layer';\n  }\n\n  return null;\n}\n\nexport function getSelectedAnnotationId(key, layerName) {\n  const viewer = key ? viewersKeyed[key] : viewerNoKey;\n  if (viewer) {\n    if (viewer.selectionDetailsState) { // New neurolgancer version\n      // v.selectionDetailsState.value.layers[0].layer.managedLayer.name\n      if (viewer.selectionDetailsState.value) {\n        const { layers } = viewer.selectionDetailsState.value;\n        if (layers) {\n          const layer = layers.find((_layer) => _layer.layer.managedLayer.name === layerName);\n          if (layer && layer.state) {\n            return layer.state.annotationId;\n          }\n        }\n      }\n    } else {\n      const layer = getAnnotationLayer(undefined, layerName);\n      if (layer && layer.selectedAnnotation && layer.selectedAnnotation.value) {\n        return layer.selectedAnnotation.value.id;\n      }\n    }\n  }\n\n  return null;\n}\n\nexport default class Neuroglancer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.ngContainer = React.createRef();\n    this.viewer = null;\n  }\n\n  componentDidMount() {\n    const {\n      perspectiveZoom,\n      viewerState,\n      brainMapsClientId,\n      eventBindingsToUpdate,\n      onViewerStateChanged,\n      callbacks,\n      ngServer,\n      key\n    } = this.props;\n    this.viewer = setupDefaultViewer({\n      brainMapsClientId,\n      target: this.ngContainer.current,\n      bundleRoot: \"/\"\n    });\n\n    this.setCallbacks(callbacks);\n\n    if (eventBindingsToUpdate) {\n      this.updateEventBindings(eventBindingsToUpdate);\n    }\n\n    this.viewer.expectingExternalUI = true;\n    if (ngServer) {\n      this.viewer.makeUrlFromState = (state) => {\n        const newState = { ...state };\n        if (state.layers) {\n          // Do not include clio annotation layers\n          newState.layers = state.layers.filter((layer) => {\n            if (layer.source) {\n              const sourceUrl = layer.source.url || layer.source;\n              if (typeof sourceUrl === 'string') {\n                return !sourceUrl.startsWith('clio://');\n              }\n            }\n            return true;\n          });\n        }\n        return `${ngServer}/#!${encodeFragment(JSON.stringify(newState))}`;\n      };\n    }\n    if (this.viewer.selectionDetailsState) {\n      this.viewer.selectionDetailsState.changed.add(this.selectionDetailsStateChanged);\n    }\n    this.viewer.layerManager.layersChanged.add(this.layersChanged);\n\n    if (viewerState) {\n      const newViewerState = viewerState;\n      if (newViewerState.projectionScale === null) {\n        delete newViewerState.projectionScale;\n      }\n      if (newViewerState.crossSectionScale === null) {\n        delete newViewerState.crossSectionScale;\n      }\n      if (newViewerState.projectionOrientation === null) {\n        delete newViewerState.projectionOrientation;\n      }\n      if (newViewerState.crossSectionOrientation === null) {\n        delete newViewerState.crossSectionOrientation;\n      }\n      this.viewer.state.restoreState(newViewerState);\n    } else {\n      this.viewer.state.restoreState({\n        layers: {\n          grayscale: {\n            type: \"image\",\n            source:\n              \"dvid://https://flyem.dvid.io/ab6e610d4fe140aba0e030645a1d7229/grayscalejpeg\"\n          },\n          segmentation: {\n            type: \"segmentation\",\n            source:\n              \"dvid://https://flyem.dvid.io/d925633ed0974da78e2bb5cf38d01f4d/segmentation\"\n          }\n        },\n        perspectiveZoom,\n        navigation: {\n          zoomFactor: 8\n        }\n      });\n    }\n\n    this.viewer.state.changed.add(() => {\n      if (onViewerStateChanged) {\n        try {\n          if (this.viewer.state.viewer.position) {\n            onViewerStateChanged(this.viewer.state.toJSON());\n          }\n        } catch (error) {\n          console.debug(error);\n        }\n      }\n    });\n\n    // Make the Neuroglancer viewer accessible from getNeuroglancerViewerState().\n    // That function can be used to synchronize an external Redux store with any\n    // state changes made internally by the viewer.\n    if (key) {\n      viewersKeyed[key] = this.viewer;\n    } else {\n      viewerNoKey = this.viewer;\n    }\n\n    // TODO: This is purely for debugging and we need to remove it.\n    window.viewer = this.viewer;\n  }\n\n  componentDidUpdate() {\n    // The restoreState() call clears the \"selected\" (hovered on) segment, which is needed\n    // by Neuroglancer's code to toggle segment visibilty on a mouse click.  To free the user\n    // from having to move the mouse before clicking, save the selected segment and restore\n    // it after restoreState().\n    const selectedSegments = {};\n    // eslint-disable-next-line no-restricted-syntax\n    for (const layer of this.viewer.layerManager.managedLayers) {\n      if (layer.layer instanceof SegmentationUserLayer) {\n        const { segmentSelectionState } = layer.layer.displayState;\n        selectedSegments[layer.name] = segmentSelectionState.selectedSegment;\n      }\n    }\n\n    const { viewerState } = this.props;\n    if (viewerState) {\n      let newViewerState = { ...viewerState };\n      let restoreStates = [() => {\n        this.viewer.state.restoreState(newViewerState)\n      }];\n      if (viewerState.projectionScale === null) {\n        delete newViewerState.projectionScale;\n        restoreStates.push(() => {\n          this.viewer.projectionScale.reset();\n        });\n      }\n      if (viewerState.crossSectionScale === null) {\n        delete newViewerState.crossSectionScale;\n      }\n      restoreStates.forEach(restore => restore());\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const layer of this.viewer.layerManager.managedLayers) {\n      if (layer.layer instanceof SegmentationUserLayer) {\n        const { segmentSelectionState } = layer.layer.displayState;\n        segmentSelectionState.set(selectedSegments[layer.name]);\n      }\n    }\n\n    // For some reason setting position to an empty array doesn't reset\n    // the position in the viewer. This should handle those cases by looking\n    // for the empty position array and calling the position reset function if\n    // found.\n    if ('position' in viewerState) {\n      if (Array.isArray(viewerState.position)) {\n        if (viewerState.position.length === 0) {\n          this.viewer.position.reset();\n        }\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    const { key } = this.props;\n    if (key) {\n      delete viewersKeyed[key];\n    } else {\n      viewerNoKey = undefined;\n    }\n  }\n\n  /* setCallbacks allows us to set a callback on a neuroglancer event\n   * each callback created should be in the format:\n   * [\n   *   {\n   *     name: 'unique-name',\n   *     event: 'the neuroglancer event to target, eg: click0, keyt',\n   *     function: (slice) => { slice.whatever }\n   *   },\n   *   {...}\n   * ]\n   *\n   */\n  setCallbacks(callbacks) {\n    callbacks.forEach(callback => {\n      this.viewer.bindCallback(callback.name, callback.function)\n      this.viewer.inputEventBindings.sliceView.set(callback.event, callback.name)\n    });\n  }\n\n  updateEventBindings = eventBindingsToUpdate => {\n    const root = this.viewer.inputEventBindings;\n\n    const traverse = current => {\n      const replace = (eaMap, event0, event1) => {\n        const action = eaMap.get(event0);\n        if (action) {\n          eaMap.delete(event0);\n          if (event1) {\n            eaMap.set(event1, action);\n          }\n        }\n      };\n\n      const eventActionMap = current.bindings;\n      eventBindingsToUpdate.forEach(oldNewBinding => {\n        const eventOldBase = Array.isArray(oldNewBinding)\n          ? oldNewBinding[0]\n          : oldNewBinding;\n\n        const eventOldA = `at:${eventOldBase}`;\n        const eventNewA = oldNewBinding[1]\n          ? `at:${oldNewBinding[1]}`\n          : undefined;\n        replace(eventActionMap, eventOldA, eventNewA);\n\n        const eventOldB = `bubble:${eventOldBase}`;\n        const eventNewB = oldNewBinding[1]\n          ? `bubble:${oldNewBinding[1]}`\n          : undefined;\n        replace(eventActionMap, eventOldB, eventNewB);\n      });\n\n      current.parents.forEach(parent => {\n        traverse(parent);\n      });\n    };\n\n    traverse(root.global);\n    traverse(root.perspectiveView);\n    traverse(root.sliceView);\n  };\n\n  selectionDetailsStateChanged = () => {\n    if (this.viewer) {\n      const { onSelectionDetailsStateChanged } = this.props;\n      if (onSelectionDetailsStateChanged) {\n        onSelectionDetailsStateChanged();\n      }\n    }\n  }\n\n  layersChanged = () => {\n    if (this.handlerRemovers) {\n      // If change handlers have been added already, call the function to remove each one,\n      // so there won't be duplicates when new handlers are added below.\n      this.handlerRemovers.forEach(remover => remover());\n    }\n\n    if (this.viewer) {\n      const { onSelectedChanged, onVisibleChanged } = this.props;\n      if (onSelectedChanged || onVisibleChanged) {\n        this.handlerRemovers = [];\n\n        // eslint-disable-next-line no-restricted-syntax\n        for (const layer of this.viewer.layerManager.managedLayers) {\n          if (layer.layer instanceof SegmentationUserLayer) {\n            const { segmentSelectionState } = layer.layer.displayState;\n            const { visibleSegments } = layer.layer.displayState.segmentationGroupState.value;\n            if (segmentSelectionState && onSelectedChanged) {\n              // Bind the layer so it will be an argument to the handler when called.\n              const selectedChanged = this.selectedChanged.bind(\n                undefined,\n                layer\n              );\n              const remover = segmentSelectionState.changed.add(\n                selectedChanged\n              );\n              this.handlerRemovers.push(remover);\n              layer.registerDisposer(remover);\n            }\n\n            if (visibleSegments && onVisibleChanged) {\n              const visibleChanged = this.visibleChanged.bind(undefined, layer);\n              const remover = visibleSegments.changed.add(visibleChanged);\n              this.handlerRemovers.push(remover);\n              layer.registerDisposer(remover);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  selectedChanged = layer => {\n    if (this.viewer) {\n      const { onSelectedChanged } = this.props;\n      if (onSelectedChanged) {\n        const { segmentSelectionState } = layer.layer.displayState;\n        if (segmentSelectionState) {\n          const segment = segmentSelectionState.hasSelectedSegment\n            ? segmentSelectionState.selectedSegment\n            : null;\n          onSelectedChanged(segment, layer);\n        }\n      }\n    }\n  };\n\n  visibleChanged = layer => {\n    if (this.viewer) {\n      const { onVisibleChanged } = this.props;\n      if (onVisibleChanged) {\n        const { visibleSegments } = layer.layer.displayState.segmentationGroupState.value;\n        if (visibleSegments) {\n          onVisibleChanged(visibleSegments, layer);\n        }\n      }\n    }\n  };\n\n  render() {\n    const { perspectiveZoom } = this.props;\n    return (\n      <div className=\"neuroglancer-container\" ref={this.ngContainer}>\n        <p>\n          Neuroglancer here with zoom {perspectiveZoom}\n        </p>\n      </div>\n    );\n  }\n}\n\nNeuroglancer.propTypes = {\n  perspectiveZoom: PropTypes.number,\n  viewerState: PropTypes.object,\n  brainMapsClientId: PropTypes.string,\n  key: PropTypes.string,\n\n  /**\n   * An array of event bindings to change in Neuroglancer.  The array format is as follows:\n   * [[old-event1, new-event1], [old-event2], old-event3]\n   * Here, `old-event1`'s will be unbound and its action will be re-bound to `new-event1`.\n   * The bindings for `old-event2` and `old-event3` will be removed.\n   * Neuroglancer has its own syntax for event descriptors, and here are some examples:\n   * 'keya', 'shift+keyb' 'control+keyc', 'digit4', 'space', 'arrowleft', 'comma', 'period',\n   * 'minus', 'equal', 'bracketleft'.\n   */\n  eventBindingsToUpdate: PropTypes.array,\n\n  /**\n   * A function of the form `(segment, layer) => {}`, called each time there is a change to\n   * the segment the user has \"selected\" (i.e., hovered over) in Neuroglancer.\n   * The `segment` argument will be a Neuroglancer `Uint64` with the ID of the now-selected\n   * segment, or `null` if no segment is now selected.\n   * The `layer` argument will be a Neuroglaner `ManagedUserLayer`, whose `layer` property\n   * will be a Neuroglancer `SegmentationUserLayer`.\n   */\n  onSelectedChanged: PropTypes.func,\n\n  /**\n   * A function of the form `(segments, layer) => {}`, called each time there is a change to\n   * the segments the user has designated as \"visible\" (i.e., double-clicked on) in Neuroglancer.\n   * The `segments` argument will be a Neuroglancer `Uint64Set` whose elements are `Uint64`\n   * instances for the IDs of the now-visible segments.\n   * The `layer` argument will be a Neuroglaner `ManagedUserLayer`, whose `layer` property\n   * will be a Neuroglancer `SegmentationUserLayer`.\n   */\n  onVisibleChanged: PropTypes.func,\n\n  /**\n   * A function of the form `() => {}` to respond to selection changes in the viewer.\n   */\n  onSelectionDetailsStateChanged: PropTypes.func,\n\n  callbacks: PropTypes.arrayOf(PropTypes.object),\n  ngServer: PropTypes.string,\n};\n\nNeuroglancer.defaultProps = {\n  perspectiveZoom: 20,\n  eventBindingsToUpdate: null,\n  brainMapsClientId: null,\n  viewerState: null,\n  onSelectedChanged: null,\n  onVisibleChanged: null,\n  onSelectionDetailsStateChanged: null,\n  key: null,\n  callbacks: [],\n  ngServer: null,\n};\n"],
  "mappings": "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",
  "names": ["layer"]
}
