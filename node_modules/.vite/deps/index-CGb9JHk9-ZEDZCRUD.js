import {
  $mt,
  BD,
  BR,
  DUn,
  FUn,
  GUn,
  Gre,
  Hmt,
  Ire,
  JUn,
  Mre,
  N2,
  Pmt,
  Ppt,
  TS,
  TUn,
  Vre,
  WP,
  WUn,
  Ws,
  Ymt,
  ZP,
  _Un,
  _re,
  aUn,
  bD,
  cUn,
  dUn,
  dwe,
  fre,
  gwe,
  jmt,
  lwe,
  mD,
  mR,
  pD,
  pR,
  qmt,
  rI,
  sUn,
  tBt,
  uwe,
  vS,
  wUn,
  x2,
  xUn,
  yD,
  zmt
} from "./chunk-HD4POB2Y.js";
import "./chunk-7TLMWTDQ.js";
import {
  require_react
} from "./chunk-DTS4TUJV.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/vitessce/dist/index-CGb9JHk9.js
var import_react = __toESM(require_react(), 1);
function iM(i, e) {
  for (var t = 0; t < e.length; t++) {
    const n = e[t];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const r in n)
        if (r !== "default" && !(r in i)) {
          const s = Object.getOwnPropertyDescriptor(n, r);
          s && Object.defineProperty(i, r, s.get ? s : {
            enumerable: true,
            get: () => n[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }));
}
var qf = {};
var rM = dUn();
var H = Ws(rM);
var tw = {};
var jf;
var nw;
function eT() {
  if (nw) return jf;
  nw = 1;
  var i = BD(), e = mR(), t = WP();
  return jf = function(n, r) {
    var s = (e.Object || {})[n] || Object[n], a = {};
    a[n] = r(s), i(i.S + i.F * t(function() {
      s(1);
    }), "Object", a);
  }, jf;
}
var iw;
function sM() {
  if (iw) return tw;
  iw = 1;
  var i = lwe(), e = _re();
  return eT()("keys", function() {
    return function(n) {
      return e(i(n));
    };
  }), tw;
}
var Jf;
var rw;
function aM() {
  return rw || (rw = 1, sM(), Jf = mR().Object.keys), Jf;
}
var Kf;
var sw;
function oM() {
  return sw || (sw = 1, Kf = { default: aM(), __esModule: true }), Kf;
}
var lM = oM();
var hn = Ws(lM);
var kd = {};
var Yf;
var aw;
function th() {
  if (aw) return Yf;
  aw = 1;
  var i = Ymt(), e = bD()("toStringTag"), t = i(/* @__PURE__ */ function() {
    return arguments;
  }()) == "Arguments", n = function(r, s) {
    try {
      return r[s];
    } catch {
    }
  };
  return Yf = function(r) {
    var s, a, l;
    return r === void 0 ? "Undefined" : r === null ? "Null" : typeof (a = n(s = Object(r), e)) == "string" ? a : t ? i(s) : (l = i(s)) == "Object" && typeof s.callee == "function" ? "Arguments" : l;
  }, Yf;
}
var Xf;
var ow;
function cM() {
  if (ow) return Xf;
  ow = 1;
  var i = th(), e = bD()("iterator"), t = gwe();
  return Xf = mR().isIterable = function(n) {
    var r = Object(n);
    return r[e] !== void 0 || "@@iterator" in r || t.hasOwnProperty(i(r));
  }, Xf;
}
var Zf;
var lw;
function dM() {
  return lw || (lw = 1, GUn(), wUn(), Zf = cM()), Zf;
}
var Qf;
var cw;
function uM() {
  return cw || (cw = 1, Qf = { default: dM(), __esModule: true }), Qf;
}
var ep;
var dw;
function sy() {
  if (dw) return ep;
  dw = 1;
  var i = th(), e = bD()("iterator"), t = gwe();
  return ep = mR().getIteratorMethod = function(n) {
    if (n != null) return n[e] || n["@@iterator"] || t[i(n)];
  }, ep;
}
var tp;
var uw;
function hM() {
  if (uw) return tp;
  uw = 1;
  var i = ZP(), e = sy();
  return tp = mR().getIterator = function(t) {
    var n = e(t);
    if (typeof n != "function") throw TypeError(t + " is not iterable!");
    return i(n.call(t));
  }, tp;
}
var np;
var hw;
function fM() {
  return hw || (hw = 1, GUn(), wUn(), np = hM()), np;
}
var ip;
var fw;
function tT() {
  return fw || (fw = 1, ip = { default: fM(), __esModule: true }), ip;
}
var pw;
function pM() {
  if (pw) return kd;
  pw = 1, kd.__esModule = true;
  var i = uM(), e = r(i), t = tT(), n = r(t);
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  return kd.default = /* @__PURE__ */ function() {
    function s(a, l) {
      var d = [], u = true, h = false, g = void 0;
      try {
        for (var v = (0, n.default)(a), y; !(u = (y = v.next()).done) && (d.push(y.value), !(l && d.length === l)); u = true)
          ;
      } catch (C) {
        h = true, g = C;
      } finally {
        try {
          !u && v.return && v.return();
        } finally {
          if (h) throw g;
        }
      }
      return d;
    }
    return function(a, l) {
      if (Array.isArray(a))
        return a;
      if ((0, e.default)(Object(a)))
        return s(a, l);
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    };
  }(), kd;
}
var gM = pM();
var de = Ws(gM);
var rp;
var gw;
function nh() {
  if (gw) return rp;
  gw = 1;
  var i = mD();
  return rp = function(e, t, n) {
    for (var r in t)
      n && e[r] ? e[r] = t[r] : i(e, r, t[r]);
    return e;
  }, rp;
}
var sp;
var mw;
function ih() {
  return mw || (mw = 1, sp = function(i, e, t, n) {
    if (!(i instanceof e) || n !== void 0 && n in i)
      throw TypeError(t + ": incorrect invocation!");
    return i;
  }), sp;
}
var ap = { exports: {} };
var op;
var vw;
function nT() {
  if (vw) return op;
  vw = 1;
  var i = ZP();
  return op = function(e, t, n, r) {
    try {
      return r ? t(i(n)[0], n[1]) : t(n);
    } catch (a) {
      var s = e.return;
      throw s !== void 0 && i(s.call(e)), a;
    }
  }, op;
}
var lp;
var yw;
function iT() {
  if (yw) return lp;
  yw = 1;
  var i = gwe(), e = bD()("iterator"), t = Array.prototype;
  return lp = function(n) {
    return n !== void 0 && (i.Array === n || t[e] === n);
  }, lp;
}
var Sw;
function Vo() {
  if (Sw) return ap.exports;
  Sw = 1;
  var i = Hmt(), e = nT(), t = iT(), n = ZP(), r = aUn(), s = sy(), a = {}, l = {}, d = ap.exports = function(u, h, g, v, y) {
    var C = y ? function() {
      return u;
    } : s(u), w = i(g, v, h ? 2 : 1), b = 0, E, T, I, R;
    if (typeof C != "function") throw TypeError(u + " is not iterable!");
    if (t(C)) {
      for (E = r(u.length); E > b; b++)
        if (R = h ? w(n(T = u[b])[0], T[1]) : w(u[b]), R === a || R === l) return R;
    } else for (I = C.call(u); !(T = I.next()).done; )
      if (R = e(I, w, T.value, h), R === a || R === l) return R;
  };
  return d.BREAK = a, d.RETURN = l, ap.exports;
}
var cp;
var bw;
function rT() {
  if (bw) return cp;
  bw = 1;
  var i = pR(), e = mR(), t = x2(), n = BR(), r = bD()("species");
  return cp = function(s) {
    var a = typeof e[s] == "function" ? e[s] : i[s];
    n && a && !a[r] && t.f(a, r, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  }, cp;
}
var dp;
var ww;
function ea() {
  if (ww) return dp;
  ww = 1;
  var i = pD();
  return dp = function(e, t) {
    if (!i(e) || e._t !== t) throw TypeError("Incompatible receiver, " + t + " required!");
    return e;
  }, dp;
}
var up;
var Cw;
function sT() {
  if (Cw) return up;
  Cw = 1;
  var i = x2().f, e = uwe(), t = nh(), n = Hmt(), r = ih(), s = Vo(), a = $mt(), l = xUn(), d = rT(), u = BR(), h = _Un().fastKey, g = ea(), v = u ? "_s" : "size", y = function(C, w) {
    var b = h(w), E;
    if (b !== "F") return C._i[b];
    for (E = C._f; E; E = E.n)
      if (E.k == w) return E;
  };
  return up = {
    getConstructor: function(C, w, b, E) {
      var T = C(function(I, R) {
        r(I, T, w, "_i"), I._t = w, I._i = e(null), I._f = void 0, I._l = void 0, I[v] = 0, R != null && s(R, b, I[E], I);
      });
      return t(T.prototype, {
        // 23.1.3.1 Map.prototype.clear()
        // 23.2.3.2 Set.prototype.clear()
        clear: function() {
          for (var R = g(this, w), P = R._i, L = R._f; L; L = L.n)
            L.r = true, L.p && (L.p = L.p.n = void 0), delete P[L.i];
          R._f = R._l = void 0, R[v] = 0;
        },
        // 23.1.3.3 Map.prototype.delete(key)
        // 23.2.3.4 Set.prototype.delete(value)
        delete: function(I) {
          var R = g(this, w), P = y(R, I);
          if (P) {
            var L = P.n, A = P.p;
            delete R._i[P.i], P.r = true, A && (A.n = L), L && (L.p = A), R._f == P && (R._f = L), R._l == P && (R._l = A), R[v]--;
          }
          return !!P;
        },
        // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
        // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
        forEach: function(R) {
          g(this, w);
          for (var P = n(R, arguments.length > 1 ? arguments[1] : void 0, 3), L; L = L ? L.n : this._f; )
            for (P(L.v, L.k, this); L && L.r; ) L = L.p;
        },
        // 23.1.3.7 Map.prototype.has(key)
        // 23.2.3.7 Set.prototype.has(value)
        has: function(R) {
          return !!y(g(this, w), R);
        }
      }), u && i(T.prototype, "size", {
        get: function() {
          return g(this, w)[v];
        }
      }), T;
    },
    def: function(C, w, b) {
      var E = y(C, w), T, I;
      return E ? E.v = b : (C._l = E = {
        i: I = h(w, true),
        // <- index
        k: w,
        // <- key
        v: b,
        // <- value
        p: T = C._l,
        // <- previous entry
        n: void 0,
        // <- next entry
        r: false
        // <- removed
      }, C._f || (C._f = E), T && (T.n = E), C[v]++, I !== "F" && (C._i[I] = E)), C;
    },
    getEntry: y,
    setStrong: function(C, w, b) {
      a(C, w, function(E, T) {
        this._t = g(E, w), this._k = T, this._l = void 0;
      }, function() {
        for (var E = this, T = E._k, I = E._l; I && I.r; ) I = I.p;
        return !E._t || !(E._l = I = I ? I.n : E._t._f) ? (E._t = void 0, l(1)) : T == "keys" ? l(0, I.k) : T == "values" ? l(0, I.v) : l(0, [I.k, I.v]);
      }, b ? "entries" : "values", !b, true), d(w);
    }
  }, up;
}
var hp;
var xw;
function mM() {
  if (xw) return hp;
  xw = 1;
  var i = pD(), e = DUn(), t = bD()("species");
  return hp = function(n) {
    var r;
    return e(n) && (r = n.constructor, typeof r == "function" && (r === Array || e(r.prototype)) && (r = void 0), i(r) && (r = r[t], r === null && (r = void 0))), r === void 0 ? Array : r;
  }, hp;
}
var fp;
var Ew;
function vM() {
  if (Ew) return fp;
  Ew = 1;
  var i = mM();
  return fp = function(e, t) {
    return new (i(e))(t);
  }, fp;
}
var pp;
var kw;
function ay() {
  if (kw) return pp;
  kw = 1;
  var i = Hmt(), e = zmt(), t = lwe(), n = aUn(), r = vM();
  return pp = function(s, a) {
    var l = s == 1, d = s == 2, u = s == 3, h = s == 4, g = s == 6, v = s == 5 || g, y = a || r;
    return function(C, w, b) {
      for (var E = t(C), T = e(E), I = i(w, b, 3), R = n(T.length), P = 0, L = l ? y(C, R) : d ? y(C, 0) : void 0, A, M; R > P; P++) if ((v || P in T) && (A = T[P], M = I(A, P, E), s)) {
        if (l) L[P] = M;
        else if (M) switch (s) {
          case 3:
            return true;
          // some
          case 5:
            return A;
          // find
          case 6:
            return P;
          // findIndex
          case 2:
            L.push(A);
        }
        else if (h) return false;
      }
      return g ? -1 : u || h ? h : L;
    };
  }, pp;
}
var gp;
var Tw;
function rh() {
  if (Tw) return gp;
  Tw = 1;
  var i = pR(), e = BD(), t = _Un(), n = WP(), r = mD(), s = nh(), a = Vo(), l = ih(), d = pD(), u = dwe(), h = x2().f, g = ay()(0), v = BR();
  return gp = function(y, C, w, b, E, T) {
    var I = i[y], R = I, P = E ? "set" : "add", L = R && R.prototype, A = {};
    return !v || typeof R != "function" || !(T || L.forEach && !n(function() {
      new R().entries().next();
    })) ? (R = b.getConstructor(C, y, E, P), s(R.prototype, w), t.NEED = true) : (R = C(function(M, O) {
      l(M, R, y, "_c"), M._c = new I(), O != null && a(O, E, M[P], M);
    }), g("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(M) {
      var O = M == "add" || M == "set";
      M in L && !(T && M == "clear") && r(R.prototype, M, function(F, q) {
        if (l(this, R, M), !O && T && !d(F)) return M == "get" ? void 0 : false;
        var U = this._c[M](F === 0 ? 0 : F, q);
        return O ? this : U;
      });
    }), T || h(R.prototype, "size", {
      get: function() {
        return this._c.size;
      }
    })), u(R, y), A[y] = R, e(e.G + e.W + e.F, A), T || b.setStrong(R, y, E), R;
  }, gp;
}
var mp;
var Lw;
function yM() {
  if (Lw) return mp;
  Lw = 1;
  var i = sT(), e = ea(), t = "Map";
  return mp = rh()(t, function(n) {
    return function() {
      return n(this, arguments.length > 0 ? arguments[0] : void 0);
    };
  }, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function(r) {
      var s = i.getEntry(e(this, t), r);
      return s && s.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function(r, s) {
      return i.def(e(this, t), r === 0 ? 0 : r, s);
    }
  }, i, true), mp;
}
var Dw = {};
var vp;
var Iw;
function SM() {
  if (Iw) return vp;
  Iw = 1;
  var i = Vo();
  return vp = function(e, t) {
    var n = [];
    return i(e, false, n.push, n, t), n;
  }, vp;
}
var yp;
var Pw;
function aT() {
  if (Pw) return yp;
  Pw = 1;
  var i = th(), e = SM();
  return yp = function(t) {
    return function() {
      if (i(this) != t) throw TypeError(t + "#toJSON isn't generic");
      return e(this);
    };
  }, yp;
}
var Rw;
function bM() {
  if (Rw) return Dw;
  Rw = 1;
  var i = BD();
  return i(i.P + i.R, "Map", { toJSON: aT()("Map") }), Dw;
}
var Aw = {};
var Sp;
var _w;
function sh() {
  if (_w) return Sp;
  _w = 1;
  var i = BD();
  return Sp = function(e) {
    i(i.S, e, { of: function() {
      for (var n = arguments.length, r = new Array(n); n--; ) r[n] = arguments[n];
      return new this(r);
    } });
  }, Sp;
}
var Mw;
function wM() {
  return Mw || (Mw = 1, sh()("Map")), Aw;
}
var Nw = {};
var bp;
var Ow;
function ah() {
  if (Ow) return bp;
  Ow = 1;
  var i = BD(), e = sUn(), t = Hmt(), n = Vo();
  return bp = function(r) {
    i(i.S, r, { from: function(a) {
      var l = arguments[1], d, u, h, g;
      return e(this), d = l !== void 0, d && e(l), a == null ? new this() : (u = [], d ? (h = 0, g = t(l, arguments[2], 2), n(a, false, function(v) {
        u.push(g(v, h++));
      })) : n(a, false, u.push, u), new this(u));
    } });
  }, bp;
}
var Vw;
function CM() {
  return Vw || (Vw = 1, ah()("Map")), Nw;
}
var wp;
var Bw;
function xM() {
  return Bw || (Bw = 1, wUn(), GUn(), yM(), bM(), wM(), CM(), wp = mR().Map), wp;
}
var Cp;
var Fw;
function EM() {
  return Fw || (Fw = 1, Cp = { default: xM(), __esModule: true }), Cp;
}
var kM = EM();
var he = Ws(kM);
var TM = TUn();
var qn = Ws(TM);
var Uw = {};
var xp;
var zw;
function LM() {
  if (zw) return xp;
  zw = 1;
  var i = x2(), e = Gre();
  return xp = function(t, n, r) {
    n in t ? i.f(t, n, e(0, r)) : t[n] = r;
  }, xp;
}
var Ep;
var $w;
function oT() {
  if ($w) return Ep;
  $w = 1;
  var i = bD()("iterator"), e = false;
  try {
    var t = [7][i]();
    t.return = function() {
      e = true;
    }, Array.from(t, function() {
      throw 2;
    });
  } catch {
  }
  return Ep = function(n, r) {
    if (!r && !e) return false;
    var s = false;
    try {
      var a = [7], l = a[i]();
      l.next = function() {
        return { done: s = true };
      }, a[i] = function() {
        return l;
      }, n(a);
    } catch {
    }
    return s;
  }, Ep;
}
var Gw;
function DM() {
  if (Gw) return Uw;
  Gw = 1;
  var i = Hmt(), e = BD(), t = lwe(), n = nT(), r = iT(), s = aUn(), a = LM(), l = sy();
  return e(e.S + e.F * !oT()(function(d) {
    Array.from(d);
  }), "Array", {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function(u) {
      var h = t(u), g = typeof this == "function" ? this : Array, v = arguments.length, y = v > 1 ? arguments[1] : void 0, C = y !== void 0, w = 0, b = l(h), E, T, I, R;
      if (C && (y = i(y, v > 2 ? arguments[2] : void 0, 2)), b != null && !(g == Array && r(b)))
        for (R = b.call(h), T = new g(); !(I = R.next()).done; w++)
          a(T, w, C ? n(R, y, [I.value, w], true) : I.value);
      else
        for (E = s(h.length), T = new g(E); E > w; w++)
          a(T, w, C ? y(h[w], w) : h[w]);
      return T.length = w, T;
    }
  }), Uw;
}
var kp;
var Ww;
function IM() {
  return Ww || (Ww = 1, wUn(), DM(), kp = mR().Array.from), kp;
}
var Tp;
var Hw;
function lT() {
  return Hw || (Hw = 1, Tp = { default: IM(), __esModule: true }), Tp;
}
var PM = lT();
var _e = Ws(PM);
var Lp;
var qw;
function RM() {
  if (qw) return Lp;
  qw = 1;
  var i = sT(), e = ea(), t = "Set";
  return Lp = rh()(t, function(n) {
    return function() {
      return n(this, arguments.length > 0 ? arguments[0] : void 0);
    };
  }, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function(r) {
      return i.def(e(this, t), r = r === 0 ? 0 : r, r);
    }
  }, i), Lp;
}
var jw = {};
var Jw;
function AM() {
  if (Jw) return jw;
  Jw = 1;
  var i = BD();
  return i(i.P + i.R, "Set", { toJSON: aT()("Set") }), jw;
}
var Kw = {};
var Yw;
function _M() {
  return Yw || (Yw = 1, sh()("Set")), Kw;
}
var Xw = {};
var Zw;
function MM() {
  return Zw || (Zw = 1, ah()("Set")), Xw;
}
var Dp;
var Qw;
function NM() {
  return Qw || (Qw = 1, wUn(), GUn(), RM(), AM(), _M(), MM(), Dp = mR().Set), Dp;
}
var Ip;
var eC;
function OM() {
  return eC || (eC = 1, Ip = { default: NM(), __esModule: true }), Ip;
}
var VM = OM();
var Ye = Ws(VM);
var Pp;
var tC;
function BM() {
  if (tC) return Pp;
  tC = 1;
  var i = mR(), e = i.JSON || (i.JSON = { stringify: JSON.stringify });
  return Pp = function(n) {
    return e.stringify.apply(e, arguments);
  }, Pp;
}
var Rp;
var nC;
function FM() {
  return nC || (nC = 1, Rp = { default: BM(), __esModule: true }), Rp;
}
var UM = FM();
var oe = Ws(UM);
function cT(i, e) {
  let t = i.length, n = 0;
  for (let r = 0; r < t; ++r)
    e(i[r], r, i) && (i[n] = i[r], ++n);
  i.length = n;
}
function zM(i, e) {
  if (i.length === e)
    return i;
  let t = new i.constructor(e);
  return t.set(i), t;
}
function ym(i, e, t, n) {
  const r = i.length / e, s = i.length * t * n, a = new i.constructor(s), l = i.length * n, d = e, u = e * n;
  for (let h = 0; h < r; ++h)
    for (let g = 0; g < e; ++g) {
      const v = i[h * e + g], y = h * u + g;
      for (let C = 0; C < t; ++C)
        for (let w = 0; w < n; ++w)
          a[C * l + w * d + y] = v;
    }
  return a;
}
function $M(i, e, t, n = 0, r = i.length) {
  for (; n < r; ) {
    const s = n + r - 1 >> 1, a = t(e, i[s]);
    if (a > 0)
      n = s + 1;
    else if (a < 0)
      r = s;
    else
      return s;
  }
  return ~n;
}
function GM(i, e, t) {
  let n = e - i;
  for (; n > 0; ) {
    let r = Math.floor(n / 2), s = i + r;
    t(s) ? n = r : (i = s + 1, n -= r + 1);
  }
  return i;
}
function WM(i, e) {
  const t = [];
  for (let n = 0, r = i.length; n < r; ++n)
    i[n] === e && t.push(n);
  return t;
}
function He(i, e) {
  const t = i.length;
  if (e.length !== t) return false;
  for (let n = 0; n < t; ++n)
    if (i[n] !== e[n]) return false;
  return true;
}
function Sm(i, e, t = (n, r) => n === r) {
  const n = i.length;
  if (e.length !== n) return false;
  for (let r = 0; r < n; ++r)
    if (!t(i[r], e[r])) return false;
  return true;
}
function HM(i, e, t) {
  const n = [];
  if (t === e) {
    for (let r = 0; r < i; ++r)
      n[r] = r;
    return n;
  }
  n[t] = e;
  for (let r = 0, s = 0; r < i; ) {
    if (r === e) {
      ++r;
      continue;
    }
    s === t && ++s, n[s++] = r++;
  }
  return n;
}
function iC(i, e, t) {
  for (let n = 0, r = t.length; n < r; ++n) {
    const s = t[n];
    s !== -1 && (i[n] = e[s]);
  }
  return i;
}
function yc(i) {
  const e = [];
  for (let t = 0, n = i.length; t < n; ++t) {
    const r = i[t];
    for (let s = 0, a = r.length; s < a; ++s) {
      let l = e[s];
      l === void 0 && (l = e[s] = []), l.push(r[s]);
    }
  }
  return e;
}
function qM(i, e) {
  const t = [];
  let n = 0;
  for (let a = 0, l = e.length; a < l; ++a) {
    var r = e[a];
    const d = r.retainCount, u = r.deleteCount, h = r.insertCount;
    d !== 0 && (t.push(i.slice(n, n + d)), n += d), n += u, h !== 0 && t.push(new Array(h));
  }
  const s = i.length;
  return n !== s && t.push(i.slice(n)), new Array(0).concat(...t);
}
function jM(i, e, t) {
  const n = [];
  let r = 0, s = 0, a = i.length, l = e.length;
  for (; r < a && s < l; ) {
    let d, u = i[r], h = e[s];
    if (d = t(u, h), d === 0) {
      let g = 1;
      for (++r, ++s; r < a && s < l && (d = t(i[r], e[s])) === 0; )
        ++g, ++r, ++s;
      n.push({ retainCount: g, deleteCount: 0, insertCount: 0 });
      continue;
    }
    if (d < 0) {
      let g = 1;
      for (; ++r < a && (d = t(i[r], h)) < 0; )
        ++g;
      n.push({ retainCount: 0, deleteCount: g, insertCount: 0 });
      continue;
    }
    if (d > 0) {
      let g = 1;
      for (; ++s < l && (d = t(u, e[s])) > 0; )
        ++g;
      n.push({ retainCount: 0, deleteCount: 0, insertCount: g });
      continue;
    }
  }
  return (r < a || s < l) && n.push({ retainCount: 0, deleteCount: a - r, insertCount: l - s }), n;
}
function JM(i, e, t, n, r, s) {
  let a = 0, l = 0;
  if (i !== 0 && e !== 0)
    for (; ; ) {
      const d = t(a, l);
      if (d < 0) {
        if (n(a), ++a === i) break;
      } else if (d > 0) {
        if (r(l), ++l === e) break;
      } else if (s(a, l), ++a, ++l, a === i || l === e) break;
    }
  for (; a < i; )
    n(a), ++a;
  for (; l < e; )
    r(l), ++l;
}
var KM = tT();
var oy = Ws(KM);
var Ap;
var rC;
function YM() {
  if (rC) return Ap;
  rC = 1;
  var i = TS(), e = function() {
    return i.Date.now();
  };
  return Ap = e, Ap;
}
var _p;
var sC;
function XM() {
  if (sC) return _p;
  sC = 1;
  var i = /\s/;
  function e(t) {
    for (var n = t.length; n-- && i.test(t.charAt(n)); )
      ;
    return n;
  }
  return _p = e, _p;
}
var Mp;
var aC;
function ZM() {
  if (aC) return Mp;
  aC = 1;
  var i = XM(), e = /^\s+/;
  function t(n) {
    return n && n.slice(0, i(n) + 1).replace(e, "");
  }
  return Mp = t, Mp;
}
var Np;
var oC;
function QM() {
  if (oC) return Np;
  oC = 1;
  var i = Ire(), e = fre(), t = "[object Symbol]";
  function n(r) {
    return typeof r == "symbol" || e(r) && i(r) == t;
  }
  return Np = n, Np;
}
var Op;
var lC;
function eN() {
  if (lC) return Op;
  lC = 1;
  var i = ZM(), e = Ppt(), t = QM(), n = NaN, r = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, a = /^0o[0-7]+$/i, l = parseInt;
  function d(u) {
    if (typeof u == "number")
      return u;
    if (t(u))
      return n;
    if (e(u)) {
      var h = typeof u.valueOf == "function" ? u.valueOf() : u;
      u = e(h) ? h + "" : h;
    }
    if (typeof u != "string")
      return u === 0 ? u : +u;
    u = i(u);
    var g = s.test(u);
    return g || a.test(u) ? l(u.slice(2), g ? 2 : 8) : r.test(u) ? n : +u;
  }
  return Op = d, Op;
}
var Vp;
var cC;
function dT() {
  if (cC) return Vp;
  cC = 1;
  var i = Ppt(), e = YM(), t = eN(), n = "Expected a function", r = Math.max, s = Math.min;
  function a(l, d, u) {
    var h, g, v, y, C, w, b = 0, E = false, T = false, I = true;
    if (typeof l != "function")
      throw new TypeError(n);
    d = t(d) || 0, i(u) && (E = !!u.leading, T = "maxWait" in u, v = T ? r(t(u.maxWait) || 0, d) : v, I = "trailing" in u ? !!u.trailing : I);
    function R(V) {
      var $ = h, B = g;
      return h = g = void 0, b = V, y = l.apply(B, $), y;
    }
    function P(V) {
      return b = V, C = setTimeout(M, d), E ? R(V) : y;
    }
    function L(V) {
      var $ = V - w, B = V - b, ue = d - $;
      return T ? s(ue, v - B) : ue;
    }
    function A(V) {
      var $ = V - w, B = V - b;
      return w === void 0 || $ >= d || $ < 0 || T && B >= v;
    }
    function M() {
      var V = e();
      if (A(V))
        return O(V);
      C = setTimeout(M, L(V));
    }
    function O(V) {
      return C = void 0, I && h ? R(V) : (h = g = void 0, y);
    }
    function F() {
      C !== void 0 && clearTimeout(C), b = 0, h = w = g = C = void 0;
    }
    function q() {
      return C === void 0 ? y : O(e());
    }
    function U() {
      var V = e(), $ = A(V);
      if (h = arguments, g = this, w = V, $) {
        if (C === void 0)
          return P(w);
        if (T)
          return clearTimeout(C), C = setTimeout(M, d), R(w);
      }
      return C === void 0 && (C = setTimeout(M, d)), y;
    }
    return U.cancel = F, U.flush = q, U;
  }
  return Vp = a, Vp;
}
var tN = dT();
var dt = Ws(tN);
function uT(i) {
  typeof i == "object" ? i.dispose() : i();
}
function ho(i) {
  for (let e = i.length; e > 0; --e)
    uT(i[e - 1]);
}
function Oi(i, e, t, n) {
  return i.addEventListener(e, t, n), () => i.removeEventListener(e, t, n);
}
var X = class {
  constructor() {
    this.refCount = 1;
  }
  addRef() {
    return ++this.refCount, this;
  }
  dispose() {
    --this.refCount === 0 && this.refCountReachedZero();
  }
  refCountReachedZero() {
    this.disposed();
    let e = this.disposers;
    e !== void 0 && (ho(e), this.disposers = void 0), this.wasDisposed = true;
  }
  disposed() {
  }
  registerDisposer(e) {
    let t = this.disposers;
    return t == null ? this.disposers = [e] : t.push(e), e;
  }
  unregisterDisposer(e) {
    let t = this.disposers;
    if (t != null) {
      let n = t.indexOf(e);
      n !== -1 && t.splice(n, 1);
    }
    return e;
  }
  registerEventListener(e, t, n, r) {
    this.registerDisposer(Oi(e, t, n, r));
  }
  registerCancellable(e) {
    return this.registerDisposer(() => {
      e.cancel();
    }), e;
  }
};
var hT = class extends X {
  constructor(e) {
    super(), this.value = e;
  }
};
function fT(i) {
  return () => {
    if (i !== void 0) {
      let e = i;
      i = void 0, uT(e);
    }
  };
}
var ct = class {
  constructor() {
    this.handlers = new Ye(), this.count = 0;
    const e = this;
    this.dispatch = function() {
      ++e.count, e.handlers.forEach((t) => {
        t.apply(this, arguments);
      });
    };
  }
  /**
   * Add a handler function.  If `dispatch` is currently be called, then the new handler will be
   * called before `dispatch` returns.
   *
   * @param handler The handler function to add.
   *
   * @return A function that unregisters the handler.
   */
  add(e) {
    return this.handlers.add(e), () => this.remove(e);
  }
  /**
   * Remove a handler function.  If `dispatch` is currently be called and the new handler has not
   * yet been called, then it will not be called.
   *
   * @param handler Handler to remove.
   * @return `true` if the handler was present, `false` otherwise.
   */
  remove(e) {
    return this.handlers.delete(e);
  }
  /**
   * Disposes of resources.  No methods, including `dispatch`, may be invoked afterwards.
   */
  dispose() {
    this.handlers = void 0;
  }
};
var Le = class extends ct {
};
var pT = {
  count: 0,
  add(i) {
    return () => {
    };
  },
  remove(i) {
    return false;
  }
};
var vt = class {
  constructor(e) {
    this.value_ = e, this.changed = new Le();
  }
  get value() {
    return this.value_;
  }
  set value(e) {
    e !== this.value_ && (this.value_ = e, this.changed.dispatch());
  }
};
var fn = class extends vt {
  constructor(e, t, n = e) {
    super(e), this.validator = t, this.defaultValue = n;
  }
  toJSON() {
    if (this.value_ !== this.defaultValue)
      return this.value_;
  }
  reset() {
    this.value = this.defaultValue;
  }
  restoreState(e) {
    if (e !== void 0) {
      let t = this.validator;
      try {
        this.value = t(e);
        return;
      } catch {
      }
    }
    this.value = this.defaultValue;
  }
};
var gT = class extends X {
  constructor(e, t) {
    super(), this.changed = new Le(), this.f = e, this.ws = t;
    for (const n of t)
      this.registerDisposer(n.changed.add(this.changed.dispatch));
  }
  get value() {
    return this.f(...this.ws.map((e) => e.value));
  }
};
function dC(i, ...e) {
  return new gT(i, e);
}
var nN = class extends X {
  constructor(e, t) {
    super(), this.changed = new Le(), this.valueGeneration = -1, this.f = e, this.ws = t;
    for (const n of t)
      this.registerDisposer(n.changed.add(this.changed.dispatch));
  }
  get value() {
    const e = this.changed.count;
    return e !== this.valueGeneration && (this.value_ = this.f(...this.ws.map((t) => t.value)), this.valueGeneration = e), this.value_;
  }
};
function nr(i, ...e) {
  return new nN(i, e);
}
var mT = class extends X {
  constructor(e, t = (n, r) => n === r) {
    super(), this.changed = new ct(), this.value = e.value, this.registerDisposer(e.changed.add(() => {
      const n = e.value;
      t(this.value, n) || (this.value = n, this.changed.dispatch());
    }));
  }
};
function wi(i, e, t) {
  const n = new gT(i, e), r = new mT(n, t);
  return r.registerDisposer(n), r;
}
var vT = class extends X {
  constructor(e) {
    super(), this.changed = new Le();
    const t = e(this), n = hn(t), r = () => {
      const s = Array.isArray(t) ? [] : {};
      for (const a of n)
        s[a] = t[a].value;
      this.value = s, this.changed.dispatch();
    };
    r();
    for (const s of n) {
      const a = t[s];
      this.registerDisposer(a.changed.add(() => r()));
    }
  }
};
var iN = class {
  constructor(e) {
    this.changed = new Le(), e === void 0 ? this.values = new Ye() : this.values = new Ye(e);
  }
  add(e) {
    const t = this.values;
    return t.has(e) || (t.add(e), this.changed.dispatch()), this;
  }
  delete(e) {
    return this.values.delete(e) ? (this.changed.dispatch(), true) : false;
  }
  has(e) {
    return this.values.has(e);
  }
  get size() {
    return this.values.size;
  }
  [qn]() {
    return oy(this.values);
  }
  clear() {
    const e = this.values;
    e.size > 0 && (e.clear(), this.changed.dispatch());
  }
};
function Or(i, ...e) {
  let t = e.map((d) => d.value);
  const n = e.length;
  let r = new X(), s = i(r, ...t);
  const a = dt(() => {
    let d = false;
    for (let u = 0; u < n; ++u) {
      const g = e[u].value;
      t[u] !== g && (t[u] = g, d = true);
    }
    d && (r.dispose(), r = new X(), s = i(r, ...t));
  }, 0), l = e.map((d) => d.changed.add(a));
  return {
    flush() {
      a.flush();
    },
    dispose() {
      a.cancel(), ho(l), r.dispose();
    },
    get value() {
      return a.flush(), s;
    }
  };
}
function fo(i, ...e) {
  let t = e.map((d) => d.value);
  const n = e.length;
  let r = new X(), s = i(r, ...t);
  const a = () => {
    let d = false;
    for (let u = 0; u < n; ++u) {
      const g = e[u].value;
      t[u] !== g && (t[u] = g, d = true);
    }
    d && (r.dispose(), r = new X(), s = i(r, ...t));
  }, l = e.map((d) => d.changed.add(a));
  return {
    dispose() {
      ho(l), r.dispose();
    },
    get value() {
      return s;
    }
  };
}
function ta(i) {
  return { changed: pT, value: i };
}
function _r(i, e) {
  return i(e.value), e.changed.add(() => i(e.value));
}
var Wd = class {
  constructor(e, t) {
    this.outer = e, this.getInner = t, this.changed = new Le(), this.update = () => {
      const n = this.disposer, r = this.outer;
      n !== void 0 && n();
      const s = this.inner = this.getInner(r.value);
      this.disposer = s.changed.add(this.changed.dispatch), this.changed.dispatch();
    }, e.changed.add(this.update), this.update();
  }
  dispose() {
    this.outer.changed.remove(this.update), this.disposer();
  }
  get value() {
    return this.inner.value;
  }
  set value(e) {
    this.inner.value = e;
  }
};
var Bp = class extends Wd {
  reset() {
    this.inner.reset();
  }
  restoreState(e) {
    this.inner.restoreState(e);
  }
  toJSON() {
    return this.inner.toJSON();
  }
};
var Td = new Float32Array(1);
function rN(i) {
  Td[0] = i, i = Td[0];
  for (let e = 1; e < 21; ++e) {
    let t = i.toPrecision(e);
    if (Td[0] = parseFloat(t), Td[0] === i)
      return t;
  }
  return i.toString();
}
var Hd = 1e-6;
var _n = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var i = 0, e = arguments.length; e--; )
    i += arguments[e] * arguments[e];
  return Math.sqrt(i);
});
function Sc() {
  var i = new _n(9);
  return _n != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i;
}
function sN(i, e) {
  if (i === e) {
    var t = e[1], n = e[2], r = e[5];
    i[1] = e[3], i[2] = e[6], i[3] = t, i[5] = e[7], i[6] = n, i[7] = r;
  } else
    i[0] = e[0], i[1] = e[3], i[2] = e[6], i[3] = e[1], i[4] = e[4], i[5] = e[7], i[6] = e[2], i[7] = e[5], i[8] = e[8];
  return i;
}
function aN(i, e) {
  var t = e[0], n = e[1], r = e[2], s = e[3], a = e[4], l = e[5], d = e[6], u = e[7], h = e[8], g = h * a - l * u, v = -h * s + l * d, y = u * s - a * d, C = t * g + n * v + r * y;
  return C ? (C = 1 / C, i[0] = g * C, i[1] = (-h * n + r * u) * C, i[2] = (l * n - r * a) * C, i[3] = v * C, i[4] = (h * t - r * d) * C, i[5] = (-l * t + r * s) * C, i[6] = y * C, i[7] = (-u * t + n * d) * C, i[8] = (a * t - n * s) * C, i) : null;
}
function ly(i) {
  var e = i[0], t = i[1], n = i[2], r = i[3], s = i[4], a = i[5], l = i[6], d = i[7], u = i[8];
  return e * (u * s - a * d) + t * (-u * r + a * l) + n * (d * r - s * l);
}
function yT(i, e) {
  var t = e[0], n = e[1], r = e[2], s = e[3], a = t + t, l = n + n, d = r + r, u = t * a, h = n * a, g = n * l, v = r * a, y = r * l, C = r * d, w = s * a, b = s * l, E = s * d;
  return i[0] = 1 - g - C, i[3] = h - E, i[6] = v + b, i[1] = h + E, i[4] = 1 - u - C, i[7] = y - w, i[2] = v - b, i[5] = y + w, i[8] = 1 - u - g, i;
}
function nt() {
  var i = new _n(16);
  return _n != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
}
function oN(i) {
  var e = new _n(16);
  return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], e;
}
function ru(i, e) {
  return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
}
function ST(i) {
  return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
}
function cy(i, e) {
  if (i === e) {
    var t = e[1], n = e[2], r = e[3], s = e[6], a = e[7], l = e[11];
    i[1] = e[4], i[2] = e[8], i[3] = e[12], i[4] = t, i[6] = e[9], i[7] = e[13], i[8] = n, i[9] = s, i[11] = e[14], i[12] = r, i[13] = a, i[14] = l;
  } else
    i[0] = e[0], i[1] = e[4], i[2] = e[8], i[3] = e[12], i[4] = e[1], i[5] = e[5], i[6] = e[9], i[7] = e[13], i[8] = e[2], i[9] = e[6], i[10] = e[10], i[11] = e[14], i[12] = e[3], i[13] = e[7], i[14] = e[11], i[15] = e[15];
  return i;
}
function ys(i, e) {
  var t = e[0], n = e[1], r = e[2], s = e[3], a = e[4], l = e[5], d = e[6], u = e[7], h = e[8], g = e[9], v = e[10], y = e[11], C = e[12], w = e[13], b = e[14], E = e[15], T = t * l - n * a, I = t * d - r * a, R = t * u - s * a, P = n * d - r * l, L = n * u - s * l, A = r * u - s * d, M = h * w - g * C, O = h * b - v * C, F = h * E - y * C, q = g * b - v * w, U = g * E - y * w, V = v * E - y * b, $ = T * V - I * U + R * q + P * F - L * O + A * M;
  return $ ? ($ = 1 / $, i[0] = (l * V - d * U + u * q) * $, i[1] = (r * U - n * V - s * q) * $, i[2] = (w * A - b * L + E * P) * $, i[3] = (v * L - g * A - y * P) * $, i[4] = (d * F - a * V - u * O) * $, i[5] = (t * V - r * F + s * O) * $, i[6] = (b * R - C * A - E * I) * $, i[7] = (h * A - v * R + y * I) * $, i[8] = (a * U - l * F + u * M) * $, i[9] = (n * F - t * U - s * M) * $, i[10] = (C * L - w * R + E * T) * $, i[11] = (g * R - h * L - y * T) * $, i[12] = (l * O - a * q - d * M) * $, i[13] = (t * q - n * O + r * M) * $, i[14] = (w * I - C * P - b * T) * $, i[15] = (h * P - g * I + v * T) * $, i) : null;
}
function vn(i, e, t) {
  var n = e[0], r = e[1], s = e[2], a = e[3], l = e[4], d = e[5], u = e[6], h = e[7], g = e[8], v = e[9], y = e[10], C = e[11], w = e[12], b = e[13], E = e[14], T = e[15], I = t[0], R = t[1], P = t[2], L = t[3];
  return i[0] = I * n + R * l + P * g + L * w, i[1] = I * r + R * d + P * v + L * b, i[2] = I * s + R * u + P * y + L * E, i[3] = I * a + R * h + P * C + L * T, I = t[4], R = t[5], P = t[6], L = t[7], i[4] = I * n + R * l + P * g + L * w, i[5] = I * r + R * d + P * v + L * b, i[6] = I * s + R * u + P * y + L * E, i[7] = I * a + R * h + P * C + L * T, I = t[8], R = t[9], P = t[10], L = t[11], i[8] = I * n + R * l + P * g + L * w, i[9] = I * r + R * d + P * v + L * b, i[10] = I * s + R * u + P * y + L * E, i[11] = I * a + R * h + P * C + L * T, I = t[12], R = t[13], P = t[14], L = t[15], i[12] = I * n + R * l + P * g + L * w, i[13] = I * r + R * d + P * v + L * b, i[14] = I * s + R * u + P * y + L * E, i[15] = I * a + R * h + P * C + L * T, i;
}
function lN(i, e, t) {
  var n = t[0], r = t[1], s = t[2], a, l, d, u, h, g, v, y, C, w, b, E;
  return e === i ? (i[12] = e[0] * n + e[4] * r + e[8] * s + e[12], i[13] = e[1] * n + e[5] * r + e[9] * s + e[13], i[14] = e[2] * n + e[6] * r + e[10] * s + e[14], i[15] = e[3] * n + e[7] * r + e[11] * s + e[15]) : (a = e[0], l = e[1], d = e[2], u = e[3], h = e[4], g = e[5], v = e[6], y = e[7], C = e[8], w = e[9], b = e[10], E = e[11], i[0] = a, i[1] = l, i[2] = d, i[3] = u, i[4] = h, i[5] = g, i[6] = v, i[7] = y, i[8] = C, i[9] = w, i[10] = b, i[11] = E, i[12] = a * n + h * r + C * s + e[12], i[13] = l * n + g * r + w * s + e[13], i[14] = d * n + v * r + b * s + e[14], i[15] = u * n + y * r + E * s + e[15]), i;
}
function cN(i, e, t) {
  var n = t[0], r = t[1], s = t[2];
  return i[0] = e[0] * n, i[1] = e[1] * n, i[2] = e[2] * n, i[3] = e[3] * n, i[4] = e[4] * r, i[5] = e[5] * r, i[6] = e[6] * r, i[7] = e[7] * r, i[8] = e[8] * s, i[9] = e[9] * s, i[10] = e[10] * s, i[11] = e[11] * s, i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
}
function dN(i, e, t, n) {
  var r = e[0], s = e[1], a = e[2], l = e[3], d = r + r, u = s + s, h = a + a, g = r * d, v = r * u, y = r * h, C = s * u, w = s * h, b = a * h, E = l * d, T = l * u, I = l * h, R = n[0], P = n[1], L = n[2];
  return i[0] = (1 - (C + b)) * R, i[1] = (v + I) * R, i[2] = (y - T) * R, i[3] = 0, i[4] = (v - I) * P, i[5] = (1 - (g + b)) * P, i[6] = (w + E) * P, i[7] = 0, i[8] = (y + T) * L, i[9] = (w - E) * L, i[10] = (1 - (g + C)) * L, i[11] = 0, i[12] = t[0], i[13] = t[1], i[14] = t[2], i[15] = 1, i;
}
function uN(i, e) {
  var t = e[0], n = e[1], r = e[2], s = e[3], a = t + t, l = n + n, d = r + r, u = t * a, h = n * a, g = n * l, v = r * a, y = r * l, C = r * d, w = s * a, b = s * l, E = s * d;
  return i[0] = 1 - g - C, i[1] = h + E, i[2] = v - b, i[3] = 0, i[4] = h - E, i[5] = 1 - u - C, i[6] = y + w, i[7] = 0, i[8] = v + b, i[9] = y - w, i[10] = 1 - u - g, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
}
function hN(i, e, t, n, r) {
  var s = 1 / Math.tan(e / 2), a;
  return i[0] = s / t, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = s, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, r != null && r !== 1 / 0 ? (a = 1 / (n - r), i[10] = (r + n) * a, i[14] = 2 * r * n * a) : (i[10] = -1, i[14] = -2 * n), i;
}
function bT(i, e, t, n, r, s, a) {
  var l = 1 / (e - t), d = 1 / (n - r), u = 1 / (s - a);
  return i[0] = -2 * l, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * d, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * u, i[11] = 0, i[12] = (e + t) * l, i[13] = (r + n) * d, i[14] = (a + s) * u, i[15] = 1, i;
}
function ze() {
  var i = new _n(3);
  return _n != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i;
}
function bm(i) {
  var e = new _n(3);
  return e[0] = i[0], e[1] = i[1], e[2] = i[2], e;
}
function fN(i) {
  var e = i[0], t = i[1], n = i[2];
  return Math.hypot(e, t, n);
}
function wt(i, e, t) {
  var n = new _n(3);
  return n[0] = i, n[1] = e, n[2] = t, n;
}
function pN(i, e) {
  return i[0] = e[0], i[1] = e[1], i[2] = e[2], i;
}
function wm(i, e, t, n) {
  return i[0] = e, i[1] = t, i[2] = n, i;
}
function wT(i, e, t) {
  return i[0] = e[0] + t[0], i[1] = e[1] + t[1], i[2] = e[2] + t[2], i;
}
function CT(i, e, t) {
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], i;
}
function xT(i, e, t) {
  return i[0] = e[0] * t[0], i[1] = e[1] * t[1], i[2] = e[2] * t[2], i;
}
function Cm(i, e, t) {
  return i[0] = e[0] / t[0], i[1] = e[1] / t[1], i[2] = e[2] / t[2], i;
}
function uC(i, e) {
  return i[0] = Math.ceil(e[0]), i[1] = Math.ceil(e[1]), i[2] = Math.ceil(e[2]), i;
}
function dy(i, e, t) {
  return i[0] = e[0] * t, i[1] = e[1] * t, i[2] = e[2] * t, i;
}
function su(i, e) {
  var t = e[0], n = e[1], r = e[2], s = t * t + n * n + r * r;
  return s > 0 && (s = 1 / Math.sqrt(s)), i[0] = e[0] * s, i[1] = e[1] * s, i[2] = e[2] * s, i;
}
function uy(i, e) {
  return i[0] * e[0] + i[1] * e[1] + i[2] * e[2];
}
function Fp(i, e, t) {
  var n = e[0], r = e[1], s = e[2], a = t[0], l = t[1], d = t[2];
  return i[0] = r * d - s * l, i[1] = s * a - n * d, i[2] = n * l - r * a, i;
}
function yi(i, e, t) {
  var n = e[0], r = e[1], s = e[2], a = t[3] * n + t[7] * r + t[11] * s + t[15];
  return a = a || 1, i[0] = (t[0] * n + t[4] * r + t[8] * s + t[12]) / a, i[1] = (t[1] * n + t[5] * r + t[9] * s + t[13]) / a, i[2] = (t[2] * n + t[6] * r + t[10] * s + t[14]) / a, i;
}
function so(i, e, t) {
  var n = t[0], r = t[1], s = t[2], a = t[3], l = e[0], d = e[1], u = e[2], h = r * u - s * d, g = s * l - n * u, v = n * d - r * l, y = r * v - s * g, C = s * h - n * v, w = n * g - r * h, b = a * 2;
  return h *= b, g *= b, v *= b, y *= 2, C *= 2, w *= 2, i[0] = l + h + y, i[1] = d + g + C, i[2] = u + v + w, i;
}
function xm(i, e) {
  var t = i[0], n = i[1], r = i[2], s = e[0], a = e[1], l = e[2];
  return Math.abs(t - s) <= Hd * Math.max(1, Math.abs(t), Math.abs(s)) && Math.abs(n - a) <= Hd * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - l) <= Hd * Math.max(1, Math.abs(r), Math.abs(l));
}
var gN = CT;
var mN = fN;
(function() {
  var i = ze();
  return function(e, t, n, r, s, a) {
    var l, d;
    for (t || (t = 3), n || (n = 0), r ? d = Math.min(r * t + n, e.length) : d = e.length, l = n; l < d; l += t)
      i[0] = e[l], i[1] = e[l + 1], i[2] = e[l + 2], s(i, i, a), e[l] = i[0], e[l + 1] = i[1], e[l + 2] = i[2];
    return e;
  };
})();
function oh() {
  var i = new _n(4);
  return _n != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 0), i;
}
function bc(i, e, t, n) {
  var r = new _n(4);
  return r[0] = i, r[1] = e, r[2] = t, r[3] = n, r;
}
function vN(i, e) {
  return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i;
}
function yN(i, e) {
  var t = e[0], n = e[1], r = e[2], s = e[3], a = t * t + n * n + r * r + s * s;
  return a > 0 && (a = 1 / Math.sqrt(a)), i[0] = t * a, i[1] = n * a, i[2] = r * a, i[3] = s * a, i;
}
(function() {
  var i = oh();
  return function(e, t, n, r, s, a) {
    var l, d;
    for (t || (t = 4), n || (n = 0), r ? d = Math.min(r * t + n, e.length) : d = e.length, l = n; l < d; l += t)
      i[0] = e[l], i[1] = e[l + 1], i[2] = e[l + 2], i[3] = e[l + 3], s(i, i, a), e[l] = i[0], e[l + 1] = i[1], e[l + 2] = i[2], e[l + 3] = i[3];
    return e;
  };
})();
function Wn() {
  var i = new _n(4);
  return _n != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i;
}
function hC(i) {
  return i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1, i;
}
function Em(i, e, t) {
  t = t * 0.5;
  var n = Math.sin(t);
  return i[0] = n * e[0], i[1] = n * e[1], i[2] = n * e[2], i[3] = Math.cos(t), i;
}
function ps(i, e, t) {
  var n = e[0], r = e[1], s = e[2], a = e[3], l = t[0], d = t[1], u = t[2], h = t[3];
  return i[0] = n * h + a * l + r * u - s * d, i[1] = r * h + a * d + s * l - n * u, i[2] = s * h + a * u + n * d - r * l, i[3] = a * h - n * l - r * d - s * u, i;
}
function SN(i, e, t) {
  t *= 0.5;
  var n = e[0], r = e[1], s = e[2], a = e[3], l = Math.sin(t), d = Math.cos(t);
  return i[0] = n * d + a * l, i[1] = r * d + s * l, i[2] = s * d - r * l, i[3] = a * d - n * l, i;
}
function bN(i, e, t) {
  t *= 0.5;
  var n = e[0], r = e[1], s = e[2], a = e[3], l = Math.sin(t), d = Math.cos(t);
  return i[0] = n * d - s * l, i[1] = r * d + a * l, i[2] = s * d + n * l, i[3] = a * d - r * l, i;
}
function Up(i, e, t, n) {
  var r = e[0], s = e[1], a = e[2], l = e[3], d = t[0], u = t[1], h = t[2], g = t[3], v, y, C, w, b;
  return y = r * d + s * u + a * h + l * g, y < 0 && (y = -y, d = -d, u = -u, h = -h, g = -g), 1 - y > Hd ? (v = Math.acos(y), C = Math.sin(v), w = Math.sin((1 - n) * v) / C, b = Math.sin(n * v) / C) : (w = 1 - n, b = n), i[0] = w * r + b * d, i[1] = w * s + b * u, i[2] = w * a + b * h, i[3] = w * l + b * g, i;
}
function au(i, e) {
  var t = e[0], n = e[1], r = e[2], s = e[3], a = t * t + n * n + r * r + s * s, l = a ? 1 / a : 0;
  return i[0] = -t * l, i[1] = -n * l, i[2] = -r * l, i[3] = s * l, i;
}
function ET(i, e) {
  var t = e[0] + e[4] + e[8], n;
  if (t > 0)
    n = Math.sqrt(t + 1), i[3] = 0.5 * n, n = 0.5 / n, i[0] = (e[5] - e[7]) * n, i[1] = (e[6] - e[2]) * n, i[2] = (e[1] - e[3]) * n;
  else {
    var r = 0;
    e[4] > e[0] && (r = 1), e[8] > e[r * 3 + r] && (r = 2);
    var s = (r + 1) % 3, a = (r + 2) % 3;
    n = Math.sqrt(e[r * 3 + r] - e[s * 3 + s] - e[a * 3 + a] + 1), i[r] = 0.5 * n, n = 0.5 / n, i[3] = (e[s * 3 + a] - e[a * 3 + s]) * n, i[s] = (e[s * 3 + r] + e[r * 3 + s]) * n, i[a] = (e[a * 3 + r] + e[r * 3 + a]) * n;
  }
  return i;
}
var wN = vN;
var Zl = yN;
(function() {
  var i = ze(), e = wt(1, 0, 0), t = wt(0, 1, 0);
  return function(n, r, s) {
    var a = uy(r, s);
    return a < -0.999999 ? (Fp(i, e, r), mN(i) < 1e-6 && Fp(i, t, r), su(i, i), Em(n, i, Math.PI), n) : a > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (Fp(i, r, s), n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = 1 + a, Zl(n, n));
  };
})();
(function() {
  var i = Wn(), e = Wn();
  return function(t, n, r, s, a, l) {
    return Up(i, n, a, l), Up(e, r, s, l), Up(t, i, e, 2 * l * (1 - l)), t;
  };
})();
(function() {
  var i = Sc();
  return function(e, t, n, r) {
    return i[0] = n[0], i[3] = n[1], i[6] = n[2], i[1] = r[0], i[4] = r[1], i[7] = r[2], i[2] = -t[0], i[5] = -t[1], i[8] = -t[2], Zl(e, ET(e, i));
  };
})();
function kT() {
  var i = new _n(2);
  return _n != Float32Array && (i[0] = 0, i[1] = 0), i;
}
function CN(i, e, t) {
  return i[0] = e, i[1] = t, i;
}
function xN(i, e, t) {
  return i[0] = e[0] + t[0], i[1] = e[1] + t[1], i;
}
(function() {
  var i = kT();
  return function(e, t, n, r, s, a) {
    var l, d;
    for (t || (t = 2), n || (n = 0), r ? d = Math.min(r * t + n, e.length) : d = e.length, l = n; l < d; l += t)
      i[0] = e[l], i[1] = e[l + 1], s(i, i, a), e[l] = i[0], e[l + 1] = i[1];
    return e;
  };
})();
var TT = nt();
var EN = ["x", "y", "z"];
var Xi = [wt(1, 0, 0), wt(0, 1, 0), wt(0, 0, 1)];
wt(0, 0, 0);
var km = bc(0, 0, 0, 0);
var LT = wt(1, 1, 1);
wt(1 / 0, 1 / 0, 1 / 0);
Wn();
function Tm(i) {
  return i[0] * i[1] * i[2];
}
function Lm(i) {
  return `${i[0]},${i[1]},${i[2]}`;
}
function kN(i, e, t) {
  let n = e[0], r = e[1], s = e[2];
  return i[0] = t[0] * n + t[4] * r + t[8] * s, i[1] = t[1] * n + t[5] * r + t[9] * s, i[2] = t[2] * n + t[6] * r + t[10] * s, i;
}
function DT(i, e, t) {
  let n = e[0], r = e[1], s = e[2];
  return i[0] = t[0] * n + t[1] * r + t[2] * s, i[1] = t[4] * n + t[5] * r + t[6] * s, i[2] = t[8] * n + t[9] * r + t[10] * s, i;
}
function TN(i, e, t) {
  const n = t.length;
  let r = 0;
  for (let a = 0; a < n; ++a)
    r += (i[a] - e[a]) ** 2;
  let s = 0;
  for (let a = 0; a < n; ++a) {
    const l = i[a];
    s -= (l - t[a]) * (e[a] - l);
  }
  return s / Math.max(r, 1e-6);
}
function IT(i, e, t, n) {
  const r = i.length;
  let s = TN(e, t, n);
  s = Math.max(0, Math.min(1, s));
  for (let a = 0; a < r; ++a) {
    const l = e[a];
    i[a] = l + s * (t[a] - l);
  }
  return i;
}
function lh(i, e) {
  const t = e[0], n = e[1], r = e[2], s = e[4], a = e[5], l = e[6], d = e[8], u = e[9], h = e[10];
  return i[0] = t, i[1] = n, i[2] = r, i[3] = s, i[4] = a, i[5] = l, i[6] = d, i[7] = u, i[8] = h, i;
}
function ou(i, e) {
  const t = e[0], n = e[1], r = e[2], s = e[3], a = e[4], l = e[5], d = e[6], u = e[7], h = e[8], g = e[9], v = e[10], y = e[11], C = e[12], w = e[13], b = e[14], E = e[15];
  i[0] = s + t, i[1] = u + a, i[2] = y + h, i[3] = E + C, i[4] = s - t, i[5] = u - a, i[6] = y - h, i[7] = E - C, i[8] = s + n, i[9] = u + l, i[10] = y + g, i[11] = E + w, i[12] = s - n, i[13] = u - l, i[14] = y - g, i[15] = E - w;
  const T = s + r, I = u + d, R = y + v, P = E + b, L = s - r, A = u - d, M = y - v, O = E - b, F = Math.sqrt(T ** 2 + I ** 2 + R ** 2);
  i[16] = T / F, i[17] = I / F, i[18] = R / F, i[19] = P / F;
  const q = Math.sqrt(L ** 2 + A ** 2 + M ** 2);
  return i[20] = L / q, i[21] = A / q, i[22] = M / q, i[23] = O / q, i;
}
function PT(i, e, t, n, r, s, a) {
  for (let l = 0; l < 6; ++l) {
    const d = a[l * 4], u = a[l * 4 + 1], h = a[l * 4 + 2], g = a[l * 4 + 3];
    if (Math.max(d * i, d * n) + Math.max(u * e, u * r) + Math.max(h * t, h * s) + g < 0)
      return false;
  }
  return true;
}
function LN(i, e, t, n, r, s, a) {
  for (let l = 0; l < 4; ++l) {
    const d = a[l * 4], u = a[l * 4 + 1], h = a[l * 4 + 2], g = a[l * 4 + 3];
    if (Math.max(d * i, d * n) + Math.max(u * e, u * r) + Math.max(h * t, h * s) + g < 0)
      return false;
  }
  {
    const d = a[20], u = a[5 * 4 + 1], h = a[5 * 4 + 2], g = a[5 * 4 + 3], v = Math.max(d * i, d * n) + Math.max(u * e, u * r) + Math.max(h * t, h * s), y = Math.min(d * i, d * n) + Math.min(u * e, u * r) + Math.min(h * t, h * s), C = Math.abs(g) * 1e-6;
    if (y > -g + C || v < -g - C) return false;
  }
  return true;
}
function ch(i, e, t, n = false) {
  const r = t.length, s = [], a = n ? 1 : e + 1, l = n ? e + 1 : 1;
  for (let d = 0; d < r; ++d) {
    const u = t[d];
    for (let h = 0; h < e; ++h)
      i[h * a + u * l] !== 0 && (s[h] = true);
  }
  return WM(s, true);
}
function RT(i, e, t) {
  for (let n = 0; n < 3; ++n) {
    const r = t[n];
    for (let s = 0; s < 3; ++s)
      i[n + s * 3] = r * e[n + s * 3];
  }
  return i;
}
function DN(i) {
  if (i[15] === 1) {
    const a = 2 / Math.abs(i[10]), l = 2 / Math.abs(i[0]), d = 2 / Math.abs(i[5]);
    return l * d * a;
  }
  const e = i[10], n = 2 * i[14] / (2 * e - 2), r = (e - 1) * n / (e + 1);
  return 4 / (i[0] * i[5]) / 3 * (Math.abs(r) ** 3 - Math.abs(n) ** 3);
}
function AT(i) {
  if (i[15] === 1)
    return 2 / Math.abs(i[10]);
  const e = i[10], n = 2 * i[14] / (2 * e - 2), r = (e - 1) * n / (e + 1);
  return Math.abs(r - n);
}
function IN(i) {
  return i[2] = 0, i[6] = 0, i[10] = 0, i[14] = 0, i;
}
var ja = ze();
function PN(i, e) {
  e[0] = e[1] = e[2] = Number.POSITIVE_INFINITY, e[3] = e[4] = e[5] = Number.NEGATIVE_INFINITY;
  for (let t = 0; t < 8; ++t) {
    ja[0] = 2 * (t & 1) - 1, ja[1] = 2 * (t >>> 1 & 1) - 1, ja[2] = 2 * (t >>> 2 & 1) - 1, yi(ja, ja, i);
    for (let n = 0; n < 3; ++n) {
      const r = ja[n];
      e[n] = Math.min(e[n], r), e[n + 3] = Math.max(e[n + 3], r);
    }
  }
}
function _T(i) {
  return ("0" + i.toString(16)).slice(-2);
}
function RN(i) {
  return Array.prototype.map.call(i, _T).join("");
}
function AN(i) {
  if (!/^(?:[0-9a-fA-F]{2})*$/.test(i))
    throw new Error("Invalid hex-encoded string");
  const e = i.length / 2, t = new Uint8Array(e);
  for (let n = 0; n < e; ++n)
    t[n] = parseInt(i.substr(n * 2, 2), 16);
  return t;
}
function MT(i) {
  const e = /^rgba\(([0-9]+), ([0-9]+), ([0-9]+), (0(?:\.[0-9]+)?)\)$/;
  {
    const n = i.match(e);
    if (n !== null)
      return [parseInt(n[1], 10), parseInt(n[2], 10), parseInt(n[3], 10), parseFloat(n[4])];
  }
  const t = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/;
  {
    const n = i.match(t);
    if (n !== null)
      return [parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16), 1];
  }
  throw new Error(`Invalid serialized color: ${oe(i)}.`);
}
function hy(i) {
  try {
    if (typeof i != "string")
      throw new Error(`Expected string, but received ${oe(i)}.`);
    const e = document.createElement("canvas").getContext("2d");
    e.fillStyle = i;
    const t = MT(e.fillStyle);
    return bc(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
  } catch (e) {
    throw new Error(`Failed to parse color specification: ${e.message}`);
  }
}
function ua(i) {
  return hy(i).subarray(0, 3);
}
function lu(i) {
  const e = i[3] === void 0 ? 3 : 4;
  let t = 0;
  for (let n = 0; n < e; n++)
    t = (t << 8 >>> 0) + Math.min(255, Math.max(0, Math.round(i[e - 1 - n] * 255)));
  return t;
}
function Xs(i) {
  return wt((i >>> 0 & 255) / 255, (i >>> 8 & 255) / 255, (i >>> 16 & 255) / 255);
}
function dh(i) {
  return bc((i >>> 0 & 255) / 255, (i >>> 8 & 255) / 255, (i >>> 16 & 255) / 255, (i >>> 24 & 255) / 255);
}
function Hn(i) {
  if (i[3] === void 0 || i[3] === 1) {
    let e = "#";
    for (let t = 0; t < 3; ++t)
      e += _T(Math.min(255, Math.max(0, Math.round(i[t] * 255))));
    return e;
  } else {
    let e = "rgba(";
    for (let t = 0; t < 3; ++t)
      t !== 0 && (e += ", "), e += Math.min(255, Math.max(0, Math.round(i[t] * 255)));
    return e += `, ${rN(i[3])})`, e;
  }
}
function qd(i) {
  return i <= 0.03928 ? i / 12.92 : ((i + 0.055) / 1.055) ** 2.4;
}
function NT(i) {
  var e = de(i, 3);
  const t = e[0], n = e[1], r = e[2];
  return 0.2126 * qd(t) + 0.7152 * qd(n) + 0.0722 * qd(r);
}
function cu(i) {
  return NT(i) <= 0.179;
}
var Ql = class extends vt {
  constructor(e) {
    super(bm(e)), this.defaultValue = e;
  }
  toString() {
    return Hn(this.value);
  }
  toJSON() {
    if (!xm(this.value, this.defaultValue))
      return Hn(this.value);
  }
  reset() {
    this.value = bm(this.defaultValue);
  }
  restoreState(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    const t = this.value, n = ua(e);
    xm(t, n) || (this.value = n);
  }
};
var OT = class extends vt {
  constructor() {
    super(void 0);
  }
  toJSON() {
    const e = this.value;
    if (e !== void 0)
      return Hn(e);
  }
  reset() {
    this.value = void 0;
  }
  restoreState(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    const t = this.value, n = ua(e);
    (t === void 0 || !xm(t, n)) && (this.value = n);
  }
};
var _N = Object.freeze(Object.defineProperty({
  __proto__: null,
  TrackableOptionalRGB: OT,
  TrackableRGB: Ql,
  getRelativeLuminance: NT,
  packColor: lu,
  parseColorSerialization: MT,
  parseRGBAColorSpecification: hy,
  parseRGBColorSpecification: ua,
  serializeColor: Hn,
  srgbGammaExpand: qd,
  unpackRGB: Xs,
  unpackRGBA: dh,
  useWhiteBackground: cu
}, Symbol.toStringTag, { value: "Module" }));
var j;
(function(i) {
  i[i.UINT8 = 0] = "UINT8", i[i.INT8 = 1] = "INT8", i[i.UINT16 = 2] = "UINT16", i[i.INT16 = 3] = "INT16", i[i.UINT32 = 4] = "UINT32", i[i.INT32 = 5] = "INT32", i[i.UINT64 = 6] = "UINT64", i[i.FLOAT32 = 7] = "FLOAT32";
})(j || (j = {}));
var VT = {
  [j.UINT8]: false,
  [j.INT8]: true,
  [j.UINT16]: false,
  [j.INT16]: true,
  [j.UINT32]: false,
  [j.INT32]: true,
  [j.UINT64]: false,
  [j.FLOAT32]: void 0
};
var MN = {
  [j.UINT8]: 1,
  [j.INT8]: 1,
  [j.UINT16]: 2,
  [j.INT16]: 2,
  [j.UINT32]: 4,
  [j.INT32]: 4,
  [j.UINT64]: 8,
  [j.FLOAT32]: 4
};
var NN = {
  [j.UINT8]: Uint8Array,
  [j.INT8]: Int8Array,
  [j.UINT16]: Uint16Array,
  [j.INT16]: Int16Array,
  [j.UINT32]: Uint32Array,
  [j.INT32]: Int32Array,
  [j.UINT64]: Uint32Array,
  [j.FLOAT32]: Float32Array
};
j.UINT8 + "", j.INT8 + "", j.UINT16 + "", j.INT16 + "", j.UINT32 + "", j.INT32 + "", j.UINT64 + "", j.FLOAT32 + "";
var ai;
(function(i) {
  i[i.LITTLE = 0] = "LITTLE", i[i.BIG = 1] = "BIG";
})(ai || (ai = {}));
function ON() {
  const i = Uint16Array.of(4386);
  return new Uint8Array(i.buffer)[0] === 17 ? ai.BIG : ai.LITTLE;
}
var wc = ON();
var fC = {};
var zp;
var pC;
function VN() {
  if (pC) return zp;
  pC = 1;
  var i = pD(), e = Math.floor;
  return zp = function(n) {
    return !i(n) && isFinite(n) && e(n) === n;
  }, zp;
}
var gC;
function BN() {
  if (gC) return fC;
  gC = 1;
  var i = BD();
  return i(i.S, "Number", { isInteger: VN() }), fC;
}
var $p;
var mC;
function FN() {
  return mC || (mC = 1, BN(), $p = mR().Number.isInteger), $p;
}
var Gp;
var vC;
function UN() {
  return vC || (vC = 1, Gp = { default: FN(), __esModule: true }), Gp;
}
var zN = UN();
var jn = Ws(zN);
var yC = {};
var SC;
function $N() {
  if (SC) return yC;
  SC = 1;
  var i = BD(), e = pR().isFinite;
  return i(i.S, "Number", {
    isFinite: function(n) {
      return typeof n == "number" && e(n);
    }
  }), yC;
}
var Wp;
var bC;
function GN() {
  return bC || (bC = 1, $N(), Wp = mR().Number.isFinite), Wp;
}
var Hp;
var wC;
function WN() {
  return wC || (wC = 1, Hp = { default: GN(), __esModule: true }), Hp;
}
var HN = WN();
var Lt = Ws(HN);
var CC = {};
var xC;
function qN() {
  if (xC) return CC;
  xC = 1;
  var i = BD();
  return i(i.S, "Number", {
    isNaN: function(t) {
      return t != t;
    }
  }), CC;
}
var qp;
var EC;
function jN() {
  return EC || (EC = 1, qN(), qp = mR().Number.isNaN), qp;
}
var jp;
var kC;
function JN() {
  return kC || (kC = 1, jp = { default: jN(), __esModule: true }), jp;
}
var KN = JN();
var er = Ws(KN);
function Bo(i) {
  let e = typeof i;
  if (e === "number" || e === "string") {
    let t = parseFloat("" + i);
    if (!er(t))
      return t;
  }
  throw new Error(`Expected floating-point number, but received: ${oe(i)}.`);
}
function Dt(i) {
  let e = Bo(i);
  if (Lt(e))
    return e;
  throw new Error(`Expected finite floating-point number, but received: ${e}.`);
}
function fy(i) {
  let e = Bo(i);
  if (Lt(e) && e >= 0)
    return e;
  throw new Error(`Expected finite non-negative floating-point number, but received: ${e}.`);
}
function yn(i) {
  let e = Dt(i);
  if (e > 0)
    return e;
  throw new Error(`Expected positive finite floating-point number, but received: ${e}.`);
}
function ec(i, e, t = Bo) {
  me(e), i[0] = i[1] = i[2] = 0;
  for (const n of hn(e))
    switch (n) {
      case "x":
        i[0] = t(e[n]);
        break;
      case "y":
        i[1] = t(e[n]);
        break;
      case "z":
        i[2] = t(e[n]);
        break;
      default:
        throw new Error(`Expected object to have keys ['x', 'y', 'z'], but received: ${oe(e)}.`);
    }
  return i;
}
function ao(i, e) {
  let t = i.length;
  if (!Array.isArray(e) || e.length !== t)
    throw new Error("Incompatible sizes");
  for (let n = 0; n < t; ++n)
    if (!Lt(parseFloat(e[n])))
      throw new Error("Non-finite value.");
  for (let n = 0; n < t; ++n)
    i[n] = parseFloat(e[n]);
  return i;
}
function js(i, e) {
  let t = i.length;
  if (!Array.isArray(e) || e.length !== t)
    throw new Error("Incompatible sizes.");
  for (let n = 0; n < t; ++n) {
    let r = parseInt(e[n], void 0);
    if (!jn(r))
      throw new Error("Non-integer value.");
  }
  for (let n = 0; n < t; ++n)
    i[n] = parseInt(e[n], void 0);
  return i;
}
function si(i) {
  if (typeof i == "object") {
    if (i === null)
      return "null";
    if (Array.isArray(i)) {
      let s = "[", a = i.length, l = 0;
      if (l < a)
        for (s += si(i[l]); ++l < a; )
          s += ",", s += si(i[l]);
      return s += "]", s;
    }
    let e = "{", t = hn(i).sort(), n = 0, r = t.length;
    if (n < r) {
      let s = t[n];
      for (e += oe(s), e += ":", e += si(i[s]); ++n < r; )
        e += ",", s = t[n], e += oe(s), e += ":", e += si(i[s]);
    }
    return e += "}", e;
  }
  return oe(i);
}
function TC(i) {
  return i.replace(/['"]/g, (e) => e === '"' ? "'" : '"');
}
function Dm(i) {
  return TC(oe(TC(i)));
}
var LC = "_";
function zl(i) {
  if (typeof i == "object") {
    if (i === null)
      return "null";
    let e = i.toJSON;
    if (typeof e == "function")
      return zl(e.call(i));
    if (Array.isArray(i)) {
      let s = "[", a = i.length, l = 0;
      if (l < a)
        for (s += zl(i[l]); ++l < a; )
          s += LC, s += zl(i[l]);
      return s += "]", s;
    }
    let t = "{", n = hn(i), r = true;
    for (let s of n) {
      let a = i[s];
      if (a === void 0)
        continue;
      let l = zl(a);
      l && (r ? r = false : t += LC, t += Dm(s), t += ":", t += l);
    }
    return t += "}", t;
  }
  return typeof i == "string" ? Dm(i) : oe(i);
}
var BT = /('(?:[^'\\]|(?:\\.))*')/;
var FT = /("(?:[^"\\]|(?:\\.))*")/;
var UT = new RegExp(`${BT.source}|${FT.source}`);
var YN = new RegExp(`${FT.source}|${BT.source}`);
var zT = /^((?:[^"'\\]|(?:\\[^']))*)("|\\')/;
var XN = /^((?:[^"'\\]|(?:\\.))*)'/;
function $T(i, e, t, n) {
  if (i.length >= 2 && i.charAt(0) === e && i.charAt(i.length - 1) === e) {
    let r = i.substr(1, i.length - 2), s = t;
    for (; r.length > 0; ) {
      let a = r.match(n);
      if (a === null) {
        s += r;
        break;
      }
      s += a[1], a[2] === t ? (s += "\\", s += t) : s += e, r = r.substr(a.index + a[0].length);
    }
    return s += t, s;
  }
  return i;
}
function GT(i) {
  return $T(i, "'", '"', zT);
}
function WT(i, e, t) {
  const n = /[&_,]/g;
  let r, s, a;
  t === '"' ? (r = "'", s = zT, a = UT) : (r = '"', s = XN, a = YN);
  let l = "";
  for (; i.length > 0; ) {
    let d = i.match(a), u, h;
    if (d === null)
      u = i, i = "", h = "";
    else {
      u = i.substr(0, d.index), i = i.substr(d.index + d[0].length);
      let g = d[1];
      g !== void 0 ? h = $T(g, r, t, s) : h = d[2];
    }
    l += u.replace(n, e), l += h;
  }
  return l;
}
function HT(i) {
  return WT(i, ",", '"');
}
function ZN(i) {
  return WT(i, "_", "'");
}
function du(i) {
  return JSON.parse(HT(i));
}
function qT(i) {
  let e = "";
  for (; i.length > 0; ) {
    let t = i.match(UT), n, r;
    if (t === null)
      n = i, i = "", r = "";
    else {
      n = i.substr(0, t.index), i = i.substr(t.index + t[0].length);
      let s = t[1];
      s !== void 0 ? r = GT(s) : r = t[2];
    }
    e += n.replace(/\(/g, "[").replace(/\)/g, "]").replace("True", "true").replace("False", "false").replace(/,\s*([\}\]])/g, "$1"), e += r;
  }
  return e;
}
function QN(i) {
  return JSON.parse(qT(i));
}
function Vi(i, e) {
  if (!Array.isArray(i))
    throw new Error(`Expected array, but received: ${oe(i)}.`);
  if (e !== void 0 && i.length !== e)
    throw new Error(`Expected array of length ${e}, but received: ${oe(i)}.`);
  return i;
}
function Xe(i, e) {
  if (!Array.isArray(i))
    throw new Error(`Expected array, but received: ${oe(i)}.`);
  return i.map(e);
}
function lt(i, e, t) {
  const n = i.length;
  if (!Array.isArray(e) || e.length !== n)
    throw new Error(`Expected length ${n} array, but received: ${oe(e)}.`);
  for (let r = 0; r < n; ++r)
    i[r] = t(e[r], r);
  return i;
}
function me(i) {
  if (typeof i != "object" || i == null || Array.isArray(i))
    throw new Error(`Expected JSON object, but received: ${oe(i)}.`);
  return i;
}
function gn(i) {
  let e = parseInt(i, 10);
  if (!jn(e))
    throw new Error(`Expected integer, but received: ${oe(i)}.`);
  return e;
}
function un(i) {
  let e = gn(i);
  if (e <= 0)
    throw new Error(`Expected positive integer, but received: ${e}.`);
  return e;
}
function jT(i) {
  const e = gn(i);
  if (e < 0)
    throw new Error(`Expected non-negative integer, but received: ${e}.`);
  return e;
}
function py(i, e) {
  let t = e.get(i);
  if (t === void 0)
    throw new Error(`Expected one of ${oe(_e(e.keys()))}, but received: ${oe(i)}.`);
  return t;
}
function Ae(i) {
  if (typeof i != "string")
    throw new Error(`Expected string, but received: ${oe(i)}.`);
  return i;
}
function Ci(i) {
  if (i !== void 0)
    return Ae(i);
}
function eO(i) {
  if (i !== void 0)
    return gn(i);
}
function tO(i) {
  if (i !== void 0) {
    if (typeof i == "boolean")
      return i;
    if (i === "true")
      return true;
    if (i === "false")
      return false;
    throw new Error(`Expected string or boolean but received: ${oe(i)}`);
  }
}
function nO(i, e) {
  return i === void 0 ? e : i;
}
function Y(i, e, t) {
  let n = Object.prototype.hasOwnProperty.call(i, e) ? i[e] : void 0;
  try {
    return t(n);
  } catch (r) {
    throw new Error(`Error parsing ${oe(e)} property: ${r.message}`);
  }
}
function xe(i, e, t, n) {
  return Y(i, e, (r) => r === void 0 ? n : t(r));
}
function uh(i, e) {
  me(i);
  let t = new he();
  for (let n of hn(i))
    try {
      t.set(n, e(i[n]));
    } catch (r) {
      throw new Error(`Error parsing value associated with key ${oe(n)}: ${r.message}`);
    }
  return t;
}
function gy(i) {
  if (typeof i != "number" || !Lt(i) || i < 0 || i > 1)
    throw new Error(`Expected floating point number in [0,1], but received: ${oe(i)}.`);
  return i;
}
function Fo(i) {
  if (i === "")
    return {};
  if (i.startsWith("{"))
    return du(i);
  {
    let e = {}, t = i.split(/[&;]/);
    for (let n of t) {
      let r = n.match(/^([^=&;]+)=([^&;]*)$/);
      if (r === null)
        throw new Error(`Invalid query string part: ${oe(n)}.`);
      e[r[1]] = decodeURIComponent(r[2]);
    }
    return e;
  }
}
function JT(i) {
  if (i === void 0) return "";
  const e = hn(i);
  return e.length === 0 ? "" : e.some((t) => typeof i[t] != "string") ? oe(i) : e.map((t) => `${encodeURIComponent(t)}=${encodeURIComponent(i[t])}`).join("&");
}
function Rn(i, e) {
  if (typeof i == "string" && i.match(/^[a-zA-Z]/) !== null && (i = i.toUpperCase(), e.hasOwnProperty(i)))
    return e[i];
  throw new Error(`Invalid enum value: ${oe(i)}.`);
}
function KT(i) {
  return lt(ze(), i, Dt);
}
function iO(i) {
  return lt(ze(), i, yn);
}
function rO(i) {
  return lt(ze(), i, un);
}
function bi(i) {
  if (!Array.isArray(i))
    throw new Error(`Expected array, received: ${oe(i)}.`);
  for (let e of i)
    if (typeof e != "string")
      throw new Error(`Expected string, received: ${oe(e)}.`);
  return i;
}
function YT(i) {
  if (!Array.isArray(i))
    throw new Error(`Expected array, received: ${oe(i)}.`);
  for (let e of i)
    if (!jn(e))
      throw new Error(`Expected integer, received: ${oe(e)}.`);
  return i;
}
function na(i) {
  if (typeof i != "boolean")
    throw new Error(`Expected boolean, received: ${oe(i)}`);
  return i;
}
function ha(i) {
  for (const e in i)
    return i;
}
var sO = Object.freeze(Object.defineProperty({
  __proto__: null,
  emptyToUndefined: ha,
  expectArray: Vi,
  jsonToUrlSafe: ZN,
  normalizeStringLiteral: GT,
  parseArray: Xe,
  parseFiniteVec: ao,
  parseFixedLengthArray: lt,
  parseIntVec: js,
  parseQueryStringParameters: Fo,
  parseXYZ: ec,
  pythonLiteralParse: QN,
  pythonLiteralToJSON: qT,
  stableStringify: si,
  unparseQueryStringParameters: JT,
  urlSafeParse: du,
  urlSafeStringify: zl,
  urlSafeStringifyString: Dm,
  urlSafeToJSON: HT,
  valueOr: nO,
  verify3dDimensions: rO,
  verify3dScale: iO,
  verify3dVec: KT,
  verifyBoolean: na,
  verifyEnumString: Rn,
  verifyFiniteFloat: Dt,
  verifyFiniteNonNegativeFloat: fy,
  verifyFinitePositiveFloat: yn,
  verifyFloat: Bo,
  verifyFloat01: gy,
  verifyInt: gn,
  verifyIntegerArray: YT,
  verifyMapKey: py,
  verifyNonnegativeInt: jT,
  verifyObject: me,
  verifyObjectAsMap: uh,
  verifyObjectProperty: Y,
  verifyOptionalBoolean: tO,
  verifyOptionalInt: eO,
  verifyOptionalObjectProperty: xe,
  verifyOptionalString: Ci,
  verifyPositiveInt: un,
  verifyString: Ae,
  verifyStringArray: bi
}, Symbol.toStringTag, { value: "Module" }));
var aO = 2 ** -1074;
var Im = new Float64Array(1);
var os = new Uint32Array(Im.buffer);
function oO(i, e) {
  if (isNaN(i) || isNaN(e)) return NaN;
  if (i === e) return e;
  if (i === 0)
    return e < 0 ? -5e-324 : aO;
  Im[0] = i;
  const t = wc === ai.LITTLE ? 0 : 1, n = 1 - t;
  return e > i == i > 0 ? os[t] === 4294967295 ? (os[t] = 0, os[n] += 1) : os[t] += 1 : os[t] === 0 ? (os[t] = 4294967295, os[n] -= 1) : os[t] -= 1, Im[0];
}
var DC = {};
var IC;
function lO() {
  if (IC) return DC;
  IC = 1;
  var i = BD(), e = Math.imul;
  return i(i.S + i.F * WP()(function() {
    return e(4294967295, 5) != -5 || e.length != 2;
  }), "Math", {
    imul: function(n, r) {
      var s = 65535, a = +n, l = +r, d = s & a, u = s & l;
      return 0 | d * u + ((s & a >>> 16) * u + d * (s & l >>> 16) << 16 >>> 0);
    }
  }), DC;
}
var Jp;
var PC;
function cO() {
  return PC || (PC = 1, lO(), Jp = mR().Math.imul), Jp;
}
var Kp;
var RC;
function dO() {
  return RC || (RC = 1, Kp = { default: cO(), __esModule: true }), Kp;
}
var uO = dO();
var tr = Ws(uO);
var AC = {};
var _C;
function hO() {
  if (_C) return AC;
  _C = 1;
  var i = BD();
  return i(i.S, "Math", {
    log2: function(t) {
      return Math.log(t) / Math.LN2;
    }
  }), AC;
}
var Yp;
var MC;
function fO() {
  return MC || (MC = 1, hO(), Yp = mR().Math.log2), Yp;
}
var Xp;
var NC;
function pO() {
  return NC || (NC = 1, Xp = { default: fO(), __esModule: true }), Xp;
}
var gO = pO();
var Zn = Ws(gO);
var Zp = new Uint32Array(2);
var Al = 4294967296;
var Pm = [];
for (let i = 2; i <= 36; ++i) {
  let e = Math.floor(32 / Zn(i)), t = Math.pow(i, e), n = `^[0-${String.fromCharCode(48 + Math.min(9, i - 1))}`;
  i > 10 && (n += `a-${String.fromCharCode(97 + i - 11)}`, n += `A-${String.fromCharCode(65 + i - 11)}`);
  let r = Math.ceil(64 / Zn(i));
  n += `]{1,${r}}$`;
  let s = new RegExp(n);
  Pm[i] = { lowDigits: e, lowBase: t, pattern: s };
}
function OC(i, e) {
  i >>>= 0, e >>>= 0;
  const t = i & 65535, n = i >>> 16, r = e & 65535, s = e >>> 16;
  let l = (t * r >>> 16) + n * r, d = l >>> 16;
  l = (l & 65535) + t * s, d += l >>> 16;
  let u = d >>> 16;
  return d = (d & 65535) + n * s, u += d >>> 16, ((u & 65535) << 16 | d & 65535) >>> 0;
}
var re = class _re2 {
  constructor(e = 0, t = 0) {
    this.low = e, this.high = t;
  }
  clone() {
    return new _re2(this.low, this.high);
  }
  assign(e) {
    this.low = e.low, this.high = e.high;
  }
  toString(e = 10) {
    let t = this.low, n = this.high;
    if (n === 0)
      return t.toString(e);
    n *= Al;
    var r = Pm[e];
    let s = r.lowBase, a = r.lowDigits, l = n % s;
    n = Math.floor(n / s), t += l, n += Math.floor(t / s), t = t % s;
    let d = t.toString(e);
    return n.toString(e) + "0".repeat(a - d.length) + d;
  }
  /**
   * Returns true if a is strictly less than b.
   */
  static less(e, t) {
    return e.high < t.high || e.high === t.high && e.low < t.low;
  }
  /**
   * Returns a negative number if a is strictly less than b, 0 if a is equal to b, or a positive
   * number if a is strictly greater than b.
   */
  static compare(e, t) {
    return e.high - t.high || e.low - t.low;
  }
  static equal(e, t) {
    return e.low === t.low && e.high === t.high;
  }
  static min(e, t) {
    return _re2.less(e, t) ? e : t;
  }
  static max(e, t) {
    return _re2.less(e, t) ? t : e;
  }
  static random() {
    return crypto.getRandomValues(Zp), new _re2(Zp[0], Zp[1]);
  }
  tryParseString(e, t = 10) {
    var n = Pm[t];
    const r = n.lowDigits, s = n.lowBase;
    if (!n.pattern.test(e))
      return false;
    if (e.length <= r)
      return this.low = parseInt(e, t), this.high = 0, true;
    const l = e.length - r, d = parseInt(e.substr(l), t), u = parseInt(e.substr(0, l), t);
    let h, g;
    if (s === Al)
      h = u, g = d;
    else {
      const v = tr(u, s) >>> 0;
      h = OC(u, s) + (tr(Math.floor(u / Al), s) >>> 0), g = d + v, g >= Al && (++h, g -= Al);
    }
    return g >>> 0 !== g || h >>> 0 !== h ? false : (this.low = g, this.high = h, true);
  }
  parseString(e, t = 10) {
    if (!this.tryParseString(e, t))
      throw new Error(`Failed to parse string as uint64 value: ${oe(e)}.`);
    return this;
  }
  static parseString(e, t = 10) {
    return new _re2().parseString(e, t);
  }
  valid() {
    let e = this.low, t = this.high;
    return e >>> 0 === e && t >>> 0 === t;
  }
  toJSON() {
    return this.toString();
  }
  static lshift(e, t, n) {
    const r = t.low, s = t.high;
    return n === 0 ? (e.low = r, e.high = s) : n < 32 ? (e.low = r << n, e.high = s << n | r >>> 32 - n) : (e.low = 0, e.high = r << n - 32), e;
  }
  static rshift(e, t, n) {
    const r = t.low, s = t.high;
    return n === 0 ? (e.low = r, e.high = s) : n < 32 ? (e.low = r >>> n | s << 32 - n, e.high = s >>> n) : (e.low = s >>> n - 32, e.high = 0), e;
  }
  static or(e, t, n) {
    return e.low = t.low | n.low, e.high = t.high | n.high, e;
  }
  static xor(e, t, n) {
    return e.low = t.low ^ n.low, e.high = t.high ^ n.high, e;
  }
  static and(e, t, n) {
    return e.low = t.low & n.low, e.high = t.high & n.high, e;
  }
  static add(e, t, n) {
    let r = t.low + n.low, s = t.high + n.high;
    const a = r >>> 0;
    return a !== r && (s += 1), e.low = a, e.high = s >>> 0, e;
  }
  static addUint32(e, t, n) {
    let r = t.low + n, s = t.high;
    const a = r >>> 0;
    return a !== r && (s += 1), e.low = a, e.high = s >>> 0, e;
  }
  static decrement(e, t) {
    let n = t.low, r = t.high;
    return n === 0 && (r -= 1), e.low = n - 1 >>> 0, e.high = r >>> 0, e;
  }
  static increment(e, t) {
    let n = t.low, r = t.high;
    return n === 4294967295 && (r += 1), e.low = n + 1 >>> 0, e.high = r >>> 0, e;
  }
  static subtract(e, t, n) {
    let r = t.low - n.low, s = t.high - n.high;
    const a = r >>> 0;
    return a !== r && (s -= 1), e.low = a, e.high = s >>> 0, e;
  }
  static absDifference(e, t, n) {
    return _re2.less(t, n) ? _re2.subtract(e, n, t) : _re2.subtract(e, t, n);
  }
  static multiplyUint32(e, t, n) {
    const r = t.low, s = t.high;
    return e.low = tr(r, n) >>> 0, e.high = tr(s, n) + OC(r, n) >>> 0, e;
  }
  static lowMask(e, t) {
    return t === 0 ? e.high = e.low = 0 : t <= 32 ? (e.high = 0, e.low = 4294967295 >>> 32 - t) : (e.high = 4294967295 >>> t - 32, e.low = 4294967295), e;
  }
  toNumber() {
    return this.low + this.high * 4294967296;
  }
  setFromNumber(e) {
    e = Math.round(e), e < 0 ? this.low = this.high = 0 : e >= 18446744073709552e3 ? this.low = this.high = 4294967295 : (this.low = e % 4294967296, this.high = Math.floor(e / 4294967296));
  }
};
re.ZERO = new re(0, 0);
re.ONE = new re(1, 0);
var mO = Object.freeze(Object.defineProperty({
  __proto__: null,
  Uint64: re
}, Symbol.toStringTag, { value: "Module" }));
var Cc = {
  [j.UINT8]: [0, 255],
  [j.INT8]: [-128, 127],
  [j.UINT16]: [0, 65535],
  [j.INT16]: [-32768, 32767],
  [j.UINT32]: [0, 4294967295],
  [j.INT32]: [-2147483648, 2147483647],
  [j.UINT64]: [re.ZERO, new re(4294967295, 4294967295)],
  [j.FLOAT32]: [0, 1]
};
function pi(i, e) {
  if (typeof e == "number") {
    const t = i[0], n = i[1];
    return (e - t) / (n - t);
  } else {
    const t = i[0], n = i[1];
    let r;
    re.compare(e, t) < 0 ? r = -re.subtract(ri, t, e).toNumber() : r = re.subtract(ri, e, t).toNumber();
    let s = re.absDifference(ri, n, t).toNumber();
    return re.compare(t, n) > 0 && (s *= -1), r / s;
  }
}
function Ir(i, e, t) {
  if (typeof i[0] == "number") {
    const r = i[0], s = i[1];
    let a = r * (1 - t) + s * t;
    if (e !== j.FLOAT32) {
      const l = Cc[e];
      a = Math.round(a), a = Math.max(l[0], a), a = Math.min(l[1], a);
    }
    return a;
  } else {
    let r = i[0], s = i[1];
    if (re.compare(r, s) > 0) {
      var n = [s, r];
      r = n[0], s = n[1], t = 1 - t;
    }
    const a = re.subtract(ri, s, r).toNumber(), l = new re();
    return t <= 0 ? (ri.setFromNumber(a * -t), re.subtract(l, r, re.min(ri, r))) : t >= 1 ? (ri.setFromNumber(a * (t - 1)), re.add(l, s, ri), re.less(l, s) && (l.low = l.high = 4294967295)) : (ri.setFromNumber(a * t), re.add(l, r, ri), re.less(l, r) && (l.low = l.high = 4294967295)), l;
  }
}
function tc(i, e) {
  return typeof e == "number" ? Math.min(Math.max(i[0], e), i[1]) : re.min(re.max(i[0], e), i[1]);
}
function Hl(i, e) {
  return [tc(i, e[0]), tc(i, e[1])];
}
function XT(i) {
  if (xi(i[0], i[1]) <= 0) return i;
  throw new Error(`Invalid interval: [${i[0]}, ${i[1]}]`);
}
function vO(i) {
  return xi(i[0], i[1]) <= 0 ? i : [i[1], i[0]];
}
function xi(i, e) {
  return typeof i == "number" ? i - e : re.compare(i, e);
}
var ri = new re();
var yO = new re();
function SO(i, e) {
  return typeof e == "number" ? Math.abs(e - i[0]) < Math.abs(e - i[1]) ? 0 : 1 : re.less(re.absDifference(ri, i[0], e), re.absDifference(yO, i[1], e)) ? 0 : 1;
}
function xc(i, e) {
  let t;
  switch (typeof e != "string" ? t = "" + e : t = e, i) {
    case j.UINT64:
      return re.parseString(t);
    case j.FLOAT32: {
      const n = parseFloat(t);
      if (!Lt(n))
        throw new Error(`Invalid float32 value: ${oe(t)}`);
      return n;
    }
    default: {
      const n = parseInt(t), r = Cc[i];
      if (!jn(n) || n < r[0] || n > r[1])
        throw new Error(`Invalid ${j[i].toLowerCase()} value: ${oe(t)}`);
      return n;
    }
  }
}
function uu(i, e) {
  return lt(new Array(2), i, (t) => xc(e, t));
}
function Pr(i, e, t) {
  return i === j.UINT64 ? re.equal(e[0], t[0]) && re.equal(e[1], t[1]) : e[0] === t[0] && e[1] === t[1];
}
function VC(i, e, t = Cc[e]) {
  if (!Pr(e, i, t))
    return e === j.UINT64 ? [i[0].toString(), i[1].toString()] : i;
}
function hu(i, e, t) {
  switch (i) {
    case j.FLOAT32:
      return oO(e, t * (1 / 0));
    case j.UINT64:
      const n = e;
      return t === -1 ? n.low === 0 && n.high === 0 ? n : re.decrement(new re(), n) : n.low === 4294967295 && n.high === 4294967295 ? n : re.increment(new re(), n);
    default: {
      const r = Cc[i];
      return Math.max(r[0], Math.min(r[1], e + t));
    }
  }
}
function bO(i, e) {
  switch (i) {
    case j.FLOAT32:
      return 0;
    case j.UINT64:
      return 0.5 / re.absDifference(ri, e[0], e[1]).toNumber();
    default:
      return 0.5 / Math.abs(e[0] - e[1]);
  }
}
function fu(i, e) {
  switch (i) {
    case j.FLOAT32:
      return 1;
    case j.UINT64: {
      const t = re.absDifference(ri, e[0], e[1]).toNumber();
      return t / (t + 1);
    }
    default: {
      const t = Math.abs(e[0] - e[1]);
      return t / (t + 1);
    }
  }
}
function pu(i = 128) {
  const e = Math.ceil(i / 32), t = new Uint32Array(e);
  crypto.getRandomValues(t);
  let n = "";
  for (let r = 0; r < e; ++r)
    n += ("00000000" + t[r].toString(16)).slice(-8);
  return n;
}
function wO(i) {
  let e = new Uint8Array(i.buffer, i.byteOffset, i.byteLength);
  const t = 65536;
  for (let n = 0, r = e.length; n < r; n += t)
    crypto.getRandomValues(e.subarray(n, Math.min(r, n + t)));
  return i;
}
function BC() {
  const i = new Uint32Array(1);
  return crypto.getRandomValues(i), i[0];
}
var jd = class extends X {
  constructor(e) {
    super(), this.id = e, this.changed = new Le();
  }
  addRef() {
    return super.addRef();
  }
  dispose() {
    super.dispose();
  }
};
var Fe;
(function(i) {
  i[i.POINT = 0] = "POINT", i[i.LINE = 1] = "LINE", i[i.AXIS_ALIGNED_BOUNDING_BOX = 2] = "AXIS_ALIGNED_BOUNDING_BOX", i[i.ELLIPSOID = 3] = "ELLIPSOID", i[i.SPHERE = 4] = "SPHERE";
})(Fe || (Fe = {}));
var Mr = [Fe.POINT, Fe.LINE, Fe.AXIS_ALIGNED_BOUNDING_BOX, Fe.ELLIPSOID, Fe.SPHERE];
var Ss = {
  rgb: {
    serializedBytes() {
      return 3;
    },
    alignment() {
      return 1;
    },
    serializeCode(i, e) {
      return `dv.setUint16(${e}, ${i}, true);dv.setUint8(${e} + 2, ${i} >>> 16);`;
    },
    deserializeCode(i, e) {
      return `${i} = dv.getUint16(${e}, true) | (dv.getUint8(${e} + 2) << 16);`;
    },
    deserializeJson(i) {
      return lu(ua(i));
    },
    serializeJson(i) {
      return Hn(Xs(i));
    }
  },
  rgba: {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 1;
    },
    serializeCode(i, e) {
      return `dv.setUint32(${e}, ${i}, true);`;
    },
    deserializeCode(i, e) {
      return `${i} = dv.getUint32(${e}, true);`;
    },
    deserializeJson(i) {
      return lu(hy(i));
    },
    serializeJson(i) {
      return Hn(dh(i));
    }
  },
  float32: {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 4;
    },
    serializeCode(i, e) {
      return `dv.setFloat32(${e}, ${i}, isLittleEndian);`;
    },
    deserializeCode(i, e) {
      return `${i} = dv.getFloat32(${e}, isLittleEndian);`;
    },
    deserializeJson(i) {
      return Bo(i);
    },
    serializeJson(i) {
      return i;
    }
  },
  uint32: {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 4;
    },
    serializeCode(i, e) {
      return `dv.setUint32(${e}, ${i}, isLittleEndian);`;
    },
    deserializeCode(i, e) {
      return `${i} = dv.getUint32(${e}, isLittleEndian);`;
    },
    deserializeJson(i) {
      return gn(i);
    },
    serializeJson(i) {
      return i;
    }
  },
  int32: {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 4;
    },
    serializeCode(i, e) {
      return `dv.setInt32(${e}, ${i}, isLittleEndian);`;
    },
    deserializeCode(i, e) {
      return `${i} = dv.getInt32(${e}, isLittleEndian);`;
    },
    deserializeJson(i) {
      return gn(i);
    },
    serializeJson(i) {
      return i;
    }
  },
  uint16: {
    serializedBytes() {
      return 2;
    },
    alignment() {
      return 2;
    },
    serializeCode(i, e) {
      return `dv.setUint16(${e}, ${i}, isLittleEndian);`;
    },
    deserializeCode(i, e) {
      return `${i} = dv.getUint16(${e}, isLittleEndian);`;
    },
    deserializeJson(i) {
      return gn(i);
    },
    serializeJson(i) {
      return i;
    }
  },
  int16: {
    serializedBytes() {
      return 2;
    },
    alignment() {
      return 2;
    },
    serializeCode(i, e) {
      return `dv.setInt16(${e}, ${i}, isLittleEndian);`;
    },
    deserializeCode(i, e) {
      return `${i} = dv.getInt16(${e}, isLittleEndian);`;
    },
    deserializeJson(i) {
      return gn(i);
    },
    serializeJson(i) {
      return i;
    }
  },
  uint8: {
    serializedBytes() {
      return 1;
    },
    alignment() {
      return 1;
    },
    serializeCode(i, e) {
      return `dv.setUint8(${e}, ${i});`;
    },
    deserializeCode(i, e) {
      return `${i} = dv.getUint8(${e});`;
    },
    deserializeJson(i) {
      return gn(i);
    },
    serializeJson(i) {
      return i;
    }
  },
  int8: {
    serializedBytes() {
      return 2;
    },
    alignment() {
      return 1;
    },
    serializeCode(i, e) {
      return `dv.setInt8(${e}, ${i});`;
    },
    deserializeCode(i, e) {
      return `${i} = dv.getInt8(${e});`;
    },
    deserializeJson(i) {
      return gn(i);
    },
    serializeJson(i) {
      return i;
    }
  }
};
var CO = 255;
function ZT(i, e, t) {
  let n = 0;
  const r = t.length, s = new Array(r), a = [];
  for (let v = 0; v < r; ++v)
    s[v] = v;
  const l = (v) => Ss[t[v].type].alignment(i);
  s.sort((v, y) => l(y) - l(v));
  let d = 0;
  const u = new Array(r);
  let h = e;
  const g = () => {
    h += (4 - h % 4) % 4, n += h, a[d] = h, h = 0, ++d;
  };
  for (let v = 0; v < r; ++v) {
    const y = s[v], C = t[y], w = Ss[C.type], b = w.serializedBytes(i), E = w.alignment(i), T = (E - h % E) % E, R = h + T + b;
    R + (4 - R % 4) % 4 <= CO ? h += T : g(), u[y] = { offset: h, group: d }, h += b;
  }
  return g(), { serializedBytes: n, offsets: u, propertyGroupBytes: a };
}
var QT = class {
  constructor(e, t, n) {
    if (this.rank = e, this.firstGroupInitialOffset = t, this.propertySpecs = n, n.length === 0) {
      this.serializedBytes = t, this.serialize = this.deserialize = () => {
      }, this.propertyGroupBytes = [t];
      return;
    }
    var r = ZT(e, t, n);
    const s = r.serializedBytes, a = r.offsets, l = r.propertyGroupBytes;
    this.propertyGroupBytes = l;
    let d = "let groupOffset0 = offset;";
    for (let y = 1; y < l.length; ++y)
      d += `let groupOffset${y} = groupOffset${y - 1} + ${l[y - 1]}*annotationCount;`;
    for (let y = 0; y < l.length; ++y)
      d += `groupOffset${y} += ${l[y]}*annotationIndex;`;
    let u = d, h = d;
    const g = n.length;
    for (let y = 0; y < g; ++y) {
      var v = a[y];
      const C = v.group, w = v.offset, b = n[y], E = Ss[b.type], T = `properties[${y}]`, I = `groupOffset${C} + ${w}`;
      u += E.serializeCode(T, I, e), h += E.deserializeCode(T, I, e);
    }
    this.serializedBytes = s, this.serialize = new Function("dv", "offset", "annotationIndex", "annotationCount", "isLittleEndian", "properties", u), this.deserialize = new Function("dv", "offset", "annotationIndex", "annotationCount", "isLittleEndian", "properties", h);
  }
};
function my(i, e) {
  const t = [];
  for (const n of Mr) {
    const r = Gn[n];
    t[n] = new QT(i, r.serializedBytes(i), e);
  }
  return t;
}
function eL(i, e) {
  const t = i.type === "float32" ? e.toPrecision(6) : e.toString(), n = i.enumValues, r = i.enumLabels;
  if (n !== void 0) {
    const s = n.indexOf(e);
    if (s !== -1)
      return `${r[s]} (${t})`;
  }
  return t;
}
function xO(i, e) {
  switch (i.type) {
    case "rgb":
      return Hn(Xs(e));
    case "rgba":
      return Hn(dh(e));
    default:
      return eL(i, e);
  }
}
function EO(i) {
  const e = Ae(i);
  if (e.match(/^[a-z][a-zA-Z0-9_]*$/) === null)
    throw new Error(`Invalid property identifier: ${oe(i)}`);
  return e;
}
function kO(i) {
  if (Ae(i), !Object.prototype.hasOwnProperty.call(Ss, i))
    throw new Error("Unsupported property type: $JSON.stringify(obj)}");
  return i;
}
function TO(i) {
  const e = new Ye();
  for (const t of i) {
    if (e.has(t.identifier))
      throw new Error(`Duplicate property identifier: ${t.identifier}`);
    e.add(t.identifier);
  }
}
function LO(i) {
  me(i);
  const e = Y(i, "id", EO), t = Y(i, "type", kO), n = xe(i, "description", Ae);
  let r = xe(i, "default", (l) => Ss[t].deserializeJson(l), 0), s, a;
  switch (t) {
    case "rgb":
    case "rgba":
      break;
    default: {
      const l = j[t.toUpperCase()];
      s = xe(i, "enum_values", (d) => Xe(d, (u) => xc(l, u))), s !== void 0 && (a = Y(i, "enum_labels", (d) => lt(new Array(s.length), d, Ae)));
    }
  }
  return { type: t, identifier: e, description: n, default: r, enumValues: s, enumLabels: a };
}
function DO(i) {
  const e = i.default;
  return {
    id: i.identifier,
    description: i.description,
    type: i.type,
    default: e === 0 ? void 0 : Ss[i.type].serializeJson(e)
  };
}
function IO(i) {
  if (!(i === void 0 || i.length === 0))
    return i.map(DO);
}
function tL(i) {
  if (i === void 0) return [];
  const e = Xe(i, LO);
  return TO(e), e;
}
function Rm(i, e, t, n, r) {
  for (let s = 0; s < n; ++s)
    i.setFloat32(e, r[s], t), e += 4;
  return e;
}
function Ld(i, e, t, n, r, s) {
  return e = Rm(i, e, t, n, r), e = Rm(i, e, t, n, s), e;
}
function Am(i, e, t, n, r) {
  for (let s = 0; s < n; ++s)
    r[s] = i.getFloat32(e, t), e += 4;
  return e;
}
function Dd(i, e, t, n, r, s) {
  return e = Am(i, e, t, n, r), e = Am(i, e, t, n, s), e;
}
var Gn = {
  [Fe.LINE]: {
    icon: "ꕹ",
    description: "Line",
    toJSON(i) {
      return {
        pointA: _e(i.pointA),
        pointB: _e(i.pointB)
      };
    },
    restoreState(i, e, t) {
      i.pointA = Y(e, "pointA", (n) => lt(new Float32Array(t), n, Dt)), i.pointB = Y(e, "pointB", (n) => lt(new Float32Array(t), n, Dt));
    },
    serializedBytes(i) {
      return 2 * 4 * i;
    },
    serialize(i, e, t, n, r) {
      Ld(i, e, t, n, r.pointA, r.pointB);
    },
    deserialize: (i, e, t, n, r) => {
      const s = new Float32Array(n), a = new Float32Array(n);
      return Dd(i, e, t, n, s, a), { type: Fe.LINE, pointA: s, pointB: a, id: r, properties: [] };
    },
    visitGeometry(i, e) {
      e(i.pointA, false), e(i.pointB, false);
    }
  },
  [Fe.SPHERE]: {
    icon: "⊖",
    description: "Sphere",
    toJSON(i) {
      return {
        pointA: _e(i.pointA),
        pointB: _e(i.pointB)
      };
    },
    restoreState(i, e, t) {
      i.pointA = Y(e, "pointA", (n) => lt(new Float32Array(t), n, Dt)), i.pointB = Y(e, "pointB", (n) => lt(new Float32Array(t), n, Dt));
    },
    serializedBytes(i) {
      return 2 * 4 * i;
    },
    serialize(i, e, t, n, r) {
      Ld(i, e, t, n, r.pointA, r.pointB);
    },
    deserialize: (i, e, t, n, r) => {
      const s = new Float32Array(n), a = new Float32Array(n);
      return Dd(i, e, t, n, s, a), { type: Fe.SPHERE, pointA: s, pointB: a, id: r, properties: [] };
    },
    visitGeometry(i, e) {
      e(i.pointA, false), e(i.pointB, false);
    }
  },
  [Fe.POINT]: {
    icon: "⚬",
    description: "Point",
    toJSON: (i) => ({
      point: _e(i.point)
    }),
    restoreState: (i, e, t) => {
      i.point = Y(e, "point", (n) => lt(new Float32Array(t), n, Dt));
    },
    serializedBytes: (i) => i * 4,
    serialize: (i, e, t, n, r) => {
      Rm(i, e, t, n, r.point);
    },
    deserialize: (i, e, t, n, r) => {
      const s = new Float32Array(n);
      return Am(i, e, t, n, s), { type: Fe.POINT, point: s, id: r, properties: [] };
    },
    visitGeometry(i, e) {
      e(i.point, false);
    }
  },
  [Fe.AXIS_ALIGNED_BOUNDING_BOX]: {
    icon: "❑",
    description: "Bounding Box",
    toJSON: (i) => ({
      pointA: _e(i.pointA),
      pointB: _e(i.pointB)
    }),
    restoreState: (i, e, t) => {
      i.pointA = Y(e, "pointA", (n) => lt(new Float32Array(t), n, Dt)), i.pointB = Y(e, "pointB", (n) => lt(new Float32Array(t), n, Dt));
    },
    serializedBytes: (i) => 2 * 4 * i,
    serialize(i, e, t, n, r) {
      Ld(i, e, t, n, r.pointA, r.pointB);
    },
    deserialize: (i, e, t, n, r) => {
      const s = new Float32Array(n), a = new Float32Array(n);
      return Dd(i, e, t, n, s, a), { type: Fe.AXIS_ALIGNED_BOUNDING_BOX, pointA: s, pointB: a, id: r, properties: [] };
    },
    visitGeometry(i, e) {
      e(i.pointA, false), e(i.pointB, false);
    }
  },
  [Fe.ELLIPSOID]: {
    icon: "◎",
    description: "Ellipsoid",
    toJSON: (i) => ({
      center: _e(i.center),
      radii: _e(i.radii)
    }),
    restoreState: (i, e, t) => {
      i.center = Y(e, "center", (n) => lt(new Float32Array(t), n, Dt)), i.radii = Y(e, "radii", (n) => lt(new Float32Array(t), n, fy));
    },
    serializedBytes: (i) => 2 * 4 * i,
    serialize(i, e, t, n, r) {
      Ld(i, e, t, n, r.center, r.radii);
    },
    deserialize: (i, e, t, n, r) => {
      const s = new Float32Array(n), a = new Float32Array(n);
      return Dd(i, e, t, n, s, a), { type: Fe.ELLIPSOID, center: s, radii: a, id: r, properties: [] };
    },
    visitGeometry(i, e) {
      e(i.center, false), e(i.radii, true);
    }
  }
};
function _m(i, e) {
  const t = Gn[i.type].toJSON(i, e.rank);
  t.type = Fe[i.type].toLowerCase(), t.id = i.id, t.description = i.description || void 0;
  const n = i.relatedSegments;
  if (n !== void 0 && n.some((r) => r.length !== 0) && (t.segments = n.map((r) => r.map((s) => s.toString()))), e.properties.length !== 0) {
    const r = e.properties;
    t.props = i.properties.map((s, a) => Ss[r[a].type].serializeJson(s));
  }
  return t;
}
function PO(i, e, t = false) {
  me(i);
  const n = Y(i, "type", (d) => Rn(d, Fe)), r = Y(i, "id", t ? Ci : Ae) || vy(), s = Y(i, "segments", (d) => {
    if (d === void 0)
      return e.relationships.map(() => []);
    const u = Vi(d);
    return u.length === 0 ? e.relationships.map(() => []) : e.relationships.length === 1 && !Array.isArray(u[0]) ? [Xe(u, (h) => re.parseString(h))] : Xe(Vi(d, e.relationships.length), (h) => Xe(h, (g) => re.parseString(g)));
  }), a = Y(i, "props", (d) => {
    const u = e.properties;
    return d === void 0 ? u.map((h) => h.default) : Xe(Vi(d, e.properties.length), (h, g) => Ss[u[g].type].deserializeJson(h));
  }), l = {
    id: r,
    description: Y(i, "description", Ci),
    relatedSegments: s,
    properties: a,
    type: n
  };
  return Gn[n].restoreState(l, i, e.rank), l;
}
var po = class extends X {
  constructor(e, t = [], n = []) {
    super(), this.relationships = t, this.properties = n, this.annotationMap = new he(), this.changed = new Le(), this.readonly = false, this.childAdded = new ct(), this.childUpdated = new ct(), this.childDeleted = new ct(), this.childRefreshed = new Le(), this.pending = new Ye(), this.references = new he(), this.rank_ = e, this.annotationPropertySerializers = my(e, n);
  }
  get rank() {
    return this.rank_;
  }
  hasNonSerializedProperties() {
    return true;
  }
  add(e, t = true) {
    if (this.ensureUpdated(), !e.id)
      e.id = vy();
    else if (this.annotationMap.has(e.id))
      throw new Error(`Annotation id already exists: ${oe(e.id)}.`);
    return this.annotationMap.set(e.id, e), this.changed.dispatch(), this.childAdded.dispatch(e), t || this.pending.add(e.id), this.getReference(e.id);
  }
  commit(e) {
    this.ensureUpdated();
    const t = e.id;
    this.pending.delete(t), this.changed.dispatch();
  }
  update(e, t) {
    if (this.ensureUpdated(), e.value === null)
      throw new Error("Annotation already deleted.");
    e.value = t, this.annotationMap.set(t.id, t), e.changed.dispatch(), this.changed.dispatch(), this.childUpdated.dispatch(t);
  }
  [qn]() {
    return this.ensureUpdated(), this.annotationMap.values();
  }
  get(e) {
    return this.ensureUpdated(), this.annotationMap.get(e);
  }
  delete(e) {
    e.value !== null && (e.value = null, this.annotationMap.delete(e.id), this.pending.delete(e.id), e.changed.dispatch(), this.changed.dispatch(), this.childDeleted.dispatch(e.id));
  }
  getReference(e) {
    let t = this.references.get(e);
    return t !== void 0 ? t.addRef() : (t = new jd(e), t.value = this.annotationMap.get(e) || null, this.references.set(e, t), t.registerDisposer(() => {
      this.references.delete(e);
    }), t);
  }
  ensureUpdated() {
  }
  toJSON() {
    this.ensureUpdated();
    const e = [], t = this.pending;
    for (const n of this)
      t.has(n.id) || e.push(_m(n, this));
    return e;
  }
  clear() {
    this.annotationMap.clear(), this.pending.clear(), this.changed.dispatch();
  }
  restoreState(e) {
    this.ensureUpdated();
    const t = this.annotationMap;
    t.clear(), this.pending.clear(), e !== void 0 && Xe(e, (n) => {
      const r = PO(n, this);
      t.set(r.id, r);
    });
    for (const n of this.references.values()) {
      const r = n.id, s = t.get(r);
      n.value = s || null, n.changed.dispatch();
    }
    this.changed.dispatch();
  }
  reset() {
    this.clear();
  }
};
var RO = class extends po {
  constructor(e, t, n) {
    super(e.value.sourceRank, n, t), this.watchableTransform = e, this.curCoordinateTransform = e.value, this.registerDisposer(e.changed.add(() => this.ensureUpdated()));
  }
  get rank() {
    return this.ensureUpdated(), this.rank_;
  }
  ensureUpdated() {
    const e = this.watchableTransform.value, t = this.curCoordinateTransform;
    if (e === t) return;
    this.curCoordinateTransform = e;
    const n = e.sourceRank, r = t.sourceRank;
    if (r === n && (t.inputSpace === e.inputSpace || He(t.inputSpace.ids.slice(0, n), e.inputSpace.ids.slice(0, n))))
      return;
    const s = e.inputSpace.ids, a = t.inputSpace.ids, l = [];
    for (let u = 0; u < n; ++u) {
      let h = a.indexOf(s[u]);
      h >= r && (h = -1), l.push(h);
    }
    const d = (u) => {
      const h = new Float32Array(n);
      for (let g = 0; g < n; ++g) {
        const v = l[g];
        h[g] = v === -1 ? 0 : u[g];
      }
      return h;
    };
    for (const u of this.annotationMap.values())
      switch (u.type) {
        case Fe.POINT:
          u.point = d(u.point);
          break;
        case Fe.LINE:
        case Fe.SPHERE:
        case Fe.AXIS_ALIGNED_BOUNDING_BOX:
          u.pointA = d(u.pointA), u.pointB = d(u.pointB);
          break;
        case Fe.ELLIPSOID:
          u.center = d(u.center), u.radii = d(u.radii);
          break;
      }
    this.rank_ !== n && (this.rank_ = n, this.annotationPropertySerializers = my(this.rank_, this.properties)), this.changed.dispatch();
  }
};
var AO = "Data Bounds";
function vy() {
  return pu(160);
}
function _O(i) {
  return {
    type: Fe.AXIS_ALIGNED_BOUNDING_BOX,
    id: "data-bounds",
    description: AO,
    pointA: new Float32Array(i.lowerBounds),
    pointB: new Float32Array(i.upperBounds),
    properties: []
  };
}
function Ec(i) {
  const e = new po(i.lowerBounds.length);
  return e.readonly = true, e.add(_O(i)), e;
}
function MO(i, e) {
  let t = 0;
  const n = [];
  for (const u of Mr) {
    const g = e[u].serializedBytes;
    n[u] = t;
    const y = i[u].length;
    t += g * y;
  }
  const r = [], s = [], a = new ArrayBuffer(t), l = new DataView(a), d = wc === ai.LITTLE;
  for (const u of Mr) {
    const h = e[u], g = h.rank, v = h.serialize, y = i[u];
    r[u] = y.map((T) => T.id), s[u] = new he(y.map((T, I) => [T.id, I]));
    const w = Gn[u].serialize, b = n[u], E = h.propertyGroupBytes[0];
    for (let T = 0, I = y.length; T < I; ++T) {
      const R = y[T];
      w(l, b + T * E, d, g, R), v(l, b, T, I, d, R.properties);
    }
  }
  return { data: new Uint8Array(a), typeToIds: r, typeToOffset: n, typeToIdMaps: s };
}
var NO = class {
  constructor(e) {
    this.propertySerializers = e, this.annotations = [[], [], [], [], []];
  }
  add(e) {
    this.annotations[e.type].push(e);
  }
  serialize() {
    return MO(this.annotations, this.propertySerializers);
  }
};
function yy(i) {
  if (i == null)
    return i;
  const e = i.relatedSegments;
  if (e !== void 0)
    for (let t = 0, n = e.length; t < n; ++t) {
      const r = e[t];
      r !== void 0 && (e[t] = r.map((s) => new re(s.low, s.high)));
    }
  return i;
}
function hh(i, e, t, n, r, s, a, l, d) {
  for (let u = 0; u < a; ++u)
    for (let h = 0; h < d; ++h) {
      let g = 0;
      for (let v = 0; v < l; ++v)
        g += t[u + n * v] * r[v + s * h];
      i[u + e * h] = g;
    }
  return i;
}
function OO(i, e, t) {
  for (let n = 0; n < t; ++n) {
    const r = e * n;
    i.fill(0, r, r + t), i[r + n] = 1;
  }
  return i;
}
function ks(i, e, t = e) {
  return OO(new i(e * t), e, Math.min(e, t));
}
function FC(i, e, t = true) {
  const n = e.length, r = t ? n + 1 : n, s = new i(r * (n + 1));
  t && (s[s.length - 1] = 1);
  for (let a = 0; a < n; ++a)
    s[(r + 1) * a] = e[a];
  return s;
}
function VO(i, e, t) {
  for (let n = 0; n < t; ++n)
    for (let r = 0; r < t; ++r)
      if (i[n * e + r] != (n === r ? 1 : 0)) return false;
  return true;
}
function Sy(i, e, t, n, r, s) {
  for (let a = 0; a < s; ++a) {
    const l = a * n, d = a * e;
    for (let u = 0; u < r; ++u)
      i[d + u] = t[l + u];
  }
  return i;
}
function by(i, e, t, n) {
  Sy(i, e + 1, t, n + 1, n, n);
  for (let r = 0; r < n; ++r)
    i[(e + 1) * e + r] = t[(n + 1) * n + r];
  i[i.length - 1] = 1;
  for (let r = n; r < e; ++r)
    i[(e + 1) * r + r] = 1;
  return i;
}
var hi;
function BO(i, e, t) {
  let n = 1;
  (hi === void 0 || hi.length < t) && (hi = new Uint32Array(t));
  for (let r = 0; r < t; ++r)
    hi[r] = r;
  for (let r = 0; r < t; ++r) {
    const s = e * r;
    let a = r;
    {
      let u = Math.abs(i[s + r]);
      for (let h = r + 1; h < t; ++h) {
        const g = Math.abs(i[s + h]);
        g > u && (u = g, a = h);
      }
    }
    if (r !== a) {
      n *= -1;
      for (let u = 0; u < t; ++u) {
        const h = e * u, g = i[h + r];
        i[h + r] = i[h + a], i[h + a] = g;
      }
      {
        const u = hi[r];
        hi[r] = hi[a], hi[a] = u;
      }
    }
    const l = i[s + r], d = 1 / l;
    n *= l;
    for (let u = 0; u < t; ++u)
      i[e * u + r] *= d;
    i[s + r] = d;
    for (let u = 0; u < t; ++u) {
      if (u === r) continue;
      const h = -i[e * r + u];
      for (let g = 0; g < t; ++g) {
        const v = e * g;
        i[v + u] += h * i[v + r];
      }
      i[e * r + u] = h * d;
    }
  }
  for (let r = 0; r < t; ++r) {
    let s = hi[r];
    for (; s !== r; ) {
      const a = e * r, l = e * s;
      for (let u = 0; u < t; ++u) {
        const h = a + u, g = l + u, v = i[h];
        i[h] = i[g], i[g] = v;
      }
      const d = hi[r] = hi[s];
      hi[s] = s, s = d;
    }
  }
  return n;
}
function wy(i, e, t, n, r) {
  return Sy(i, e, t, n, r, r), BO(i, e, r);
}
function FO(i, e, t, n, r, s) {
  for (let a = 0; a < s; ++a) {
    const l = e * a, d = n * a;
    for (let u = 0; u < r; ++u)
      if (i[l + u] !== t[d + u]) return false;
  }
  return true;
}
function Ar(i, e, t, n, r) {
  for (let s = 0; s < r; ++s) {
    let a = e[t * r + s];
    for (let l = 0; l < r; ++l)
      a += e[t * l + s] * n[l];
    i[s] = a;
  }
  return i;
}
function nL(i, e, t, n, r) {
  for (let s = 0; s < r; ++s) {
    let a = 0;
    for (let l = 0; l < r; ++l)
      a += e[t * l + s] * n[l];
    i[s] = a;
  }
  return i;
}
var UC = {};
var zC;
function UO() {
  if (zC) return UC;
  zC = 1;
  var i = BD();
  return i(i.S, "Math", {
    log10: function(t) {
      return Math.log(t) * Math.LOG10E;
    }
  }), UC;
}
var Qp;
var $C;
function zO() {
  return $C || ($C = 1, UO(), Qp = mR().Math.log10), Qp;
}
var eg;
var GC;
function $O() {
  return GC || (GC = 1, eg = { default: zO(), __esModule: true }), eg;
}
var GO = $O();
var iL = Ws(GO);
var Jd = [
  { prefix: "Y", exponent: 24 },
  { prefix: "Z", exponent: 21 },
  { prefix: "E", exponent: 18 },
  { prefix: "P", exponent: 15 },
  { prefix: "T", exponent: 12 },
  { prefix: "G", exponent: 9 },
  { prefix: "M", exponent: 6 },
  { prefix: "k", exponent: 3 },
  // {prefix: 'h', exponent: 2},
  // {prefix: 'da', exponent: 1},
  { prefix: "", exponent: 0 },
  // {prefix: 'd', exponent: -1},
  // {prefix: 'c', exponent: -2},
  { prefix: "m", exponent: -3 },
  { prefix: "µ", exponent: -6 },
  { prefix: "n", exponent: -9 },
  { prefix: "p", exponent: -12 },
  { prefix: "f", exponent: -15 },
  { prefix: "a", exponent: -18 },
  { prefix: "z", exponent: -21 },
  { prefix: "y", exponent: -24 }
];
var WO = [
  // Parse 'c' for centi, but don't pick it.
  { prefix: "c", exponent: -2 },
  { prefix: "u", exponent: -6 },
  ...Jd
];
var kc = new he();
kc.set("", { unit: "", exponent: 0 });
var HO = new he();
for (const i of WO) {
  const e = i.prefix, t = i.exponent;
  HO.set(t, e);
  for (const n of ["m", "s", "Hz", "rad/s"])
    kc.set(`${e}${n}`, { unit: n, exponent: t });
}
function rL(i) {
  const e = iL(i), t = Jd.length, n = GM(0, t, (r) => Jd[r].exponent <= e);
  return Jd[Math.min(n, t - 1)];
}
function sL(i, e, t = {}) {
  var n = t.precision;
  const r = n === void 0 ? 6 : n;
  var s = t.elide1;
  const a = s === void 0 ? true : s;
  let l = i, d = "";
  if (e !== "") {
    const h = rL(i);
    d = h.prefix, l = Cy(i, -h.exponent);
  }
  if (a && l === 1)
    return { scale: "", unit: e, prefix: d };
  let u;
  if (r != 0) {
    l < 1 || l >= 1e3 ? u = l.toPrecision(r) : u = l.toFixed(r);
    const h = u.indexOf("e");
    let g, v;
    h !== -1 ? (g = u.substring(0, h), v = u.substring(h)) : (g = u, v = "");
    const y = g.match(/.*\.(?:[0-9]*[1-9])?(0+)$/);
    y !== null && (g = g.substring(0, g.length - y[1].length), g.endsWith(".") && (g = g.substring(0, g.length - 1)), u = g + v);
  } else
    u = l.toString();
  return {
    scale: u,
    unit: e,
    prefix: d
  };
}
function ia(i, e, t) {
  var n = sL(i, e, t);
  const r = n.scale, s = n.unit, a = n.prefix;
  return `${r}${a}${s}`;
}
function nc(i) {
  if (i === "")
    return { scale: 1, unit: "" };
  const e = i.match(/^((?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)?([µa-zA-Z]+)?$/);
  if (e === null) return;
  const t = e[1];
  let n = t === void 0 ? 1 : Number(t);
  if (er(n)) return;
  let r = "";
  if (e[2] !== void 0) {
    const s = kc.get(e[2]);
    if (s === void 0)
      return;
    r = s.unit, s.exponent > 0 ? n *= 10 ** s.exponent : n /= 10 ** -s.exponent;
  }
  if (!(n <= 0 || !Lt(n)))
    return { scale: n, unit: r };
}
function WC(i) {
  const e = kc.get(i);
  if (e === void 0)
    throw new Error(`Invalid unit: ${oe(i)}`);
  return e;
}
function Cy(i, e) {
  return e >= 0 ? i * 10 ** e : i / 10 ** -e;
}
function aL(i, e, t) {
  const n = i.length;
  for (let r = 0; r < n; ++r)
    i[r] = e[r] + t[r];
  return i;
}
function Mm(i, e, t) {
  const n = i.length;
  for (let r = 0; r < n; ++r)
    i[r] = e[r] - t[r];
  return i;
}
function qO(i, e, t, n) {
  const r = i.length;
  for (let s = 0; s < r; ++s)
    i[s] = e[s] + t[s] * n;
  return i;
}
function jO(i, e, t) {
  const n = i.length;
  for (let r = 0; r < n; ++r)
    i[r] = e[r] * t;
  return i;
}
function xy(i) {
  let e = 1;
  for (let t = 0, n = i.length; t < n; ++t)
    e *= i[t];
  return e;
}
function JO(i, e, t) {
  const n = i.length;
  for (let r = 0; r < n; ++r)
    i[r] = Math.min(e[r], t[r]);
  return i;
}
var go = new Float32Array(0);
var oL = new Float64Array(0);
var KO = 0;
function to() {
  return ++KO;
}
function YO(i, e) {
  return He(i.lowerBounds, e.lowerBounds) && He(i.upperBounds, e.upperBounds);
}
function XO(i, e) {
  return i === void 0 ? e === void 0 : e === void 0 ? false : i.explicit === e.explicit && He(i.coordinates, e.coordinates) && He(i.labels, e.labels);
}
function ZO(i, e) {
  const t = new he();
  for (let n = 0, r = i.length; n < r; ++n)
    t.set(i[n], e[n]);
  return i = _e(t.keys()), i.sort((n, r) => n - r), e = _e(i, (n) => t.get(n)), { coordinates: i, labels: e };
}
function lL(i) {
  if (i.length === 1) return i[0];
  const e = new he();
  let t = false;
  for (const s of i) {
    s.explicit && (t = true);
    const a = s.coordinates, l = s.labels;
    for (let d = 0, u = a.length; d < u; ++d)
      e.set(a[d], l[d]);
  }
  const n = _e(e.keys());
  n.sort((s, a) => s - a);
  const r = _e(n, (s) => e.get(s));
  return { explicit: t, coordinates: n, labels: r };
}
function HC(i) {
  if (i = i.filter((e) => e !== void 0), i.length !== 0)
    return lL(i);
}
function QO(i, e) {
  return He(i.transform, e.transform) && YO(i.box, e.box);
}
function gu(i, e) {
  return i.valid === e.valid && i.rank === e.rank && He(i.names, e.names) && He(i.ids, e.ids) && He(i.timestamps, e.timestamps) && He(i.units, e.units) && He(i.scales, e.scales) && Sm(i.boundingBoxes, e.boundingBoxes, QO) && Sm(i.coordinateArrays, e.coordinateArrays, XO);
}
function yt(i) {
  const e = i.names, t = i.units, n = i.scales;
  var r = i.valid;
  const s = r === void 0 ? true : r;
  var a = i.rank;
  const l = a === void 0 ? e.length : a;
  var d = i.timestamps;
  const u = d === void 0 ? e.map(() => Number.NEGATIVE_INFINITY) : d;
  var h = i.ids;
  const g = h === void 0 ? e.map((T, I) => -I) : h;
  var v = i.boundingBoxes;
  const y = v === void 0 ? [] : v;
  var C = i.coordinateArrays;
  const w = C === void 0 ? new Array(l) : C;
  var b = i.bounds;
  const E = b === void 0 ? nV(y, l) : b;
  return {
    valid: s,
    rank: l,
    names: e,
    timestamps: u,
    ids: g,
    units: t,
    scales: n,
    boundingBoxes: y,
    bounds: E,
    coordinateArrays: w
  };
}
var Vr = yt({
  valid: false,
  names: [],
  units: [],
  scales: oL,
  boundingBoxes: []
});
var mo = yt({
  valid: true,
  names: [],
  units: [],
  scales: oL,
  boundingBoxes: []
});
function eV(i) {
  var e = Vi(i, 2), t = de(e, 2);
  const n = t[0], r = t[1], s = yn(n), a = Ae(r), l = kc.get(a);
  if (l === void 0) throw new Error(`Invalid unit: ${oe(a)}`);
  return { unit: l.unit, scale: Cy(s, l.exponent) };
}
function mu(i, e = false) {
  if (i === void 0) return Vr;
  me(i);
  const t = Ly(hn(i), e), n = t.length, r = new Array(n), s = new Float64Array(n), a = new Array(n);
  for (let l = 0; l < n; ++l)
    Y(i, t[l], (d) => {
      if (Array.isArray(d)) {
        var u = eV(d);
        const h = u.unit, g = u.scale;
        r[l] = h, s[l] = g;
      } else {
        me(d);
        let h = Y(d, "coordinates", YT), g = Y(d, "labels", bi), v = h.length;
        if (v !== g.length)
          throw new Error(`Length of coordinates array (${v}) does not match length of labels array (${g.length})`);
        r[l] = "", s[l] = 1, a[l] = H({ explicit: true }, ZO(h, g));
      }
    });
  return yt({ valid: false, names: t, units: r, scales: s, coordinateArrays: a });
}
function Nm(i) {
  const e = i.rank;
  if (e === 0) return;
  const t = i.names, n = i.units, r = i.scales, s = i.coordinateArrays, a = {};
  for (let l = 0; l < e; ++l) {
    const d = t[l], u = s[l];
    (u == null ? void 0 : u.explicit) ? a[d] = {
      coordinates: _e(u.coordinates),
      labels: u.labels
    } : a[d] = [r[l], n[l]];
  }
  return a;
}
var Ey = class extends vt {
  constructor() {
    super(Vr);
  }
  toJSON() {
    return Nm(this.value);
  }
  reset() {
    this.value = Vr;
  }
  restoreState(e) {
    this.value = mu(e);
  }
};
function cL(i, e) {
  let t = (i + e) / 2;
  return Lt(t) || (t = Math.min(Math.max(0, i), e)), t;
}
function tV(i, e) {
  const t = e.lowerBounds, n = e.upperBounds, r = i.length;
  for (let s = 0; s < r; ++s)
    i[s] = cL(t[s], n[s]);
  return i;
}
function fa(i) {
  const e = i.lowerBounds.length;
  return { box: i, transform: ks(Float64Array, e, e + 1) };
}
function dL(i, e, t) {
  var n = i.box;
  const r = n.lowerBounds, s = n.upperBounds, a = i.transform, l = r.length, d = t, u = a[d * l + e];
  let h = u, g = u, v = false;
  for (let y = 0; y < l; ++y) {
    let C = a[d * y + e];
    if (C === 0) continue;
    const w = C * r[y], b = C * s[y];
    h += Math.min(w, b), g += Math.max(w, b), v = true;
  }
  if (v)
    return { lower: h, upper: g };
}
function nV(i, e) {
  const t = new Float64Array(e), n = new Float64Array(e);
  t.fill(Number.NEGATIVE_INFINITY), n.fill(Number.POSITIVE_INFINITY);
  for (const r of i)
    for (let s = 0; s < e; ++s) {
      const a = dL(r, s, e);
      if (a === void 0) continue;
      const l = a.lower, d = a.upper;
      t[s] = t[s] === Number.NEGATIVE_INFINITY ? l : Math.min(t[s], l), n[s] = n[s] === Number.POSITIVE_INFINITY ? d : Math.max(n[s], d);
    }
  return { lowerBounds: t, upperBounds: n };
}
function iV(i, e, t) {
  const n = i.transform, r = i.box, s = t.length, a = r.lowerBounds.length, l = new Float64Array((a + 1) * e);
  for (let d = 0; d < s; ++d) {
    const u = t[d];
    if (u !== -1)
      for (let h = 0; h <= a; ++h)
        l[h * e + u] = n[h * s + d];
  }
  return {
    transform: l,
    box: r
  };
}
function uL(i, e) {
  const t = { lowerBounds: Float64Array.of(0), upperBounds: Float64Array.of(1) }, n = new Float64Array(2 * i);
  return n[e] = 1, { transform: n, box: t };
}
function hL(i, e, t) {
  if (e === t) return i;
  const n = i.box, r = n.lowerBounds.length, s = new Float64Array((r + 1) * t);
  return Sy(s, t, i.transform, e, e, r + 1), { box: n, transform: s };
}
function rV(i, e) {
  const t = i.rank, n = i.sourceRank;
  if (t !== e.rank || n !== e.sourceRank) return false;
  const r = i.inputSpace, s = e.inputSpace;
  return !He(s.scales, r.scales) || !He(s.units, r.units) || !He(e.outputSpace.names, i.outputSpace.names) ? false : gL(i.transform, t, i.outputSpace.scales, e.transform, t, e.outputSpace.scales);
}
function ei(i) {
  return {
    rank: i.rank,
    sourceRank: i.rank,
    inputSpace: i,
    outputSpace: i,
    transform: ks(Float64Array, i.rank + 1)
  };
}
function sV(i, e, t, n) {
  let r = i.transform, s = i.box;
  const a = i.box.lowerBounds.length, l = n.length, d = new Float64Array((a + 1) * l);
  for (let u = 0; u < l; ++u) {
    const h = n[u];
    for (let v = 0; v < a; ++v) {
      let y = 0;
      for (let C = 0; C < l; ++C) {
        const w = t[C];
        y += e[(l + 1) * C + u] * r[l * v + C] * (w / h);
      }
      d[l * v + u] = y;
    }
    let g = e[(l + 1) * l + u];
    for (let v = 0; v < l; ++v) {
      const y = t[v];
      g += e[(l + 1) * v + u] * r[l * a + v] * (y / h);
    }
    d[a * l + u] = g;
  }
  return {
    transform: d,
    box: s
  };
}
function fL(i, e, t) {
  return i.boundingBoxes.map((n) => sV(n, e, i.scales, t));
}
function Om(i, e, t) {
  const n = yt({
    valid: i.valid,
    rank: t.rank,
    ids: t.ids,
    names: t.names,
    timestamps: t.timestamps,
    scales: t.scales,
    units: t.units,
    boundingBoxes: fL(i, e, t.scales),
    coordinateArrays: t.coordinateArrays
  });
  return gu(n, t) ? t : n;
}
function ky(i, e = false) {
  if (e) {
    const t = Number(i);
    if (jn(t) && t >= 0) return true;
  }
  return i.match(/^[a-zA-Z][a-zA-Z_0-9]*['^]?$/) !== null;
}
function fh(i, e = false) {
  const t = new Ye();
  for (const n of i) {
    if (!ky(n, e) || t.has(n)) return false;
    t.add(n);
  }
  return true;
}
function Ty(i) {
  const e = i.length, t = new Array(e);
  t.fill(true);
  for (let n = 0; n < e; ++n) {
    const r = i[n];
    if (!ky(r)) {
      t[n] = false;
      continue;
    }
    const s = i.indexOf(r, n + 1);
    s !== -1 && (t[n] = false, t[s] = false);
  }
  return t;
}
function ql(i) {
  return i.endsWith("'");
}
function pL(i) {
  return i.endsWith("'") || i.endsWith("^");
}
function aV(i) {
  return i.endsWith("^");
}
function oV(i) {
  return !pL(i);
}
function lV(i, e, t) {
  const n = new Float64Array(i), r = e.length, s = (r + 1) * r;
  for (let a = 0; a < r; ++a)
    n[s + a] *= e[a] / t[a];
  return n;
}
function gL(i, e, t, n, r, s) {
  if (!FO(i, e + 1, n, r + 1, e, e)) return false;
  for (let a = 0; a < e; ++a) {
    const l = i[(e + 1) * e + a], d = n[(r + 1) * r + a];
    if (l * (t[a] / s[a]) !== d) return false;
  }
  for (let a = e; a < r; ++a)
    if (n[(r + 1) * r + a] !== 0) return false;
  for (let a = e; a < r; ++a) {
    for (let l = 0; l < e; ++l)
      if (n[(r + 1) * l + a] !== 0) return false;
    for (let l = 0; l < r; ++l) {
      const d = n[(r + 1) * a + l];
      if (a === l) {
        if (d !== 1) return false;
      } else if (d !== 0) return false;
    }
  }
  return true;
}
function cV(i, e) {
  if (!e.includes(i)) return i;
  var t = i.match(/^([^']*)('?)$/), n = de(t, 3);
  const r = n[1], s = n[2];
  for (let a = 0; ; ++a) {
    const l = `${r}${a}${s}`;
    if (!e.includes(l)) return l;
  }
}
function dV(i, e) {
  const t = i.inputSpace, n = i.transform, r = t.ids, s = t.rank, a = e.rank, l = e.names, d = e.units, u = e.scales, h = new Array(s);
  h.fill(true);
  const g = [], v = e.ids.map(($, B) => {
    const ue = r.indexOf($);
    return ue !== -1 ? h[ue] = false : g.push(B), ue;
  }), y = i.outputSpace, C = y.names, w = y.units, b = y.scales, E = y.ids, T = y.timestamps, I = y.coordinateArrays, R = h, P = [], L = [], A = new Float64Array(a), M = [], O = [], F = new Array(a);
  let q = 0;
  const U = new Float64Array((a + 1) ** 2);
  U[U.length - 1] = 1;
  for (let $ = 0; $ < s; ++$)
    if (!R[$]) {
      P[q] = C[$], M[q] = E[$], L[q] = w[$], A[q] = b[$], O[q] = T[$], F[q] = I[$];
      for (let B = 0; B < a; ++B) {
        const ue = v[B];
        ue !== -1 && (U[B * (a + 1) + q] = n[ue * (s + 1) + $]);
      }
      U[a * (a + 1) + q] = n[s * (s + 1) + $], ++q;
    }
  for (const $ of g)
    M[q] = to(), P[q] = cV(l[$], P), A[q] = u[$], L[q] = d[$], U[$ * (a + 1) + q] = 1, ++q;
  const V = yt({
    valid: e.valid,
    rank: a,
    names: P,
    ids: M,
    timestamps: O,
    units: L,
    scales: A,
    boundingBoxes: fL(e, U, A),
    coordinateArrays: F
  });
  return {
    rank: a,
    sourceRank: i.sourceRank,
    inputSpace: e,
    outputSpace: V,
    transform: U
  };
}
function qC(i) {
  const e = Om(i.inputSpace, i.transform, i.outputSpace);
  return e === i.outputSpace ? i : {
    rank: i.rank,
    sourceRank: i.sourceRank,
    inputSpace: i.inputSpace,
    transform: i.transform,
    outputSpace: e
  };
}
var jC = class {
  constructor(e, t = false) {
    this.mutableSourceRank = t, this.value_ = void 0, this.changed = new Le(), this.inputSpaceChanged = new Le(), this.defaultTransform = qC(e);
    const n = this;
    this.outputSpace = {
      changed: n.changed,
      get value() {
        return n.value.outputSpace;
      },
      set value(r) {
        const s = n.value;
        if (gu(s.outputSpace, r) || s.rank !== r.rank) return;
        const a = lV(s.transform, s.outputSpace.scales, r.scales);
        n.value_ = {
          sourceRank: s.sourceRank,
          rank: s.rank,
          inputSpace: s.inputSpace,
          outputSpace: Om(s.inputSpace, a, r),
          transform: a
        }, n.changed.dispatch();
      }
    }, this.inputSpace = {
      changed: n.inputSpaceChanged,
      get value() {
        return n.value.inputSpace;
      },
      set value(r) {
        const s = n.value;
        gu(s.inputSpace, r) || (n.value_ = dV(s, r), n.inputSpaceChanged.dispatch(), n.changed.dispatch());
      }
    };
  }
  set value(e) {
    const t = this.value;
    e !== t && (this.value_ = qC(e), e.inputSpace !== t.inputSpace && this.inputSpaceChanged.dispatch(), this.changed.dispatch());
  }
  get value() {
    let e = this.value_;
    return e === void 0 && (e = this.value_ = this.defaultTransform), e;
  }
  reset() {
    this.value_ !== this.defaultTransform && (this.value_ = this.defaultTransform, this.inputSpaceChanged.dispatch(), this.changed.dispatch());
  }
  get defaultInputSpace() {
    return this.defaultTransform.inputSpace;
  }
  get spec() {
    const e = this.value, t = e.rank, n = e.transform, r = e.inputSpace, s = e.outputSpace, a = e.sourceRank, l = this.defaultTransform, d = this.mutableSourceRank, u = l.inputSpace, h = l.rank, g = l.transform, v = l.outputSpace, y = r.units, C = r.scales, w = a === t && He(C, d ? s.scales : u.scales) && He(y, d ? s.units : u.units), b = gL(g, h, v.scales, n, t, s.scales), E = He(v.names, s.names);
    if (!(b && E && w))
      return {
        sourceRank: a,
        transform: b ? void 0 : n,
        outputSpace: e.outputSpace,
        inputSpace: w ? void 0 : r
      };
  }
  set transform(e) {
    const t = this.value, n = t.inputSpace;
    this.value_ = {
      rank: t.rank,
      sourceRank: t.sourceRank,
      inputSpace: n,
      transform: e,
      outputSpace: Om(n, e, t.outputSpace)
    }, this.changed.dispatch();
  }
  set spec(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    if (this.mutableSourceRank) {
      const U = e.inputSpace || e.outputSpace, V = U.rank, $ = yt({
        rank: V,
        names: U.names.map((B, ue) => `${ue}`),
        units: U.units,
        scales: U.scales,
        coordinateArrays: U.coordinateArrays
      });
      this.value = {
        rank: V,
        transform: e.transform || ks(Float64Array, V + 1),
        sourceRank: e.sourceRank,
        outputSpace: e.outputSpace,
        inputSpace: $
      };
      return;
    }
    var t = this.defaultTransform;
    const n = t.inputSpace, r = t.sourceRank, s = t.outputSpace, a = t.transform, l = t.rank, d = e.inputSpace, u = e.sourceRank, h = e.outputSpace, g = e.transform, v = e.outputSpace.rank, y = n.names, C = d !== void 0 ? d.names : y, w = new Array(r);
    for (let U = 0; U < r; ++U) {
      let V = C.indexOf(y[U]);
      V >= u && (V = -1), w[U] = V;
    }
    const b = v - u + r;
    for (let U = u; U < v; ++U)
      w[r + U - u] = U;
    const E = new Float64Array(b), T = new Array(b), I = [];
    for (let U = 0; U < r; ++U) {
      const V = w[U];
      V === -1 || d === void 0 ? (E[U] = n.scales[U], I[U] = n.units[U], T[U] = n.coordinateArrays[U]) : (E[U] = d.scales[V], I[U] = d.units[V], T[U] = HC([n.coordinateArrays[U], d.coordinateArrays[V]]));
    }
    const R = d || h, P = y.slice(0, r), L = s.names.slice(0, r), A = s.coordinateArrays.slice(0, r), M = new Float64Array(b), O = [];
    for (let U = 0; U < b; ++U) {
      const V = w[U];
      V === -1 ? (M[U] = s.scales[U], O[U] = s.units[U], A[U] = s.coordinateArrays[U]) : (L[U] = h.names[V], O[U] = h.units[V], M[U] = h.scales[V], A[U] = h.coordinateArrays[V]);
    }
    if (!fh(L)) {
      this.reset();
      return;
    }
    for (let U = r; U < b; ++U) {
      const V = U - r + u;
      E[U] = R.scales[V], I[U] = R.units[V], P[U] = `${U}`;
    }
    const F = new Float64Array((b + 1) ** 2);
    F[F.length - 1] = 1;
    for (let U = 0; U < b; ++U) {
      const V = w[U];
      let $;
      V === -1 || g === void 0 ? U >= r ? $ = 0 : $ = a[l * (l + 1) + U] * (s.scales[U] / M[U]) : $ = g[v * (v + 1) + V], F[b * (b + 1) + U] = $;
      for (let B = 0; B < b; ++B) {
        const ue = w[B];
        let se;
        V === -1 != (ue === -1) ? se = 0 : V === -1 || g === void 0 ? V >= r || ue >= r ? se = V === ue ? 1 : 0 : se = a[B * (l + 1) + U] : se = g[ue * (v + 1) + V], F[B * (b + 1) + U] = se;
      }
    }
    const q = n.boundingBoxes.map((U) => hL(U, l, b));
    for (let U = r; U < b; ++U)
      q.push(uL(b, U));
    for (let U = 0; U < b; ++U) {
      if (F[b * (b + 1) + U] !== 0) continue;
      let $;
      for (let ue = 0; ue < b; ++ue) {
        const se = F[ue * (b + 1) + U];
        if (se !== 0)
          if (se === 1)
            if ($ === void 0)
              $ = ue;
            else {
              $ = null;
              break;
            }
          else {
            $ = null;
            break;
          }
      }
      if ($ == null) continue;
      let B = T[$];
      B !== void 0 && (B.explicit && (B = H(H({}, B), { explicit: false })), A[U] = HC([B, A[U]]));
    }
    this.value = {
      rank: b,
      transform: F,
      sourceRank: r,
      outputSpace: yt({
        rank: b,
        names: L,
        scales: M,
        units: O,
        coordinateArrays: A
      }),
      inputSpace: yt({
        rank: b,
        names: P,
        scales: E,
        units: I,
        coordinateArrays: T,
        boundingBoxes: q
      })
    };
  }
  toJSON() {
    return yL(this.spec);
  }
  restoreState(e) {
    this.spec = vL(e);
  }
};
function uV(i, e = false) {
  const t = Ae(i);
  if (!ky(t, e))
    throw new Error(`Invalid dimension name: ${oe(t)}`);
  return t;
}
function Ly(i, e = false) {
  const t = Xe(i, (n) => uV(n, e));
  if (!fh(t, e))
    throw new Error(`Invalid dimensions: ${oe(t)}`);
  return t;
}
var Dy = class {
  constructor(e, t) {
    this.combined = e, this.bindings = new Ye(), this.retainCount = 0, this.prevCombined = this.combined.value, this.dimensionRefCounts = new he(), this.handleCombinedChanged = () => {
      this.combined.value !== this.prevCombined && this.update();
    }, this.includeDimensionPredicate_ = t;
  }
  getRenameValidity(e) {
    const t = this.combined.value.names, n = Ty(e), r = e.length;
    for (let s = 0; s < r; ++s) {
      if (!n[s]) continue;
      const a = e[s];
      if (t.includes(a)) continue;
      let l = true;
      for (const d of this.bindings)
        if (d.space.value.names.includes(a)) {
          l = false;
          break;
        }
      n[s] = l;
    }
    return n;
  }
  get includeDimensionPredicate() {
    return this.includeDimensionPredicate_;
  }
  set includeDimensionPredicate(e) {
    this.includeDimensionPredicate_ = e, this.update();
  }
  update() {
    const e = this.combined, t = this.bindings, n = this.retainCount > 0 ? 1 : 0;
    if (t.size === 0 && !n) {
      e.value = Vr;
      return;
    }
    const r = this.includeDimensionPredicate_, s = e.value;
    let a = _e(s.names), l = _e(s.units), d = _e(s.scales), u = _e(s.ids), h = _e(s.timestamps), g = s.names.map(() => n ? 1 : 0);
    const v = [];
    let y = false;
    for (const P of t) {
      const L = P.space.value, A = P.prevValue, M = P.mappedDimensionIds;
      y = y || L.valid;
      const O = L.names, F = L.units, q = L.scales, U = L.ids, V = L.timestamps, $ = [], B = [];
      v.push(B), P.mappedDimensionIds = $, P.prevValue = L;
      const ue = O.length;
      for (let se = 0; se < ue; ++se) {
        const Pe = O[se];
        if (!r(Pe)) continue;
        if (A !== void 0) {
          const ce = U[se], ge = A.ids.indexOf(ce);
          if (ge !== -1) {
            const Ne = M[ge];
            if (Ne !== void 0) {
              const Me = u.indexOf(Ne);
              if (Me !== -1) {
                $[se] = Ne, ++g[Me], B[se] = Me;
                const je = V[se];
                je !== void 0 && !(je <= h[Me]) && (a[Me] = Pe, d[Me] = q[se], l[Me] = F[se], h[Me] = je);
                continue;
              }
            }
          }
        }
        let ae = a.indexOf(Pe);
        if (ae !== -1) {
          $[se] = u[ae], ++g[ae], B[se] = ae;
          continue;
        }
        ae = a.length, B[se] = ae, g[ae] = 1 + n, a[ae] = Pe, l[ae] = F[se], d[ae] = q[se], h[ae] = V[se];
        const Ee = to();
        u[ae] = Ee, $[se] = Ee;
      }
    }
    const C = this.dimensionRefCounts;
    C.clear();
    let w = 0, b = a.length;
    for (const P of t) {
      const L = P.space.value, A = v[w++], M = L.rank, O = _e(L.names), F = _e(L.timestamps), q = Float64Array.from(L.scales), U = _e(L.units);
      for (let V = 0; V < M; ++V) {
        const $ = A[V];
        $ !== void 0 && (U[V] = l[$], q[V] = d[$], F[V] = h[$], O[V] = a[$]);
      }
      for (const V of O) {
        let $ = C.get(V);
        $ === void 0 ? $ = 1 : ++$, C.set(V, $);
      }
      if (!He(U, L.units) || !He(q, L.scales) || !He(O, L.names) || !He(F, L.timestamps)) {
        const V = yt({
          valid: L.valid,
          ids: L.ids,
          scales: q,
          units: U,
          names: O,
          timestamps: F,
          boundingBoxes: L.boundingBoxes,
          coordinateArrays: L.coordinateArrays
        });
        P.prevValue = V, P.space.value = V;
      }
    }
    {
      for (let L = 0; L < b; ++L)
        r(a[L]) || (g[L] = 0);
      const P = (L, A) => g[A] !== 0;
      a = a.filter(P), l = l.filter(P), d = d.filter(P), u = u.filter(P), h = h.filter(P), g = g.filter(P), b = a.length;
    }
    const E = [], T = new Array(b);
    for (let P = 0, L = s.rank; P < L; ++P) {
      const A = s.coordinateArrays[P];
      if (!(A == null ? void 0 : A.explicit)) continue;
      const M = u.indexOf(s.ids[P]);
      M !== -1 && (T[M] = [A]);
    }
    for (const P of t) {
      const L = P.space.value, A = L.rank, M = L.boundingBoxes, O = L.coordinateArrays, F = L.names.map((q) => a.indexOf(q));
      for (const q of M)
        E.push(iV(q, b, F));
      for (let q = 0; q < A; ++q) {
        const U = O[q];
        if (U === void 0) continue;
        const V = F[q], $ = T[V];
        $ === void 0 ? T[V] = [U] : $.push(U);
      }
    }
    const I = new Array(b);
    for (let P = 0; P < b; ++P) {
      const L = T[P];
      L !== void 0 && (I[P] = lL(L));
    }
    const R = yt({
      valid: y,
      ids: u,
      names: a,
      units: l,
      scales: new Float64Array(d),
      boundingBoxes: E,
      coordinateArrays: I
    });
    if (n)
      for (let P = 0; P < b; ++P)
        --g[P];
    gu(s, R) || (this.prevCombined = R, e.value = R);
  }
  retain() {
    return ++this.retainCount, () => {
      --this.retainCount === 0 && this.update();
    };
  }
  bind(e) {
    const t = { space: e, mappedDimensionIds: [], prevValue: void 0 }, n = this.bindings;
    n.size === 0 && this.combined.changed.add(this.handleCombinedChanged), n.add(t);
    const r = e.changed.add(() => {
      e.value !== t.prevValue && this.update();
    }), s = () => {
      r();
      const a = this.bindings;
      a.delete(t), a.size === 0 && this.combined.changed.remove(this.handleCombinedChanged), this.update();
    };
    return this.update(), s;
  }
};
function mL(i, e, t, n, r) {
  const s = r.length, a = new i((s + 1) ** 2);
  a[a.length - 1] = 1;
  for (let l = 0; l < s; ++l) {
    const d = n[l];
    a[(s + 1) * s + l] = e[(t + 1) * t + d];
    for (let u = 0; u < s; ++u) {
      const h = r[u];
      a[(s + 1) * u + l] = e[(t + 1) * h + d];
    }
  }
  return a;
}
function hV(i) {
  if (i === void 0) return;
  const e = new Float64Array(16);
  if (Array.isArray(i))
    if (i.length === 16)
      for (let t = 0; t < 4; ++t)
        for (let n = 0; n < 4; ++n)
          e[t * 4 + n] = Dt(i[n * 4 + t]);
    else {
      Vi(i, 4);
      for (let t = 0; t < 4; ++t) {
        const n = Vi(i[t], 4);
        for (let r = 0; r < 4; ++r)
          e[r * 4 + t] = Dt(n[r]);
      }
    }
  else {
    me(i);
    const t = Wn(), n = ze(), r = wt(1, 1, 1);
    xe(i, "rotation", (a) => {
      ao(t, a), Zl(t, t);
    }), xe(i, "translation", (a) => {
      ao(n, a);
    }), xe(i, "scale", (a) => {
      ao(r, a);
    });
    const s = nt();
    dN(s, t, n, r), e.set(s);
  }
  return {
    sourceRank: 3,
    transform: e,
    outputSpace: yt({
      valid: true,
      names: ["x", "y", "z"],
      units: ["m", "m", "m"],
      scales: Float64Array.of(1e-9, 1e-9, 1e-9)
    }),
    inputSpace: void 0
  };
}
function vL(i) {
  if (i === void 0) return;
  const e = me(i), t = Y(e, "outputDimensions", mu), n = t.rank, r = Y(e, "sourceRank", (l) => {
    if (l === void 0) return n;
    if (!jn(l) || l < 0 || l > n)
      throw new Error(`Expected integer in range [0, ${n}] but received: ${oe(l)}`);
    return l;
  }), s = xe(e, "inputDimensions", (l) => {
    const d = mu(l, true);
    if (d.rank !== n)
      throw new Error(`Expected rank of ${n}, but received rank of: ${d.rank}`);
    return d;
  });
  return { transform: xe(e, "matrix", (l) => {
    const d = new Float64Array((n + 1) ** 2), u = Vi(l, n);
    d[d.length - 1] = 1;
    for (let h = 0; h < n; ++h)
      try {
        const g = Vi(u[h], n + 1);
        for (let v = 0; v <= n; ++v)
          d[(n + 1) * v + h] = Dt(g[v]);
      } catch (g) {
        throw new Error(`Error in row ${h}: ${g.message}`);
      }
    return d;
  }), outputSpace: t, inputSpace: s, sourceRank: r };
}
function yL(i) {
  if (i === void 0) return;
  const e = i.transform, t = i.outputSpace, n = i.inputSpace, r = i.sourceRank;
  let s;
  const a = t.rank;
  if (e !== void 0) {
    s = [];
    for (let l = 0; l < a; ++l) {
      const d = [];
      s[l] = d;
      for (let u = 0; u <= a; ++u)
        d[u] = e[(a + 1) * u + l];
    }
  }
  return {
    sourceRank: r === a ? void 0 : r,
    matrix: s,
    outputDimensions: Nm(t),
    inputDimensions: n === void 0 ? void 0 : Nm(n)
  };
}
function fV(i, e, t) {
  const n = i.box, r = i.transform, s = i.box.lowerBounds.length, a = e.length, l = new Float64Array((s + 1) * a);
  for (let d = 0; d < a; ++d)
    for (let u = 0; u <= s; ++u) {
      const h = e[d];
      l[d + u * a] = r[h + u * t];
    }
  if (!l.every((d) => d === 0))
    return {
      transform: l,
      box: n
    };
}
function Vm(i, e) {
  const t = i.ids, n = i.names, r = i.scales, s = i.units, a = i.timestamps, l = i.coordinateArrays;
  return yt({
    rank: e.length,
    valid: i.valid,
    ids: e.map((d) => t[d]),
    names: e.map((d) => n[d]),
    timestamps: e.map((d) => a[d]),
    scales: Float64Array.from(e, (d) => r[d]),
    units: e.map((d) => s[d]),
    coordinateArrays: e.map((d) => l[d]),
    boundingBoxes: i.boundingBoxes.map((d) => fV(d, e, i.rank)).filter((d) => d !== void 0)
  });
}
function SL(i, e, t) {
  return e === t ? i : Vm(i, HM(i.rank, t, e));
}
function JC(i, e) {
  const t = i.transform, n = i.rank, r = ch(t, n, [e]);
  if (r.length !== 1) return;
  var s = de(r, 1);
  const a = s[0], l = Math.abs(t[(n + 1) * a + e]), d = i.inputSpace;
  return { scale: d.scales[a] * l, unit: d.units[a] };
}
function KC(i, e) {
  var t = i.defaultInputSpace;
  const n = t.scales, r = t.units;
  return e < n.length ? { scale: n[e], unit: r[e] } : void 0;
}
function pV(i) {
  const e = i.rank;
  var t = i.bounds;
  const n = t.lowerBounds, r = t.upperBounds;
  if (n.some((d) => d !== 0))
    throw new Error("Lower bounds of channel coordinate space must all be 0");
  if (r.some((d) => !jn(d) || d <= 0 || d >= 2 ** 32))
    throw new Error("Upper bounds of channel coordinate space must all be positive integers");
  const s = new Uint32Array(r), a = xy(s), l = new Uint32Array(a * e);
  for (let d = 0; d < a; ++d) {
    let u = d;
    for (let h = 0; h < e; ++h) {
      const g = u % s[h];
      u = (u - g) / s[h], l[d * e + h] = g;
    }
  }
  return { channelCoordinateSpace: i, shape: s, numChannels: a, coordinates: l };
}
function tg(i, e, t, n, r, s) {
  const a = t.scales, l = r.scales, d = r.rank, u = e + 1;
  for (let h = 0; h < d; ++h) {
    const g = s[h];
    if (g === -1) continue;
    const v = l[h];
    for (let y = 0; y < e; ++y) {
      const C = n[y], w = a[C];
      i[u * y + g] *= w / v;
    }
  }
}
function gV(i, e, t, n, r = mo) {
  const s = t.inputSpace, a = t.rank, l = t.sourceRank, d = t.outputSpace, u = t.transform, h = s.names, g = d.names;
  let v;
  if (n !== void 0)
    v = _e(n.modelSubspaceDimensionIndices);
  else {
    v = [];
    for (let F = 0; F < l; ++F)
      v[F] = F;
  }
  const y = v.length;
  for (let F = l; F < a; ++F)
    v.push(F);
  const C = ch(t.transform, a, v, true), w = v.length, b = v.map((F) => h[F] || `${F}`), E = C.map((F) => g[F]);
  if (w !== C.length)
    return {
      error: "Rank mismatch between model subspace dimensions (" + b.join(", ") + ") and corresponding layer/global dimensions (" + E.join(", ") + ")"
    };
  let T = mL(Float32Array, u, a, C, v);
  const I = C.map((F) => g[F]), R = e.names.map((F) => I.indexOf(F)), P = i.names.map((F) => I.indexOf(F));
  tg(T, w, s, v, i, P), tg(T, w, s, v, e, R);
  const L = r.names.map((F) => I.indexOf(F));
  tg(T, w, s, v, r, L);
  const A = [], M = r.rank;
  if (n !== void 0) {
    let F = n.subsourceToModelSubspaceTransform;
    y !== w && (F = by(new Float32Array((w + 1) ** 2), w, F, y)), T = hh(new Float32Array((w + 1) ** 2), w + 1, T, w + 1, F, w + 1, w + 1, w + 1, w + 1);
  }
  const O = new Uint32Array(M);
  for (let F = 0; F < M; ++F) {
    const q = r.bounds.lowerBounds[F], U = r.bounds.upperBounds[F];
    if (q !== 0 || !jn(U) || U <= 0 || U >= 2 ** 32)
      return {
        error: `Channel dimension ${r.names[F]} must have lower bound of 0 and positive integer upper bound`
      };
    O[F] = U;
    const V = L[F];
    let $ = -1;
    if (V !== -1)
      for (let B = 0; B < w; ++B) {
        const ue = T[V + B * (w + 1)];
        if (ue !== 0) {
          if (ue !== 1 || $ !== -1)
            return {
              error: `Channel dimension ${E[V]} must map to a single source dimension`
            };
          $ = B;
        }
      }
    A[F] = $;
  }
  return {
    rank: w,
    unpaddedRank: y,
    modelDimensionNames: b,
    layerDimensionNames: E,
    localToRenderLayerDimensions: R,
    globalToRenderLayerDimensions: P,
    channelToRenderLayerDimensions: L,
    modelToRenderLayerTransform: T,
    channelToModelDimensions: A,
    channelSpaceShape: O
  };
}
function mV(i, e) {
  return i === e ? true : i.error !== void 0 || e.error !== void 0 ? false : He(i.modelDimensionNames, e.modelDimensionNames) && He(i.layerDimensionNames, e.layerDimensionNames) && He(i.globalToRenderLayerDimensions, e.globalToRenderLayerDimensions) && He(i.localToRenderLayerDimensions, e.localToRenderLayerDimensions) && He(i.channelToRenderLayerDimensions, e.channelToRenderLayerDimensions) && He(i.modelToRenderLayerTransform, e.modelToRenderLayerTransform) && He(i.channelSpaceShape, e.channelSpaceShape);
}
function bL(i, e, t, n, r) {
  return wi((s, a, l, d) => gV(s, a, l, n, d), [i, e, t, r === void 0 ? ta(void 0) : r], mV);
}
function vV(i, e, t, n) {
  const r = t.globalToRenderLayerDimensions;
  for (let s = 0; s < 3; ++s) {
    let a = 0;
    const l = n[s];
    if (l !== -1) {
      const d = r[l];
      d !== -1 && (a = e[d]);
    }
    i[s] = a;
  }
}
function yV(i, e, t, n) {
  const r = t.globalToRenderLayerDimensions;
  for (let s = 0; s < 3; ++s) {
    const a = n[s];
    if (a !== -1) {
      const l = r[a];
      l !== -1 && (i[l] = e[s]);
    }
  }
}
function wL(i, e) {
  const t = i.rank, n = i.unpaddedRank;
  let r;
  n !== t && e !== void 0 && (e = by(new Float32Array((t + 1) ** 2), t, e, n)), e !== void 0 ? (r = new Float32Array((t + 1) * (t + 1)), hh(r, t + 1, i.modelToRenderLayerTransform, t + 1, e, t + 1, t + 1, t + 1, t + 1)) : r = i.modelToRenderLayerTransform;
  const s = new Float32Array((t + 1) * (t + 1)), a = wy(s, t + 1, r, t + 1, t + 1);
  if (a === 0)
    throw new Error("Transform is singular");
  const l = i.globalToRenderLayerDimensions, d = i.localToRenderLayerDimensions, u = i.channelToRenderLayerDimensions, h = l.length, g = d.length, v = h + g, y = new Float32Array((v + 1) * t);
  for (let P = 0; P < t; ++P) {
    for (let L = 0; L < h; ++L) {
      const A = l[L];
      A !== -1 && (y[P + L * t] = s[P + A * (t + 1)]);
    }
    for (let L = 0; L < g; ++L) {
      const A = d[L];
      A !== -1 && (y[P + (h + L) * t] = s[P + A * (t + 1)]);
    }
    y[P + v * t] = s[P + t * (t + 1)];
  }
  const C = u.length;
  let w = new Array(C);
  const b = [];
  for (let P = 0; P < C; ++P) {
    const L = u[P];
    let A = -1;
    if (L !== -1) {
      for (let M = 0; M < t; ++M) {
        const O = r[L + M * (t + 1)];
        if (O !== 0) {
          if (O !== 1 || A !== -1)
            throw new Error(`Channel dimension ${i.layerDimensionNames[L]} must map with stride 1 to a single data chunk dimensions`);
          A = M;
        }
      }
      if (A !== -1) {
        if (r[L + t * (t + 1)] !== 0)
          throw new Error(`Channel dimension ${i.layerDimensionNames[L]} must have an offset of 0 in the chunk coordinate space`);
        b.push(A);
      }
    }
    w[P] = A;
  }
  const E = i.channelSpaceShape, T = xy(E), I = b.length, R = new Uint32Array(T * I);
  for (let P = 0; P < T; ++P) {
    let L = P, A = 0;
    for (let M = 0; M < C; ++M) {
      const O = L % E[M];
      L = (L - O) / E[M], w[M] !== -1 && (R[P * I + A] = O, ++A);
    }
  }
  return {
    layerRank: t,
    modelTransform: i,
    chunkToLayerTransform: r,
    layerToChunkTransform: s,
    chunkToLayerTransformDet: a,
    combinedGlobalLocalRank: v,
    combinedGlobalLocalToChunkTransform: y,
    channelToChunkDimensionIndices: w,
    chunkChannelDimensionIndices: b,
    numChannels: T,
    chunkChannelCoordinates: R,
    channelSpaceShape: E
  };
}
function CL(i, e) {
  const t = i.globalToRenderLayerDimensions, n = [], r = [];
  for (let s = 0; s < 3; ++s) {
    const a = e[s];
    if (a == -1) continue;
    const l = t[a];
    r.push(l), l !== -1 && n.push(l);
  }
  for (let s = r.length; s < 3; ++s)
    r[s] = -1;
  return { layerDisplayDimensionIndices: n, displayToLayerDimensionIndices: r };
}
function xL(i, e) {
  const t = i.chunkToLayerTransform, n = i.modelTransform, r = n.rank, s = e.layerDisplayDimensionIndices, a = e.displayToLayerDimensionIndices, l = s.length, d = ch(t, r, s);
  if (d.length !== l) {
    const g = n.modelDimensionNames, v = n.layerDimensionNames;
    throw new Error(`Rank mismatch between displayed layer dimensions (${_e(s, (y) => v[y]).join(", ")}) and corresponding chunk dimensions (${_e(d, (y) => g[y]).join(", ")})`);
  }
  const u = nt();
  for (let g = 0; g < 3; ++g) {
    const v = a[g];
    if (v !== -1) {
      for (let y = 0; y < l; ++y) {
        const C = d[y];
        u[y * 4 + g] = t[C * (r + 1) + v];
      }
      u[12 + g] = t[r * (r + 1) + v];
    }
  }
  const h = nt();
  ys(h, u);
  for (let g = d.length; g < 3; ++g)
    d[g] = -1;
  return {
    modelTransform: i.modelTransform,
    chunkTransform: i,
    displaySubspaceModelMatrix: u,
    displaySubspaceInvModelMatrix: h,
    chunkDisplayDimensionIndices: d,
    numChunkDisplayDims: l
  };
}
function ic(i, e, t, n, r) {
  const s = e.length, a = t.length, l = i.length;
  let d = true;
  for (let u = 0; u < n; ++u) {
    let h = u, g = 0;
    for (let v = 0; v < s; ++v)
      g += r[h + v * n] * e[v];
    h += s * n;
    for (let v = 0; v < a; ++v)
      g += r[h + v * n] * t[v];
    g += r[h + a * n], u < l ? i[u] = g : (g < 0 || g >= 1) && (d = false);
  }
  return d;
}
function SV(i, e, t) {
  i.fill(0), i[15] = 1;
  let n = true;
  const r = e.displayDimensionIndices, s = t.globalToRenderLayerDimensions, a = t.modelToRenderLayerTransform, l = t.rank;
  for (let d = 0; d < 3; ++d) {
    const u = r[d];
    if (u === -1) {
      n = false;
      continue;
    }
    const h = s[u];
    if (h === -1) {
      n = false;
      continue;
    }
    i[d + 12] = a[h + l * (l + 1)];
    for (let g = 0; g < 3; ++g)
      i[d + 4 * g] = a[h + (l + 1) * g];
  }
  if (!n) {
    const d = e.globalDimensionNames, u = _e(r.filter((h) => h !== -1), (h) => d[h]).join(", ");
    throw new Error(`Transform from model dimensions (${t.modelDimensionNames.join(", ")}) to display dimensions (${u}) does not have full rank`);
  }
}
var ng;
var YC;
function bV() {
  return YC || (YC = 1, WUn(), ng = mR().Object.getOwnPropertySymbols), ng;
}
var ig;
var XC;
function wV() {
  return XC || (XC = 1, ig = { default: bV(), __esModule: true }), ig;
}
var CV = wV();
var ZC = Ws(CV);
var xV = jmt();
var zi = Ws(xV);
var QC = {};
var ex;
function EV() {
  if (ex) return QC;
  ex = 1;
  var i = yD(), e = tBt().f;
  return eT()("getOwnPropertyDescriptor", function() {
    return function(n, r) {
      return e(i(n), r);
    };
  }), QC;
}
var rg;
var tx;
function kV() {
  if (tx) return rg;
  tx = 1, EV();
  var i = mR().Object;
  return rg = function(t, n) {
    return i.getOwnPropertyDescriptor(t, n);
  }, rg;
}
var sg;
var nx;
function TV() {
  return nx || (nx = 1, sg = { default: kV(), __esModule: true }), sg;
}
var LV = TV();
var $i = Ws(LV);
var kt;
(function(i) {
  i[i.GPU_MEMORY = 0] = "GPU_MEMORY", i[i.SYSTEM_MEMORY = 1] = "SYSTEM_MEMORY", i[i.SYSTEM_MEMORY_WORKER = 2] = "SYSTEM_MEMORY_WORKER", i[i.DOWNLOADING = 3] = "DOWNLOADING", i[i.QUEUED = 4] = "QUEUED", i[i.NEW = 5] = "NEW", i[i.FAILED = 6] = "FAILED", i[i.EXPIRED = 7] = "EXPIRED";
})(kt || (kt = {}));
var EL = 8;
var xr;
(function(i) {
  i[i.FIRST_TIER = 0] = "FIRST_TIER", i[i.FIRST_ORDERED_TIER = 0] = "FIRST_ORDERED_TIER", i[i.VISIBLE = 0] = "VISIBLE", i[i.PREFETCH = 1] = "PREFETCH", i[i.LAST_ORDERED_TIER = 1] = "LAST_ORDERED_TIER", i[i.RECENT = 2] = "RECENT", i[i.LAST_TIER = 2] = "LAST_TIER";
})(xr || (xr = {}));
var kL = 3;
var vu;
(function(i) {
  i[i.totalTime = 0] = "totalTime", i[i.totalChunks = 1] = "totalChunks";
})(vu || (vu = {}));
var Er;
(function(i) {
  i[i.numChunks = 0] = "numChunks", i[i.systemMemoryBytes = 1] = "systemMemoryBytes", i[i.gpuMemoryBytes = 2] = "gpuMemoryBytes";
})(Er || (Er = {}));
var ds = 3;
function $s(i, e) {
  return i * kL + e;
}
function ix(i) {
  return EL * kL * ds + i;
}
var DV = "ChunkQueueManager";
var IV = "ChunkManager";
var PV = "ChunkSource.invalidate";
var RV = "ChunkQueueManager.requestChunkStatistics";
var AV = "ChunkManager.chunkLayerStatistics";
var Iy = class {
  constructor() {
    this.numVisibleChunksNeeded = 0, this.numVisibleChunksAvailable = 0, this.numPrefetchChunksNeeded = 0, this.numPrefetchChunksAvailable = 0;
  }
};
function Ct(i) {
  let e = -1;
  return H(() => {
    e === -1 && (e = requestAnimationFrame(() => {
      e = -1, i();
    }));
  }, { flush: () => {
    e !== -1 && (e = -1, i());
  }, cancel: () => {
    e !== -1 && (cancelAnimationFrame(e), e = -1);
  } });
}
var TL = class {
  constructor() {
    this.map = new he();
  }
  /**
   * If getter throws an exception, no value is added.
   */
  get(e, t) {
    let n = this.map, r = n.get(e);
    return r === void 0 ? (r = t(), r.registerDisposer(() => {
      n.delete(e);
    }), n.set(e, r)) : r.addRef(), r;
  }
};
var LL = class extends TL {
  get(e, t) {
    return typeof e != "string" && (e = si(e)), super.get(e, t);
  }
  getUncounted(e, t) {
    return this.get(e, () => new hT(t())).value;
  }
};
function _V(i) {
  let e = {
    antialias: false,
    stencil: true
  }, t = i.getContext("webgl2", e);
  if (t == null)
    throw new Error("WebGL not supported.");
  t.memoize = new TL(), t.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), t.max3dTextureSize = t.getParameter(t.MAX_3D_TEXTURE_SIZE), t.maxTextureImageUnits = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), t.tempTextureUnit = t.maxTextureImageUnits - 1;
  for (const n of ["EXT_color_buffer_float"])
    if (!t.getExtension(n))
      throw new Error(`${n} extension not available`);
  for (const n of [
    // Some versions of Firefox 67.0 seem to require this extension being added in addition
    // to EXT_color_buffer_float, despite the note here indicating it is unnecessary:
    // https://developer.mozilla.org/en-US/docs/Web/API/EXT_float_blend
    //
    // See https://github.com/google/neuroglancer/issues/140
    "EXT_float_blend"
  ])
    t.getExtension(n);
  return t;
}
var Py = class {
  constructor() {
    this.width = 0, this.height = 0, this.logicalWidth = 0, this.logicalHeight = 0, this.visibleLeftFraction = 0, this.visibleTopFraction = 0, this.visibleWidthFraction = 0, this.visibleHeightFraction = 0;
  }
};
function DL(i, e) {
  const t = 1 / i.visibleWidthFraction, n = 1 / i.visibleHeightFraction, r = -1 - (-1 + 2 * i.visibleLeftFraction) * t;
  let s = -1 - (-1 + 2 * i.visibleTopFraction) * n;
  s = -s, e[0] = e[0] * t + e[3] * r, e[4] = e[4] * t + e[7] * r, e[8] = e[8] * t + e[11] * r, e[12] = e[12] * t + e[15] * r, e[1] = e[1] * n + e[3] * s, e[5] = e[5] * n + e[7] * s, e[9] = e[9] * n + e[11] * s, e[13] = e[13] * n + e[15] * s;
}
function IL(i, e) {
  return i.width === e.width && i.height === e.height && i.logicalWidth === e.logicalWidth && i.logicalHeight === e.logicalHeight && i.visibleLeftFraction === e.visibleLeftFraction && i.visibleTopFraction === e.visibleTopFraction;
}
var PL = class extends X {
  constructor(e, t, n) {
    super(), this.context = e, this.element = t, this.visibility = n, this.boundsGeneration = -1, this.canvasRelativeClippedLeft = 0, this.canvasRelativeClippedTop = 0, this.canvasRelativeLogicalLeft = 0, this.canvasRelativeLogicalTop = 0, this.renderViewport = new Py(), this.boundsObserversRegistered = false, this.gl = e.gl, e.addPanel(this);
  }
  scheduleRedraw() {
    this.visible && this.context.scheduleRedraw();
  }
  ensureBoundsUpdated() {
    const e = this.context;
    e.ensureBoundsUpdated();
    const t = e.boundsGeneration;
    if (t === this.boundsGeneration) return;
    this.boundsGeneration = t;
    const n = this.element;
    !this.boundsObserversRegistered && e.monitorPanel(n) && (this.boundsObserversRegistered = true);
    const r = n.getBoundingClientRect(), s = e.container, a = e.canvasRect, l = e.canvas, d = l.width, u = l.height, h = d / a.width, g = u / a.height, v = a.left, y = a.top;
    let C = this.canvasRelativeLogicalLeft = Math.round((r.left - v) * h + n.clientLeft), w = this.canvasRelativeLogicalTop = Math.round((r.top - y) * g + n.clientTop), b = n.clientWidth, E = n.clientHeight, T = C + b, I = w + E, R = w, P = C, L = T, A = I;
    for (let q = n.parentElement; q !== null && q !== s; q = q.parentElement) {
      const U = q.getBoundingClientRect();
      U.x === 0 && U.y === 0 && U.width === 0 && U.height === 0 || (P = Math.max(P, (U.left - v) * h), R = Math.max(R, (U.top - y) * g), L = Math.min(L, (U.right - v) * h), A = Math.min(A, (U.bottom - y) * g));
    }
    R = this.canvasRelativeClippedTop = Math.round(Math.max(R, 0)), P = this.canvasRelativeClippedLeft = Math.round(Math.max(P, 0)), L = Math.round(Math.min(L, d)), A = Math.round(Math.min(A, u));
    const M = this.renderViewport, O = M.width = Math.max(0, L - P), F = M.height = Math.max(0, A - R);
    M.logicalWidth = b, M.logicalHeight = E, M.visibleLeftFraction = (P - C) / b, M.visibleTopFraction = (R - w) / E, M.visibleWidthFraction = O / b, M.visibleHeightFraction = F / E;
  }
  // Sets the viewport to the clipped viewport.  Any drawing must take
  // `visible{Left,Top,Width,Height}Fraction` into account.  setGLClippedViewport() {
  setGLClippedViewport() {
    const e = this.gl, t = this.canvasRelativeClippedTop, n = this.canvasRelativeClippedLeft;
    var r = this.renderViewport;
    const s = r.width, a = r.height, l = t + a;
    e.enable(WebGL2RenderingContext.SCISSOR_TEST);
    let d = this.context.canvas.height - l;
    e.viewport(n, d, s, a), e.scissor(n, d, s, a);
  }
  // Sets the viewport to the logical viewport, using the scissor test to constrain drawing to the
  // clipped viewport.  Drawing does not need to take `visible{Left,Top,Width,Height}Fraction` into
  // account.
  setGLLogicalViewport() {
    const e = this.gl;
    var t = this.renderViewport;
    const n = t.width, r = t.height, s = t.logicalWidth, a = t.logicalHeight, l = this.context.canvas.height;
    e.enable(WebGL2RenderingContext.SCISSOR_TEST), e.viewport(this.canvasRelativeLogicalLeft, l - (this.canvasRelativeLogicalTop + a), s, a), e.scissor(this.canvasRelativeClippedLeft, l - (this.canvasRelativeClippedTop + r), n, r);
  }
  disposed() {
    this.boundsObserversRegistered && this.context.unmonitorPanel(this.element), this.context.removePanel(this), super.disposed();
  }
  get visible() {
    return this.visibility.visible;
  }
  getDepthArray() {
  }
  get shouldDraw() {
    if (!this.visible) return false;
    const e = this.element;
    return !(e.clientWidth === 0 || e.clientHeight === 0 || e.offsetWidth === 0 || e.offsetHeight === 0);
  }
  // Returns a number that determine the order in which panels are drawn. This is used by CdfPanel
  // to ensure it is drawn after other panels that update the histogram.
  //
  // A higher number -> later draw.
  get drawOrder() {
    return 0;
  }
};
var RL = class extends PL {
  constructor(e, t, n) {
    super(e, t, n), this.canvas = document.createElement("canvas"), this.canvasRenderingContext = this.canvas.getContext("2d");
    const r = this.canvas;
    t.appendChild(r), t.style.position = "relative", r.style.position = "absolute", r.style.left = "0", r.style.right = "0", r.style.top = "0", r.style.bottom = "0";
  }
  draw() {
    this.drawIndirect();
    const e = this.renderViewport, t = this.canvas, n = e.logicalWidth, r = e.logicalHeight;
    t.width = n, t.height = r;
    const s = this.canvasRenderingContext;
    s == null ? void 0 : s.drawImage(this.context.canvas, this.canvasRelativeLogicalLeft, this.canvasRelativeLogicalTop, n, r, 0, 0, n, r);
  }
};
var MV = class extends fn {
  constructor() {
    super(Float64Array.of(0, 0, 1, 1), (e) => lt(new Float64Array(4), e, gy));
  }
  toJSON() {
    const e = this.value;
    var t = de(e, 4);
    const n = t[0], r = t[1], s = t[2], a = t[3];
    if (!(n === 0 && r == 0 && s === 1 && a === 1))
      return _e(e);
  }
};
var NV = class extends X {
  constructor(e) {
    super(), this.container = e, this.canvas = document.createElement("canvas"), this.updateStarted = new Le(), this.updateFinished = new Le(), this.changed = this.updateFinished, this.panels = new Ye(), this.resizeGeneration = 0, this.boundsGeneration = -1, this.orderedPanels = [], this.frameNumber = 0, this.panelAncestors = new he(), this.resizeCallback = () => {
      ++this.resizeGeneration, this.scheduleRedraw();
    }, this.resizeObserver = new ResizeObserver(this.resizeCallback), this.scheduleRedraw = this.registerCancellable(Ct(() => this.draw()));
    const t = this.canvas, n = this.resizeObserver;
    e.style.position = "relative", t.style.position = "absolute", t.style.top = "0px", t.style.left = "0px", t.style.width = "100%", t.style.height = "100%", t.style.zIndex = "0", n.observe(t), e.appendChild(t), this.registerEventListener(t, "webglcontextlost", (r) => {
      console.log(`Lost WebGL context: ${r.statusMessage}`), r.preventDefault();
    }), this.registerEventListener(t, "webglcontextrestored", () => {
      console.log("WebGL context restored"), window.location.reload();
    }), this.gl = _V(t);
  }
  monitorPanel(e) {
    const t = this.panelAncestors, n = this.container;
    if (!n.contains(e)) return false;
    for (; e !== n; ) {
      let r = t.get(e);
      if (r !== void 0) {
        ++r.count;
        break;
      }
      const s = e.parentElement;
      r = { parent: s, count: 1 }, t.set(e, r), e.addEventListener("scroll", this.resizeCallback, { capture: true }), this.resizeObserver.observe(e), e = s;
    }
    return true;
  }
  unmonitorPanel(e) {
    const t = this.panelAncestors, n = this.container;
    for (; e !== n; ) {
      const r = t.get(e);
      if (r.count !== 1) {
        --r.count;
        break;
      }
      e.removeEventListener("scroll", this.resizeCallback, { capture: true }), this.resizeObserver.unobserve(e), t.delete(e), e = r.parent;
    }
  }
  applyWindowedViewportToElement(e, t) {
    var n = de(t, 4);
    const r = n[0], s = n[1], a = n[2], l = n[3], d = 1 / a, u = 1 / l;
    e.style.position = "absolute", e.style.top = `${-u * s * 100}%`, e.style.left = `${-d * r * 100}%`, e.style.width = `${d * 100}%`, e.style.height = `${u * 100}%`, ++this.resizeGeneration, this.scheduleRedraw();
  }
  isReady() {
    for (const e of this.panels)
      if (e.visible && !e.isReady())
        return false;
    return true;
  }
  /**
   * Returns a child element that overlays the canvas.
   */
  makeCanvasOverlayElement() {
    const e = document.createElement("div");
    return e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.style.width = "100%", e.style.height = "100%", e.style.zIndex = "2", this.container.appendChild(e), e;
  }
  disposed() {
    this.orderedPanels.length = 0, this.resizeObserver.disconnect();
  }
  addPanel(e) {
    this.panels.add(e), this.orderedPanels.length = 0, ++this.resizeGeneration, this.scheduleRedraw();
  }
  removePanel(e) {
    this.panels.delete(e), this.orderedPanels.length = 0, ++this.resizeGeneration, this.scheduleRedraw();
  }
  ensureBoundsUpdated() {
    const e = this.resizeGeneration;
    if (this.boundsGeneration === e) return;
    const t = this.canvas;
    t.width = t.offsetWidth, t.height = t.offsetHeight, this.canvasRect = t.getBoundingClientRect(), this.boundsGeneration = e;
  }
  draw() {
    ++this.frameNumber, this.updateStarted.dispatch();
    let e = this.gl;
    this.ensureBoundsUpdated(), this.gl.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT);
    const t = this.orderedPanels, n = this.panels;
    t.length !== n.size && (t.push(...n), t.sort((r, s) => r.drawOrder - s.drawOrder));
    for (const r of t) {
      if (!r.shouldDraw) continue;
      r.ensureBoundsUpdated();
      const s = r.renderViewport;
      s.width === 0 || s.height === 0 || r.draw();
    }
    e.disable(e.SCISSOR_TEST), this.gl.clearColor(1, 1, 1, 1), this.gl.colorMask(false, false, false, true), e.clear(e.COLOR_BUFFER_BIT), this.gl.colorMask(true, true, true, true), this.updateFinished.dispatch();
  }
  getDepthArray() {
    var e = this.canvas;
    const t = e.width, n = e.height, r = new Float32Array(t * n);
    for (const a of this.panels) {
      if (!a.shouldDraw) continue;
      const l = a.getDepthArray();
      if (l === void 0) continue;
      const d = a.canvasRelativeClippedTop, u = a.canvasRelativeClippedLeft;
      var s = a.renderViewport;
      const h = s.width, g = s.height;
      for (let v = 0; v < g; ++v) {
        const y = (g - 1 - v) * h;
        r.set(l.subarray(y, y + h), (d + v) * h + u);
      }
    }
    return r;
  }
};
var AL = class extends Py {
  constructor() {
    super(...arguments), this.globalPosition = go, this.projectionMat = nt(), this.viewMatrix = nt(), this.invViewMatrix = nt(), this.viewProjectionMat = nt(), this.invViewProjectionMat = nt();
  }
};
function OV(i, e) {
  return i.displayDimensionRenderInfo === e.displayDimensionRenderInfo && IL(i, e) && He(i.globalPosition, e.globalPosition) && He(i.projectionMat, e.projectionMat) && He(i.viewMatrix, e.viewMatrix);
}
function _L(i) {
  const e = i.viewMatrix, t = i.viewProjectionMat;
  ys(e, i.invViewMatrix), vn(t, i.projectionMat, e), ys(i.invViewProjectionMat, t);
}
var VV = "rendered_view.addLayer";
var BV = "rendered_view.removeLayer";
var FV = "SharedProjectionParameters";
var UV = "SharedProjectionParameters.changed";
var ar;
(function(i) {
  i[i.info = 0] = "info", i[i.warning = 1] = "warning", i[i.error = 2] = "error";
})(ar || (ar = {}));
var Uo = class {
  constructor() {
    this.changed = new Le(), this.messages = [], this.children = [];
  }
  addMessage(e) {
    this.messages.push(e), this.changed.dispatch();
  }
  clearMessages() {
    const e = this.messages;
    e.length !== 0 && (e.length = 0, this.changed.dispatch());
  }
  isEmpty() {
    return this.messages.length === 0 && !this.children.some((e) => !e.isEmpty());
  }
  addChild(e) {
    return this.children.push(e), e.changed.add(this.changed.dispatch), e.isEmpty() || this.changed.dispatch(), () => {
      const t = this.children;
      t.splice(t.indexOf(e), 1), e.changed.remove(this.changed.dispatch), e.isEmpty() || this.changed.dispatch();
    };
  }
  *[qn]() {
    yield* this.messages;
    for (const e of this.children)
      yield* e;
  }
};
var rx = {};
var ag;
var sx;
function ML() {
  if (sx) return ag;
  sx = 1;
  var i = ZP(), e = sUn(), t = bD()("species");
  return ag = function(n, r) {
    var s = i(n).constructor, a;
    return s === void 0 || (a = i(s)[t]) == null ? r : e(a);
  }, ag;
}
var og;
var ax;
function zV() {
  return ax || (ax = 1, og = function(i, e, t) {
    var n = t === void 0;
    switch (e.length) {
      case 0:
        return n ? i() : i.call(t);
      case 1:
        return n ? i(e[0]) : i.call(t, e[0]);
      case 2:
        return n ? i(e[0], e[1]) : i.call(t, e[0], e[1]);
      case 3:
        return n ? i(e[0], e[1], e[2]) : i.call(t, e[0], e[1], e[2]);
      case 4:
        return n ? i(e[0], e[1], e[2], e[3]) : i.call(t, e[0], e[1], e[2], e[3]);
    }
    return i.apply(t, e);
  }), og;
}
var lg;
var ox;
function NL() {
  if (ox) return lg;
  ox = 1;
  var i = Hmt(), e = zV(), t = FUn(), n = Pmt(), r = pR(), s = r.process, a = r.setImmediate, l = r.clearImmediate, d = r.MessageChannel, u = r.Dispatch, h = 0, g = {}, v = "onreadystatechange", y, C, w, b = function() {
    var T = +this;
    if (g.hasOwnProperty(T)) {
      var I = g[T];
      delete g[T], I();
    }
  }, E = function(T) {
    b.call(T.data);
  };
  return (!a || !l) && (a = function(I) {
    for (var R = [], P = 1; arguments.length > P; ) R.push(arguments[P++]);
    return g[++h] = function() {
      e(typeof I == "function" ? I : Function(I), R);
    }, y(h), h;
  }, l = function(I) {
    delete g[I];
  }, Ymt()(s) == "process" ? y = function(T) {
    s.nextTick(i(b, T, 1));
  } : u && u.now ? y = function(T) {
    u.now(i(b, T, 1));
  } : d ? (C = new d(), w = C.port2, C.port1.onmessage = E, y = i(w.postMessage, w, 1)) : r.addEventListener && typeof postMessage == "function" && !r.importScripts ? (y = function(T) {
    r.postMessage(T + "", "*");
  }, r.addEventListener("message", E, false)) : v in n("script") ? y = function(T) {
    t.appendChild(n("script"))[v] = function() {
      t.removeChild(this), b.call(T);
    };
  } : y = function(T) {
    setTimeout(i(b, T, 1), 0);
  }), lg = {
    set: a,
    clear: l
  }, lg;
}
var cg;
var lx;
function $V() {
  if (lx) return cg;
  lx = 1;
  var i = pR(), e = NL().set, t = i.MutationObserver || i.WebKitMutationObserver, n = i.process, r = i.Promise, s = Ymt()(n) == "process";
  return cg = function() {
    var a, l, d, u = function() {
      var y, C;
      for (s && (y = n.domain) && y.exit(); a; ) {
        C = a.fn, a = a.next;
        try {
          C();
        } catch (w) {
          throw a ? d() : l = void 0, w;
        }
      }
      l = void 0, y && y.enter();
    };
    if (s)
      d = function() {
        n.nextTick(u);
      };
    else if (t && !(i.navigator && i.navigator.standalone)) {
      var h = true, g = document.createTextNode("");
      new t(u).observe(g, { characterData: true }), d = function() {
        g.data = h = !h;
      };
    } else if (r && r.resolve) {
      var v = r.resolve(void 0);
      d = function() {
        v.then(u);
      };
    } else
      d = function() {
        e.call(i, u);
      };
    return function(y) {
      var C = { fn: y, next: void 0 };
      l && (l.next = C), a || (a = C, d()), l = C;
    };
  }, cg;
}
var dg = {};
var cx;
function Ry() {
  if (cx) return dg;
  cx = 1;
  var i = sUn();
  function e(t) {
    var n, r;
    this.promise = new t(function(s, a) {
      if (n !== void 0 || r !== void 0) throw TypeError("Bad Promise constructor");
      n = s, r = a;
    }), this.resolve = i(n), this.reject = i(r);
  }
  return dg.f = function(t) {
    return new e(t);
  }, dg;
}
var ug;
var dx;
function OL() {
  return dx || (dx = 1, ug = function(i) {
    try {
      return { e: false, v: i() };
    } catch (e) {
      return { e: true, v: e };
    }
  }), ug;
}
var hg;
var ux;
function GV() {
  if (ux) return hg;
  ux = 1;
  var i = pR(), e = i.navigator;
  return hg = e && e.userAgent || "", hg;
}
var fg;
var hx;
function VL() {
  if (hx) return fg;
  hx = 1;
  var i = ZP(), e = pD(), t = Ry();
  return fg = function(n, r) {
    if (i(n), e(r) && r.constructor === n) return r;
    var s = t.f(n), a = s.resolve;
    return a(r), s.promise;
  }, fg;
}
var fx;
function WV() {
  if (fx) return rx;
  fx = 1;
  var i = Vre(), e = pR(), t = Hmt(), n = th(), r = BD(), s = pD(), a = sUn(), l = ih(), d = Vo(), u = ML(), h = NL().set, g = $V()(), v = Ry(), y = OL(), C = GV(), w = VL(), b = "Promise", E = e.TypeError, T = e.process, I = T && T.versions, R = I && I.v8 || "", P = e[b], L = n(T) == "process", A = function() {
  }, M, O, F, q, U = O = v.f, V = !!function() {
    try {
      var ce = P.resolve(1), ge = (ce.constructor = {})[bD()("species")] = function(Ne) {
        Ne(A, A);
      };
      return (L || typeof PromiseRejectionEvent == "function") && ce.then(A) instanceof ge && R.indexOf("6.6") !== 0 && C.indexOf("Chrome/66") === -1;
    } catch {
    }
  }(), $ = function(ce) {
    var ge;
    return s(ce) && typeof (ge = ce.then) == "function" ? ge : false;
  }, B = function(ce, ge) {
    if (!ce._n) {
      ce._n = true;
      var Ne = ce._c;
      g(function() {
        for (var Me = ce._v, je = ce._s == 1, Oe = 0, Re = function(Ve) {
          var qe = je ? Ve.ok : Ve.fail, We = Ve.resolve, De = Ve.reject, et = Ve.domain, $t, At, Z;
          try {
            qe ? (je || (ce._h == 2 && Pe(ce), ce._h = 1), qe === true ? $t = Me : (et && et.enter(), $t = qe(Me), et && (et.exit(), Z = true)), $t === Ve.promise ? De(E("Promise-chain cycle")) : (At = $($t)) ? At.call($t, We, De) : We($t)) : De(Me);
          } catch (ne) {
            et && !Z && et.exit(), De(ne);
          }
        }; Ne.length > Oe; ) Re(Ne[Oe++]);
        ce._c = [], ce._n = false, ge && !ce._h && ue(ce);
      });
    }
  }, ue = function(ce) {
    h.call(e, function() {
      var ge = ce._v, Ne = se(ce), Me, je, Oe;
      if (Ne && (Me = y(function() {
        L ? T.emit("unhandledRejection", ge, ce) : (je = e.onunhandledrejection) ? je({ promise: ce, reason: ge }) : (Oe = e.console) && Oe.error && Oe.error("Unhandled promise rejection", ge);
      }), ce._h = L || se(ce) ? 2 : 1), ce._a = void 0, Ne && Me.e) throw Me.v;
    });
  }, se = function(ce) {
    return ce._h !== 1 && (ce._a || ce._c).length === 0;
  }, Pe = function(ce) {
    h.call(e, function() {
      var ge;
      L ? T.emit("rejectionHandled", ce) : (ge = e.onrejectionhandled) && ge({ promise: ce, reason: ce._v });
    });
  }, ae = function(ce) {
    var ge = this;
    ge._d || (ge._d = true, ge = ge._w || ge, ge._v = ce, ge._s = 2, ge._a || (ge._a = ge._c.slice()), B(ge, true));
  }, Ee = function(ce) {
    var ge = this, Ne;
    if (!ge._d) {
      ge._d = true, ge = ge._w || ge;
      try {
        if (ge === ce) throw E("Promise can't be resolved itself");
        (Ne = $(ce)) ? g(function() {
          var Me = { _w: ge, _d: false };
          try {
            Ne.call(ce, t(Ee, Me, 1), t(ae, Me, 1));
          } catch (je) {
            ae.call(Me, je);
          }
        }) : (ge._v = ce, ge._s = 1, B(ge, false));
      } catch (Me) {
        ae.call({ _w: ge, _d: false }, Me);
      }
    }
  };
  return V || (P = function(ge) {
    l(this, P, b, "_h"), a(ge), M.call(this);
    try {
      ge(t(Ee, this, 1), t(ae, this, 1));
    } catch (Ne) {
      ae.call(this, Ne);
    }
  }, M = function(ge) {
    this._c = [], this._a = void 0, this._s = 0, this._d = false, this._v = void 0, this._h = 0, this._n = false;
  }, M.prototype = nh()(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function(ge, Ne) {
      var Me = U(u(this, P));
      return Me.ok = typeof ge == "function" ? ge : true, Me.fail = typeof Ne == "function" && Ne, Me.domain = L ? T.domain : void 0, this._c.push(Me), this._a && this._a.push(Me), this._s && B(this, false), Me.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    catch: function(ce) {
      return this.then(void 0, ce);
    }
  }), F = function() {
    var ce = new M();
    this.promise = ce, this.resolve = t(Ee, ce, 1), this.reject = t(ae, ce, 1);
  }, v.f = U = function(ce) {
    return ce === P || ce === q ? new F(ce) : O(ce);
  }), r(r.G + r.W + r.F * !V, { Promise: P }), dwe()(P, b), rT()(b), q = mR()[b], r(r.S + r.F * !V, b, {
    // 25.4.4.5 Promise.reject(r)
    reject: function(ge) {
      var Ne = U(this), Me = Ne.reject;
      return Me(ge), Ne.promise;
    }
  }), r(r.S + r.F * (i || !V), b, {
    // 25.4.4.6 Promise.resolve(x)
    resolve: function(ge) {
      return w(i && this === q ? P : this, ge);
    }
  }), r(r.S + r.F * !(V && oT()(function(ce) {
    P.all(ce).catch(A);
  })), b, {
    // 25.4.4.1 Promise.all(iterable)
    all: function(ge) {
      var Ne = this, Me = U(Ne), je = Me.resolve, Oe = Me.reject, Re = y(function() {
        var Ve = [], qe = 0, We = 1;
        d(ge, false, function(De) {
          var et = qe++, $t = false;
          Ve.push(void 0), We++, Ne.resolve(De).then(function(At) {
            $t || ($t = true, Ve[et] = At, --We || je(Ve));
          }, Oe);
        }), --We || je(Ve);
      });
      return Re.e && Oe(Re.v), Me.promise;
    },
    // 25.4.4.4 Promise.race(iterable)
    race: function(ge) {
      var Ne = this, Me = U(Ne), je = Me.reject, Oe = y(function() {
        d(ge, false, function(Re) {
          Ne.resolve(Re).then(Me.resolve, je);
        });
      });
      return Oe.e && je(Oe.v), Me.promise;
    }
  }), rx;
}
var px = {};
var gx;
function HV() {
  if (gx) return px;
  gx = 1;
  var i = BD(), e = mR(), t = pR(), n = ML(), r = VL();
  return i(i.P + i.R, "Promise", { finally: function(s) {
    var a = n(this, e.Promise || t.Promise), l = typeof s == "function";
    return this.then(
      l ? function(d) {
        return r(a, s()).then(function() {
          return d;
        });
      } : s,
      l ? function(d) {
        return r(a, s()).then(function() {
          throw d;
        });
      } : s
    );
  } }), px;
}
var mx = {};
var vx;
function qV() {
  if (vx) return mx;
  vx = 1;
  var i = BD(), e = Ry(), t = OL();
  return i(i.S, "Promise", { try: function(n) {
    var r = e.f(this), s = t(n);
    return (s.e ? r.reject : r.resolve)(s.v), r.promise;
  } }), mx;
}
var pg;
var yx;
function jV() {
  return yx || (yx = 1, wUn(), GUn(), WV(), HV(), qV(), pg = mR().Promise), pg;
}
var gg;
var Sx;
function JV() {
  return Sx || (Sx = 1, gg = { default: jV(), __esModule: true }), gg;
}
var KV = JV();
var Ft = Ws(KV);
var YV = class {
  constructor() {
    this.name = "CancellationError", this.message = "CANCELED";
  }
  toString() {
    return "CANCELED";
  }
};
var bs = new YV();
function XV(i) {
  if (i.isCanceled === true)
    throw bs;
}
var Bm = () => {
};
var Qt = {
  isCanceled: false,
  add: () => Bm,
  remove: Bm
};
var Ts = class {
  /**
   * Trigger cancellation.
   *
   * If this.isCanceled === false, then each registered cancellation handler is invoked
   * synchronously.
   */
  cancel() {
    const e = this.handlers;
    if (e !== null && (this.handlers = null, e !== void 0))
      for (let t of e)
        t();
  }
  get isCanceled() {
    return this.handlers === null;
  }
  add(e) {
    let t = this.handlers;
    return t === null ? (e(), Bm) : (t === void 0 && (t = this.handlers = new Ye()), t.add(e), () => {
      this.remove(e);
    });
  }
  remove(e) {
    const t = this.handlers;
    t == null ? void 0 : t.delete(e);
  }
};
var ZV = class extends Ts {
  constructor() {
    super(...arguments), this.consumers = new Ye();
  }
  addConsumer(e = Qt) {
    const t = this.consumers;
    t.has(e) || e.isCanceled || (t.add(e), e.add(() => {
      t.delete(e), t.size === 0 && this.cancel();
    }));
  }
};
function QV(i, e) {
  return new Ft((t, n) => {
    if (i === Qt) {
      e(t, n, Qt);
      return;
    }
    const r = new Ts(), s = i.add(() => {
      r.cancel();
    });
    e((a) => {
      s(), t(a);
    }, (a) => {
      s(), n(a);
    }, r);
  });
}
var BL = !(typeof Window < "u" && self instanceof Window);
var Fm = "rpc.promise.response";
var FL = "rpc.promise.cancel";
var UL = new he();
function zt(i, e) {
  UL.set(i, e);
}
var eB = class extends Error {
  constructor(e, t) {
    super(t), this.name = e, this.message = t;
  }
};
function zL(i, e) {
  zt(i, function(t) {
    let n = t.id;
    const r = new Ts();
    let s = e.call(this, t, r);
    this.set(n, { promise: s, cancellationToken: r }), s.then(({ value: a, transfers: l }) => {
      this.delete(n), this.invoke(Fm, { id: n, value: a }, l);
    }, (a) => {
      this.delete(n), this.invoke(Fm, { id: n, error: a.message, errorName: a.name });
    });
  });
}
zt(FL, function(i) {
  let e = i.id;
  const t = this.get(e);
  t !== void 0 && t.cancellationToken.cancel();
});
zt(Fm, function(i) {
  let e = i.id;
  var t = this.get(e);
  let n = t.resolve, r = t.reject;
  this.delete(e), i.hasOwnProperty("value") ? n(i.value) : i.errorName === bs.name ? r(bs) : r(new eB(i.errorName, i.error));
});
var tB = BL ? -1 : 0;
var nB = class {
  constructor(e) {
    this.target = e, this.objects = new he(), this.nextId = tB, e.onmessage = (t) => {
      let n = t.data;
      UL.get(n.functionName).call(this, n);
    };
  }
  get numObjects() {
    return this.objects.size;
  }
  set(e, t) {
    this.objects.set(e, t);
  }
  delete(e) {
    this.objects.delete(e);
  }
  get(e) {
    return this.objects.get(e);
  }
  getRef(e) {
    let t = e.id, n = this.get(t);
    return n.referencedGeneration = e.gen, n.addRef(), n;
  }
  getOptionalRef(e) {
    if (e === void 0) return;
    let t = e.id, n = this.get(t);
    return n.referencedGeneration = e.gen, n.addRef(), n;
  }
  invoke(e, t, n) {
    t.functionName = e, this.target.postMessage(t, n);
  }
  promiseInvoke(e, t, n = Qt, r) {
    return QV(n, (s, a, l) => {
      const d = t.id = this.newId();
      this.set(d, { resolve: s, reject: a }), this.invoke(e, t, r), l.add(() => {
        this.invoke(FL, { id: d });
      });
    });
  }
  newId() {
    return BL ? this.nextId-- : this.nextId++;
  }
};
var cr = class extends X {
  constructor() {
    super(...arguments), this.rpc = null, this.rpcId = null;
  }
  initializeSharedObject(e, t = e.newId()) {
    this.rpc = e, this.rpcId = t, this.isOwner = false, e.set(t, this);
  }
  initializeCounterpart(e, t = {}) {
    this.initializeSharedObject(e), this.unreferencedGeneration = 0, this.referencedGeneration = 0, this.isOwner = true, t.id = this.rpcId, t.type = this.RPC_TYPE_ID, e.invoke("SharedObject.new", t);
  }
  dispose() {
    super.dispose();
  }
  /**
   * Precondition: this.isOwner === true.
   */
  addCounterpartRef() {
    return { id: this.rpcId, gen: ++this.referencedGeneration };
  }
  refCountReachedZero() {
    this.isOwner === true ? this.referencedGeneration === this.unreferencedGeneration && this.ownerDispose() : this.isOwner === false ? this.rpc.invoke("SharedObject.refCountReachedZero", { id: this.rpcId, gen: this.referencedGeneration }) : super.refCountReachedZero();
  }
  /**
   * Precondition: this.isOwner === true.
   */
  ownerDispose() {
    let e = this.rpc, t = this.rpcId;
    super.refCountReachedZero(), e.delete(t), e.invoke("SharedObject.dispose", { id: t });
  }
  /**
   * Precondition: this.isOwner === true.
   *
   * This should be called when the counterpart's refCount is decremented and reaches zero.
   */
  counterpartRefCountReachedZero(e) {
    this.unreferencedGeneration = e, this.refCount === 0 && e === this.referencedGeneration && this.ownerDispose();
  }
};
function iB(i, e, t = {}) {
  e != null && i.initializeSharedObject(e, t.id);
}
var ph = class extends cr {
  constructor(e, t = {}) {
    super(), iB(this, e, t);
  }
};
zt("SharedObject.dispose", function(i) {
  let e = this.get(i.id);
  if (e.refCount !== 0)
    throw new Error("Attempted to dispose object with non-zero reference count.");
  e.disposed(), this.delete(e.rpcId), e.rpcId = null, e.rpc = null;
});
var rB = "Worker";
zt(rB, function(i) {
  const e = i.port, t = i.path;
  new Worker(t).postMessage({ port: e }, [e]);
});
zt("SharedObject.refCountReachedZero", function(i) {
  let e = this.get(i.id), t = i.gen;
  e.counterpartRefCountReachedZero(t);
});
var $L = new he();
function ki(i) {
  return (e) => {
    e.prototype.RPC_TYPE_ID = i;
  };
}
function gh(i) {
  return (e) => {
    if (i !== void 0)
      e.prototype.RPC_TYPE_ID = i;
    else if (i = e.prototype.RPC_TYPE_ID, i === void 0)
      throw new Error("RPC_TYPE_ID should have already been defined");
    $L.set(i, e);
  };
}
zt("SharedObject.new", function(i) {
  let e = this, t = i.type, n = $L.get(t), r = new n(e, i);
  --r.refCount;
});
var sB = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
var Kd;
var GL = "SharedWatchableValue.changed";
var An = Kd = class extends ph {
  constructor(e, t = {}) {
    super(e, t), this.updatingValue_ = false, e !== void 0 && (this.base = new vt(t.value), this.setupChangedHandler());
  }
  initializeCounterpart(e, t = {}) {
    t.value = this.value, super.initializeCounterpart(e, t);
  }
  setupChangedHandler() {
    this.registerDisposer(this.base.changed.add(() => {
      if (this.updatingValue_)
        this.updatingValue_ = false;
      else {
        const e = this.rpc;
        e !== null && e.invoke(GL, { id: this.rpcId, value: this.value });
      }
    }));
  }
  static makeFromExisting(e, t) {
    let n = new Kd();
    return n.base = t, n.setupChangedHandler(), n.initializeCounterpart(e), n;
  }
  static make(e, t) {
    return Kd.makeFromExisting(e, new vt(t));
  }
  get value() {
    return this.base.value;
  }
  set value(e) {
    this.base.value = e;
  }
  get changed() {
    return this.base.changed;
  }
};
An = Kd = sB([gh("SharedWatchableValue")], An);
zt(GL, function(i) {
  const e = this.get(i.id);
  e.updatingValue_ = true, e.base.value = i.value, e.updatingValue_ = false;
});
var Zt = class extends vt {
  constructor(e = Number.NEGATIVE_INFINITY) {
    super(e);
  }
  get visible() {
    return this.value === Number.POSITIVE_INFINITY;
  }
  get ignored() {
    return this.value === Number.NEGATIVE_INFINITY;
  }
};
Zt.VISIBLE = Number.POSITIVE_INFINITY;
Zt.IGNORED = Number.NEGATIVE_INFINITY;
var rc = class extends Zt {
  constructor() {
    super(...arguments), this.contributors = new he();
  }
  /**
   * Registers `x` to be included in the set of values to be aggregated.
   *
   * @returns A disposer function that unregisters the specified value.
   */
  add(e) {
    const t = this.contributors, n = e.changed.add(() => {
      this.update();
    }), r = () => {
      t.delete(r), n(), this.update();
    };
    return t.set(r, e), this.update(), r;
  }
  update() {
    let e = Number.NEGATIVE_INFINITY;
    for (const t of this.contributors.values())
      e = Math.max(e, t.value);
    this.value = e;
  }
};
function mh(i) {
  return class extends i {
    constructor() {
      super(...arguments), this.visibility = new rc();
    }
    initializeCounterpart(e, t = {}) {
      t.visibility = this.registerDisposer(An.makeFromExisting(e, this.visibility)).rpcId, super.initializeCounterpart(e, t);
    }
  };
}
var aB = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
var oB = function(i, e) {
  var t = {};
  for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && e.indexOf(n) < 0 && (t[n] = i[n]);
  if (i != null && typeof ZC == "function") for (var r = 0, n = ZC(i); r < n.length; r++)
    e.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(i, n[r]) && (t[n[r]] = i[n[r]]);
  return t;
};
var Ei;
(function(i) {
  i[i.DATA = 0] = "DATA", i[i.ANNOTATION = 1] = "ANNOTATION", i[i.DEFAULT_ANNOTATION = 2] = "DEFAULT_ANNOTATION";
})(Ei || (Ei = {}));
function lB() {
  return new iN([Ei.DATA, Ei.ANNOTATION, Ei.DEFAULT_ANNOTATION]);
}
var WL = class extends X {
  constructor() {
    super(...arguments), this.role = Ei.DATA, this.messages = new Uo(), this.layerChanged = new Le(), this.redrawNeeded = new Le(), this.layerChunkProgressInfo = new Iy();
  }
  handleAction(e) {
  }
  getValueAt(e) {
  }
  /**
   * Transform the stored pickedValue and offset associated with the retrieved pick ID into the
   * actual value.
   */
  transformPickedValue(e) {
    return e.pickedValue;
  }
  /**
   * Optionally updates the mouse state based on the retrived pick information.  This might snap the
   * 3-d position to the center of the picked point.
   */
  updateMouseState(e, t, n, r) {
  }
};
var HL = class extends WL {
  constructor() {
    super(...arguments), this.visibility = new rc();
  }
  attach(e) {
  }
};
function yu(i, e, t) {
  let n = t.state;
  if (n === void 0 || n.transform !== i || n.displayDimensionRenderInfo !== e) {
    if (t.messages.clearMessages(), n = t.state = { transform: i, displayDimensionRenderInfo: e, modelTransform: void 0 }, i.error !== void 0) {
      t.messages.addMessage({ severity: ar.error, message: i.error });
      return;
    }
    try {
      const r = nt();
      SV(r, e, i), n.modelTransform = r;
    } catch (r) {
      t.messages.addMessage({ severity: ar.error, message: r.message });
    }
  }
  return n.modelTransform;
}
var qL = class extends X {
  constructor(e) {
    super(), this.renderViewport = new Py(), this.changed = new ct();
    var t = e.parametersConstructor;
    const n = t === void 0 ? AL : t, r = e.navigationState, s = e.update;
    var a = e.isEqual;
    const l = a === void 0 ? OV : a;
    this.oldValue_ = new n(), this.value_ = new n();
    const d = () => {
      const h = this.oldValue_, g = this.value_;
      h.displayDimensionRenderInfo = r.displayDimensionRenderInfo.value, H(h, this.renderViewport);
      let v = h.globalPosition;
      const y = r.position.value, C = y.length;
      v.length !== C && (h.globalPosition = v = new Float32Array(C)), v.set(y), s(h, r), !l(h, g) && (this.value_ = h, this.oldValue_ = g, this.changed.dispatch(g, h));
    }, u = this.update = this.registerCancellable(dt(d, 0));
    this.registerDisposer(r.changed.add(u)), d();
  }
  setViewport(e) {
    IL(e, this.renderViewport) || (H(this.renderViewport, e), this.update());
  }
  get value() {
    return this.update.flush(), this.value_;
  }
};
var Su = class extends cr {
  constructor(e, t, n = 10) {
    super(), this.base = t, this.updateInterval = n, this.prevDisplayDimensionRenderInfo = void 0, this.update = this.registerCancellable(dt((r, s) => {
      let a;
      s.displayDimensionRenderInfo !== this.prevDisplayDimensionRenderInfo ? (a = s, this.prevDisplayDimensionRenderInfo = s.displayDimensionRenderInfo) : (s.displayDimensionRenderInfo, a = oB(s, ["displayDimensionRenderInfo"])), this.rpc.invoke(UV, { id: this.rpcId, value: a });
    }, this.updateInterval)), this.initializeCounterpart(e, { value: t.value }), this.registerDisposer(t.changed.add(this.update));
  }
  flush() {
    this.update.flush();
  }
};
Su = aB([ki(FV)], Su);
var nn = class {
  constructor(e, t = e) {
    this.value_ = e, this.defaultValue = t, this.changed = new Le();
  }
  get value() {
    return this.value_;
  }
  set value(e) {
    e !== this.value_ && (this.value_ = e, this.changed.dispatch());
  }
  toggle() {
    this.value = !this.value;
  }
  toJSON() {
    if (this.value_ !== this.defaultValue)
      return this.value_;
  }
  restoreState(e) {
    if (e === true || e === false) {
      this.value = e;
      return;
    }
    this.value = this.defaultValue;
  }
  reset() {
    this.value = this.defaultValue;
  }
};
var Ls = class extends X {
  constructor(e, t = {}) {
    super(), this.model = e, this.element = document.createElement("input");
    let n = this.element;
    n.type = "checkbox";
    const r = () => {
      var s;
      const a = this.model.value;
      this.element.checked = a, (t.enableTitle !== void 0 || t.disableTitle !== void 0) && (this.element.title = (s = a ? t.enableTitle : t.disableTitle) !== null && s !== void 0 ? s : "");
    };
    this.registerDisposer(e.changed.add(r)), r(), this.registerEventListener(n, "change", function(s) {
      e.value = this.checked;
    }), n.addEventListener("mousedown", (s) => {
      s.preventDefault();
    });
  }
  disposed() {
    let e = this.element, t = e.parentElement;
    t && t.removeChild(e), super.disposed();
  }
};
var fi = class extends X {
  constructor(e, t) {
    super(), this.model = e, this.element = t, this.initialDisplay = this.element.style.display, this.updateVisibility(), this.registerDisposer(e.changed.add(this.registerCancellable(dt(() => this.updateVisibility(), 0))));
  }
  updateVisibility() {
    this.element.style.display = this.model.value ? this.initialDisplay : "none";
  }
};
function jL(i) {
  try {
    return i();
  } catch (e) {
    return { error: e.message };
  }
}
function cB(i) {
  if (i.error !== void 0) throw new Error(i.error);
  return i;
}
var Ay = class extends X {
  constructor(e, t) {
    if (super(), this.register = e, this.changed = new Le(), this.disposerMap = new he(), t === void 0)
      this.map = new he();
    else {
      const r = this.map = new he(t), s = this.disposerMap;
      for (const a of r) {
        var n = de(a, 2);
        const l = n[0], d = n[1], u = new X();
        s.set(l, u), e(u, d, l);
      }
    }
  }
  get value() {
    return this.map;
  }
  set(e, t) {
    const n = this.map, r = this.disposerMap;
    let s = r.get(e);
    return s !== void 0 && s.dispose(), s = new X(), r.set(e, s), n.set(e, t), this.register(s, t, e), this.changed.dispatch(), this;
  }
  delete(e) {
    const t = this.map, n = this.disposerMap, r = n.get(e);
    return r !== void 0 ? (r.dispose(), n.delete(e), t.delete(e), this.changed.dispatch(), true) : false;
  }
  get(e) {
    return this.map.get(e);
  }
  has(e) {
    return this.map.has(e);
  }
  get size() {
    return this.map.size;
  }
  [qn]() {
    return oy(this.map);
  }
  clear() {
    const e = this.map, t = this.disposerMap;
    if (e.size > 0) {
      for (const n of t.values())
        n.dispose();
      e.clear(), t.clear(), this.changed.dispatch();
    }
  }
  values() {
    return this.map.values();
  }
  keys() {
    return this.map.keys();
  }
  disposed() {
    const e = this.map, t = this.disposerMap;
    for (const n of t.values())
      n.dispose();
    e.clear(), t.clear(), super.disposed();
  }
};
var dB = JUn();
var li = Ws(dB);
var bx = li("objectId");
var uB = 0;
function En(i) {
  if (i instanceof Object) {
    let e = i[bx];
    return e === void 0 && (e = i[bx] = uB++), `o${e}`;
  } else
    return "" + oe(i);
}
var Um;
(function(i) {
  i[i.VERTEX = WebGL2RenderingContext.VERTEX_SHADER] = "VERTEX", i[i.FRAGMENT = WebGL2RenderingContext.FRAGMENT_SHADER] = "FRAGMENT";
})(Um || (Um = {}));
function hB(i) {
  i = i.replace("\0", "");
  let e = [];
  for (let t of i.split(`
`)) {
    let n = t.match(/^ERROR:\s*(\d+):(\d+)\s*(.+)$/);
    n !== null ? e.push({ message: n[3].trim(), file: parseInt(n[1], 10), line: parseInt(n[2], 10) }) : (n = t.match(/^ERROR:\s*(.+)$/), n !== null ? e.push({ message: n[1] }) : (t = t.trim(), t && e.push({ message: t })));
  }
  return e;
}
var fB = class extends Error {
  constructor(e, t, n, r) {
    const s = `Error compiling ${Um[e].toLowerCase()} shader: ${n}`;
    super(s), this.name = "ShaderCompilationError", this.log = n, this.message = s, this.shaderType = e, this.source = t, this.errorMessages = r;
  }
};
var pB = class extends Error {
  constructor(e, t, n) {
    const r = `Error linking shader: ${n}`;
    super(r), this.name = "ShaderLinkError", this.log = n, this.message = r, this.vertexSource = e, this.fragmentSource = t;
  }
};
function wx(i, e, t) {
  var n = i.createShader(t);
  if (i.shaderSource(n, e), i.compileShader(n), !i.getShaderParameter(n, i.COMPILE_STATUS)) {
    let r = i.getShaderInfoLog(n) || "";
    throw new fB(t, e, r, hB(r));
  }
  return n;
}
var gB = class extends X {
  constructor(e, t, n, r, s, a) {
    super(), this.gl = e, this.vertexSource = t, this.fragmentSource = n, this.attributes = new he(), this.uniforms = new he(), this.vertexShaderInputBinders = {};
    let l = this.vertexShader = wx(e, t, e.VERTEX_SHADER), d = this.fragmentShader = wx(e, n, e.FRAGMENT_SHADER), u = e.createProgram();
    if (e.attachShader(u, l), e.attachShader(u, d), e.linkProgram(u), !e.getProgramParameter(u, e.LINK_STATUS)) {
      let v = e.getProgramInfoLog(u) || "";
      throw new pB(t, n, v);
    }
    this.program = u;
    let h = this.uniforms, g = this.attributes;
    if (r)
      for (let v of r)
        h.set(v, e.getUniformLocation(u, v));
    if (s)
      for (let v of s)
        g.set(v, e.getAttribLocation(u, v));
  }
  uniform(e) {
    return this.uniforms.get(e);
  }
  attribute(e) {
    return this.attributes.get(e);
  }
  textureUnit(e) {
    return this.textureUnits.get(e);
  }
  bind() {
    this.gl.useProgram(this.program);
  }
  disposed() {
    let e = this.gl;
    e.deleteShader(this.vertexShader), this.vertexShader = void 0, e.deleteShader(this.fragmentShader), this.fragmentShader = void 0, e.deleteProgram(this.program), this.program = void 0, this.gl = void 0, this.attributes = void 0, this.uniforms = void 0;
  }
};
function mB(i, e, t, n, r) {
  i.drawArraysInstanced(e, t, n, r);
}
var Cx = class {
  constructor() {
    this.code = "", this.parts = new Ye();
  }
  add(e) {
    if (!this.parts.has(e))
      switch (this.parts.add(e), typeof e) {
        case "string":
          this.code += e;
          break;
        case "function":
          this.add(e());
          break;
        default:
          if (Array.isArray(e))
            for (let t of e)
              this.add(t);
          else
            throw console.log("Invalid code type", e), new Error("Invalid code type");
      }
  }
  toString() {
    return this.code;
  }
};
var zm = {
  sampler2D: WebGL2RenderingContext.TEXTURE_2D,
  isampler2D: WebGL2RenderingContext.TEXTURE_2D,
  usampler2D: WebGL2RenderingContext.TEXTURE_2D,
  sampler3D: WebGL2RenderingContext.TEXTURE_3D,
  isampler3D: WebGL2RenderingContext.TEXTURE_3D,
  usampler3D: WebGL2RenderingContext.TEXTURE_3D
};
var ra = class {
  constructor(e) {
    this.gl = e, this.nextSymbolID = 0, this.nextTextureUnit = 0, this.uniformsCode = "", this.attributesCode = "", this.varyingsCodeVS = "", this.varyingsCodeFS = "", this.fragmentExtensionsSet = new Ye(), this.fragmentExtensions = "", this.vertexCode = new Cx(), this.vertexMain = "", this.fragmentCode = new Cx(), this.outputBufferCode = "", this.fragmentMain = "", this.required = new Ye(), this.uniforms = new Array(), this.attributes = new Array(), this.initializers = [], this.textureUnits = new he(), this.vertexDebugOutputs = [];
  }
  addVertexPositionDebugOutput() {
    this.vertexDebugOutputs.push({ typeName: "vec4", name: "gl_Position" });
  }
  addVertexDebugOutput(e, t) {
    this.addVarying(e, t), this.vertexDebugOutputs.push({ typeName: e, name: t });
  }
  allocateTextureUnit(e, t = 1) {
    if (this.textureUnits.has(e))
      throw new Error("Duplicate texture unit symbol: " + e.toString());
    let n = this.nextTextureUnit;
    return this.nextTextureUnit += t, this.textureUnits.set(e, n), n;
  }
  addTextureSampler(e, t, n, r) {
    let s = this.allocateTextureUnit(n, r);
    return this.addUniform(`highp ${e}`, t, r), this.addInitializer((a) => {
      if (r) {
        let l = new Int32Array(r);
        for (let d = 0; d < r; ++d)
          l[d] = d + s;
        a.gl.uniform1iv(a.uniform(t), l);
      } else
        a.gl.uniform1i(a.uniform(t), s);
    }), s;
  }
  symbol(e) {
    return e + this.nextSymbolID++;
  }
  addAttribute(e, t, n) {
    return this.attributes.push(t), n !== void 0 && (this.attributesCode += `layout(location = ${n})`), this.attributesCode += `in ${e} ${t};
`, t;
  }
  addVarying(e, t, n = "") {
    this.varyingsCodeVS += `${n} out ${e} ${t};
`, this.varyingsCodeFS += `${n} in ${e} ${t};
`;
  }
  addOutputBuffer(e, t, n) {
    n !== null && (this.outputBufferCode += `layout(location = ${n}) `), this.outputBufferCode += `out ${e} ${t};
`;
  }
  addUniform(e, t, n) {
    return this.uniforms.push(t), n != null ? this.uniformsCode += `uniform ${e} ${t}[${n}];
` : this.uniformsCode += `uniform ${e} ${t};
`, t;
  }
  addFragmentExtension(e) {
    this.fragmentExtensionsSet.has(e) || (this.fragmentExtensionsSet.add(e), this.fragmentExtensions += `#extension ${e} : require
`);
  }
  addVertexCode(e) {
    this.vertexCode.add(e);
  }
  addFragmentCode(e) {
    this.fragmentCode.add(e);
  }
  setVertexMain(e) {
    this.vertexMain = e;
  }
  addVertexMain(e) {
    this.vertexMain = (this.vertexMain || "") + e;
  }
  setFragmentMain(e) {
    this.fragmentMain = `void main() {
${e}
}
`;
  }
  setFragmentMainFunction(e) {
    this.fragmentMain = e;
  }
  addInitializer(e) {
    this.initializers.push(e);
  }
  require(e) {
    this.required.has(e) || (this.required.add(e), e(this));
  }
  build() {
    let e = `#version 300 es
precision highp float;
precision highp int;
${this.uniformsCode}
${this.attributesCode}
${this.varyingsCodeVS}
${this.vertexCode}
void main() {
${this.vertexMain}
}
`, t = `#version 300 es
${this.fragmentExtensions}
precision highp float;
precision highp int;
${this.uniformsCode}
${this.varyingsCodeFS}
${this.outputBufferCode}
${this.fragmentCode}
${this.fragmentMain}
`, n = new gB(this.gl, e, t, this.uniforms, this.attributes, this.vertexDebugOutputs);
    n.textureUnits = this.textureUnits;
    let r = this.initializers;
    if (r.length > 0) {
      n.bind();
      for (let s of r)
        s(n);
    }
    return n;
  }
};
function vh() {
  return new vt(void 0);
}
function _y(i) {
  return new fn(i, Ae);
}
function My(i, e, t) {
  const n = new he(), r = t.parameters, s = t.fallbackParameters, a = t.shaderError;
  var l = t.encodeParameters;
  const d = l === void 0 ? (R) => R : l;
  var u = t.extraParameters;
  const h = u === void 0 ? ta(void 0) : u;
  var g = t.encodeExtraParameters;
  const v = g === void 0 ? (R) => R : g, y = t.getContextKey, C = t.defineShader;
  a !== void 0 && (a.value = void 0);
  var w = t.encodeContext;
  const b = w === void 0 ? y : w, E = si(t.memoizeKey);
  function T(R, P, L) {
    const A = oe({
      id: E,
      context: b(R),
      parameters: d(P),
      extraParameters: v(L)
    });
    return e.memoize.get(A, () => {
      const M = new ra(e);
      return C(M, R, P, L), M.build();
    });
  }
  function I(R) {
    const P = y(R);
    let L = n.get(P);
    L === void 0 && (L = {
      parametersGeneration: -1,
      extraParametersGeneration: -1,
      shader: null,
      fallback: false,
      parameters: r.value,
      extraParameters: h.value
    }, n.set(P, L));
    const A = r.changed.count, M = h.changed.count;
    if (A === L.parametersGeneration && M === L.extraParametersGeneration)
      return L;
    const O = L.parameters = r.value, F = L.extraParameters = h.value, q = L.shader;
    L.parametersGeneration = A, L.extraParametersGeneration = M;
    let U = null;
    try {
      U = T(R, O, F), L.fallback = false, s !== void 0 && (s.value = O), a !== void 0 && (a.value = null);
    } catch (V) {
      if (a !== void 0 && (a.value = V), s !== void 0)
        try {
          const $ = s.value;
          U = T(R, $, F), L.parameters = $, L.fallback = true;
        } catch {
        }
    }
    return q !== null && q.dispose(), L.shader = U, L;
  }
  return i.registerDisposer(() => {
    for (const R of n.values()) {
      const P = R.shader;
      P !== null && P.dispose();
    }
  }), I;
}
function vo(i, e, t) {
  return My(i, e, H(H({}, t), { getContextKey: (n) => n, encodeContext: (n) => En(n), defineShader: (n, r, s, a) => (n.require(r), t.defineShader(n, s, a)) }));
}
function sc(i, e = 1, t = 0) {
  return `
#line ${t} ${e}
` + i;
}
var Qn = class _Qn {
  constructor(e, t = WebGL2RenderingContext.ARRAY_BUFFER) {
    this.gl = e, this.bufferType = t, this.gl = e, this.buffer = e.createBuffer();
  }
  bind() {
    this.gl.bindBuffer(this.bufferType, this.buffer);
  }
  bindToVertexAttrib(e, t, n = WebGL2RenderingContext.FLOAT, r = false, s = 0, a = 0) {
    this.bind(), this.gl.enableVertexAttribArray(e), this.gl.vertexAttribPointer(e, t, n, r, s, a);
  }
  bindToVertexAttribI(e, t, n = WebGL2RenderingContext.UNSIGNED_INT, r = 0, s = 0) {
    this.bind(), this.gl.enableVertexAttribArray(e), this.gl.vertexAttribIPointer(e, t, n, r, s);
  }
  setData(e, t = WebGL2RenderingContext.STATIC_DRAW) {
    let n = this.gl;
    this.bind(), n.bufferData(this.bufferType, e, t);
  }
  dispose() {
    this.gl.deleteBuffer(this.buffer), this.buffer = void 0, this.gl = void 0;
  }
  static fromData(e, t, n, r) {
    let s = new _Qn(e, n);
    return s.setData(t, r), s;
  }
};
function ac(i, e, t, ...n) {
  return i.memoize.get(si({ id: "getMemoizedBuffer", getter: En(t), args: n }), () => {
    const r = new hT(Qn.fromData(i, t(...n), e, WebGL2RenderingContext.STATIC_DRAW));
    return r.registerDisposer(r.value), r;
  });
}
function vB(i = -1, e = -1, t = 1, n = 1, r = 1, s = 1) {
  return ym(
    new Float32Array([i, e, i, n, t, n, t, e]),
    /*majorDimension=*/
    2,
    r,
    s
  );
}
function oc(i, e = -1, t = -1, n = 1, r = 1, s = 1, a = 1) {
  return ac(i, WebGL2RenderingContext.ARRAY_BUFFER, vB, e, t, n, r, s, a).value;
}
function yo(i) {
  i.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST), i.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST), i.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE), i.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
}
function yB(i) {
  i.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST), i.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST), i.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE), i.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE), i.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_R, WebGL2RenderingContext.CLAMP_TO_EDGE);
}
function SB(i, e, t, n, r = WebGL2RenderingContext.RGBA8, s = WebGL2RenderingContext.RGBA, a = WebGL2RenderingContext.UNSIGNED_BYTE) {
  i.activeTexture(WebGL2RenderingContext.TEXTURE0 + i.tempTextureUnit), i.bindTexture(WebGL2RenderingContext.TEXTURE_2D, e), yo(i), i.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    0,
    /*internalformat=*/
    r,
    /*width=*/
    t,
    /*height=*/
    n,
    /*border=*/
    0,
    /*format=*/
    s,
    a,
    null
  ), i.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
}
function bB(i, e, t) {
  i.activeTexture(WebGL2RenderingContext.TEXTURE0 + i.tempTextureUnit), i.bindTexture(WebGL2RenderingContext.TEXTURE_2D, e), i.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR), i.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR), i.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE), i.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE), i.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, 1), i.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 4), i.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    /*level=*/
    0,
    /*internalformat=*/
    WebGL2RenderingContext.RGBA8,
    /*format=*/
    WebGL2RenderingContext.RGBA,
    WebGL2RenderingContext.UNSIGNED_BYTE,
    t
  ), i.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, 0), i.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
}
function JL(i) {
  i.addOutputBuffer("vec4", "v4f_fragColor", null), i.setFragmentMain("v4f_fragColor = getValue0();");
}
function wB(i, e = JL, t = 1) {
  return i.memoize.get(`elementWiseTextureShader:${t}:${En(e)}`, () => {
    let n = new ra(i);
    n.addVarying("vec2", "vTexCoord"), n.addUniform("sampler2D", "uSampler", t), n.addInitializer((r) => {
      let s = [];
      for (let a = 0; a < t; ++a)
        s[a] = a;
      i.uniform1iv(r.uniform("uSampler"), s);
    });
    for (let r = 0; r < t; ++r)
      n.addFragmentCode(`
vec4 getValue${r}() {
  return texture(uSampler[${r}], vTexCoord);
}
`);
    return n.addUniform("mat4", "uProjectionMatrix"), n.require(e), n.addAttribute("vec4", "aVertexPosition"), n.addAttribute("vec2", "aTexCoord"), n.setVertexMain("vTexCoord = aTexCoord; gl_Position = uProjectionMatrix * aVertexPosition;"), n.build();
  });
}
function CB(i) {
  return i.memoize.get("trivialColorShader", () => {
    let e = new ra(i);
    return e.addVarying("vec4", "vColor"), e.addOutputBuffer("vec4", "v4f_fragColor", null), e.setFragmentMain("v4f_fragColor = vColor;"), e.addAttribute("vec4", "aVertexPosition"), e.addAttribute("vec4", "aColor"), e.addUniform("mat4", "uProjectionMatrix"), e.setVertexMain("vColor = aColor; gl_Position = uProjectionMatrix * aVertexPosition;"), e.build();
  });
}
var KL = class extends X {
  constructor() {
    super(...arguments), this.width = Number.NaN, this.height = Number.NaN;
  }
  hasSize(e, t) {
    return this.width === e && this.height === t;
  }
  resize(e, t) {
    this.hasSize(e, t) || (this.width = e, this.height = t, this.performResize());
  }
};
var xB = class extends KL {
  constructor(e, t) {
    super(), this.gl = e, this.internalformat = t, this.renderbuffer = null, this.renderbuffer = e.createRenderbuffer();
  }
  performResize() {
    let e = this.gl;
    e.bindRenderbuffer(e.RENDERBUFFER, this.renderbuffer), e.renderbufferStorage(e.RENDERBUFFER, this.internalformat, this.width, this.height), e.bindRenderbuffer(e.RENDERBUFFER, null);
  }
  disposed() {
    this.gl.deleteRenderbuffer(this.renderbuffer);
  }
  attachToFramebuffer(e) {
    let t = this.gl;
    t.framebufferRenderbuffer(t.FRAMEBUFFER, e, t.RENDERBUFFER, this.renderbuffer);
  }
};
var EB = class extends xB {
  constructor(e, t = false) {
    super(e, t ? e.DEPTH_STENCIL : e.DEPTH_COMPONENT16), this.gl = e, this.includeStencilBuffer = t;
  }
  attachToFramebuffer() {
    let e = this.gl;
    super.attachToFramebuffer(this.includeStencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT);
  }
};
var kB = class extends EB {
  constructor(e) {
    super(
      e,
      /*includeStencilBuffer=*/
      true
    );
  }
};
var TB = class extends X {
  constructor(e) {
    super(), this.gl = e, this.framebuffer = this.gl.createFramebuffer();
  }
  disposed() {
    this.gl.deleteFramebuffer(this.framebuffer);
  }
  bind() {
    let e = this.gl;
    e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer);
  }
  unbind() {
    let e = this.gl;
    e.bindFramebuffer(e.FRAMEBUFFER, null);
  }
};
var Zs = class extends KL {
  constructor(e, t, n, r) {
    super(), this.gl = e, this.internalFormat = t, this.format = n, this.dataType = r, this.texture = e.createTexture();
  }
  performResize() {
    SB(this.gl, this.texture, this.width, this.height, this.internalFormat, this.format, this.dataType);
  }
  disposed() {
    this.gl.deleteTexture(this.texture);
  }
  attachToFramebuffer(e) {
    let t = this.gl;
    t.framebufferTexture2D(
      t.FRAMEBUFFER,
      e,
      t.TEXTURE_2D,
      this.texture,
      /*level=*/
      0
    );
  }
};
var LB = class extends Zs {
  constructor(e, t = WebGL2RenderingContext.DEPTH_COMPONENT16, n = WebGL2RenderingContext.DEPTH_COMPONENT, r = WebGL2RenderingContext.UNSIGNED_SHORT) {
    super(e, t, n, r);
  }
  attachToFramebuffer() {
    super.attachToFramebuffer(this.format === WebGL2RenderingContext.DEPTH_COMPONENT ? WebGL2RenderingContext.DEPTH_ATTACHMENT : WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT);
  }
};
function bu(i, e, t = WebGL2RenderingContext.RGBA8, n = WebGL2RenderingContext.RGBA, r = WebGL2RenderingContext.UNSIGNED_BYTE) {
  let s = new Array();
  for (let a = 0; a < e; ++a)
    s[a] = new Zs(i, t, n, r);
  return s;
}
var So = class extends X {
  constructor(e, t) {
    super(), this.gl = e, this.width = Number.NaN, this.height = Number.NaN, this.fullAttachmentList = new Array(), this.attachmentVerified = false, this.singleAttachmentList = [this.gl.COLOR_ATTACHMENT0];
    var n = t.framebuffer;
    let r = n === void 0 ? new TB(e) : n, s = t.colorBuffers, a = t.depthBuffer;
    this.framebuffer = this.registerDisposer(r), this.colorBuffers = s, this.depthBuffer = a, a !== void 0 && this.registerDisposer(a);
    let l = this.fullAttachmentList;
    s.forEach((d, u) => {
      this.registerDisposer(d), l[u] = e.COLOR_ATTACHMENT0 + u;
    });
  }
  hasSize(e, t) {
    return this.width === e && this.height === t;
  }
  bind(e, t) {
    this.width = e, this.height = t, this.framebuffer.bind();
    let n = this.gl, r = this.depthBuffer;
    r !== void 0 ? (r.resize(e, t), r.attachToFramebuffer()) : n.framebufferRenderbuffer(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT, WebGL2RenderingContext.RENDERBUFFER, null), this.colorBuffers.forEach((s, a) => {
      s.resize(e, t), s.attachToFramebuffer(n.COLOR_ATTACHMENT0 + a);
    }), n.drawBuffers(this.fullAttachmentList), this.verifyAttachment(), n.viewport(0, 0, e, t);
  }
  bindSingle(e) {
    let t = this.gl;
    this.framebuffer.bind(), e !== 0 && t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0 + e,
      t.TEXTURE_2D,
      null,
      /*level=*/
      0
    ), t.bindTexture(t.TEXTURE_2D, null), this.colorBuffers[e].attachToFramebuffer(t.COLOR_ATTACHMENT0), t.drawBuffers(this.singleAttachmentList);
  }
  unbind() {
    this.framebuffer.unbind();
  }
  readPixelFloat32IntoBuffer(e, t, n, r, s = 1, a = 1) {
    let l = this.gl;
    try {
      this.bindSingle(e), l.readPixels(t, n, s, a, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, r);
    } finally {
      this.framebuffer.unbind();
    }
  }
  verifyAttachment() {
    if (this.attachmentVerified)
      return;
    let e = this.gl, t = e.checkFramebufferStatus(e.FRAMEBUFFER);
    if (t !== e.FRAMEBUFFER_COMPLETE)
      throw new Error(`Framebuffer configuration not supported: ${t}`);
    this.attachmentVerified = true;
  }
};
var bo = class _bo extends X {
  constructor(e, t) {
    super(), this.gl = e, this.shader = t, this.copyVertexPositionsBuffer = oc(this.gl), this.copyTexCoordsBuffer = oc(this.gl, 0, 0, 1, 1), this.registerDisposer(t);
  }
  draw(...e) {
    let t = this.gl, n = this.shader;
    n.bind();
    let r = e.length;
    for (let l = 0; l < r; ++l)
      t.activeTexture(t.TEXTURE0 + l), t.bindTexture(t.TEXTURE_2D, e[l]);
    t.uniformMatrix4fv(n.uniform("uProjectionMatrix"), false, TT);
    let s = n.attribute("aVertexPosition");
    this.copyVertexPositionsBuffer.bindToVertexAttrib(
      s,
      /*components=*/
      2
    );
    let a = n.attribute("aTexCoord");
    this.copyTexCoordsBuffer.bindToVertexAttrib(
      a,
      /*components=*/
      2
    ), t.drawArrays(t.TRIANGLE_FAN, 0, 4), t.disableVertexAttribArray(s), t.disableVertexAttribArray(a);
    for (let l = 0; l < r; ++l)
      t.activeTexture(t.TEXTURE0 + l), t.bindTexture(t.TEXTURE_2D, null);
  }
  static get(e, t = JL, n = 1) {
    return e.memoize.get(`OffscreenCopyHelper:${n}:${En(t)}`, () => new _bo(e, wB(e, t, n)));
  }
};
var DB = `
float mixLinear(float x, float y, float a) { return mix(x, y, a); }
`;
var IB = `
vec3 hueToRgb(float hue) {
  float hue6 = hue * 6.0;
  float r = abs(hue6 - 3.0) - 1.0;
  float g = 2.0 - abs(hue6 - 2.0);
  float b = 2.0 - abs(hue6 - 4.0);
  return clamp(vec3(r, g, b), 0.0, 1.0);
}
vec3 hsvToRgb(vec3 c) {
  vec3 hueRgb = hueToRgb(c.x);
  return c.z * ((hueRgb - 1.0) * c.y + 1.0);
}
`;
var jt = `
struct uint64_t {
  highp uvec2 value;
};
struct uint64x2_t {
  highp uvec4 value;
};
uint64_t mixLinear(uint64_t x, uint64_t y, float a) {
  return x;
}
uint64_t toUint64(uint64_t x) { return x; }
`;
var PB = [jt, `
uint64_t unpackUint64leFromUint32(highp uvec2 x) {
  uint64_t result;
  result.value = x;
  return result;
}
uint64x2_t unpackUint64leFromUint32(highp uvec4 x) {
  uint64x2_t result;
  result.value = x;
  return result;
}
`];
var YL = [jt, `
bool equals(uint64_t a, uint64_t b) {
  return a.value == b.value;
}
`];
var yh = [jt, `
bool compareLessThan(uint64_t a, uint64_t b) {
  return (a.value[1] < b.value[1])||
         (a.value[1] == b.value[1] && a.value[0] < b.value[0]);
}
`];
var XL = [jt, `
uint64_t subtract(uint64_t a, uint64_t b) {
  if (a.value[0] < b.value[0]) {
    --a.value[1];
  }
  a.value -= b.value;
  return a;
}
`];
var RB = [jt, `
uint64_t add(uint64_t a, uint64_t b) {
  a.value[0] += b.value[0];
  if (a.value[0] < b.value[0]) {
    ++a.value[1];
  }
  a.value[1] += b.value[1];
  return a;
}
`];
var AB = [RB, yh, `
uint64_t addSaturate(uint64_t a, uint64_t b) {
  a = add(a, b);
  if (compareLessThan(a, b)) {
    a.value = uvec2(0xffffffffu, 0xffffffffu);
  }
  return a;
}
`];
var _B = [XL, yh, `
uint64_t subtractSaturate(uint64_t a, uint64_t b) {
  b = subtract(a, b);
  if (compareLessThan(a, b)) {
    b.value = uvec2(0u, 0u);
  }
  return b;
}
`];
var ZL = [jt, `
uint64_t shiftRight(uint64_t a, int shift) {
  if (shift >= 32) {
    return uint64_t(uvec2(a.value[1] >> (shift - 32), 0u));
  } else if (shift == 0) {
    return a;
  } else {
    return uint64_t(uvec2((a.value[0] >> shift) | (a.value[1] << (32 - shift)), a.value[1] >> shift));
  }
}
`];
var MB = [jt, `
uint64_t shiftLeft(uint64_t a, int shift) {
  if (shift >= 32) {
    return uint64_t(uvec2(0u, a.value[0] << (shift - 32)));
  } else if (shift == 0) {
    return a;
  } else {
    return uint64_t(uvec2(a.value[0] << shift, (a.value[1] << shift) | (a.value[0] >> (32 - shift))));
  }
}
`];
var QL = [jt, `
struct uint8_t {
  highp uint value;
};
struct uint8x2_t {
  highp uvec2 value;
};
struct uint8x3_t {
  highp uvec3 value;
};
struct uint8x4_t {
  highp uvec4 value;
};
uint8_t mixLinear(uint8_t x, uint8_t y, highp float a) {
  return uint8_t(uint(round(mix(float(x.value), float(y.value), a))));
}
highp uint toRaw(uint8_t x) { return x.value; }
highp float toNormalized(uint8_t x) { return float(x.value) / 255.0; }
highp uvec2 toRaw(uint8x2_t x) { return x.value; }
highp vec2 toNormalized(uint8x2_t x) { return vec2(x.value) / 255.0; }
highp uvec3 toRaw(uint8x3_t x) { return x.value; }
vec3 toNormalized(uint8x3_t x) { return vec3(x.value) / 255.0; }
highp uvec4 toRaw(uint8x4_t x) { return x.value; }
vec4 toNormalized(uint8x4_t x) { return vec4(x.value) / 255.0; }
uint64_t toUint64(uint8_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
uint8_t uint8FromFloat(highp float x) {
  return uint8_t(uint(clamp(x, 0.0, 255.0)));
}
`];
var eD = [jt, `
struct int8_t {
  highp int value;
};
struct int8x2_t {
  highp ivec2 value;
};
struct int8x3_t {
  highp ivec3 value;
};
struct int8x4_t {
  highp ivec4 value;
};
int8_t mixLinear(int8_t x, int8_t y, highp float a) {
  return int8_t(int(round(mix(float(x.value), float(y.value), a))));
}
highp int toRaw(int8_t x) { return x.value; }
highp ivec2 toRaw(int8x2_t x) { return x.value; }
highp ivec3 toRaw(int8x3_t x) { return x.value; }
highp ivec4 toRaw(int8x4_t x) { return x.value; }
uint64_t toUint64(int8_t x) {
  uint64_t result;
  result.value[0] = uint(x.value);
  result.value[1] = uint(x.value >> 31);
  return result;
}
int8_t int8FromFloat(highp float x) {
  return int8_t(int(clamp(x, -128.0, 127.0)));
}
`];
var Ny = `
highp float toRaw(highp float x) { return x; }
highp float toNormalized(highp float x) { return x; }
vec2 toRaw(vec2 x) { return x; }
vec2 toNormalized(vec2 x) { return x; }
vec3 toRaw(vec3 x) { return x; }
vec3 toNormalized(vec3 x) { return x; }
vec4 toRaw(vec4 x) { return x; }
vec4 toNormalized(vec4 x) { return x; }
`;
var tD = [jt, `
struct uint16_t {
  highp uint value;
};
struct uint16x2_t {
  highp uvec2 value;
};
uint16_t mixLinear(uint16_t x, uint16_t y, highp float a) {
  return uint16_t(uint(round(mix(float(x.value), float(y.value), a))));
}
highp uint toRaw(uint16_t x) { return x.value; }
highp float toNormalized(uint16_t x) { return float(toRaw(x)) / 65535.0; }
highp uvec2 toRaw(uint16x2_t x) { return x.value; }
highp vec2 toNormalized(uint16x2_t x) { return vec2(toRaw(x)) / 65535.0; }
uint64_t toUint64(uint16_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
uint16_t uint16FromFloat(highp float x) {
  return uint16_t(uint(clamp(x, 0.0, 65535.0)));
}
`];
var nD = [jt, `
struct int16_t {
  highp int value;
};
struct int16x2_t {
  highp ivec2 value;
};
int16_t mixLinear(int16_t x, int16_t y, highp float a) {
  return int16_t(int(round(mix(float(x.value), float(y.value), a))));
}
highp int toRaw(int16_t x) { return x.value; }
highp ivec2 toRaw(int16x2_t x) { return x.value; }
uint64_t toUint64(int16_t x) {
  uint64_t result;
  result.value[0] = uint(x.value);
  result.value[1] = uint(x.value >> 31);
  return result;
}
int16_t int16FromFloat(highp float x) {
  return int16_t(int(clamp(x, -32768.0, 32767.0)));
}
`];
var Oy = [jt, `
struct uint32_t {
  highp uint value;
};
uint32_t mixLinear(uint32_t x, uint32_t y, highp float a) {
  return uint32_t(uint(round(mix(float(x.value), float(y.value), a))));
}
highp float toNormalized(uint32_t x) { return float(x.value) / 4294967295.0; }
highp uint toRaw(uint32_t x) { return x.value; }
uint64_t toUint64(uint32_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
uint32_t uint32FromFloat(highp float x) {
  return uint32_t(uint(clamp(x, 0.0, 4294967295.0)));
}
`];
var iD = [jt, `
struct int32_t {
  highp int value;
};
int32_t mixLinear(int32_t x, int32_t y, highp float a) {
  return int32_t(int(round(mix(float(x.value), float(y.value), a))));
}
highp int toRaw(int32_t x) { return x.value; }
uint64_t toUint64(int32_t x) {
  uint64_t result;
  result.value[0] = uint(x.value);
  result.value[1] = uint(x.value >> 31);
  return result;
}
int32_t int32FromFloat(highp float x) {
  return int32_t(int(clamp(x, 2147483648.0, 2147483647.0)));
}
`];
var NB = `
highp int getFortranOrderIndex(ivec3 subscripts, ivec3 size) {
  return subscripts.x + size.x * (subscripts.y + size.y * subscripts.z);
}
`;
var OB = `
highp uint log2Exact(highp uint i) {
  highp uint r;
  r = uint((i & 0xAAAAAAAAu) != 0u);
  r |= uint((i & 0xFFFF0000u) != 0u) << 4;
  r |= uint((i & 0xFF00FF00u) != 0u) << 3;
  r |= uint((i & 0xF0F0F0F0u) != 0u) << 2;
  r |= uint((i & 0xCCCCCCCCu) != 0u) << 1;
  return r;
}
`;
var VB = `
bool clipLineToDepthRange(inout highp vec4 a, inout highp vec4 b) {
  highp float tmin = 0.0, tmax = 1.0;
  highp float k1 = b.w - a.w + a.z - b.z;
  highp float k2 = a.w - b.w + a.z - b.z;
  highp float q1 = (a.z - a.w) / k1;
  highp float q2 = (a.z + a.w) / k2;
  if (k1 > 0.0) tmin = max(tmin, q1);
  else if (k1 < 0.0) tmax = min(tmax, q1);
  if (k2 > 0.0) tmax = min(tmax, q2);
  else if (k2 < 0.0) tmin = max(tmin, q2);
  if (tmin <= tmax) {
    highp vec4 tempA = a;
    highp vec4 tempB = b;
    a = mix(tempA, tempB, tmin);
    b = mix(tempA, tempB, tmax);
    return true;
  }
  return false;
}
`;
var BB = `
highp float simpleFloatHash(highp vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
`;
var FB = `
highp uint shiftLeftSaturate(highp uint x, int shiftAmount) {
  highp uint result = x << shiftAmount;
  if ((result >> shiftAmount) != x) return 0xffffffffu;
  return result;
}
`;
var Vy = `
highp uint addSaturate(highp uint x, highp uint y) {
  highp uint result = x + y;
  if (result < x) return 0xffffffffu;
  return result;
}
`;
var UB = `
highp uint subtractSaturate(highp uint x, highp uint y) {
  highp uint result = x - y;
  if (result > x) return 0u;
  return result;
}
`;
var zB = [Vy, `
highp int addSaturate(highp int x, highp uint y) {
  if (x >= 0) {
    return int(min(addSaturate(y, uint(x)), 0x7fffffffu));
  } else if (y >= uint(-x)) {
    return int(min(y - uint(-x), 0x7fffffffu));
  } else {
    return -int(min(uint(-x) - y, 0x80000000u));
  }
}
`];
var $B = [Vy, `
highp int subtractSaturate(highp int x, highp uint y) {
  if (x < 0) {
    return -int(min(addSaturate(uint(-x), uint(y)), 0x80000000u));
  } else if (uint(x) >= y) {
    return x - int(y);
  } else {
    return -int(min(y - uint(x), 0x80000000u));
  }
}
`];
function xn(i, e = 1) {
  switch (i) {
    case j.FLOAT32:
      if (e === 1)
        return "float";
      if (e > 1 && e <= 4)
        return `vec${e}`;
      break;
    case j.UINT8:
    case j.INT8:
    case j.UINT16:
    case j.INT16:
    case j.UINT32:
    case j.INT32:
    case j.UINT64: {
      const t = VT[i] ? "" : "u", n = MN[i] * 8;
      if (e === 1)
        return `${t}int${n}_t`;
      if (e > 1 && e * n <= 32)
        return `${t}int${n}x${e}_t`;
      break;
    }
  }
  throw new Error(`No shader type for ${j[i]}[${e}].`);
}
var zo = {
  [j.UINT8]: QL,
  [j.INT8]: eD,
  [j.UINT16]: tD,
  [j.INT16]: nD,
  [j.UINT32]: Oy,
  [j.INT32]: iD,
  [j.UINT64]: jt,
  [j.FLOAT32]: Ny
};
function GB(i, e) {
  return e === 1 ? i : `vec${e}`;
}
var WB = {
  [WebGL2RenderingContext.UNSIGNED_BYTE]: 1,
  [WebGL2RenderingContext.BYTE]: 1,
  [WebGL2RenderingContext.UNSIGNED_SHORT]: 2,
  [WebGL2RenderingContext.SHORT]: 2,
  [WebGL2RenderingContext.FLOAT]: 4,
  [WebGL2RenderingContext.INT]: 4,
  [WebGL2RenderingContext.UNSIGNED_INT]: 4
};
function Tc(i, e, t, n, r, s, a = 1) {
  let l = 0, d = s * a;
  for (; d > 0; ) {
    const g = Math.min(4, d), v = GB(e, g);
    d -= g, i.addAttribute("highp " + v, `a${r}${l}`), ++l;
  }
  d = s * a;
  let u = "";
  for (let g = 0; g < a; ++g) {
    u += `highp ${e}[${s}] get${r}${g}() {
  highp ${e}[${s}] result;
`;
    for (let v = 0; v < s; ++v) {
      const y = g * s + v, C = Math.floor(y / 4), w = y % 4;
      u += `  result[${v}] = a${r}${C}`, (w !== 0 || y !== d - 1) && (u += `[${w}]`), u += `;
`;
    }
    u += `  return result;
`, u += `}
`;
  }
  i.addVertexCode(u);
  const h = WB[t];
  i.addInitializer((g) => {
    const v = [];
    for (let y = 0; y < l; ++y)
      v[y] = g.attribute(`a${r}${y}`);
    g.vertexShaderInputBinders[r] = {
      enable(y) {
        const C = g.gl;
        for (let w = 0; w < l; ++w) {
          const b = v[w];
          C.enableVertexAttribArray(b), C.vertexAttribDivisor(b, y);
        }
      },
      disable() {
        const y = g.gl;
        for (let C = 0; C < l; ++C) {
          const w = v[C];
          y.vertexAttribDivisor(w, 0), y.disableVertexAttribArray(w);
        }
      },
      bind(y, C) {
        const w = g.gl;
        for (let b = 0; b < l; ++b) {
          const E = v[b], T = Math.min(4, d - 4 * b);
          w.vertexAttribPointer(
            E,
            /*size=*/
            T,
            t,
            n,
            y,
            C
          ), C += h * T;
        }
      }
    };
  });
}
var rD = class extends X {
  constructor(e, t, n = new rc()) {
    super(), this.channels = e, this.bounds = t, this.visibility = n, this.framebuffers = [], this.producerVisibility = new rc(), this.frameNumber = -1;
  }
  getFramebuffers(e) {
    const t = this.framebuffers;
    for (; t.length < this.channels.value.length; ) {
      const n = new So(e, {
        colorBuffers: bu(e, 1, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT)
      });
      t.push(n);
    }
    return t;
  }
  disposed() {
    for (const e of this.framebuffers)
      e.dispose();
    this.framebuffers.length = 0;
  }
};
var xx = li("histogramDataSamplerTextureUnit");
var Ex = li("histogramDepthTextureUnit");
var mg = 4096;
var HB = 2 ** 14;
var By = class _By extends X {
  constructor(e) {
    super(), this.gl = e, this.shader = this.registerDisposer((() => {
      const t = new ra(this.gl);
      return t.addOutputBuffer("vec4", "outputValue", 0), t.addAttribute("float", "aInput1"), t.addTextureSampler("sampler2D", "uDataSampler", xx), t.addTextureSampler("sampler2D", "uDepthSampler", Ex), t.addVertexCode(BB), t.setVertexMain(`
float uRandomSeed = 0.0;
vec2 p = vec2(simpleFloatHash(vec2(aInput1 + float(gl_VertexID), uRandomSeed + float(gl_InstanceID))),
              simpleFloatHash(vec2(aInput1 + float(gl_VertexID) + 10.0, 5.0 + uRandomSeed + float(gl_InstanceID))));
float dataValue = texture(uDataSampler, p).x;
float stencilValue = texture(uDepthSampler, p).x;
if (stencilValue == 1.0) {
  gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
} else {
  gl_Position = vec4(2.0 * (dataValue * 255.0 + 0.5) / 256.0 - 1.0, 0.0, 0.0, 1.0);
}
gl_PointSize = 1.0;
`), t.setFragmentMain(`
outputValue = vec4(1.0, 1.0, 1.0, 1.0);
`), t.build();
    })()), this.inputIndexBuffer = this.registerDisposer(ac(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, () => new Uint8Array(mg)));
  }
  static get(e) {
    return e.memoize.get("textureHistogramGeneration", () => new _By(e));
  }
  compute(e, t, n, r, s) {
    const a = this.gl, l = this.shader, d = r.getFramebuffers(a);
    l.bind(), a.enable(WebGL2RenderingContext.BLEND), a.disable(WebGL2RenderingContext.SCISSOR_TEST), a.disable(WebGL2RenderingContext.DEPTH_TEST), a.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE), this.inputIndexBuffer.value.bindToVertexAttrib(
      l.attribute("aInput1"),
      1,
      WebGL2RenderingContext.UNSIGNED_BYTE,
      /*normalized=*/
      true
    );
    const u = l.textureUnit(xx), h = l.textureUnit(Ex);
    a.activeTexture(WebGL2RenderingContext.TEXTURE0 + h), a.bindTexture(WebGL2RenderingContext.TEXTURE_2D, t), yo(a), a.activeTexture(WebGL2RenderingContext.TEXTURE0 + u);
    const g = r.frameNumber;
    r.frameNumber = s;
    for (let v = 0; v < e; ++v)
      a.bindTexture(WebGL2RenderingContext.TEXTURE_2D, n[v].texture), yo(a), d[v].bind(256, 1), s !== g && (a.clearColor(0, 0, 0, 0), a.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT)), a.drawArraysInstanced(WebGL2RenderingContext.POINTS, 0, mg, HB / mg);
    a.disable(WebGL2RenderingContext.BLEND);
  }
};
var Fy = {
  [j.UINT8]: "vec2",
  [j.INT8]: "vec2",
  [j.UINT16]: "vec2",
  [j.INT16]: "vec2",
  [j.FLOAT32]: "vec2",
  [j.UINT32]: "Uint32LerpParameters",
  [j.INT32]: "Int32LerpParameters",
  [j.UINT64]: "Uint64LerpParameters"
};
var Lc = {
  [j.UINT8]: "",
  [j.INT8]: "",
  [j.UINT16]: "",
  [j.INT16]: "",
  [j.FLOAT32]: "",
  [j.UINT32]: `
struct Uint32LerpParameters {
  uint offset;
  int shift;
  float multiplier;
};
`,
  [j.INT32]: `
struct Int32LerpParameters {
  int offset;
  int shift;
  float multiplier;
};
`,
  [j.UINT64]: [jt, `
struct Uint64LerpParameters {
  uint64_t offset;
  int shift;
  float multiplier;
};
`]
};
function _l(i) {
  let t = `
float computeInvlerp(${xn(i)} inputValue, vec2 p) {
  float outputValue = float(toRaw(inputValue));
  outputValue = (outputValue - p[0]) * p[1];
  return outputValue;
}
`;
  return [zo[i], t];
}
function kx(i) {
  const e = xn(i);
  let t = i === j.INT32 ? "int" : "uint", n = Fy[i];
  return [zo[i], Lc[i], `
float computeInvlerp(${e} inputValue, ${n} p) {
  ${t} v = toRaw(inputValue);
  uint x;
  if (v >= p.offset) {
    x = uint(v - p.offset);
  } else {
    x = uint(p.offset - v);
    p.multiplier = -p.multiplier;
  }
  x >>= p.shift;
  return float(x) * p.multiplier;
}
`];
}
var qB = {
  [j.UINT8]: _l(j.UINT8),
  [j.INT8]: _l(j.INT8),
  [j.UINT16]: _l(j.UINT16),
  [j.INT16]: _l(j.INT16),
  [j.FLOAT32]: _l(j.FLOAT32),
  [j.UINT32]: kx(j.UINT32),
  [j.INT32]: kx(j.INT32),
  [j.UINT64]: [jt, yh, XL, ZL, Lc[j.UINT64], `
float computeInvlerp(uint64_t inputValue, Uint64LerpParameters p) {
  if (compareLessThan(inputValue, p.offset)) {
    inputValue = subtract(p.offset, inputValue);
    p.multiplier = -p.multiplier;
  } else {
    inputValue = subtract(inputValue, p.offset);
  }
  uint shifted = shiftRight(inputValue, p.shift).value[0];
  return float(shifted) * p.multiplier;
}
`]
};
function Ml(i) {
  let t = `
${xn(i)} computeLerp(float inputValue, vec2 p) {
  inputValue = inputValue / p[1] + p[0];
`;
  return i === j.FLOAT32 ? t += `return inputValue;
` : t += `return ${j[i].toLowerCase()}FromFloat(round(inputValue));
`, t += `
}
`, [zo[i], t];
}
function Tx(i) {
  const e = xn(i);
  let t = Fy[i];
  return [zo[i], Lc[i], FB, i === j.UINT32 ? Vy : zB, i === j.UINT32 ? UB : $B, `
${e} computeLerp(float inputValue, ${t} p) {
  inputValue = inputValue / p.multiplier;
  uint x = uint(clamp(round(abs(inputValue)), 0.0, 4294967295.0));
  uint xShifted = shiftLeftSaturate(x, p.shift);
  if (inputValue >= 0.0) {
    return ${e}(addSaturate(p.offset, xShifted));
  } else {
    return ${e}(subtractSaturate(p.offset, xShifted));
  }
}
`];
}
var jB = {
  [j.UINT8]: Ml(j.UINT8),
  [j.INT8]: Ml(j.INT8),
  [j.UINT16]: Ml(j.UINT16),
  [j.INT16]: Ml(j.INT16),
  [j.FLOAT32]: Ml(j.FLOAT32),
  [j.UINT32]: Tx(j.UINT32),
  [j.INT32]: Tx(j.INT32),
  [j.UINT64]: [jt, yh, YL, AB, _B, ZL, MB, Lc[j.UINT64], `
uint64_t computeLerp(float inputValue, Uint64LerpParameters p) {
  inputValue = inputValue / p.multiplier;
  uint64_t x = uint64_t(uvec2(uint(clamp(round(abs(inputValue)), 0.0, 4294967295.0)), 0u));
  uint64_t shifted = shiftLeft(x, p.shift);
  if (!equals(shiftRight(shifted, p.shift), x)) {
    return uint64_t(uvec2(0xffffffffu, 0xffffffffu));
  }
  if (inputValue >= 0.0) {
    return addSaturate(p.offset, shifted);
  } else {
    return subtractSaturate(p.offset, shifted);
  }
}
`]
};
function sD(i, e, t) {
  const n = `uLerpParams_${e}`, r = `uLerpBounds_${e}`, s = `uLerpScalar_${e}`;
  let a = "";
  switch (t) {
    case j.INT8:
    case j.UINT8:
    case j.INT16:
    case j.UINT16:
    // {uint,int}{8,16} can be converted with float32 without any loss of precision
    case j.FLOAT32:
      i.addUniform("vec2", n);
      break;
    case j.INT32:
    case j.UINT32: {
      const l = Fy[t];
      i.addUniform(`${t === j.INT32 ? "i" : "u"}vec2`, r), i.addUniform("float", s), a += `
#define ${n} ${l}(${r}[0], int(${r}[1]), ${s})
`;
      break;
    }
    case j.UINT64: {
      i.addUniform("uvec3", r), i.addUniform("float", s), a += `
#define ${n} Uint64LerpParameters(uint64_t(${r}.xy), int(${r}[2]), ${s})
`;
      break;
    }
  }
  return [Lc[t], a];
}
function aD(i, e, t, n = false) {
  return [zo[t], sD(i, e, t), qB[t], `
float ${e}(${xn(t)} inputValue) {
  float v = computeInvlerp(inputValue, uLerpParams_${e});
  ${n ? "v = clamp(v, 0.0, 1.0);" : ""}
  return v;
}
`];
}
function JB(i, e, t) {
  return [zo[t], sD(i, e, t), jB[t], `
${xn(t)} ${e}(float inputValue) {
  return computeLerp(inputValue, uLerpParams_${e});
}
`];
}
var Gs = new re();
function Uy(i, e, t, n) {
  const r = i.gl;
  switch (t) {
    case j.INT8:
    case j.UINT8:
    case j.INT16:
    case j.UINT16:
    case j.FLOAT32:
      r.uniform2f(i.uniform(`uLerpParams_${e}`), n[0], 1 / (n[1] - n[0]));
      break;
    case j.INT32:
    case j.UINT32: {
      const s = n[0], a = n[1] - s, l = Math.max(0, Math.ceil(Zn(Math.abs(a))) - 24), d = Math.pow(2, l) / a, u = i.uniform(`uLerpBounds_${e}`);
      t === j.UINT32 ? r.uniform2ui(u, s, l) : r.uniform2i(u, s, l), r.uniform1f(i.uniform(`uLerpScalar_${e}`), d);
      break;
    }
    case j.UINT64: {
      const s = n[0], a = n[1];
      re.absDifference(Gs, a, s);
      const l = Gs.high > 0 ? 32 + Math.ceil(Zn(Gs.high)) : Math.ceil(Zn(Gs.low)), d = Math.max(0, l - 24);
      re.rshift(Gs, Gs, d);
      let u = 1 / Gs.low;
      re.compare(s, a) > 0 && (u *= -1);
      const h = i.uniform(`uLerpBounds_${e}`);
      r.uniform3ui(h, s.low, s.high, d), r.uniform1f(i.uniform(`uLerpScalar_${e}`), u);
    }
  }
}
function KB(i) {
  const e = /\/\/.*?$|\/\*(?:.|\n)*?\*\/|'(?:\\.|[^\\'])*'|"(?:\\.|[^\\"])*"/mg;
  return i.replace(e, (t) => t.startsWith("/") ? t.replace(/[^\s]/g, " ") : t);
}
function YB(i) {
  const e = /^(?:-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?|"(?:\\.|[^\\"])*"|true|false|:|\s+|,|\[|\]|\{|\})/;
  let t = 0, n = i;
  e: for (; i.length; ) {
    const r = i.match(e);
    if (r === null) break;
    const s = r[0];
    switch (s.charAt(0)) {
      case "[":
      case "{":
        ++t;
        break;
      case "]":
      case "}":
        if (--t < 0) return -1;
        break;
      case ",":
        if (t === 0) break e;
        break;
      default:
        if (t === 0) {
          i = i.substring(s.length);
          break e;
        }
        break;
    }
    i = i.substring(s.length);
  }
  return t !== 0 ? -1 : n.length - i.length;
}
function XB(i) {
  let e = [], t = new he();
  if (i === void 0)
    return { errors: e, parameters: t };
  const n = /^([_a-z][_a-zA-Z0-9]*)[ \t]*=/;
  for (; i = i.trim(), i.length != 0; ) {
    const r = i.match(n);
    if (r === null) {
      e.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...");
      break;
    }
    const s = r[1];
    i = i.substring(r[0].length);
    let a = YB(i);
    if (a <= 0) {
      e.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...");
      break;
    }
    let l;
    try {
      l = JSON.parse(i.substring(0, a));
    } catch {
      e.push(`Invalid #uicontrol parameter value for ${s}: ${l}`);
      break;
    }
    t.has(s) ? e.push(`Duplicate #uicontrol parameter: ${s}`) : t.set(s, l), i = i.substring(a), i = i.trim(), i.length > 0 && !i.startsWith(",") && e.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ..."), i = i.substring(1);
  }
  return { parameters: t, errors: e };
}
function ZB(i, e) {
  let t, n, r, s, a = [];
  i !== "float" && i !== "uint" && i !== "int" && a.push("type must be float, int, or uint");
  for (const d of e) {
    var l = de(d, 2);
    const u = l[0], h = l[1], g = () => {
      if (typeof h != "number") {
        a.push(`Expected ${u} argument to be a number`);
        return;
      }
      return (i === "int" || i === "uint") && (jn(h) || a.push(`Expected ${u} argument to be an integer`), i === "uint" && h < 0 && a.push(`Expected ${u} argument to be an unsigned integer`)), h;
    };
    u === "min" ? t = g() : u === "max" ? n = g() : u === "default" ? s = g() : u === "step" ? r = g() : a.push(`Invalid parameter: ${u}`);
  }
  return t === void 0 && a.push("min must be specified"), n === void 0 && a.push("max must be specified"), t !== void 0 && n !== void 0 && (t > n && a.push("min must be less than max"), r === void 0 && (i === "float" ? r = (n - t) / 100 : r = 1), s !== void 0 ? (s < t || s > n) && a.push("default must be within valid range") : i === "float" ? s = (t + n) / 2 : s = t), a.length > 0 ? { errors: a } : {
    control: { type: "slider", valueType: i, min: t, max: n, step: r, default: s },
    errors: void 0
  };
}
function QB(i, e) {
  let t = false, n = [];
  i !== "bool" && n.push("type must be bool");
  for (const s of e) {
    var r = de(s, 2);
    const a = r[0], l = r[1];
    if (a === "default") {
      if (typeof l != "boolean") {
        n.push(`Expected ${a} argument to be a boolean`);
        continue;
      }
      t = l;
    } else
      n.push(`Invalid parameter: ${a}`);
  }
  return n.length > 0 ? { errors: n } : {
    control: { type: "checkbox", valueType: i, default: t },
    errors: void 0
  };
}
function eF(i, e) {
  let t = "white", n = [];
  i !== "vec3" && n.push("type must be vec3");
  for (const s of e) {
    var r = de(s, 2);
    const a = r[0], l = r[1];
    a === "default" ? typeof l != "string" ? n.push("Expected default argument to be a string") : t = l : n.push(`Invalid parameter: ${a}`);
  }
  return n.length > 0 ? { errors: n } : {
    control: {
      type: "color",
      valueType: i,
      defaultString: t,
      default: ua(t)
    },
    errors: void 0
  };
}
function oD(i, e) {
  typeof i == "number" && (i = [i]);
  const t = new Array(e);
  return lt(t, i, (n) => {
    if (!jn(n) || n < 0)
      throw new Error(`Expected non-negative integer, but received: ${oe(n)}`);
    return n;
  }), t;
}
function tF(i, e, t) {
  let n = [];
  const r = t.imageData;
  if (r === void 0)
    return n.push("invlerp control not supported"), { errors: n };
  i !== "invlerp" && n.push("type must be invlerp");
  let s = new Array(r.channelRank).fill(0);
  const a = r.dataType;
  let l = true, d = Cc[a], u;
  for (let g of e) {
    var h = de(g, 2);
    let v = h[0], y = h[1];
    try {
      switch (v) {
        case "range": {
          d = uu(y, a);
          break;
        }
        case "window": {
          u = XT(uu(y, a));
          break;
        }
        case "clamp": {
          typeof y != "boolean" ? n.push(`Invalid clamp value: ${oe(y)}`) : l = y;
          break;
        }
        case "channel": {
          s = oD(y, s.length);
          break;
        }
        default:
          n.push(`Invalid parameter: ${v}`);
          break;
      }
    } catch (C) {
      n.push(`Invalid ${v} value: ${C.message}`);
    }
  }
  return n.length > 0 ? { errors: n } : {
    control: {
      type: "invlerp",
      dataType: a,
      clamp: l,
      default: { range: d, window: u ?? vO(d), channel: s }
    },
    errors: void 0
  };
}
var nF = new he([["slider", ZB], ["color", eF], ["invlerp", tF], ["checkbox", QB]]);
function Sh(i, e = {}) {
  i = KB(i);
  const t = /^[ \t]*#[ \t]*uicontrol[ \t]+(.*)$/mg, n = /^([_a-zA-Z][_a-zA-Z0-9]*)[ \t]+([a-z][a-zA-Z0-9_]*)(?:[ \t]+([a-z]+))?[ \t]*(?:\([ \t]*(.*)\)[ \t]*)?/;
  let r = [];
  const s = new he(), a = i.replace(t, (l, d, u) => {
    var h;
    const g = d.match(n), v = () => Math.max(0, i.substring(0, u).split(`
`).length - 1);
    if (g === null)
      return r.push({
        line: v(),
        message: "Invalid #uicontrol syntax, expected: #uicontrol <type> <name> <control>(<param>=<value>, ...)"
      }), "";
    const y = g[1], C = g[2], w = (h = g[3]) !== null && h !== void 0 ? h : y, b = g[4];
    var E = XB(b);
    const T = E.parameters, I = E.errors;
    for (const L of I)
      r.push({ line: v(), message: L });
    if (s.has(C) && r.push({ line: v(), message: `Duplicate definition for control ${C}` }), I.length > 0)
      return "";
    const R = nF.get(w);
    if (R === void 0)
      return r.push({ line: v(), message: `Invalid control type ${w}` }), "";
    const P = R(y, T, e);
    if (P.errors !== void 0) {
      for (const L of P.errors)
        r.push({ line: v(), message: L });
      return "";
    }
    return s.set(C, P.control), "";
  });
  return { source: i, code: a, errors: r, controls: s };
}
function lD(i) {
  return `u_shaderControl_${i}`;
}
function lc(i, e) {
  const t = i.builderValues;
  for (const r of i.parseResult.controls) {
    var n = de(r, 2);
    const s = n[0], a = n[1], l = lD(s), d = t[s];
    switch (a.type) {
      case "invlerp": {
        const u = [aD(e, l, a.dataType, a.clamp), `
float ${l}() {
  return ${l}(getDataValue(${d.channel.join(",")}));
}
`];
        e.addFragmentCode(u), e.addFragmentCode(`#define ${s} ${l}
`);
        break;
      }
      case "checkbox": {
        const u = `#define ${s} ${d.value}
`;
        e.addFragmentCode(u), e.addVertexCode(u);
        break;
      }
      default: {
        e.addUniform(`highp ${a.valueType}`, l), e.addVertexCode(`#define ${s} ${l}
`), e.addFragmentCode(`#define ${s} ${l}
`);
        break;
      }
    }
  }
}
function iF(i) {
  const e = {};
  for (const n of i) {
    var t = de(n, 2);
    const r = t[0], s = t[1];
    e[r] = s;
  }
  return e;
}
function Lx(i) {
  if (i !== void 0)
    return oe(iF(i));
}
var rF = class {
  constructor() {
    this.changed = new Le(), this.controls = void 0;
  }
  get value() {
    return this.controls;
  }
  set value(e) {
    Lx(e) !== Lx(this.controls) && (this.controls = e, this.changed.dispatch());
  }
};
function sF(i, e, t) {
  return i === void 0 ? t : (me(i), {
    range: xe(i, "range", (n) => uu(n, e), t.range),
    window: xe(i, "window", (n) => XT(uu(n, e)), t.window),
    channel: xe(i, "channel", (n) => oD(n, t.channel.length), t.channel)
  });
}
var aF = class extends fn {
  constructor(e, t) {
    super(t, (n) => sF(n, e, t)), this.dataType = e, this.defaultValue = t;
  }
  toJSON() {
    var e = this.value;
    const t = e.range, n = e.window, r = e.channel, s = this.dataType, a = this.defaultValue, l = VC(t, s, a.range), d = VC(n, s, a.window), u = He(a.channel, r) ? void 0 : r;
    if (!(l === void 0 && d === void 0 && u === void 0))
      return { range: l, window: d, channel: u };
  }
};
function cD(i) {
  switch (i.type) {
    case "slider":
      return {
        trackable: new fn(i.default, (e) => {
          let t;
          if (i.valueType === "float" ? t = Dt(e) : t = gn(e), t < i.min || t > i.max)
            throw new Error(`${oe(e)} is outside valid range [${i.min}, ${i.max}]`);
          return t;
        }),
        getBuilderValue: () => null
      };
    case "color":
      return { trackable: new Ql(i.default), getBuilderValue: () => null };
    case "invlerp":
      return {
        trackable: new aF(i.dataType, i.default),
        getBuilderValue: (e) => ({ channel: e.channel, dataType: i.dataType })
      };
    case "checkbox":
      return {
        trackable: new nn(i.default),
        getBuilderValue: (e) => ({ value: e })
      };
  }
}
function dD(i, e) {
  return oe(i) + "\0" + e.source;
}
function zy(i) {
  const e = {};
  for (const r of i.controls) {
    var t = de(r, 2);
    const s = t[0], a = t[1];
    var n = cD(a);
    const l = n.trackable, d = n.getBuilderValue;
    e[s] = d(l.value);
  }
  return { builderValues: e, parseResult: i, key: dD(e, i) };
}
var $y = class extends X {
  constructor(e, t = ta({}), n) {
    super(), this.fragmentMain = e, this.dataContext = t, this.channelCoordinateSpaceCombiner = n, this.changed = new Le(), this.controls = new rF(), this.fragmentMainGeneration = -1, this.dataContextGeneration = -1, this.parseErrors_ = [], this.processedFragmentMain_ = "", this.controlsGeneration = -1, this.parseResultChanged = new Le(), this.state_ = new he(), this.unparsedJson = void 0, this.registerDisposer(e.changed.add(() => this.handleFragmentMainChanged())), this.registerDisposer(this.controls.changed.add(() => this.handleControlsChanged())), this.registerDisposer(this.dataContext.changed.add(() => this.handleFragmentMainChanged())), this.handleFragmentMainChanged();
    const r = this;
    this.parseErrors = {
      changed: this.parseResultChanged,
      get value() {
        return r.handleFragmentMainChanged(), r.parseErrors_;
      }
    }, this.processedFragmentMain = {
      changed: this.parseResultChanged,
      get value() {
        return r.handleFragmentMainChanged(), r.processedFragmentMain_;
      }
    }, this.parseResult = {
      changed: this.parseResultChanged,
      get value() {
        return r.parseResult_;
      }
    }, this.builderState = wi((l, d) => {
      const u = {};
      for (const v of d) {
        var h = de(v, 2);
        const y = h[0];
        var g = h[1];
        const C = g.trackable, w = g.getBuilderValue, b = w(C.value);
        u[y] = b;
      }
      return {
        key: dD(u, l),
        parseResult: l,
        builderValues: u
      };
    }, [this.parseResult, this], (l, d) => l.key === d.key);
    const s = wi((l) => {
      const d = [];
      for (const u of l.values()) {
        const h = u.control, g = u.trackable;
        h.type === "invlerp" && d.push({ channel: g.value.channel });
      }
      return d;
    }, [this], (l, d) => Sm(l, d, (u, h) => He(u.channel, h.channel))), a = nr((l) => {
      const d = [];
      for (const u of l.values()) {
        const h = u.control, g = u.trackable;
        h.type === "invlerp" && d.push(g.value.window);
      }
      return d;
    }, this);
    this.histogramSpecifications = this.registerDisposer(new rD(s, a));
  }
  handleFragmentMainChanged() {
    const e = this.fragmentMain.changed.count, t = this.dataContext.changed.count;
    if (e === this.fragmentMainGeneration && t === this.dataContextGeneration)
      return;
    this.fragmentMainGeneration = e, this.dataContextGeneration = t;
    const n = this.dataContext.value;
    if (n === null)
      this.parseResult_ = {
        source: "",
        code: "",
        controls: new he(),
        errors: [{ line: 0, message: "Loading" }]
      }, this.parseErrors_ = [], this.processedFragmentMain_ = "", this.controls.value = void 0;
    else {
      const r = this.parseResult_ = Sh(this.fragmentMain.value, n);
      this.parseErrors_ = r.errors, this.processedFragmentMain_ = r.code, r.errors.length === 0 && (this.controls.value = r.controls);
    }
    this.parseResultChanged.dispatch();
  }
  handleControlsChanged() {
    const e = this.controls.changed.count;
    if (e === this.controlsGeneration)
      return;
    this.controlsGeneration = e;
    const t = this.controls.value;
    if (t === void 0)
      return;
    let n = false;
    const r = this.state_, s = this.unparsedJson;
    for (const u of r) {
      var a = de(u, 2);
      const h = a[0], g = a[1];
      if (t.get(h) === void 0) {
        g.trackable.changed.remove(this.changed.dispatch), r.delete(h), n = true;
        continue;
      }
    }
    for (const u of t) {
      var l = de(u, 2);
      const h = l[0], g = l[1];
      let v = r.get(h);
      if (v !== void 0 && oe(v.control) !== oe(g) && (v.trackable.changed.remove(this.changed.dispatch), v = void 0), v === void 0) {
        var d = cD(g);
        const y = d.trackable, C = d.getBuilderValue;
        v = { control: g, trackable: y, getBuilderValue: C }, v.trackable.changed.add(this.changed.dispatch), r.set(h, v), n = true;
      }
      if (s !== void 0 && s.hasOwnProperty(h)) {
        n = true;
        try {
          v.trackable.restoreState(s[h]);
        } catch {
        }
      }
    }
    s !== void 0 && (n = true), this.unparsedJson = void 0, n && this.changed.dispatch();
  }
  get state() {
    return this.controls.changed.count !== this.controlsGeneration && this.handleControlsChanged(), this.state_;
  }
  get value() {
    return this.state;
  }
  restoreState(e) {
    if (e === void 0) return;
    const t = this.state;
    if (me(e), this.controls.value === void 0) {
      this.unparsedJson = e, this.changed.dispatch();
      return;
    }
    for (const s of t) {
      var r = de(s, 2);
      const a = r[0], d = r[1].trackable;
      if (d.reset(), e.hasOwnProperty(a))
        try {
          d.restoreState(e[a]);
        } catch {
        }
    }
    this.unparsedJson = void 0;
  }
  reset() {
    for (const e of this.state.values())
      e.trackable.reset();
    this.unparsedJson !== void 0 && (this.unparsedJson = void 0, this.changed.dispatch());
  }
  toJSON() {
    const e = this.state, t = this.unparsedJson;
    if (t !== void 0) return t;
    const n = {};
    let r = true;
    for (const a of e) {
      var s = de(a, 2);
      const l = s[0], u = s[1].trackable.toJSON();
      u !== void 0 && (n[l] = u, r = false);
    }
    if (!r)
      return n;
  }
};
function Dx(i, e, t, n, r) {
  const s = lD(t), a = e.uniform(s);
  switch (n.type) {
    case "slider":
      switch (n.valueType) {
        case "int":
        case "uint":
          i.uniform1i(a, r);
          break;
        case "float":
          i.uniform1f(a, r);
      }
      break;
    case "color":
      i.uniform3fv(a, r);
      break;
    case "invlerp":
      Uy(e, s, n.dataType, r.range);
      break;
  }
}
function wo(i, e, t, n) {
  const r = t.state;
  if (t.controls.value === n)
    for (const l of r) {
      var s = de(l, 2);
      const d = s[0], u = s[1];
      Dx(i, e, d, u.control, u.trackable.value);
    }
  else
    for (const l of n) {
      var a = de(l, 2);
      const d = a[0], u = a[1], h = r.get(d), g = h !== void 0 && oe(h.control) === oe(u) ? h.trackable.value : u.default;
      Dx(i, e, d, u, g);
    }
}
var oF = class extends vt {
};
var lF = class extends Ay {
  constructor() {
    super((e, { showMatches: t, segmentationState: n }) => {
      e.registerDisposer(t.changed.add(this.changed.dispatch)), e.registerDisposer(n.changed.add(this.changed.dispatch)), e.registerDisposer(Or((r, s) => {
        if (s == null) return;
        const a = s.segmentationGroupState;
        r.registerDisposer(a.changed.add(this.changed.dispatch)), r.registerDisposer(Or((l, d) => {
          const u = d.visibleSegments;
          let h = u.size === 0;
          l.registerDisposer(u.changed.add(() => {
            const g = u.size === 0;
            g !== h && (h = g, this.changed.dispatch());
          }));
        }, a));
      }, n));
    });
  }
  get(e) {
    let t = super.get(e);
    return t === void 0 && (t = {
      segmentationState: new vt(void 0),
      showMatches: new nn(false)
    }, super.set(e, t)), t;
  }
};
var Ix = `
void main() {
  setColor(defaultColor());
}
`;
var cF = class extends X {
  constructor() {
    super(...arguments), this.shader = _y(Ix), this.shaderControls = new $y(this.shader), this.fallbackShaderControls = new vt(zy(Sh(Ix))), this.shaderError = vh(), this.color = new Ql(wt(1, 1, 0)), this.relationshipStates = this.registerDisposer(new lF()), this.ignoreNullSegmentFilter = new nn(true), this.displayUnfiltered = nr((e, t) => {
      for (const n of e.values())
        if (n.showMatches.value) {
          if (!t) return false;
          const r = n.segmentationState.value;
          if (r != null && r.segmentationGroupState.value.visibleSegments.size > 0)
            return false;
        }
      return true;
    }, this.relationshipStates, this.ignoreNullSegmentFilter), this.hoverState = new oF(void 0);
  }
};
var $m = class extends X {
  constructor(e) {
    super();
    const t = e.transform, n = e.localPosition, r = e.source;
    var s = e.role;
    const a = s === void 0 ? Ei.ANNOTATION : s;
    this.transform = t, this.localPosition = n, this.source = this.registerDisposer(r), this.role = a, this.displayState = e.displayState, this.chunkTransform = this.registerDisposer(nr((l) => jL(() => wL(cB(l))), this.transform)), this.dataSource = e.dataSource, this.subsourceId = e.subsourceId, this.subsourceIndex = e.subsourceIndex;
  }
  get sourceIndex() {
    const e = this.dataSource;
    return e.layer.dataSources.indexOf(e);
  }
};
var bh = class _bh {
  constructor(e, t, n) {
    this.size = bm(e), this.transform = oN(t), this.finiteRank = n;
    const r = nt(), s = wy(r, 4, t, 4, 4);
    if (s === 0)
      throw new Error("Transform is singular");
    this.invTransform = r, this.detTransform = s;
  }
  toObject() {
    return { size: this.size, transform: this.transform, finiteRank: this.finiteRank };
  }
  static fromObject(e) {
    return new _bh(e.size, e.transform, e.finiteRank);
  }
  /**
   * Transform global spatial coordinates to local spatial coordinates.
   */
  globalToLocalSpatial(e, t) {
    return yi(e, t, this.invTransform);
  }
  localSpatialVectorToGlobal(e, t) {
    return kN(e, t, this.transform);
  }
  /**
   * Returns the unnormalized normal vector.
   */
  globalToLocalNormal(e, t) {
    return DT(e, t, this.transform);
  }
};
var dF = nt();
function uF(i, e) {
  let t = 0, n = Math.abs(i.detTransform);
  const r = i.transform, s = i.size;
  for (let a = 0; a < 3; ++a) {
    let l = 0;
    for (let u = 0; u < 3; ++u)
      l += e[u * 4 + 2] * r[4 * a + u];
    const d = s[a];
    t += Math.abs(l) * d, n *= d;
  }
  return n / t;
}
function uD(i, e, t) {
  const n = i.curPositionInChunks, r = i.fixedPositionWithinChunk, s = i.nonDisplayLowerClipBound, a = i.nonDisplayUpperClipBound;
  var l = i.source.spec;
  const d = l.rank, u = l.chunkDataSize;
  if (!ic(n, e, t, i.layerRank, i.fixedLayerToChunkTransform))
    return false;
  for (let h = 0; h < d; ++h) {
    const g = n[h];
    if (g < s[h] || g >= a[h])
      return false;
    const v = u[h], y = n[h] = Math.floor(g / v);
    r[h] = g - y * v;
  }
  return true;
}
function hF(i, e) {
  let t = e.length, n = 0;
  if (t > 1) {
    let r = 0;
    for (let s = 0; s < t; ++s) {
      const l = e[s].chunkLayout;
      let d = uF(l, i);
      d > r && (r = d, n = s);
    }
  }
  return n;
}
var Ja = new bh(ze(), nt(), 0);
var fF = class extends AL {
  constructor() {
    super(...arguments), this.viewportNormalInGlobalCoordinates = ze(), this.viewportNormalInCanonicalCoordinates = ze(), this.centerDataPosition = ze(), this.pixelSize = 0;
  }
};
function pF(i, e) {
  if (i.displayDimensionRenderInfo !== e.displayDimensionRenderInfo || i.pixelSize !== e.pixelSize) return true;
  const t = i.viewMatrix, n = e.viewMatrix;
  for (let r = 0; r < 12; ++r)
    if (t[r] !== n[r]) return true;
  return false;
}
var gF = class extends cr {
  constructor(e) {
    super(), this.projectionParameters = e, this.visibleLayers = new he(), this.visibleSourcesStale = true, this.registerDisposer(e.changed.add((t, n) => {
      pF(t, n) && this.invalidateVisibleSources(), this.invalidateVisibleChunks();
    }));
  }
  invalidateVisibleSources() {
    this.visibleSourcesStale = true;
  }
  invalidateVisibleChunks() {
  }
  /**
   * Computes the list of sources to use for each visible layer, based on the
   * current pixelSize.
   */
  updateVisibleSources() {
    if (!this.visibleSourcesStale)
      return;
    this.visibleSourcesStale = false;
    const e = this.projectionParameters.value.displayDimensionRenderInfo, t = this.visibleLayers;
    for (const s of t) {
      var n = de(s, 2);
      const a = n[0];
      var r = n[1];
      const l = r.allSources, d = r.visibleSources, u = r.displayDimensionRenderInfo;
      if (d.length = 0, u !== e || l.length === 0)
        continue;
      const h = hF(this.projectionParameters.value.viewMatrix, l.map((v) => v[0])), g = l[h];
      for (const v of a.filterVisibleSources(this, g))
        d.push(v);
      d.reverse();
    }
  }
};
var mF = 18;
function wu(i) {
  let e = i.rank, t = i.upperVoxelBound;
  var n = i.maxVoxelsPerChunkLog2;
  let r = n === void 0 ? mF : n, s = i.chunkToViewTransform, a = i.displayRank, l = i.minBlockSize, d = i.maxBlockSize;
  var u = i.lowerVoxelBound;
  const h = u === void 0 ? new Uint32Array(e) : u, g = new Float32Array(e);
  for (let w = 0; w < e; ++w) {
    let b = 0;
    for (let E = 0; E < a; ++E) {
      const T = s[w * a + E];
      b += T * T;
    }
    g[w] = Math.sqrt(b);
  }
  const v = new Uint32Array(e);
  l !== void 0 ? v.set(l) : v.fill(1);
  const y = new Array(e);
  for (let w = 0; w < e; ++w) {
    let b = Number.POSITIVE_INFINITY;
    g[w] === 0 ? b = v[w] : (t !== void 0 && (b = Math.pow(2, Math.floor(Zn(t[w] - h[w])))), d !== void 0 && (b = Math.min(b, d[w]))), y[w] = b;
  }
  function C() {
    let w = 1 / 0, b = -1;
    for (let E = 0; E < e; ++E) {
      if (v[E] >= y[E])
        continue;
      let T = v[E] * g[E];
      T < w && (w = T, b = E);
    }
    return b;
  }
  r -= Zn(xy(v));
  for (let w = 0; w < r; ++w) {
    let b = C();
    if (b === -1)
      break;
    v[b] *= 2;
  }
  return v;
}
function vF(i) {
  const e = [], t = i.displayRank, n = i.chunkToViewTransform, r = i.rank;
  if (t > 3)
    throw new Error("Unsupported view transform");
  if (t < 3)
    return [wu(i)];
  for (let s = 0; s < 3; ++s) {
    const a = (s + 2) % 3, l = new Float32Array(n);
    for (let d = 0; d < r; ++d)
      l[d * t + a] = 0;
    e[s] = wu(H(H({}, i), { chunkToViewTransform: l }));
  }
  return e;
}
var oo;
(function(i) {
  i[i.ISOTROPIC = 0] = "ISOTROPIC", i[i.FLAT = 1] = "FLAT";
})(oo || (oo = {}));
function yF(i) {
  if (i.chunkDataSizes !== void 0)
    return i.chunkDataSizes;
  var e = i.chunkLayoutPreference;
  switch (e === void 0 ? oo.ISOTROPIC : e) {
    case oo.ISOTROPIC:
      return [wu(i)];
    case oo.FLAT:
      return vF(i);
  }
}
function Dc(i) {
  const e = i.rank, t = i.chunkDataSize, n = i.upperVoxelBound;
  var r = i.lowerVoxelBound;
  const s = r === void 0 ? new Float32Array(e) : r, a = new Float32Array(e), l = new Float32Array(e);
  for (let d = 0; d < e; ++d)
    a[d] = Math.floor(s[d] / t[d]), l[d] = Math.floor((n[d] - 1) / t[d] + 1);
  return {
    rank: e,
    chunkDataSize: t,
    lowerChunkBound: a,
    upperChunkBound: l,
    lowerVoxelBound: s,
    upperVoxelBound: n
  };
}
function* SF(i, e, t) {
  const n = i.projectionParameters.value.pixelSize * 1.1, r = t[0].effectiveVoxelSize, s = e.renderScaleTarget.value, a = (h) => {
    const g = n * s;
    for (let v = 0; v < 3; ++v) {
      const y = h[v];
      if (y > g && y > 1.01 * r[v])
        return true;
    }
    return false;
  }, l = (h, g) => {
    const v = n * s;
    for (let y = 0; y < 3; ++y) {
      const C = h[y], w = g[y];
      if (Math.abs(v - C) < Math.abs(v - w) && C < 1.01 * w)
        return true;
    }
    return false;
  };
  let d = t.length - 1, u;
  for (; ; ) {
    const h = t[d];
    if (u !== void 0 && !l(h.effectiveVoxelSize, u) || (yield h, d === 0 || !a(h.effectiveVoxelSize)))
      break;
    u = h.effectiveVoxelSize, --d;
  }
}
var bF = "SliceView";
var wF = "sliceview/RenderLayer";
var CF = "SliceView.addVisibleLayer";
var xF = "SliceView.removeVisibleLayer";
var Gy = new Float32Array(3);
var Wy = new Float32Array(3);
var hD = nt();
var fD = new Float32Array(24);
function pD2(i, e, t, n) {
  const r = Gy, s = Wy, a = e.lowerChunkDisplayBound, l = e.upperChunkDisplayBound;
  for (let g = 0; g < 3; ++g)
    r[g] = Math.max(r[g], a[g]), s[g] = Math.min(s[g], l[g]);
  const d = e.curPositionInChunks, u = e.chunkDisplayDimensionIndices;
  function h() {
    if (!n(r[0], r[1], r[2], s[0], s[1], s[2], i))
      return;
    let g = 0, v = Math.max(0, s[0] - r[0]), y = v;
    for (let E = 1; E < 3; ++E) {
      const T = Math.max(0, s[E] - r[E]);
      y *= T, T > v && (v = T, g = E);
    }
    if (y === 0) return;
    if (y === 1) {
      d[u[0]] = r[0], d[u[1]] = r[1], d[u[2]] = r[2], t(r, i);
      return;
    }
    const C = r[g], w = s[g], b = Math.floor(0.5 * (C + w));
    s[g] = b, h(), s[g] = w, r[g] = b, h(), r[g] = C;
  }
  h();
}
function gD(i, e, t, n) {
  if (!uD(t, i.globalPosition, e))
    return;
  const r = t.chunkLayout.size, s = vn(hD, i.viewProjectionMat, t.chunkLayout.transform);
  for (let u = 0; u < 3; ++u) {
    const h = r[u];
    for (let g = 0; g < 4; ++g)
      s[4 * u + g] *= h;
  }
  const a = fD;
  ou(a, s);
  const l = Gy, d = Wy;
  l.fill(Number.NEGATIVE_INFINITY), d.fill(Number.POSITIVE_INFINITY), pD2(a, t, n, PT);
}
function EF(i, e, t, n, r) {
  if (!uD(t, i.globalPosition, e))
    return;
  const s = n.size, a = vn(hD, i.viewProjectionMat, n.transform);
  for (let v = 0; v < 3; ++v) {
    const y = s[v];
    for (let C = 0; C < 4; ++C)
      a[4 * v + C] *= y;
  }
  const l = dF;
  ys(l, a);
  const d = Gy, u = Wy, h = 1e-3;
  for (let v = 0; v < 3; ++v) {
    const y = l[12 + v] + h / s[v], C = Math.abs(l[v]), w = Math.abs(l[4 + v]);
    d[v] = Math.floor(y - C - w), u[v] = Math.floor(y + C + w + 1);
  }
  const g = fD;
  for (let v = 0; v < 3; ++v) {
    const y = a[4 * v], C = a[4 * v + 1], w = a[4 * v + 2];
    g[v] = y, g[4 + v] = -y, g[8 + v] = +C, g[12 + v] = -C, g[16 + v] = +w, g[20 + v] = -w;
  }
  {
    const y = a[12], C = a[4 * 3 + 1], w = a[4 * 3 + 2];
    g[3] = 1 + y, g[7] = 1 - y, g[11] = 1 + C, g[15] = 1 - C, g[19] = w, g[23] = -w;
  }
  pD2(g, t, r, LN);
}
function Hy(i, e) {
  const t = e.finiteRank;
  if (t === 3) return e;
  Ja.finiteRank = t, pN(Ja.size, e.size);
  const n = ru(Ja.transform, e.transform), r = ru(Ja.invTransform, e.invTransform);
  Ja.detTransform = e.detTransform;
  const s = i.invViewMatrix, a = i.width, l = i.height, d = AT(i.projectionMat);
  for (let u = t; u < 3; ++u) {
    const h = s[12 + u];
    let g = h, v = h;
    const y = Math.abs(s[u] * a);
    g -= y, v += y;
    const C = Math.abs(s[u + 4] * l);
    g -= C, v += C;
    const w = Math.abs(s[u + 8] * d);
    g -= w, v += w;
    const b = Math.max(1, v - g);
    n[12 + u] = g, n[5 * u] = b;
  }
  return ys(r, n), Ja;
}
var kF = "annotation.MetadataChunkSource";
var TF = "annotation.GeometryChunkSource";
var LF = "annotation.SubsetGeometryChunkSource";
var DF = "annotation.reference.add";
var IF = "annotation.reference.delete";
var PF = "annotation.commit";
var RF = "annotation.commit";
var AF = "annotation/SpatiallyIndexedRenderLayer";
var _F = "annotation/PerspectiveRenderLayer:updateSources";
var MF = "annotation/RenderLayer";
var NF = "annotation/RenderLayer.updateSegmentation";
var OF = Sc();
function VF(i, e, t, n, r, s) {
  const a = i.displayDimensionRenderInfo, l = i.viewMatrix, d = i.projectionMat, u = i.width, h = i.height, g = a.voxelPhysicalScales, v = Math.abs(ly(lh(OF, l))), y = Tm(g), C = DN(d) / v * y;
  if (n.length === 0) return;
  const w = n[0];
  let b = Math.abs(w.chunkLayout.detTransform) * y;
  const E = w.lowerClipDisplayBound, T = w.upperClipDisplayBound;
  for (let M = 0; M < 3; ++M)
    b *= T[M] - E[M];
  const I = Math.min(b, C), R = u * h, L = R / t ** 2 / I;
  let A = 0;
  for (let M = n.length - 1; M >= 0 && A < L; --M) {
    const O = n[M], F = O.source.spec, q = O.chunkLayout, U = Tm(q.size) * Math.abs(q.detTransform) * y, V = F.limit, $ = F.rank, B = O.nonDisplayLowerClipBound, ue = O.nonDisplayUpperClipBound;
    let se = 1;
    for (let Me = 0; Me < $; ++Me) {
      const je = ue[Me] - B[Me];
      Lt(je) && (se /= je);
    }
    const Pe = V * se / U, ae = A + Pe, Ee = Math.pow(1 / ae, 1 / 3), ce = Math.sqrt(R / (ae * I)), ge = (L - A) * U / se, Ne = Math.min(1, ge / F.limit);
    gD(i, e, O, () => {
      s(O, M, Ne, Ee, ce);
    }), A = ae;
  }
}
var cc = `vec3 colormapJet(float x) {
  vec3 result;
  result.r = x < 0.89 ? ((x - 0.35) / 0.31) : (1.0 - (x - 0.89) / 0.11 * 0.5);
  result.g = x < 0.64 ? ((x - 0.125) * 4.0) : (1.0 - (x - 0.64) / 0.27);
  result.b = x < 0.34 ? (0.5 + x * 0.5 / 0.11) : (1.0 - (x - 0.34) / 0.31);
  return clamp(result, 0.0, 1.0);
}
vec3 colormapCubehelix(float x) {
  float xclamp = clamp(x, 0.0, 1.0);
  float angle = 2.0 * 3.1415926 * (4.0 / 3.0 + xclamp);
  float amp = xclamp * (1.0 - xclamp) / 2.0;
  vec3 result;
  float cosangle = cos(angle);
  float sinangle = sin(angle);
  result.r = -0.14861 * cosangle + 1.78277 * sinangle;
  result.g = -0.29227 * cosangle + -0.90649 * sinangle;
  result.b = 1.97294 * cosangle;
  result = clamp(xclamp + amp * result, 0.0, 1.0);
  return result;
}
`;
function mD2(i, e) {
  return {
    defineShader(t, n) {
      const r = `prop_${n}`, s = `a_${r}`;
      t.addAttribute(`${i}`, s), t.addVertexCode(`${i} ${r}() { return ${s}; }`), t.addInitializer((a) => {
        const l = a.attribute(s), d = a.gl;
        a.vertexShaderInputBinders[r] = l === -1 ? {
          enable() {
          },
          disable() {
          },
          bind() {
          }
        } : {
          enable(u) {
            d.enableVertexAttribArray(l), d.vertexAttribDivisor(l, u);
          },
          disable() {
            d.vertexAttribDivisor(l, 0), d.disableVertexAttribArray(l);
          },
          bind(u, h) {
            e(d, l, u, h);
          }
        };
      });
    }
  };
}
function vg(i, e, t, n) {
  return mD2(i, (r, s, a, l) => {
    r.vertexAttribPointer(
      s,
      /*size=*/
      e,
      /*type=*/
      t,
      /*normalized=*/
      n,
      a,
      l
    );
  });
}
function Ka(i, e, t) {
  return mD2(i, (n, r, s, a) => {
    n.vertexAttribIPointer(
      r,
      /*size=*/
      e,
      /*type=*/
      t,
      s,
      a
    );
  });
}
var BF = {
  rgb: vg(
    "highp vec3",
    3,
    WebGL2RenderingContext.UNSIGNED_BYTE,
    /*normalized=*/
    true
  ),
  rgba: vg(
    "highp vec4",
    4,
    WebGL2RenderingContext.UNSIGNED_BYTE,
    /*normalized=*/
    true
  ),
  float32: vg(
    "highp float",
    1,
    WebGL2RenderingContext.FLOAT,
    /*normalized=*/
    false
  ),
  uint32: Ka("highp uint", 1, WebGL2RenderingContext.UNSIGNED_INT),
  int32: Ka("highp int", 1, WebGL2RenderingContext.INT),
  uint16: Ka("highp uint", 1, WebGL2RenderingContext.UNSIGNED_SHORT),
  int16: Ka("highp int", 1, WebGL2RenderingContext.SHORT),
  uint8: Ka("highp uint", 1, WebGL2RenderingContext.UNSIGNED_BYTE),
  int8: Ka("highp int", 1, WebGL2RenderingContext.BYTE)
};
var Ic = class extends X {
  constructor(e, t, n, r, s, a, l) {
    super(), this.gl = e, this.annotationType = t, this.rank = n, this.properties = r, this.shaderControlState = s, this.fallbackShaderParameters = a, this.shaderError = l;
    const d = this.serializedGeometryBytesPerAnnotation = Gn[t].serializedBytes(n);
    var u = ZT(n, d, r);
    const h = u.offsets, g = u.serializedBytes, v = u.propertyGroupBytes;
    this.serializedBytesPerAnnotation = g, this.propertyOffsets = h, this.propertyGroupBytes = v, this.geometryDataStride = v[0];
  }
  getDependentShader(e, t) {
    return vo(this, this.gl, {
      memoizeKey: {
        t: "annotation",
        targetIsSliceView: this.targetIsSliceView,
        type: this.annotationType,
        subType: e,
        properties: this.properties,
        rank: this.rank
      },
      fallbackParameters: this.fallbackShaderParameters,
      parameters: this.shaderControlState.builderState,
      shaderError: this.shaderError,
      defineShader: (n, r) => {
        const s = this.rank, a = this.properties, l = [], d = r.parseResult.code;
        for (let C = 0, w = a.length; C < w; ++C) {
          const b = a[C], E = `prop_${b.identifier}`;
          if (!d.match(new RegExp(`\\b${E}\\b`))) continue;
          l.push(C), BF[b.type].defineShader(n, b.identifier, s);
        }
        const u = this.propertyOffsets, h = this.propertyGroupBytes, g = new Array(h.length);
        g[0] = 0;
        for (let C = 1; C < h.length; ++C)
          g[C] = g[C - 1] + h[C - 1];
        n.addInitializer((C) => {
          const w = l.map((E) => C.vertexShaderInputBinders[`prop_${a[E].identifier}`]), b = w.length;
          C.vertexShaderInputBinders.properties = {
            enable(E) {
              for (let T = 0; T < b; ++T)
                w[T].enable(E);
            },
            bind(E, T) {
              for (let R = 0; R < b; ++R) {
                var I = u[l[R]];
                let P = I.group, L = I.offset;
                w[R].bind(
                  /*stride=*/
                  h[P],
                  /*offset=*/
                  T + L + g[P] * E
                );
              }
            },
            disable() {
              for (let E = 0; E < b; ++E)
                w[E].disable();
            }
          };
        }), n.addUniform("highp vec3", "uColor"), n.addUniform("highp uint", "uSelectedIndex"), n.addVarying("highp vec4", "vColor"), n.addUniform("highp vec3", "uSubspaceMatrix", s), n.addUniform("highp mat4", "uModelViewProjection"), n.addUniform("highp float", "uModelClipBounds", s * 2), n.addUniform("highp uint", "uPickID"), n.addVarying("highp uint", "vPickID", "flat"), n.addVertexCode(cc), n.addVertexCode(`
vec3 defaultColor() { return uColor; }
highp uint getPickBaseOffset() { return uint(gl_InstanceID) * ${this.pickIdsPerInstance}u; }
`), n.addFragmentCode(`
void emitAnnotation(vec4 color) {
  emit(color, vPickID);
}
`);
        const v = `
float getSubspaceClipCoefficient(float modelPoint[${this.rank}]) {
  float coefficient = 1.0;
  for (int i = 0; i < ${s}; ++i) {
    float d = abs(modelPoint[i] - uModelClipBounds[i]) * uModelClipBounds[${s} + i];
    coefficient *= max(0.0, 1.0 - d);
  }
  return coefficient;
}
`;
        n.addVertexCode(v), n.addFragmentCode(v), n.addVertexCode(`
vec3 projectModelVectorToSubspace(float modelPoint[${this.rank}]) {
  vec3 result = vec3(0.0, 0.0, 0.0);
  for (int i = 0; i < ${s}; ++i) {
    result += uSubspaceMatrix[i] * modelPoint[i];
  }
  return result;
}

float getMaxEndpointSubspaceClipCoefficient(float modelPointA[${this.rank}],  float modelPointB[${this.rank}]) {
  float coefficient = 1.0;
  for (int i = 0; i < ${s}; ++i) {
    float dA = abs(modelPointA[i] - uModelClipBounds[i]) * uModelClipBounds[${s} + i];
    float dB = abs(modelPointB[i] - uModelClipBounds[i]) * uModelClipBounds[${s} + i];
    coefficient *= max(0.0, 1.0 - min(dA, dB));
  }
  return coefficient;
}

float getMaxSubspaceClipCoefficient(float modelPointA[${this.rank}],  float modelPointB[${this.rank}]) {
  float coefficient = 1.0;
  for (int i = 0; i < ${s}; ++i) {
    float a = modelPointA[i];
    float b = modelPointB[i];
    float c = uModelClipBounds[i];
    float x = clamp(c, min(a, b), max(a, b));
    float d = abs(x - c) * uModelClipBounds[${s} + i];
    coefficient *= max(0.0, 1.0 - d);
  }
  return coefficient;
}

`), lc(r, n), n.addVertexCode(`
const bool PROJECTION_VIEW = ${!this.targetIsSliceView};
bool ng_discardValue;
#define discard ng_discard()
void ng_discard() {
  ng_discardValue = true;
}
void setLineColor(vec4 startColor, vec4 endColor);
void setLineWidth(float width);

void setAxisColor(vec4 startColor, vec4 endColor);
void setAxisWidth(float width);
void setSphereColor(vec4 color);

void setEndpointMarkerColor(vec4 startColor, vec4 endColor);
void setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor);
void setEndpointMarkerSize(float startSize, float endSize);
void setEndpointMarkerBorderWidth(float startSize, float endSize);

void setPointMarkerColor(vec4 color);
void setPointMarkerBorderColor(vec4 color);
void setPointMarkerSize(float size);
void setPointMarkerBorderWidth(float size);
void setPointMarkerBorderColor(vec3 color) { setPointMarkerBorderColor(vec4(color, 1.0)); }

void setAxisEndpointMarkerColor(vec4 startColor, vec4 endColor);
void setAxisEndpointMarkerBorderColor(vec4 startColor, vec4 endColor);
void setAxisEndpointMarkerSize(float startSize, float endSize);
void setAxisEndpointMarkerBorderWidth(float startSize, float endSize);

void setAxisPointMarkerColor(vec4 color);
void setAxisPointMarkerBorderColor(vec4 color);
void setAxisPointMarkerSize(float size);
void setAxisPointMarkerBorderWidth(float size);

void setEllipsoidFillColor(vec4 color);

void setBoundingBoxBorderColor(vec4 color);
void setBoundingBoxBorderWidth(float size);
void setBoundingBoxFillColor(vec4 color);

void setEndpointMarkerColor(vec3 startColor, vec3 endColor) {
  setEndpointMarkerColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setEndpointMarkerBorderColor(vec3 startColor, vec3 endColor) {
  setEndpointMarkerBorderColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setEndpointMarkerColor(vec3 color) { setEndpointMarkerColor(color, color); }
void setEndpointMarkerColor(vec4 color) { setEndpointMarkerColor(color, color); }
void setEndpointMarkerBorderColor(vec3 color) { setEndpointMarkerBorderColor(color, color); }
void setEndpointMarkerBorderColor(vec4 color) { setEndpointMarkerBorderColor(color, color); }
void setEndpointMarkerSize(float size) { setEndpointMarkerSize(size, size); }
void setEndpointMarkerBorderWidth(float size) { setEndpointMarkerBorderWidth(size, size); }
void setLineColor(vec4 color) { setLineColor(color, color); }
void setLineColor(vec3 color) { setLineColor(vec4(color, 1.0)); }
void setLineColor(vec3 startColor, vec3 endColor) { setLineColor(vec4(startColor, 1.0), vec4(endColor, 1.0)); }
void setAxisColor(vec4 color) { setAxisColor(color, color); }
void setAxisColor(vec3 color) { setAxisColor(vec4(color, 1.0)); }
void setAxisColor(vec3 startColor, vec3 endColor) { setAxisColor(vec4(startColor, 1.0), vec4(endColor, 1.0)); }
void setAxisEndpointMarkerColor(vec3 startColor, vec3 endColor) {
  setAxisEndpointMarkerColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setAxisEndpointMarkerBorderColor(vec3 startColor, vec3 endColor) {
  setAxisEndpointMarkerBorderColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setAxisEndpointMarkerColor(vec3 color) { setAxisEndpointMarkerColor(color, color); }
void setAxisEndpointMarkerColor(vec4 color) { setAxisEndpointMarkerColor(color, color); }
void setAxisEndpointMarkerBorderColor(vec3 color) { setAxisEndpointMarkerBorderColor(color, color); }
void setAxisEndpointMarkerBorderColor(vec4 color) { setAxisEndpointMarkerBorderColor(color, color); }
void setAxisEndpointMarkerSize(float size) { setAxisEndpointMarkerSize(size, size); }
void setAxisEndpointMarkerBorderWidth(float size) { setAxisEndpointMarkerBorderWidth(size, size); }
void setColor(vec4 color) {
  setPointMarkerColor(color);
  setLineColor(color);
  setEndpointMarkerColor(color);
  setBoundingBoxBorderColor(color);
  setEllipsoidFillColor(vec4(color.rgb, color.a * (PROJECTION_VIEW ? 1.0 : 0.5)));
  setAxisColor(color);
  setAxisEndpointMarkerColor(color);
  setSphereColor(color);
}
void setEllipsoidFillColor(vec3 color) { setEllipsoidFillColor(vec4(color, 1.0)); }

void setBoundingBoxFillColor(vec3 color) { setBoundingBoxFillColor(vec4(color, 1.0)); }
void setBoundingBoxBorderColor(vec3 color) { setBoundingBoxBorderColor(vec4(color, 1.0)); }

void setColor(vec3 color) { setColor(vec4(color, 1.0)); }
void userMain();
`);
        for (const C of qy) {
          var y = de(C, 2);
          const w = y[0], b = y[1];
          w !== this.annotationType && b.defineShaderNoOpSetters(n);
        }
        t(n), n.addVertexCode(`
#define main userMain
` + sc(r.parseResult.code) + `
#undef main
`);
      }
    });
  }
  setPartIndex(e, ...t) {
    let n = `
void setPartIndex(${t.map((r, s) => `highp uint partIndex${s}`).join()}) {
  highp uint pickID = uPickID;
  highp uint pickBaseOffset = getPickBaseOffset();
${t.map((r, s) => `highp uint pickOffset${s} = pickBaseOffset + partIndex${s};`).join(`
`)}
`;
    return t.length === 0 && (n += `
  highp uint pickOffset0 = pickBaseOffset;
`), n += `
  vPickID = pickID + pickOffset0;
  highp uint selectedIndex = uSelectedIndex;
if (selectedIndex == pickBaseOffset${t.map((r, s) => ` || selectedIndex == pickOffset${s}`).join("")}) {
    vColor = vec4(mix(vColor.rgb, vec3(1.0, 1.0, 1.0), 0.75), vColor.a);
  }
}
`, e.addVertexCode(n), `setPartIndex(${t.join()})`;
  }
  get invokeUserMain() {
    return `
ng_discardValue = false;
userMain();
if (ng_discardValue) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
`;
  }
  getCrossSectionFadeFactor() {
    return this.targetIsSliceView ? "(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))" : "(1.0)";
  }
  enable(e, t, n) {
    var r = e(t.renderContext.emitter);
    const s = r.shader, a = r.parameters;
    if (s === null) return;
    s.bind();
    const l = this.gl, d = t.renderContext, u = t.annotationLayer;
    if (wo(l, s, this.shaderControlState, a.parseResult.controls), l.uniform3fv(s.uniform("uSubspaceMatrix"), t.subspaceMatrix), l.uniform1fv(s.uniform("uModelClipBounds"), t.modelClipBounds), l.uniformMatrix4fv(s.uniform("uModelViewProjection"), false, t.modelViewProjectionMatrix), d.emitPickID && l.uniform1ui(s.uniform("uPickID"), t.basePickId), d.emitColor) {
      const g = u.state.displayState.color.value;
      l.uniform3f(s.uniform("uColor"), g[0], g[1], g[2]), l.uniform1ui(s.uniform("uSelectedIndex"), t.selectedIndex);
    }
    const h = s.vertexShaderInputBinders.properties;
    h.enable(1), l.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), h.bind(
      /*stride=*/
      t.count,
      t.bufferOffset
    ), n(s), h.disable();
  }
};
var qy = new he();
function Pc(i, e) {
  qy.set(i, e);
}
function jl(i) {
  return qy.get(i);
}
var jy = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
var Ds = class {
  constructor(e) {
    this.source = e, this.state = kt.SYSTEM_MEMORY;
  }
  get gl() {
    return this.source.gl;
  }
  copyToGPU(e) {
    this.state = kt.GPU_MEMORY;
  }
  freeGPUMemory(e) {
    this.state = kt.SYSTEM_MEMORY;
  }
};
function Px(i) {
  if (typeof i != "number" || i < 0)
    throw new Error(`Expected non-negative number as limit, but received: ${oe(i)}`);
  return i;
}
var Id = class {
  constructor({ defaultItemLimit: e = Number.POSITIVE_INFINITY, defaultSizeLimit: t = Number.POSITIVE_INFINITY } = {}) {
    this.sizeLimit = new fn(t, Px), this.itemLimit = new fn(e, Px);
  }
};
var Gm = class extends cr {
  constructor(e, t, n, r) {
    super(), this.gl = t, this.frameNumberCounter = n, this.capacities = r, this.visibleChunksChanged = new Le(), this.pendingChunkUpdates = null, this.pendingChunkUpdatesTail = null, this.chunkUpdateDeadline = null, this.chunkUpdateDelay = 30, this.enablePrefetch = new nn(true, true);
    const s = (a) => ({
      itemLimit: this.registerDisposer(An.makeFromExisting(e, a.itemLimit)).rpcId,
      sizeLimit: this.registerDisposer(An.makeFromExisting(e, a.sizeLimit)).rpcId
    });
    this.initializeCounterpart(e, {
      gpuMemoryCapacity: s(r.gpuMemory),
      systemMemoryCapacity: s(r.systemMemory),
      downloadCapacity: s(r.download),
      computeCapacity: s(r.compute),
      enablePrefetch: this.registerDisposer(An.makeFromExisting(e, this.enablePrefetch)).rpcId
    });
  }
  scheduleChunkUpdate() {
    let e = this.chunkUpdateDeadline, t;
    e === null || Date.now() < e ? t = 0 : t = this.chunkUpdateDelay, setTimeout(this.processPendingChunkUpdates.bind(this), t);
  }
  processPendingChunkUpdates(e = false) {
    let t = this.chunkUpdateDeadline;
    !e && t === null && (t = Date.now() + 30);
    let n = false, r = 0;
    for (; ; ) {
      if (!e && Date.now() > t) {
        this.chunkUpdateDeadline = null, setTimeout(() => this.processPendingChunkUpdates(), this.chunkUpdateDelay);
        break;
      }
      let s = this.pendingChunkUpdates;
      if (s == null) break;
      if (this.applyChunkUpdate(s) && (n = true), ++r, (this.pendingChunkUpdates = s.nextUpdate) == null) {
        this.pendingChunkUpdatesTail = null;
        break;
      }
    }
    return n && this.visibleChunksChanged.dispatch(), r;
  }
  handleFetch_(e, t) {
    var n = t.promise;
    const r = n.resolve, s = n.reject;
    if (n.cancellationToken.isCanceled) {
      s(bs);
      return;
    }
    const l = t.key, d = e.chunks.get(l);
    if (!d) {
      s(new Error(`No chunk found at ${l} for source ${e.constructor.name}`));
      return;
    }
    const u = d.data;
    if (!u) {
      s(new Error(`At ${l} for source ${e.constructor.name}: chunk has no data`));
      return;
    }
    r({ value: u });
  }
  applyChunkUpdate(e) {
    let t = false;
    const r = this.rpc.get(e.source);
    if (e.promise !== void 0)
      this.handleFetch_(r, e);
    else if (e.id === void 0) {
      for (const s of r.chunks.keys())
        r.deleteChunk(s);
      t = true;
    } else {
      let s = e.state;
      if (s === kt.EXPIRED)
        r.deleteChunk(e.id);
      else {
        let a, l = e.id;
        e.new ? (a = r.getChunk(e), r.addChunk(l, a)) : a = r.chunks.get(l);
        let d = a.state;
        if (s !== d)
          switch (s) {
            case kt.GPU_MEMORY:
              a.copyToGPU(this.gl), t = true;
              break;
            case kt.SYSTEM_MEMORY:
              a.freeGPUMemory(this.gl);
              break;
            default:
              throw new Error(`INTERNAL ERROR: Invalid chunk state: ${kt[s]}`);
          }
      }
    }
    return t;
  }
  flushPendingChunkUpdates() {
    return this.processPendingChunkUpdates(true);
  }
  async getStatistics() {
    const e = this.rpc, t = await e.promiseInvoke(RV, { queue: this.rpcId }), n = new he();
    for (const s of t) {
      var r = de(s, 2);
      const a = r[0], l = r[1], d = e.get(a);
      d !== void 0 && n.set(d, l);
    }
    return n;
  }
};
Gm = jy([ki(DV)], Gm);
function vD(i, e) {
  let t = i.get(e.source), n = t.chunkManager.chunkQueueManager;
  if (t.immediateChunkUpdates) {
    n.applyChunkUpdate(e) && n.visibleChunksChanged.dispatch();
    return;
  }
  let r = n.pendingChunkUpdatesTail;
  r == null ? (n.pendingChunkUpdates = e, n.pendingChunkUpdatesTail = e, n.scheduleChunkUpdate()) : (r.nextUpdate = e, n.pendingChunkUpdatesTail = e);
}
zt("Chunk.update", function(i) {
  vD(this, i);
});
zL("Chunk.retrieve", function(i, e) {
  return new Ft((t, n) => {
    i.promise = { resolve: t, reject: n, cancellationToken: e }, vD(this, i);
  });
});
zt(AV, function(i) {
  const e = this.get(i.id);
  for (const t of e.prevStatisticsLayers)
    t.numVisibleChunksNeeded = 0, t.numVisibleChunksAvailable = 0, t.numPrefetchChunksNeeded = 0, t.numPrefetchChunksAvailable = 0;
  e.prevStatisticsLayers.length = 0;
  for (const t of i.layers) {
    const n = this.get(t.id);
    if (n === void 0) continue;
    const r = n.layerChunkProgressInfo;
    r.numVisibleChunksAvailable = t.numVisibleChunksAvailable, r.numVisibleChunksNeeded = t.numVisibleChunksNeeded, r.numPrefetchChunksAvailable = t.numPrefetchChunksAvailable, r.numPrefetchChunksNeeded = t.numPrefetchChunksNeeded, e.prevStatisticsLayers.push(r);
  }
  e.layerChunkStatisticsUpdated.dispatch();
});
var Wm = class extends cr {
  constructor(e) {
    super(), this.chunkQueueManager = e, this.memoize = new LL(), this.prevStatisticsLayers = [], this.layerChunkStatisticsUpdated = new Le(), this.registerDisposer(e.addRef()), this.initializeCounterpart(e.rpc, { chunkQueueManager: e.rpcId });
  }
  get gl() {
    return this.chunkQueueManager.gl;
  }
  getChunkSource(e, t) {
    const n = e.encodeOptions(t);
    n.constructorId = En(e);
    const r = si(n);
    return this.memoize.get(r, () => {
      const s = new e(this, t);
      return s.initializeCounterpart(this.rpc, {}), s.key = n, s;
    });
  }
};
Wm = jy([ki(IV)], Wm);
var Wr = class extends cr {
  constructor(e, t = {}) {
    super(), this.chunkManager = e, this.chunks = new he(), this.immediateChunkUpdates = false;
  }
  initializeCounterpart(e, t) {
    t.chunkManager = this.chunkManager.rpcId, super.initializeCounterpart(e, t);
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  deleteChunk(e) {
    const t = this.chunks.get(e);
    t.state === kt.GPU_MEMORY && t.freeGPUMemory(this.gl), this.chunks.delete(e);
  }
  addChunk(e, t) {
    this.chunks.set(e, t);
  }
  /**
   * Default implementation for use with backendOnly chunk sources.
   */
  getChunk(e) {
    throw new Error("Not implemented.");
  }
  /**
   * Invalidates the chunk cache.  Operates asynchronously.
   */
  invalidateCache() {
    this.rpc.invoke(PV, { id: this.rpcId });
  }
  static encodeOptions(e) {
    return {};
  }
};
function Jt(i, e) {
  let t = class extends i {
    constructor(...r) {
      super(...r);
      const s = r[1];
      this.parameters = s.parameters;
    }
    initializeCounterpart(r, s) {
      s.parameters = this.parameters, super.initializeCounterpart(r, s);
    }
    static encodeOptions(r) {
      return H({ parameters: r.parameters }, super.encodeOptions(r));
    }
  };
  return t = jy([ki(e.RPC_ID)], t), t;
}
var Rc = class extends cr {
  constructor(e) {
    super(), this.layerChunkProgressInfo = e;
  }
};
var Bi;
(function(i) {
  i[i.MIN_REPRESENTATIVE = 0] = "MIN_REPRESENTATIVE", i[i.MAX_REPRESENTATIVE = 1] = "MAX_REPRESENTATIVE", i[i.REPRESENTATIVE_EXCLUDED = 2] = "REPRESENTATIVE_EXCLUDED", i[i.NONREPRESENTATIVE_EXCLUDED = 4] = "NONREPRESENTATIVE_EXCLUDED";
})(Bi || (Bi = {}));
var FF = class {
};
var UF = class extends X {
  constructor(e, t, n) {
    super(), this.graph = e, this.segmentsState = t, this.transform = n;
  }
  createRenderLayers(e, t, n) {
    return [];
  }
};
function zF(i) {
  return !(i.high >>> 31);
}
var $F = ["visibleSegments", "segmentEquivalences", "temporaryVisibleSegments", "temporarySegmentEquivalences", "useTemporaryVisibleSegments", "useTemporarySegmentEquivalences"];
function GF(i, e, t) {
  i.registerDisposer(e.visibleSegments.changed.add(t)), i.registerDisposer(e.segmentEquivalences.changed.add(t));
}
function WF(i, e, t) {
  i.registerDisposer(e.temporaryVisibleSegments.changed.add(t)), i.registerDisposer(e.temporarySegmentEquivalences.changed.add(t)), i.registerDisposer(e.useTemporaryVisibleSegments.changed.add(t)), i.registerDisposer(e.useTemporarySegmentEquivalences.changed.add(t));
}
function ir(i) {
  return `${i.low},${i.high}`;
}
function HF(i) {
  return !!(i.high >>> 31);
}
function yD2(i) {
  return i.useTemporaryVisibleSegments.value ? i.temporaryVisibleSegments : i.visibleSegments;
}
function qF(i) {
  return i.useTemporarySegmentEquivalences.value ? i.temporarySegmentEquivalences : i.segmentEquivalences;
}
function $o(i, e) {
  const t = yD2(i), n = qF(i);
  if (n.disjointSets) {
    const r = n.disjointSets.visibleSegmentEquivalencePolicy.value;
    for (let s of t.unsafeKeys())
      if (r & Bi.NONREPRESENTATIVE_EXCLUDED) {
        const a = n.get(s);
        e(s, a);
      } else {
        if (n.disjointSets === void 0 || !n.disjointSets.isMinElement(s))
          continue;
        for (let a of n.setElements(s))
          r & Bi.REPRESENTATIVE_EXCLUDED && r & Bi.MAX_REPRESENTATIVE && HF(a) || e(a, s);
      }
  }
}
var dn = 40;
var SD = 0.5;
var bD2 = -4;
function Yd(i) {
  return (Zn(i) - bD2) / SD;
}
function jF(i) {
  return 2 ** (i * SD + bD2);
}
function sa(i) {
  return new fn(i, yn);
}
var Co = class {
  constructor() {
    this.visibility = new rc(), this.changed = new Le(), this.frameNumber = -1, this.spatialScales = new he(), this.numHistogramRows = 1, this.value = new Uint32Array(dn * this.numHistogramRows * 2);
  }
  begin(e) {
    e !== this.frameNumber && (this.value.fill(0), this.frameNumber = e, this.spatialScales.clear(), this.changed.dispatch());
  }
  /**
   * Adds a count to the histogram.
   *
   * @param spatialScale Spatial resolution of data in nanometers.
   * @param renderScale Rendered scale of data in screen pixels.
   * @param presentCount Number of present chunks.
   * @param notPresentCount Number of desired but not-present chunks.
   */
  add(e, t, n, r) {
    let s = this.spatialScales, a = this.numHistogramRows, l = this.value, d = s.get(e);
    if (d === void 0 && (d = s.size, s.set(e, d)), d >= a) {
      this.numHistogramRows = a *= 2;
      const h = new Uint32Array(a * dn * 2);
      h.set(l), this.value = l = h;
    }
    const u = d * dn * 2 + Math.min(Math.max(0, Math.round(Yd(t))), dn - 1);
    l[u] += n, l[u + dn] += r;
  }
};
var Jy = class extends WL {
  constructor(e, t, n) {
    var r;
    super(), this.chunkManager = e, this.multiscaleSource = t, this.rpcId = null, this.rpcTransfer = {}, this.visibleSources = new he(), this.visibleSourcesList_ = [];
    var s = n.renderScaleTarget;
    const a = s === void 0 ? sa(1) : s;
    this.renderScaleTarget = a, this.renderScaleHistogram = n.renderScaleHistogram, this.transform = n.transform, this.localPosition = n.localPosition, this.rpcTransfer = n.rpcTransfer || {}, this.dataHistogramSpecifications = this.registerDisposer((r = n.dataHistogramSpecifications) !== null && r !== void 0 ? r : new rD(ta([]), ta([]))), this.registerDisposer(this.dataHistogramSpecifications.visibility.changed.add(this.redrawNeeded.dispatch));
  }
  getDataHistogramCount() {
    const e = this.dataHistogramSpecifications;
    return e.visibility.visible ? e.bounds.value.length : 0;
  }
  getSources(e) {
    return this.multiscaleSource.getSources(e);
  }
  addSource(e, t) {
    const n = this.visibleSources, r = n.get(e);
    r !== void 0 ? (++r.refCount, r.chunkTransform = t) : (n.set(e, { source: e, refCount: 1, chunkTransform: t }), this.visibleSourcesList_.length = 0);
  }
  removeSource(e) {
    const t = this.visibleSources, n = t.get(e);
    n.refCount !== 1 ? --n.refCount : (t.delete(e), this.visibleSourcesList_.length = 0);
  }
  get visibleSourcesList() {
    const e = this.visibleSources, t = this.visibleSourcesList_;
    if (t.length === 0 && e.size !== 0) {
      for (const n of e.values())
        t.push(n);
      t.sort((n, r) => n.chunkTransform.chunkToLayerTransformDet - r.chunkTransform.chunkToLayerTransformDet);
    }
    return t;
  }
  initializeCounterpart() {
    const e = this.registerDisposer(new Rc(this.layerChunkProgressInfo)), t = this.chunkManager.rpc;
    e.RPC_TYPE_ID = this.RPC_TYPE_ID, e.initializeCounterpart(t, H({ localPosition: this.registerDisposer(An.makeFromExisting(t, this.localPosition)).rpcId, renderScaleTarget: this.registerDisposer(An.makeFromExisting(t, this.renderScaleTarget)).rpcId }, this.rpcTransfer)), this.rpcId = e.rpcId;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  setGLBlendMode(e, t) {
    t > 0 ? (e.enable(WebGL2RenderingContext.BLEND), e.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA)) : e.disable(WebGL2RenderingContext.BLEND);
  }
  filterVisibleSources(e, t) {
    return SF(e, this, t);
  }
};
Jy.prototype.RPC_TYPE_ID = wF;
var xo = class extends HL {
  draw(e, t) {
  }
  isReady(e, t) {
    return true;
  }
};
var JF = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
var KF = class extends gF {
};
var YF = mh(KF);
function XF(i) {
  return {
    source: i.source.addCounterpartRef(),
    effectiveVoxelSize: i.effectiveVoxelSize,
    layerRank: i.layerRank,
    nonDisplayLowerClipBound: i.nonDisplayLowerClipBound,
    nonDisplayUpperClipBound: i.nonDisplayUpperClipBound,
    lowerClipBound: i.lowerClipBound,
    upperClipBound: i.upperClipBound,
    lowerClipDisplayBound: i.lowerClipDisplayBound,
    upperClipDisplayBound: i.upperClipDisplayBound,
    chunkDisplayDimensionIndices: i.chunkDisplayDimensionIndices,
    lowerChunkDisplayBound: i.lowerChunkDisplayBound,
    upperChunkDisplayBound: i.upperChunkDisplayBound,
    fixedLayerToChunkTransform: i.fixedLayerToChunkTransform,
    combinedGlobalLocalToChunkTransform: i.combinedGlobalLocalToChunkTransform,
    chunkLayout: i.chunkLayout.toObject()
  };
}
function Ky(i) {
  return i.map((e) => e.map(XF));
}
function yg(i, e) {
  for (const t of e)
    for (const n of t) {
      const r = n.source;
      i.removeSource(r), r.dispose();
    }
}
var Cu = class extends YF {
  constructor(e, t, n, r) {
    super(new qL({
      parametersConstructor: fF,
      navigationState: n,
      update: (l, d) => {
        const u = l.invViewMatrix, h = l.centerDataPosition;
        d.toMat4(u);
        var g = l.displayDimensionRenderInfo;
        const v = g.canonicalVoxelFactors, y = g.voxelPhysicalScales;
        for (let L = 0; L < 3; ++L)
          h[L] = u[12 + L];
        const C = l.logicalWidth, w = l.logicalHeight, b = l.projectionMat, E = l.viewportNormalInGlobalCoordinates, T = l.viewportNormalInCanonicalCoordinates, I = d.relativeDepthRange;
        bT(b, -C / 2, C / 2, w / 2, -w / 2, -I, I), DL(l, b), _L(l);
        const R = l.viewMatrix;
        for (let L = 0; L < 3; ++L) {
          const A = E[L] = R[L * 4 + 2];
          T[L] = A / v[L];
        }
        su(E, E), su(T, T);
        let P = 0;
        for (let L = 0; L < 3; ++L) {
          const A = y[L], M = u[L];
          P += (A * M) ** 2;
        }
        P = Math.sqrt(P), l.pixelSize = P;
      }
    })), this.chunkManager = e, this.layerManager = t, this.navigationState = n, this.wireFrame = r, this.gl = this.chunkManager.gl, this.viewChanged = new Le(), this.renderingStale = true, this.visibleChunksStale = true, this.visibleLayerList = new Array(), this.offscreenFramebuffer = this.registerDisposer(new So(this.gl, {
      colorBuffers: bu(this.gl, 1),
      depthBuffer: new LB(this.gl)
    })), this.histogramInputTextures = [], this.offscreenFramebuffersWithHistograms = [this.offscreenFramebuffer], this.histogramGenerator = By.get(this.gl), this.updateVisibleLayers = this.registerCancellable(dt(() => {
      this.updateVisibleLayersNow();
    }, 0)), this.registerDisposer(n), this.registerDisposer(this.projectionParameters), this.registerDisposer(this.projectionParameters.changed.add((l, d) => {
      l.displayDimensionRenderInfo !== d.displayDimensionRenderInfo && this.updateVisibleLayers();
    }));
    const s = this.chunkManager.rpc, a = this.sharedProjectionParameters = this.registerDisposer(new Su(s, this.projectionParameters));
    this.initializeCounterpart(s, {
      chunkManager: e.rpcId,
      projectionParameters: a.rpcId
    }), this.registerDisposer(t.layersChanged.add(() => {
      this.updateVisibleLayers();
    })), this.wireFrame.changed.add(this.viewChanged.dispatch), this.viewChanged.add(() => {
      this.renderingStale = true;
    }), this.registerDisposer(e.chunkQueueManager.visibleChunksChanged.add(this.viewChanged.dispatch)), this.updateVisibleLayers();
  }
  get displayDimensionRenderInfo() {
    return this.navigationState.displayDimensionRenderInfo;
  }
  computeHistograms(e, t) {
    this.histogramGenerator.compute(e, this.offscreenFramebuffer.depthBuffer.texture, this.histogramInputTextures, t, this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
  }
  flushBackendProjectionParameters() {
    this.sharedProjectionParameters.flush();
  }
  forEachVisibleChunk(e, t, n) {
    EF(this.projectionParameters.value, e.renderLayer.localPosition.value, e, t, () => {
      n(e.curPositionInChunks.join());
    });
  }
  isReady() {
    if (!this.navigationState.valid)
      return false;
    this.updateVisibleLayers.flush(), this.updateVisibleSources();
    let e = 0, t = 0;
    for (const n of this.visibleLayers.values()) {
      const r = n.visibleSources;
      for (const s of r) {
        const a = Hy(this.projectionParameters.value, s.chunkLayout), d = s.source.chunks;
        this.forEachVisibleChunk(s, a, (u) => {
          const h = d.get(u);
          ++t, h && h.state === kt.GPU_MEMORY && ++e;
        });
      }
    }
    return e === t;
  }
  invalidateVisibleSources() {
    super.invalidateVisibleSources(), this.viewChanged.dispatch();
  }
  bindVisibleRenderLayer(e, t) {
    t.push(e.localPosition.changed.add(() => this.invalidateVisibleChunks())), t.push(e.redrawNeeded.add(this.viewChanged.dispatch)), t.push(e.transform.changed.add(this.updateVisibleLayers)), t.push(e.renderScaleTarget.changed.add(() => this.invalidateVisibleSources()));
    const n = e.renderScaleHistogram;
    n !== void 0 && t.push(n.visibility.add(this.visibility)), t.push(e.dataHistogramSpecifications.producerVisibility.add(this.visibility));
  }
  updateVisibleLayersNow() {
    if (this.wasDisposed || !this.navigationState.valid) return false;
    const e = Date.now(), t = this.visibleLayers, n = this.visibleLayerList, r = this.projectionParameters.value.displayDimensionRenderInfo;
    let s = this.rpc, a = { id: this.rpcId }, l = false;
    n.length = 0;
    for (let u of this.layerManager.readyRenderLayers())
      if (u instanceof Jy) {
        n.push(u);
        let h = t.get(u);
        if (h === void 0) {
          const g = [], v = new Uo();
          h = {
            messages: v,
            allSources: this.getTransformedSources(u, v),
            transformGeneration: u.transform.changed.count,
            visibleSources: [],
            disposers: g,
            lastSeenGeneration: e,
            displayDimensionRenderInfo: r
          }, g.push(u.messages.addChild(h.messages)), t.set(u.addRef(), h), this.bindVisibleRenderLayer(u, g);
        } else {
          h.lastSeenGeneration = e;
          const g = u.transform.changed.count;
          if (h.transformGeneration === g && h.displayDimensionRenderInfo === r)
            continue;
          const v = h.allSources;
          h.allSources = this.getTransformedSources(u, h.messages), yg(u, v), h.visibleSources.length = 0, h.displayDimensionRenderInfo = r, h.transformGeneration = g;
        }
        a.layerId = u.rpcId, a.sources = Ky(h.allSources), this.flushBackendProjectionParameters(), s.invoke(CF, a), l = true;
      }
    for (const u of t) {
      var d = de(u, 2);
      const h = d[0], g = d[1];
      g.lastSeenGeneration !== e && (a.layerId = h.rpcId, s.invoke(xF, a), t.delete(h), yg(h, g.allSources), ho(g.disposers), h.dispose(), l = true);
    }
    return l && (this.visibleSourcesStale = true), this.viewChanged.dispatch(), l;
  }
  invalidateVisibleChunks() {
    super.invalidateVisibleChunks(), this.viewChanged.dispatch();
  }
  get valid() {
    return this.navigationState.valid;
  }
  getOffscreenFramebufferWithHistograms(e) {
    const t = this.offscreenFramebuffersWithHistograms;
    let n = t[e];
    if (n === void 0) {
      const r = this.gl, s = this.histogramInputTextures, a = this.offscreenFramebuffer;
      s.length < e && s.push(...bu(r, e - s.length, WebGL2RenderingContext.R8, WebGL2RenderingContext.RED));
      let l = [a.colorBuffers[0].addRef()];
      for (let d = 0; d < e; ++d)
        l.push(s[d].addRef());
      n = this.registerDisposer(new So(r, { colorBuffers: l, depthBuffer: a.depthBuffer.addRef() })), t[e] = n;
    }
    return n;
  }
  updateRendering() {
    const e = this.projectionParameters.value, t = e.width, n = e.height;
    if (!this.renderingStale || !this.valid || t === 0 || n === 0)
      return;
    this.renderingStale = false, this.updateVisibleLayers.flush(), this.updateVisibleSources();
    let r = this.gl, s = this.offscreenFramebuffer;
    s.bind(t, n), r.disable(r.SCISSOR_TEST), r.clearColor(0, 0, 0, 0), r.colorMask(true, true, true, true), r.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
    let a = 0;
    const l = this.wireFrame.value, d = { sliceView: this, projectionParameters: e, wireFrame: l };
    for (let u of this.visibleLayerList) {
      const h = l ? 0 : u.getDataHistogramCount();
      this.getOffscreenFramebufferWithHistograms(h).bind(t, n);
      for (let v = 0; v < h; ++v)
        r.clearBufferfv(WebGL2RenderingContext.COLOR, 1 + v, km);
      r.enable(WebGL2RenderingContext.DEPTH_TEST), r.depthFunc(WebGL2RenderingContext.LESS), r.clearDepth(1), r.clear(WebGL2RenderingContext.DEPTH_BUFFER_BIT), u.setGLBlendMode(r, a), u.draw(d), ++a;
    }
    r.disable(WebGL2RenderingContext.BLEND), r.disable(WebGL2RenderingContext.DEPTH_TEST), s.unbind();
  }
  disposed() {
    for (const t of this.visibleLayers) {
      var e = de(t, 2);
      const n = e[0], r = e[1];
      yg(n, r.allSources), ho(r.disposers), n.dispose();
    }
    this.visibleLayers.clear(), this.visibleLayerList.length = 0;
  }
  getTransformedSources(e, t) {
    const n = Yy(this.projectionParameters.value.displayDimensionRenderInfo, e.transform.value, (r) => e.getSources(r), t, e);
    for (const r of n)
      for (const s of r)
        e.addSource(s.source, s.chunkTransform);
    return n;
  }
};
Cu = JF([ki(bF)], Cu);
var wD = class extends Wr {
  constructor(e, t) {
    super(e, t), this.spec = t.spec;
  }
  static encodeSpec(e) {
    return {
      chunkDataSize: _e(e.chunkDataSize),
      lowerVoxelBound: _e(e.lowerVoxelBound),
      upperVoxelBound: _e(e.upperVoxelBound)
    };
  }
  static encodeOptions(e) {
    const t = super.encodeOptions(e);
    return t.spec = this.encodeSpec(e.spec), t;
  }
  initializeCounterpart(e, t) {
    t.spec = this.spec, super.initializeCounterpart(e, t);
  }
};
var CD = class extends Ds {
  constructor(e, t) {
    super(e), this.chunkGridPosition = t.chunkGridPosition, this.state = kt.SYSTEM_MEMORY;
  }
};
var xD = class ED extends X {
  constructor(e, t) {
    super(), this.gl = e, this.copyVertexPositionsBuffer = oc(this.gl), this.textureCoordinateAdjustment = new Float32Array(4);
    let n = new ra(e);
    n.addVarying("vec2", "vTexCoord"), n.addUniform("sampler2D", "uSampler"), n.addInitializer((r) => {
      e.uniform1i(r.uniform("uSampler"), 0);
    }), n.addUniform("vec4", "uColorFactor"), n.addUniform("vec4", "uBackgroundColor"), n.addUniform("mat4", "uProjectionMatrix"), n.addUniform("vec4", "uTextureCoordinateAdjustment"), n.require(t), n.setFragmentMain(`
vec4 sampledColor = texture(uSampler, vTexCoord);
if (sampledColor.a == 0.0) {
  sampledColor = uBackgroundColor;
}
emit(sampledColor * uColorFactor, 0u);
`), n.addAttribute("vec4", "aVertexPosition"), n.setVertexMain(`
vTexCoord = uTextureCoordinateAdjustment.xy + 0.5 * (aVertexPosition.xy + 1.0) * uTextureCoordinateAdjustment.zw;
gl_Position = uProjectionMatrix * aVertexPosition;
`), this.shader = this.registerDisposer(n.build());
  }
  draw(e, t, n, r, s, a, l, d) {
    let u = this.gl, h = this.shader, g = this.textureCoordinateAdjustment;
    g[0] = s, g[1] = a, g[2] = l - s, g[3] = d - a, h.bind(), u.activeTexture(u.TEXTURE0), u.bindTexture(u.TEXTURE_2D, e), u.disable(WebGL2RenderingContext.BLEND), u.uniformMatrix4fv(h.uniform("uProjectionMatrix"), false, t), u.uniform4fv(h.uniform("uColorFactor"), n), u.uniform4fv(h.uniform("uBackgroundColor"), r), u.uniform4fv(h.uniform("uTextureCoordinateAdjustment"), g);
    let v = h.attribute("aVertexPosition");
    this.copyVertexPositionsBuffer.bindToVertexAttrib(
      v,
      /*components=*/
      2
    ), u.drawArrays(u.TRIANGLE_FAN, 0, 4), u.disableVertexAttribArray(v), u.bindTexture(u.TEXTURE_2D, null);
  }
  static get(e, t) {
    return e.memoize.get(`sliceview/SliceViewRenderHelper:${En(t)}`, () => new ED(e, t));
  }
};
var ZF = class {
  constructor(e) {
    this.chunkManager = e;
  }
};
function Yy(i, e, t, n, r) {
  n.clearMessages();
  const s = (E) => (n.addMessage({
    severity: ar.error,
    message: E
  }), []);
  if (e.error !== void 0)
    return s(e.error);
  const a = e.rank, l = e.unpaddedRank, d = i.displayDimensionIndices, u = i.displayRank, h = i.canonicalVoxelFactors, g = CL(e, d), v = g.displayToLayerDimensionIndices, y = new Float32Array(u * l), C = e.modelToRenderLayerTransform;
  for (let E = 0; E < u; ++E) {
    const T = v[E];
    if (T === -1) continue;
    const I = h[E];
    for (let R = 0; R < l; ++R)
      y[u * R + E] = C[(a + 1) * R + T] * I;
  }
  const w = t({
    displayRank: u,
    multiscaleToViewTransform: y,
    modelChannelDimensionIndices: e.channelToRenderLayerDimensions
  }), b = i.voxelPhysicalScales;
  try {
    const E = (T) => {
      const I = T.chunkSource, R = I.spec;
      var P = T.lowerClipBound;
      const L = P === void 0 ? R.lowerVoxelBound : P;
      var A = T.upperClipBound;
      const M = A === void 0 ? R.upperVoxelBound : A, O = wL(e, T.chunkToMultiscaleTransform), F = R.chunkDataSize, q = O.channelToChunkDimensionIndices, U = new Float32Array(l), V = new Float32Array(l);
      U.set(L), V.set(M);
      const $ = q.length, B = e.channelSpaceShape;
      for (let We = 0; We < $; ++We) {
        const De = q[We];
        if (De === -1) continue;
        const et = B[We];
        if (F[De] !== et)
          throw new Error("Channel dimension " + e.layerDimensionNames[e.channelToRenderLayerDimensions[We]] + ` has extent ${et} but corresponding chunk dimension has extent ${F[De]}`);
        U[De] = Number.NEGATIVE_INFINITY, V[De] = Number.POSITIVE_INFINITY;
      }
      const ue = xL(O, g), se = ze(), Pe = ze(), ae = ze(), Ee = ze(), ce = ze(), ge = ue.numChunkDisplayDims, Ne = ue.chunkDisplayDimensionIndices, Me = O.combinedGlobalLocalToChunkTransform, je = O.layerRank, Oe = O.combinedGlobalLocalRank, Re = new Float32Array(Me);
      for (let We = 0; We < ge; ++We) {
        const De = Ne[We];
        for (let et = 0; et <= Oe; ++et)
          Re[De + et * je] = 0;
        De < l ? (ce[We] = R.chunkDataSize[De], se[We] = R.lowerChunkBound[De], Pe[We] = R.upperChunkBound[De], ae[We] = L[De], Ee[We] = M[De], U[De] = Number.NEGATIVE_INFINITY, V[De] = Number.POSITIVE_INFINITY) : (ce[We] = 1, se[We] = 0, Pe[We] = 1, ae[We] = 0, Ee[We] = 1);
      }
      ce.fill(1, ge), se.fill(0, ge), Pe.fill(1, ge), ae.fill(0, ge), Ee.fill(1, ge);
      const Ve = new bh(ce, ue.displaySubspaceModelMatrix, ge), qe = Ve.localSpatialVectorToGlobal(
        ze(),
        /*baseVoxelSize=*/
        LT
      );
      for (let We = 0; We < u; ++We)
        qe[We] = Math.abs(qe[We] * b[We]);
      return qe.fill(1, u), {
        layerRank: je,
        lowerClipBound: L,
        upperClipBound: M,
        nonDisplayLowerClipBound: U,
        nonDisplayUpperClipBound: V,
        renderLayer: r,
        source: I,
        lowerChunkDisplayBound: se,
        upperChunkDisplayBound: Pe,
        lowerClipDisplayBound: ae,
        upperClipDisplayBound: Ee,
        effectiveVoxelSize: qe,
        chunkLayout: Ve,
        chunkDisplayDimensionIndices: Ne,
        fixedLayerToChunkTransform: Re,
        curPositionInChunks: new Float32Array(l),
        combinedGlobalLocalToChunkTransform: O.combinedGlobalLocalToChunkTransform,
        fixedPositionWithinChunk: new Uint32Array(l),
        chunkTransform: O,
        chunkDisplayTransform: ue
      };
    };
    return w.map((T) => T.map((I) => E(I)));
  } catch (E) {
    for (const P of w)
      for (const L of P)
        L.chunkSource.dispose();
    const T = i.globalDimensionNames, R = `Cannot render (${_e(i.displayDimensionIndices.filter((P) => P !== -1), (P) => T[P]).join(", ")}) cross section: ${E.message}`;
    return s(R);
  }
}
var Ws2 = null;
var QF = 200;
var rt = class _rt {
  constructor(e = false) {
    if (Ws2 === null) {
      Ws2 = document.createElement("ul"), Ws2.id = "statusContainer";
      const n = document.getElementById("neuroglancer-container");
      n ? n.appendChild(Ws2) : document.body.appendChild(Ws2);
    }
    let t = document.createElement("li");
    this.element = t, e === true && (e = QF), e !== false ? (this.setVisible(false), this.timer = window.setTimeout(this.setVisible.bind(this, true), e)) : this.timer = null, Ws2.appendChild(t);
  }
  dispose() {
    Ws2.removeChild(this.element), this.element = void 0, this.timer !== null && clearTimeout(this.timer);
  }
  setText(e, t) {
    this.element.textContent = e, t && this.setVisible(true);
  }
  setHTML(e, t) {
    this.element.innerHTML = e, t && this.setVisible(true);
  }
  setVisible(e) {
    this.timer !== null && (clearTimeout(this.timer), this.timer = null), this.element.style.display = e ? "block" : "none";
  }
  static forPromise(e, t) {
    let n = new _rt(t.delay);
    n.setText(t.initialMessage);
    let r = n.dispose.bind(n);
    return e.then(r, (s) => {
      let a;
      s instanceof Error ? a = s.message : a = "" + s;
      var l = t.errorPrefix;
      let d = l === void 0 ? "" : l;
      n.setErrorMessage(d + a), n.setVisible(true);
    }), e;
  }
  setErrorMessage(e) {
    this.element.textContent = e + " ";
    let t = document.createElement("button");
    t.textContent = "Dismiss", t.addEventListener("click", () => {
      this.dispose();
    }), this.element.appendChild(t);
  }
  static showMessage(e) {
    const t = new _rt();
    return t.element.textContent = e, t.setVisible(true), t;
  }
  static showTemporaryMessage(e, t = 2e3) {
    const n = this.showMessage(e);
    return window.setTimeout(() => n.dispose(), t), n;
  }
};
var Xy = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
function kD(i) {
  let e = 0;
  const t = i.typeToIds;
  for (const n of Mr)
    e += jl(n).pickIdsPerInstance * t[n].length;
  return e;
}
var TD = class {
  constructor(e) {
    this.bufferValid = false, this.numPickIds = 0, this.serializedAnnotations = {
      data: e.data,
      typeToIds: e.typeToIds,
      typeToOffset: e.typeToOffset,
      typeToIdMaps: e.typeToIdMaps
    };
  }
  freeGPUMemory(e) {
    const t = this.buffer;
    t !== void 0 && (t.dispose(), this.bufferValid = false, this.buffer = void 0);
  }
};
var e3 = class extends Ds {
  constructor(e, t) {
    super(e), t.data !== void 0 && (this.data = new TD(t));
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e);
    const t = this.data;
    t !== void 0 && t.freeGPUMemory(e);
  }
  dispose() {
    this.data = void 0;
  }
};
var LD = class extends CD {
  constructor(e, t) {
    super(e, t), t.data !== void 0 && (this.data = new TD(t));
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e);
    const t = this.data;
    t !== void 0 && t.freeGPUMemory(e);
  }
  dispose() {
    this.data = void 0;
  }
};
var Eo = class extends wD {
  constructor(e, t) {
    super(e, t), this.immediateChunkUpdates = true, (this.parent = t.parent).spatiallyIndexedSources.add(this);
    var r = this.spec;
    const s = r.rank, a = r.chunkDataSize, l = this.multiscaleToChunkTransform = new Float32Array((s + 1) ** 2);
    wy(l, s + 1, this.spec.chunkToMultiscaleTransform, s + 1, s + 1);
    for (let d = 0; d < s; ++d)
      for (let u = 0; u < s + 1; ++u)
        l[(s + 1) * u + d] /= a[d];
  }
  disposed() {
    this.parent.spatiallyIndexedSources.delete(this), super.disposed();
  }
  initializeCounterpart(e, t) {
    t.parent = this.parent.rpcId, super.initializeCounterpart(e, t);
  }
  addChunk(e, t) {
    super.addChunk(e, t);
  }
  getChunk(e) {
    return new LD(this, e);
  }
};
Eo = Xy([ki(TF)], Eo);
var Hm = class extends Wr {
  constructor(e, t, n) {
    super(e, {}), this.parent = t, this.relationshipIndex = n, this.immediateChunkUpdates = true;
  }
  addChunk(e, t) {
    super.addChunk(e, t);
  }
  getChunk(e) {
    return new e3(this, e);
  }
};
Hm = Xy([ki(LF)], Hm);
var t3 = class extends Ds {
  constructor(e, t) {
    super(e), this.annotation = yy(t.annotation);
  }
};
var qm = class extends Wr {
  constructor(e, t) {
    super(e), this.parent = t;
  }
  getChunk(e) {
    return new t3(this, e);
  }
  addChunk(e, t) {
    super.addChunk(e, t);
    const r = this.parent.references.get(e);
    r !== void 0 && (r.value = t.annotation, r.changed.dispatch());
  }
  deleteChunk(e) {
    const n = this.parent.references.get(e);
    n !== void 0 && (n.value = void 0, n.changed.dispatch());
  }
};
qm = Xy([ki(kF)], qm);
function DD(i, e, t, n) {
  const r = new Uint8Array(i.data.length + n);
  for (const s of Mr) {
    if (s === t) continue;
    let a = i.typeToOffset[s], l = a;
    s > t && (l += n, i.typeToOffset[s] = l), r.set(i.data.subarray(a, a + i.typeToIds[s].length * e[s].serializedBytes), l);
  }
  return r;
}
function jm(i, e, t, n, r, s, a, l) {
  const d = i.typeToOffset[t];
  let u = d, h = d;
  const g = e[t].propertyGroupBytes, v = g.length, y = i.typeToIds[t].length;
  for (let C = 0; C < v; ++C) {
    const w = g[C];
    n.set(i.data.subarray(u + r * w, u + s * w), h + a * w), u += w * y, h += w * l;
  }
}
function Pd(i, e, t) {
  const n = e.type, r = t[n].rank, s = i.serializedAnnotations, a = s.typeToIds[n], l = s.typeToIdMaps[n], d = Gn[n], u = t[n].serializedBytes;
  let h = l.get(e.id);
  if (h === void 0) {
    h = l.size, l.set(e.id, h);
    const w = DD(s, t, n, u);
    jm(
      s,
      t,
      n,
      w,
      /*sourceBeginIndex=*/
      0,
      /*sourceEndIndex=*/
      h,
      /*destBeginIndex=*/
      0,
      /*destCount=*/
      h + 1
    ), a.push(e.id), s.data = w;
  }
  const g = s.typeToOffset[n], v = new DataView(s.data.buffer, s.data.byteOffset, s.data.byteLength), y = wc === ai.LITTLE, C = t[n];
  d.serialize(v, g + C.propertyGroupBytes[0] * h, y, r, e), C.serialize(v, g, h, a.length, y, e.properties), i.bufferValid = false;
}
function Rd(i, e, t, n) {
  const r = i.serializedAnnotations, s = r.typeToIdMaps[e], a = s.get(t);
  if (a === void 0)
    return false;
  const l = r.typeToIds[e], d = n[e].serializedBytes, u = DD(r, n, e, -d);
  jm(
    r,
    n,
    e,
    u,
    /*sourceBeginIndex=*/
    0,
    /*sourceEndIndex=*/
    a,
    /*destBeginIndex=*/
    0,
    /*destCount=*/
    l.length - 1
  ), jm(
    r,
    n,
    e,
    u,
    /*sourceBeginIndex=*/
    a + 1,
    /*sourceEndIndex=*/
    l.length,
    /*destBeginIndex=*/
    a,
    /*destCount=*/
    l.length - 1
  ), l.splice(a, 1), s.delete(t);
  for (let h = a, g = l.length; h < g; ++h)
    s.set(l[h], h);
  return r.data = u, i.bufferValid = false, true;
}
function n3() {
  const i = [], e = [], t = [];
  for (const n of Mr)
    i[n] = [], e[n] = 0, t[n] = new he();
  return new LD(void 0, { data: new Uint8Array(0), numPickIds: 0, typeToOffset: e, typeToIds: i, typeToIdMaps: t });
}
var Fi = class extends cr {
  constructor(e, t) {
    super(), this.chunkManager = e, this.metadataChunkSource = this.registerDisposer(new qm(this.chunkManager, this)), this.spatiallyIndexedSources = new Ye(), this.temporary = n3(), this.references = new he(), this.localUpdates = new he(), this.numCommitsInProgress = 0, this.changed = new Le(), this.referencesChanged = new ct(), this.readonly = false, this.childRefreshed = new Le(), this.rank = t.rank, this.properties = t.properties, this.annotationPropertySerializers = my(this.rank, this.properties);
    const n = this.segmentFilteredSources = [], r = t.relationships;
    this.relationships = r;
    for (let s = 0, a = r.length; s < a; ++s)
      n.push(this.registerDisposer(new Hm(e, this, s)));
  }
  hasNonSerializedProperties() {
    return this.relationships.length > 0;
  }
  getSources(e) {
    throw new Error("not implemented");
  }
  initializeCounterpart(e, t) {
    this.metadataChunkSource.initializeCounterpart(e, {});
    for (const n of this.segmentFilteredSources)
      n.initializeCounterpart(e, {});
    t.segmentFilteredSource = this.segmentFilteredSources.map((n) => n.addCounterpartRef()), t.metadataChunkSource = this.metadataChunkSource.addCounterpartRef(), t.chunkManager = this.chunkManager.rpcId, super.initializeCounterpart(e, t);
  }
  add(e, t = true) {
    e.id = vy();
    const n = new jd(e.id);
    return n.value = e, this.references.set(n.id, n), this.referencesChanged.dispatch({ action: "adding", id: n.id }), n.registerDisposer(() => {
      this.references.delete(n.id), this.referencesChanged.dispatch({ action: "deref", id: n.id });
    }), this.applyLocalUpdate(
      n,
      /*existing=*/
      false,
      /*commit=*/
      t,
      /*newAnnotation=*/
      e
    ), n;
  }
  applyLocalUpdate(e, t, n, r) {
    const s = this.localUpdates, a = e.id;
    let l = this.localUpdates.get(a);
    const d = e.value;
    if (d == null)
      throw new Error("Cannot create local update from null annotation");
    if (l === void 0 ? (l = {
      type: d.type,
      reference: e.addRef(),
      existingAnnotation: t ? d : void 0,
      pendingCommit: void 0,
      commitInProgress: void 0
    }, s.set(a, l), this.forEachPossibleChunk(d, (u) => {
      const h = u.data;
      if (h === void 0) return;
      const g = d.type;
      Rd(h, g, a, this.annotationPropertySerializers);
    }), r !== null && Pd(this.temporary.data, r, this.annotationPropertySerializers)) : (r === null ? Rd(this.temporary.data, d.type, d.id, this.annotationPropertySerializers) : Pd(this.temporary.data, r, this.annotationPropertySerializers), e.value = r), n)
      if (l.commitInProgress !== void 0)
        l.pendingCommit = r;
      else {
        if (r === null && l.existingAnnotation === void 0) {
          s.delete(a), l.reference.dispose();
          return;
        }
        this.sendCommitRequest(l, r);
      }
    this.notifyChanged(e.id, r || void 0);
  }
  sendCommitRequest(e, t) {
    this.updateCommitsInProgress(1), e.commitInProgress = t, this.rpc.invoke(PF, {
      id: this.rpcId,
      annotationId: e.existingAnnotation && e.reference.id,
      newAnnotation: t
    });
  }
  delete(e) {
    this.applyLocalUpdate(
      e,
      /*existing=*/
      true,
      /*commit=*/
      true,
      /*newAnnotation=*/
      null
    );
  }
  update(e, t) {
    this.applyLocalUpdate(
      e,
      /*existing=*/
      true,
      /*commit=*/
      false,
      /*newAnnotation=*/
      t
    );
  }
  notifyChanged(e, t) {
    const n = this.references.get(e), r = this.metadataChunkSource.chunks.get(e);
    r !== void 0 && (r.annotation = t || null), n !== void 0 && (n.value = t || null, n.changed.dispatch(), this.referencesChanged.dispatch({ action: "changed", id: e })), this.chunkManager.chunkQueueManager.visibleChunksChanged.dispatch();
  }
  /**
   * Must be called after `add` or `update` to commit the result.
   */
  commit(e) {
    this.applyLocalUpdate(
      e,
      /*existing=*/
      true,
      /*commit=*/
      true,
      e.value
    );
  }
  updateReference(e) {
    let t = this.references.get(e.id);
    if (t !== void 0)
      t.value = e;
    else {
      let n = new jd(e.id);
      this.references.set(e.id, n), n.value = e, this.referencesChanged.dispatch({ action: "update", id: n.id }), n.registerDisposer(() => {
        this.references.delete(n.id), this.referencesChanged.dispatch({ action: "deref", id: n.id });
      });
    }
  }
  hasReference(e) {
    return this.references.has(e);
  }
  getReference(e) {
    let t = this.references.get(e);
    if (t !== void 0)
      return t.addRef();
    t = new jd(e), this.references.set(e, t), this.referencesChanged.dispatch({ action: "get", id: e }), this.rpc.invoke(DF, { id: this.rpcId, annotation: e }), t.registerDisposer(() => {
      this.references.delete(e), this.referencesChanged.dispatch({ action: "deref", id: e }), this.rpc.invoke(IF, { id: this.rpcId, annotation: e });
    });
    const n = this.metadataChunkSource.chunks.get(e);
    return n !== void 0 && n.annotation !== null && (t.value = n.annotation), t;
  }
  forEachPossibleChunk(e, t) {
    const n = e.relatedSegments;
    if (n !== void 0) {
      const d = n.length, u = this.segmentFilteredSources;
      for (let h = 0; h < d; ++h) {
        const g = n[h];
        if (g === void 0) return;
        const v = u[h];
        for (const y of g) {
          const C = v.chunks.get(ir(y));
          C !== void 0 && t(C);
        }
      }
    }
    const r = this.rank, s = new Float32Array(r), a = new Float32Array(r), l = new Float32Array(r);
    for (const d of this.spatiallyIndexedSources) {
      switch (e.type) {
        case Fe.POINT:
          Ar(s, d.multiscaleToChunkTransform, r + 1, e.point, r), a.set(s);
          break;
        case Fe.LINE:
        case Fe.SPHERE:
        case Fe.AXIS_ALIGNED_BOUNDING_BOX:
          Ar(s, d.multiscaleToChunkTransform, r + 1, e.pointA, r), Ar(a, d.multiscaleToChunkTransform, r + 1, e.pointB, r);
          break;
        case Fe.ELLIPSOID:
          Ar(s, d.multiscaleToChunkTransform, r + 1, e.center, r), nL(a, d.multiscaleToChunkTransform, r + 1, e.radii, r);
          for (let g = 0; g < r; ++g) {
            const v = s[g], y = a[g];
            s[g] = v - y, a[g] = v + y;
          }
          break;
      }
      let u = 1;
      for (let g = 0; g < r; ++g) {
        const v = s[g], y = a[g], C = Math.min(v, y), w = Math.max(v, y);
        s[g] = Math.ceil(C - 1), a[g] = Math.floor(w + 1), u *= a[g] - s[g];
      }
      const h = d.chunks;
      for (let g = 0; g < u; ++g) {
        let v = g;
        for (let C = 0; C < r; ++C) {
          const w = s[C], E = a[C] - w, T = l[C] = v % E;
          v = (v - T) / E;
        }
        const y = h.get(l.join());
        y !== void 0 && t(y);
      }
    }
  }
  static encodeOptions(e) {
    return {};
  }
  handleSuccessfulUpdate(e, t) {
    const n = this.localUpdates.get(e);
    if (n === void 0 || n.commitInProgress === void 0)
      throw new Error("Received invalid successful update notification");
    if (this.updateCommitsInProgress(-1), t !== null && n.reference.id !== t.id) {
      if (n.commitInProgress === null)
        throw new Error("Received invalid successful update notification");
      n.reference.id = t.id, this.references.delete(e), this.references.set(t.id, n.reference.addRef()), this.localUpdates.delete(e), this.localUpdates.set(t.id, n), n.reference.value !== null && (n.reference.value.id = t.id, Rd(this.temporary.data, n.type, e, this.annotationPropertySerializers), Pd(this.temporary.data, n.reference.value, this.annotationPropertySerializers)), n.reference.changed.dispatch();
    }
    let r = n.existingAnnotation === void 0;
    n.existingAnnotation = t || void 0, n.commitInProgress = void 0;
    let s = n.pendingCommit;
    n.pendingCommit = void 0, t === null && (s = void 0), s !== void 0 ? (s !== null && (s.id = t.id), this.sendCommitRequest(n, s)) : (this.revertLocalUpdate(n), r ? (this.childAdded.dispatch(t), this.referencesChanged.dispatch({ action: "added", id: t.id })) : t === null ? (this.references.get(e).dispose(), this.childDeleted.dispatch(e), this.referencesChanged.dispatch({ action: "deleted", id: e })) : (this.childUpdated.dispatch(t), this.referencesChanged.dispatch({ action: "updated", id: t.id })));
  }
  disposed() {
    const e = this.commitStatus;
    e !== void 0 && e.dispose();
  }
  updateCommitsInProgress(e) {
    this.numCommitsInProgress += e, this.numCommitsInProgress === 0 ? this.commitStatus !== void 0 && (this.commitStatus.dispose(), this.commitStatus = void 0) : this.commitStatus === void 0 && (this.commitStatus = new rt(
      /*delay=*/
      true
    )).setText("Commiting annotations");
  }
  handleFailedUpdate(e, t) {
    const n = this.localUpdates.get(e);
    if (n === void 0 || n.commitInProgress === void 0)
      throw new Error("Received invalid update notification");
    new rt().setErrorMessage(`Error commiting annotation update: ${t}`), this.revertLocalUpdate(n), this.updateCommitsInProgress(-1);
  }
  revertLocalUpdate(e) {
    Rd(this.temporary.data, e.type, e.reference.id, this.annotationPropertySerializers);
    const t = e.existingAnnotation;
    t !== void 0 && this.forEachPossibleChunk(t, (s) => {
      const a = s.data;
      a !== void 0 && Pd(a, t, this.annotationPropertySerializers);
    });
    const n = e.reference, r = n.id;
    n.value = t || null, n.changed.dispatch(), n.dispose(), this.localUpdates.delete(r);
  }
  *[qn]() {
  }
};
zt(RF, function(i) {
  const e = this.get(i.id), t = i.annotationId, n = i.error;
  if (n !== void 0)
    e.handleFailedUpdate(t, n);
  else {
    const r = yy(i.newAnnotation);
    e.handleSuccessfulUpdate(t, r);
  }
});
function Ac(i, e) {
  return i < e ? -1 : i > e ? 1 : 0;
}
var ID = {
  offset: 0,
  completions: []
};
function Go(i, e) {
  return e.offset += i, e;
}
function Sg(i, e) {
  let t = [];
  for (let n of e)
    n.startsWith(i) && t.push({ value: n });
  return t.sort((n, r) => Ac(n.value, r.value)), t;
}
function Wo(i, e, t, n) {
  let r = [];
  for (let s of e) {
    let a = t(s);
    a.startsWith(i) && r.push({ value: a, description: n(s) });
  }
  return r.sort((s, a) => Ac(s.value, a.value)), r;
}
async function i3(i, e, t) {
  if (i.startsWith("{")) return ID;
  const r = i.match(/^(?:(.*)[&;])?([^&;]*)$/)[2];
  let s = i.length - r.length;
  const a = r.indexOf("=");
  if (a === -1) {
    const l = await e(r);
    return {
      offset: l.offset + s,
      completions: l.completions.map((d) => H(H({}, d), { value: `${d.value}=` }))
    };
  }
  return Go(s + a + 1, await t(r.substring(0, a), r.substring(a + 1)));
}
async function PD(i, e) {
  return i3(i, async (t) => {
    const n = [];
    for (const r of e) {
      const s = r.key;
      s.value.startsWith(t) && n.push(s);
    }
    return { offset: 0, completions: n };
  }, async (t, n) => {
    for (const r of e)
      if (r.key.value === t)
        return { offset: 0, completions: r.values.filter((s) => s.value.startsWith(n)) };
    return ID;
  });
}
var RD = class extends Error {
  constructor(e) {
    super(`Redirected to: ${e}`), this.redirectTarget = e;
  }
};
function AD(i, e) {
  e === void 0 && (i.indexOf("/") === -1 ? e = ":" : e = "/");
  let t = i.lastIndexOf(e);
  return t === -1 ? 0 : t + 1;
}
function r3(i, e) {
  let t = AD(i, e);
  return i.substring(t);
}
var Br;
(function(i) {
  i[i.annotations = 0] = "annotations", i[i.equivalences = 1] = "equivalences";
})(Br || (Br = {}));
function _D() {
  return { url: "", transform: void 0, enableDefaultSubsources: true, subsources: new he() };
}
var pa = class extends X {
  normalizeUrl(e) {
    return e.url;
  }
  convertLegacyUrl(e) {
    return e.url;
  }
  async completeUrl(e) {
    throw null;
  }
};
var MD = "local://annotations";
var Jm = "local://equivalences";
var s3 = class extends pa {
  get description() {
    return "Local in-memory";
  }
  async get(e) {
    switch (e.url) {
      case MD: {
        const t = e.transform;
        let n;
        if (t === void 0) {
          const r = e.globalCoordinateSpace.value, s = r.rank, a = r.names, l = r.scales, d = r.units, u = yt({
            rank: s,
            scales: l,
            units: d,
            names: a.map((g, v) => `${v}`)
          }), h = yt({ rank: s, scales: l, units: d, names: a });
          n = {
            rank: s,
            sourceRank: s,
            inputSpace: u,
            outputSpace: h,
            transform: ks(Float64Array, s + 1)
          };
        } else
          n = ei(mo);
        return {
          modelTransform: n,
          canChangeModelSpaceRank: true,
          subsources: [{
            id: "default",
            default: true,
            subsource: {
              local: Br.annotations
            }
          }]
        };
      }
      case Jm:
        return {
          modelTransform: ei(mo),
          canChangeModelSpaceRank: false,
          subsources: [{
            id: "default",
            default: true,
            subsource: {
              local: Br.equivalences
            }
          }]
        };
    }
    throw new Error("Invalid local data source URL");
  }
  async completeUrl(e) {
    return {
      offset: 0,
      completions: Wo(e.providerUrl, [{
        value: "annotations",
        description: "Annotations stored in the JSON state"
      }, {
        value: "equivalences",
        description: "Segmentation equivalence graph stored in the JSON state"
      }], (t) => t.value, (t) => t.description)
    };
  }
};
var Rx = /^(?:([a-zA-Z][a-zA-Z0-9-+_]*):\/\/)?(.*)$/;
var a3 = class extends X {
  constructor(e) {
    super(), this.credentialsManager = e, this.dataSources = new he([["local", new s3()]]);
  }
  register(e, t) {
    this.dataSources.set(e, this.registerDisposer(t));
  }
  getProvider(e) {
    const t = e.match(Rx);
    if (t === null || t[1] === void 0)
      throw new Error('Data source URL must have the form "<protocol>://<path>".');
    var n = de(t, 3);
    const r = n[1], s = n[2], a = this.dataSources.get(r);
    if (a === void 0)
      throw new Error(`Unsupported data source: ${oe(r)}.`);
    return [a, s, r];
  }
  async get(e) {
    const t = new Ye();
    var n = e.cancellationToken;
    const r = n === void 0 ? Qt : n;
    let s = e.url;
    for (; ; ) {
      var a = this.getProvider(e.url), l = de(a, 3);
      const d = l[0], u = l[1], h = l[2];
      t.add(e.url);
      try {
        return d.get(H(H({}, e), {
          url: s,
          providerProtocol: h,
          providerUrl: u,
          registry: this,
          cancellationToken: r,
          credentialsManager: this.credentialsManager
        }));
      } catch (g) {
        if (g instanceof RD) {
          const v = g.redirectTarget;
          if (t.has(v))
            throw Error(`Layer source redirection contains loop: ${oe(_e(t))}`);
          if (t.size >= 10)
            throw Error(`Too many layer source redirections: ${oe(_e(t))}`);
          s = v;
          continue;
        }
        throw g;
      }
    }
  }
  convertLegacyUrl(e) {
    try {
      var t = this.getProvider(e.url), n = de(t, 3);
      const r = n[0], s = n[1], a = n[2];
      return r.convertLegacyUrl(H(H({}, e), { providerUrl: s, providerProtocol: a, registry: this }));
    } catch {
      return e.url;
    }
  }
  normalizeUrl(e) {
    try {
      var t = this.getProvider(e.url), n = de(t, 3);
      const r = n[0], s = n[1], a = n[2];
      return r.normalizeUrl(H(H({}, e), { providerUrl: s, providerProtocol: a, registry: this }));
    } catch {
      return e.url;
    }
  }
  async completeUrl(e) {
    const t = e.url;
    var n = e.cancellationToken;
    const r = n === void 0 ? Qt : n;
    let s = t.match(Rx), a = s[1];
    if (a === void 0)
      return Ft.resolve({
        offset: 0,
        completions: Wo(t, this.dataSources, ([l]) => `${l}://`, ([, l]) => l.description)
      });
    {
      const l = this.dataSources.get(a);
      if (l !== void 0) {
        const d = await l.completeUrl({
          registry: this,
          url: t,
          providerUrl: s[2],
          chunkManager: e.chunkManager,
          cancellationToken: r,
          credentialsManager: this.credentialsManager
        });
        return Go(a.length + 3, d);
      }
      throw null;
    }
  }
  suggestLayerName(e) {
    var t = this.getProvider(e), n = de(t, 2);
    let r = n[0], s = n[1];
    s.endsWith("/") && (s = s.substring(0, s.length - 1));
    let a = r.suggestLayerName;
    return a !== void 0 ? a(s) : r3(s);
  }
  findSourceGroup(e) {
    var t = this.getProvider(e), n = de(t, 3);
    let r = n[0], s = n[1], a = n[2];
    return (r.findSourceGroup || AD)(s) + a.length + 3;
  }
};
var Ax = {};
var bg;
var _x;
function ND() {
  if (_x) return bg;
  _x = 1;
  var i = BR(), e = _re(), t = yD(), n = Mre().f;
  return bg = function(r) {
    return function(s) {
      for (var a = t(s), l = e(a), d = l.length, u = 0, h = [], g; d > u; )
        g = l[u++], (!i || n.call(a, g)) && h.push(r ? [g, a[g]] : a[g]);
      return h;
    };
  }, bg;
}
var Mx;
function o3() {
  if (Mx) return Ax;
  Mx = 1;
  var i = BD(), e = ND()(true);
  return i(i.S, "Object", {
    entries: function(n) {
      return e(n);
    }
  }), Ax;
}
var wg;
var Nx;
function l3() {
  return Nx || (Nx = 1, o3(), wg = mR().Object.entries), wg;
}
var Cg;
var Ox;
function c3() {
  return Ox || (Ox = 1, Cg = { default: l3(), __esModule: true }), Cg;
}
var d3 = c3();
var _c = Ws(d3);
var Vx = {};
var xg;
var Bx;
function OD() {
  if (Bx) return xg;
  Bx = 1;
  var i = nh(), e = _Un().getWeak, t = ZP(), n = pD(), r = ih(), s = Vo(), a = ay(), l = N2(), d = ea(), u = a(5), h = a(6), g = 0, v = function(w) {
    return w._l || (w._l = new y());
  }, y = function() {
    this.a = [];
  }, C = function(w, b) {
    return u(w.a, function(E) {
      return E[0] === b;
    });
  };
  return y.prototype = {
    get: function(w) {
      var b = C(this, w);
      if (b) return b[1];
    },
    has: function(w) {
      return !!C(this, w);
    },
    set: function(w, b) {
      var E = C(this, w);
      E ? E[1] = b : this.a.push([w, b]);
    },
    delete: function(w) {
      var b = h(this.a, function(E) {
        return E[0] === w;
      });
      return ~b && this.a.splice(b, 1), !!~b;
    }
  }, xg = {
    getConstructor: function(w, b, E, T) {
      var I = w(function(R, P) {
        r(R, I, b, "_i"), R._t = b, R._i = g++, R._l = void 0, P != null && s(P, E, R[T], R);
      });
      return i(I.prototype, {
        // 23.3.3.2 WeakMap.prototype.delete(key)
        // 23.4.3.3 WeakSet.prototype.delete(value)
        delete: function(R) {
          if (!n(R)) return false;
          var P = e(R);
          return P === true ? v(d(this, b)).delete(R) : P && l(P, this._i) && delete P[this._i];
        },
        // 23.3.3.4 WeakMap.prototype.has(key)
        // 23.4.3.4 WeakSet.prototype.has(value)
        has: function(P) {
          if (!n(P)) return false;
          var L = e(P);
          return L === true ? v(d(this, b)).has(P) : L && l(L, this._i);
        }
      }), I;
    },
    def: function(w, b, E) {
      var T = e(t(b), true);
      return T === true ? v(w).set(b, E) : T[w._i] = E, w;
    },
    ufstore: v
  }, xg;
}
var Fx;
function u3() {
  if (Fx) return Vx;
  Fx = 1;
  var i = OD(), e = ea(), t = "WeakSet";
  return rh()(t, function(n) {
    return function() {
      return n(this, arguments.length > 0 ? arguments[0] : void 0);
    };
  }, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function(r) {
      return i.def(e(this, t), r, true);
    }
  }, i, false, true), Vx;
}
var Ux = {};
var zx;
function h3() {
  return zx || (zx = 1, sh()("WeakSet")), Ux;
}
var $x = {};
var Gx;
function f3() {
  return Gx || (Gx = 1, ah()("WeakSet")), $x;
}
var Eg;
var Wx;
function p3() {
  return Wx || (Wx = 1, GUn(), u3(), h3(), f3(), Eg = mR().WeakSet), Eg;
}
var kg;
var Hx;
function g3() {
  return Hx || (Hx = 1, kg = { default: p3(), __esModule: true }), kg;
}
var m3 = g3();
var v3 = Ws(m3);
var Tg;
var qx;
function y3() {
  if (qx) return Tg;
  qx = 1;
  var i = dT(), e = Ppt(), t = "Expected a function";
  function n(r, s, a) {
    var l = true, d = true;
    if (typeof r != "function")
      throw new TypeError(t);
    return e(a) && (l = "leading" in a ? !!a.leading : l, d = "trailing" in a ? !!a.trailing : d), i(r, s, {
      leading: l,
      maxWait: s,
      trailing: d
    });
  }
  return Tg = n, Tg;
}
var S3 = y3();
var wh = Ws(S3);
function b3(i) {
  return typeof i == "boolean" ? { enabled: i } : (me(i), { enabled: xe(i, "enabled", na) });
}
function Jl(i, e = void 0) {
  return typeof i == "string" ? {
    url: i,
    transform: e,
    enableDefaultSubsources: true,
    subsources: new he()
  } : (me(i), {
    url: Y(i, "url", Ae),
    transform: Y(i, "transform", vL) || e,
    enableDefaultSubsources: xe(i, "enableDefaultSubsources", na, true),
    subsources: xe(i, "subsources", (t) => uh(t, b3), new he())
  });
}
function w3(i) {
  return i.enabled;
}
function jx(i) {
  const e = yL(i.transform), t = {};
  let n = true;
  for (const s of i.subsources) {
    var r = de(s, 2);
    const a = r[0], l = r[1], d = w3(l);
    d !== void 0 && (t[a] = d, n = false);
  }
  return e === void 0 && n && i.enableDefaultSubsources === true ? i.url : {
    url: i.url,
    transform: e,
    subsources: n ? void 0 : t,
    enableDefaultSubsources: i.enableDefaultSubsources === true ? void 0 : false
  };
}
var C3 = class {
  constructor(e, t, n, r, s) {
    this.loadedDataSource = e, this.subsourceEntry = t, this.subsourceSpec = n, this.subsourceIndex = r, this.activated = void 0, this.guardValues = [], this.messages = new Uo(), this.isActiveChanged = new Le();
    let a;
    n === void 0 || n.enabled === void 0 ? a = t.default && s : a = n.enabled;
    const l = e.dataSource.modelTransform.sourceRank;
    let d = t.modelSubspaceDimensionIndices;
    if (d === void 0) {
      d = new Array(l);
      for (let g = 0; g < l; ++g)
        d[g] = g;
    }
    var u = t.subsourceToModelSubspaceTransform;
    const h = u === void 0 ? ks(Float32Array, d.length + 1) : u;
    this.enabled = a, this.subsourceToModelSubspaceTransform = h, this.modelSubspaceDimensionIndices = d, this.isActiveChanged.add(e.activatedSubsourcesChanged.dispatch);
  }
  activate(e, ...t) {
    if (this.messages.clearMessages(), this.activated !== void 0) {
      if (He(t, this.guardValues)) return;
      this.activated.dispose();
    }
    this.guardValues = t;
    const n = this.activated = new X();
    e(n), this.isActiveChanged.dispatch();
  }
  deactivate(e) {
    this.messages.clearMessages(), this.messages.addMessage({ severity: ar.error, message: e });
    const t = this.activated;
    t !== void 0 && (this.activated = void 0, t.dispose(), this.isActiveChanged.dispatch());
  }
  addRenderLayer(e) {
    const t = this.activated;
    t.registerDisposer(this.loadedDataSource.layer.addRenderLayer(e)), t.registerDisposer(this.messages.addChild(e.messages));
  }
  getRenderLayerTransform(e) {
    const t = this.activated;
    var n = this.loadedDataSource;
    const r = n.layer, s = n.transform;
    return t.registerDisposer(bL(r.manager.root.coordinateSpace, r.localPosition.coordinateSpace, s, this, e));
  }
};
var Zy = class extends X {
  constructor(e, t, n) {
    super(), this.layerDataSource = e, this.dataSource = t, this.error = void 0, this.enabledSubsourcesChanged = new Le(), this.activatedSubsourcesChanged = new Le(), this.messages = new Uo(), t.canChangeModelSpaceRank ? (this.transform = new jC(ei(yt({ rank: 0, scales: new Float64Array(0), units: [], names: [] })), true), this.transform.value = t.modelTransform) : this.transform = new jC(t.modelTransform), n.transform !== void 0 && (this.transform.spec = n.transform);
    const r = n.subsources;
    this.enableDefaultSubsources = n.enableDefaultSubsources, this.subsources = t.subsources.map((s, a) => new C3(this, s, r.get(s.id), a, this.enableDefaultSubsources));
  }
  get enabledSubsources() {
    return this.subsources.filter((e) => e.enabled);
  }
  get layer() {
    return this.layerDataSource.layer;
  }
  disposed() {
    for (const e of this.subsources) {
      const t = e.activated;
      t !== void 0 && (e.activated = void 0, t.dispose());
    }
  }
};
var x3 = class extends X {
  constructor(e, t = void 0) {
    super(), this.layer = e, this.changed = new Le(), this.messages = new Uo(), this.loadState_ = void 0, this.specGeneration = -1, this.refCounted_ = void 0, this.registerDisposer(this.changed.add(e.dataSourcesChanged.dispatch)), t === void 0 ? this.spec_ = _D() : this.spec = t;
  }
  get spec() {
    const e = this.loadState;
    if (e !== void 0 && e.error === void 0) {
      const t = this.changed.count;
      t !== this.specGeneration && (this.specGeneration = t, this.spec_ = {
        url: this.spec.url,
        transform: e.transform.spec,
        enableDefaultSubsources: e.enableDefaultSubsources,
        subsources: new he(_e(e.subsources, (n) => {
          const r = e.enableDefaultSubsources && n.subsourceEntry.default;
          return [n.subsourceEntry.id, {
            enabled: n.enabled !== r ? n.enabled : void 0
          }];
        }))
      });
    }
    return this.spec_;
  }
  get loadState() {
    return this.loadState_;
  }
  set spec(e) {
    const t = this.layer;
    if (this.messages.clearMessages(), e.url.length === 0) {
      if (t.dataSources.length !== 1) {
        const d = t.dataSources.indexOf(this);
        if (d !== -1) {
          t.dataSources.splice(d, 1), t.dataSourcesChanged.dispatch(), this.dispose();
          return;
        }
      }
      this.spec_ = e, this.refCounted_ !== void 0 && (this.refCounted_.dispose(), this.refCounted_ = void 0, this.loadState_ = void 0, this.changed.dispatch());
      return;
    }
    const n = new X(), r = n.registerDisposer(fT(t.markLoading()));
    this.refCounted_ !== void 0 && (this.refCounted_.dispose(), this.loadState_ = void 0), this.refCounted_ = n, this.spec_ = e;
    const s = t.manager.chunkManager, a = t.manager.dataSourceProviderRegistry, l = new Ts();
    this.messages.addMessage({ severity: ar.info, message: "Loading data source" }), a.get({
      chunkManager: s,
      url: e.url,
      cancellationToken: l,
      globalCoordinateSpace: t.manager.root.coordinateSpace,
      transform: e.transform
    }).then((d) => {
      if (n.wasDisposed) return;
      this.messages.clearMessages();
      const u = n.registerDisposer(new Zy(this, d, e));
      u.registerDisposer(t.addCoordinateSpace(u.transform.outputSpace)), u.registerDisposer(u.transform.changed.add(this.changed.dispatch)), this.loadState_ = u, u.registerDisposer(u.enabledSubsourcesChanged.add(this.changed.dispatch)), this.changed.dispatch(), r();
    }).catch((d) => {
      this.wasDisposed || (this.loadState_ = { error: d }, this.messages.clearMessages(), this.messages.addMessage({ severity: ar.error, message: d.message }), this.changed.dispatch());
    }), n.registerDisposer(() => {
      l.cancel();
    }), this.changed.dispatch();
  }
  disposed() {
    const e = this.refCounted_;
    e !== void 0 && e.dispose();
  }
  toJSON() {
    const e = this.loadState;
    return e === void 0 || e.error !== void 0 ? jx(this.spec) : jx({
      url: this.spec.url,
      transform: e.transform.spec,
      enableDefaultSubsources: e.enableDefaultSubsources,
      subsources: new he(_e(e.subsources, (t) => {
        const n = e.enableDefaultSubsources && t.subsourceEntry.default;
        return [t.subsourceEntry.id, {
          enabled: t.enabled !== n ? t.enabled : void 0
        }];
      }))
    });
  }
};
var Jx = {};
var Lg;
var Kx;
function E3() {
  return Kx || (Kx = 1, Lg = Object.is || function(e, t) {
    return e === t ? e !== 0 || 1 / e === 1 / t : e != e && t != t;
  }), Lg;
}
var Yx;
function k3() {
  if (Yx) return Jx;
  Yx = 1;
  var i = BD();
  return i(i.S, "Object", { is: E3() }), Jx;
}
var Dg;
var Xx;
function T3() {
  return Xx || (Xx = 1, k3(), Dg = mR().Object.is), Dg;
}
var Ig;
var Zx;
function L3() {
  return Zx || (Zx = 1, Ig = { default: T3(), __esModule: true }), Ig;
}
var D3 = L3();
var Qx = Ws(D3);
var e1 = {};
var Pg;
var t1;
function I3() {
  return t1 || (t1 = 1, Pg = Math.sign || function(e) {
    return (e = +e) == 0 || e != e ? e : e < 0 ? -1 : 1;
  }), Pg;
}
var n1;
function P3() {
  if (n1) return e1;
  n1 = 1;
  var i = BD();
  return i(i.S, "Math", { sign: I3() }), e1;
}
var Rg;
var i1;
function R3() {
  return i1 || (i1 = 1, P3(), Rg = mR().Math.sign), Rg;
}
var Ag;
var r1;
function A3() {
  return r1 || (r1 = 1, Ag = { default: R3(), __esModule: true }), Ag;
}
var _3 = A3();
var dc = Ws(_3);
var _g = { exports: {} };
var s1;
function M3() {
  if (s1) return _g.exports;
  s1 = 1;
  var i = pR(), e = ay()(0), t = qmt(), n = _Un(), r = cUn(), s = OD(), a = pD(), l = ea(), d = ea(), u = !i.ActiveXObject && "ActiveXObject" in i, h = "WeakMap", g = n.getWeak, v = Object.isExtensible, y = s.ufstore, C, w = function(T) {
    return function() {
      return T(this, arguments.length > 0 ? arguments[0] : void 0);
    };
  }, b = {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function(I) {
      if (a(I)) {
        var R = g(I);
        return R === true ? y(l(this, h)).get(I) : R ? R[this._i] : void 0;
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function(I, R) {
      return s.def(l(this, h), I, R);
    }
  }, E = _g.exports = rh()(h, w, b, s, true, true);
  return d && u && (C = s.getConstructor(w, h), r(C.prototype, b), n.NEED = true, e(["delete", "has", "get", "set"], function(T) {
    var I = E.prototype, R = I[T];
    t(I, T, function(P, L) {
      if (a(P) && !v(P)) {
        this._f || (this._f = new C());
        var A = this._f[T](P, L);
        return T == "set" ? this : A;
      }
      return R.call(this, P, L);
    });
  })), _g.exports;
}
var a1 = {};
var o1;
function N3() {
  return o1 || (o1 = 1, sh()("WeakMap")), a1;
}
var l1 = {};
var c1;
function O3() {
  return c1 || (c1 = 1, ah()("WeakMap")), l1;
}
var Mg;
var d1;
function V3() {
  return d1 || (d1 = 1, GUn(), M3(), N3(), O3(), Mg = mR().WeakMap), Mg;
}
var Ng;
var u1;
function B3() {
  return u1 || (u1 = 1, Ng = { default: V3(), __esModule: true }), Ng;
}
var F3 = B3();
var VD = Ws(F3);
function Dn(i, e, t) {
  xe(i, e, (n) => t.restoreState(n));
}
var Ch = class extends X {
  constructor() {
    super(...arguments), this.children = new he(), this.changed = new Le();
  }
  add(e, t) {
    if (this.children.has(e))
      throw new Error(`Key ${oe(e)} already registered.`);
    return this.children.set(e, t), t.changed.add(this.changed.dispatch), this.changed.dispatch(), () => {
      this.remove(e);
    };
  }
  remove(e) {
    const t = this.children;
    if (t.has(e))
      throw new Error(`Key ${oe(e)} not registered.`);
    const n = t.get(e);
    this.children.delete(e), n.changed.remove(this.changed.dispatch), this.changed.dispatch();
  }
  disposed() {
    const e = this.changed;
    for (let t of this.children.values())
      t.changed.remove(e.dispatch);
    this.children = void 0, super.disposed();
  }
  toJSON() {
    const e = this.baseJSON();
    for (let n of this.children) {
      var t = de(n, 2);
      let r = t[0], s = t[1];
      e[r] = s.toJSON();
    }
    return e;
  }
  baseJSON() {
    return {};
  }
  reset() {
    for (let e of this.children.values())
      e.reset();
  }
  restoreState(e) {
    me(e);
    for (let n of this.children) {
      var t = de(n, 2);
      let r = t[0], s = t[1];
      try {
        if (e.hasOwnProperty(r)) {
          const a = e[r];
          if (a === void 0)
            continue;
          s.restoreState(a);
        }
      } catch (a) {
        throw new Error(`Error restoring property ${oe(r)}: ${a.message}`);
      }
    }
  }
};
var h1 = new VD();
function xh(i) {
  let e = h1.get(i);
  const t = i.changed.count;
  if (e !== void 0 && e.generation === t)
    return e;
  let n;
  if (i instanceof Ch) {
    n = i.baseJSON();
    for (let s of i.children) {
      var r = de(s, 2);
      let a = r[0], l = r[1];
      n[a] = xh(l).value;
    }
  } else
    n = i.toJSON();
  return e === void 0 ? (e = { generation: t, value: n }, h1.set(i, e)) : (e.generation = t, e.value = n), e;
}
var Eh = class {
  constructor(e, t, n = t) {
    this.enumType = e, this.value_ = t, this.defaultValue = n, this.changed = new Le();
  }
  set value(e) {
    this.value_ !== e && (this.value_ = e, this.changed.dispatch());
  }
  get value() {
    return this.value_;
  }
  reset() {
    this.value = this.defaultValue;
  }
  restoreState(e) {
    this.value = Rn(e, this.enumType);
  }
  toJSON() {
    if (this.value_ !== this.defaultValue)
      return this.enumType[this.value_].toLowerCase();
  }
};
var qt;
(function(i) {
  i[i.LINKED = 0] = "LINKED", i[i.RELATIVE = 1] = "RELATIVE", i[i.UNLINKED = 2] = "UNLINKED";
})(qt || (qt = {}));
var xu;
(function(i) {
  i[i.LINKED = 0] = "LINKED", i[i.UNLINKED = 2] = "UNLINKED";
})(xu || (xu = {}));
var U3 = class extends Eh {
  constructor(e = qt.LINKED) {
    super(qt, e);
  }
};
var z3 = class extends Eh {
  constructor(e = xu.LINKED) {
    super(xu, e);
  }
};
var Ad = ze();
var BD2 = Wn();
function Mc(i, e, t, n) {
  let r = false, s;
  i.registerDisposer(e);
  const a = () => {
    switch (r = true, t.value) {
      case qt.UNLINKED:
        if (n.isValid(i))
          break;
      case qt.LINKED:
        n.assign(i, e);
        break;
      case qt.RELATIVE:
        n.add(i, e, s);
        break;
    }
    r = false;
  }, l = () => {
    if (!r)
      switch (t.value) {
        case qt.UNLINKED:
          break;
        case qt.LINKED:
          n.assign(e, i);
          break;
        case qt.RELATIVE:
          n.subtract(e, i, s);
          break;
      }
  };
  let d = qt.UNLINKED;
  const u = () => {
    const h = t.value;
    if (h !== d)
      switch (h) {
        case qt.UNLINKED:
          s = void 0;
          break;
        case qt.LINKED:
          s = void 0, n.assign(i, e);
          break;
        case qt.RELATIVE:
          s = n.difference(i, e);
          break;
      }
    d = h, i.changed.dispatch();
  };
  return i.registerDisposer(i.changed.add(l)), i.registerDisposer(e.changed.add(a)), i.registerDisposer(t.changed.add(u)), u(), i;
}
function FD(i, e, t, n) {
  return Mc(i, e, t, n);
}
var Js = class extends X {
  constructor(e) {
    super(), this.coordinateSpace = e, this.coordinates_ = go, this.changed = new Le(), this.registerDisposer(e.changed.add(() => {
      this.handleCoordinateSpaceChanged();
    }));
  }
  get valid() {
    return this.coordinateSpace.value.valid;
  }
  /**
   * Returns the position in voxels.
   */
  get value() {
    return this.handleCoordinateSpaceChanged(), this.coordinates_;
  }
  reset() {
    this.curCoordinateSpace = void 0, this.coordinates_ = go, this.changed.dispatch();
  }
  set value(e) {
    const t = this.curCoordinateSpace;
    if (t === void 0 || !t.valid || t.rank !== e.length)
      return;
    this.coordinates_.set(e), this.changed.dispatch();
  }
  handleCoordinateSpaceChanged() {
    const e = this.coordinateSpace.value, t = this.curCoordinateSpace;
    if (e === t) return;
    this.curCoordinateSpace = e;
    const n = e.rank;
    if (!e.valid) return;
    if (t === void 0 || !t.valid) {
      let h = this.coordinates_;
      if (!(h !== void 0 && h.length === n)) {
        h = this.coordinates_ = new Float32Array(n), tV(h, e.bounds);
        for (let g = 0; g < n; ++g)
          h[g] = Math.floor(h[g]) + 0.5;
      }
      this.changed.dispatch();
      return;
    }
    const r = new Float32Array(n), s = this.coordinates_, a = e.ids, l = e.scales, d = t.ids, u = t.scales;
    for (let h = 0; h < n; ++h) {
      const g = a[h], v = d.indexOf(g);
      v === -1 ? r[h] = cL(e.bounds.lowerBounds[h], e.bounds.upperBounds[h]) : r[h] = s[v] * (u[v] / l[h]);
    }
    this.coordinates_ = r, this.changed.dispatch();
  }
  toJSON() {
    if (!this.valid && this.coordinates_.length === 0) return;
    this.handleCoordinateSpaceChanged();
    const e = this.value;
    if (e.length !== 0)
      return _e(e);
  }
  restoreState(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    this.curCoordinateSpace = void 0, this.coordinates_ = Float32Array.from(Xe(e, Dt)), this.handleCoordinateSpaceChanged(), this.changed.dispatch();
  }
  snapToVoxel() {
    this.handleCoordinateSpaceChanged();
    const e = this.coordinates_, t = e.length;
    for (let n = 0; n < t; ++n)
      e[n] = Math.floor(e[n]) + 0.5;
    this.changed.dispatch();
  }
  assign(e) {
    e.handleCoordinateSpaceChanged();
    const t = e.curCoordinateSpace, n = e.coordinates_;
    this.curCoordinateSpace = t, this.coordinates_ = Float32Array.from(n), this.changed.dispatch();
  }
  /**
   * Get the offset of `a` relative to `b`.
   */
  static getOffset(e, t) {
    const n = e.coordinates_, r = t.coordinates_;
    if (n.length === r.length)
      return Mm(new Float32Array(n.length), n, r);
  }
  static addOffset(e, t, n, r = 1) {
    e.handleCoordinateSpaceChanged();
    const s = t.value;
    n !== void 0 && s.length === n.length && (qO(e.value, s, n, r), e.changed.dispatch());
  }
  get legacyJsonView() {
    const e = this;
    return {
      changed: e.changed,
      toJSON() {
        return e.toJSON();
      },
      reset() {
        e.reset();
      },
      restoreState(t) {
        if (t === void 0 || Array.isArray(t)) {
          e.restoreState(t);
          return;
        }
        me(t), Dn(t, "voxelCoordinates", e);
      }
    };
  }
};
function UD(i, e, t) {
  if (t === void 0 || hn(t).length === 0) {
    i.value = qt.LINKED;
    return;
  }
  me(t), i.value = qt.UNLINKED, Y(t, "value", (n) => {
    n !== void 0 && e.restoreState(n);
  }), Y(t, "link", (n) => i.restoreState(n));
}
var Nc = class {
  constructor(e, t = new U3()) {
    this.peer = e, this.link = t;
  }
  get changed() {
    return this.value.changed;
  }
  toJSON() {
    const e = this.link;
    if (e.value !== qt.LINKED)
      return { link: e.toJSON(), value: this.getValueJson() };
  }
  getValueJson() {
    return this.value.toJSON();
  }
  reset() {
    this.link.value = qt.LINKED;
  }
  restoreState(e) {
    UD(this.link, this.value, e);
  }
  copyToPeer() {
    this.link.value !== qt.LINKED && (this.link.value = qt.UNLINKED, this.peer.assign(this.value), this.link.value = qt.LINKED);
  }
};
var zD = class extends Nc {
  constructor(e, t = new z3()) {
    super(e, t);
  }
};
var $D = class extends Nc {
  constructor() {
    super(...arguments), this.value = Mc(new Js(this.peer.coordinateSpace), this.peer, this.link, {
      assign: (e, t) => e.assign(t),
      isValid: (e) => e.valid,
      difference: Js.getOffset,
      add: Js.addOffset,
      subtract: (e, t, n) => {
        Js.addOffset(e, t, n, -1);
      }
    });
  }
};
function $3(i) {
  return i[0] === 0 && i[1] === 0 && i[2] === 0 && i[3] === 1;
}
var ko = class _ko extends X {
  constructor(e) {
    super(), this.changed = new Le(), e == null && (e = Wn()), this.orientation = e;
  }
  toJSON() {
    let e = this.orientation;
    if (Zl(this.orientation, this.orientation), !$3(e))
      return Array.prototype.slice.call(this.orientation);
  }
  restoreState(e) {
    try {
      ao(this.orientation, e), Zl(this.orientation, this.orientation);
    } catch {
      hC(this.orientation);
    }
    this.changed.dispatch();
  }
  reset() {
    hC(this.orientation), this.changed.dispatch();
  }
  snap() {
    let e = Sc();
    yT(e, this.orientation);
    let t = [false, false, false];
    for (let n = 0; n < 3; ++n) {
      let r = 0, s = 0;
      for (let a = 0; a < 3; ++a) {
        let l = e[n * 3 + a];
        e[n * 3 + a] = 0, !t[a] && Math.abs(l) > Math.abs(r) && (r = l, s = a);
      }
      e[n * 3 + s] = dc(r), t[s] = true;
    }
    ET(this.orientation, e), this.changed.dispatch();
  }
  /**
   * Returns a new OrientationState with orientation fixed to peerToSelf * peer.orientation.  Any
   * changes to the returned OrientationState will cause a corresponding change in peer, and vice
   * versa.
   */
  static makeRelative(e, t) {
    let n = new _ko(ps(Wn(), e.orientation, t)), r = false;
    n.registerDisposer(e.changed.add(() => {
      r || (s = true, ps(n.orientation, e.orientation, t), n.changed.dispatch(), s = false);
    }));
    let s = false;
    const a = au(Wn(), t);
    return n.registerDisposer(n.changed.add(() => {
      s || (r = true, ps(e.orientation, n.orientation, a), e.changed.dispatch(), r = false);
    })), n;
  }
  assign(e) {
    wN(this.orientation, e.orientation), this.changed.dispatch();
  }
};
var Km = class extends Nc {
  constructor() {
    super(...arguments), this.value = Mc(new ko(), this.peer, this.link, {
      assign: (e, t) => e.assign(t),
      isValid: () => true,
      difference: (e, t) => {
        const n = Wn();
        return ps(n, au(n, t.orientation), e.orientation);
      },
      add: (e, t, n) => {
        ps(e.orientation, t.orientation, n), e.changed.dispatch();
      },
      subtract: (e, t, n) => {
        ps(e.orientation, t.orientation, au(BD2, n)), e.changed.dispatch();
      }
    });
  }
};
var GD = class extends X {
  constructor(e) {
    super(), this.coordinateSpace = e, this.changed = new Le(), this.curCoordinateSpace = Vr, this.value_ = { factors: new Float64Array(0) }, this.registerDisposer(e.changed.add(() => this.update())), this.update();
  }
  get value() {
    return this.update();
  }
  reset() {
    this.value_ = { factors: new Float64Array(0) }, this.curCoordinateSpace = Vr, this.changed.dispatch();
  }
  toJSON() {
    const e = {};
    let t = false;
    const r = this.value.factors;
    var s = this.curCoordinateSpace;
    const a = s.names, l = s.rank;
    for (let d = 0; d < l; ++d) {
      const u = r[d];
      u !== 1 && (e[a[d]] = u, t = true);
    }
    if (t) return e;
  }
  restoreState(e) {
    const t = this.coordinateSpace.value, n = t.names, r = t.rank, s = new Float64Array(r);
    if (s.fill(-1), e !== void 0) {
      const a = me(e);
      for (let l = 0; l < r; ++l)
        s[l] = Y(a, n[l], (d) => d === void 0 ? 1 : yn(d));
    }
    this.value_ = { factors: s }, this.curCoordinateSpace = t, this.changed.dispatch();
  }
  setFactors(e) {
    const t = this.coordinateSpace.value;
    e.length === t.rank && (this.value_ = { factors: e }, this.curCoordinateSpace = t, this.changed.dispatch());
  }
  update() {
    const e = this.coordinateSpace.value;
    let t = this.value_;
    const n = this.curCoordinateSpace;
    if (n === e) return t;
    const r = n.ids, s = e.ids, a = e.rank, l = t.factors, d = new Float64Array(a);
    d.fill(1);
    for (let u = 0; u < a; ++u) {
      const h = s[u], g = r.indexOf(h);
      g !== -1 && (d[u] = l[g]);
    }
    return He(d, l) || (t = this.value_ = { factors: d }, this.curCoordinateSpace = e, this.changed.dispatch()), t;
  }
  assign(e) {
    this.setFactors(e.value.factors);
  }
};
function f1(i, e, t, n, r) {
  if (t === n) return e;
  const s = t.ids, a = n.rank, l = n.ids, d = new i(a);
  for (let u = 0; u < a; ++u) {
    const h = l[u], g = s.indexOf(h);
    d[u] = g === -1 ? r(u) : e[g];
  }
  return d;
}
var G3 = class extends Nc {
  constructor() {
    super(...arguments), this.value = Mc(new GD(this.peer.coordinateSpace), this.peer, this.link, {
      assign: (e, t) => e.assign(t),
      difference: (e, t) => {
        const n = e.value.factors, r = e.coordinateSpace.value, s = t.value.factors;
        return {
          coordinateSpace: r,
          offsets: Mm(new Float64Array(n.length), n, s)
        };
      },
      add: (e, t, n) => {
        const r = f1(Float64Array, n.offsets, n.coordinateSpace, e.coordinateSpace.value, () => 0);
        e.setFactors(aL(new Float64Array(r.length), r, t.value.factors));
      },
      subtract: (e, t, n) => {
        const r = f1(Float64Array, n.offsets, n.coordinateSpace, e.coordinateSpace.value, () => 0);
        e.setFactors(Mm(new Float64Array(r.length), t.value.factors, r));
      },
      isValid: () => true
    });
  }
};
function p1(i, e, t) {
  const n = i.rank, r = i.names, s = i.units, a = e.displayRank, l = e.displayDimensionIndices, d = new Float64Array(3);
  let u = new Float64Array(3), h;
  const g = t.factors, v = new Array(3), y = new Float64Array(3);
  if (d.fill(1), u.fill(1), y.fill(1), v.fill(""), a === 0)
    h = 1;
  else {
    h = Number.POSITIVE_INFINITY;
    const C = i.scales;
    for (let w = 0; w < a; ++w) {
      const b = l[w], E = u[w] = g[b] * C[b];
      h = Math.min(h, E), v[w] = s[b], y[w] = C[b];
    }
    for (let w = 0; w < a; ++w)
      d[w] = u[w] / h;
  }
  return {
    globalRank: n,
    globalDimensionNames: r,
    displayRank: a,
    displayDimensionIndices: l,
    displayDimensionUnits: v,
    displayDimensionScales: y,
    canonicalVoxelFactors: d,
    voxelPhysicalScales: u,
    canonicalVoxelPhysicalSize: h
  };
}
function W3(i, e) {
  return He(i.globalDimensionNames, e.globalDimensionNames) && He(i.displayDimensionIndices, e.displayDimensionIndices) && He(i.canonicalVoxelFactors, e.canonicalVoxelFactors) && He(i.voxelPhysicalScales, e.voxelPhysicalScales) && i.canonicalVoxelPhysicalSize === e.canonicalVoxelPhysicalSize && He(i.displayDimensionUnits, e.displayDimensionUnits) && He(i.displayDimensionScales, e.displayDimensionScales);
}
var WD = class extends X {
  constructor(e, t) {
    super(), this.relativeDisplayScales = e, this.displayDimensions = t, this.changed = new Le(), this.curRelativeDisplayScales = this.relativeDisplayScales.value, this.curDisplayDimensions = this.displayDimensions.value, this.curCoordinateSpace = this.relativeDisplayScales.coordinateSpace.value, this.value_ = p1(this.curCoordinateSpace, this.curDisplayDimensions, this.curRelativeDisplayScales), this.registerDisposer(e), this.registerDisposer(t);
    const n = () => {
      this.value;
    };
    this.registerDisposer(e.changed.add(n)), this.registerDisposer(t.changed.add(n));
  }
  get value() {
    var e = this.relativeDisplayScales;
    const t = e.value, n = e.coordinateSpace.value, r = this.displayDimensions.value, s = this.curRelativeDisplayScales, a = this.curDisplayDimensions, l = this.curCoordinateSpace;
    let d = this.value_;
    if (s !== t || a !== r || l !== n) {
      this.curRelativeDisplayScales = t, this.curDisplayDimensions = r, this.curCoordinateSpace = n;
      const u = p1(n, r, t);
      W3(d, u) || (this.value_ = d = u, this.changed.dispatch());
    }
    return d;
  }
};
var HD = class extends X {
  constructor(e) {
    super(), this.coordinateSpace = e, this.changed = new Le(), this.default_ = true, this.value_ = void 0, this.registerDisposer(this.coordinateSpace.changed.add(this.changed.dispatch)), this.update();
  }
  get value() {
    return this.update(), this.value_;
  }
  update() {
    const e = this.coordinateSpace.value, t = this.value_;
    if (t !== void 0 && t.coordinateSpace === e)
      return;
    if (t === void 0 || this.default_) {
      this.setToDefault(e);
      return;
    }
    const n = new Int32Array(3), r = t.coordinateSpace.ids, s = e.ids, a = t.displayDimensionIndices, l = t.displayRank;
    let d = 0;
    for (let u = 0; u < l; ++u) {
      const h = s.indexOf(r[a[u]]);
      h !== -1 && (n[d] = h, ++d);
    }
    if (n.fill(-1, d), d === 0) {
      this.default_ = true, this.setToDefault(e);
      return;
    }
    this.assignValue(e, d, n), this.changed.dispatch();
  }
  setToDefault(e) {
    const t = Math.min(e.rank, 3), n = new Int32Array(3);
    n.fill(-1);
    for (let r = 0; r < t; ++r)
      n[r] = r;
    this.assignValue(e, t, n);
  }
  assignValue(e, t, n) {
    this.value_ = {
      coordinateSpace: e,
      displayRank: t,
      displayDimensionIndices: n
    }, this.changed.dispatch();
  }
  reset() {
    this.default_ = true, this.value_ = void 0, this.changed.dispatch();
  }
  restoreState(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    const t = Ly(e);
    if (t.length > 3)
      throw new Error("Number of spatial dimensions must be <= 3");
    const n = this.coordinateSpace.value, r = new Int32Array(3);
    r.fill(-1);
    const s = n.names;
    let a = 0;
    for (const l of t) {
      const d = s.indexOf(l);
      d !== -1 && (r[a++] = d);
    }
    if (a === 0) {
      this.reset();
      return;
    }
    this.default_ = false, this.assignValue(n, a, r);
  }
  get default() {
    return this.update(), this.default_;
  }
  set default(e) {
    this.default_ !== e && (e ? (this.default_ = true, this.setToDefault(this.coordinateSpace.value)) : (this.default_ = false, this.changed.dispatch()));
  }
  setDimensionIndices(e, t) {
    this.default_ = false, this.assignValue(this.coordinateSpace.value, e, t);
  }
  toJSON() {
    if (this.default_) return;
    const e = this.value, t = [], n = e.displayRank, r = e.displayDimensionIndices, s = e.coordinateSpace.names;
    if (n !== 0) {
      for (let a = 0; a < n; ++a)
        t[a] = s[r[a]];
      return t;
    }
  }
  assign(e) {
    if (e.default)
      this.default = true;
    else {
      var t = e.value;
      const n = t.displayRank, r = t.displayDimensionIndices;
      this.setDimensionIndices(n, r);
    }
  }
};
var H3 = class extends zD {
  constructor(e) {
    super(e), this.value = FD(new HD(this.peer.coordinateSpace), this.peer, this.link, {
      assign: (t, n) => t.assign(n),
      isValid: () => true
    });
  }
};
var To = class extends X {
  constructor(e, t, n) {
    super(), this.position = e, this.displayDimensionRenderInfo = t, this.orientation = n, this.changed = new Le(), this.registerDisposer(e), this.registerDisposer(n), this.registerDisposer(t), this.registerDisposer(e.changed.add(this.changed.dispatch)), this.registerDisposer(n.changed.add(this.changed.dispatch)), this.registerDisposer(t.changed.add(this.changed.dispatch));
  }
  get displayDimensions() {
    return this.displayDimensionRenderInfo.displayDimensions;
  }
  get relativeDisplayScales() {
    return this.displayDimensionRenderInfo.relativeDisplayScales;
  }
  get valid() {
    return this.position.valid;
  }
  /**
   * Resets everything.
   */
  reset() {
    this.position.reset(), this.orientation.reset(), this.displayDimensions.reset();
  }
  updateDisplayPosition(e, t = Ad) {
    var n = this.position;
    const r = n.coordinateSpace.value, s = n.value;
    var a = this.displayDimensions.value;
    const l = a.displayDimensionIndices, d = a.displayRank;
    if (r === void 0) return false;
    t.fill(0);
    for (let u = 0; u < d; ++u) {
      const h = l[u];
      t[u] = s[h];
    }
    if (e(t) !== false) {
      for (let u = 0; u < d; ++u) {
        const h = l[u];
        s[h] = t[u];
      }
      return this.position.changed.dispatch(), true;
    }
    return false;
  }
  // Transform from view coordinates to global spatial coordinates.
  toMat4(e, t) {
    uN(e, this.orientation.orientation);
    const n = this.position.value;
    var r = this.displayDimensionRenderInfo.value;
    const s = r.canonicalVoxelFactors, a = r.displayDimensionIndices;
    for (let l = 0; l < 3; ++l) {
      const d = a[l], u = t / s[l];
      e[l] *= u, e[4 + l] *= u, e[8 + l] *= u, e[12 + l] = n[d] || 0;
    }
  }
  toMat3(e, t) {
    yT(e, this.orientation.orientation);
    var n = this.displayDimensionRenderInfo.value;
    const r = n.canonicalVoxelFactors, s = n.displayRank;
    for (let a = 0; a < s; ++a) {
      const l = t / r[a];
      e[a] *= l, e[3 + a] *= l, e[6 + a] *= l;
    }
  }
  /**
   * Snaps the orientation to the nearest axis-aligned orientation, and
   * snaps the position to the nearest voxel.
   */
  snap() {
    this.orientation.snap(), this.position.snapToVoxel(), this.changed.dispatch();
  }
  translateDimensionRelative(e, t) {
    if (!this.valid)
      return;
    const n = this.position, r = n.value;
    var s = n.coordinateSpace.value.bounds;
    const a = s.lowerBounds, l = s.upperBounds;
    let d = r[e] + t;
    if (t > 0) {
      const u = l[e];
      Lt(u) && (d = Math.min(d, Math.ceil(u - 1)));
    } else {
      const u = a[e];
      Lt(u) && (d = Math.max(d, Math.floor(u)));
    }
    r[e] = d, n.changed.dispatch();
  }
  translateVoxelsRelative(e, t = false) {
    if (!this.valid)
      return;
    const n = so(Ad, e, this.orientation.orientation), r = this.position, s = r.value;
    var a = this.displayDimensions.value;
    const l = a.displayDimensionIndices, d = a.displayRank;
    var u = r.coordinateSpace.value.bounds;
    const h = u.lowerBounds, g = u.upperBounds;
    for (let v = 0; v < d; ++v) {
      const y = l[v], C = n[v];
      if (C === 0) continue;
      let w = s[y] + C;
      if (C > 0) {
        const b = g[y];
        Lt(b) && (w = Math.min(w, Math.ceil(b - 1)));
      } else {
        const b = h[y];
        Lt(b) && (w = Math.max(w, Math.floor(b)));
      }
      t && (w = Math.floor(w) + 0.5), s[y] = w;
    }
    this.position.changed.dispatch();
  }
  rotateRelative(e, t) {
    var n = Wn();
    Em(n, e, t);
    var r = this.orientation.orientation;
    ps(r, r, n), this.orientation.changed.dispatch();
  }
  rotateAbsolute(e, t, n) {
    var r = this.position;
    const s = r.coordinateSpace.value, a = r.value;
    if (s === void 0) return;
    const l = this.relativeDisplayScales.value.factors;
    var d = this.displayDimensions.value;
    const u = d.displayDimensionIndices, h = d.displayRank, g = s.scales, v = Wn();
    Em(v, e, t);
    const y = this.orientation.orientation, C = Ad;
    Ad.fill(0);
    for (let b = 0; b < h; ++b) {
      const E = u[b], T = n[E] - a[E];
      C[b] = T * g[E] * l[E];
    }
    const w = au(BD2, y);
    so(C, C, w), ps(y, v, y), so(C, C, y);
    for (let b = 0; b < h; ++b) {
      const E = u[b];
      a[E] = n[E] - C[b] / (g[E] * l[E]);
    }
    this.position.changed.dispatch(), this.orientation.changed.dispatch();
  }
  translateNonDisplayDimension(e, t) {
    if (!this.valid) return;
    const n = this.displayDimensions.value.displayDimensionIndices, s = this.position.coordinateSpace.value.rank;
    for (let a = 0; a < s; ++a)
      if (n.indexOf(a) === -1 && e-- === 0) {
        this.translateDimensionRelative(a, t);
        return;
      }
  }
};
var Ym = class extends Nc {
  constructor(e, t) {
    super(e), this.value = (() => {
      const n = new e.constructor(t), r = (u, h) => {
        u.assign(h);
      }, s = (u, h) => u.value / h.value * (u.canonicalVoxelPhysicalSize / h.canonicalVoxelPhysicalSize), a = (u, h, g) => {
        u.setPhysicalScale(h.value * g, h.canonicalVoxelPhysicalSize);
      }, l = (u, h, g) => {
        u.setPhysicalScale(h.value / g, h.canonicalVoxelPhysicalSize);
      }, d = (u) => u.coordinateSpaceValue.valid && u.canonicalVoxelPhysicalSize !== 0;
      return Mc(n, this.peer, this.link, { assign: r, isValid: d, difference: s, add: a, subtract: l }), n;
    })();
  }
};
function uc(i) {
  return {
    changed: i.changed,
    toJSON() {
      return i.toJSON();
    },
    restoreState(e) {
      UD(i.link, i.value.legacyJsonView, e);
    },
    reset() {
      i.reset();
    }
  };
}
var qD = class extends X {
  constructor(e) {
    super(), this.displayDimensionRenderInfo = e, this.changed = new Le(), this.curCanonicalVoxelPhysicalSize = 0, this.value_ = Number.NaN, this.legacyValue_ = Number.NaN, this.registerDisposer(e), this.registerDisposer(e.changed.add(() => this.handleCoordinateSpaceChanged())), this.registerDisposer(e.relativeDisplayScales.coordinateSpace.changed.add(() => this.handleCoordinateSpaceChanged())), this.handleCoordinateSpaceChanged();
  }
  /**
   * Zoom factor.  For cross section views, in canonical voxels per viewport pixel.  For projection
   * views, in canonical voxels per viewport height (for orthographic projection).
   */
  get value() {
    return this.handleCoordinateSpaceChanged(), this.value_;
  }
  set value(e) {
    const t = this.canonicalVoxelPhysicalSize;
    Qx(e, this.value_) && t === this.curCanonicalVoxelPhysicalSize || (this.curCanonicalVoxelPhysicalSize = t, this.legacyValue_ = Number.NaN, this.value_ = e, this.changed.dispatch());
  }
  get canonicalVoxelPhysicalSize() {
    return this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
  }
  get coordinateSpaceValue() {
    return this.displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace.value;
  }
  /**
   * Sets the zoom factor in the legacy units.  For cross section views, `1e-9` spatial units per
   * viewport pixel.  For projection views, `2 * 100 * Math.tan(Math.PI / 8) * 1e-9` spatial units
   * per viewport height (for orthographic projection).
   */
  set legacyValue(e) {
    Qx(e, this.legacyValue_) || (this.value_ = Number.NaN, this.legacyValue_ = e, this.curCanonicalVoxelPhysicalSize = 0, this.changed.dispatch());
  }
  get legacyValue() {
    return this.legacyValue_;
  }
  handleCoordinateSpaceChanged() {
    const e = this.value_;
    var t = this.displayDimensionRenderInfo;
    const n = t.value.canonicalVoxelPhysicalSize, r = t.relativeDisplayScales.coordinateSpace.value, s = this.curCanonicalVoxelPhysicalSize;
    if (!(!er(e) && n === s)) {
      if (!er(e)) {
        s !== 0 && (this.value_ = e * (s / n), this.curCanonicalVoxelPhysicalSize = n, this.changed.dispatch());
        return;
      }
      !r.valid || n === 0 || (this.curCanonicalVoxelPhysicalSize = n, this.value_ = this.getDefaultValue(), this.changed.dispatch());
    }
  }
  toJSON() {
    const e = this.value;
    return er(e) ? void 0 : e;
  }
  restoreState(e) {
    this.curCanonicalVoxelPhysicalSize = 0, this.legacyValue_ = Number.NaN, e === void 0 ? this.value_ = Number.NaN : this.value_ = yn(e), this.changed.dispatch();
  }
  reset() {
    this.curCanonicalVoxelPhysicalSize = 0, this.value_ = Number.NaN, this.legacyValue_ = Number.NaN, this.changed.dispatch();
  }
  get legacyJsonView() {
    const e = this;
    return {
      changed: e.changed,
      toJSON() {
        return e.toJSON();
      },
      reset() {
        return e.reset();
      },
      restoreState(t) {
        e.legacyValue = yn(t);
      }
    };
  }
  setPhysicalScale(e, t) {
    const n = this.curCanonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;
    this.value = e * (t / n);
  }
  assign(e) {
    const t = e.legacyValue;
    er(t) ? this.setPhysicalScale(e.value, e.canonicalVoxelPhysicalSize) : this.legacyValue = t;
  }
};
var q3 = class extends qD {
  getDefaultValue() {
    const e = this.legacyValue_;
    if (er(e))
      return 1;
    const t = this.canonicalVoxelPhysicalSize;
    return this.legacyValue_ * 1e-9 / t;
  }
};
var j3 = class extends qD {
  getDefaultValue() {
    const e = this.legacyValue_;
    if (!er(e)) {
      this.legacyValue_ = Number.NaN;
      const u = this.canonicalVoxelPhysicalSize;
      return 2 * 100 * Math.tan(Math.PI / 8) * 1e-9 * e / u;
    }
    var t = this.coordinateSpaceValue.bounds;
    const n = t.lowerBounds, r = t.upperBounds;
    var s = this.displayDimensionRenderInfo.value;
    const a = s.canonicalVoxelFactors, l = s.displayDimensionIndices;
    let d = a.reduce((u, h, g) => {
      const v = l[g], y = (r[v] - n[v]) * h;
      return Math.max(u, y);
    }, 0);
    return Lt(d) ? d = 2 ** Math.ceil(Zn(d)) : d = 1024, d;
  }
};
var Xm = class extends X {
  constructor(e, t) {
    super(), this.defaultValue = e, this.displayDimensionRenderInfo = t, this.changed = new Le(), this.value_ = e, this.canonicalVoxelPhysicalSize = t.value.canonicalVoxelPhysicalSize, this.registerDisposer(t.changed.add(() => {
      this.value;
    }));
  }
  get value() {
    let e = this.value_;
    if (e > 0) {
      const t = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize, n = this.canonicalVoxelPhysicalSize;
      t !== n && (this.canonicalVoxelPhysicalSize = t, e = this.value_ = e = n / t, this.changed.dispatch());
    }
    return e;
  }
  set value(e) {
    if (e === this.value) return;
    this.value_ = e;
    const t = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
    this.canonicalVoxelPhysicalSize = t, this.changed.dispatch();
  }
  toJSON() {
    const e = this.value;
    if (e !== this.defaultValue)
      return e;
  }
  reset() {
    this.value = this.defaultValue;
  }
  restoreState(e) {
    typeof e != "number" || !Lt(e) || e === 0 ? this.value = this.defaultValue : this.value = e;
  }
  setValueAbsolute(e, t) {
    if (e > 0) {
      const n = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
      e = e * (t / n);
    }
    this.value = e;
  }
  assign(e) {
    this.setValueAbsolute(e.value, e.canonicalVoxelPhysicalSize);
  }
};
var g1 = class extends zD {
  constructor(e, t) {
    super(e), this.value = FD(new Xm(e.defaultValue, t), this.peer, this.link, {
      assign: (n, r) => n.assign(r),
      isValid: () => true
    });
  }
};
var Lo = class extends X {
  constructor(e, t, n) {
    super(), this.pose = e, this.zoomFactor = t, this.depthRange = n, this.changed = new Le(), this.registerDisposer(e), this.registerDisposer(t), this.registerDisposer(n), this.registerDisposer(this.pose.changed.add(this.changed.dispatch)), this.registerDisposer(this.zoomFactor.changed.add(this.changed.dispatch)), this.registerDisposer(this.depthRange.changed.add(this.changed.dispatch));
  }
  get coordinateSpace() {
    return this.pose.position.coordinateSpace;
  }
  /**
   * Resets everything.
   */
  reset() {
    this.pose.reset(), this.zoomFactor.reset();
  }
  get position() {
    return this.pose.position;
  }
  get displayDimensions() {
    return this.pose.displayDimensions;
  }
  get relativeDisplayScales() {
    return this.pose.relativeDisplayScales;
  }
  get displayDimensionRenderInfo() {
    return this.pose.displayDimensionRenderInfo;
  }
  toMat4(e) {
    this.pose.toMat4(e, this.zoomFactor.value);
  }
  toMat3(e) {
    this.pose.toMat3(e, this.zoomFactor.value);
  }
  get relativeDepthRange() {
    let e = this.depthRange.value;
    return e > 0 ? e /= this.zoomFactor.value : e *= -1, e;
  }
  get valid() {
    return this.pose.valid && !er(this.zoomFactor.value);
  }
  zoomBy(e) {
    this.zoomFactor.value *= e;
  }
};
var J3 = "mesh/MeshLayer";
var K3 = "mesh/MultiscaleMeshLayer";
var Y3 = "mesh/FragmentSource";
var X3 = "mesh/MultiscaleFragmentSource";
var Nr;
(function(i) {
  i[i.float32 = 0] = "float32", i[i.uint10 = 1] = "uint10", i[i.uint16 = 2] = "uint16";
})(Nr || (Nr = {}));
function Z3(i, e, t) {
  return i & 1 | e << 1 & 2 | t << 2 & 4;
}
function Q3(i, e, t, n, r, s, a) {
  const l = i.octree, d = i.lodScales, u = i.chunkGridSpatialOrigin, h = i.chunkShape, g = d.length - 1, v = e[0], y = e[4], C = e[8], w = e[1], b = e[5], E = e[9], T = e[3], I = e[7], R = e[11], P = e[15], L = T > 0 ? 0 : 1, A = I > 0 ? 0 : 1, M = R > 0 ? 0 : 1, O = t[4 * 4], F = t[4 * 4 + 1], q = t[4 * 4 + 2], U = t[4 * 4 + 3];
  function V(Re, Ve, qe) {
    return T * Re + I * Ve + R * qe + P;
  }
  function $(Re, Ve, qe, We, De, et) {
    return V(Re + L * (We - Re), Ve + A * (De - Ve), qe + M * (et - qe));
  }
  const B = V(-U * O, -U * F, -U * q), ue = i.clipLowerBound[0], se = i.clipLowerBound[1], Pe = i.clipLowerBound[2], ae = i.clipUpperBound[0], Ee = i.clipUpperBound[1], ce = i.clipUpperBound[2], ge = Math.sqrt((v * r) ** 2 + (w * s) ** 2), Ne = Math.sqrt((y * r) ** 2 + (b * s) ** 2), Me = Math.sqrt((C * r) ** 2 + (E * s) ** 2), je = Math.max(ge, Ne, Me);
  function Oe(Re, Ve, qe) {
    const We = 1 << Re, De = Ve * 5, et = l[De], $t = l[De + 1], At = l[De + 2], Z = l[De + 3], ne = l[De + 4];
    let te = et * We * h[0] + u[0], ve = $t * We * h[1] + u[1], ke = At * We * h[2] + u[2], ye = te + We * h[0], Je = ve + We * h[1], it = ke + We * h[2];
    if (te = Math.max(te, ue), ve = Math.max(ve, se), ke = Math.max(ke, Pe), ye = Math.min(ye, ae), Je = Math.min(Je, Ee), it = Math.min(it, ce), PT(te, ve, ke, ye, Je, it, t)) {
      const gt = Math.max(B, $(te, ve, ke, ye, Je, it)) / je;
      if (qe === 0 || gt * n < qe) {
        const ot = d[Re];
        if (ot !== 0 && a(Re, Ve, ot / gt, ne >>> 31), Re > 0 && (ot === 0 || gt * n < ot)) {
          const Gt = ot === 0 ? qe : ot, mt = (ne & 2147483647) >>> 0;
          for (let It = Z; It < mt; ++It)
            Oe(Re - 1, It, Gt);
        }
      }
    }
  }
  Oe(g, l.length / 5 - 1, 0);
}
function m1(i, e, t, n, r, s, a, l) {
  const d = i.lodScales;
  let u = 0;
  for (; u + 1 < d.length && d[u + 1] !== 0; )
    ++u;
  const h = 3, g = [];
  let v = 0, y = 0;
  function C(E, T) {
    for (; ; ) {
      if (v === 0) return;
      const I = v - 1, R = u - I, P = g[I * h], L = R === 0 ? 1 : 8, A = g[I * h + 1], M = g[I * h + 2];
      if (E === v) {
        const O = T & L - 1;
        y !== O && P !== -1 && l(R, P, y, O, M), y = O + 1;
        return;
      }
      y !== L && P !== -1 && l(R, P, y, L, M), y = A + 1, --v;
    }
  }
  let w = 0;
  const b = i.octree;
  Q3(i, e, t, n, r, s, (E, T, I, R) => {
    if (!R && !a(E, T, I)) {
      w = Math.max(E, w);
      return;
    }
    if (E < w)
      return;
    w = 0;
    const P = T * 5, L = b[P], A = b[P + 1], M = b[P + 2], O = Z3(L, A, M), F = u - E;
    C(F, O);
    const q = F * h;
    g[q] = R ? -1 : T, g[q + 1] = O, g[q + 2] = I, y = 0, v = F + 1;
  }), C(0, 0);
}
function jD(i, e, t) {
  return `${i}/${e}:${t}`;
}
var Ho = class extends HL {
  draw(e, t) {
  }
  isReady(e, t) {
    return true;
  }
  get transparentPickEnabled() {
    return true;
  }
};
var eU = 3432918353;
var tU = 461845907;
function Eu(i, e) {
  return e >>>= 0, i >>>= 0, e = tr(e, eU) >>> 0, e = (e << 15 | e >>> 17) >>> 0, e = tr(e, tU) >>> 0, i = (i ^ e) >>> 0, i = (i << 13 | i >>> 19) >>> 0, i = i * 5 + 3864292196 >>> 0, i;
}
var Og;
var v1;
function nU() {
  return v1 || (v1 = 1, WUn(), Og = mR().Symbol.for), Og;
}
var Vg;
var y1;
function iU() {
  return y1 || (y1 = 1, Vg = { default: nU(), __esModule: true }), Vg;
}
var rU = iU();
var sU = Ws(rU);
var Zm = 3;
var aU = 0.8;
var kr = 0;
var Tr = 0;
var S1 = 0;
var b1 = 0;
var hc = class _hc {
  constructor(e = _hc.generateHashSeeds(Zm)) {
    this.hashSeeds = e, this.loadFactor = aU, this.size = 0, this.emptyLow = 4294967295, this.emptyHigh = 4294967295, this.maxRehashAttempts = 5, this.maxAttempts = 5, this.generation = 0, this.mungedEmptyKey = -1;
    let t = 8;
    for (; t < 2 * e.length; )
      t *= 2;
    this.allocate(t);
  }
  updateHashFunctions(e) {
    this.hashSeeds = _hc.generateHashSeeds(e), this.mungedEmptyKey = -1;
  }
  /**
   * Invokes callback with a modified version of the hash table data array.
   *
   * Replaces all slots that appear to be valid entries for (emptyLow, emptyHigh), i.e. slots that
   * contain (emptyLow, emptyHigh) and to which (emptyLow, emptyHigh) hashes, with (mungedEmptyKey,
   * mungedEmptyKey).
   *
   * mungedEmptyKey is chosen to be a 32-bit value with the property that the 64-bit value
   * (mungedEmptyKey, mungedEmptyKey) does not hash to any of the same slots as (emptyLow,
   * emptyHigh).
   *
   * This allows the modified data array to be used for lookups without special casing the empty
   * key.
   */
  tableWithMungedEmptyKey(e) {
    const t = this.hashSeeds.length, n = new Array(t);
    for (let d = 0; d < t; ++d)
      n[d] = this.getHash(d, this.emptyLow, this.emptyHigh);
    let r = this.mungedEmptyKey;
    if (r === -1)
      e: for (; ; ) {
        r = Math.random() * 16777216 >>> 0;
        for (let d = 0; d < t; ++d) {
          let u = this.getHash(d, r, r);
          for (let h = 0; h < t; ++h)
            if (n[h] === u)
              continue e;
        }
        this.mungedEmptyKey = r;
        break;
      }
    let s = this.table, a = this.emptyLow, l = this.emptyHigh;
    for (let d = 0; d < t; ++d) {
      let u = n[d];
      s[u] === a && s[u + 1] === l && (s[u] = r, s[u + 1] = r);
    }
    try {
      e(s);
    } finally {
      for (let d = 0; d < t; ++d) {
        let u = n[d];
        s[u] === r && s[u + 1] === r && (s[u] = a, s[u + 1] = l);
      }
    }
  }
  static generateHashSeeds(e = Zm) {
    return wO(new Uint32Array(e));
  }
  getHash(e, t, n) {
    let r = this.hashSeeds[e];
    return r = Eu(r, t), r = Eu(r, n), this.entryStride * (r & this.tableSize - 1);
  }
  /**
   * Iterates over the Uint64 keys contained in the hash set.
   *
   * Creates a new Uint64 object at every iteration (otherwise spread and Array.from() fail)
   */
  *keys() {
    let e = this.emptyLow, t = this.emptyHigh, n = this.entryStride, r = this.table;
    for (let s = 0, a = r.length; s < a; s += n) {
      let l = r[s], d = r[s + 1];
      (l !== e || d !== t) && (yield new re(l, d));
    }
  }
  /**
   * Iterates over the Uint64 keys contained in the hash set.
   *
   * The same temp value will be modified and yielded at every iteration.
   */
  *unsafeKeys(e = new re()) {
    let t = this.emptyLow, n = this.emptyHigh, r = this.entryStride, s = this.table;
    for (let a = 0, l = s.length; a < l; a += r) {
      let d = s[a], u = s[a + 1];
      (d !== t || u !== n) && (e.low = d, e.high = u, yield e);
    }
  }
  indexOfPair(e, t) {
    let n = this.table, r = this.emptyLow, s = this.emptyHigh;
    if (e === r && t === s)
      return -1;
    for (let a = 0, l = this.hashSeeds.length; a < l; ++a) {
      let d = this.getHash(a, e, t);
      if (n[d] === e && n[d + 1] === t)
        return d;
    }
    return -1;
  }
  /**
   * Returns the offset into the hash table of the specified element, or -1 if the element is not
   * present.
   */
  indexOf(e) {
    return this.indexOfPair(e.low, e.high);
  }
  /**
   * Changes the empty key to a value that is not equal to the current empty key and is not present
   * in the table.
   *
   * This is called when an attempt is made to insert the empty key.
   */
  chooseAnotherEmptyKey() {
    let e = this.emptyLow, t = this.emptyHigh, n = this.table, r = this.entryStride, s, a;
    for (; s = Math.random() * 4294967296 >>> 0, a = Math.random() * 4294967296 >>> 0, !(!(s === e && a === t) && !this.hasPair(s, a)); )
      ;
    this.emptyLow = s, this.emptyHigh = a;
    for (let l = 0, d = n.length; l < d; l += r)
      n[l] === e && n[l + 1] === t && (n[l] = s, n[l + 1] = a);
  }
  /**
   * Returns true iff the specified element is present.
   */
  has(e) {
    return this.indexOf(e) !== -1;
  }
  /**
   * Returns true iff the specified element is present.
   */
  hasPair(e, t) {
    return this.indexOfPair(e, t) !== -1;
  }
  delete(e) {
    let t = this.indexOf(e);
    if (t !== -1) {
      let n = this.table;
      return n[t] = this.emptyLow, n[t + 1] = this.emptyHigh, ++this.generation, this.size--, true;
    }
    return false;
  }
  clearTable() {
    let e = this.table, t = this.entryStride, n = this.emptyLow, r = this.emptyHigh, s = e.length;
    for (let a = 0; a < s; a += t)
      e[a] = n, e[a + 1] = r;
  }
  clear() {
    return this.size === 0 ? false : (this.size = 0, ++this.generation, this.clearTable(), true);
  }
  reserve(e) {
    return e > this.capacity ? (this.backupPending(), this.grow(e), this.restorePending(), true) : false;
  }
  swapPending(e, t) {
    let n = kr, r = Tr;
    this.storePending(e, t), e[t] = n, e[t + 1] = r;
  }
  storePending(e, t) {
    kr = e[t], Tr = e[t + 1];
  }
  backupPending() {
    S1 = kr, b1 = Tr;
  }
  restorePending() {
    kr = S1, Tr = b1;
  }
  tryToInsert() {
    let e = 0, t = this.emptyLow, n = this.emptyHigh, r = this.maxAttempts, s = this.table, a = this.hashSeeds.length, l = Math.floor(Math.random() * a);
    for (; ; ) {
      let d = this.getHash(l, kr, Tr);
      if (this.swapPending(s, d), kr === t && Tr === n)
        return true;
      if (++e === r)
        break;
      l = (l + Math.floor(Math.random() * (a - 1)) + 1) % a;
    }
    return false;
  }
  allocate(e) {
    this.tableSize = e;
    let t = this.entryStride;
    this.table = new Uint32Array(e * t), this.maxAttempts = e, this.clearTable(), this.capacity = e * this.loadFactor, this.mungedEmptyKey = -1;
  }
  rehash(e, t) {
    this.allocate(t), this.updateHashFunctions(this.hashSeeds.length);
    let n = this.emptyLow, r = this.emptyHigh, s = this.entryStride;
    for (let a = 0, l = e.length; a < l; a += s) {
      let d = e[a], u = e[a + 1];
      if ((d !== n || u !== r) && (this.storePending(e, a), !this.tryToInsert()))
        return false;
    }
    return true;
  }
  grow(e) {
    let t = this.table, n = this.tableSize;
    for (; n < e; )
      n *= 2;
    for (; ; ) {
      for (let r = 0; r < this.maxRehashAttempts; ++r)
        if (this.rehash(t, n))
          return;
      n *= 2;
    }
  }
  insertInternal() {
    for (++this.generation, kr === this.emptyLow && Tr === this.emptyHigh && this.chooseAnotherEmptyKey(), ++this.size > this.capacity && (this.backupPending(), this.grow(this.tableSize * 2), this.restorePending()); !this.tryToInsert(); )
      this.backupPending(), this.grow(this.tableSize), this.restorePending();
  }
};
var JD = class extends hc {
  add(e) {
    let t = e.low, n = e.high;
    return this.hasPair(t, n) ? false : (kr = t, Tr = n, this.insertInternal(), true);
  }
  /**
   * Iterates over the keys.
   * Creates a new Uint64 object at every iteration (otherwise spread and Array.from() fail)
   */
  [qn]() {
    return this.unsafeKeys();
  }
};
JD.prototype.entryStride = 2;
var Nl = 0;
var Ol = 0;
var w1 = 0;
var C1 = 0;
var Qy = class extends hc {
  set(e, t) {
    let n = e.low, r = e.high;
    return this.hasPair(n, r) ? false : (kr = n, Tr = r, Nl = t.low, Ol = t.high, this.insertInternal(), true);
  }
  get(e, t) {
    let n = this.indexOf(e);
    if (n === -1)
      return false;
    let r = this.table;
    return t.low = r[n + 2], t.high = r[n + 3], true;
  }
  swapPending(e, t) {
    let n = Nl, r = Ol;
    super.swapPending(e, t), e[t + 2] = n, e[t + 3] = r;
  }
  storePending(e, t) {
    super.storePending(e, t), Nl = e[t + 2], Ol = e[t + 3];
  }
  backupPending() {
    super.backupPending(), w1 = Nl, C1 = Ol;
  }
  restorePending() {
    super.restorePending(), Nl = w1, Ol = C1;
  }
  /**
   * Iterates over entries.  The same temporary value will be modified and yielded at every
   * iteration.
   */
  [qn]() {
    return this.unsafeEntries();
  }
  /**
   * Iterates over entries.
   * Creates new Uint64 objects at every iteration (otherwise spread and Array.from() fail)
   */
  *entries() {
    let e = this.emptyLow, t = this.emptyHigh, n = this.entryStride, r = this.table;
    for (let s = 0, a = r.length; s < a; s += n) {
      let l = r[s], d = r[s + 1];
      if (l !== e || d !== t) {
        let u = new re(l, d), h = new re(r[s + 2], r[s + 3]);
        yield [u, h];
      }
    }
  }
  /**
   * Iterates over entries.  The same temporary value will be modified and yielded at every
   * iteration.
   */
  *unsafeEntries(e = [new re(), new re()]) {
    let t = this.emptyLow, n = this.emptyHigh, r = this.entryStride, s = this.table;
    var a = de(e, 2);
    let l = a[0], d = a[1];
    for (let u = 0, h = s.length; u < h; u += r) {
      let g = s[u], v = s[u + 1];
      (g !== t || v !== n) && (l.low = g, l.high = v, d.low = s[u + 2], d.high = s[u + 3], yield e);
    }
  }
};
Qy.prototype.entryStride = 4;
var kh = class {
};
var Hs = [-1, WebGL2RenderingContext.RED_INTEGER, WebGL2RenderingContext.RG_INTEGER, WebGL2RenderingContext.RGB_INTEGER, WebGL2RenderingContext.RGBA_INTEGER];
var oU = [-1, WebGL2RenderingContext.RED, WebGL2RenderingContext.RG, WebGL2RenderingContext.RGB, WebGL2RenderingContext.RGBA];
var _d = ["", "r", "rg", "rgb", "rgba"];
var lU = [-1, WebGL2RenderingContext.R8UI, WebGL2RenderingContext.RG8UI, WebGL2RenderingContext.RGB8UI, WebGL2RenderingContext.RGBA8UI];
var cU = [-1, WebGL2RenderingContext.R8I, WebGL2RenderingContext.RG8I, WebGL2RenderingContext.RGB8I, WebGL2RenderingContext.RGBA8I];
var dU = [-1, WebGL2RenderingContext.R16UI, WebGL2RenderingContext.RG16UI, WebGL2RenderingContext.RGB16UI, WebGL2RenderingContext.RGBA16UI];
var uU = [-1, WebGL2RenderingContext.R16I, WebGL2RenderingContext.RG16I, WebGL2RenderingContext.RGB16I, WebGL2RenderingContext.RGBA16I];
var x1 = [-1, WebGL2RenderingContext.R32UI, WebGL2RenderingContext.RG32UI, WebGL2RenderingContext.RGB32UI, WebGL2RenderingContext.RGBA32UI];
var hU = [-1, WebGL2RenderingContext.R32I, WebGL2RenderingContext.RG32I, WebGL2RenderingContext.RGB32I, WebGL2RenderingContext.RGBA32I];
var fU = [-1, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RG32F, WebGL2RenderingContext.RGB32F, WebGL2RenderingContext.RGBA32F];
function eS(i) {
  return i === j.FLOAT32 ? "" : VT[i] ? "i" : "u";
}
function Oc(i, e, t = 1) {
  switch (e) {
    case j.UINT8:
      if (t < 1 || t > 4)
        break;
      return i.texelsPerElement = 1, i.textureInternalFormat = lU[t], i.textureFormat = Hs[t], i.texelType = WebGL2RenderingContext.UNSIGNED_BYTE, i.arrayElementsPerTexel = t, i.arrayConstructor = Uint8Array, i.samplerPrefix = "u", i;
    case j.INT8:
      if (t < 1 || t > 4)
        break;
      return i.texelsPerElement = 1, i.textureInternalFormat = cU[t], i.textureFormat = Hs[t], i.texelType = WebGL2RenderingContext.BYTE, i.arrayElementsPerTexel = t, i.arrayConstructor = Int8Array, i.samplerPrefix = "i", i;
    case j.UINT16:
      if (t < 1 || t > 4)
        break;
      return i.texelsPerElement = 1, i.textureInternalFormat = dU[t], i.textureFormat = Hs[t], i.texelType = WebGL2RenderingContext.UNSIGNED_SHORT, i.arrayElementsPerTexel = t, i.arrayConstructor = Uint16Array, i.samplerPrefix = "u", i;
    case j.INT16:
      if (t < 1 || t > 4)
        break;
      return i.texelsPerElement = 1, i.textureInternalFormat = uU[t], i.textureFormat = Hs[t], i.texelType = WebGL2RenderingContext.SHORT, i.arrayElementsPerTexel = t, i.arrayConstructor = Int16Array, i.samplerPrefix = "i", i;
    case j.UINT32:
      if (t < 1 || t > 4)
        break;
      return i.texelsPerElement = 1, i.textureInternalFormat = x1[t], i.textureFormat = Hs[t], i.texelType = WebGL2RenderingContext.UNSIGNED_INT, i.arrayElementsPerTexel = 1, i.arrayConstructor = Uint32Array, i.samplerPrefix = "u", i;
    case j.INT32:
      if (t < 1 || t > 4)
        break;
      return i.texelsPerElement = 1, i.textureInternalFormat = hU[t], i.textureFormat = Hs[t], i.texelType = WebGL2RenderingContext.INT, i.arrayElementsPerTexel = 1, i.arrayConstructor = Int32Array, i.samplerPrefix = "i", i;
    case j.UINT64:
      if (t < 1 || t > 2)
        break;
      return i.texelsPerElement = 1, i.textureInternalFormat = x1[t * 2], i.textureFormat = Hs[t * 2], i.texelType = WebGL2RenderingContext.UNSIGNED_INT, i.arrayElementsPerTexel = 2 * t, i.arrayConstructor = Uint32Array, i.samplerPrefix = "u", i;
    case j.FLOAT32:
      if (t < 1 || t > 4)
        break;
      return i.texelsPerElement = 1, i.textureInternalFormat = fU[t], i.textureFormat = oU[t], i.texelType = WebGL2RenderingContext.FLOAT, i.arrayElementsPerTexel = t, i.arrayConstructor = Float32Array, i.samplerPrefix = "", i;
  }
  throw new Error(`No supported texture format for ${j[e]}[${t}].`);
}
function tS(i, e, t) {
  const n = e.arrayConstructor, r = e.arrayElementsPerTexel, s = e.textureInternalFormat, a = e.textureFormat, l = e.texelsPerElement, d = i.maxTextureSize, u = t.length / r;
  if (u * l > d * d)
    throw new Error("Number of elements exceeds maximum texture size: " + l + " * " + u);
  const h = Math.ceil(u / d), g = Math.ceil(Zn(h)), v = (1 << g) * l, y = Math.ceil(u / (1 << g)), C = v * y * r;
  t.constructor !== n && (t = new n(t.buffer, t.byteOffset, t.byteLength / n.BYTES_PER_ELEMENT));
  let w = zM(t, C);
  i.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1), yo(i), i.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    /*level=*/
    0,
    s,
    /*width=*/
    v,
    /*height=*/
    y,
    /*border=*/
    0,
    a,
    e.texelType,
    w
  );
}
function pU(i, e, t, n, r) {
  const s = e.arrayConstructor, a = e.textureInternalFormat, l = e.textureFormat, d = e.texelsPerElement;
  t.constructor !== s && (t = new s(t.buffer, t.byteOffset, t.byteLength / s.BYTES_PER_ELEMENT)), i.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1), yo(i), i.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    /*level=*/
    0,
    a,
    /*width=*/
    n * d,
    /*height=*/
    r,
    /*border=*/
    0,
    l,
    e.texelType,
    t
  );
}
function gU(i, e, t, n, r, s) {
  const a = e.arrayConstructor, l = e.textureInternalFormat, d = e.textureFormat, u = e.texelsPerElement;
  t.constructor !== a && (t = new a(t.buffer, t.byteOffset, t.byteLength / a.BYTES_PER_ELEMENT)), i.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1), yB(i), i.texImage3D(
    WebGL2RenderingContext.TEXTURE_3D,
    /*level=*/
    0,
    l,
    /*width=*/
    n * u,
    /*height=*/
    r,
    /*depth=*/
    s,
    /*border=*/
    0,
    d,
    e.texelType,
    t
  );
}
function mU(i) {
  switch (i) {
    case j.UINT8:
      return QL;
    case j.INT8:
      return eD;
    case j.UINT16:
      return tD;
    case j.INT16:
      return nD;
    case j.UINT32:
      return Oy;
    case j.INT32:
      return iD;
    case j.UINT64:
      return jt;
    case j.FLOAT32:
      return Ny;
  }
}
function KD(i, e, t, n, r, s) {
  const a = xn(r, s);
  let l = [mU(r)], d = `
${a} ${i}(${n} index) {
`;
  switch (r) {
    case j.UINT8:
    case j.UINT16:
    case j.UINT32:
      d += `
  ${a} result;
  highp uvec4 temp;
  ${e}(${t}, index, temp);
  result.value = temp.${_d[s]};
  return result;
`;
      break;
    case j.INT8:
    case j.INT16:
    case j.INT32:
      d += `
  ${a} result;
  highp ivec4 temp;
  ${e}(${t}, index, temp);
  result.value = temp.${_d[s]};
  return result;
`;
      break;
    case j.UINT64:
      l.push(PB), d += `
  highp uvec4 temp;
  ${e}(${t}, index, temp);
  return unpackUint64leFromUint32(temp.${_d[s * 2]});
`;
      break;
    case j.FLOAT32:
      l.push(Ny), d += `
  highp vec4 temp;
  ${e}(${t}, index, temp);
  return temp.${_d[s]};
`;
      break;
  }
  return d += `
}
`, l.push(d), l;
}
var nS = class {
  constructor(e) {
    this.key = e, this.readTextureValue = `readTextureValue_${this.key}`;
  }
  defineShader(e) {
  }
  getReadTextureValueCode(e, t) {
    let n = `
void ${this.readTextureValue}(highp ${t}sampler2D sampler, highp uint index`;
    for (let r = 0; r < e; ++r)
      n += `, out ${t}vec4 output${r}`;
    n += `) {
  highp int width = textureSize(sampler, 0).x / ${e};
  highp uint log2width = log2Exact(uint(width));
  highp int y = int(index >> log2width);
  highp int x = int((index - (uint(y) << log2width)) * ${e}u);
`;
    for (let r = 0; r < e; ++r)
      n += `
  output${r} = texelFetch(sampler, ivec2(x + ${r}, y), 0);
`;
    return n += `
}
`, [OB, n];
  }
  getAccessor(e, t, n, r = 1) {
    const s = eS(n);
    return [this.getReadTextureValueCode(1, s), ...KD(e, this.readTextureValue, t, "highp uint", n, r)];
  }
};
var vU = class {
  constructor(e, t) {
    this.key = e, this.textureDims = t, this.readTextureValue = `readTextureValue_${this.key}`;
  }
  getReadTextureValueCode(e, t) {
    const n = this.textureDims;
    let r = `
void ${this.readTextureValue}(highp ${t}sampler${this.textureDims}D sampler, highp ivec${n} p`;
    for (let s = 0; s < e; ++s)
      r += `, out ${t}vec4 output${s}`;
    r += `) {
`;
    for (let s = 0; s < e; ++s)
      r += `
  output${s} = texelFetch(sampler, ivec${n}(p.x * ${e} + ${s}, p.y
                                         ${n === 3 ? ", p.z" : ""}), 0);
`;
    return r += `
}
`, r;
  }
  getAccessor(e, t, n, r = 1) {
    const s = eS(n);
    return [this.getReadTextureValueCode(1, s), ...KD(e, this.readTextureValue, t, `highp ivec${this.textureDims}`, n, r)];
  }
};
var YD = [jt, `
highp uint hashCombine(highp uint state, highp uint value) {
  value *= 0xcc9e2d51u;
  value = (value << 15u) | (value >> 17u);
  value *= 0x1b873593u;
  state ^= value;
  state = (state << 13u) | (state >> 19u);
  state = (state * 5u) + 0xe6546b64u;
  return state;
}
highp uint hashCombine(highp uint state, uint64_t x) {
  state = hashCombine(state, x.value[0]);
  return hashCombine(state, x.value[1]);
}
`];
var yU = Oc(new kh(), j.UINT64, 1);
var Vl = class extends X {
  constructor(e, t) {
    super(), this.gl = e, this.hashTable = t, this.generation = -1, this.texture = null, this.texture = e.createTexture();
  }
  copyToGPU() {
    let e = this.hashTable, t = e.generation;
    if (this.generation === t)
      return;
    const n = this.gl, r = this.texture;
    this.generation = t, n.activeTexture(WebGL2RenderingContext.TEXTURE0 + n.tempTextureUnit), n.bindTexture(WebGL2RenderingContext.TEXTURE_2D, r), e.tableWithMungedEmptyKey((s) => {
      tS(this.gl, yU, s);
    }), n.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
  }
  disposed() {
    this.gl.deleteTexture(this.texture), this.texture = null, this.gl = void 0, this.hashTable = void 0, super.disposed();
  }
  static get(e, t) {
    return e.memoize.get(t, () => new this(e, t));
  }
};
var XD = class {
  constructor(e, t = Zm) {
    this.prefix = e, this.numAlternatives = t, this.textureUnitSymbol = sU(`gpuhashtable:${this.prefix}`), this.accessHelper = new nS(`gpuhashtable_${this.prefix}`), this.samplerName = this.prefix + "_sampler", this.hashSeedsName = this.prefix + "_seeds", this.hashKeyMask = this.prefix + "_keyMask", this.readTable = this.prefix + "_readTable";
  }
  defineShader(e) {
    let t = this.hashSeedsName, n = this.samplerName, r = this.numAlternatives, s = this.hashKeyMask;
    e.addUniform("highp uint", t, r), e.addUniform("highp uint", s), e.addTextureSampler("usampler2D", n, this.textureUnitSymbol), e.addFragmentCode(YD), e.addFragmentCode(jt), e.addFragmentCode(YL), this.accessHelper.defineShader(e), e.addFragmentCode(this.accessHelper.getAccessor(this.readTable, this.samplerName, j.UINT64, 1));
    let a = "";
    a += `
bool ${this.hasFunctionName}(uint64_t x) {
`;
    for (let l = 0; l < r; ++l)
      a += `
  {
    uint h = hashCombine(${t}[${l}], x) & ${s};
    uint64_t key = ${this.readTable}(h);
    if (equals(key, x)) {
      return true;
    }
  }
`;
    a += `
  return false;
}
`, e.addFragmentCode(a);
  }
  get hasFunctionName() {
    return `${this.prefix}_has`;
  }
  enable(e, t, n) {
    n.copyToGPU();
    const r = t.textureUnit(this.textureUnitSymbol);
    e.activeTexture(WebGL2RenderingContext.TEXTURE0 + r), e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, n.texture), e.uniform1ui(t.uniform(this.hashKeyMask), n.hashTable.tableSize - 1), e.uniform1uiv(t.uniform(this.hashSeedsName), n.hashTable.hashSeeds);
  }
  disable(e, t) {
    const n = t.textureUnit(this.textureUnitSymbol);
    e.activeTexture(WebGL2RenderingContext.TEXTURE0 + n), e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
  }
};
var ZD = class extends XD {
  defineShader(e) {
    super.defineShader(e);
    let t = this.numAlternatives, n = this.hashSeedsName, r = this.hashKeyMask, s = `
bool ${this.getFunctionName}(uint64_t x, out uint64_t value) {
`;
    for (let a = 0; a < t; ++a)
      s += `
  {
    uint h = hashCombine(${n}[${a}], x) & ${r};
    uint64_t key = ${this.readTable}(h * 2u);
    if (equals(key, x)) {
      value = ${this.readTable}(h * 2u + 1u);
      return true;
    }
  }
`;
    s += `
  return false;
}
`, e.addFragmentCode(s);
  }
  get getFunctionName() {
    return `${this.prefix}_get`;
  }
};
function ku(i, e, t, n) {
  e *= 6;
  let r = Math.floor(e), s = e - r, a = n * (1 - t), l = n * (1 - t * s), d = n * (1 - t * (1 - s));
  switch (r % 6) {
    case 0:
      i[0] = n, i[1] = d, i[2] = a;
      break;
    case 1:
      i[0] = l, i[1] = n, i[2] = a;
      break;
    case 2:
      i[0] = a, i[1] = n, i[2] = d;
      break;
    case 3:
      i[0] = a, i[1] = l, i[2] = n;
      break;
    case 4:
      i[0] = d, i[1] = a, i[2] = n;
      break;
    case 5:
      i[0] = n, i[1] = a, i[2] = l;
      break;
  }
  return i;
}
function SU(i, e, t, n) {
  const r = Math.max(Math.max(e, t), n), s = Math.min(Math.min(e, t), n);
  if (i[2] = r, s === r)
    i[0] = 0, i[1] = 0;
  else {
    const a = r - s;
    i[1] = a / r, e === r ? i[0] = (t - n) / a : t === r ? i[0] = 2 + (n - e) / a : i[0] = 4 + (e - t) / a, i[0] /= 6, i[0] < 0 && (i[0] += 1), i[0] > 1 && (i[0] -= 1);
  }
  return i;
}
var E1 = 2;
var bU = class {
  constructor(e) {
    this.prefix = e, this.seedName = this.prefix + "_seed";
  }
  defineShader(e) {
    const t = this.seedName;
    e.addUniform("highp uint", t), e.addFragmentCode(jt), e.addFragmentCode(YD), e.addFragmentCode(IB);
    let n = `
vec3 ${this.prefix}(uint64_t x) {
  uint h = hashCombine(${t}, x);
  vec${E1} v;
`;
    for (let r = 0; r < E1; ++r)
      n += `
  v[${r}] = float(h & 0xFFu) / 255.0;
  h >>= 8u;
`;
    n += `
  vec3 hsv = vec3(v.x, 0.5 + v.y * 0.5, 1.0);
  return hsvToRgb(hsv);
}
`, e.addFragmentCode(n);
  }
  enable(e, t, n) {
    e.uniform1ui(t.uniform(this.seedName), n);
  }
};
var k1 = new Float32Array(3);
function QD(i) {
  return `rgb(${i[0] * 100}%,${i[1] * 100}%,${i[2] * 100}%)`;
}
var iS = class _iS {
  constructor(e = BC()) {
    this.hashSeed = e, this.changed = new Le();
  }
  static getDefault() {
    return new _iS(0);
  }
  get value() {
    return this.hashSeed;
  }
  set value(e) {
    e !== this.hashSeed && (this.hashSeed = e, this.changed.dispatch());
  }
  compute(e, t) {
    let n = Eu(this.hashSeed, t.low);
    n = Eu(n, t.high);
    const r = (n & 255) / 255, s = (n >> 8 & 255) / 255;
    return ku(e, r, 0.5 + 0.5 * s, 1), e;
  }
  computeCssColor(e) {
    return this.compute(k1, e), QD(k1);
  }
  randomize() {
    this.hashSeed = BC(), this.changed.dispatch();
  }
  toString() {
    return `new SegmentColorHash(${this.hashSeed})`;
  }
  toJSON() {
    return this.hashSeed === 0 ? void 0 : this.hashSeed;
  }
  reset() {
    this.restoreState(0);
  }
  restoreState(e) {
    const t = e >>> 0;
    t !== this.hashSeed && (this.hashSeed = t, this.changed.dispatch());
  }
};
var wU = class {
  constructor(e) {
    this.prefix = e, this.hashMapShaderManager = new ZD("segmentStatedColorHash");
  }
  defineShader(e) {
    this.hashMapShaderManager.defineShader(e);
    let t = `
bool ${this.getFunctionName}(uint64_t x, out vec3 value) {
  uint64_t uint64Value;
  if (${this.hashMapShaderManager.getFunctionName}(x, uint64Value)) {
    uint uintValue = uint64Value.value[0];
    value.r = float((uintValue & 0x0000ffu))       / 255.0;
    value.g = float((uintValue & 0x00ff00u) >>  8) / 255.0;
    value.b = float((uintValue & 0xff0000u) >> 16) / 255.0;
    return true;
  }
  return false;
}
`;
    e.addFragmentCode(t);
  }
  get getFunctionName() {
    return `${this.prefix}_get`;
  }
  enable(e, t, n) {
    this.hashMapShaderManager.enable(e, t, n);
  }
  disable(e, t) {
    this.hashMapShaderManager.disable(e, t);
  }
};
var eI = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='arrowLeftIconTitle'%3e%3ctitle%20id='arrowLeftIconTitle'%3eArrow%20Left%3c/title%3e%3cpath%20d='M9%206l-6%206%206%206'/%3e%3cpath%20d='M21%2012H4'/%3e%3cpath%20stroke-linecap='round'%20d='M3%2012h1'/%3e%3c/svg%3e";
var tI = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='arrowRightIconTitle'%3e%3ctitle%20id='arrowRightIconTitle'%3eArrow%20Right%3c/title%3e%3cpath%20d='M15%2018l6-6-6-6'/%3e%3cpath%20d='M3%2012h17'/%3e%3cpath%20stroke-linecap='round'%20d='M21%2012h-1'/%3e%3c/svg%3e";
var CU = class {
  /**
   * If an existing HierarchicalMap is specified, a shallow copy is made.
   *
   * @param existing Existing map to make a shallow copy of.
   */
  constructor(e) {
    if (this.parents = new Array(), this.parentPriorities = new Array(), this.bindings = new he(), e !== void 0) {
      this.parents.push(...e.parents), this.parentPriorities.push(...e.parentPriorities);
      for (const n of e.bindings) {
        var t = de(n, 2);
        const r = t[0], s = t[1];
        this.bindings.set(r, s);
      }
    }
  }
  /**
   * Register `parent` as a parent map.  If `priority > 0`, this map will take precedence over
   * direct bindings.
   *
   * @returns A nullary function that unregisters the parent (and may be called at most once).
   */
  addParent(e, t) {
    const n = this.parents, r = this.parentPriorities;
    let s = 0;
    const a = n.length;
    for (; s < a && t < r[s]; )
      ++s;
    return n.splice(s, 0, e), r.splice(s, 0, t), () => {
      this.removeParent(e);
    };
  }
  /**
   * Unregisters `parent` as a parent.
   */
  removeParent(e) {
    const t = this.parents.indexOf(e);
    if (t === -1)
      throw new Error("Attempt to remove non-existent parent map.");
    this.parents.splice(t, 1), this.parentPriorities.splice(t, 1);
  }
  /**
   * Register a direct binding.
   */
  set(e, t) {
    this.bindings.set(e, t);
  }
  /**
   * Unregister a direct binding.
   */
  delete(e) {
    this.bindings.delete(e);
  }
  /**
   * Deletes all bindings, including parents.
   */
  clear() {
    this.bindings.clear(), this.parents.length = 0, this.parentPriorities.length = 0;
  }
  /**
   * Lookup the highest priority value to which the specified key is mapped.
   */
  get(e) {
    const t = this.parents, n = this.parentPriorities, r = n.length;
    let s = 0, a;
    for (; s < r && n[s] > 0; ++s)
      if (a = t[s].get(e), a !== void 0)
        return a;
    if (a = this.bindings.get(e), a !== void 0)
      return a;
    for (; s < r; ++s)
      if (a = t[s].get(e), a !== void 0)
        return a;
  }
  /**
   * Find all values to which the specified key is mapped.
   */
  *getAll(e) {
    const t = this.parents, n = this.parentPriorities, r = n.length;
    let s = 0, a;
    for (; s < r && n[s] > 0; )
      a = t[s].get(e), a !== void 0 && (yield a);
    for (a = this.bindings.get(e), a !== void 0 && (yield a); s < r; )
      a = t[s].get(e), a !== void 0 && (yield a);
  }
  *entries() {
    const e = this.parents, t = this.parentPriorities, n = t.length;
    let r = 0;
    for (; r < n && t[r] > 0; ++r)
      yield* e[r].entries();
    for (yield* this.bindings.entries(); r < n; ++r)
      yield* e[r].entries();
  }
};
var T1;
(function(i) {
  i[i.CONTROL = 1] = "CONTROL", i[i.ALT = 2] = "ALT", i[i.META = 4] = "META", i[i.SHIFT = 8] = "SHIFT";
})(T1 || (T1 = {}));
function rS(i) {
  return (i.ctrlKey ? 1 : 0) | (i.altKey ? 2 : 0) | (i.metaKey ? 4 : 0) | (i.shiftKey ? 8 : 0);
}
function Qm(i, e) {
  let t = "";
  return e & 1 && (t += "control+"), e & 2 && (t += "alt+"), e & 4 && (t += "meta+"), e & 8 && (t += "shift+"), t += i, t;
}
function xU(i, e, t) {
  let n = "";
  return e & 1 && (n += "control+"), t & 1 && (n += "control?+"), e & 2 && (n += "alt+"), t & 2 && (n += "alt?+"), e & 4 && (n += "meta+"), t & 4 && (n += "meta?+"), e & 8 && (n += "shift+"), t & 8 && (n += "shift?+"), n += i, n;
}
function L1(i) {
  const e = i.indexOf(":");
  let t;
  if (e !== -1 && (t = i.substring(0, e), t !== "at" && t !== "bubble"))
    throw new Error(`Invalid event phase: ${oe(t)}`);
  const n = i.substring(e + 1).split("+");
  let r, s = 0, a = 0;
  e: for (let l of n)
    switch (l) {
      case "control":
        s |= 1;
        break;
      case "control?":
        a |= 1;
        break;
      case "alt":
        s |= 2;
        break;
      case "alt?":
        a |= 2;
        break;
      case "meta":
        s |= 4;
        break;
      case "meta?":
        a |= 4;
        break;
      case "shift":
        s |= 8;
        break;
      case "shift?":
        a |= 8;
        break;
      default:
        if (r === void 0)
          r = l;
        else {
          r = void 0;
          break e;
        }
    }
  if (r === void 0 || s & a)
    throw new Error(`Invalid event identifier: ${oe(i)}`);
  return { phase: t, keyName: r, modifiers: s, optionalModifiers: a };
}
function* EU(i, e, t) {
  t === 0 && (yield Qm(i, e));
  for (let n = 0; n < 16; ++n)
    (n & (e | t)) === n && (n & e) === e && (yield Qm(i, n));
}
function* D1(i) {
  const e = i.phase, t = EU(i.keyName, i.modifiers, i.optionalModifiers);
  if (e === void 0)
    for (const n of t)
      yield `at:${n}`, yield `bubble:${n}`;
  else
    for (const n of t)
      yield `${e}:${n}`;
}
function kU(i, e) {
  const t = xU(i.keyName, i.modifiers, i.optionalModifiers);
  return typeof e == "string" ? { action: e, originalEventIdentifier: t } : H(H({}, e), { originalEventIdentifier: t });
}
var St = class _St extends CU {
  /**
   * Returns a new EventActionMap with the specified bindings.
   *
   * The keys of the `bindings` object specify unnormalized event identifiers to be mapped to their
   * corresponding `ActionOrEventAction` values.
   */
  static fromObject(e, t = {}) {
    const n = new _St();
    if (n.label = t.label, t.parents !== void 0)
      for (const s of t.parents) {
        var r = de(s, 2);
        const a = r[0], l = r[1];
        n.addParent(a, l);
      }
    for (const s of hn(e))
      n.set(s, e[s]);
    return n;
  }
  setFromObject(e) {
    for (const t of hn(e))
      this.set(t, e[t]);
  }
  /**
   * Maps the specified event `identifier` to the specified `action`.
   *
   * The `identifier` may be unnormalized; the actual mapping is created for each corresponding
   * normalized identifier.
   */
  set(e, t) {
    const n = L1(e), r = kU(n, t);
    for (const s of D1(n))
      super.set(s, r);
  }
  /**
   * Deletes the mapping for the specified `identifier`.
   *
   * The `identifier` may be unnormalized; the mapping is deleted for each corresponding normalized
   * identifier.
   */
  delete(e) {
    for (const t of D1(L1(e)))
      super.delete(t);
  }
  describe() {
    const e = [], t = new he();
    for (const s of this.entries()) {
      var n = de(s, 2);
      const a = n[1];
      t.set(a.originalEventIdentifier, a.action);
    }
    for (const s of t) {
      var r = de(s, 2);
      const a = r[0], l = r[1];
      e.push(`${a}→${l}`);
    }
    return e.join(", ");
  }
};
function nI(i, e, t) {
  if (t === void 0)
    return;
  t.stopPropagation !== false && i.stopPropagation();
  const n = new CustomEvent("action:" + t.action, { bubbles: true, detail: e, cancelable: true }), r = !i.target.dispatchEvent(n);
  (t.preventDefault !== false || r) && i.preventDefault();
}
var Th = [];
Th[Event.AT_TARGET] = "at";
Th[Event.CAPTURING_PHASE] = "capture";
Th[Event.BUBBLING_PHASE] = "bubble";
function iI(i, e, t, n, r) {
  const s = Th[t] + ":" + i, a = r.get(s);
  nI(e, n, a);
}
function rI2(i, e, t, n) {
  iI(Qm(i, rS(e)), e, e.eventPhase, t, n);
}
function Ce(i, e, t, n) {
  return Oi(i, `action:${e}`, t, n);
}
var Bg;
function TU() {
  if (Bg === void 0) {
    const i = new St();
    i.set("keyl", "recolor"), i.set("keyx", "clear-segments"), i.set("keys", "toggle-show-slices"), i.set("keyb", "toggle-scale-bar"), i.set("keyv", "toggle-default-annotations"), i.set("keya", "toggle-axis-lines"), i.set("keyo", "toggle-orthographic-projection");
    for (let e = 1; e <= 9; ++e)
      i.set("digit" + e, "toggle-layer-" + e), i.set("control+digit" + e, "select-layer-" + e), i.set("alt+digit" + e, "toggle-pick-layer-" + e);
    for (let e = 0; e < 26; ++e) {
      const t = String.fromCharCode(97 + e), n = String.fromCharCode(65 + e);
      i.set(`alt?+control?+shift+key${t}`, `tool-${n}`);
    }
    i.set("keyn", "add-layer"), i.set("keyh", "help"), i.set("space", "toggle-layout"), i.set("shift+space", "toggle-layout-alternative"), i.set("backslash", "toggle-show-statistics"), Bg = i;
  }
  return Bg;
}
var Fg;
function Lh() {
  return Fg === void 0 && (Fg = St.fromObject({ "control+mousedown2": "select-position" })), Fg;
}
var Ug;
function LU() {
  return Ug === void 0 && (Ug = St.fromObject({
    click0: "pin-annotation",
    mousedown2: "move-to-annotation"
  }, { parents: [[Lh(), 0]] })), Ug;
}
var zg;
function sI() {
  return zg === void 0 && (zg = St.fromObject({
    arrowleft: "x-",
    arrowright: "x+",
    arrowup: "y-",
    arrowdown: "y+",
    comma: "z-",
    period: "z+",
    bracketleft: "t-",
    bracketright: "t+",
    keyz: "snap",
    "control+equal": "zoom-in",
    "alt+equal": "depth-range-decrease",
    "control+shift+equal": "zoom-in",
    "alt+shift+equal": "depth-range-decrease",
    "control+minus": "zoom-out",
    "alt+minus": "depth-range-increase",
    keyr: "rotate-relative-z-",
    keye: "rotate-relative-z+",
    "shift+arrowdown": "rotate-relative-x-",
    "shift+arrowup": "rotate-relative-x+",
    "shift+arrowleft": "rotate-relative-y-",
    "shift+arrowright": "rotate-relative-y+",
    "control+wheel": { action: "zoom-via-wheel", preventDefault: true },
    "alt+wheel": { action: "adjust-depth-range-via-wheel", preventDefault: true },
    "at:wheel": { action: "z+1-via-wheel", preventDefault: true },
    "at:shift+wheel": { action: "z+10-via-wheel", preventDefault: true },
    "at:alt+mousedown2": "copy-segment-id",
    "at:alt+shift+mousedown2": "add-copy-segment-id",
    "at:dblclick0": "select",
    "at:control+mousedown0": "annotate",
    "at:mousedown2": "move-to-mouse-position",
    "at:alt+mousedown0": "move-annotation",
    "at:control+alt+mousedown2": "delete-annotation",
    "at:touchpinch": "zoom-via-touchpinch",
    "at:touchrotate": "rotate-in-plane-via-touchrotate",
    "at:touchtranslate2": "translate-in-plane-via-touchtranslate",
    "at:touchhold1": "move-to-mouse-position",
    "at:touchtap1x2": "select",
    "at:touchtap2x3": "snap"
  }, {
    label: "All Data Panels",
    parents: [[Lh(), 0]]
  })), zg;
}
var $g;
function DU() {
  return $g === void 0 && ($g = St.fromObject({
    "at:mousedown0": { action: "rotate-via-mouse-drag", stopPropagation: true },
    "at:shift+mousedown0": { action: "translate-via-mouse-drag", stopPropagation: true },
    "at:touchtranslate1": "rotate-out-of-plane-via-touchtranslate"
  }, { parents: [[sI(), Number.NEGATIVE_INFINITY]] })), $g;
}
var Gg;
function IU() {
  return Gg === void 0 && (Gg = St.fromObject({
    "at:mousedown0": { action: "translate-via-mouse-drag", stopPropagation: true },
    "at:shift+mousedown0": { action: "rotate-via-mouse-drag", stopPropagation: true },
    "at:touchtranslate1": "translate-z-via-touchtranslate"
  }, { parents: [[sI(), Number.NEGATIVE_INFINITY]] })), Gg;
}
function PU(i) {
  i.global.addParent(TU(), Number.NEGATIVE_INFINITY), i.sliceView.addParent(IU(), Number.NEGATIVE_INFINITY), i.perspectiveView.addParent(DU(), Number.NEGATIVE_INFINITY);
}
function st(i) {
  for (; ; ) {
    let e = i.firstChild;
    if (!e)
      break;
    i.removeChild(e);
  }
}
function Ut(i) {
  let e = i.parentElement;
  return e ? (e.removeChild(i), true) : false;
}
function Xn(i, e = Math.max(1, i.value.length)) {
  const t = `${e}ch`;
  i.style.width !== t && (i.style.width = "0px", i.offsetWidth, i.style.width = t);
}
function rr(i, e) {
  let t = i.firstElementChild;
  for (const n of e)
    n !== t && i.insertBefore(n, t), t = n.nextElementSibling;
  for (; t !== null; ) {
    let n = t.nextElementSibling;
    i.removeChild(t), t = n;
  }
}
function sS(i) {
  return i instanceof HTMLElement ? !!(i instanceof HTMLInputElement || i instanceof HTMLTextAreaElement || i.isContentEditable) : false;
}
function RU(i) {
  const e = i.cloneNode(
    /*deep=*/
    true
  );
  return e.style.position = "absolute", document.body.appendChild(e), e.getBoundingClientRect();
}
var lo;
var Kl = [];
function AU() {
  if (lo === void 0) {
    const i = lo = document.createElement("div");
    i.classList.add("neuroglancer-drag-status"), document.body.appendChild(i);
  }
  return lo;
}
function _U() {
  lo !== void 0 && (st(lo), lo.style.display = "none");
}
function aI(i) {
  const e = AU();
  st(e), typeof i == "string" ? e.appendChild(document.createTextNode(i)) : e.appendChild(i()), e.style.display = "";
}
function oI(i, e) {
  cT(Kl, (t) => !(t.target === i && t.operation === e));
}
function sr(i, e, t) {
  oI(i, e), Kl.push({ target: i, operation: e, status: t }), aI(t);
}
function In(i, e) {
  oI(i, e);
  const t = Kl.length === 0 ? void 0 : Kl[Kl.length - 1];
  t === void 0 ? _U() : aI(t.status);
}
var MU = 300;
var NU = 100;
var ga = {
  side: "right",
  col: 0,
  row: 1 / 0,
  flex: 1,
  size: MU,
  minSize: NU,
  visible: false
};
var Is = class {
  constructor(e = ga, t = e) {
    this.defaultValue = e, this.value = t, this.changed = new ct(), this.locationChanged = new ct(), this.locationChanged.add(this.changed.dispatch);
    const n = this;
    this.watchableVisible = {
      get value() {
        return n.visible;
      },
      set value(r) {
        n.visible = r;
      },
      changed: n.locationChanged
    };
  }
  toJSON(e = this.defaultValue) {
    const t = {}, n = this.value;
    for (const r in n)
      n[r] !== e[r] && (t[r] = n[r]);
    return t;
  }
  get visible() {
    return this.value.visible;
  }
  set visible(e) {
    const t = this.value;
    t.visible !== e && (this.value = H(H({}, t), { visible: e }), this.locationChanged.dispatch());
  }
  reset() {
    this.value !== this.defaultValue && (this.value = this.defaultValue, this.locationChanged.dispatch());
  }
  restoreState(e, t = this.defaultValue) {
    if (e === void 0) return;
    me(e);
    const n = {
      side: xe(e, "side", (r) => {
        if (r !== "left" && r !== "right" && r !== "top" && r !== "bottom")
          throw new Error(`Expected "left", "right", "top", or "bottom", but received: ${oe(r)}`);
        return r;
      }, t.side),
      col: xe(e, "col", Dt, t.col),
      row: xe(e, "row", Dt, t.row),
      flex: xe(e, "flex", Dt, t.flex),
      size: xe(e, "size", un, t.size),
      visible: xe(e, "visible", na, t.visible),
      // minSize cannot be modified.
      minSize: t.minSize
    };
    this.value = n, this.locationChanged.dispatch();
  }
};
function Ui(i, e, t) {
  const n = i.view.document;
  let r = i.clientX, s = i.clientY;
  const a = (h) => {
    const g = h.clientX - r, v = h.clientY - s;
    r = h.clientX, s = h.clientY, e(h, g, v);
  }, l = i.button, d = (h) => {
    n.removeEventListener("pointermove", a, true), n.removeEventListener("pointerup", u, false), t !== void 0 && t(h, h.clientX - r, h.clientY - s);
  }, u = (h) => {
    h.button === l && d(h);
  };
  n.addEventListener("pointermove", a, true), n.addEventListener("pointerup", u, false), n.addEventListener("pointercancel", d, false);
}
var OU = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='closeIconTitle'%3e%3ctitle%20id='closeIconTitle'%3eClose%3c/title%3e%3cpath%20d='M6.34314575%206.34314575L17.6568542%2017.6568542M6.34314575%2017.6568542L17.6568542%206.34314575'/%3e%3c/svg%3e";
var VU = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='refreshIconTitle'%3e%3ctitle%20id='refreshIconTitle'%3eRefresh%3c/title%3e%3cpolyline%20points='22%2012%2019%2015%2016%2012'/%3e%3cpath%20d='M11,20%20C6.581722,20%203,16.418278%203,12%20C3,7.581722%206.581722,4%2011,4%20C15.418278,4%2019,7.581722%2019,12%20L19,14'/%3e%3c/svg%3e";
function Tt(i) {
  const e = i.title, t = i.onClick, n = i.href;
  let r;
  n !== void 0 ? (r = document.createElement("a"), r.href = n, r.target = "_blank") : r = document.createElement("div"), e !== void 0 && (r.title = e), t !== void 0 && r.addEventListener("click", t);
  const s = i.svg;
  return r.className = "neuroglancer-icon", s !== void 0 && (r.innerHTML = s), i.text !== void 0 && r.appendChild(document.createTextNode(i.text)), r;
}
function aS(i = {}) {
  return Tt(H({ svg: OU }, i));
}
function BU(i = {}) {
  return Tt(H({ svg: VU }, i));
}
var co = "neuroglancer-drag-over";
var I1 = {
  row: "row",
  column: "col"
};
var FU = {
  left: "right",
  right: "left",
  top: "bottom",
  bottom: "top"
};
var ls = {
  left: "column",
  right: "column",
  top: "row",
  bottom: "row"
};
var Md = {
  left: "row",
  right: "row",
  top: "column",
  bottom: "column"
};
var Ya = {
  row: "width",
  column: "height"
};
var P1 = {
  row: "left",
  column: "top"
};
var UU = {
  row: "right",
  column: "bottom"
};
var R1 = {
  left: "marginLeft",
  right: "marginRight",
  top: "marginTop",
  bottom: "marginBottom"
};
var Nd = {
  left: -1,
  right: 1,
  top: -1,
  bottom: 1
};
var ma = class extends X {
  constructor(e, t = new Is()) {
    super(), this.sidePanelManager = e, this.location = t, this.element = document.createElement("div"), this.visibility = new Zt(Zt.VISIBLE);
    const n = this.element;
    n.classList.add("neuroglancer-side-panel"), n.draggable = true, n.addEventListener("dragstart", (r) => {
      this.sidePanelManager.startDrag(this.makeDragSource(), r), n.style.backgroundColor = "black", setTimeout(() => {
        n.style.backgroundColor = "";
      }, 0), sr(n, "drag", () => document.createTextNode("Drag side panel to move it to the left/right/top/bottom of another panel"));
    }), n.addEventListener("dragend", (r) => {
      this.sidePanelManager.endDrag(), In(n, "drag");
    });
  }
  makeDragSource() {
    return {
      dropAsNewPanel: (e) => {
        const t = this.location.value;
        this.location.value = H(H({}, t), e), this.location.locationChanged.dispatch();
      }
    };
  }
  close() {
    this.location.visible = false;
  }
  addTitleBar(e) {
    const t = document.createElement("div");
    t.classList.add("neuroglancer-side-panel-titlebar");
    const n = e.title;
    let r;
    n !== void 0 && (r = document.createElement("div"), r.classList.add("neuroglancer-side-panel-title"), r.textContent = n, t.appendChild(r));
    const s = aS({
      title: "Close panel",
      onClick: () => {
        this.close();
      }
    });
    return s.style.order = "100", t.appendChild(s), this.element.appendChild(t), { titleBar: t, titleElement: r, closeButton: s };
  }
  addBody(e) {
    e.draggable = true, e.addEventListener("dragstart", (t) => {
      t.preventDefault(), t.stopPropagation();
    }), this.element.appendChild(e);
  }
};
var zU = class extends X {
  constructor(e, t, n = new Zt(Zt.VISIBLE)) {
    super(), this.display = e, this.center = t, this.visibility = n, this.element = document.createElement("div"), this.centerColumn = document.createElement("div"), this.beforeRender = new ct(), this.sides = {
      left: this.makeSidePanelSideState("left"),
      right: this.makeSidePanelSideState("right"),
      top: this.makeSidePanelSideState("top"),
      bottom: this.makeSidePanelSideState("bottom")
    }, this.registeredPanels = new Ye(), this.layoutNeedsUpdate = false, this.invalidateLayout = () => {
      this.layoutNeedsUpdate = true, this.display.scheduleRedraw();
    };
    const r = this.element, s = this.centerColumn;
    r.style.display = "flex", r.style.flex = "1", r.style.flexDirection = "row", s.style.display = "flex", s.style.flex = "1", s.style.flexDirection = "column", s.style.flexBasis = "0px", s.style.minWidth = "0px", this.render(), this.registerDisposer(e.updateStarted.add(() => {
      this.beforeRender.dispatch(), this.layoutNeedsUpdate && (this.render(), ++e.resizeGeneration);
    })), this.registerDisposer(this.visibility.changed.add(this.invalidateLayout));
  }
  get visible() {
    return this.visibility.visible;
  }
  makeSidePanelSideState(e) {
    return {
      flexGroups: [],
      outerDropZoneElement: this.makeDropZone(
        e,
        /*crossIndex=*/
        Nd[e] * (1 / 0),
        /*flexIndex=*/
        0,
        /*zoneSide=*/
        e,
        /*centered=*/
        false
      )
    };
  }
  hasDroppablePanel() {
    return this.dragSource !== void 0;
  }
  startDrag(e, t) {
    setTimeout(() => {
      this.dragSource === e && (this.element.dataset.neuroglancerSidePanelDrag = "true");
    }, 0), this.dragSource = e, t.stopPropagation(), t.dataTransfer.setData("neuroglancer-side-panel", "");
  }
  endDrag() {
    delete this.element.dataset.neuroglancerSidePanelDrag, this.dragSource = void 0;
  }
  makeDropZone(e, t, n, r, s = false) {
    const a = document.createElement("div");
    a.className = "neuroglancer-side-panel-drop-zone";
    const l = 10, d = ls[r], u = Md[r];
    return a.style[Ya[u]] = `${l}px`, a.style[Ya[d]] = "100%", s ? (a.style.position = "absolute", a.style[r] = "50%", a.style[R1[r]] = "-${size/2}px") : (a.style.position = "relative", a.style[R1[FU[r]]] = `-${l}px`), a.addEventListener("dragenter", (h) => {
      this.hasDroppablePanel() && (a.classList.add(co), h.preventDefault(), sr(a, "drop", () => document.createTextNode(`Drop side panel as new ${d}`)));
    }), a.addEventListener("dragleave", () => {
      In(a, "drop"), a.classList.remove(co);
    }), a.addEventListener("dragover", (h) => {
      this.hasDroppablePanel() && h.preventDefault();
    }), a.addEventListener("drop", (h) => {
      const g = this.dragSource;
      if (g === void 0) return;
      In(a, "drop"), a.classList.remove(co);
      const v = ls[e];
      g.dropAsNewPanel({
        side: e,
        row: v === "column" ? n : t,
        col: v === "row" ? n : t
      }), this.dragSource = void 0, h.preventDefault(), h.stopPropagation();
    }), a;
  }
  registerPanel(e) {
    return this.registeredPanels.add(e), this.invalidateLayout(), e.location.locationChanged.add(this.invalidateLayout), () => {
      this.unregisterPanel(e);
    };
  }
  unregisterPanel(e) {
    var t;
    this.registeredPanels.delete(e), e.location.locationChanged.remove(this.invalidateLayout), (t = e.panel) === null || t === void 0 || t.dispose(), this.invalidateLayout();
  }
  disposed() {
    for (const e of this.registeredPanels) {
      const t = e.panel;
      t == null ? void 0 : t.dispose();
    }
    super.disposed();
  }
  render() {
    this.layoutNeedsUpdate = false;
    const e = { left: [], right: [], top: [], bottom: [] };
    for (const a of this.registeredPanels)
      e[a.location.value.side].push(a);
    const t = (a) => this.renderSide(a, this.sides[a].flexGroups, e[a]), n = this;
    function* r() {
      yield n.sides.left.outerDropZoneElement, yield* t("left"), yield n.centerColumn, yield* t("right"), yield n.sides.right.outerDropZoneElement;
    }
    rr(this.element, r());
    function* s() {
      yield n.sides.top.outerDropZoneElement, yield* t("top"), yield n.center, yield* t("bottom"), yield n.sides.bottom.outerDropZoneElement;
    }
    rr(this.centerColumn, s());
  }
  makeCrossGutter(e, t) {
    const n = document.createElement("div");
    n.style.position = "relative";
    const r = Md[e];
    n.className = `neuroglancer-resize-gutter-${r === "row" ? "horizontal" : "vertical"}`, n.addEventListener("pointerdown", (a) => {
      if ("button" in a && a.button !== 0)
        return;
      a.preventDefault();
      const l = this.sides[e].flexGroups[t];
      if (l === void 0 || !l.visible) return;
      let u = l.element.getBoundingClientRect()[Ya[r]];
      const h = l.minSize, g = () => {
        sr(n, "drag", `Drag to resize, current ${Ya[r]} is ${l.crossSize}px`);
      };
      g(), Ui(a, (v, y, C) => {
        const w = r === "row" ? y : C;
        u -= Nd[e] * w, l.crossSize = Math.max(h, Math.round(u)), g(), this.invalidateLayout();
      }, () => {
        In(n, "drag");
      });
    });
    const s = this.makeDropZone(
      e,
      t - Nd[e] * 0.5,
      /*flexIndex=*/
      0,
      /*zoneSide=*/
      e,
      /*centered=*/
      true
    );
    return n.appendChild(s), n;
  }
  makeFlexGutter(e, t, n) {
    const r = document.createElement("div");
    r.style.position = "relative";
    const s = ls[e];
    r.className = `neuroglancer-resize-gutter-${s === "row" ? "horizontal" : "vertical"}`, r.addEventListener("pointerdown", (l) => {
      if ("button" in l && l.button !== 0)
        return;
      l.preventDefault();
      const d = this.sides[e].flexGroups[t];
      if (d === void 0 || !d.visible) return;
      const u = d.cells, h = u[n];
      if (h === void 0 || !h.registeredPanel.location.visible) return;
      let g = n + 1;
      for (; g < u.length && !u[g].registeredPanel.location.visible; )
        ++g;
      if (g === u.length) return;
      const v = u[g], y = () => {
        sr(r, "drag", `Drag to resize, current ${Ya[s]} ratio is ${h.registeredPanel.location.value.flex} : ${v.registeredPanel.location.value.flex}`);
      };
      y(), Ui(l, (C) => {
        const w = h.registeredPanel.panel, b = v.registeredPanel.panel;
        if (w === void 0 || b === void 0) return;
        const E = w.element.getBoundingClientRect(), T = b.element.getBoundingClientRect(), I = Math.max(0.1, Math.min(0.9, s === "column" ? (C.clientY - E.top) / (T.bottom - E.top) : (C.clientX - E.left) / (T.right - E.left))), R = h.registeredPanel.location.value, P = v.registeredPanel.location.value, L = R.flex + P.flex;
        h.registeredPanel.location.value = H(H({}, R), { flex: Math.round(I * L * 100) / 100 }), v.registeredPanel.location.value = H(H({}, P), { flex: Math.round((1 - I) * L * 100) / 100 }), y(), h.registeredPanel.location.locationChanged.dispatch(), v.registeredPanel.location.locationChanged.dispatch(), this.invalidateLayout();
      }, () => {
        In(r, "drag");
      });
    });
    const a = this.makeDropZone(
      e,
      t,
      /*flexIndex=*/
      n + 0.5,
      /*zoneSide=*/
      P1[ls[e]],
      /*centered=*/
      true
    );
    return r.appendChild(a), r;
  }
  renderSide(e, t, n) {
    const r = I1[Md[e]], s = I1[ls[e]];
    n.sort((d, u) => {
      const h = d.location.value, g = u.location.value, v = h[s] - g[s];
      return v !== 0 ? v : h[r] - g[r];
    });
    const a = this;
    function* l() {
      let d = 0, u = n.length, h = 0;
      for (; d < u; ) {
        const g = n[d].location.value[s];
        let v = d, y = 0, C = 0;
        do {
          const T = n[v].location.value;
          if (T[s] !== g) break;
          T.visible && (++y, C = Math.max(C, T.minSize)), ++v;
        } while (v < u);
        const w = y > 0;
        let b = t[h];
        if (b === void 0) {
          const T = a.makeCrossGutter(e, h), I = document.createElement("div");
          I.className = `neuroglancer-side-panel-${ls[e]}`, b = t[h] = {
            element: I,
            gutterElement: T,
            cells: [],
            crossSize: -1,
            minSize: C,
            visible: w,
            beginDropZone: a.makeDropZone(
              e,
              h,
              /*flexIndex=*/
              -1 / 0,
              P1[ls[e]]
            ),
            endDropZone: a.makeDropZone(
              e,
              h,
              /*flexIndex=*/
              1 / 0,
              UU[ls[e]]
            )
          };
        } else
          b.visible = w, b.minSize = C, b.crossSize = Math.max(b.crossSize, C);
        function* E() {
          yield b.beginDropZone;
          let T = 0;
          for (let I = d, R = 0; I < v; ++I, ++R) {
            const P = n[I];
            let L = b.cells[R];
            L === void 0 ? L = b.cells[R] = {
              registeredPanel: P,
              gutterElement: void 0
            } : L.registeredPanel = P;
            const A = L.registeredPanel.location.value;
            b.crossSize == -1 && (b.crossSize = Math.max(C, A.size)), (A[s] !== h || A[r] !== R || A.visible && A.size !== b.crossSize) && (L.registeredPanel.location.value = H(H({}, A), { [s]: h, [r]: R, size: A.visible ? b.crossSize : A.size }), L.registeredPanel.location.changed.dispatch());
            const M = A.visible && a.visibility.visible;
            let O = P.panel;
            if (!M) {
              O !== void 0 && (O.dispose(), P.panel = void 0);
              continue;
            }
            ++T, O === void 0 && (O = P.panel = P.makePanel()), O.element.style.flex = y > 1 ? `${A.flex}` : "1", yield O.element, T === y ? L.gutterElement = void 0 : (L.gutterElement === void 0 && (L.gutterElement = a.makeFlexGutter(e, h, R)), yield L.gutterElement);
          }
          yield b.endDropZone;
        }
        rr(b.element, E()), b.cells.length = v - d, w && (b.element.style[Ya[Md[e]]] = `${b.crossSize}px`, Nd[e] > 0 ? (yield b.gutterElement, yield b.element) : (yield b.element, yield b.gutterElement)), d = v, ++h;
      }
      t.length = h;
    }
    return l();
  }
};
function oi(i, e = "text/plain") {
  let t = false;
  const n = Oi(document, "copy", (r) => {
    const s = r.clipboardData;
    s !== null && (s.setData(e, i), t = true), r.stopPropagation(), r.preventDefault();
  }, true);
  try {
    document.execCommand("copy");
  } finally {
    n();
  }
  return t;
}
var Hr = class extends X {
  constructor(e, t, n) {
    super(), this.target = e, this.eventMap = t, this.registerEventListener(e, "wheel", (r) => {
      n !== void 0 && n(r), this.dispatch("wheel", r);
    }), this.registerEventListener(e, "click", (r) => {
      n !== void 0 && n(r), this.dispatch(`click${r.button}`, r);
    }), this.registerEventListener(e, "dblclick", (r) => {
      n !== void 0 && n(r), this.dispatch(`dblclick${r.button}`, r);
    }), this.registerEventListener(e, "mousedown", (r) => {
      n !== void 0 && n(r);
      let s = r.button;
      s === 2 && (r.buttons & 3) === 1 && (s = 0), this.dispatch(`mousedown${s}`, r);
    }), this.registerEventListener(e, "mouseup", (r) => {
      n !== void 0 && n(r), this.dispatch(`mouseup${r.button}`, r);
    });
  }
  dispatch(e, t) {
    rI2(e, t, t, this.eventMap);
  }
};
var Qi = class extends X {
  constructor(e, t) {
    super(), this.element = Tt(H(H({}, t), { onClick: () => {
      e.value = !e.value;
    } })), this.element.classList.add("neuroglancer-checkbox-icon"), this.element.classList.add(t.backgroundScheme === "dark" ? "dark-background" : "light-background");
    const n = () => {
      const r = e.value;
      this.element.dataset.checked = r ? "true" : "false", this.element.title = (r ? t.disableTitle : t.enableTitle) || "";
    };
    this.registerDisposer(e.changed.add(n)), n();
  }
};
var $U = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='copyIconTitle'%3e%3ctitle%20id='copyIconTitle'%3eCopy%3c/title%3e%3crect%20width='12'%20height='14'%20x='8'%20y='7'/%3e%3cpolyline%20points='16%203%204%203%204%2017'/%3e%3c/svg%3e";
function or(i = {}) {
  return Tt(H({ svg: $U }, i));
}
var GU = class extends X {
  constructor(e) {
    super(), this.redraw = e;
  }
};
var lr = class extends X {
  constructor(e, t, n = new Zt(Zt.VISIBLE)) {
    super(), this.model = e, this.render = t, this.visibility = n, this.element = document.createElement("div"), this.generation = -1, this.currentViewDisposer = void 0, this.debouncedUpdateView = this.registerCancellable(Ct(() => this.updateView())), this.element.style.display = "contents", this.registerDisposer(e.changed.add(this.debouncedUpdateView)), this.registerDisposer(n.changed.add(() => {
      this.visible && this.debouncedUpdateView();
    })), this.updateView();
  }
  get visible() {
    return this.visibility.visible;
  }
  updateView() {
    if (!this.visible) return;
    const e = this.model;
    if (e.changed.count === this.generation) return;
    this.disposeCurrentView();
    const n = this.currentViewDisposer = new GU(this.debouncedUpdateView);
    this.render(e.value, this.element, n);
  }
  disposeCurrentView() {
    let e = this.currentViewDisposer;
    e !== void 0 && e.dispose(), st(this.element);
  }
  disposed() {
    this.disposeCurrentView(), super.disposed();
  }
};
function lI(i = {}) {
  return Tt(H({ text: "↗" }, i));
}
function A1(i) {
  return i.closest(".neuroglancer-selection-details");
}
var _1 = class extends ma {
  constructor(e, t, n, r) {
    super(e, t.location), this.sidePanelManager = e, this.state = t, this.manager = n, this.selectedLayer = r, this.body = document.createElement("div");
    const s = this.element, a = this.body;
    s.classList.add("neuroglancer-selection-details"), this.registerDisposer(new Hr(this.element, Lh()));
    var l = this.addTitleBar({ title: "Selection" });
    const d = l.titleBar, u = Tt({
      svg: eI,
      title: "Previous selection",
      onClick: () => {
        this.state.goBack();
      }
    }), h = Tt({
      svg: tI,
      title: "Next selection",
      onClick: () => {
        this.state.goForward();
      }
    });
    d.appendChild(u), d.appendChild(h), d.appendChild(this.registerDisposer(new Qi(t.pin, {
      // Note: \ufe0e forces text display, as otherwise the pin icon may as an emoji with
      // color.
      text: "📌︎",
      enableTitle: "Pin selection",
      disableTitle: "Unpin selection"
    })).element), a.classList.add("neuroglancer-selection-details-body"), this.addBody(a), a.appendChild(this.registerDisposer(new lr(t, (g, v, y) => {
      if (!t.location.visible || (u.style.visibility = t.canGoBack() ? "visible" : "hidden", h.style.visibility = t.canGoForward() ? "visible" : "hidden", g === void 0)) return;
      if (g.position !== void 0) {
        const b = document.createElement("div");
        b.classList.add("neuroglancer-selection-details-position");
        const E = or({
          title: "Copy position",
          onClick: () => {
            oi(R.map((L) => Math.floor(L)).join(", "));
          }
        });
        b.appendChild(E);
        var w = g.coordinateSpace;
        const T = w.rank, I = w.names, R = g.position;
        for (let L = 0; L < T; ++L) {
          const A = document.createElement("span");
          A.classList.add("neuroglancer-selection-details-position-dimension");
          const M = document.createElement("span");
          M.classList.add("neuroglancer-selection-details-position-dimension-name"), M.textContent = I[L];
          const O = document.createElement("span");
          O.classList.add("neuroglancer-selection-details-position-dimension-coordinate"), O.textContent = Math.floor(R[L]).toString(), A.appendChild(M), A.appendChild(O), b.appendChild(A);
        }
        const P = lI({
          title: "Move to position",
          onClick: () => {
            this.manager.globalPosition.value = R;
          }
        });
        b.appendChild(P), v.appendChild(b);
      }
      for (const b of g.layers) {
        const E = b.layer;
        v.appendChild(y.registerDisposer(new lr({
          value: void 0,
          changed: E.managedLayer.layerChanged
        }, (T, I, R) => {
          if (E.wasDisposed || !E.isReady)
            return;
          const P = document.createElement("div");
          if (P.classList.add("neuroglancer-selection-details-layer-body"), !E.displaySelectionState(b.state, P, R))
            return;
          const L = document.createElement("div");
          I.appendChild(L), L.classList.add("neuroglancer-selection-details-layer");
          const A = document.createElement("div");
          A.classList.add("neuroglancer-selection-details-layer-title"), A.textContent = E.managedLayer.name, A.addEventListener("click", () => {
            this.selectedLayer.layer = E.managedLayer, this.selectedLayer.visible = true;
          }), A.title = "Click to show layer side panel", L.appendChild(A), L.appendChild(P);
        })).element);
      }
    })).element);
  }
  close() {
    super.close(), this.state.value = void 0, this.state.pin.value = true;
  }
};
var WU = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='filterIconTitle'%3e%3ctitle%20id='filterIconTitle'%3eFilter%3c/title%3e%3cpath%20d='M10%2012.261L4.028%203.972h16L14%2012.329V17l-4%203z'/%3e%3c/svg%3e";
function HU(i = {}) {
  return Tt(H({ svg: WU }, i));
}
var Fr = class {
  constructor(e, t, n) {
    this.key = e, this.value = t, this.label = n;
  }
  toString() {
    const e = this.key, t = this.value, n = this.label;
    let r;
    return t === void 0 ? r = `${e}` : r = `${e}→${t}`, n === void 0 ? r : `${r} ${n}`;
  }
};
var cI = class extends X {
  constructor() {
    super(...arguments), this.selectedSegment = new re(), this.baseSelectedSegment = new re(), this.hasSelectedSegment = false, this.changed = new Le();
  }
  get value() {
    return this.hasSelectedSegment ? this.selectedSegment : void 0;
  }
  get baseValue() {
    return this.hasSelectedSegment ? this.baseSelectedSegment : void 0;
  }
  set(e, t = false) {
    const n = this.selectedSegment, r = this.baseSelectedSegment;
    let s = 0, a = 0, l = 0, d = 0, u;
    if (e == null)
      u = false;
    else if (typeof e == "number")
      s = l = e >>> 0, a = d = e < 0 ? 4294967295 : 0, u = true;
    else if (e instanceof Fr) {
      const h = e.value || e.key;
      s = h.low, a = h.high, l = e.key.low, d = e.key.high, u = true;
    } else e instanceof re ? (s = l = e.low, a = d = e.high, u = true) : u = false;
    t && s === 0 && a === 0 && (u = false), u ? u && (!this.hasSelectedSegment || n.low !== s || n.high !== a || r.low !== l || r.high !== d) && (n.low = s, n.high = a, r.low = l, r.high = d, this.hasSelectedSegment = true, this.changed.dispatch()) : this.hasSelectedSegment && (this.hasSelectedSegment = false, this.changed.dispatch());
  }
  isSelected(e) {
    return this.hasSelectedSegment && re.equal(e, this.selectedSegment);
  }
  bindTo(e, t) {
    this.registerDisposer(e.changed.add(() => {
      const n = e.get(t);
      let r;
      n !== void 0 && (r = n.value), this.set(r, t.displayState.segmentationGroupState.value.hideSegmentZero.value);
    }));
  }
};
function fc(i) {
  i.useTemporarySegmentEquivalences.value = false, i.useTemporaryVisibleSegments.value = false, i.temporaryVisibleSegments.clear(), i.temporarySegmentEquivalences.clear();
}
function oS(i, e, t = false) {
  let n, r, s, a;
  if (typeof e == "number" ? n = new re(e >>> 0, e < 0 ? 4294967295 : 0) : typeof e == "string" ? n = re.parseString(e) : n = t ? e.clone() : e, i == null) return n;
  var l = i.segmentationGroupState.value;
  const d = l.segmentEquivalences, u = l.segmentPropertyMap.value;
  return d.size !== 0 ? (r = d.get(n), re.equal(r, n) ? s = void 0 : s = r) : r = n, a = u == null ? void 0 : u.getSegmentLabel(r), a === void 0 && s == null ? n : new Fr(n, s, a);
}
function aa(i, e) {
  if (e instanceof Fr) return e;
  let t = oS(i, e);
  return t instanceof re ? new Fr(t) : t;
}
function ev(i, e) {
  const t = e.length;
  i.value < t && (i.value = t);
}
function Do(i, e) {
  return _r((t) => e.style.setProperty("--neuroglancer-segment-list-width", `${t}ch`), i.segmentationGroupState.value.maxIdLength);
}
var lS = (() => {
  const i = document.createElement("div");
  i.classList.add("neuroglancer-segment-list-entry");
  const e = document.createElement("div");
  e.classList.add("neuroglancer-segment-list-entry-sticky"), i.appendChild(e);
  const t = or({
    title: "Copy segment ID"
  });
  t.classList.add("neuroglancer-segment-list-entry-copy");
  const n = document.createElement("div");
  n.classList.add("neuroglancer-segment-list-entry-copy-container");
  const r = n.childElementCount;
  n.appendChild(t);
  const s = e.childElementCount;
  e.appendChild(n);
  const a = e.childElementCount, l = document.createElement("input");
  l.type = "checkbox", l.title = "Toggle segment visibility", l.classList.add("neuroglancer-segment-list-entry-visible-checkbox"), e.appendChild(l);
  const d = document.createElement("div");
  d.classList.add("neuroglancer-segment-list-entry-id-container");
  const u = e.childElementCount;
  e.appendChild(d);
  const h = document.createElement("div");
  h.classList.add("neuroglancer-segment-list-entry-id");
  const g = d.childElementCount;
  d.appendChild(h);
  const v = document.createElement("span");
  v.classList.add("neuroglancer-segment-list-entry-name");
  const y = i.childElementCount;
  i.appendChild(v);
  const C = HU({
    title: "Filter by label"
  });
  C.classList.add("neuroglancer-segment-list-entry-filter");
  const w = i.childElementCount;
  return i.appendChild(C), {
    template: i,
    copyContainerIndex: s,
    copyIndex: r,
    visibleIndex: a,
    idContainerIndex: u,
    idIndex: g,
    labelIndex: y,
    filterIndex: w,
    unmappedIdIndex: -1,
    unmappedCopyIndex: -1
  };
})();
var qU = (() => {
  const i = lS, e = i.template.cloneNode(
    /*deep=*/
    true
  ), t = e.children[0], n = t.children[i.idContainerIndex], r = n.childElementCount, s = n.children[i.idIndex].cloneNode(
    /*deep=*/
    true
  );
  s.classList.add("neuroglancer-segment-list-entry-unmapped-id"), n.appendChild(s);
  const a = t.children[i.copyContainerIndex], l = a.childElementCount;
  return a.appendChild(a.children[i.copyIndex].cloneNode(
    /*deep=*/
    true
  )), H(H({}, i), { template: e, unmappedIdIndex: r, unmappedCopyIndex: l });
})();
function dI(i) {
  let e = lS;
  const t = e.template.cloneNode(
    /*deep=*/
    true
  ), n = [];
  for (let r = 0; r < i; ++r) {
    n.push(t.childElementCount);
    const s = document.createElement("div");
    s.classList.add("neuroglancer-segment-list-entry-extra-property"), s.style.width = `max(var(--neuroglancer-column-${r}-width), var(--neuroglancer-column-${r}-label-width))`, t.appendChild(s);
  }
  return H(H({}, e), { template: t, numericalPropertyIndices: n });
}
var M1 = new VD();
function jU(i) {
  const e = (h) => {
    const g = h.currentTarget, v = g.dataset.id, y = Ni;
    y.tryParseString(v), i.segmentSelectionState.set(y), A1(g) || i.selectSegment(y, false);
  }, t = (h) => {
    const g = h.currentTarget, v = g.dataset.id, y = Ni;
    y.tryParseString(v), i.selectSegment(y, A1(g) ? "toggle" : true);
  }, n = () => {
    i.segmentSelectionState.set(null);
  }, r = (h) => h.currentTarget.closest(".neuroglancer-segment-list-entry"), s = (h) => {
    const g = r(h);
    oi(g.dataset.id), h.stopPropagation();
  }, a = (h) => {
    const g = r(h);
    oi(g.dataset.unmappedId), h.stopPropagation();
  }, l = (h) => {
    const v = r(h).dataset.id, y = Ni;
    y.tryParseString(v);
    const C = i.segmentationGroupState.value.visibleSegments;
    C.set(y, !C.has(y)), h.stopPropagation();
  }, d = (h) => {
    const v = r(h).dataset.id, y = Ni;
    y.tryParseString(v), i.filterBySegmentLabel(y), h.stopPropagation();
  }, u = (h) => {
    if (h.button !== 2 || h.ctrlKey || h.altKey || h.metaKey || h.shiftKey)
      return;
    const v = h.currentTarget.dataset.id, y = Ni;
    y.tryParseString(v), i.moveToSegment(y);
  };
  return (h, g) => {
    const v = h.children, y = v[0].children;
    h.addEventListener("mousedown", u);
    const C = y[g.copyContainerIndex];
    g.unmappedCopyIndex !== -1 && C.children[g.unmappedCopyIndex].addEventListener("click", a), C.children[g.copyIndex].addEventListener("click", s), h.addEventListener("mouseenter", e), h.addEventListener("mouseleave", n), y[g.visibleIndex].addEventListener("click", l), v[g.filterIndex].addEventListener("click", d), h.addEventListener("action:select-position", t);
  };
}
var qo = class _qo {
  constructor(e, t) {
    if (this.displayState = e, this.template = t, e !== void 0) {
      let n = M1.get(e);
      n === void 0 && (n = jU(e), M1.set(e, n)), this.registerEventHandlers = n;
    }
  }
  static make(e, t) {
    return new _qo(e, t ? qU : lS);
  }
  get(e) {
    const t = this.displayState;
    return this.getWithNormalizedId(aa(t, e));
  }
  getWithNormalizedId(e) {
    var t, n;
    const r = this.displayState, s = this.template, a = s.template.cloneNode(
      /*deep=*/
      true
    ), l = e.key, d = (t = e.value) !== null && t !== void 0 ? t : l, u = d.toString();
    a.dataset.id = u;
    const h = a.children, g = h[0].children, v = g[s.idContainerIndex];
    v.children[s.idIndex].textContent = u;
    const y = s.unmappedIdIndex;
    if (r !== void 0 ? this.registerEventHandlers(a, s) : g[s.visibleIndex].style.display = "none", y !== -1) {
      const C = v.children[y];
      if (re.equal(l, d)) {
        C.style.display = "none";
        const w = g[s.copyContainerIndex];
        w.children[s.unmappedCopyIndex].style.display = "none";
      } else {
        const w = l.toString();
        a.dataset.unmappedId = w, C.textContent = w, r !== void 0 && ev(r.segmentationGroupState.value.maxIdLength, w);
      }
    }
    return h[s.labelIndex].textContent = (n = e.label) !== null && n !== void 0 ? n : "", r !== void 0 && (this.updateWithId(a, d), ev(r.segmentationGroupState.value.maxIdLength, u)), a;
  }
  update(e) {
    const t = Ni, n = e.dataset.id;
    n !== void 0 && (t.parseString(n), this.updateWithId(e, t));
  }
  updateWithId(e, t) {
    const r = e.children[0].children, s = this.template, a = this.displayState, l = a.segmentSelectionState, d = a.segmentationGroupState.value.visibleSegments;
    r[s.visibleIndex].checked = d.has(t), e.dataset.selected = (l.hasSelectedSegment && re.equal(l.selectedSegment, t)).toString();
    const u = r[s.idContainerIndex];
    N1(u.children[s.idIndex], Tu(this.displayState, t));
    const h = s.unmappedIdIndex;
    if (h !== -1) {
      let g, v;
      if (a.baseSegmentColoring.value && (g = e.dataset.unmappedId) !== void 0) {
        const y = Ni;
        y.parseString(g), v = Tu(this.displayState, y);
      } else
        v = LT;
      N1(u.children[h], v);
    }
  }
};
function N1(i, e) {
  i.style.backgroundColor = QD(e), i.style.color = cu(e) ? "white" : "black";
}
var uI = class extends qo {
  constructor(e, t, n) {
    var r;
    const s = e.segmentationGroupState.value.segmentPropertyMap.value, a = ((r = s == null ? void 0 : s.numericalProperties) !== null && r !== void 0 ? r : []).filter(n), l = dI(a.length);
    super(e, l), this.parentElement = t, this.segmentPropertyMap = s, this.numericalProperties = a, (this.numericalPropertyWidths = new Array(this.numericalProperties.length)).fill(0);
  }
  getWithNormalizedId(e) {
    var t, n, r;
    const s = super.getWithNormalizedId(e), a = this.numericalProperties, l = this.template.numericalPropertyIndices;
    if (l.length > 0) {
      const d = (r = (t = this.segmentPropertyMap) === null || t === void 0 ? void 0 : t.getSegmentInlineIndex((n = e.value) !== null && n !== void 0 ? n : e.key)) !== null && r !== void 0 ? r : -1;
      if (d !== -1) {
        const u = this.numericalPropertyWidths;
        for (let h = 0, g = l.length; h < g; ++h) {
          const v = a[h].values[d];
          if (!isNaN(v)) {
            const y = v.toString(), C = y.length;
            C > u[h] && (u[h] = C, this.parentElement.style.setProperty(`--neuroglancer-column-${h}-width`, `${C}ch`)), s.children[l[h]].textContent = y;
          }
        }
      }
    }
    return s;
  }
  makeHeaderLabel(e, t, n) {
    const r = document.createElement("span");
    r.textContent = e, r.classList.add("neuroglancer-segment-list-header-label"), r.classList.add("neuroglancer-segment-list-header-label"), e === "label" && (n.style.textAlign = "left");
    const s = document.createElement("span");
    s.classList.add("neuroglancer-segment-list-header-label-sort"), r.appendChild(s), s.textContent = "▲";
    const a = RU(r).width;
    return this.parentElement.style.setProperty(t, `${a}px`), n.appendChild(r), { id: e, label: r, sortIcon: s };
  }
  getHeader() {
    const e = this.template, t = e.template.cloneNode(
      /*deep=*/
      true
    ), n = t.children, r = n[0].children, s = r[e.copyContainerIndex];
    s.style.visibility = "hidden", r[e.visibleIndex].style.visibility = "hidden", n[e.filterIndex].style.visibility = "hidden";
    const a = r[e.idContainerIndex], l = [this.makeHeaderLabel("id", "--neuroglancer-id-column-label-width", a.children[e.idIndex]), this.makeHeaderLabel("label", "--neuroglancer-label-column-label-width", n[e.labelIndex])], d = this.numericalProperties, u = this.template.numericalPropertyIndices;
    for (let h = 0, g = u.length; h < g; ++h) {
      const v = d[h], y = this.makeHeaderLabel(v.id, `--neuroglancer-column-${h}-label-width`, t.children[u[h]]), C = v.description;
      C && (y.label.title = C), l.push(y);
    }
    return { container: t, propertyLabels: l };
  }
};
function Dh(i, e) {
  return qo.make(
    i ?? void 0,
    /*includeUnmapped=*/
    true
  ).getWithNormalizedId(e);
}
function jo(i, e, t) {
  e.registerDisposer(fo((n, r) => {
    GF(n, r, t);
  }, i.segmentationGroupState)), e.registerDisposer(fo((n, r) => {
    n.registerDisposer(r.segmentColorHash.changed.add(t)), n.registerDisposer(r.segmentDefaultColor.changed.add(t));
  }, i.segmentationColorGroupState)), e.registerDisposer(i.saturation.changed.add(t)), e.registerDisposer(i.segmentSelectionState.changed.add(t)), e.registerDisposer(i.baseSegmentColoring.changed.add(t));
}
function cS(i, e) {
  const t = e.redrawNeeded.dispatch;
  jo(i, e, t), e.registerDisposer(fo((n, r) => {
    WF(n, r, t);
  }, i.segmentationGroupState));
}
function hI(i, e) {
  cS(i, e), e.registerDisposer(i.objectAlpha.changed.add(e.redrawNeeded.dispatch));
}
function Ih(i, e) {
  hI(i, e), e.registerDisposer(i.transform.changed.add(e.redrawNeeded.dispatch)), e.registerDisposer(i.renderScaleTarget.changed.add(e.redrawNeeded.dispatch)), e.registerDisposer(i.transparentPickEnabled.changed.add(e.redrawNeeded.dispatch));
}
var fI = oh();
var Ni = new re();
function Tu(i, e, t = fI) {
  if (i == null)
    return t.fill(1), t;
  const n = i.segmentationColorGroupState.value;
  if (n.segmentStatedColors.size !== 0 && n.segmentStatedColors.get(e, Ni))
    return t[0] = (Ni.low & 255) / 255, t[1] = ((Ni.low & 65280) >>> 8) / 255, t[2] = ((Ni.low & 16711680) >>> 16) / 255, t;
  const s = n.segmentDefaultColor.value;
  return s !== void 0 ? (t[0] = s[0], t[1] = s[1], t[2] = s[2], t) : (n.segmentColorHash.compute(t, e), t);
}
function pI(i, e, t = 1) {
  const n = fI;
  n[3] = t, Tu(i, e, n);
  let r = i.saturation.value;
  i.segmentSelectionState.isSelected(e) && (r > 0.5 ? r = r -= 0.5 : r += 0.5);
  for (let s = 0; s < 3; ++s)
    n[s] = n[s] * r + (1 - r);
  return n[0] *= t, n[1] *= t, n[2] *= t, n;
}
function dS(i, e = {}) {
  for (const t of $F)
    e[t] = i[t].rpcId;
  return e;
}
var JU = mh(Rc);
var Ph = class extends JU {
  constructor(e, t, n) {
    super(n), this.chunkManager = e, this.displayState = t;
  }
  initializeCounterpartWithChunkManager(e) {
    let t = this.displayState;
    e.chunkManager = this.chunkManager.rpcId, dS(t.segmentationGroupState.value, e), e.transform = this.registerDisposer(An.makeFromExisting(this.chunkManager.rpc, this.displayState.transform)).rpcId, e.renderScaleTarget = this.registerDisposer(An.makeFromExisting(this.chunkManager.rpc, this.displayState.renderScaleTarget)).rpcId, super.initializeCounterpart(this.chunkManager.rpc, e);
  }
};
function Rh(i, e, t, n, r) {
  const s = Math.min(1, i.objectAlpha.value), a = i.baseSegmentColoring.value;
  $o(i.segmentationGroupState.value, (l, d) => {
    let u = n == null ? void 0 : n.registerUint64(e, l), h = t ? pI(i, a ? l : d, s) : void 0;
    r(l, h, u, d);
  });
}
var KU = Object.freeze(Object.defineProperty({
  __proto__: null,
  SegmentSelectionState: cI,
  SegmentWidgetFactory: qo,
  SegmentWidgetWithExtraColumnsFactory: uI,
  SegmentationLayerSharedObject: Ph,
  Uint64MapEntry: Fr,
  augmentSegmentId: aa,
  bindSegmentListWidth: Do,
  forEachVisibleSegmentToDraw: Rh,
  getBaseObjectColor: Tu,
  getObjectColor: pI,
  makeSegmentWidget: Dh,
  maybeAugmentSegmentId: oS,
  registerCallbackWhenSegmentationDisplayStateChanged: jo,
  registerRedrawWhenSegmentationDisplayState3DChanged: Ih,
  registerRedrawWhenSegmentationDisplayStateChanged: cS,
  registerRedrawWhenSegmentationDisplayStateWithAlphaChanged: hI,
  resetTemporaryVisibleSegmentsState: fc,
  segmentWidgetTemplateWithExtraColumns: dI,
  sendVisibleSegmentsState: dS,
  updateIdStringWidth: ev
}, Symbol.toStringTag, { value: "Module" }));
var gI = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
var YU = nt();
var gi = Sc();
function mI(i, e) {
  e.vertexBuffer = Qn.fromData(i, e.meshData.vertexPositions, i.ARRAY_BUFFER, i.STATIC_DRAW), e.indexBuffer = Qn.fromData(i, e.meshData.indices, i.ELEMENT_ARRAY_BUFFER, i.STATIC_DRAW), e.normalBuffer = Qn.fromData(i, e.meshData.vertexNormals, i.ARRAY_BUFFER, i.STATIC_DRAW);
}
function vI(i) {
  i.vertexBuffer.dispose(), i.indexBuffer.dispose(), i.normalBuffer.dispose();
}
var XU = `
highp vec3 decodeNormalOctahedronSnorm8(highp vec2 e) {
  vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  if (v.z < 0.0) v.xy = (1.0 - abs(v.yx)) * vec2(v.x > 0.0 ? 1.0 : -1.0, v.y > 0.0 ? 1.0 : -1.0);
  return normalize(v);
}
`;
function O1(i) {
  return {
    defineShader: (e) => {
      e.addAttribute("highp vec3", "aVertexPosition"), e.addVertexCode("highp vec3 getVertexPosition() { return aVertexPosition; }");
    },
    bind(e, t, n) {
      n.vertexBuffer.bindToVertexAttrib(
        t.attribute("aVertexPosition"),
        /*components=*/
        3,
        i,
        /* normalized=*/
        true
      );
    },
    endLayer: (e, t) => {
      e.disableVertexAttribArray(t.attribute("aVertexPosition"));
    }
  };
}
var ZU = {
  [Nr.float32]: O1(WebGL2RenderingContext.FLOAT),
  [Nr.uint16]: O1(WebGL2RenderingContext.UNSIGNED_SHORT),
  [Nr.uint10]: {
    defineShader: (i) => {
      i.addAttribute("highp uint", "aVertexPosition"), i.addVertexCode(`
highp vec3 getVertexPosition() {
  return vec3(float(aVertexPosition & 1023u),
              float((aVertexPosition >> 10) & 1023u),
              float((aVertexPosition >> 20) & 1023u)) / 1023.0;
}
`);
    },
    bind(i, e, t) {
      t.vertexBuffer.bindToVertexAttribI(
        e.attribute("aVertexPosition"),
        /*components=*/
        1,
        WebGL2RenderingContext.UNSIGNED_INT
      );
    },
    endLayer: (i, e) => {
      i.disableVertexAttribArray(e.attribute("aVertexPosition"));
    }
  }
};
var yI = class {
  constructor(e, t) {
    this.fragmentRelativeVertices = e, this.vertexPositionFormat = t, this.tempLightVec = new Float32Array(4), this.vertexPositionHandler = ZU[this.vertexPositionFormat];
  }
  beginLayer(e, t, n, r) {
    let s = n.lightDirection, a = n.ambientLighting, l = n.directionalLighting, d = this.tempLightVec;
    dy(d, s, l), d[3] = a, e.uniform4fv(t.uniform("uLightDirection"), d);
    const u = r.silhouetteRendering.value;
    u > 0 && e.uniform1f(t.uniform("uSilhouettePower"), u);
  }
  setColor(e, t, n) {
    e.uniform4fv(t.uniform("uColor"), n);
  }
  setPickID(e, t, n) {
    e.uniform1ui(t.uniform("uPickID"), n);
  }
  beginModel(e, t, n, r) {
    const s = n.projectionParameters;
    e.uniformMatrix4fv(t.uniform("uModelViewProjection"), false, vn(YU, s.viewProjectionMat, r)), lh(gi, r), RT(gi, gi, s.displayDimensionRenderInfo.canonicalVoxelFactors), aN(gi, gi), sN(gi, gi), e.uniformMatrix3fv(t.uniform("uNormalMatrix"), false, gi);
  }
  drawFragmentHelper(e, t, n, r, s) {
    this.vertexPositionHandler.bind(e, t, n);
    const a = n.meshData;
    n.normalBuffer.bindToVertexAttrib(
      t.attribute("aVertexNormal"),
      /*components=*/
      2,
      WebGL2RenderingContext.BYTE,
      /*normalized=*/
      true
    ), n.indexBuffer.bind();
    const l = a.indices;
    e.drawElements(a.strips ? WebGL2RenderingContext.TRIANGLE_STRIP : WebGL2RenderingContext.TRIANGLES, s - r, l.BYTES_PER_ELEMENT === 2 ? WebGL2RenderingContext.UNSIGNED_SHORT : WebGL2RenderingContext.UNSIGNED_INT, r * l.BYTES_PER_ELEMENT);
  }
  drawFragment(e, t, n) {
    const s = n.meshData.indices;
    this.drawFragmentHelper(e, t, n, 0, s.length);
  }
  drawMultiscaleFragment(e, t, n, r, s) {
    const a = n.meshData.subChunkOffsets[r], l = n.meshData.subChunkOffsets[s];
    this.drawFragmentHelper(e, t, n, a, l);
  }
  endLayer(e, t) {
    this.vertexPositionHandler.endLayer(e, t), e.disableVertexAttribArray(t.attribute("aVertexNormal"));
  }
  makeGetter(e) {
    const t = e.registerDisposer(wi((n) => n > 0, [e.displayState.silhouetteRendering]));
    return vo(e, e.gl, {
      memoizeKey: `mesh/MeshShaderManager/${this.fragmentRelativeVertices}/${this.vertexPositionFormat}`,
      parameters: t,
      defineShader: (n, r) => {
        this.vertexPositionHandler.defineShader(n), n.addAttribute("highp vec2", "aVertexNormal"), n.addVarying("highp vec4", "vColor"), n.addUniform("highp vec4", "uLightDirection"), n.addUniform("highp vec4", "uColor"), n.addUniform("highp mat3", "uNormalMatrix"), n.addUniform("highp mat4", "uModelViewProjection"), n.addUniform("highp uint", "uPickID"), r && n.addUniform("highp float", "uSilhouettePower"), this.fragmentRelativeVertices && (n.addUniform("highp vec3", "uFragmentOrigin"), n.addUniform("highp vec3", "uFragmentShape")), n.addVertexCode(XU);
        let s = "";
        this.fragmentRelativeVertices ? s += `
highp vec3 vertexPosition = uFragmentOrigin + uFragmentShape * getVertexPosition();
highp vec3 normalMultiplier = 1.0 / uFragmentShape;
` : s += `
highp vec3 vertexPosition = getVertexPosition();
highp vec3 normalMultiplier = vec3(1.0, 1.0, 1.0);
`, s += `
gl_Position = uModelViewProjection * vec4(vertexPosition, 1.0);
vec3 origNormal = decodeNormalOctahedronSnorm8(aVertexNormal);
vec3 normal = normalize(uNormalMatrix * (normalMultiplier * origNormal));
float absCosAngle = abs(dot(normal, uLightDirection.xyz));
float lightingFactor = absCosAngle + uLightDirection.w;
vColor = vec4(lightingFactor * uColor.rgb, uColor.a);
`, r && (s += `
vColor *= pow(1.0 - absCosAngle, uSilhouettePower);
`), n.setVertexMain(s), n.setFragmentMain("emit(vColor, uPickID);");
      }
    });
  }
};
var V1 = class extends Ho {
  constructor(e, t, n) {
    super(), this.chunkManager = e, this.source = t, this.displayState = n, this.meshShaderManager = new yI(
      /*fragmentRelativeVertices=*/
      false,
      Nr.float32
    ), this.getShader = this.meshShaderManager.makeGetter(this), Ih(n, this), this.registerDisposer(n.silhouetteRendering.changed.add(this.redrawNeeded.dispatch));
    let r = this.backend = this.registerDisposer(new Ph(e, n, this.layerChunkProgressInfo));
    r.RPC_TYPE_ID = J3, r.initializeCounterpartWithChunkManager({
      source: t.addCounterpartRef()
    }), r.visibility.add(this.visibility), this.registerDisposer(n.renderScaleHistogram.visibility.add(this.visibility));
  }
  get isTransparent() {
    const e = this.displayState;
    return e.objectAlpha.value < 1 || e.silhouetteRendering.value > 0;
  }
  get transparentPickEnabled() {
    return this.displayState.transparentPickEnabled.value;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  draw(e, t) {
    if (!e.emitColor && e.alreadyEmittedPickID)
      return;
    const n = this.gl, r = this.displayState, s = this.meshShaderManager;
    if (r.objectAlpha.value <= 0)
      return;
    const a = yu(r.transform.value, e.projectionParameters.displayDimensionRenderInfo, t);
    if (a === void 0)
      return;
    var l = this.getShader(e.emitter);
    const d = l.shader;
    if (d === null) return;
    d.bind(), s.beginLayer(n, d, e, this.displayState), s.beginModel(n, d, e, a);
    const u = this.source.chunks;
    let h = 0, g = 0;
    const v = this.displayState.renderScaleHistogram, y = this.source.fragmentSource.chunks;
    Rh(r, this, e.emitColor, e.emitPickID ? e.pickIDs : void 0, (C, w, b) => {
      const E = ir(C), T = u.get(E);
      if (++h, T !== void 0) {
        ++g, e.emitColor && s.setColor(n, d, w), e.emitPickID && s.setPickID(n, d, b), h += T.fragmentIds.length;
        for (const R of T.fragmentIds) {
          var I = this.source.getFragmentKey(E, R);
          const P = I.key, L = y.get(P);
          L !== void 0 && L.state === kt.GPU_MEMORY && (s.drawFragment(n, d, L), ++g);
        }
      }
    }), e.emitColor && (v.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber), v.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, g, h - g)), s.endLayer(n, d);
  }
  isReady() {
    const e = this.displayState, t = this.source;
    let n = true;
    const r = t.fragmentSource.chunks;
    return $o(e.segmentationGroupState.value, (s) => {
      const a = ir(s), l = t.chunks.get(a);
      if (l === void 0) {
        n = false;
        return;
      }
      for (const u of l.fragmentIds) {
        var d = this.source.getFragmentKey(a, u);
        const h = d.key, g = r.get(h);
        if (g === void 0 || g.state !== kt.GPU_MEMORY) {
          n = false;
          return;
        }
      }
    }), n;
  }
};
var QU = class extends Ds {
  constructor(e, t) {
    super(e), this.fragmentIds = t.fragmentIds;
  }
};
var ez = class extends Ds {
  constructor(e, t) {
    super(e), this.meshData = t;
  }
  copyToGPU(e) {
    super.copyToGPU(e), mI(e, this);
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e), vI(this);
  }
};
var Vc = class extends Wr {
  constructor(e, t) {
    super(e, t), this.fragmentSource = this.registerDisposer(new tv(this.chunkManager, this));
  }
  initializeCounterpart(e, t) {
    this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {}), t.fragmentSource = this.fragmentSource.addCounterpartRef(), super.initializeCounterpart(e, t);
  }
  getChunk(e) {
    return new QU(this, e);
  }
  getFragmentKey(e, t) {
    return { key: `${e}/${t}`, fragmentId: t };
  }
};
var tv = class extends Wr {
  constructor(e, t) {
    super(e), this.meshSource = t;
  }
  get key() {
    return this.meshSource.key;
  }
  getChunk(e) {
    return new ez(this, e);
  }
};
tv = gI([ki(Y3)], tv);
function B1(i, e, t, n) {
  const r = i.get(jD(e, t, n));
  return r !== void 0 && r.state === kt.GPU_MEMORY;
}
var Wg = class extends Ho {
  constructor(e, t, n) {
    super(), this.chunkManager = e, this.source = t, this.displayState = n, this.meshShaderManager = new yI(
      /*fragmentRelativeVertices=*/
      this.source.format.fragmentRelativeVertices,
      this.source.format.vertexPositionFormat
    ), this.getShader = this.meshShaderManager.makeGetter(this), Ih(n, this), this.registerDisposer(n.silhouetteRendering.changed.add(this.redrawNeeded.dispatch));
    let r = this.backend = this.registerDisposer(new Ph(e, n, this.layerChunkProgressInfo));
    r.RPC_TYPE_ID = K3, r.initializeCounterpartWithChunkManager({
      source: t.addCounterpartRef()
    }), r.visibility.add(this.visibility), this.registerDisposer(n.renderScaleHistogram.visibility.add(this.visibility));
  }
  get isTransparent() {
    const e = this.displayState;
    return e.objectAlpha.value < 1 || e.silhouetteRendering.value > 0;
  }
  get transparentPickEnabled() {
    return this.displayState.transparentPickEnabled.value;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  draw(e, t) {
    if (!e.emitColor && e.alreadyEmittedPickID)
      return;
    const n = this.gl, r = this.displayState, s = this.meshShaderManager;
    if (r.objectAlpha.value <= 0)
      return;
    const a = yu(r.transform.value, e.projectionParameters.displayDimensionRenderInfo, t);
    if (a === void 0) return;
    var l = this.getShader(e.emitter);
    const d = l.shader;
    if (d === null) return;
    d.bind(), s.beginLayer(n, d, e, this.displayState);
    const u = this.displayState.renderScaleHistogram;
    e.emitColor && u.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber), lh(gi, a), RT(gi, gi, e.projectionParameters.displayDimensionRenderInfo.voxelPhysicalScales);
    const h = Math.pow(Math.abs(ly(gi)), 1 / 3), g = this.source.chunks, v = this.source.fragmentSource.chunks, y = e.projectionParameters, C = vn(nt(), y.viewProjectionMat, a), w = ou(new Float32Array(24), C), b = this.displayState.renderScaleTarget.value, E = this.source.format.fragmentRelativeVertices;
    s.beginModel(n, d, e, a);
    let T = 0, I = 0;
    Rh(r, this, e.emitColor, e.emitPickID ? e.pickIDs : void 0, (R, P, L) => {
      const A = ir(R), M = g.get(A);
      if (++T, M === void 0) return;
      ++I;
      const O = M.manifest, F = O.octree, q = O.chunkShape, U = O.chunkGridSpatialOrigin, V = O.vertexOffsets;
      e.emitColor && s.setColor(n, d, P), e.emitPickID && s.setPickID(n, d, L), m1(O, C, w, b, y.width, y.height, ($, B, ue) => {
        const se = B1(v, A, $, B);
        return e.emitColor && u.add(O.lodScales[$] * h, ue, se ? 1 : 0, se ? 0 : 1), se;
      }, ($, B, ue, se) => {
        const Pe = jD(A, $, B), ae = v.get(Pe), Ee = F[5 * B], ce = F[5 * B + 1], ge = F[5 * B + 2], Ne = 1 << $;
        E && (n.uniform3f(d.uniform("uFragmentOrigin"), U[0] + Ee * q[0] * Ne + V[$ * 3 + 0], U[1] + ce * q[1] * Ne + V[$ * 3 + 1], U[2] + ge * q[2] * Ne + V[$ * 3 + 2]), n.uniform3f(d.uniform("uFragmentShape"), q[0] * Ne, q[1] * Ne, q[2] * Ne)), s.drawMultiscaleFragment(n, d, ae, ue, se);
      });
    }), u.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, I, T - I), s.endLayer(n, d);
  }
  isReady(e, t) {
    let n = this.displayState;
    if (n.objectAlpha.value <= 0)
      return true;
    const r = yu(n.transform.value, e.projectionParameters.displayDimensionRenderInfo, t);
    if (r === void 0) return false;
    const s = this.source.chunks, a = this.source.fragmentSource.chunks, l = e.projectionParameters, d = vn(nt(), l.viewProjectionMat, r), u = ou(new Float32Array(24), d), h = this.displayState.renderScaleTarget.value;
    let g = true;
    return $o(n.segmentationGroupState.value, (v) => {
      if (!g) return;
      const y = ir(v), C = s.get(y);
      if (C === void 0) {
        g = false;
        return;
      }
      const w = C.manifest;
      m1(w, d, u, h, l.width, l.height, (b, E) => (g = g && B1(a, y, b, E), g), () => {
      });
    }), g;
  }
  getObjectPosition(e) {
    const t = this.displayState.transform.value;
    if (t.error !== void 0) return;
    const n = this.source.chunks.get(ir(e));
    if (n === void 0) return;
    const r = n.manifest, s = r.clipLowerBound, a = r.clipUpperBound, l = t.rank, d = new Float32Array(l);
    for (let h = 0; h < 3; ++h)
      d[h] = (s[h] + a[h]) / 2;
    const u = new Float32Array(l);
    return Ar(u, t.modelToRenderLayerTransform, l + 1, d, l), u;
  }
};
var tz = class extends Ds {
  constructor(e, t) {
    super(e), this.manifest = t.manifest;
  }
};
var nz = class extends Ds {
  constructor(e, t) {
    super(e), this.meshData = t;
  }
  copyToGPU(e) {
    super.copyToGPU(e), mI(e, this);
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e), vI(this);
  }
};
var Ah = class extends Wr {
  constructor(e, t) {
    super(e, t), this.fragmentSource = this.registerDisposer(new nv(this.chunkManager, this)), this.format = t.format;
  }
  static encodeOptions(e) {
    return H({ format: e.format }, super.encodeOptions(e));
  }
  initializeCounterpart(e, t) {
    this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {}), t.fragmentSource = this.fragmentSource.addCounterpartRef(), t.format = this.format, super.initializeCounterpart(e, t);
  }
  getChunk(e) {
    return new tz(this, e);
  }
};
var nv = class extends Wr {
  constructor(e, t) {
    super(e), this.meshSource = t;
  }
  get key() {
    return this.meshSource.key;
  }
  getChunk(e) {
    return new nz(this, e);
  }
};
nv = gI([ki(X3)], nv);
var F1 = {};
var U1;
function iz() {
  if (U1) return F1;
  U1 = 1;
  var i = BD(), e = ND()(false);
  return i(i.S, "Object", {
    values: function(n) {
      return e(n);
    }
  }), F1;
}
var Hg;
var z1;
function rz() {
  return z1 || (z1 = 1, iz(), Hg = mR().Object.values), Hg;
}
var qg;
var $1;
function sz() {
  return $1 || ($1 = 1, qg = { default: rz(), __esModule: true }), qg;
}
var az = sz();
var iv = Ws(az);
var oz = "skeleton/SkeletonLayer";
var uS = 6;
var hS = `
vec2 getQuadVertexPosition(vec2 lower, vec2 upper) {
  const vec2 coeffs[] = vec2[](
    vec2(0.0, 0.0),
    vec2(0.0, 1.0),
    vec2(1.0, 1.0),
    vec2(1.0, 1.0),
    vec2(1.0, 0.0),
    vec2(0.0, 0.0)
  );
  int v = gl_VertexID % 6;
  return mix(lower, upper, coeffs[v]);
}
`;
function fS(i, e, t) {
  i.drawArraysInstanced(WebGL2RenderingContext.TRIANGLES, 0, uS * e, t);
}
function lz(i, e) {
  const t = new Float32Array((i + 1) * (e + 1) * 3);
  let n = 0;
  for (let r = 0; r <= i; ++r) {
    const s = r * Math.PI / i, a = Math.sin(s), l = Math.cos(s);
    for (let d = 0; d <= e; ++d) {
      const u = d * 2 * Math.PI / e, h = Math.sin(u), g = Math.cos(u);
      t[n++] = g * a, t[n++] = l, t[n++] = h * a;
    }
  }
  return t;
}
function cz(i, e) {
  const t = new Uint16Array(i * e * 6);
  let n = 0;
  for (let r = 0; r < i; r++)
    for (let s = 0; s < e; s++) {
      const a = r * (e + 1) + s, l = a + e + 1;
      t[n++] = a, t[n++] = l, t[n++] = a + 1, t[n++] = l, t[n++] = l + 1, t[n++] = a + 1;
    }
  return t;
}
var SI = class extends X {
  constructor(e, t, n) {
    super(), this.vertexBuffer = this.registerDisposer(ac(e, WebGL2RenderingContext.ARRAY_BUFFER, lz, t, n)).value, this.indexBuffer = this.registerDisposer(ac(e, WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, cz, t, n)).value, this.numIndices = t * n * 6;
  }
  defineShader(e) {
    e.addAttribute("highp vec3", "aSphereVertex"), e.addVarying("highp float", "vLightingFactor"), e.addVertexCode(`
void emitSphere(mat4 projectionMatrix, mat4 normalTransformMatrix, vec3 centerPosition, vec3 radii, vec4 lightDirection) {
  vec3 vertexPosition = aSphereVertex * radii + centerPosition;
  gl_Position = projectionMatrix * vec4(vertexPosition, 1.0);
  vec3 normal = normalize((normalTransformMatrix * vec4(aSphereVertex / max(radii, 1e-6), 0.0)).xyz);
  vLightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;
}
`);
  }
  draw(e, t) {
    const n = e.attribute("aSphereVertex");
    this.vertexBuffer.bindToVertexAttrib(
      n,
      /*components=*/
      3,
      /*attributeType=*/
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false
    ), this.indexBuffer.bind(), e.gl.drawElementsInstanced(
      WebGL2RenderingContext.TRIANGLES,
      this.numIndices,
      WebGL2RenderingContext.UNSIGNED_SHORT,
      /*offset=*/
      0,
      t
    ), e.gl.disableVertexAttribArray(n);
  }
};
var pS = uS;
function Bc(i, e) {
  i.addVertexCode(hS), i.addUniform("highp vec3", "uCircleParams"), i.addVarying("highp vec4", "vCircleCoord"), i.addVertexCode(`
void emitCircle(vec4 position, float diameter, float borderWidth) {
  gl_Position = position;
  float totalDiameter = diameter + 2.0 * (borderWidth + uCircleParams.z);
  if (diameter == 0.0) totalDiameter = 0.0;
  vec2 circleCornerOffset = getQuadVertexPosition(vec2(-1.0, -1.0), vec2(1.0, 1.0));
  gl_Position.xy += circleCornerOffset * uCircleParams.xy * gl_Position.w * totalDiameter;
  vCircleCoord.xy = circleCornerOffset;
  if (borderWidth == 0.0) {
    vCircleCoord.z = totalDiameter;
    vCircleCoord.w = 1e-6;
  } else {
    vCircleCoord.z = diameter / totalDiameter;
    vCircleCoord.w = uCircleParams.z / totalDiameter;
  }
}
`), e ? i.addFragmentCode(`
float getCircleAlphaMultiplier() {
  return 1.0 - 2.0 * abs(0.5 - gl_FragCoord.z);
}
`) : i.addFragmentCode(`
float getCircleAlphaMultiplier() {
  return 1.0;
}
`), i.addFragmentCode(`
vec4 getCircleColor(vec4 interiorColor, vec4 borderColor) {
  float radius = length(vCircleCoord.xy);
  if (radius > 1.0) {
    discard;
  }

  float borderColorFraction = clamp((radius - vCircleCoord.z) / vCircleCoord.w, 0.0, 1.0);
  float feather = clamp((1.0 - radius) / vCircleCoord.w, 0.0, 1.0);
  vec4 color = mix(interiorColor, borderColor, borderColorFraction);

  return vec4(color.rgb, color.a * feather * getCircleAlphaMultiplier());
}
`);
}
function Fc(i, e, t) {
  i.gl.uniform3f(i.uniform("uCircleParams"), 1 / e.width, 1 / e.height, Math.max(1e-6, t.featherWidthInPixels));
}
function Uc(i, e, t) {
  fS(i, e, t);
}
var dz = class extends X {
  constructor(e) {
    super(), this.lightDirection = new Float32Array([1, 0, 0, 0]), this.sphereHelper = this.registerDisposer(new SI(e, 20, 20));
  }
  defineShader(e) {
    e.addUniform("highp vec4", "uLightDirection"), e.addUniform("highp mat4", "uNormalTransform"), e.addVertexCode(`
float getRadiusAdjustment(vec3 vertex, float r) {
  float radiusAdjustment = 1.0;
  for (int i = 0; i < 3; ++i) {
    if (r != 0.0) {
      float d = vertex[i] - uModelClipBounds[i];
      radiusAdjustment -= d * d / (r * r);
    }
  }

  return sqrt(max(0.1, radiusAdjustment));
}
    `), this.sphereHelper.defineShader(e);
  }
  draw(e, t, n) {
    const r = e.gl;
    r.uniformMatrix4fv(
      e.uniform("uNormalTransform"),
      /*transpose=*/
      false,
      cy(nt(), t.renderSubspaceInvModelMatrix)
    ), r.uniform4f(e.uniform("uLightDirection"), this.lightDirection[0], this.lightDirection[1], this.lightDirection[2], this.lightDirection[3]), this.sphereHelper.draw(e, n);
  }
};
var gs = uS;
function dr(i, e = false) {
  i.addVertexCode(hS), i.addUniform("highp vec3", "uLineParams"), i.addVarying("highp float", "vLineCoord"), i.addVarying("highp float", "vLineFeatherFraction"), e && (i.addVarying("highp float", "vEndpointFraction"), i.addVarying("highp float", "vLineCoordT"), i.addVarying("highp float", "vLineBorderStartFraction")), i.addVertexCode(VB), i.addVertexCode(`
vec2 getLineOffset() { return getQuadVertexPosition(vec2(0.0, -1.0), vec2(1.0, 1.0)); }
float getLineEndpointCoefficient() { return getLineOffset().x; }
uint getLineEndpointIndex() { return uint(getLineEndpointCoefficient()); }
void emitLine(vec4 vertexAClip, vec4 vertexBClip, float lineWidthInPixels
              ${e ? ", float borderWidth" : ""}) {
  if (!clipLineToDepthRange(vertexAClip, vertexBClip)) {
    gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
    return;
  }
  vec3 vertexADevice = vertexAClip.xyz / vertexAClip.w;
  vec3 vertexBDevice = vertexBClip.xyz / vertexBClip.w;

  vec2 lineDirectionUnnormalized = vertexBDevice.xy - vertexADevice.xy;
  vec2 lineDirection;
  float linePixelLength = length(lineDirectionUnnormalized / uLineParams.xy * 0.5);

  if (linePixelLength < 1e-3) {
    lineDirection = vec2(1.0, 0.0);
    vertexADevice.z = vertexBDevice.z = 0.0;
  } else {
    lineDirection = normalize(lineDirectionUnnormalized);
  }
  vec2 lineNormal = normalize(vec2(lineDirection.y, -lineDirection.x) / uLineParams.yx * uLineParams.xy);

  vec2 lineOffset = getLineOffset();
  gl_Position = vec4(mix(vertexADevice, vertexBDevice, lineOffset.x), 1.0);
  float totalLineWidth = lineWidthInPixels + 2.0 * uLineParams.z ${e ? " + 2.0 * borderWidth" : ""};
  if (lineWidthInPixels == 0.0) totalLineWidth = 0.0;
  vLineFeatherFraction = max(1e-6, uLineParams.z) / totalLineWidth;
  gl_Position.xy += (lineOffset.y * lineNormal
                     ${e ? "+ lineDirection * (2.0 * lineOffset.x - 1.0)" : ""})
                  * totalLineWidth * uLineParams.xy;
  vLineCoord = lineOffset.y;
  ${e ? "vEndpointFraction = totalLineWidth / (linePixelLength + totalLineWidth * 2.0);" : ""}
  ${e ? "vLineCoordT = lineOffset.x; vLineBorderStartFraction = lineWidthInPixels / totalLineWidth;" : ""}
}
void emitLine(mat4 projection, vec3 vertexA, vec3 vertexB, float lineWidthInPixels
              ${e ? ", float borderWidth" : ""}) {
  emitLine(projection * vec4(vertexA, 1.0), projection * vec4(vertexB, 1.0),
           lineWidthInPixels
           ${e ? ", borderWidth" : ""});
}
`), e && i.addFragmentCode(`
vec4 getRoundedLineColor(vec4 interiorColor, vec4 borderColor) {
  float radius;
  if (vLineCoordT < vEndpointFraction || vLineCoordT > 1.0 - vEndpointFraction) {
    radius = length(vec2(1.0 - min(vLineCoordT, 1.0 - vLineCoordT) / vEndpointFraction,
                         vLineCoord));
    if (radius > 1.0) {
      discard;
    }
  } else {
    radius = abs(vLineCoord);
  }
  float borderColorFraction = clamp((radius - vLineBorderStartFraction) / vLineFeatherFraction, 0.0, 1.0);
  float feather = clamp((1.0 - radius) / vLineFeatherFraction, 0.0, 1.0);
  vec4 color = mix(interiorColor, borderColor, borderColorFraction);
  return vec4(color.rgb, color.a * feather);
}
`), i.addFragmentCode(`
float getLineAlpha() {
  return clamp((1.0 - abs(vLineCoord)) / vLineFeatherFraction, 0.0, 1.0);
}
`);
}
function ur(i, e, t) {
  fS(i, e, t);
}
function hr(i, e, t) {
  i.gl.uniform3f(i.uniform("uLineParams"), 1 / e.width, 1 / e.height, t);
}
function Ur(i) {
  i.addAttribute("int", "aDummyVertexId", 0), i.addVertexCode(`
int getVertexId () {
  return aDummyVertexId + gl_VertexID;
}
#define gl_VertexID (getVertexId())
`);
}
var fr = class _fr extends X {
  constructor(e) {
    super(), this.buffer = new Qn(e), this.size = 0;
  }
  disposed() {
    this.buffer.dispose();
  }
  enable(e = 256) {
    const t = this.buffer, n = t.gl;
    t.bind(), e > this.size && (this.size = e, n.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, new Int32Array(e), WebGL2RenderingContext.STATIC_DRAW)), n.vertexAttribIPointer(0, 1, WebGL2RenderingContext.INT, 0, 0), n.vertexAttribDivisor(0, 0), n.enableVertexAttribArray(0);
  }
  disable() {
    this.buffer.gl.disableVertexAttribArray(0);
  }
  static get(e) {
    return e.memoize.get("VertexIdHelper", () => new _fr(e));
  }
};
var uz = nt();
var bI = `void main() {
  emitDefault();
}
`;
var Bl = [];
var hz = Oc(new kh(), j.FLOAT32, 3);
var wI = class extends X {
  constructor(e, t) {
    super(), this.base = e, this.targetIsSliceView = t, this.textureAccessHelper = new nS("vertexData"), this.vertexIdHelper = this.registerDisposer(fr.get(this.gl)), this.edgeShaderGetter = vo(this, this.gl, {
      memoizeKey: { type: "skeleton/SkeletonShaderManager/edge", vertexAttributes: this.vertexAttributes },
      fallbackParameters: this.base.fallbackShaderParameters,
      parameters: this.base.displayState.skeletonRenderingOptions.shaderControlState.builderState,
      shaderError: this.base.displayState.shaderError,
      defineShader: (n, r) => {
        if (r.parseResult.errors.length !== 0)
          throw new Error("Invalid UI control specification");
        this.defineCommonShader(n), this.defineAttributeAccess(n), dr(n), n.addAttribute("highp uvec2", "aVertexIndex"), n.addUniform("highp float", "uLineWidth");
        let s = `
highp vec3 vertexA = readAttribute0(aVertexIndex.x);
highp vec3 vertexB = readAttribute0(aVertexIndex.y);
emitLine(uProjection, vertexA, vertexB, uLineWidth);
highp uint lineEndpointIndex = getLineEndpointIndex();
highp uint vertexIndex = aVertexIndex.x * lineEndpointIndex + aVertexIndex.y * (1u - lineEndpointIndex);
`;
        n.addFragmentCode(`
vec4 segmentColor() {
  return uColor;
}
void emitRGB(vec3 color) {
  emit(vec4(color * uColor.a, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);
}
void emitDefault() {
  emit(vec4(uColor.rgb, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);
}
`), n.addFragmentCode(cc);
        const a = this.vertexAttributes, l = a.length;
        for (let d = 1; d < l; ++d) {
          const u = a[d];
          n.addVarying(`highp ${u.glslDataType}`, `vCustom${d}`), s += `vCustom${d} = readAttribute${d}(vertexIndex);
`, n.addFragmentCode(`#define ${u.name} vCustom${d}
`);
        }
        n.setVertexMain(s), lc(r, n), n.setFragmentMainFunction(sc(r.parseResult.code));
      }
    }), this.nodeShaderGetter = vo(this, this.gl, {
      memoizeKey: { type: "skeleton/SkeletonShaderManager/node", vertexAttributes: this.vertexAttributes },
      fallbackParameters: this.base.fallbackShaderParameters,
      parameters: this.base.displayState.skeletonRenderingOptions.shaderControlState.builderState,
      shaderError: this.base.displayState.shaderError,
      defineShader: (n, r) => {
        if (r.parseResult.errors.length !== 0)
          throw new Error("Invalid UI control specification");
        this.defineCommonShader(n), this.defineAttributeAccess(n), Bc(
          n,
          /*crossSectionFade=*/
          this.targetIsSliceView
        ), n.addUniform("highp float", "uNodeDiameter");
        let s = `
highp uint vertexIndex = uint(gl_InstanceID);
highp vec3 vertexPosition = readAttribute0(vertexIndex);
emitCircle(uProjection * vec4(vertexPosition, 1.0), uNodeDiameter, 0.0);
`;
        n.addFragmentCode(`
vec4 segmentColor() {
  return uColor;
}
void emitRGBA(vec4 color) {
  vec4 borderColor = color;
  emit(getCircleColor(color, borderColor), uPickID);
}
void emitRGB(vec3 color) {
  emitRGBA(vec4(color, 1.0));
}
void emitDefault() {
  emitRGBA(uColor);
}
`), n.addFragmentCode(cc);
        const a = this.vertexAttributes, l = a.length;
        for (let d = 1; d < l; ++d) {
          const u = a[d];
          n.addVarying(`highp ${u.glslDataType}`, `vCustom${d}`), s += `vCustom${d} = readAttribute${d}(vertexIndex);
`, n.addFragmentCode(`#define ${u.name} vCustom${d}
`);
        }
        n.setVertexMain(s), lc(r, n), n.setFragmentMainFunction(sc(r.parseResult.code));
      }
    });
  }
  get vertexAttributes() {
    return this.base.vertexAttributes;
  }
  defineCommonShader(e) {
    Ur(e), e.addUniform("highp vec4", "uColor"), e.addUniform("highp mat4", "uProjection"), e.addUniform("highp uint", "uPickID");
  }
  get gl() {
    return this.base.gl;
  }
  defineAttributeAccess(e) {
    const t = this.textureAccessHelper;
    t.defineShader(e);
    const n = this.vertexAttributes.length;
    for (let r = Bl.length; r < n; ++r)
      Bl[r] = li(`SkeletonShader.vertexAttributeTextureUnit${r}`);
    this.vertexAttributes.forEach((r, s) => {
      e.addTextureSampler(`${eS(r.dataType)}sampler2D`, `uVertexAttributeSampler${s}`, Bl[s]), e.addVertexCode(t.getAccessor(`readAttribute${s}`, `uVertexAttributeSampler${s}`, r.dataType, r.numComponents));
    });
  }
  getCrossSectionFadeFactor() {
    return this.targetIsSliceView ? "(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))" : "(1.0)";
  }
  beginLayer(e, t, n, r) {
    const s = n.projectionParameters.viewProjectionMat;
    let a = vn(uz, s, r);
    e.uniformMatrix4fv(t.uniform("uProjection"), false, a), this.vertexIdHelper.enable();
  }
  setColor(e, t, n) {
    e.uniform4fv(t.uniform("uColor"), n);
  }
  setPickID(e, t, n) {
    e.uniform1ui(t.uniform("uPickID"), n);
  }
  drawSkeleton(e, t, n, r, s) {
    const l = this.vertexAttributes.length, d = r.vertexAttributeTextures;
    for (let u = 0; u < l; ++u) {
      const h = WebGL2RenderingContext.TEXTURE0 + t.textureUnit(Bl[u]);
      e.activeTexture(h), e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, d[u]);
    }
    {
      t.bind();
      const u = t.attribute("aVertexIndex");
      r.indexBuffer.bindToVertexAttribI(u, 2, WebGL2RenderingContext.UNSIGNED_INT), e.vertexAttribDivisor(u, 1), hr(t, s, this.targetIsSliceView ? 1 : 0), ur(e, 1, r.numIndices / 2), e.vertexAttribDivisor(u, 0), e.disableVertexAttribArray(u);
    }
    n !== null && (n.bind(), Fc(n, s, { featherWidthInPixels: this.targetIsSliceView ? 1 : 0 }), Uc(n.gl, 2, r.numVertices));
  }
  endLayer(e, t) {
    const r = this.vertexAttributes.length;
    for (let s = 0; s < r; ++s) {
      let a = t.textureUnit(Bl[s]) + WebGL2RenderingContext.TEXTURE0;
      e.activeTexture(a), e.bindTexture(e.TEXTURE_2D, null);
    }
    this.vertexIdHelper.disable();
  }
};
var Io;
(function(i) {
  i[i.LINES = 0] = "LINES", i[i.LINES_AND_POINTS = 1] = "LINES_AND_POINTS";
})(Io || (Io = {}));
var G1 = class extends Eh {
  constructor(e, t = e) {
    super(Io, e, t);
  }
};
var W1 = class extends fn {
  constructor(e, t = e) {
    super(e, yn, t);
  }
};
var fz = class {
  constructor() {
    this.compound = new Ch(), this.shader = _y(bI), this.shaderControlState = new $y(this.shader), this.params2d = {
      mode: new G1(Io.LINES_AND_POINTS),
      lineWidth: new W1(2)
    }, this.params3d = {
      mode: new G1(Io.LINES),
      lineWidth: new W1(1)
    };
    const e = this.compound;
    e.add("shader", this.shader), e.add("shaderControls", this.shaderControlState), e.add("mode2d", this.params2d.mode), e.add("lineWidth2d", this.params2d.lineWidth), e.add("mode3d", this.params3d.mode), e.add("lineWidth3d", this.params3d.lineWidth);
  }
  get changed() {
    return this.compound.changed;
  }
  reset() {
    this.compound.reset();
  }
  restoreState(e) {
    e !== void 0 && this.compound.restoreState(e);
  }
  toJSON() {
    const e = this.compound.toJSON();
    for (const t of iv(e))
      if (t !== void 0) return e;
  }
};
var pz = class extends X {
  constructor(e, t, n) {
    super(), this.chunkManager = e, this.source = t, this.displayState = n, this.layerChunkProgressInfo = new Iy(), this.redrawNeeded = new Le(), this.fallbackShaderParameters = new vt(zy(Sh(bI))), Ih(n, this), this.displayState.shaderError.value = void 0;
    const r = n.skeletonRenderingOptions;
    this.registerDisposer(r.shader.changed.add(() => {
      this.displayState.shaderError.value = void 0, this.redrawNeeded.dispatch();
    }));
    let s = this.sharedObject = this.registerDisposer(new Ph(e, n, this.layerChunkProgressInfo));
    s.RPC_TYPE_ID = oz, s.initializeCounterpartWithChunkManager({
      source: t.addCounterpartRef()
    });
    const a = this.vertexAttributes = [mz];
    for (let d of t.vertexAttributes) {
      var l = de(d, 2);
      let u = l[0], h = l[1];
      a.push({
        name: u,
        dataType: h.dataType,
        numComponents: h.numComponents,
        webglDataType: gz(h.dataType),
        glslDataType: h.numComponents > 1 ? `vec${h.numComponents}` : "float"
      });
    }
  }
  get visibility() {
    return this.sharedObject.visibility;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  draw(e, t, n, r, s) {
    let a = r.lineWidth.value;
    const l = this.gl, d = this.source, u = this.displayState;
    if (u.objectAlpha.value <= 0)
      return;
    const h = yu(u.transform.value, e.projectionParameters.displayDimensionRenderInfo, s);
    if (h === void 0) return;
    let g;
    r.mode.value === Io.LINES_AND_POINTS ? g = Math.max(5, a * 2) : g = a;
    const v = n.edgeShaderGetter(e.emitter), y = n.nodeShaderGetter(e.emitter), C = v.shader, w = v.parameters, b = y.shader, E = y.parameters;
    if (C === null || b === null)
      return;
    const T = this.displayState.skeletonRenderingOptions.shaderControlState;
    C.bind(), n.beginLayer(l, C, e, h), wo(l, C, T, w.parseResult.controls), l.uniform1f(C.uniform("uLineWidth"), a), b.bind(), n.beginLayer(l, b, e, h), l.uniform1f(b.uniform("uNodeDiameter"), g), wo(l, b, T, E.parseResult.controls);
    const I = d.chunks;
    Rh(u, t, e.emitColor, e.emitPickID ? e.pickIDs : void 0, (R, P, L) => {
      const A = ir(R), M = I.get(A);
      M === void 0 || M.state !== kt.GPU_MEMORY || (P !== void 0 && (C.bind(), n.setColor(l, C, P), b.bind(), n.setColor(l, b, P)), L !== void 0 && (C.bind(), n.setPickID(l, C, L), b.bind(), n.setPickID(l, b, L)), n.drawSkeleton(l, C, b, M, e.projectionParameters));
    }), n.endLayer(l, C);
  }
  isReady() {
    const e = this.source, t = this.displayState;
    if (t.objectAlpha.value <= 0)
      return true;
    const n = e.chunks;
    let r = true;
    return $o(t.segmentationGroupState.value, (s) => {
      const a = ir(s), l = n.get(a);
      if (l === void 0 || l.state !== kt.GPU_MEMORY) {
        r = false;
        return;
      }
    }), r;
  }
};
var jg = class extends Ho {
  constructor(e) {
    super(), this.base = e, this.renderHelper = this.registerDisposer(new wI(this.base, false)), this.renderOptions = this.base.displayState.skeletonRenderingOptions.params3d, this.layerChunkProgressInfo = e.layerChunkProgressInfo, this.registerDisposer(e), this.registerDisposer(e.redrawNeeded.add(this.redrawNeeded.dispatch));
    const t = this.renderOptions;
    this.registerDisposer(t.mode.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(t.lineWidth.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(e.visibility.add(this.visibility));
  }
  get gl() {
    return this.base.gl;
  }
  get isTransparent() {
    return this.base.displayState.objectAlpha.value < 1;
  }
  draw(e, t) {
    !e.emitColor && e.alreadyEmittedPickID || this.base.draw(e, this, this.renderHelper, this.renderOptions, t);
  }
  isReady() {
    return this.base.isReady();
  }
};
var H1 = class extends xo {
  constructor(e) {
    super(), this.base = e, this.renderHelper = this.registerDisposer(new wI(this.base, true)), this.renderOptions = this.base.displayState.skeletonRenderingOptions.params2d, this.layerChunkProgressInfo = e.layerChunkProgressInfo, this.registerDisposer(e);
    const t = this.renderOptions;
    this.registerDisposer(t.mode.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(t.lineWidth.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(e.redrawNeeded.add(this.redrawNeeded.dispatch)), this.registerDisposer(e.visibility.add(this.visibility));
  }
  get gl() {
    return this.base.gl;
  }
  draw(e, t) {
    this.base.draw(e, this, this.renderHelper, this.renderOptions, t);
  }
  isReady() {
    return this.base.isReady();
  }
};
function gz(i) {
  switch (i) {
    case j.FLOAT32:
      return WebGL2RenderingContext.FLOAT;
    default:
      throw new Error(`Data type not supported by WebGL: ${j[i]}`);
  }
}
var mz = {
  dataType: j.FLOAT32,
  numComponents: 3,
  name: "",
  webglDataType: WebGL2RenderingContext.FLOAT,
  glslDataType: "vec3"
};
var vz = class extends Ds {
  constructor(e, t) {
    super(e), this.vertexAttributes = t.vertexAttributes;
    let n = this.indices = t.indices;
    this.numVertices = t.numVertices, this.vertexAttributeOffsets = t.vertexAttributeOffsets, this.numIndices = n.length;
  }
  copyToGPU(e) {
    super.copyToGPU(e);
    const t = this.source.attributeTextureFormats, n = this.vertexAttributes, r = this.vertexAttributeOffsets, s = this.vertexAttributeTextures = [];
    for (let a = 0, l = r.length; a < l; ++a) {
      const d = e.createTexture();
      e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, d), tS(e, t[a], n.subarray(r[a], a + 1 !== l ? r[a + 1] : n.length)), s[a] = d;
    }
    e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null), this.indexBuffer = Qn.fromData(e, this.indices, WebGL2RenderingContext.ARRAY_BUFFER, WebGL2RenderingContext.STATIC_DRAW);
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e);
    const t = this.vertexAttributeTextures;
    for (const n of t)
      e.deleteTexture(n);
    t.length = 0, this.indexBuffer.dispose();
  }
};
var yz = new he();
function Sz(i) {
  const e = [hz];
  for (const t of i.values())
    e.push(Oc(new kh(), t.dataType, t.numComponents));
  return e;
}
var _h = class extends Wr {
  constructor(e, t) {
    super(e, t);
  }
  get attributeTextureFormats() {
    let e = this.attributeTextureFormats_;
    return e === void 0 && (e = this.attributeTextureFormats_ = Sz(this.vertexAttributes)), e;
  }
  getChunk(e) {
    return new vz(this, e);
  }
  get vertexAttributes() {
    return yz;
  }
};
function CI(i, e, t, n) {
  const r = e.dataType;
  e.defineShader(i, t);
  let s = "", a = "";
  if (t === 0)
    s += "highp int ignoredChannelIndex";
  else
    for (let d = 0; d < t; ++d)
      d !== 0 && (s += ", "), s += `highp int channelIndex${d}`, a += `, channelIndex${d}`;
  i.addFragmentCode(DB);
  let l = `
${xn(r)} getDataValue(${s}) {
  highp ivec3 p = ivec3(max(vec3(0.0, 0.0, 0.0), min(floor(${n}), uChunkDataSize - 1.0)));
  return getDataValueAt(p${a});
}
${xn(r)} getInterpolatedDataValue(${s}) {
  highp vec3 positionWithinChunk = ${n};
  highp ivec3[2] points;
  points[0] = ivec3(max(vec3(0.0, 0.0, 0.0), min(floor(positionWithinChunk - 0.5), uChunkDataSize - 1.0)));
  points[1] = ivec3(max(vec3(0.0, 0.0, 0.0), min(ceil(positionWithinChunk - 0.5), uChunkDataSize - 1.0)));
  highp vec3 mixCoeff = fract(positionWithinChunk - 0.5);
  ${xn(r)} xvalues[2];
  for (int ix = 0; ix < 2; ++ix) {
    ${xn(r)} yvalues[2];
    for (int iy = 0; iy < 2; ++iy) {
      ${xn(r)} zvalues[2];
      for (int iz = 0; iz < 2; ++iz) {
        zvalues[iz] = getDataValueAt(ivec3(points[ix].x, points[iy].y, points[iz].z)
                                     ${a});
      }
      yvalues[iy] = mixLinear(zvalues[0], zvalues[1], mixCoeff.z);
    }
    xvalues[ix] = mixLinear(yvalues[0], yvalues[1], mixCoeff.y);
  }
  return mixLinear(xvalues[0], xvalues[1], mixCoeff.x);
}
`;
  i.addFragmentCode(l), t <= 1 && i.addFragmentCode(`
${xn(r)} getDataValue() { return getDataValue(0); }
${xn(r)} getInterpolatedDataValue() { return getInterpolatedDataValue(0); }
`);
}
var xI = new Array();
function EI(i) {
  xI.push(i);
}
function bz(i, e) {
  for (let t of xI) {
    let n = t(i, e);
    if (n != null)
      return n;
  }
  throw new Error("No chunk format handler found.");
}
var zc = class extends wD {
  constructor(e, t) {
    super(e, t), this.chunkFormatHandler = this.registerDisposer(bz(e.chunkQueueManager.gl, this.spec));
    const n = this.spec.upperVoxelBound.length;
    this.tempChunkGridPosition = new Float32Array(n), this.tempPositionWithinChunk = new Uint32Array(n);
  }
  static encodeSpec(e) {
    const t = e;
    return H(H({}, super.encodeSpec(e)), { dataType: t.dataType, compressedSegmentationBlockSize: t.compressedSegmentationBlockSize && _e(t.compressedSegmentationBlockSize), baseVoxelOffset: _e(t.baseVoxelOffset) });
  }
  get chunkFormat() {
    return this.chunkFormatHandler.chunkFormat;
  }
  getValueAt(e, t) {
    const n = this.spec.rank, r = this.tempChunkGridPosition, s = this.tempPositionWithinChunk, a = this.spec;
    {
      const w = a.chunkDataSize;
      for (let b = 0; b < n; ++b) {
        const E = e[b], T = w[b], I = Math.floor(E / T);
        r[b] = I, s[b] = Math.floor(E - T * I);
      }
    }
    const l = this.chunks.get(r.join());
    if (l === void 0)
      return null;
    const d = l.chunkDataSize;
    for (let w = 0; w < 3; ++w)
      if (s[w] >= d[w])
        return;
    if (t.channelSpaceShape.length === 0)
      return l.getValueAt(s);
    const u = t.numChannels, h = t.chunkChannelCoordinates, g = t.chunkChannelDimensionIndices, v = g.length;
    let y = 0;
    const C = new Array(u);
    for (let w = 0; w < u; ++w) {
      for (let b = 0; b < v; ++b)
        s[g[b]] = h[y++];
      C[w] = l.getValueAt(s);
    }
    return C;
  }
  getChunk(e) {
    return this.chunkFormatHandler.getChunk(this, e);
  }
};
var wz = class extends CD {
  constructor(e, t) {
    super(e, t), this.chunkDataSize = t.chunkDataSize || e.spec.chunkDataSize;
  }
  get chunkFormat() {
    return this.source.chunkFormat;
  }
};
var Ps = class extends ZF {
};
var Lu = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='plusIconTitle'%3e%3ctitle%20id='plusIconTitle'%3ePlus%3c/title%3e%3cpath%20d='M20%2012L4%2012M12%204L12%2020'/%3e%3c/svg%3e";
function kI(i = {}) {
  return Tt(H({ svg: Lu }, i));
}
var Cz = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='arrowUpIconTitle'%3e%3ctitle%20id='arrowUpIconTitle'%3eArrow%20Up%3c/title%3e%3cpath%20d='M18%209l-6-6-6%206'/%3e%3cpath%20d='M12%2021V4'/%3e%3cpath%20stroke-linecap='round'%20d='M12%203v1'/%3e%3c/svg%3e";
var Du = new vt(0);
window.addEventListener("keydown", (i) => {
  Du.value = rS(i);
});
window.addEventListener("keyup", (i) => {
  Du.value = rS(i);
});
var xz = new Ye(["f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "escape", "pause"]);
var Ez = new Ye(["color", "date", "datetime", "datetime-local", "email", "month", "number", "password", "search", "tel", "text", "time", "url", "week"]);
var Gi = class extends X {
  constructor(e, t) {
    super(), this.target = e, this.eventMap = t, this.modifierShortcutsAreGlobal = true, this.allShortcutsAreGlobal = false, this.allowSpaceKeyOnButtons = false, this.registerEventListener(
      e,
      "keydown",
      this.handleKeyDown.bind(this),
      /*useCapture=*/
      false
    );
  }
  shouldIgnoreEvent(e, t) {
    var n = t.target;
    let r = n.tagName;
    if (n === this.target)
      return false;
    var s = r === "TEXTAREA" || r === "INPUT" || r === "BUTTON" || r === "SELECT", a = !s && (n.isContentEditable || n.ownerDocument && n.ownerDocument.designMode === "on");
    return !s && !a || this.allShortcutsAreGlobal || xz.has(e) ? false : a || this.modifierShortcutsAreGlobal && (t.altKey || t.ctrlKey || t.metaKey) ? true : r === "INPUT" && Ez.has(n.type) ? e !== "enter" : r === "INPUT" || r === "BUTTON" ? this.allowSpaceKeyOnButtons ? false : e === "space" : true;
  }
  handleKeyDown(e) {
    const t = kz(e);
    this.shouldIgnoreEvent(t, e) || rI2(t, e, e, this.eventMap);
  }
};
function kz(i) {
  return i.code.toLowerCase();
}
function Fl(i, e = i.value) {
  i.style.minWidth = e.length + 1 + "ch";
}
var q1 = "neuroglancer-coordinate-space-transform-singleton";
function j1(i, e) {
  let t;
  i === Number.NEGATIVE_INFINITY ? t = "(-∞," : t = `[${Math.floor(i)},`;
  let n;
  return e === Number.POSITIVE_INFINITY ? n = "+∞)" : n = `${Math.floor(e)})`, { lower: t, upper: n };
}
var J1 = St.fromObject({
  arrowup: { action: "move-up" },
  arrowdown: { action: "move-down" },
  arrowleft: { action: "move-left", preventDefault: false },
  arrowright: { action: "move-right", preventDefault: false },
  enter: { action: "commit" },
  escape: { action: "cancel" }
});
function K1() {
  const i = document.createElement("div"), e = document.createElement("input");
  i.classList.add("neuroglancer-coordinate-space-transform-scale-container"), e.spellcheck = false, e.autocomplete = "off", e.size = 1, e.classList.add("neuroglancer-coordinate-space-transform-scale"), i.appendChild(e);
  const t = document.createElement("div"), n = document.createElement("span");
  n.innerHTML = Cz, t.appendChild(n);
  const r = document.createTextNode("");
  return t.appendChild(r), t.classList.add("neuroglancer-coordinate-space-transform-scale-suggestion"), i.appendChild(t), { cellElement: i, inputElement: e, suggestionElement: t };
}
function Y1(i, e, t, n, r) {
  if (e === void 0 || e.scale === t && e.unit === n)
    i.style.display = "none";
  else {
    i.style.display = "";
    const s = ia(e.scale, e.unit, { elide1: false });
    i.lastChild.textContent = s, i.title = `${r}${s}`;
  }
}
function X1() {
  const i = document.createElement("input");
  return i.spellcheck = false, i.autocomplete = "off", i.size = 1, i.placeholder = " ", i.classList.add("neuroglancer-coordinate-space-transform-output-name"), i;
}
function Z1(i, e, t) {
  const n = i.map((v) => nc(v.value));
  if (n.includes(void 0))
    return false;
  const r = Float64Array.from(n, (v) => v.scale), s = _e(n, (v) => v.unit), a = t.value, l = a.scales, d = a.units, u = a.rank;
  for (let v = 0; v < u; ++v)
    e[v] || (r[v] = l[v], s[v] = d[v]);
  if (He(l, r) && He(d, s)) return false;
  const h = a.timestamps.map((v, y) => r[y] === l[y] && s[y] === d[y] ? v : Date.now()), g = yt({
    valid: a.valid,
    rank: a.rank,
    scales: r,
    units: s,
    timestamps: h,
    ids: a.ids,
    names: a.names,
    boundingBoxes: a.boundingBoxes,
    coordinateArrays: a.coordinateArrays
  });
  return t.value = g, true;
}
function Q1(i, e, t, n) {
  const r = new Float64Array(i.scales), s = _e(i.units);
  if (r[e] === t && s[e] === n) return i;
  const a = _e(i.timestamps);
  return r[e] = t, s[e] = n, a[e] = Date.now(), H(H({}, i), { scales: r, units: s, timestamps: a });
}
var Tz = class extends X {
  constructor(e, t, n) {
    super(), this.transform = e, this.localCombiner = t, this.globalCombiner = n, this.element = document.createElement("div"), this.coefficientContainer = document.createElement("div"), this.translationContainer = document.createElement("div"), this.outputNameContainer = document.createElement("div"), this.outputScaleContainer = document.createElement("div"), this.inputNameContainer = document.createElement("div"), this.inputScaleContainer = document.createElement("div"), this.inputLowerBoundsContainer = document.createElement("div"), this.inputUpperBoundsContainer = document.createElement("div"), this.coefficientElements = [], this.inputNameElements = [], this.outputNameElements = [], this.outputScaleElements = [], this.outputScaleSuggestionElements = [], this.inputScaleSuggestionElements = [], this.inputScaleElements = [], this.inputBoundsElements = [], this.outputBoundsElements = [], this.addSourceDimensionIcon = Tt({ svg: Lu, text: "S" }), this.addOutputDimensionIcon = Tt({ svg: Lu, text: "V" }), this.addOutputDimensionCell = document.createElement("div"), this.addOutputDimensionInput = X1(), this.inputScaleModified = [], this.outputScaleModified = [], this.curSourceRank = -1, this.curRank = -1, this.curTransform = void 0, this.addingSourceDimension = false, this.resetToIdentityButton = Tt({
      text: "Set to identity",
      title: "Reset to identity transform",
      onClick: () => {
        const F = this.transform, q = F.value.rank;
        F.transform = ks(Float64Array, q + 1);
      }
    }), this.resetToDefaultButton = Tt({
      text: "Reset to default",
      title: "Reset to default input scales, transform, and output dimensions.",
      onClick: () => {
        const F = this.transform;
        if (F.mutableSourceRank) return;
        const q = F.defaultTransform;
        let U = q.outputSpace;
        const V = U.ids.map(() => to());
        F.value = H(H({}, q), { outputSpace: H(H({}, U), { ids: V }) });
      }
    });
    const r = this.element, s = this.registerDisposer(new Gi(r, J1));
    s.allShortcutsAreGlobal = true, r.classList.add("neuroglancer-coordinate-space-transform-widget"), this.registerDisposer(new Hr(r, J1));
    const a = Ct(() => this.updateView());
    this.registerDisposer(e.changed.add(a));
    const l = this.coefficientContainer, d = this.translationContainer, u = this.outputNameContainer, h = this.inputNameContainer, g = this.inputScaleContainer, v = this.inputLowerBoundsContainer, y = this.inputUpperBoundsContainer, C = this.outputScaleContainer, w = this.addOutputDimensionCell, b = this.addOutputDimensionIcon, E = this.addSourceDimensionIcon, T = this.resetToIdentityButton, I = this.resetToDefaultButton;
    l.style.display = "contents", d.style.display = "contents", u.style.display = "contents", h.style.display = "contents", g.style.display = "contents", C.style.display = "contents", v.style.display = "contents", y.style.display = "contents";
    const R = document.createElement("div");
    R.classList.add("neuroglancer-coordinate-space-transform-widget-reset-buttons"), T.classList.add("neuroglancer-coordinate-space-transform-widget-reset-to-identity"), I.classList.add("neuroglancer-coordinate-space-transform-widget-reset-to-default"), R.appendChild(T), R.appendChild(I), r.appendChild(R);
    for (const F of [["source", "Source dimensions"], ["output", "Output dimensions"], ["input-lower", "Lower"], ["input-upper", "Upper"], ["input-scale", "Scale"], ["translation", "Translation"]]) {
      var P = de(F, 2);
      const q = P[0], U = P[1], V = document.createElement("div");
      V.classList.add(`neuroglancer-coordinate-space-transform-${q}-label`), V.classList.add("neuroglancer-coordinate-space-transform-label"), V.textContent = U, r.appendChild(V);
    }
    e.mutableSourceRank && w.appendChild(E), w.appendChild(b), w.classList.add("neuroglancer-coordinate-space-transform-output-extend");
    const L = "Embed in additional output dimension", A = "Extend to additional source dimension";
    b.title = L, E.title = A, w.appendChild(this.addOutputDimensionInput), w.dataset.isActive = "false", b.addEventListener("click", () => {
      this.addingSourceDimension = false, this.addOutputDimensionInput.title = L, this.addOutputDimensionCell.dataset.isActive = "true", this.addOutputDimensionInput.focus();
    }), E.addEventListener("click", () => {
      this.addingSourceDimension = true, this.addOutputDimensionInput.title = A, this.addOutputDimensionCell.dataset.isActive = "true", this.addOutputDimensionInput.focus();
    }), this.addOutputDimensionInput.addEventListener("blur", () => {
      this.updateAddOutputDimensionCellStyle();
    }), r.appendChild(l), r.appendChild(u), r.appendChild(h), r.appendChild(g), r.appendChild(C), r.appendChild(v), r.appendChild(y), l.appendChild(d), r.addEventListener("input", (F) => {
      const q = F.target;
      if (q instanceof HTMLInputElement) {
        Fl(q);
        let U = this.inputScaleElements.indexOf(q);
        if (U !== -1) {
          this.inputScaleModified[U] = true, this.updateScaleValidity(q);
          return;
        }
        if (U = this.outputScaleElements.indexOf(q), U !== -1) {
          this.outputScaleModified[U] = true, this.updateScaleValidity(q);
          return;
        }
        if (U = this.outputNameElements.indexOf(q), U !== -1) {
          this.updateOutputNameValidity();
          return;
        }
        if (this.coefficientContainer.contains(q)) {
          this.updateCoefficientValidity(q);
          return;
        }
      }
    });
    const M = (F, q, U) => {
      Ce(r, F, (V) => {
        V.stopPropagation();
        const $ = V.target;
        if (!($ instanceof HTMLInputElement) || U !== 0 && ($.selectionStart !== $.selectionEnd || $.selectionStart !== (U === 1 ? $.value.length : 0)))
          return;
        const B = this.getElementGridPosition($);
        if (B === void 0) return;
        const ue = this.getElementByGridPosition(B.row + q, B.col + U);
        ue !== null && (ue.focus(), V.preventDefault());
      });
    };
    M("move-up", -1, 0), M("move-down", 1, 0), M("move-left", 0, -1), M("move-right", 0, 1);
    const O = (F, q) => {
      F.addEventListener("focusout", (U) => {
        const V = U.relatedTarget;
        V instanceof Node && F.contains(V) || q(U);
      });
    };
    O(l, () => {
      this.updateModelTransform() || this.updateViewTransformCoefficients();
    }), O(u, () => {
      this.updateModelOutputNames() || this.updateViewOutputNames();
    }), O(g, () => {
      this.updateModelInputScales() || this.updateViewInputScales();
    }), O(C, () => {
      this.updateModelOutputScales() || this.updateViewOutputScales();
    }), Ce(r, "cancel", (F) => {
      this.curTransform = void 0, this.updateView(), F.target.blur();
    }), Ce(l, "commit", () => {
      this.updateModelTransform();
    }), Ce(u, "commit", () => {
      this.updateModelOutputNames();
    }), Ce(g, "commit", () => {
      this.updateModelInputScales();
    }), Ce(C, "commit", () => {
      this.updateModelOutputScales();
    }), r.addEventListener("focusin", (F) => {
      const q = F.target;
      q instanceof HTMLInputElement && q.select();
    }), this.updateView();
  }
  updateWillBeDeletedAttributes(e) {
    const t = this.transform.value.rank;
    e === void 0 && (e = new Array(t), e.fill(false));
    const n = this.coefficientElements, r = this.inputBoundsElements, s = this.inputScaleElements;
    for (let l = 0; l < t; ++l) {
      const d = e[l];
      for (let g = 0; g <= t; ++g) {
        const v = n[t * g + l], y = g < t && e[g];
        v.dataset.willBeDeleted = (d || y).toString();
      }
      s[l].dataset.willBeDeleted = d.toString();
      var a = r[l];
      const u = a.lower, h = a.upper;
      u.dataset.willBeDeleted = d.toString(), h.dataset.willBeDeleted = d.toString();
    }
  }
  updateAddOutputDimensionCellStyle() {
    const e = this.addOutputDimensionInput;
    this.addOutputDimensionCell.dataset.isActive = (e.value.length !== 0 || document.activeElement === e).toString();
  }
  updateOutputNameValidity() {
    const e = this.outputNameElements, t = e.map((h) => h.value);
    var n = this.transform, r = n.value;
    const s = r.sourceRank, a = r.rank, l = n.mutableSourceRank;
    if (e.length !== a + 1) return;
    const d = Ty(t);
    let u = new Array(a);
    u.fill(false);
    for (let h = 0; h <= a; ++h) {
      let g = d[h];
      t[h].length === 0 && (l || h >= s) && (g = true, u[h] = true), e[h].dataset.isValid = g.toString();
    }
    this.updateWillBeDeletedAttributes(u), this.updateAddOutputDimensionCellStyle();
  }
  updateScaleValidity(e) {
    const t = nc(e.value) !== void 0;
    e.dataset.isValid = t.toString();
  }
  updateCoefficientValidity(e) {
    const t = Lt(Number(e.value));
    e.dataset.isValid = t.toString();
  }
  getElementGridPosition(e) {
    {
      const t = this.outputNameElements.indexOf(e);
      if (t !== -1)
        return { row: t, col: -2 };
    }
    {
      const t = this.inputScaleElements.indexOf(e);
      if (t !== -1)
        return { row: -1, col: t };
    }
    {
      const t = this.coefficientElements.indexOf(e), n = this.transform.value.rank;
      if (t !== -1)
        return { row: t % n, col: Math.floor(t / n) };
    }
    {
      const t = this.outputScaleElements.indexOf(e);
      if (t !== -1)
        return { row: t, col: -1 };
    }
  }
  getElementByGridPosition(e, t) {
    const n = this.transform.value.rank;
    return e === -1 ? t < 0 || t >= n ? null : this.inputScaleElements[t] : t === -2 ? e < 0 || e > n ? null : this.outputNameElements[e] : t === -1 ? e < 0 || e >= n ? null : this.outputScaleElements[e] : e < 0 || e >= n || t < 0 || t > n ? null : this.coefficientElements[t * n + e];
  }
  dimensionRefCount(e) {
    return (ql(e) ? this.localCombiner : this.globalCombiner).dimensionRefCounts.get(e) || 0;
  }
  updateModelInputScales() {
    return Z1(this.inputScaleElements, this.inputScaleModified, this.transform.inputSpace);
  }
  updateModelOutputScales() {
    return Z1(this.outputScaleElements, this.outputScaleModified, this.transform.outputSpace);
  }
  updateModelOutputNames() {
    const e = this.outputNameElements.map((I) => I.value);
    var t = this.transform;
    const n = t.value, r = t.mutableSourceRank, s = n.outputSpace, a = n.rank, l = n.sourceRank;
    if (e.length !== a + 1) return;
    const d = [], u = [], h = e[a].length !== 0;
    let g = l;
    for (let I = 0; I <= a; ++I) {
      const R = e[I];
      if (R.length === 0) {
        if (I < l) {
          if (!r) return false;
          --g;
        }
        continue;
      }
      u.push(R), d.push(I);
    }
    if (!fh(u)) return false;
    const v = s.names;
    if (!h && He(v, u))
      return true;
    let y = n.inputSpace, C = n.outputSpace, w = n.transform;
    if (h) {
      this.addingSourceDimension && ++g;
      const I = e[a], R = (ql(I) ? this.localCombiner : this.globalCombiner).combined.value, P = R.names.indexOf(I);
      let L, A;
      P !== -1 ? (L = R.units[P], A = R.scales[P]) : (L = "", A = 1);
      const M = y.boundingBoxes.map((O) => hL(O, a, a + 1));
      this.addingSourceDimension || M.push(uL(a + 1, a)), y = yt({
        valid: y.valid,
        rank: a + 1,
        names: [...y.names, ""],
        ids: [...y.ids, to()],
        timestamps: [...y.timestamps, Date.now()],
        scales: Float64Array.from([...y.scales, A]),
        units: [...y.units, L],
        boundingBoxes: M,
        coordinateArrays: [...y.coordinateArrays, void 0]
      }), C = yt({
        valid: s.valid,
        rank: a + 1,
        names: [...s.names, I],
        ids: [...s.ids, to()],
        timestamps: [...s.timestamps, Date.now()],
        scales: Float64Array.from([...s.scales, A]),
        units: [...s.units, L],
        coordinateArrays: [...s.coordinateArrays, void 0]
      }), w = by(new Float64Array((a + 2) ** 2), a + 1, w, a);
    }
    w = mL(Float64Array, w, y.rank, d, d), y = Vm(y, d), C = Vm(C, d);
    const b = C.ids.map((I, R) => {
      const P = d[R];
      if (P === a) return I;
      const L = u[R], A = v[P];
      return L === A || this.dimensionRefCount(A) === 1 && this.dimensionRefCount(L) === (v.includes(L) ? 1 : 0) ? I : to();
    }), E = C.timestamps.map((I, R) => {
      const P = d[R];
      return P === a || u[R] === v[P] ? I : Date.now();
    });
    C = H(H({}, C), {
      names: u,
      ids: b,
      timestamps: E
    });
    let T = {
      rank: C.rank,
      sourceRank: g,
      outputSpace: C,
      inputSpace: y,
      transform: w
    };
    return this.transform.value = T, true;
  }
  updateModelTransform() {
    const e = this.coefficientElements, t = this.transform.value.rank, n = new Float64Array((t + 1) ** 2);
    n[n.length - 1] = 1;
    for (let r = 0; r < t; ++r)
      for (let s = 0; s <= t; ++s) {
        const a = e[s * t + r], l = parseFloat(a.value);
        if (!Lt(l))
          return false;
        n[s * (t + 1) + r] = l;
      }
    return this.transform.transform = n, true;
  }
  updateViewOutputNames() {
    var e = this.transform.value;
    const t = e.outputSpace, n = e.rank;
    if (n !== this.curRank) return;
    const r = this.outputNameElements, s = t.names;
    for (let a = 0; a < n; ++a) {
      const l = r[a];
      l.value = s[a], l.dataset.isValid = "true", Fl(l);
    }
    r[n].value = "", this.updateWillBeDeletedAttributes();
  }
  updateViewTransformCoefficients() {
    var e = this.transform.value;
    const t = e.transform, n = e.rank, r = this.coefficientElements;
    for (let s = 0; s < n; ++s)
      for (let a = 0; a <= n; ++a) {
        const l = r[a * n + s];
        l.value = t[a * (n + 1) + s].toString(), l.dataset.isValid = "true", Fl(l);
      }
  }
  ensureViewRankUpdated() {
    const e = this.transform.value, t = e.rank, n = e.sourceRank;
    if (this.curSourceRank === n && this.curRank === t)
      return;
    const r = this.inputBoundsElements, s = this.inputNameElements, a = this.inputScaleElements, l = this.element, d = this.coefficientElements, u = this.outputNameElements, h = this.outputScaleElements, g = this.outputScaleSuggestionElements, v = this.inputScaleSuggestionElements, y = this.outputBoundsElements, C = this.coefficientContainer, w = this.translationContainer, b = this.outputNameContainer, E = this.inputNameContainer, T = this.inputScaleContainer, I = this.inputLowerBoundsContainer, R = this.inputUpperBoundsContainer, P = this.outputScaleContainer;
    l.style.gridTemplateColumns = `[outputLabel headerStart] min-content [outputNames] 1fr [outputScales] 1fr [headerEnd] repeat(${Math.max(1, t) + 1}, [sourceDim] 1fr)`, l.style.gridTemplateRows = `[sourceLabel headerStart] auto [sourceNames] auto [sourceLower] auto [sourceUpper] auto [sourceScales] auto [headerEnd]repeat(${t + 1}, [outputDim] auto)`, st(C), st(w), C.appendChild(w), st(b), st(E), st(T), st(I), st(R), st(P), s.length = 0, a.length = 0, r.length = 0, h.length = 0, g.length = 0, v.length = 0, d.length = 0, u.length = 0, y.length = 0;
    for (let M = 0; M < t; ++M) {
      const O = (F) => {
        F.classList.add("neuroglancer-coordinate-space-transform-input"), M >= n && F.classList.add(q1);
      };
      {
        const F = document.createElement("div");
        F.classList.add("neuroglancer-coordinate-space-transform-input-name"), O(F), F.style.gridRowStart = "sourceNames", F.style.gridColumnStart = `sourceDim ${M + 1}`, E.appendChild(F), s.push(F);
      }
      {
        var L = K1();
        const F = L.cellElement, q = L.inputElement, U = L.suggestionElement;
        F.classList.add("neuroglancer-coordinate-space-transform-input-scale-container"), O(F), F.style.gridRowStart = "sourceScales", F.style.gridColumnStart = `sourceDim ${M + 1}`, T.appendChild(F), a.push(q), v.push(U);
        const V = M;
        U.addEventListener("click", () => {
          const $ = KC(this.transform, V);
          $ !== void 0 && (this.transform.inputSpace.value = Q1(this.transform.inputSpace.value, V, $.scale, $.unit));
        });
      }
      {
        const F = document.createElement("div");
        O(F), F.classList.add("neuroglancer-coordinate-space-transform-input-bounds"), F.style.gridRowStart = "sourceLower", F.style.gridColumnStart = `sourceDim ${M + 1}`, I.appendChild(F);
        const q = document.createElement("div");
        O(q), q.classList.add("neuroglancer-coordinate-space-transform-input-bounds"), q.style.gridRowStart = "sourceUpper", q.style.gridColumnStart = `sourceDim ${M + 1}`, R.appendChild(q), r.push({ lower: F, upper: q });
      }
    }
    for (let M = 0; M < t; ++M) {
      for (let O = 0; O <= t; ++O) {
        const F = document.createElement("input");
        F.classList.add("neuroglancer-coordinate-space-transform-coeff"), F.spellcheck = false, F.autocomplete = "off", F.size = 1, F.style.gridRowStart = `outputDim ${M + 1}`, F.placeholder = " ", F.style.gridColumnStart = `sourceDim ${O + 1}`, d[O * t + M] = F, O === t ? F.classList.add("neuroglancer-coordinate-space-transform-translation-coeff") : O == n && F.classList.add(q1), (O === t ? w : C).appendChild(F);
      }
      {
        var A = K1();
        const O = A.cellElement, F = A.suggestionElement, q = A.inputElement;
        O.classList.add("neuroglancer-coordinate-space-transform-output-scale-container"), O.style.gridRowStart = `outputDim ${M + 1}`, O.style.gridColumnStart = "outputScales";
        const U = M;
        F.addEventListener("click", () => {
          const V = this.transform.value, $ = JC(V, U);
          $ !== void 0 && (this.transform.outputSpace.value = Q1(V.outputSpace, U, $.scale, $.unit));
        }), g.push(F), P.appendChild(O), h.push(q);
      }
      {
        const O = document.createElement("div");
        O.classList.add("neuroglancer-coordinate-space-transform-output-name-container"), O.style.gridRowStart = `outputDim ${M + 1}`, O.style.gridColumnStart = "outputNames";
        const F = X1();
        F.title = "Rebind to a different dimension", M >= n ? F.title += ", or delete to remove singleton dimension" : this.transform.mutableSourceRank && (F.title += ", or delete to remove source dimension"), F.title += ".  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).", u.push(F), b.appendChild(O), O.appendChild(F);
        const q = document.createElement("div");
        q.classList.add("neuroglancer-coordinate-space-transform-output-bounds"), O.appendChild(q);
        const U = document.createElement("div");
        U.classList.add("neuroglancer-coordinate-space-transform-output-bounds"), O.appendChild(U), y.push({ lower: q, upper: U }), O.addEventListener("mousedown", (V) => {
          V.target !== F && (F.focus(), V.preventDefault());
        });
      }
    }
    u.push(this.addOutputDimensionInput), this.addOutputDimensionInput.value = "", b.appendChild(this.addOutputDimensionCell), this.curSourceRank = n, this.curRank = t;
  }
  updateViewInputScales() {
    this.ensureViewRankUpdated(), this.inputScaleModified.length = 0;
    var e = this.transform.value;
    const t = e.inputSpace, n = e.rank, r = e.sourceRank, s = this.inputBoundsElements, a = this.inputNameElements, l = this.inputScaleElements, d = this.inputScaleSuggestionElements, u = t.names, h = t.scales, g = t.units;
    var v = t.bounds;
    const y = v.lowerBounds, C = v.upperBounds;
    for (let b = 0; b < n; ++b) {
      const E = l[b], T = h[b], I = g[b];
      E.value = ia(T, I, { elide1: false }), E.dataset.isValid = "true", Fl(E);
      let R;
      if (b < r) {
        let M = u[b];
        M || (M = `${b}`), a[b].textContent = M, R = `source dimension ${M}`, E.title = `Override scale of ${R}`;
      } else
        R = "singleton dimension", E.title = `Set extent of ${R}`;
      var w = j1(y[b], C[b]);
      const P = w.lower, L = w.upper, A = s[b];
      A.lower.textContent = P, A.lower.title = `Lower bound of ${R}`, A.upper.title = `Upper bound of ${R}`, A.upper.textContent = L, Y1(d[b], KC(this.transform, b), T, I, `Revert scale of ${R} to `);
    }
  }
  updateViewOutputScales() {
    const e = this.transform.value;
    var t = e.outputSpace;
    const n = t.rank, r = t.names, s = t.units, a = t.scales;
    var l = t.bounds;
    const d = l.lowerBounds, u = l.upperBounds, h = this.outputScaleElements, g = this.outputBoundsElements, v = this.outputScaleSuggestionElements;
    for (let C = 0; C < n; ++C) {
      const w = h[C], b = a[C], E = s[C];
      w.value = ia(b, E, { elide1: false }), Fl(w);
      const T = r[C];
      w.dataset.isValid = "true";
      const I = `Change coordinates of ${ql(T) ? "local" : "global"} dimension ${T}`;
      w.title = `${I} (does not rescale the source)`;
      var y = j1(d[C], u[C]);
      const R = y.lower, P = y.upper, L = g[C];
      L.lower.textContent = R, L.upper.textContent = P, Y1(v[C], JC(e, C), b, E, `${I} to inferred scale of `);
    }
  }
  updateResetButtonVisibility(e = false, t = false) {
    var n = this.transform;
    const r = n.value, s = n.mutableSourceRank, a = n.defaultTransform, l = r.rank;
    this.resetToIdentityButton.style.visibility = e || !VO(r.transform, l + 1, l + 1) ? "visible" : "hidden", this.resetToDefaultButton.style.visibility = !s && (e || t || !rV(a, r)) ? "visible" : "hidden";
  }
  updateView() {
    const e = this.transform.value;
    this.curTransform !== e && (this.curTransform = e, this.ensureViewRankUpdated(), this.updateViewInputScales(), this.updateViewOutputNames(), this.updateViewTransformCoefficients(), this.updateViewOutputScales(), this.updateAddOutputDimensionCellStyle(), this.updateResetButtonVisibility());
  }
  disposed() {
    Ut(this.element), super.disposed();
  }
};
function Lz(i, e, { horizontal: t = false, vertical: n = true, topMargin: r = 6, bottomMargin: s = 6, leftMargin: a = 6, rightMargin: l = 6, maxHeight: d = true, maxWidth: u = true } = {}) {
  const h = e.getBoundingClientRect();
  if (t) {
    const g = i.ownerDocument.documentElement.clientWidth;
    let v = h.right, y = g - h.left;
    v > y ? (i.style.left = "", i.style.right = `${g - h.right}px`, u && (i.style.maxWidth = v - a + "px")) : (i.style.right = "", i.style.left = `${h.left}px`, u && (i.style.maxWidth = y - l + "px"));
  }
  if (n) {
    const g = i.ownerDocument.documentElement.clientHeight;
    let v = h.top - r, y = g - h.bottom - s;
    i.style.left = `${h.left}px`, i.style.width = `${h.width}px`, v > y * 3 ? (i.style.top = "", i.style.bottom = `${g - h.top}px`, d && (i.style.maxHeight = v + "px")) : (i.style.top = `${h.bottom}px`, i.style.bottom = "", d && (i.style.maxHeight = y + "px"));
  }
}
function Dz(i) {
  let e = oy(i);
  var t = e.next();
  let n = t.value;
  if (t.done)
    return "";
  let s = n.length;
  for (; s > 0; ) {
    var a = e.next();
    let l = a.value;
    if (a.done)
      break;
    let u = 0;
    for (; u < s && n.charCodeAt(u) === l.charCodeAt(u); ++u)
      ;
    s = u;
  }
  return n.substring(0, s);
}
var eE = 10;
var Od = 0.5;
var Iz = class {
  constructor() {
    this.anchorIndex = 0, this.anchorClientOffset = 0;
  }
  splice(e) {
    let t = this.anchorIndex, n = 0;
    for (const r of e) {
      if (n += r.retainCount, t < n) break;
      const s = r.deleteCount;
      if (t < n + s) {
        t = n;
        break;
      }
      const a = r.insertCount;
      t = t - s + a, n += a - a;
    }
    this.anchorIndex = t;
  }
};
var tE = class {
  constructor() {
    this.startIndex = 0, this.endIndex = 0, this.anchorIndex = 0, this.anchorOffset = 0, this.scrollOffset = 0;
  }
};
var Pz = class {
  constructor() {
    this.itemSize = [], this.totalKnownSize = 0, this.numItemsInTotalKnownSize = 0;
  }
  get averageSize() {
    return this.totalKnownSize / this.numItemsInTotalKnownSize;
  }
  getEstimatedSize(e) {
    var t;
    return (t = this.itemSize[e]) !== null && t !== void 0 ? t : this.averageSize;
  }
  getEstimatedTotalSize() {
    return this.totalKnownSize / this.numItemsInTotalKnownSize * this.itemSize.length;
  }
  getEstimatedOffset(e, t = 0, n = 0) {
    for (; t < e; ++t)
      n += this.getEstimatedSize(t);
    for (; t > e; --t)
      n -= this.getEstimatedSize(t - 1);
    return n;
  }
  getRangeSize(e, t) {
    var n;
    let r = 0;
    const s = this.itemSize, a = this.averageSize;
    for (let l = e; l < t; ++l)
      r += (n = s[l]) !== null && n !== void 0 ? n : a;
    return r;
  }
  splice(e) {
    let t = this.itemSize;
    t = this.itemSize = qM(t, e), this.totalKnownSize = t.reduce((n, r) => n + r, 0), this.numItemsInTotalKnownSize = t.reduce((n) => n + 1, 0);
  }
};
function Rz(i, e, t, n, r, s) {
  let a = s.anchorIndex, l = s.anchorClientOffset, d = r.getEstimatedOffset(a), u, h, g, v, y;
  if (n === 0 || r.totalKnownSize === 0)
    u = Math.max(0, a - eE / 2), h = Math.min(t, u + eE), y = a, g = 0, v = l;
  else {
    const C = r.getEstimatedTotalSize(), w = Math.max(0, C - n);
    v = d - l, v = Math.max(0, Math.min(w, v));
    const b = v - 2 * Od * n, E = v - Od * n, T = v + n + Od * n, I = d - l + n + 2 * Od * n;
    u = Math.min(t, e.startIndex);
    let R = r.getEstimatedOffset(u, a, d);
    if (R < b)
      for (; u + 1 < t; ++u) {
        const L = r.getEstimatedSize(u);
        if (R + L >= E) break;
        R += L;
      }
    if (R >= E)
      for (; R > b && u > 0; --u) {
        const L = r.getEstimatedSize(u - 1);
        R -= L;
      }
    h = Math.min(t, e.endIndex);
    let P = r.getEstimatedOffset(h, a, d);
    if (P < T)
      for (; P <= I && h + 1 <= t; ++h) {
        const L = r.getEstimatedSize(h);
        P += L;
      }
    else if (P >= I)
      for (; h > u; --h) {
        const L = r.getEstimatedSize(h - 1);
        if (P - L < T) break;
        P -= L;
      }
    for (y = a, g = d; y < u; ++y) {
      const L = r.getEstimatedSize(y);
      g += L;
    }
    for (; y > h; --y) {
      const L = r.getEstimatedSize(y - 1);
      g -= L;
    }
  }
  i.startIndex = u, i.endIndex = h, i.anchorIndex = y, i.anchorOffset = g, i.scrollOffset = v;
}
function Az(i, e) {
  const t = e.getEstimatedOffset(i.anchorIndex), n = i.anchorOffset;
  i.anchorOffset = t, i.scrollOffset += t - n;
}
function _z(i, e) {
  return i.startIndex < e.startIndex || i.endIndex > e.endIndex;
}
var gS = class extends X {
  constructor(e) {
    super(), this.element = document.createElement("div"), this.scrollContent = document.createElement("div"), this.header = document.createElement("div"), this.body = document.createElement("div"), this.topItems = document.createElement("div"), this.bottomItems = document.createElement("div"), this.renderedItems = [], this.renderGeneration = -1, this.listGeneration = -1, this.newRenderedItems = [], this.state = new Iz(), this.renderParams = new tE(), this.newRenderParams = new tE(), this.sizes = new Pz(), this.debouncedUpdateView = this.registerCancellable(Ct(() => this.updateView())), this.resizeObserver = new ResizeObserver(() => this.updateView());
    const t = e.selectedIndex;
    t !== void 0 && (this.state.anchorIndex = t, this.state.anchorClientOffset = 0);
    const n = this.source = e.source;
    this.sizes.itemSize.length = n.length;
    const r = this.element, s = this.header, a = this.body, l = this.scrollContent, d = this.topItems, u = this.bottomItems;
    this.resizeObserver.observe(r), this.registerDisposer(() => this.resizeObserver.disconnect()), r.appendChild(l), r.style.overflowAnchor = "none", l.appendChild(s), l.appendChild(a), s.style.position = "sticky", s.style.zIndex = "1", s.style.top = "0", e.horizontalScroll ? (l.style.width = "min-content", l.style.minWidth = "100%", s.style.width = "min-content", s.style.minWidth = "100%", u.style.width = "min-content", u.style.minWidth = "100%") : (l.style.width = "100%", s.style.width = "100%", u.style.width = "100%"), a.appendChild(d), a.appendChild(u), d.style.width = "min-content", d.style.position = "relative", d.style.height = "0", d.style.minWidth = "100%", u.style.height = "0", u.style.position = "relative", r.addEventListener("scroll", () => {
      const h = r.scrollTop;
      this.state.anchorClientOffset = this.renderParams.anchorOffset - h, this.renderParams.scrollOffset = h, this.debouncedUpdateView();
    }), n.changed !== void 0 && this.registerDisposer(n.changed.add((h) => {
      this.sizes.splice(h), this.state.splice(h), this.renderedItems.length = 0, this.debouncedUpdateView();
    })), n.renderChanged !== void 0 && this.registerDisposer(n.renderChanged.add(this.debouncedUpdateView));
  }
  updateView() {
    const e = this.element;
    if (e.offsetHeight === 0)
      return;
    const t = e.clientHeight - this.header.offsetHeight, n = this.source, r = this.state, s = this.sizes, a = n.length, l = this.body, d = this.topItems, u = this.bottomItems, h = n.changed, g = n.renderChanged;
    let v;
    for (; ; ) {
      v = this.newRenderParams;
      const b = this.renderParams;
      Rz(v, b, a, t, s, r);
      let E;
      if (g !== void 0 && g.count !== this.renderGeneration || h !== void 0 && h.count !== this.listGeneration ? (this.renderGeneration = g === void 0 ? -1 : g.count, this.listGeneration = h === void 0 ? -1 : h.count, E = true, this.renderedItems.length = 0) : E = false, !E && !_z(v, b)) {
        b.scrollOffset = v.scrollOffset, v = b;
        break;
      }
      this.renderParams = v, this.newRenderParams = b;
      const T = this.renderedItems, I = this.newRenderedItems;
      I.length = 0, this.renderedItems = I, this.newRenderedItems = T;
      const R = this.source, P = R.render;
      var y = v;
      const L = y.startIndex, A = y.endIndex, M = y.anchorIndex;
      function* O(F, q) {
        for (let U = F; U < q; ++U) {
          let V = T[U];
          V === void 0 && (V = P.call(R, U)), I[U] = V, yield V;
        }
      }
      rr(d, O(L, M)), rr(u, O(M, A));
      for (let F = L; F < A; ++F) {
        const V = I[F].getBoundingClientRect().height, $ = s.itemSize[F];
        $ !== void 0 && (s.totalKnownSize -= $, --s.numItemsInTotalKnownSize), s.itemSize[F] = V, s.totalKnownSize += V, ++s.numItemsInTotalKnownSize;
      }
    }
    Az(v, s), r.anchorIndex = v.anchorIndex, r.anchorClientOffset = v.anchorOffset - v.scrollOffset;
    const C = s.getRangeSize(v.startIndex, v.anchorIndex), w = s.getEstimatedTotalSize();
    l.style.height = `${w}px`, d.style.top = `${v.anchorOffset - C}px`, u.style.top = `${v.anchorOffset}px`, e.scrollTop = v.scrollOffset;
  }
  getItemElement(e) {
    return this.renderedItems[e];
  }
  forEachRenderedItem(e) {
    var t = this.renderParams;
    const n = t.startIndex, r = t.endIndex, s = this.renderedItems;
    for (let a = n; a < r; ++a) {
      const l = s[a];
      l !== void 0 && e(l, a);
    }
  }
  scrollToTop() {
    this.state.anchorIndex = 0, this.state.anchorClientOffset = 0, this.debouncedUpdateView();
  }
  scrollItemIntoView(e) {
    const t = this.sizes.getEstimatedOffset(e), n = t + this.sizes.getEstimatedSize(e), r = this.element.scrollTop;
    if (t < r)
      this.state.anchorIndex = e, this.state.anchorClientOffset = 0;
    else if (t > r && n > r + this.element.offsetHeight)
      this.state.anchorIndex = e + 1, this.state.anchorClientOffset = this.element.offsetHeight;
    else
      return;
    this.debouncedUpdateView();
  }
  disposed() {
    Ut(this.element);
  }
};
var Jg = "neuroglancer-multiline-autocomplete-completion-active";
function Mz(i) {
  let e = document.createElement("div");
  return e.textContent = i.value, e;
}
function* nE(i) {
  for (; i.length > 0; ) {
    const e = i.match(/[:/_]+/);
    if (e === null) {
      yield i;
      return;
    }
    const t = e.index + e[0].length;
    yield i.substring(0, t), i = i.substring(t);
  }
}
function Nz(i) {
  let e = document.createElement("div");
  e.className = "neuroglancer-multiline-autocomplete-completion-with-description", e.textContent = i.value;
  let t = document.createElement("div");
  return t.className = "neuroglancer-multiline-autocomplete-completion-description", t.textContent = i.description || "", e.appendChild(t), e;
}
var Oz = St.fromObject({
  arrowdown: { action: "cycle-next-active-completion" },
  arrowup: { action: "cycle-prev-active-completion" },
  home: { action: "home" },
  end: { action: "end" },
  tab: { action: "choose-active-completion-or-prefix", preventDefault: false },
  enter: { action: "commit" },
  escape: { action: "cancel", preventDefault: false, stopPropagation: false }
});
var Vz = 200;
var Bz = class extends X {
  constructor(e) {
    super(), this.element = document.createElement("div"), this.inputElement = document.createElement("span"), this.hintElement = document.createElement("span"), this.completionsVirtualList = void 0, this.onCommit = new ct(), this.onInput = new ct(), this.prevInputValue = "", this.completionsVisible = false, this.activeCompletionPromise = null, this.activeCompletionCancellationToken = void 0, this.hasFocus = false, this.completionResult = null, this.dropdownContentsStale = true, this.hasResultForDropdown = false, this.commonPrefix = "", this.completionDisabled = -1, this.activeIndex = -1, this.dropdownStyleStale = true, this.resizeHandler = () => {
      this.completionsVisible && this.updateDropdownStyle();
    }, this.resizeObserver = new ResizeObserver(this.resizeHandler), this.debouncedUpdateHintState = this.registerCancellable(dt(() => this.updateHintState(), 0)), this.completer = e.completer;
    var t = e.delay;
    const n = t === void 0 ? Vz : t;
    let r = this.scheduleUpdateCompletions = dt(() => {
      const u = this.activeCompletionCancellationToken = new Ts();
      let h = this.activeCompletionPromise = this.completer(this.value, u);
      h !== null && h.then((g) => {
        this.activeCompletionPromise === h && (this.setCompletions(g), this.activeCompletionPromise = null);
      });
    }, n);
    this.registerDisposer(() => {
      r.cancel();
    });
    const s = this.element, a = this.inputElement, l = this.hintElement;
    s.classList.add("neuroglancer-multiline-autocomplete"), this.registerEventListener(window, "resize", this.resizeHandler), this.resizeObserver.observe(s), this.registerDisposer(() => this.resizeObserver.unobserve(a)), a.contentEditable = "true", a.spellcheck = false, s.appendChild(document.createTextNode("​")), s.appendChild(a), s.appendChild(l), a.classList.add("neuroglancer-multiline-autocomplete-input"), l.classList.add("neuroglancer-multiline-autocomplete-hint"), a.addEventListener("input", () => {
      this.completionDisabled = -1, this.setValueAndSelection(this.value, this.getSelectionRange()), this.debouncedUpdateHintState();
    }), a.addEventListener("copy", (u) => {
      const h = u.clipboardData;
      if (h !== null) {
        const g = window.getSelection();
        g !== null && !g.isCollapsed && g.containsNode(
          a,
          /*allowPartialContainment=*/
          true
        ) && h.setData("text/plain", g.toString());
      }
      u.preventDefault(), u.stopPropagation();
    }), this.registerEventListener(document, "selectionchange", () => {
      const u = this.getSelectionRange(), h = this.completionDisabled;
      u !== void 0 && u.begin === h && u.end === h || (this.completionDisabled = -1, this.debouncedUpdateHintState());
    }), this.setValueAndSelection(""), this.updateHintState(), s.addEventListener("pointerdown", (u) => {
      const h = u.target;
      if (h instanceof Node) {
        if (a.contains(h)) return;
        const g = this.completionsVirtualList;
        if (g !== void 0 && g.element.contains(h))
          return;
      }
      a === document.activeElement && (this.moveCaretToEndOfInput(), u.stopPropagation(), u.preventDefault());
    }), s.addEventListener("click", () => {
      a.focus();
    }), this.registerEventListener(this.inputElement, "focus", () => {
      if (!this.hasFocus) {
        this.hasFocus = true, this.dropdownStyleStale = true, this.updateDropdown();
        const u = document.createRange(), h = a.childNodes;
        u.setStart(a, 0), h.length === 0 ? u.setEnd(a, 0) : u.setEndAfter(h[h.length - 1]);
        const g = window.getSelection();
        g !== null && (g.removeAllRanges(), g.addRange(u)), this.debouncedUpdateHintState();
      }
    }), this.registerEventListener(this.inputElement, "blur", () => {
      this.hasFocus && (this.hasFocus = false, this.updateDropdown()), this.debouncedUpdateHintState();
      const u = window.getSelection();
      u !== null && u.containsNode(this.inputElement, true) && u.removeAllRanges(), this.onCommit.dispatch(this.value, false);
    }), this.registerEventListener(window, "resize", () => {
      this.dropdownStyleStale = true;
    }), this.registerEventListener(window, "scroll", () => {
      this.dropdownStyleStale = true;
    });
    const d = this.registerDisposer(new Gi(a, Oz));
    d.allShortcutsAreGlobal = true, Ce(a, "cycle-next-active-completion", () => {
      this.cycleActiveCompletion(1);
    }), Ce(a, "cycle-prev-active-completion", () => {
      this.cycleActiveCompletion(-1);
    }), Ce(a, "home", () => {
      this.moveCaretToBeginningOfInput();
    }), Ce(a, "end", () => {
      this.moveCaretToEndOfInput();
    }), Ce(a, "choose-active-completion-or-prefix", (u) => {
      this.selectActiveCompletion(
        /*allowPrefix=*/
        true
      ) && u.preventDefault();
    }), Ce(a, "commit", (u) => {
      if (this.selectActiveCompletion(
        /*allowPrefix=*/
        false
      ))
        u.stopPropagation();
      else {
        let h = !this.completionsVisible;
        this.disableCompletion(), this.hideCompletions(), this.onCommit.dispatch(this.value, h);
      }
    }), Ce(a, "cancel", (u) => {
      u.stopPropagation(), this.cancel() && (u.detail.preventDefault(), u.detail.stopPropagation());
    });
  }
  disableCompletion() {
    const e = this.getSelectionRange();
    this.completionDisabled = e !== void 0 && e.end === e.begin ? e.end : -1;
  }
  get placeholder() {
    return this.inputElement.dataset.placeholder || "";
  }
  set placeholder(e) {
    this.inputElement.dataset.placeholder = e;
  }
  getSelectionRange() {
    const e = window.getSelection();
    if (e === null || e.rangeCount === 0) return;
    const t = e.getRangeAt(0), n = this.inputElement, r = document.createRange();
    r.setStart(n, 0), r.setEnd(t.startContainer, t.startOffset);
    const s = r.toString().length, a = e.toString().length;
    return { begin: s, end: s + a };
  }
  setValueAndSelection(e, t = void 0) {
    const n = this.completionDisabled !== -1;
    this.onInput.dispatch(e);
    const r = this.inputElement;
    st(r);
    let s = 0;
    const a = t !== void 0 ? document.createRange() : void 0;
    let l = true;
    for (const d of nE(e)) {
      l || r.appendChild(document.createElement("wbr")), l = false;
      const u = s + d.length, h = document.createTextNode(d);
      if (r.appendChild(h), a !== void 0) {
        const g = t.begin, v = t.end;
        g >= s && g <= u && a.setStart(h, g - s), v >= s && v <= u && a.setEnd(h, v - s);
      }
      s = u;
    }
    if (a !== void 0) {
      l && (a.setStart(r, 0), a.setEnd(r, 0));
      const d = window.getSelection();
      d !== null && (d.removeAllRanges(), d.addRange(a));
    }
    this.completionDisabled = n && t !== void 0 && t.end === t.begin ? t.end : -1;
  }
  shouldAttemptCompletion() {
    const e = this.inputElement;
    if (document.activeElement !== e) return false;
    const t = this.getSelectionRange();
    return t !== void 0 && t.end === t.begin && t.end != this.completionDisabled && t.end === this.value.length;
  }
  hideCompletions() {
    this.cancelActiveCompletion(), this.clearCompletions(), this.hintElement.textContent = "";
  }
  updateHintState() {
    if (this.debouncedUpdateHintState.cancel(), this.shouldAttemptCompletion()) {
      const e = this.value;
      if (e === this.prevInputValue)
        return;
      this.hideCompletions(), this.prevInputValue = e, this.scheduleUpdateCompletions();
    } else {
      this.hideCompletions();
      return;
    }
  }
  handleDropdownClick(e) {
    let t = this.completionsVirtualList;
    if (t === void 0) return;
    const n = t.element;
    for (let r = e.target; r instanceof HTMLElement && r !== n; r = r.parentElement) {
      const s = r.dataset.completionIndex;
      if (s !== void 0) {
        this.selectCompletion(Number(s));
        break;
      }
    }
  }
  cycleActiveCompletion(e) {
    if (this.completionResult === null)
      return;
    let t = this.activeIndex, n = this.completionResult.completions.length;
    t === -1 ? e > 0 ? t = 0 : t = n - 1 : t = (t + e + n) % n, this.setActiveIndex(t);
  }
  shouldShowDropdown() {
    return this.completionResult === null || !this.hasFocus ? false : this.hasResultForDropdown;
  }
  updateDropdownStyle() {
    const e = this.completionsVirtualList, t = this.element;
    e !== void 0 && Lz(e.element, t, { horizontal: false }), this.dropdownStyleStale = false;
  }
  updateDropdown() {
    let e = this.completionsVirtualList;
    if (this.shouldShowDropdown()) {
      if (this.dropdownContentsStale) {
        e !== void 0 && e.dispose();
        const r = this.completionResult;
        var t = r.makeElement;
        const s = t === void 0 ? Mz : t;
        e = this.completionsVirtualList = new gS({
          source: {
            length: r.completions.length,
            render: (a) => {
              const l = r.completions[a], d = s.call(r, l);
              return d.classList.add("neuroglancer-multiline-autocomplete-completion"), d.dataset.completionIndex = `${a}`, this.activeIndex === a && d.classList.add(Jg), d;
            }
          },
          selectedIndex: this.activeIndex === -1 ? void 0 : this.activeIndex
        }), e.element.classList.add("neuroglancer-multiline-autocomplete-dropdown"), e.element.addEventListener("mousedown", (a) => {
          this.inputElement.focus(), a.preventDefault();
        }), e.element.addEventListener("mouseup", this.handleDropdownClick.bind(this)), this.element.appendChild(e.element), this.dropdownContentsStale = false;
      }
      this.dropdownStyleStale && this.updateDropdownStyle(), this.completionsVisible || (this.completionsVisible = true);
      const n = this.activeIndex;
      n !== -1 && this.completionsVirtualList.scrollItemIntoView(n);
    } else this.completionsVisible && (e !== void 0 && (e.dispose(), this.completionsVirtualList = void 0, this.dropdownContentsStale = true), this.completionsVisible = false);
  }
  setCompletions(e) {
    this.clearCompletions();
    let t = e.completions;
    if (t.length === 0)
      return;
    const n = this.prevInputValue;
    if (n !== void 0) {
      if (this.completionResult = e, t.length === 1) {
        let r = t[0];
        e.showSingleResult ? this.hasResultForDropdown = true : r.value.startsWith(n) ? this.hasResultForDropdown = false : this.hasResultForDropdown = true, e.selectSingleResult ? this.setActiveIndex(0) : this.setHintValue(this.getCompletedValueByIndex(0));
      } else {
        this.hasResultForDropdown = true;
        let r = Dz(function* () {
          for (let a of e.completions)
            yield a.value;
        }()), s = this.getCompletedValue(r);
        s.startsWith(n) && (this.commonPrefix = s, this.setHintValue(s));
      }
      this.updateDropdown();
    }
  }
  setHintValue(e) {
    const t = this.prevInputValue;
    if (t === void 0) return;
    (e === t || !e.startsWith(t)) && (e = ""), e = e.substring(t.length);
    const n = this.hintElement;
    st(n);
    let r = true;
    for (const s of nE(e)) {
      r || n.appendChild(document.createElement("wbr")), r = false;
      const a = document.createTextNode(s);
      n.appendChild(a);
    }
  }
  /**
   * This sets the active completion, which causes it to be highlighted and displayed as the hint.
   * Additionally, if the user hits tab then it is chosen.
   */
  setActiveIndex(e) {
    if (!this.dropdownContentsStale) {
      let t = this.activeIndex;
      const n = this.completionsVirtualList;
      if (n !== void 0) {
        if (t !== -1) {
          const r = n.getItemElement(t);
          r !== void 0 && r.classList.remove(Jg);
        }
        if (e !== -1) {
          let r = n.getItemElement(e);
          r !== void 0 && r.classList.add(Jg), n.scrollItemIntoView(e);
        }
      }
    }
    e !== -1 && this.setHintValue(this.getCompletedValueByIndex(e)), this.activeIndex = e;
  }
  getCompletedValueByIndex(e) {
    return this.getCompletedValue(this.completionResult.completions[e].value);
  }
  getCompletedValue(e) {
    let t = this.completionResult, n = this.prevInputValue;
    return n === void 0 ? "" : n.substring(0, t.offset) + e;
  }
  moveCaretToBeginningOfInput() {
    const e = document.createRange(), t = this.inputElement;
    e.setStart(t, 0), e.setEnd(t, 0);
    const n = window.getSelection();
    n !== null && (n.removeAllRanges(), n.addRange(e), this.debouncedUpdateHintState());
  }
  moveCaretToEndOfInput() {
    const e = document.createRange(), t = this.inputElement, n = t.childNodes, r = n[n.length - 1];
    r === void 0 ? (e.setStart(t, 0), e.setEnd(t, 0)) : (e.setStartAfter(r), e.setEndAfter(r));
    const s = window.getSelection();
    s !== null && (s.removeAllRanges(), s.addRange(e), this.debouncedUpdateHintState());
  }
  selectActiveCompletion(e) {
    let t = this.activeIndex;
    if (t === -1) {
      if (!e)
        return false;
      let r = this.completionResult;
      if (r !== null && r.completions.length === 1)
        t = 0;
      else {
        let s = this.commonPrefix;
        return s.length > this.value.length ? (this.value = s, this.moveCaretToEndOfInput(), true) : false;
      }
    }
    let n = this.getCompletedValueByIndex(t);
    return this.value === n ? false : (this.value = n, this.moveCaretToEndOfInput(), true);
  }
  selectCompletion(e) {
    this.value = this.getCompletedValueByIndex(e), this.moveCaretToEndOfInput();
  }
  /**
   * Called when user presses escape.  Does nothing here, but may be overridden in a subclass.
   */
  cancel() {
    return false;
  }
  cancelActiveCompletion() {
    this.prevInputValue = void 0;
    const e = this.activeCompletionCancellationToken;
    e !== void 0 && e.cancel(), this.activeCompletionCancellationToken = void 0, this.activeCompletionPromise = null;
  }
  clearCompletions() {
    if (this.completionResult !== null) {
      this.activeIndex = -1, this.completionResult = null, this.dropdownContentsStale = true, this.dropdownStyleStale = true, this.commonPrefix = "";
      const e = this.completionsVirtualList;
      e !== void 0 && (e.dispose(), this.completionsVirtualList = void 0), this.updateDropdown();
    }
  }
  get value() {
    return this.inputElement.textContent || "";
  }
  set value(e) {
    e !== this.value && (this.completionDisabled = -1, this.setValueAndSelection(e), this.debouncedUpdateHintState());
  }
  disposed() {
    const e = this.completionsVirtualList;
    e !== void 0 && e.dispose(), Ut(this.element), this.cancelActiveCompletion(), super.disposed();
  }
};
var qr = class extends X {
  constructor(e = new Zt(Zt.VISIBLE)) {
    super(), this.visibility = e, this.element = document.createElement("div"), this.element.classList.add("neuroglancer-tab-content");
  }
  get visible() {
    return this.visibility.visible;
  }
  disposed() {
    Ut(this.element), super.disposed();
  }
};
var Fz = class extends X {
  constructor() {
    super(...arguments), this.changed = new Le(), this.options = new he(), this.optionsChanged = new Le(), this.selectedValue = void 0, this.defaultValue = void 0, this.ready_ = true;
  }
  get value() {
    const e = this.selectedValue;
    return e !== void 0 ? e : this.defaultValue;
  }
  set default(e) {
    this.defaultValue !== e && (this.defaultValue = e, this.changed.dispatch());
  }
  get default() {
    return this.defaultValue;
  }
  set value(e) {
    e !== void 0 && this.ready_ && !this.options.has(e) && (e = void 0), this.selectedValue !== e && (this.selectedValue = e, this.changed.dispatch());
  }
  get validValue() {
    const e = this.selectedValue;
    return e === void 0 || !this.options.has(e) ? this.defaultValue : e;
  }
  add(e, t) {
    const n = this.options;
    if (n.has(e))
      throw new Error(`Option already defined: ${oe(e)}.`);
    n.set(e, t), this.optionsChanged.dispatch(), this.defaultValue === void 0 && (this.default = e);
  }
  toJSON() {
    const e = this.value, t = this.defaultValue;
    if (e !== t)
      return e;
  }
  reset() {
    this.value = void 0;
  }
  /**
   * When `ready` is `false`, the selected `value` may be set to an unknown option.
   */
  get ready() {
    return this.ready_;
  }
  set ready(e) {
    e !== this.ready_ && (this.ready_ = e, e && (this.value = this.value), this.changed.dispatch());
  }
  restoreState(e) {
    typeof e != "string" && (e = void 0), this.value = e;
  }
};
var Uz = class extends X {
  constructor(e, t, n = new Zt(Zt.VISIBLE), r = false) {
    super(), this.getter = e, this.selected = t, this.visibility = n, this.invalidateByDefault = r, this.element = document.createElement("div"), this.tabs = new he(), this.tabVisibilityChanged = new ct(), this.debouncedUpdateSelectedTab = this.registerCancellable(Ct(() => this.updateSelectedTab()));
    const s = this.element;
    s.className = "neuroglancer-stack-view", this.registerDisposer(n.changed.add(this.debouncedUpdateSelectedTab)), this.registerDisposer(t.changed.add(this.debouncedUpdateSelectedTab)), this.updateSelectedTab();
  }
  get visible() {
    return this.visibility.visible;
  }
  flush() {
    this.debouncedUpdateSelectedTab.flush();
  }
  invalidate(e) {
    const t = this.tabs, n = t.get(e);
    n !== void 0 && (n.dispose(), t.delete(e), e === this.displayedTab && (this.displayedTab = void 0, this.debouncedUpdateSelectedTab()));
  }
  hideTab(e) {
    const t = this.tabs.get(e);
    t !== void 0 && (t.visibility.value = Zt.IGNORED, t.element.style.display = "none"), this.tabVisibilityChanged.dispatch(e, false);
  }
  showTab(e) {
    const t = this.tabs;
    let n = t.get(e);
    n === void 0 && (n = this.getter(e), this.element.appendChild(n.element), t.set(e, n)), n.element.style.display = "", n.visibility.value = Zt.VISIBLE, this.tabVisibilityChanged.dispatch(e, true);
  }
  updateSelectedTab() {
    const e = this.displayedTab, t = this.visible ? this.selected.value : void 0;
    t === e && (t === void 0 || this.tabs.has(t)) || (e !== void 0 && this.hideTab(e), this.invalidateByDefault && this.invalidateAll(), this.displayedTab = t, t !== void 0 && this.showTab(t));
  }
  invalidateAll(e = void 0) {
    const t = this.tabs;
    for (const r of t) {
      var n = de(r, 2);
      const s = n[0], a = n[1];
      e !== void 0 && e(s) || (t.delete(s), a.dispose());
    }
    this.debouncedUpdateSelectedTab();
  }
  disposed() {
    this.invalidateAll(), Ut(this.element), super.disposed();
  }
};
var zz = class extends Fz {
};
function $z(i, e) {
  const t = "neuroglancer-selected-tab-label";
  e ? i.classList.add(t) : i.classList.remove(t);
}
var Gz = class extends X {
  constructor(e, t = new Zt(Zt.VISIBLE)) {
    super(), this.visibility = t, this.element = document.createElement("div"), this.tabBar = document.createElement("div"), this.tabLabels = new he(), this.tabsGeneration = -1, this.debouncedUpdateView = this.registerCancellable(Ct(() => this.updateTabs())), this.tabs = e.tabs, this.selectedTab = e.selectedTab, this.handleTabElement = e.handleTabElement;
    const n = this.element, r = this.tabBar;
    n.className = "neuroglancer-tab-view", r.className = "neuroglancer-tab-view-bar", n.appendChild(r), this.registerDisposer(t.changed.add(this.debouncedUpdateView));
    const s = this.stack = this.registerDisposer(new Uz(e.makeTab, e.selectedTab, this.visibility));
    n.appendChild(s.element), this.registerDisposer(e.tabs.changed.add(this.debouncedUpdateView)), this.registerDisposer(e.selectedTab.changed.add(() => this.updateTabLabelStyles())), this.updateTabs();
  }
  get visible() {
    return this.visibility.visible;
  }
  updateTabLabelStyles() {
    const e = this.selectedTab.value;
    for (const n of this.tabLabels) {
      var t = de(n, 2);
      const r = t[0], s = t[1];
      $z(s, r === e);
    }
  }
  updateTabs() {
    this.tabsGeneration !== this.tabs.changed.count && (this.destroyTabs(), this.visible && this.makeTabs());
  }
  destroyTabs() {
    if (this.tabsGeneration !== -1) {
      if (this.tabLabels.clear(), !this.visible)
        this.stack.invalidateAll();
      else {
        const e = this.tabs.value;
        this.stack.invalidateAll((t) => e.find(({ id: n }) => n === t) !== void 0);
      }
      st(this.tabBar), this.tabsGeneration = -1;
    }
  }
  makeTabs() {
    const e = this.tabBar, t = this.tabLabels, n = this.handleTabElement;
    for (const r of this.tabs.value) {
      const s = r.id, a = r.label, l = document.createElement("div");
      l.classList.add("neuroglancer-tab-label"), l.textContent = a, l.addEventListener("click", () => {
        this.selectedTab.value = s;
      }), n !== void 0 && n(s, l), t.set(s, l), e.appendChild(l);
    }
    this.updateTabLabelStyles(), this.tabsGeneration = this.tabs.changed.count;
  }
  disposed() {
    st(this.tabBar), this.tabLabels.clear(), Ut(this.element), super.disposed();
  }
};
var Wz = class extends Bz {
  constructor(e) {
    const t = e.source.layer.manager, n = (s, a) => t.dataSourceProviderRegistry.completeUrl({ url: s, chunkManager: t.chunkManager, cancellationToken: a }).then((l) => ({
      completions: l.completions,
      makeElement: Nz,
      offset: l.offset,
      showSingleResult: true
    }));
    super({ completer: n, delay: 0 }), this.placeholder = "Data source URL", this.dataSourceView = e, this.element.classList.add("neuroglancer-layer-data-source-url-input"), this.dirty = new vt(false);
    const r = (s) => {
      s !== this.dataSourceView.source.spec.url && (this.dirty.value = true);
    };
    r(""), this.onInput.add(r);
  }
  cancel() {
    return this.value = this.dataSourceView.source.spec.url, this.dirty.value = false, this.inputElement.blur(), true;
  }
};
var TI = class extends X {
  constructor(e) {
    super(), this.model = e, this.element = document.createElement("ul"), this.generation = -1, this.element.classList.add("neuroglancer-layer-data-sources-source-messages");
    const t = this.registerCancellable(Ct(() => this.updateView()));
    this.registerDisposer(e.changed.add(t)), this.registerDisposer(() => Ut(this.element)), this.updateView();
  }
  updateView() {
    const e = this.model, t = e.changed.count;
    if (t === this.generation) return;
    this.generation = t;
    const n = this.element;
    st(n);
    const r = new Ye();
    for (const s of e) {
      const a = `${s.severity} ${s.message}`;
      if (r.has(a)) continue;
      r.add(a);
      const l = document.createElement("li");
      n.appendChild(l), l.classList.add("neuroglancer-message"), l.classList.add(`neuroglancer-message-${ar[s.severity]}`), l.textContent = s.message;
    }
  }
};
var Hz = class extends X {
  constructor(e, t) {
    super(), this.loadedSubsource = t, this.element = document.createElement("div");
    const n = this.element;
    n.classList.add("neuroglancer-layer-data-source-subsource");
    const r = document.createElement("label"), s = document.createElement("span"), a = () => {
      r.dataset.isActive = (t.activated !== void 0 || !t.enabled).toString();
    };
    a(), this.registerDisposer(t.isActiveChanged.add(a)), this.registerDisposer(e.enabledSubsourcesChanged.add(a));
    const l = this.registerDisposer(new Ls({
      get value() {
        return t.enabled;
      },
      set value(C) {
        t.enabled = C, e.enableDefaultSubsources = false, e.enabledSubsourcesChanged.dispatch();
      },
      changed: e.enabledSubsourcesChanged
    }));
    r.classList.add("neuroglancer-layer-data-sources-info-line"), r.appendChild(l.element);
    const d = document.createElement("span");
    d.classList.add("neuroglancer-layer-data-sources-source-id");
    const u = t.subsourceEntry.id;
    u !== "default" && (d.textContent = u), r.appendChild(d), s.classList.add("neuroglancer-layer-data-sources-source-type");
    const h = this.registerDisposer(new TI(this.loadedSubsource.messages));
    n.appendChild(r), r.appendChild(s), n.appendChild(h.element);
    let g = "";
    const v = t.subsourceEntry.subsource, y = v.volume;
    if (y instanceof Ps)
      g = `${j[y.dataType].toLowerCase()} volume`;
    else if (v.mesh instanceof Vc)
      g = "meshes (single-res.)";
    else if (v.mesh instanceof Ah)
      g = "meshes (multi-res.)";
    else if (v.mesh instanceof _h)
      g = "skeletons";
    else if (v.segmentPropertyMap !== void 0)
      g = "segment property map";
    else if (v.local !== void 0)
      switch (v.local) {
        case Br.annotations:
          g = "Local annotations";
          break;
        case Br.equivalences:
          g = "local segmentation graph";
          break;
      }
    else v.staticAnnotations !== void 0 ? g = "default annotations" : v.annotation !== void 0 ? g = "annotations" : v.singleMesh !== void 0 ? g = "single mesh" : v.segmentationGraph !== void 0 && (g = "segmentation graph");
    s.textContent = g;
  }
};
var qz = class extends X {
  constructor(e) {
    super(), this.source = e, this.element = document.createElement("div");
    const t = this.element, n = document.createElement("label");
    n.classList.add("neuroglancer-layer-data-sources-source-default"), n.appendChild(this.registerDisposer(new Ls({
      changed: e.enabledSubsourcesChanged,
      get value() {
        return e.enableDefaultSubsources;
      },
      set value(s) {
        if (e.enableDefaultSubsources !== s) {
          if (e.enableDefaultSubsources = s, s)
            for (const a of e.subsources)
              a.enabled = a.subsourceEntry.default;
          e.enabledSubsourcesChanged.dispatch();
        }
      }
    })).element), n.appendChild(document.createTextNode("Enable default subsource set")), n.title = "Enable the default set of subsources for this data source.", t.appendChild(n);
    for (const s of e.subsources)
      t.appendChild(this.registerDisposer(new Hz(e, s)).element);
    const r = e.transform;
    if (r.mutableSourceRank || r.value.sourceRank !== 0) {
      const s = this.registerDisposer(new Tz(e.transform, e.layer.localCoordinateSpaceCombiner, e.layer.manager.root.coordinateSpaceCombiner));
      this.element.appendChild(s.element);
    }
    this.registerDisposer(() => Ut(this.element));
  }
};
var jz = class extends X {
  constructor(e, t) {
    super(), this.tab = e, this.source = t, this.element = document.createElement("div"), this.seenGeneration = 0, this.generation = -1;
    const n = this.urlInput = this.registerDisposer(new Wz(this)), r = (a, l) => {
      const d = this.source, u = d.spec, h = this.source.layer;
      if (a = h.manager.dataSourceProviderRegistry.normalizeUrl({ url: a }), a !== n.value && (n.disableCompletion(), n.setValueAndSelection(a, { begin: a.length, end: a.length })), n.dirty.value = false, a && a === u.url) {
        l && e.detectedLayerConstructor !== void 0 && LI(d.layer);
        return;
      }
      if (h instanceof zr)
        try {
          const g = h.manager.dataSourceProviderRegistry.suggestLayerName(a);
          EP(h.managedLayer, g);
        } catch {
        }
      d.spec = H(H({}, u), { url: a });
    };
    n.onCommit.add(r);
    const s = this.element;
    s.classList.add("neuroglancer-layer-data-source"), s.appendChild(n.element), s.appendChild(this.registerDisposer(new TI(t.messages)).element), this.updateView();
  }
  updateView() {
    const e = this.source.changed.count;
    if (e === this.generation) return;
    this.generation = e, this.urlInput.value = this.source.spec.url, this.urlInput.dirty.value = false;
    const t = this.source.loadState;
    let n = this.loadedView;
    if (n !== void 0) {
      if (n.source === t)
        return;
      n.dispose(), n = this.loadedView = void 0;
    }
    t instanceof Zy && (n = this.loadedView = new qz(t), this.element.appendChild(n.element));
  }
  disposed() {
    const e = this.loadedView;
    e !== void 0 && e.dispose(), Ut(this.element), super.disposed();
  }
};
function LI(i) {
  if (i instanceof zr) {
    const e = i.detectedLayerConstructor;
    if (e !== void 0)
      return DS(i.managedLayer, e), true;
  }
  return false;
}
var Jz = class extends qr {
  constructor(e) {
    super(), this.layer = e, this.generation = -1, this.sourceViews = new he(), this.addDataSourceIcon = kI({ title: "Add additional data source" }), this.layerTypeDetection = document.createElement("div"), this.layerTypeElement = document.createElement("span"), this.dataSourcesContainer = document.createElement("div"), this.detectedLayerConstructor = void 0;
    const t = this.element, n = this.dataSourcesContainer;
    t.classList.add("neuroglancer-layer-data-sources-tab"), n.classList.add("neuroglancer-layer-data-sources-container");
    const r = this.addDataSourceIcon;
    if (r.style.alignSelf = "start", r.addEventListener("click", () => {
      const a = this.layer.addDataSource(void 0);
      this.updateView();
      const l = this.sourceViews.get(a);
      l !== void 0 && l.urlInput.inputElement.focus();
    }), t.appendChild(this.dataSourcesContainer), e instanceof zr) {
      const a = this.layerTypeDetection, l = this.layerTypeElement;
      a.style.display = "none", l.classList.add("neuroglancer-layer-data-sources-tab-type-detection-type"), a.appendChild(document.createTextNode("Create as ")), a.appendChild(l), a.appendChild(document.createTextNode(" layer")), t.appendChild(a), a.classList.add("neuroglancer-layer-data-sources-tab-type-detection"), a.addEventListener("click", () => {
        LI(e);
      });
    }
    const s = this.reRender = Ct(() => this.updateView());
    this.registerDisposer(e.dataSourcesChanged.add(s)), this.registerDisposer(this.visibility.changed.add(s)), this.updateView();
  }
  updateLayerTypeDetection() {
    const e = (() => {
      const n = this.layer;
      if (!(n instanceof zr)) return;
      const r = n.detectedLayerConstructor;
      if (r !== void 0) {
        for (const s of this.sourceViews.values())
          if (s.urlInput.dirty.value) return;
        return r;
      }
    })();
    if (e === this.detectedLayerConstructor) return;
    const t = this.layerTypeDetection;
    if (this.detectedLayerConstructor = e, e !== void 0) {
      const n = this.layerTypeElement;
      n.textContent = e.type, t.title = `Click here or press enter in the data source URL input box to create as ${e.type} layer`, t.style.display = "";
    } else
      t.style.display = "none";
  }
  disposed() {
    const e = this.sourceViews;
    for (const t of e.values())
      t.dispose();
    e.clear(), super.disposed();
  }
  updateView() {
    if (!this.visible) return;
    const e = this.layer.dataSourcesChanged.count;
    if (e !== this.generation) {
      this.generation = e;
      const n = Date.now(), r = this.sourceViews, s = this.layer;
      function* a() {
        let l = true;
        const d = s.dataSources;
        for (const u of d) {
          let h = r.get(u);
          h === void 0 && (h = new jz(this, u), h.registerDisposer(h.urlInput.dirty.changed.add(this.reRender)), r.set(u, h)), h.seenGeneration = n, h.updateView();
          const g = u.spec.url;
          d.length === 1 && g === "" && setTimeout(() => {
            h.urlInput.inputElement.focus();
          }, 0), l = u.spec.url.length === 0, yield h.element;
        }
        l || (yield this.addDataSourceIcon);
      }
      rr(this.dataSourcesContainer, a.call(this));
      for (const l of r) {
        var t = de(l, 2);
        const d = t[0], u = t[1];
        u.seenGeneration !== n && (u.dispose(), r.delete(d));
      }
    }
    this.updateLayerTypeDetection();
  }
};
var Vd = "tab";
var iE = "tabs";
var rE = "panels";
var Kz = H(H({}, ga), { row: 0 });
var DI = H(H({}, ga), { visible: true, row: 0 });
var pc = class _pc extends X {
  constructor(e) {
    super(), this.panels = e, this.layer = this.panels.layer, this.location = new Is(DI), this.tabsChanged = new ct(), this.selectedTab = new vt(void 0), this.tabs = [];
  }
  initialize() {
    const e = this.panels;
    this.tabsChanged.add(e.specificationChanged.dispatch), this.selectedTab.changed.add(e.specificationChanged.dispatch), this.location.changed.add(() => {
      var t;
      e.specificationChanged.dispatch();
      const n = this.layer, r = n.manager.root.selectedLayer;
      if (((t = r.layer) === null || t === void 0 ? void 0 : t.layer) !== n || this !== n.panels.panels[0]) return;
      const s = this.location.value;
      r.location.value !== s && (r.location.value = s, r.location.locationChanged.dispatch());
    }), this.location.locationChanged.add(() => {
      this.location.visible || this !== this.panels.panels[0] && this.panels.removePanel(this);
    });
  }
  normalizeTabs() {
    const e = this.tabs;
    if (e.length === 0) {
      this.selectedTab.value = void 0;
      return;
    }
    const t = this.layer.tabs.options, n = (a) => {
      var l;
      return (l = t.get(a).order) !== null && l !== void 0 ? l : 0;
    };
    e.sort((a, l) => n(a) - n(l));
    const r = this.selectedTab, s = r.value;
    (s === void 0 || !e.includes(s)) && (r.value = e[0]);
  }
  pin() {
    var e;
    const t = this.layer, n = t.manager.root.selectedLayer;
    if (((e = n.layer) === null || e === void 0 ? void 0 : e.layer) !== t || this !== t.panels.panels[0] || this.tabs.length === 0) return;
    const r = this.panels, s = t.registerDisposer(new _pc(r));
    r.panels.splice(0, 1, s), r.panels.push(this), r.updateTabs(), s.initialize(), n.layerManager.layersChanged.dispatch(), this.panels.specificationChanged.dispatch();
  }
  unpin() {
    var e;
    const t = this.panels, n = t.panels.indexOf(this);
    if (n === -1 || n === 0) return;
    const r = this.layer, s = r.manager.root.selectedLayer, a = (e = s.layer) === null || e === void 0 ? void 0 : e.layer;
    s.visible && a != null && a != r && a.panels.panels[0].pin(), t.panels.splice(n, 1);
    var l = t.panels.splice(0, 1, this), d = de(l, 1);
    const u = d[0];
    if (this.explicitTabs === void 0)
      r.unregisterDisposer(u);
    else {
      t.panels.push(u);
      for (let h = 1, g = t.panels.length; h < g; ++h) {
        const v = t.panels[h];
        v.explicitTabs === void 0 && (v.explicitTabs = new Ye(v.tabs));
      }
    }
    this.explicitTabs = void 0, t.updateTabs(), s.layer = r.managedLayer, s.location.value = this.location.value, s.location.locationChanged.dispatch(), s.layerManager.layersChanged.dispatch(), this.panels.specificationChanged.dispatch();
  }
  splitOffTab(e, t) {
    if (!this.tabs.includes(e)) return;
    const n = this.panels;
    {
      const a = this.explicitTabs;
      a !== void 0 && a.delete(e);
    }
    const r = this.layer, s = r.registerDisposer(new _pc(n));
    s.location.value = t, s.explicitTabs = new Ye([e]), n.panels.splice(1, 0, s), n.updateTabs(), s.initialize(), r.manager.root.layerManager.layersChanged.dispatch(), n.specificationChanged.dispatch();
  }
  moveTabTo(e, t) {
    if (!this.tabs.includes(e)) return;
    {
      const r = this.explicitTabs;
      r !== void 0 && r.delete(e);
    }
    {
      const r = t.explicitTabs;
      r !== void 0 && r.add(e);
    }
    const n = this.panels;
    n.updateTabs(), t.selectedTab.value = e, n.specificationChanged.dispatch();
  }
  mergeInto(e) {
    const t = e.explicitTabs;
    if (t !== void 0)
      for (const r of this.tabs)
        t.add(r);
    this.panels.removePanel(this);
  }
};
var Yz = class {
  constructor(e) {
    this.layer = e, this.specificationChanged = new ct(), this.updating = false, this.panels = [e.registerDisposer(new pc(this))];
  }
  restoreState(e) {
    const t = this.panels;
    t[0].selectedTab.value = xe(e, Vd, Ae);
    const n = this.layer, r = n.tabs, s = new Ye(r.options.keys());
    xe(e, rE, (a) => Xe(a, (l) => {
      me(l);
      const d = new pc(this);
      d.location.restoreState(l), d.location.visible && (d.selectedTab.value = xe(l, Vd, Ae), d.explicitTabs = xe(l, iE, (u) => {
        const h = new Ye();
        for (const g of bi(u))
          s.has(g) && (s.delete(g), h.add(g));
        return h;
      }), d.explicitTabs === void 0 ? (d.tabs = _e(s), s.clear()) : d.tabs = _e(d.explicitTabs), d.tabs.length !== 0 && (d.normalizeTabs(), n.registerDisposer(d), d.initialize(), t.push(d)));
    })), t[0].tabs = _e(s), t[0].normalizeTabs(), this.panels[0].initialize();
  }
  removePanel(e) {
    if (this.updating) return;
    const t = this.panels.indexOf(e);
    this.panels.splice(t, 1), this.layer.unregisterDisposer(e), this.updateTabs();
  }
  updateTabs() {
    var e;
    const t = this.layer, n = t.tabs, r = new Ye(n.options.keys()), s = this.panels;
    this.updating = true;
    const a = (l) => {
      const d = l.tabs;
      if (l.explicitTabs === void 0)
        l.tabs = _e(r), r.clear();
      else {
        l.tabs = _e(l.explicitTabs);
        for (const u of l.tabs)
          r.delete(u);
      }
      He(d, l.tabs) || (l.normalizeTabs(), l.tabsChanged.dispatch());
    };
    for (let l = 1; l < s.length; ) {
      const d = s[l];
      if (d.location.visible && (a(d), d.tabs.length !== 0)) {
        ++l;
        continue;
      }
      s.splice(l, 1), t.unregisterDisposer(d);
    }
    if (a(s[0]), s[0].tabs.length === 0) {
      const l = this.layer.manager.root.selectedLayer;
      ((e = l.layer) === null || e === void 0 ? void 0 : e.layer) === this.layer && (l.location.visible = false);
    }
    this.updating = false;
  }
  toJSON() {
    var e;
    const t = this.panels, n = {};
    if (n[Vd] = t[0].selectedTab.value, t.length > 1) {
      const r = [];
      for (let s = 1, a = t.length; s < a; ++s) {
        const l = t[s], d = (e = l.location.toJSON()) !== null && e !== void 0 ? e : {};
        d[Vd] = l.selectedTab.value;
        const u = l.explicitTabs;
        u !== void 0 && (d[iE] = _e(u)), r.push(d);
      }
      n[rE] = r;
    }
    return n;
  }
};
var Xz = /^[A-Z]$/;
var sE = class extends X {
  constructor(e, t) {
    super(), this.tool = e, this.inputEventMapBinder = t;
  }
  bindAction(e, t) {
    this.registerDisposer(Ce(window, e, t));
  }
  bindInputEventMap(e) {
    this.inputEventMapBinder(e, this);
  }
  cancel() {
    this == this.tool.layer.manager.root.toolBinder.activeTool_ && this.tool.layer.manager.root.toolBinder.deactivate_();
  }
};
var Po = class extends X {
  constructor(e, t = false) {
    super(), this.layer = e, this.toggle = t, this.changed = new ct(), this.keyBinding = void 0;
  }
  get mouseState() {
    return this.layer.manager.root.layerSelectedValues.mouseState;
  }
  unbind() {
    const e = this.layer, t = this.keyBinding;
    t !== void 0 && e.toolBinder.set(t, void 0);
  }
};
var II = class extends X {
  constructor(e) {
    super(), this.layer = e, this.changed = new ct();
  }
  get mouseState() {
    return this.layer.manager.root.layerSelectedValues.mouseState;
  }
  deactivate() {
  }
  unbind() {
    const e = this.layer;
    e.tool.value === this && (e.tool.value = void 0);
  }
};
function aE(i, e) {
  var t;
  if (e === void 0)
    return;
  typeof e == "string" && (e = { type: e }), me(e);
  const n = Y(e, "type", Ae);
  let r = (t = rv.get(i.constructor)) === null || t === void 0 ? void 0 : t.get(n);
  if (r === void 0 && (r = Qz.get(n)), r === void 0)
    throw new Error(`Invalid tool type: ${oe(e)}.`);
  return r(i, e);
}
function Zz(i, e) {
  if (e === void 0)
    return;
  typeof e == "string" && (e = { type: e }), me(e);
  const t = Y(e, "type", Ae), n = PI.get(t);
  if (n === void 0)
    throw new Error(`Invalid tool type: ${oe(e)}.`);
  return n(i, e);
}
var PI = new he();
var Qz = new he();
var rv = new he();
function $c(i, e) {
  PI.set(i, e);
}
function gc(i, e, t) {
  let n = rv.get(i);
  n === void 0 && (n = new he(), rv.set(i, n)), n.set(e, t);
}
var e$ = class extends X {
  constructor(e) {
    super(), this.layer = e, this.changed = new ct();
  }
  get value() {
    return this.value_;
  }
  set value(e) {
    e !== this.value_ && (this.unregister(), e !== void 0 && (e.changed.add(this.changed.dispatch), this.value_ = e), this.changed.dispatch());
  }
  unregister() {
    const e = this.value_;
    e !== void 0 && (e.changed.remove(this.changed.dispatch), e.dispose(), this.value_ = void 0);
  }
  disposed() {
    this.unregister(), super.disposed();
  }
  restoreState(e) {
    this.value = Zz(this.layer, e);
  }
  reset() {
    this.value = void 0;
  }
  toJSON() {
    const e = this.value_;
    if (e !== void 0)
      return e.toJSON();
  }
};
var t$ = class extends X {
  constructor(e) {
    super(), this.inputEventMapBinder = e, this.bindings = new he(), this.changed = new ct(), this.debounceDeactivate = this.registerCancellable(dt(() => this.deactivate_(), 100)), this.debounceReactivate = this.registerCancellable(dt(() => this.reactivateQueuedTool(), 100));
  }
  get(e) {
    return this.bindings.get(e);
  }
  set(e, t) {
    const n = this.bindings, r = n.get(e);
    if (r !== void 0) {
      r.keyBinding = void 0, n.delete(e);
      const s = r.layer.toolBinder;
      s.bindings.delete(e), s.jsonToKey.delete(oe(r.toJSON())), this.destroyTool(r), s.changed.dispatch();
    }
    if (t !== void 0) {
      const s = t.layer.toolBinder, a = oe(t.toJSON()), l = s.jsonToKey.get(a);
      if (l !== void 0) {
        const d = s.bindings.get(l);
        d.keyBinding = void 0, n.delete(l), s.bindings.delete(l), s.jsonToKey.delete(a), this.destroyTool(d);
      }
      s.bindings.set(e, t), t.keyBinding = e, s.jsonToKey.set(a, e), n.set(e, t), s.changed.dispatch();
    }
    this.changed.dispatch();
  }
  activate(e) {
    const t = this.get(e);
    if (t === void 0) {
      this.deactivate_();
      return;
    }
    this.debounceDeactivate.cancel(), this.debounceReactivate.cancel();
    const n = this.activeTool_;
    if (t === (n == null ? void 0 : n.tool)) {
      t.toggle && this.deactivate_();
      return;
    } else n !== void 0 && (n.tool.toggle && !t.toggle && (this.queuedTool = n.tool), this.deactivate_());
    const r = new sE(t, this.inputEventMapBinder);
    if (this.activeTool_ = r, !t.toggle) {
      const s = `Key${e}`;
      r.registerEventListener(window, "keyup", (a) => {
        a.code === s && (this.debounceDeactivate(), this.debounceReactivate());
      }), r.registerEventListener(window, "blur", () => {
        this.debounceDeactivate(), this.debounceReactivate();
      });
    }
    return t.activate(r), t;
  }
  reactivateQueuedTool() {
    if (this.queuedTool) {
      const e = new sE(this.queuedTool, this.inputEventMapBinder);
      this.activeTool_ = e, this.queuedTool.activate(e), this.queuedTool = void 0;
    }
  }
  destroyTool(e) {
    var t;
    this.queuedTool === e && (this.queuedTool = void 0), ((t = this.activeTool_) === null || t === void 0 ? void 0 : t.tool) === e && this.deactivate_(), e.dispose();
  }
  disposed() {
    this.deactivate_(), super.disposed();
  }
  deactivate_() {
    this.debounceDeactivate.cancel();
    const e = this.activeTool_;
    e !== void 0 && (this.activeTool_ = void 0, e.dispose());
  }
};
var n$ = class {
  constructor(e) {
    this.layer = e, this.bindings = new he(), this.jsonToKey = new he(), this.changed = new ct(), e.registerDisposer(() => this.clear());
  }
  get globalBinder() {
    return this.layer.manager.root.toolBinder;
  }
  get(e) {
    return this.bindings.get(e);
  }
  set(e, t) {
    this.globalBinder.set(e, t);
  }
  setJson(e, t) {
    const n = aE(this.layer, t);
    n !== void 0 && this.set(e, n);
  }
  removeJsonString(e) {
    const t = this.jsonToKey.get(e);
    t !== void 0 && this.set(t, void 0);
  }
  toJSON() {
    const e = this.bindings;
    if (e.size === 0) return;
    const t = {};
    for (const r of e) {
      var n = de(r, 2);
      const s = n[0], a = n[1];
      t[s] = a.toJSON();
    }
    return t;
  }
  clear() {
    const e = this.globalBinder, t = this.bindings;
    if (t.size !== 0) {
      for (const r of t) {
        var n = de(r, 2);
        const s = n[0], a = n[1];
        a.keyBinding = void 0, e.bindings.delete(s), e.destroyTool(a);
      }
      t.clear(), this.jsonToKey.clear(), e.changed.dispatch(), this.changed.dispatch();
    }
  }
  reset() {
    this.clear();
  }
  restoreState(e) {
    if (e !== void 0) {
      me(e);
      for (const n of _c(e)) {
        var t = de(n, 2);
        const r = t[0], s = t[1];
        if (!r.match(Xz))
          throw new Error(`Invalid tool key: ${oe(r)}`);
        const a = aE(this.layer, s);
        if (a === void 0) return;
        this.set(r, a);
      }
    }
  }
};
var RI = class extends X {
  constructor(e, t) {
    super(), this.layer = e, this.toolJson = t, this.element = document.createElement("div"), this.toolJsonString = oe(this.toolJson);
    const n = this.element;
    n.classList.add("neuroglancer-tool-key-binding"), this.registerDisposer(e.toolBinder.changed.add(this.registerCancellable(Ct(() => this.updateView())))), this.updateView(), n.title = "click → bind key, dbclick → unbind", n.addEventListener("dblclick", () => {
      this.layer.toolBinder.removeJsonString(this.toolJsonString);
    }), AI(this, n, (r) => this.layer.toolBinder.setJson(r, this.toolJson));
  }
  updateView() {
    const t = this.layer.toolBinder.jsonToKey.get(this.toolJsonString);
    this.element.textContent = t ?? " ";
  }
};
function AI(i, e, t) {
  let n;
  e.addEventListener("mousedown", (r) => {
    if (r.button !== 0 || n !== void 0) return;
    r.preventDefault(), r.stopPropagation(), n = new X(), i.registerDisposer(n), n.registerDisposer(new rt(false)).setText("Press A-Z to bind key"), n.registerEventListener(window, "keydown", (a) => {
      const d = a.code.match(/^Key([A-Z])$/);
      if (d === null) return;
      a.stopPropagation(), a.preventDefault();
      const u = d[1];
      t(u);
    }, { capture: true }), n.registerEventListener(window, "mouseup", (a) => {
      a.button !== 0 || n === void 0 || (a.preventDefault(), a.stopPropagation(), i.unregisterDisposer(n), n.dispose(), n = void 0);
    });
  }), e.addEventListener("click", (r) => {
    r.preventDefault(), r.stopPropagation();
  });
}
function Kg(i, e, t) {
  const n = document.createElement("div");
  n.classList.add("neuroglancer-tool-button"), n.appendChild(i.registerDisposer(new RI(e, t.toolJson)).element);
  const r = document.createElement("div");
  return r.classList.add("neuroglancer-tool-button-label"), r.textContent = t.label, t.title && (r.title = t.title), n.appendChild(r), n;
}
function i$(i) {
  const e = i.registerDisposer(new rt(false));
  e.element.classList.add("neuroglancer-tool-status");
  const t = document.createElement("div");
  t.classList.add("neuroglancer-tool-status-content"), e.element.appendChild(t);
  const n = i.inputEventMapBinder;
  return i.inputEventMapBinder = (r, s) => {
    const a = document.createElement("div");
    a.textContent = r.describe(), a.classList.add("neuroglancer-tool-status-bindings"), e.element.appendChild(a), n(r, s);
  }, { message: e, content: t };
}
function Mh(i) {
  var e = i$(i);
  const t = e.message, n = e.content, r = document.createElement("div");
  r.classList.add("neuroglancer-tool-status-header");
  const s = document.createElement("div");
  s.classList.add("neuroglancer-tool-status-header-container"), s.appendChild(r), n.appendChild(s);
  const a = document.createElement("div");
  return a.classList.add("neuroglancer-tool-status-body"), n.appendChild(a), { message: t, body: a, header: r };
}
function r$(i, e) {
  i.remove(e);
}
function s$(i, e) {
  i.add(e);
}
var _I = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20aria-labelledby='controlsAltIconTitle'%3e%3ctitle%20id='controlsAltIconTitle'%3eControls%3c/title%3e%3ccircle%20cx='9'%20cy='6'%20r='2'/%3e%3cpath%20d='M4%206H7'/%3e%3cpath%20d='M11%206H20'/%3e%3ccircle%20cx='9'%20cy='18'%20r='2'/%3e%3cpath%20d='M4%2018H7'/%3e%3cpath%20d='M11%2018H20'/%3e%3ccircle%20cx='15'%20cy='12'%20r='2'/%3e%3cpath%20d='M4%2012H13'/%3e%3cpath%20d='M17%2012L20%2012'/%3e%3c/svg%3e";
var a$ = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20aria-labelledby='layersIconTitle'%3e%3ctitle%20id='layersIconTitle'%3eLayers%3c/title%3e%3cpath%20d='M12%204L20%208.00004L12%2012L4%208.00004L12%204Z'/%3e%3cpath%20d='M20%2012L12%2016L4%2012'/%3e%3cpath%20d='M20%2016L12%2020L4%2016'/%3e%3c/svg%3e";
var o$ = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='listIconTitle'%3e%3ctitle%20id='listIconTitle'/%3e%3cpath%20d='M10%207L18%207M10%2012L18%2012M10%2017L18%2017'/%3e%3cline%20x1='7'%20y1='7'%20x2='7'%20y2='7'/%3e%3cline%20x1='7'%20y1='12'%20x2='7'%20y2='12'/%3e%3cline%20x1='7'%20y1='17'%20x2='7'%20y2='17'/%3e%3c/svg%3e";
var l$ = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='settingsIconTitle'%3e%3ctitle%20id='settingsIconTitle'%3eSettings%3c/title%3e%3cpath%20d='M5.03506429,12.7050339%20C5.01187484,12.4731696%205,12.2379716%205,12%20C5,11.7620284%205.01187484,11.5268304%205.03506429,11.2949661%20L3.20577137,9.23205081%20L5.20577137,5.76794919%20L7.9069713,6.32070904%20C8.28729123,6.0461342%208.69629298,5.80882212%209.12862533,5.61412402%20L10,3%20L14,3%20L14.8713747,5.61412402%20C15.303707,5.80882212%2015.7127088,6.0461342%2016.0930287,6.32070904%20L18.7942286,5.76794919%20L20.7942286,9.23205081%20L18.9649357,11.2949661%20C18.9881252,11.5268304%2019,11.7620284%2019,12%20C19,12.2379716%2018.9881252,12.4731696%2018.9649357,12.7050339%20L20.7942286,14.7679492%20L18.7942286,18.2320508%20L16.0930287,17.679291%20C15.7127088,17.9538658%2015.303707,18.1911779%2014.8713747,18.385876%20L14,21%20L10,21%20L9.12862533,18.385876%20C8.69629298,18.1911779%208.28729123,17.9538658%207.9069713,17.679291%20L5.20577137,18.2320508%20L3.20577137,14.7679492%20L5.03506429,12.7050339%20Z'/%3e%3ccircle%20cx='12'%20cy='12'%20r='1'/%3e%3c/svg%3e";
var Gc = class extends X {
};
function MI(i) {
  let e, t, n;
  return (r, s) => t !== void 0 && (e === void 0 || r === void 0 || e.generation !== r.generation) ? (e === void 0 && n.addConsumer(s), t) : (e = void 0, n = new ZV(), t = i(r, n).then((a) => (e = a, n = void 0, a), (a) => {
    throw n.isCanceled && (n = void 0, t = void 0), a;
  }), t);
}
function Nh(i) {
  let e = 0;
  return MI((t, n) => i(n).then((r) => ({ generation: ++e, credentials: r })));
}
var c$ = class {
  constructor() {
    this.providers = new he(), this.topLevelManager = this;
  }
  register(e, t) {
    this.providers.set(e, t);
  }
  getCredentialsProvider(e, t) {
    const n = this.providers.get(e);
    if (n === void 0)
      throw new Error(`No registered credentials provider: ${oe(e)}`);
    return n(t, this.topLevelManager);
  }
};
var d$ = class extends X {
  constructor(e) {
    super(), this.base = e, this.memoize = new LL();
  }
  getCredentialsProvider(e, t) {
    return this.memoize.get({ key: e, parameters: t }, () => this.registerDisposer(this.base.getCredentialsProvider(e, t).addRef()));
  }
};
var NI = class extends d$ {
  constructor() {
    super(new c$()), this.base.topLevelManager = this;
  }
  register(e, t) {
    this.base.register(e, t);
  }
};
var u$ = class extends Gc {
  constructor(e, t) {
    super(), this.baseProvider = e, this.anonymousCredentials = t, this.anonymous = true, this.get = MI((n) => this.anonymous && n === void 0 ? Ft.resolve({ generation: -10, credentials: this.anonymousCredentials }) : (this.anonymous = false, this.baseProvider.get(n)));
  }
};
var Jo = new NI();
function mi(i, e) {
  return (t) => {
    t.style.flex = i, e(t);
  };
}
function Ks(i, e) {
  return (t) => {
    t.style.display = "flex", t.style.flexDirection = i;
    for (let n of e) {
      let r = t.ownerDocument.createElement("div");
      t.appendChild(r), n(r);
    }
  };
}
var h$ = nt();
function OI(i, e) {
  const t = ST(h$), n = i.globalPosition;
  var r = i.displayDimensionRenderInfo;
  const s = r.canonicalVoxelFactors, a = r.displayDimensionIndices;
  for (let l = 0; l < 3; ++l) {
    const d = a[l];
    t[12 + l] = d === -1 ? 0 : n[d], t[5 * l] = e / s[l];
  }
  return vn(t, i.viewProjectionMat, t), t;
}
var Oh = class _Oh extends X {
  constructor(e) {
    super(), this.gl = e, this.vertexBuffer = this.registerDisposer(Qn.fromData(e, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1]), e.ARRAY_BUFFER, e.STATIC_DRAW));
    let t = 0.5;
    this.colorBuffer = this.registerDisposer(Qn.fromData(e, new Float32Array([1, 0, 0, t, 1, 0, 0, t, 0, 1, 0, t, 0, 1, 0, t, 0, 0, 1, t, 0, 0, 1, t]), e.ARRAY_BUFFER, e.STATIC_DRAW)), this.trivialColorShader = this.registerDisposer(CB(e));
  }
  static get(e) {
    return e.memoize.get("SliceViewPanel:AxesLineHelper", () => new _Oh(e));
  }
  draw(e, t = true) {
    let n = this.trivialColorShader, r = this.gl;
    n.bind(), r.uniformMatrix4fv(n.uniform("uProjectionMatrix"), false, e);
    let s = n.attribute("aVertexPosition");
    this.vertexBuffer.bindToVertexAttrib(s, 4);
    let a = n.attribute("aColor");
    this.colorBuffer.bindToVertexAttrib(a, 4), t && (r.colorMask(false, false, false, true), r.clearColor(0, 0, 0, 0), r.clear(r.COLOR_BUFFER_BIT), r.colorMask(true, true, true, true), r.enable(r.BLEND), r.blendFunc(r.ONE_MINUS_DST_ALPHA, r.DST_ALPHA)), r.lineWidth(1), r.drawArrays(r.LINES, 0, 6), t && r.disable(r.BLEND), r.disableVertexAttribArray(s), r.disableVertexAttribArray(a);
  }
};
var f$ = "perspective_view/PerspectiveView";
var VI = class {
  constructor() {
    this.renderLayers = [null], this.pickData = [null], this.values = [0, 0, 0], this.nextPickID = 1;
  }
  clear() {
    this.renderLayers.length = 1, this.pickData.length = 1, this.values.length = 3, this.nextPickID = 1;
  }
  registerUint64(e, t, n = 1, r = null) {
    return this.register(e, n, t.low, t.high, r);
  }
  register(e, t = 1, n = 0, r = 0, s = null) {
    let a = this.renderLayers, l = this.values, d = this.nextPickID;
    this.nextPickID += t;
    let u = a.length;
    a[u] = e;
    let h = u * 3;
    return l[h] = d, l[h + 1] = n, l[h + 2] = r, this.pickData[u] = s, d;
  }
  /**
   * Set the object state according to the specified pick ID.
   */
  setMouseState(e, t) {
    const n = this.renderLayers, r = this.values;
    let s = 0, a = n.length - 1;
    for (; s < a; ) {
      const v = Math.ceil(s + (a - s) / 2);
      r[v * 3] > t ? a = v - 1 : s = v;
    }
    const l = e.pickedRenderLayer = n[s], d = s * 3, u = e.pickedOffset = t - r[d];
    let h = e.pickedValue;
    h.low = r[d + 1], h.high = r[d + 2], e.pickedAnnotationId = void 0, e.pickedAnnotationLayer = void 0, e.pickedAnnotationBuffer = void 0, e.pickedAnnotationBufferBaseOffset = void 0, e.pickedAnnotationIndex = void 0, e.pickedAnnotationCount = void 0, e.pickedAnnotationType = void 0;
    const g = this.pickData[s];
    l !== null && l.updateMouseState(e, h, u, g);
  }
};
var no = class {
  static insertAfter(e, t) {
    let n = e.next0;
    t.next0 = n, t.prev0 = e, e.next0 = t, n.prev0 = t;
  }
  static insertBefore(e, t) {
    let n = e.prev0;
    t.prev0 = n, t.next0 = e, e.prev0 = t, n.next0 = t;
  }
  static front(e) {
    let t = e.next0;
    return t === e ? null : t;
  }
  static back(e) {
    let t = e.prev0;
    return t === e ? null : t;
  }
  static pop(e) {
    let t = e.next0, n = e.prev0;
    return t.prev0 = n, n.next0 = t, e.next0 = null, e.prev0 = null, e;
  }
  static *iterator(e) {
    for (let t = e.next0; t !== e; t = t.next0)
      yield t;
  }
  static *reverseIterator(e) {
    for (let t = e.prev0; t !== e; t = t.prev0)
      yield t;
  }
  static initializeHead(e) {
    e.next0 = e.prev0 = e;
  }
};
var p$ = class {
  constructor() {
    no.initializeHead(this);
  }
};
var sv = new p$();
var g$ = window.top === window;
var mS = dt(() => {
  if (!g$) return;
  var i = document;
  const e = i.activeElement;
  if (e === null || e === document.body) {
    const t = no.front(sv);
    t !== null && t.element.focus({ preventScroll: true });
  }
});
window.addEventListener("focus", () => {
  mS();
}, true);
window.addEventListener("blur", () => {
  mS();
}, true);
var Vh = class extends X {
  constructor(e) {
    super(), this.element = e, this.prev0 = null, this.next0 = null, this.lastFocusedElement = null, this.scheduleUpdateFocus = this.registerCancellable(dt(() => {
      var t = document;
      const n = t.activeElement, r = this.element;
      r.contains(n) || sS(n) || (n != null && (n === this.lastFocusedElement || n.contains(r)) && this.element.focus({ preventScroll: true }), this.lastFocusedElement = null);
    }, 0)), e.tabIndex = -1, this.registerEventListener(e, "pointerdown", (t) => {
      t.target === e && (this.lastFocusedElement = null, e.focus({ preventScroll: true }));
    }), this.registerEventListener(e, "mouseenter", () => {
      this.lastFocusedElement = document.activeElement, this.scheduleUpdateFocus();
    }), this.registerEventListener(e, "mouseleave", () => {
      this.scheduleUpdateFocus.cancel();
    }), no.insertBefore(sv, this), this.registerEventListener(e, "focus", () => {
      no.pop(this), no.insertAfter(sv, this);
    }), mS();
  }
  disposed() {
    no.pop(this), super.disposed();
  }
};
var oE = 10;
var m$ = 1e3;
var v$ = 400;
var y$ = 500;
var S$ = Math.PI / 20;
var b$ = 20;
var w$ = 10;
function BI(i, e) {
  return Math.sqrt(i * i + e * e);
}
function lE(i) {
  var e = de(i, 2);
  let t = e[0], n = e[1];
  if (t.identifier > n.identifier) {
    var r = [t, n];
    n = r[0], t = r[1];
  }
  const s = t.clientX - n.clientX, a = t.clientY - n.clientY, l = BI(s, a), d = Math.atan2(s, a);
  return { distance: l, angle: d };
}
function C$(i, e) {
  const t = Math.PI * 2, n = Math.abs(i - e) % t;
  return Math.min(n, t - n);
}
var x$ = class extends X {
  constructor(e, t) {
    super(), this.target = e, this.eventMap = t, this.prevTouches = new he(), this.moved = false, this.prevAngle = 0, this.rotated = false, this.prevDistance = 0, this.pinched = false, this.prevCenterX = 0, this.prevCenterY = 0, this.translated = false, this.startHold = this.registerCancellable(wh((n, r, s, a) => {
      const l = { event: n, centerX: s, centerY: a };
      this.dispatch(`touchhold${n.targetTouches.length}`, n, l, r);
    }, m$, { leading: false, trailing: true })), this.numPriorTaps = 0, this.priorTapNumTouches = 0, this.tapStartTime = 0, this.tapEndTime = 0, this.curTapNumTouches = 0, this.registerEventListener(e, "touchstart", (n) => {
      this.handleTouchEvent(n);
    }), this.registerEventListener(e, "touchmove", (n) => {
      this.handleTouchEvent(n);
    }), this.registerEventListener(e, "touchend", (n) => {
      this.handleTouchEvent(n);
    });
  }
  dispatch(e, t, n, r = t.eventPhase) {
    iI(e, t, r, n, this.eventMap);
  }
  handleTouchEvent(e) {
    if (e.target === this.target)
      e.preventDefault();
    else
      return;
    const t = new he(), n = this.prevTouches, r = this.prevEvent;
    let s = 0, a = 0;
    for (const w of e.targetTouches)
      t.set(w.identifier, w), s += w.clientX, a += w.clientY;
    s /= t.size, a /= t.size;
    for (const w of n.entries()) {
      var l = de(w, 2);
      const b = l[0], E = l[1], T = t.get(b);
      if (T === void 0)
        n.delete(b);
      else {
        const I = T.clientX - E.clientX, R = T.clientY - E.clientY;
        (Math.abs(I) >= oE || Math.abs(R) >= oE) && (this.moved = true);
      }
    }
    if (r === void 0 || r.targetTouches.length !== t.size || t.size == 0) {
      if (this.moved = false, e.type === "touchstart")
        this.startHold(e, e.eventPhase, s, a), (r === void 0 || r.targetTouches.length === 0) && (this.tapStartTime = Date.now(), this.curTapNumTouches = 0), this.curTapNumTouches = Math.max(this.curTapNumTouches, e.targetTouches.length);
      else {
        if (e.type == "touchend") {
          const w = Date.now();
          if (e.targetTouches.length === 0 && w - this.tapStartTime < v$) {
            (this.curTapNumTouches !== this.priorTapNumTouches || w - this.tapEndTime >= y$) && (this.numPriorTaps = 0), ++this.numPriorTaps, this.tapEndTime = w, this.priorTapNumTouches = this.curTapNumTouches;
            const b = { event: e, centerX: s, centerY: a };
            this.dispatch(`touchtap${this.curTapNumTouches}x${this.numPriorTaps}`, e, b);
          }
        }
        this.startHold.cancel();
      }
      if (this.prevTouches = t, this.prevEvent = e, this.prevCenterX = s, this.prevCenterY = a, this.translated = false, t.size === 2) {
        var d = lE(t.values());
        const w = d.distance, b = d.angle;
        this.prevDistance = w, this.prevAngle = b, this.rotated = false, this.pinched = false;
      }
      return;
    }
    if (!this.moved)
      return;
    this.tapStartTime = 0, this.startHold.cancel(), this.prevTouches = t, this.prevEvent = e;
    let u = this.prevCenterX, h = this.prevCenterY, g = this.translated;
    const v = s - u, y = a - h;
    if (g === false && BI(v, y) >= w$ && (g = this.translated = true), g === true && (v !== 0 || y !== 0)) {
      this.prevCenterX = s, this.prevCenterY = a;
      const w = { event: e, deltaX: v, deltaY: y, centerX: s, centerY: a };
      this.dispatch(`touchtranslate${t.size}`, e, w);
    }
    if (t.size === 2) {
      var C = lE(t.values());
      const w = C.distance, b = C.angle;
      let E = this.pinched, T = this.rotated, I = this.prevDistance, R = this.prevAngle;
      E === false && Math.abs(w - I) >= b$ && (this.pinched = E = true);
      const P = C$(b, R);
      if (T === false && P >= S$ && (this.rotated = T = true), E === true && w != I) {
        this.prevDistance = w;
        const L = { event: e, distance: w, prevDistance: I, centerX: s, centerY: a };
        this.dispatch("touchpinch", e, L);
      }
      T === true && b !== R && (this.prevAngle = b, this.dispatch("touchrotate", e, { event: e, centerX: s, centerY: a, angle: b, prevAngle: R }));
    }
  }
};
var E$ = 0;
var k$ = 1;
var T$ = 2;
function Iu(i) {
  let e = 0;
  switch (i.deltaMode) {
    case E$:
      e = 1 / 200;
      break;
    case k$:
      e = 1 / 10;
      break;
    case T$:
      e = 2;
      break;
  }
  return Math.exp(i.deltaY * e);
}
var Yg = ze();
var cE = class {
  constructor() {
    this.pickIDs = new VI(), this.viewportWidth = 0, this.viewportHeight = 0, this.invTransform = nt(), this.frameNumber = -1;
  }
};
var dE = class {
  constructor() {
    this.buffer = null, this.glWindowX = 0, this.glWindowY = 0;
  }
};
var L$ = 30;
var mn = 5;
var ft = 1 + mn * 2;
var Pu = (() => {
  const i = mn ** 2, e = (r, s) => (r - mn) ** 2 + (s - mn) ** 2;
  let t = new Uint32Array(ft * ft), n = 0;
  for (let r = 0; r < ft; ++r)
    for (let s = 0; s < ft; ++s)
      e(r, s) > i || (t[n++] = s * ft + r);
  return t = t.subarray(0, n), t.sort((r, s) => {
    const a = r % ft, l = (r - a) / ft, d = s % ft, u = (s - d) / ft;
    return e(a, l) - e(d, u);
  }), t;
})();
function FI(i, e, t, n, r, s, a) {
  const l = n - mn, d = r - mn;
  if (!(l >= 0 && d >= 0 && l + ft <= s && d + ft <= a))
    for (let u = 0; u < ft; ++u)
      for (let h = 0; h < ft; ++h) {
        const g = l + h, v = d + u;
        (g < 0 || v < 0 || g >= s || v >= a) && (i[e + (v * ft + g) * t] = 0);
      }
}
var UI = class extends PL {
  constructor(e, t, n) {
    super(e, t, n.visibility), this.viewer = n, this.mouseX = -1, this.mouseY = -1, this.pickRequestPending = false, this.mouseStateForcer = () => this.blockOnPickRequest(), this.pickingData = [new cE(), new cE()], this.pickRequests = [new dE(), new dE()], this.pickBufferContents = new Float32Array(2 * 4 * ft * ft), this.pickTimerId = -1, this.nextPickRequestTime = 0, this.pendingPickRequestTimerId = -1, this.pendingPickRequestTimerExpired = () => {
      this.pendingPickRequestTimerId = -1, this.pickRequestPending && this.attemptToIssuePickRequest();
    }, this.inputEventMap = n.inputEventMap, t.classList.add("neuroglancer-rendered-data-panel"), t.classList.add("neuroglancer-panel"), t.classList.add("neuroglancer-noselect"), typeof NEUROGLANCER_SHOW_OBJECT_SELECTION_TOOLTIP < "u" && NEUROGLANCER_SHOW_OBJECT_SELECTION_TOOLTIP === true && (t.title = "Double click to toggle display of object under mouse pointer.  Control+rightclick to pin/unpin selection."), this.registerDisposer(new Vh(t)), this.registerDisposer(new Gi(t, this.inputEventMap)), this.registerDisposer(new Hr(t, this.inputEventMap, (r) => {
      this.onMousemove(r);
    })), this.registerDisposer(new x$(t, this.inputEventMap)), this.registerEventListener(t, "mousemove", this.onMousemove.bind(this)), this.registerEventListener(t, "touchstart", this.onTouchstart.bind(this)), this.registerEventListener(t, "mouseleave", () => this.onMouseout()), this.registerEventListener(
      t,
      "mouseover",
      (r) => {
        r.target !== t && this.onMouseout();
      },
      /*capture=*/
      true
    ), Ce(t, "select-position", () => {
      this.viewer.selectionDetailsState.select(false);
    }), Ce(t, "snap", () => {
      this.navigationState.pose.snap();
    }), Ce(t, "zoom-in", () => {
      this.navigationState.zoomBy(0.5);
    }), Ce(t, "zoom-out", () => {
      this.navigationState.zoomBy(2);
    }), Ce(t, "depth-range-decrease", () => {
      this.navigationState.depthRange.value *= 0.5;
    }), Ce(t, "depth-range-increase", () => {
      this.navigationState.depthRange.value *= 2;
    });
    for (let r = 0; r < 3; ++r) {
      let s = EN[r];
      for (let a of [-1, 1]) {
        let l = a < 0 ? "-" : "+";
        Ce(t, `rotate-relative-${s}${l}`, () => {
          this.navigationState.pose.rotateRelative(Xi[r], a * 0.1);
        });
        let d = ze();
        Ce(t, `${s}${l}`, () => {
          let u = this.navigationState, h = d;
          h[0] = 0, h[1] = 0, h[2] = 0, h[r] = a, u.pose.translateVoxelsRelative(h, true);
        });
      }
    }
    Ce(t, "zoom-via-wheel", (r) => {
      const s = r.detail;
      this.onMousemove(s, false), this.zoomByMouse(Iu(s));
    }), Ce(t, "adjust-depth-range-via-wheel", (r) => {
      const s = r.detail;
      this.navigationState.depthRange.value *= Iu(s);
    }), Ce(t, "translate-via-mouse-drag", (r) => {
      Ui(r.detail, (s, a, l) => {
        this.translateByViewportPixels(a, l);
      });
    }), Ce(t, "translate-in-plane-via-touchtranslate", (r) => {
      const s = r.detail;
      this.translateByViewportPixels(s.deltaX, s.deltaY);
    }), Ce(t, "translate-z-via-touchtranslate", (r) => {
      const s = r.detail;
      let a = this.navigationState, l = Yg;
      l[0] = 0, l[1] = 0, l[2] = s.deltaY + s.deltaX, a.pose.translateVoxelsRelative(l, true);
    });
    for (const r of [1, 10])
      Ce(t, `z+${r}-via-wheel`, (s) => {
        const a = s.detail;
        let l = this.navigationState, d = Yg, u = a.deltaY !== 0 ? a.deltaY : a.deltaX;
        d[0] = 0, d[1] = 0, d[2] = (u > 0 ? -1 : 1) * r, l.pose.translateVoxelsRelative(d, true);
      });
    Ce(t, "move-to-mouse-position", () => {
      const r = this.viewer.mouseState;
      r.updateUnconditionally() && (this.navigationState.position.value = r.position);
    }), Ce(t, "snap", () => this.navigationState.pose.snap()), Ce(t, "move-annotation", (r) => {
      const s = this.viewer.mouseState, a = s.pickedAnnotationId, l = s.pickedAnnotationLayer;
      if (l !== void 0 && a !== void 0) {
        r.stopPropagation();
        let d = l.source.getReference(a), u = d.value;
        const h = jl(u.type), g = s.pickedOffset, v = l.chunkTransform.value;
        if (v.error !== void 0) return;
        const y = v.layerRank, C = new Float32Array(y);
        h.getRepresentativePoint(C, u, s.pickedOffset);
        let w = CN(kT(), 0, 0);
        s.updateUnconditionally() && Ui(r.detail, (b, E, T) => {
          xN(w, w, [E, T]);
          const I = new Float32Array(y);
          Ar(I, v.chunkToLayerTransform, y + 1, C, y);
          const R = Yg, P = this.navigationState.pose.displayDimensions.value.displayDimensionIndices;
          vV(R, I, v.modelTransform, P), this.translateDataPointByViewportPixels(R, R, w[0], w[1]), yV(I, R, v.modelTransform, P);
          const L = new Float32Array(y);
          Ar(L, v.layerToChunkTransform, y + 1, I, y);
          let A = h.updateViaRepresentativePoint(u, L, g);
          l.source.update(d, A);
        }, (b) => {
          l.source.commit(d), d.dispose();
        });
      }
    }), Ce(t, "delete-annotation", () => {
      const r = this.viewer.mouseState, s = r.pickedAnnotationId, a = r.pickedAnnotationLayer;
      if (a !== void 0 && !a.source.readonly && s !== void 0) {
        const l = a.source.getReference(s);
        try {
          a.source.delete(l);
        } finally {
          l.dispose();
        }
      }
    }), Ce(t, "zoom-via-touchpinch", (r) => {
      const s = r.detail;
      this.handleMouseMove(s.centerX, s.centerY);
      const a = s.prevDistance / s.distance;
      a > 0.1 && a < 10 && this.zoomByMouse(a);
    });
  }
  cancelPickRequests() {
    const e = this.gl;
    for (const t of this.pickRequests) {
      const n = t.sync;
      n !== null && e.deleteSync(n), t.sync = null;
    }
    clearTimeout(this.pickTimerId), this.pickTimerId = -1;
  }
  issuePickRequestInternal(e) {
    const t = this.gl;
    let n = e.buffer;
    n === null ? (n = e.buffer = t.createBuffer(), t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, n), t.bufferData(WebGL2RenderingContext.PIXEL_PACK_BUFFER, 2 * 4 * 4 * ft * ft, WebGL2RenderingContext.STREAM_READ)) : t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, n);
    const r = this.renderViewport;
    let s = this.mouseX - r.visibleLeftFraction * r.logicalWidth, a = r.height - (this.mouseY - r.visibleTopFraction * r.logicalHeight);
    this.issuePickRequest(s, a), e.sync = t.fenceSync(WebGL2RenderingContext.SYNC_GPU_COMMANDS_COMPLETE, 0), e.frameNumber = this.context.frameNumber, e.glWindowX = s, e.glWindowY = a, t.flush(), t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, null), this.pickTimerId === -1 && this.scheduleCheckForPickRequestCompletion(), this.pickRequestPending = false;
    const l = this.pickRequests;
    e !== l[0] && (l[1] = l[0], l[0] = e), this.nextPickRequestTime = Date.now() + L$;
  }
  completePickInternal(e) {
    const t = this.gl, n = this.pickBufferContents;
    t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, e.buffer), t.getBufferSubData(WebGL2RenderingContext.PIXEL_PACK_BUFFER, 0, n), t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, null);
    const r = this.pickingData, s = e.frameNumber;
    this.completePickRequest(e.glWindowX, e.glWindowY, n, r[0].frameNumber === s ? r[0] : r[1]);
  }
  scheduleCheckForPickRequestCompletion() {
    this.pickTimerId = window.setTimeout(() => {
      this.pickTimerId = -1, this.checkForPickRequestCompletion();
    }, 0);
  }
  checkForPickRequestCompletion(e = false, t = false) {
    let n = this.context.frameNumber, r = -1;
    e && (--n, r = n - 1);
    const s = this.pickRequests, a = this.gl;
    let l = false, d = false, u;
    for (const g of s) {
      const v = g.sync;
      if (v === null) continue;
      const y = g.frameNumber;
      if (!d && y >= n - 1) {
        if (t || a.getSyncParameter(v, WebGL2RenderingContext.SYNC_STATUS) === WebGL2RenderingContext.SIGNALED)
          this.completePickInternal(g), d = true;
        else if (y !== r) {
          l = true;
          continue;
        }
      }
      a.deleteSync(v), g.sync = null, u = g;
    }
    const h = this.pickTimerId;
    l && h === -1 ? this.scheduleCheckForPickRequestCompletion() : !l && h !== -1 && (window.clearTimeout(h), this.pickTimerId = -1), !e && u !== void 0 && this.pickRequestPending && this.canIssuePickRequest() && this.issuePickRequestInternal(u);
  }
  blockOnPickRequest() {
    this.pickRequestPending && (this.cancelPickRequests(), this.nextPickRequestTime = 0, this.attemptToIssuePickRequest()), this.checkForPickRequestCompletion(
      /*checkingBeforeDraw=*/
      false,
      /*block=*/
      true
    );
  }
  draw() {
    var e = this.renderViewport;
    const t = e.width, n = e.height;
    this.checkForPickRequestCompletion(true);
    const r = this.pickingData;
    r[0] = r[1];
    const s = this.context.frameNumber, a = r[1];
    if (a.frameNumber = s, a.viewportWidth = t, a.viewportHeight = n, a.pickIDs.clear(), !this.drawWithPicking(a)) {
      a.frameNumber = -1;
      return;
    }
    this.nextPickRequestTime = 0, this.mouseX >= 0 && this.attemptToIssuePickRequest();
  }
  canIssuePickRequest() {
    const e = Date.now(), t = this.nextPickRequestTime, n = this.pendingPickRequestTimerId;
    return e < t ? (n == -1 && (this.pendingPickRequestTimerId = window.setTimeout(this.pendingPickRequestTimerExpired, t - e)), false) : true;
  }
  attemptToIssuePickRequest() {
    if (!this.canIssuePickRequest()) return;
    const e = this.context.frameNumber, t = this.gl, n = this.pickRequests;
    for (const r of n) {
      let s = r.sync;
      if (s !== null)
        if (r.frameNumber < e - 1)
          t.deleteSync(s);
        else
          continue;
      this.issuePickRequestInternal(r);
      return;
    }
  }
  /**
   * Called each time the mouse position relative to the top level of the rendered viewport changes.
   */
  updateMousePosition(e, t) {
    if (e === this.mouseX && t === this.mouseY)
      return;
    if (this.mouseX = e, this.mouseY = t, e < 0) {
      this.pickRequestPending = false, this.cancelPickRequests();
      return;
    }
    const n = this.context.frameNumber, r = this.pickingData[1];
    r.frameNumber !== n || this.renderViewport.width !== r.viewportWidth || this.renderViewport.height !== r.viewportHeight || (this.pickRequestPending = true, this.attemptToIssuePickRequest());
  }
  onMouseout() {
    this.updateMousePosition(-1, -1), this.viewer.mouseState.setForcer(void 0);
  }
  handleMouseMove(e, t) {
    const n = this.element, r = n.getBoundingClientRect(), s = e - (r.left + n.clientLeft), a = t - (r.top + n.clientTop), l = this.viewer.mouseState;
    l.pageX = e + window.scrollX, l.pageY = t + window.scrollY, l.setForcer(this.mouseStateForcer), this.updateMousePosition(s, a);
  }
  onMousemove(e, t = true) {
    const n = this.element;
    t && e.target !== n || this.handleMouseMove(e.clientX, e.clientY);
  }
  onTouchstart(e) {
    let t = this.element;
    if (e.target !== t || e.targetTouches.length !== 1)
      return;
    var n = e.targetTouches[0];
    const r = n.clientX, s = n.clientY;
    this.handleMouseMove(r, s);
  }
  disposed() {
    this.viewer.mouseState.removeForcer(this.mouseStateForcer);
    const t = this.gl;
    this.cancelPickRequests();
    const n = this.pendingPickRequestTimerId;
    n !== -1 && window.clearTimeout(n);
    for (const r of this.pickRequests)
      t.deleteBuffer(r.buffer);
    super.disposed();
  }
};
var D$ = [1.5, 2, 3, 5, 7.5, 10];
var I$ = class {
  constructor() {
    this.allowedSignificands = D$, this.targetLengthInPixels = 0, this.physicalSizePerPixel = 0, this.prevPhysicalSizePerPixel = 0, this.prevTargetLengthInPixels = 0, this.prevPhysicalUnit = "\0";
  }
  /**
   * Updates physicalLength, physicalUnit, and lengthInPixels to be the optimal values corresponding
   * to targetLengthInPixels and physicalSizePerPixel.
   *
   * @returns true if the scale bar has changed, false if it is unchanged.
   */
  update() {
    let e = this.physicalSizePerPixel, t = this.targetLengthInPixels;
    if (this.prevPhysicalSizePerPixel === e && this.prevTargetLengthInPixels === t && this.prevPhysicalUnit === this.physicalUnit)
      return false;
    this.prevPhysicalSizePerPixel = e, this.prevTargetLengthInPixels = t, this.prevPhysicalUnit = this.physicalUnit;
    const n = t * e, r = Math.floor(iL(n)), s = 10 ** r, a = n / s;
    let l = 1;
    for (let h of this.allowedSignificands)
      if (Math.abs(h - a) < Math.abs(l - a))
        l = h;
      else
        break;
    const d = l * s, u = rL(d);
    return this.lengthInPixels = Math.round(d / e), this.physicalUnit = `${u.prefix}${this.physicalBaseUnit}`, this.physicalLength = l * 10 ** (r - u.exponent), true;
  }
};
function P$(i, e, t, n, r) {
  const s = document.createElement("canvas"), a = s.getContext("2d"), l = r.textHeightInPixels * r.scaleFactor, d = `bold ${l}px ${r.fontName}`;
  a.font = d, a.fillStyle = "white";
  const u = `${n}${i.physicalLength} ${i.physicalUnit}`, h = a.measureText(u), g = Math.max(i.lengthInPixels, h.width), v = r.barHeightInPixels * r.scaleFactor, y = r.barTopMarginInPixels * r.scaleFactor, C = v + y + l, w = r.paddingInPixels * r.scaleFactor, b = C + 2 * w, E = g + 2 * w;
  return s.width = E, s.height = b, a.font = d, a.textAlign = "center", a.fillStyle = "rgba(0, 0, 0, 0.3)", a.fillRect(0, 0, E, b), a.fillStyle = "white", a.fillText(u, E / 2, b - w - v - y), a.fillRect(w, b - w - v, i.lengthInPixels, v), bB(e, t, s), { width: E, height: b };
}
var R$ = class extends X {
  constructor(e, t = new I$()) {
    super(), this.gl = e, this.dimensions = t, this.texture = null, this.width = 0, this.height = 0, this.label = "", this.factor = 1, this.priorOptions = void 0, this.prevLabel = "";
  }
  update(e) {
    const t = this.dimensions, n = this.label;
    let r = this.texture;
    if (!t.update() && r !== null && e === this.priorOptions && n == this.prevLabel)
      return;
    r === null && (r = this.texture = this.gl.createTexture());
    var s = P$(t, this.gl, r, n, e);
    const a = s.width, l = s.height;
    this.priorOptions = e, this.prevLabel = n, this.width = a, this.height = l;
  }
  disposed() {
    this.gl.deleteTexture(this.texture), this.texture = null, super.disposed();
  }
};
var zI = class extends X {
  constructor(e) {
    super(), this.gl = e, this.scaleBarCopyHelper = this.registerDisposer(bo.get(this.gl)), this.scaleBars = [];
    for (let t = 0; t < 3; ++t)
      this.scaleBars.push(this.registerDisposer(new R$(e)));
  }
  draw(e, t, n, r, s) {
    const a = this.scaleBars, l = t.displayRank, d = t.displayDimensionIndices, u = t.canonicalVoxelFactors, h = t.globalDimensionNames, g = t.displayDimensionUnits, v = t.displayDimensionScales, y = n.factors, C = Math.min(s.maxWidthFraction * e.logicalWidth, s.maxWidthInPixels * s.scaleFactor);
    let w = 0;
    for (let I = 0; I < l; ++I) {
      const R = d[I], P = g[I], L = y[R];
      let A, M, O;
      for (A = 0; A < w && (M = a[A], O = M.dimensions, !(O.physicalBaseUnit === P && M.factor === L)); ++A)
        ;
      A === w && (++w, M = a[A], M.label = "", O = M.dimensions, M.factor = L, O.physicalBaseUnit = P, O.targetLengthInPixels = C, O.physicalSizePerPixel = v[I] * r / u[I]), M.label += `${h[R]} `;
    }
    const b = this.gl, E = this.scaleBarCopyHelper;
    let T = s.bottomPixelOffset * s.scaleFactor;
    for (let I = w - 1; I >= 0; --I) {
      const R = a[I];
      w === 1 ? R.label = "" : R.label += ": ", R.update(s), b.viewport(s.leftPixelOffset * s.scaleFactor - e.visibleLeftFraction * e.logicalWidth, T - (1 - (e.visibleTopFraction + e.visibleHeightFraction)) * e.logicalHeight, R.width, R.height), E.draw(R.texture), T += R.height + s.marginPixelsBetweenScaleBars * s.scaleFactor;
    }
  }
};
var A$ = {
  scaleFactor: 1,
  textHeightInPixels: 15,
  barHeightInPixels: 8,
  barTopMarginInPixels: 5,
  fontName: "sans-serif",
  paddingInPixels: 2
};
var $I = H(H({}, A$), { maxWidthInPixels: 100, maxWidthFraction: 0.25, leftPixelOffset: 10, bottomPixelOffset: 10, marginPixelsBetweenScaleBars: 5 });
function _$(i) {
  const e = H({}, $I);
  for (const t of ["textHeightInPixels", "barTopMarginInPixels", "barHeightInPixels", "paddingInPixels", "scaleFactor", "maxWidthInPixels", "maxWidthFraction", "leftPixelOffset", "bottomPixelOffset"])
    Y(i, t, (n) => {
      n !== void 0 && (e[t] = Bo(n));
    });
  return Y(i, "fontName", (t) => {
    t !== void 0 && (e.fontName = Ae(t));
  }), e;
}
var M$ = class extends fn {
  constructor() {
    super($I, _$);
  }
};
var ii;
(function(i) {
  i[i.COLOR = 0] = "COLOR", i[i.Z = 1] = "Z", i[i.PICK = 2] = "PICK", i[i.NUM_TEXTURES = 3] = "NUM_TEXTURES";
})(ii || (ii = {}));
var N$ = `
void emit(vec4 color, highp uint pickId) {
  out_color = color;
  float zValue = 1.0 - gl_FragCoord.z;
  out_z = vec4(zValue, zValue, zValue, 1.0);
  float pickIdFloat = float(pickId);
  out_pickId = vec4(pickIdFloat, pickIdFloat, pickIdFloat, 1.0);
}
`;
var O$ = `
float computeOITWeight(float alpha) {
  float a = min(1.0, alpha) * 8.0 + 0.01;
  float b = -gl_FragCoord.z * 0.95 + 1.0;
  return a * a * a * b * b * b;
}
`;
var V$ = [O$, `
void emit(vec4 color, highp uint pickId) {
  float weight = computeOITWeight(color.a);
  vec4 accum = color * weight;
  v4f_fragData0 = vec4(accum.rgb, color.a);
  v4f_fragData1 = vec4(accum.a, 0.0, 0.0, 0.0);
}
`];
function Xg(i) {
  i.addOutputBuffer("vec4", "out_color", ii.COLOR), i.addOutputBuffer("highp vec4", "out_z", ii.Z), i.addOutputBuffer("highp vec4", "out_pickId", ii.PICK), i.addFragmentCode(N$);
}
function B$(i) {
  i.addOutputBuffer("vec4", "v4f_fragData0", 0), i.addOutputBuffer("vec4", "v4f_fragData1", 1), i.addFragmentCode(V$);
}
var Cr = ze();
var uE = oh();
var F$ = nt();
function U$(i) {
  i.addOutputBuffer("vec4", "v4f_fragColor", null), i.setFragmentMain(`
vec4 v0 = getValue0();
vec4 v1 = getValue1();
vec4 accum = vec4(v0.rgb, v1.r);
float revealage = v0.a;

v4f_fragColor = vec4(accum.rgb / accum.a, revealage);
`);
}
var z$ = mh(cr);
var $$ = class extends z$ {
  constructor(e) {
    super(), this.panel = e;
  }
  initializeCounterpart(e, t) {
    this.sharedProjectionParameters = this.registerDisposer(new Su(e, this.panel.projectionParameters)), t.projectionParameters = this.sharedProjectionParameters.rpcId, super.initializeCounterpart(e, t);
  }
};
var vS2 = class extends UI {
  constructor(e, t, n) {
    super(e, t, n), this.sliceViews = this.registerDisposer(new Ay((s, a, l) => {
      s.registerDisposer(l), s.registerDisposer(l.visibility.add(this.visibility));
    })), this.axesLineHelper = this.registerDisposer(Oh.get(this.gl)), this.sliceViewRenderHelper = this.registerDisposer(xD.get(this.gl, Xg)), this.offscreenFramebuffer = this.registerDisposer(new So(this.gl, {
      colorBuffers: [new Zs(this.gl, WebGL2RenderingContext.RGBA8, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE), new Zs(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT), new Zs(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT)],
      depthBuffer: new kB(this.gl)
    })), this.offscreenCopyHelper = this.registerDisposer(bo.get(this.gl)), this.transparencyCopyHelper = this.registerDisposer(bo.get(this.gl, U$, 2)), this.scaleBars = this.registerDisposer(new zI(this.gl)), this.projectionParameters = this.registerDisposer(new qL({
      navigationState: this.navigationState,
      update: (s, a) => {
        const l = s.invViewMatrix, d = s.projectionMat, u = s.logicalWidth, h = s.logicalHeight, g = u / h, v = Math.PI / 4;
        let y = a.relativeDepthRange, w = a.zoomFactor.value / 2;
        if (this.viewer.orthographicProjection.value) {
          const b = Math.max(0.1, 1 - y), E = 1 + y;
          bT(d, -g, g, -1, 1, b, E);
        } else {
          const b = 1 / Math.tan(v / 2);
          y /= b;
          const E = Math.max(0.1, 1 - y), T = 1 + y;
          w *= b, hN(d, v, g, E, T);
        }
        DL(s, d), a.pose.toMat4(l, w), cN(l, l, wm(Cr, 1, -1, -1)), lN(l, l, Xi[2]), _L(s);
      }
    })), this.projectionParameters.changed.add(() => this.context.scheduleRedraw());
    const r = this.sharedObject = this.registerDisposer(new $$(this));
    if (r.RPC_TYPE_ID = f$, r.initializeCounterpart(n.rpc, {}), r.visibility.add(this.visibility), this.visibleLayerTracker = gP(this.viewer.layerManager, Ho, this.viewer.visibleLayerRoles, this), Ce(t, "rotate-via-mouse-drag", (s) => {
      Ui(s.detail, (a, l, d) => {
        this.navigationState.pose.rotateRelative(Xi[1], l / 4 * Math.PI / 180), this.navigationState.pose.rotateRelative(Xi[0], -d / 4 * Math.PI / 180);
      });
    }), Ce(t, "rotate-in-plane-via-touchrotate", (s) => {
      const a = s.detail;
      this.navigationState.pose.rotateRelative(Xi[2], a.angle - a.prevAngle);
    }), Ce(t, "rotate-out-of-plane-via-touchtranslate", (s) => {
      const a = s.detail;
      this.navigationState.pose.rotateRelative(Xi[1], a.deltaX / 4 * Math.PI / 180), this.navigationState.pose.rotateRelative(Xi[0], -a.deltaY / 4 * Math.PI / 180);
    }), n.showSliceViewsCheckbox) {
      let s = this.registerDisposer(new Ls(n.showSliceViews));
      s.element.className = "perspective-panel-show-slice-views neuroglancer-noselect";
      let a = document.createElement("label");
      a.className = "perspective-panel-show-slice-views neuroglancer-noselect", a.appendChild(document.createTextNode("Sections")), a.appendChild(s.element), this.element.appendChild(a);
    }
    this.registerDisposer(n.orthographicProjection.changed.add(() => {
      this.projectionParameters.update(), this.scheduleRedraw();
    })), this.registerDisposer(n.showScaleBar.changed.add(() => this.scheduleRedraw())), this.registerDisposer(n.scaleBarOptions.changed.add(() => this.scheduleRedraw())), this.registerDisposer(n.showSliceViews.changed.add(() => this.scheduleRedraw())), this.registerDisposer(n.showAxisLines.changed.add(() => this.scheduleRedraw())), this.registerDisposer(n.crossSectionBackgroundColor.changed.add(() => this.scheduleRedraw())), this.registerDisposer(n.perspectiveViewBackgroundColor.changed.add(() => this.scheduleRedraw())), this.registerDisposer(n.wireFrame.changed.add(() => this.scheduleRedraw())), this.sliceViews.changed.add(() => this.scheduleRedraw());
  }
  get rpc() {
    return this.sharedObject.rpc;
  }
  get rpcId() {
    return this.sharedObject.rpcId;
  }
  get displayDimensionRenderInfo() {
    return this.navigationState.displayDimensionRenderInfo;
  }
  flushBackendProjectionParameters() {
    this.sharedObject.sharedProjectionParameters.flush();
  }
  translateByViewportPixels(e, t) {
    const n = Cr;
    var r = this.projectionParameters.value;
    const s = r.viewProjectionMat, a = r.invViewProjectionMat, l = r.logicalWidth, d = r.logicalHeight;
    this.viewer.navigationState.pose.updateDisplayPosition((h) => {
      yi(n, h, s), n[0] += -2 * e / l, n[1] += 2 * t / d, yi(h, n, a);
    });
  }
  get navigationState() {
    return this.viewer.navigationState;
  }
  ensureBoundsUpdated() {
    super.ensureBoundsUpdated(), this.projectionParameters.setViewport(this.renderViewport);
  }
  isReady() {
    if (!this.visible)
      return true;
    for (const u of this.sliceViews) {
      var e = de(u, 2);
      const h = e[0];
      if ((e[1] || this.viewer.showSliceViews.value) && !h.isReady())
        return false;
    }
    this.ensureBoundsUpdated();
    var t = this.renderViewport;
    const n = t.width, r = t.height;
    if (n === 0 || r === 0)
      return true;
    const a = {
      projectionParameters: this.projectionParameters.value
    }, l = this.visibleLayerTracker.visibleLayers;
    for (const u of l) {
      var d = de(u, 2);
      const h = d[0], g = d[1];
      if (!h.isReady(a, g))
        return false;
    }
    return true;
  }
  disposed() {
    this.sliceViews.clear(), super.disposed();
  }
  getDepthArray() {
    if (!this.navigationState.valid)
      return;
    const e = this.offscreenFramebuffer;
    var t = this.renderViewport;
    const n = t.width, r = t.height, s = n * r, a = new Float32Array(s * 4);
    try {
      e.bindSingle(ii.Z), this.gl.readPixels(0, 0, n, r, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, a);
    } finally {
      e.framebuffer.unbind();
    }
    const l = new Float32Array(s);
    for (let d = 0; d < s; ++d)
      l[d] = a[d * 4];
    return l;
  }
  issuePickRequest(e, t) {
    const n = this.offscreenFramebuffer;
    n.readPixelFloat32IntoBuffer(ii.Z, e - mn, t - mn, 0, ft, ft), n.readPixelFloat32IntoBuffer(ii.PICK, e - mn, t - mn, 4 * 4 * ft * ft, ft, ft);
  }
  completePickRequest(e, t, n, r) {
    const s = this.viewer.mouseState;
    s.pickedRenderLayer = null, FI(n, 0, 4, e, t, r.viewportWidth, r.viewportHeight);
    const a = Pu.length;
    for (let l = 0; l < a; ++l) {
      const d = Pu[l];
      let u = n[4 * d];
      if (u === 0) continue;
      const h = d % ft, g = (d - h) / ft;
      let v = 1 - u;
      Cr[0] = 2 * (e + h - mn) / r.viewportWidth - 1, Cr[1] = 2 * (t + g - mn) / r.viewportHeight - 1, Cr[2] = 2 * v - 1, yi(Cr, Cr, r.invTransform);
      let y = s.position, C = s.unsnappedPosition;
      const w = this.navigationState.position.value, b = w.length;
      y.length !== b && (y = s.position = new Float32Array(b)), C.length !== b && (C = s.unsnappedPosition = new Float32Array(b)), y.set(w), s.coordinateSpace = this.navigationState.coordinateSpace.value;
      const E = this.navigationState.pose.displayDimensions.value, T = E.displayDimensionIndices;
      for (let R = 0, P = T.length; R < P; ++R)
        y[T[R]] = Cr[R];
      C.set(y);
      const I = n[4 * ft * ft + 4 * d];
      r.pickIDs.setMouseState(s, I), s.displayDimensions = E, s.setActive(true);
      return;
    }
    s.setActive(false);
  }
  translateDataPointByViewportPixels(e, t, n, r) {
    const s = Cr;
    var a = this.projectionParameters.value;
    const l = a.viewProjectionMat, d = a.invViewProjectionMat, u = a.width, h = a.height;
    return yi(s, t, l), s[0] += 2 * n / u, s[1] += -2 * r / h, yi(e, s, d);
  }
  get transparentConfiguration() {
    let e = this.transparentConfiguration_;
    return e === void 0 && (e = this.transparentConfiguration_ = this.registerDisposer(new So(this.gl, {
      colorBuffers: bu(this.gl, 2, this.gl.RGBA32F, this.gl.RGBA, this.gl.FLOAT),
      depthBuffer: this.offscreenFramebuffer.depthBuffer.addRef()
    }))), e;
  }
  drawWithPicking(e) {
    if (!this.navigationState.valid)
      return false;
    var t = this.renderViewport;
    const n = t.width, r = t.height, s = this.viewer.showSliceViews.value;
    for (const L of this.sliceViews) {
      var a = de(L, 2);
      const A = a[0];
      (a[1] || s) && A.updateRendering();
    }
    let l = this.gl;
    this.offscreenFramebuffer.bind(n, r), l.disable(l.SCISSOR_TEST), l.enable(WebGL2RenderingContext.STENCIL_TEST), l.stencilMask(4294967295), l.clearStencil(0), l.clear(WebGL2RenderingContext.STENCIL_BUFFER_BIT), l.stencilOp(
      /*sfail=*/
      WebGL2RenderingContext.KEEP,
      /*dpfail=*/
      WebGL2RenderingContext.KEEP,
      /*dppass=*/
      WebGL2RenderingContext.REPLACE
    ), l.stencilFunc(
      /*func=*/
      WebGL2RenderingContext.ALWAYS,
      /*ref=*/
      1,
      /*mask=*/
      1
    );
    const d = this.viewer.perspectiveViewBackgroundColor.value;
    this.gl.clearColor(d[0], d[1], d[2], 0), l.clear(l.DEPTH_BUFFER_BIT), l.clearBufferfv(WebGL2RenderingContext.COLOR, ii.COLOR, [d[0], d[1], d[2], 0]), l.clearBufferfv(WebGL2RenderingContext.COLOR, ii.Z, km), l.clearBufferfv(WebGL2RenderingContext.COLOR, ii.PICK, km), l.enable(l.DEPTH_TEST);
    const u = this.projectionParameters.value;
    let h = ze();
    so(h, Xi[2], this.navigationState.pose.orientation.orientation), dy(h, h, -1);
    let g = 0.2, v = 1 - g;
    const y = {
      wireFrame: this.viewer.wireFrame.value,
      projectionParameters: u,
      lightDirection: h,
      ambientLighting: g,
      directionalLighting: v,
      pickIDs: e.pickIDs,
      emitter: Xg,
      emitColor: true,
      emitPickID: true,
      alreadyEmittedPickID: false
    };
    ru(e.invTransform, u.invViewProjectionMat);
    const C = this.visibleLayerTracker.visibleLayers;
    let w = false, b = false;
    for (const L of C) {
      var E = de(L, 2);
      const A = E[0], M = E[1];
      A.isTransparent ? w = true : A.isAnnotation ? b = true : A.draw(y, M);
    }
    if (this.drawSliceViews(y), b) {
      l.enable(WebGL2RenderingContext.BLEND), l.depthFunc(WebGL2RenderingContext.LEQUAL), l.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
      for (const L of C) {
        var T = de(L, 2);
        const A = T[0], M = T[1];
        A.isAnnotation && A.draw(y, M);
      }
      l.depthFunc(WebGL2RenderingContext.LESS), l.disable(WebGL2RenderingContext.BLEND);
    }
    if (this.viewer.showAxisLines.value && this.drawAxisLines(), l.stencilOp(
      /*sfail=*/
      WebGL2RenderingContext.KEEP,
      /*dpfail=*/
      WebGL2RenderingContext.KEEP,
      /*dppass=*/
      WebGL2RenderingContext.KEEP
    ), w) {
      l.depthMask(false), l.enable(WebGL2RenderingContext.BLEND);
      const L = this.transparentConfiguration;
      L.bind(n, r), this.gl.clearColor(0, 0, 0, 1), l.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT), y.emitter = B$, l.blendFuncSeparate(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA), y.emitPickID = false;
      for (const A of C) {
        var I = de(A, 2);
        const M = I[0], O = I[1];
        M.isTransparent && M.draw(y, O);
      }
      l.disable(WebGL2RenderingContext.DEPTH_TEST), this.offscreenFramebuffer.bindSingle(ii.COLOR), l.blendFunc(WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA, WebGL2RenderingContext.SRC_ALPHA), this.transparencyCopyHelper.draw(L.colorBuffers[0].texture, L.colorBuffers[1].texture), l.depthMask(true), l.disable(WebGL2RenderingContext.BLEND), l.enable(WebGL2RenderingContext.DEPTH_TEST), this.offscreenFramebuffer.bind(n, r), l.enable(WebGL2RenderingContext.STENCIL_TEST), l.drawBuffers([l.NONE, l.COLOR_ATTACHMENT1, l.COLOR_ATTACHMENT2]), y.emitter = Xg, y.emitPickID = true, y.emitColor = false, l.stencilFunc(
        /*func=*/
        WebGL2RenderingContext.NOTEQUAL,
        /*ref=*/
        3,
        /*mask=*/
        1
      ), l.stencilOp(
        /*sfail=*/
        WebGL2RenderingContext.KEEP,
        /*dpfail=*/
        WebGL2RenderingContext.KEEP,
        /*dppass=*/
        WebGL2RenderingContext.REPLACE
      ), l.stencilMask(2);
      for (const A of C) {
        var R = de(A, 2);
        const M = R[0], O = R[1];
        !M.isTransparent || !M.transparentPickEnabled || M.draw(y, O);
      }
      l.stencilFunc(
        /*func=*/
        WebGL2RenderingContext.EQUAL,
        /*ref=*/
        0,
        /*mask=*/
        3
      ), l.stencilOp(
        /*sfail=*/
        WebGL2RenderingContext.KEEP,
        /*dpfail=*/
        WebGL2RenderingContext.KEEP,
        /*dppass=*/
        WebGL2RenderingContext.KEEP
      ), l.stencilMask(0);
      for (const A of C) {
        var P = de(A, 2);
        const M = P[0], O = P[1];
        !M.isTransparent || M.transparentPickEnabled || M.draw(y, O);
      }
    }
    if (l.stencilMask(4294967295), l.disable(WebGL2RenderingContext.STENCIL_TEST), this.viewer.showScaleBar.value && this.viewer.orthographicProjection.value) {
      l.drawBuffers([l.COLOR_ATTACHMENT0]), l.disable(WebGL2RenderingContext.DEPTH_TEST), l.enable(WebGL2RenderingContext.BLEND), l.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
      const L = this.scaleBars, A = this.viewer.scaleBarOptions.value;
      L.draw(this.renderViewport, this.navigationState.displayDimensionRenderInfo.value, this.navigationState.relativeDisplayScales.value, this.navigationState.zoomFactor.value / this.renderViewport.logicalHeight, A), l.disable(WebGL2RenderingContext.BLEND);
    }
    return this.offscreenFramebuffer.unbind(), this.setGLClippedViewport(), this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[ii.COLOR].texture), true;
  }
  drawSliceViews(e) {
    let t = this.sliceViewRenderHelper, n = e.lightDirection, r = e.ambientLighting, s = e.directionalLighting, a = e.projectionParameters.viewProjectionMat;
    const l = this.viewer.showSliceViews.value;
    for (const h of this.sliceViews) {
      var d = de(h, 2);
      const g = d[0];
      if (!d[1] && !l)
        continue;
      var u = g.projectionParameters.value;
      const y = u.width, C = u.height, w = u.invViewMatrix, b = u.viewportNormalInCanonicalCoordinates;
      if (y === 0 || C === 0 || !g.valid)
        continue;
      let E = Math.abs(uy(n, b)), T = r + E * s, I = F$;
      ST(I), I[0] = y / 2, I[5] = -C / 2, vn(I, w, I), vn(I, a, I);
      const R = uE, P = this.viewer.crossSectionBackgroundColor.value;
      R[0] = P[0], R[1] = P[1], R[2] = P[2], R[3] = 1, t.draw(g.offscreenFramebuffer.colorBuffers[0].texture, I, bc(T, T, T, 1), uE, 0, 0, 1, 1);
    }
  }
  drawAxisLines() {
    const e = this.viewer.navigationState.zoomFactor.value, t = this.projectionParameters.value, n = Math.min(t.logicalWidth, t.logicalHeight) / this.renderViewport.logicalHeight / 4, r = e * n, s = this.gl;
    s.drawBuffers([s.COLOR_ATTACHMENT0]), this.axesLineHelper.draw(
      OI(t, r),
      /*blend=*/
      false
    );
  }
  zoomByMouse(e) {
    this.navigationState.zoomBy(e);
  }
};
var io;
(function(i) {
  i[i.COLOR = 0] = "COLOR", i[i.PICK = 1] = "PICK", i[i.NUM_TEXTURES = 2] = "NUM_TEXTURES";
})(io || (io = {}));
function G$(i) {
  i.addOutputBuffer("vec4", "out_fragColor", 0), i.addOutputBuffer("highp vec4", "out_pickId", 1), i.addFragmentCode(`
void emit(vec4 color, highp uint pickId) {
  out_fragColor = color;
  float pickIdFloat = float(pickId);
  out_pickId = vec4(pickIdFloat, pickIdFloat, pickIdFloat, 1.0);
}
`);
}
function W$(i) {
  i.addOutputBuffer("vec4", "out_fragColor", null), i.addFragmentCode(`
void emit(vec4 color, highp uint pickId) {
  out_fragColor = color;
}
`);
}
var qs = ze();
var H$ = ze();
var q$ = oh();
var Bh = class extends UI {
  constructor(e, t, n, r) {
    super(e, t, r), this.sliceView = n, this.axesLineHelper = this.registerDisposer(Oh.get(this.gl)), this.sliceViewRenderHelper = this.registerDisposer(xD.get(this.gl, W$)), this.colorFactor = bc(1, 1, 1, 1), this.pickIDs = new VI(), this.offscreenFramebuffer = this.registerDisposer(new So(this.gl, {
      colorBuffers: [new Zs(this.gl, WebGL2RenderingContext.RGBA8, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE), new Zs(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT)]
    })), this.offscreenCopyHelper = this.registerDisposer(bo.get(this.gl)), this.scaleBars = this.registerDisposer(new zI(this.gl)), r.wireFrame.changed.add(() => this.scheduleRedraw()), Ce(t, "rotate-via-mouse-drag", (s) => {
      const a = this.viewer.mouseState;
      if (a.updateUnconditionally()) {
        const l = Float32Array.from(a.position);
        Ui(s.detail, (d, u, h) => {
          const g = this.navigationState.pose, v = so(qs, Xi[0], g.orientation.orientation), y = so(H$, Xi[1], g.orientation.orientation);
          this.viewer.navigationState.pose.rotateAbsolute(y, -u / 4 * Math.PI / 180, l), this.viewer.navigationState.pose.rotateAbsolute(v, -h / 4 * Math.PI / 180, l);
        });
      }
    }), Ce(t, "rotate-in-plane-via-touchrotate", (s) => {
      const a = s.detail, l = this.viewer.mouseState;
      this.handleMouseMove(a.centerX, a.centerY), l.updateUnconditionally() && this.navigationState.pose.rotateAbsolute(this.sliceView.projectionParameters.value.viewportNormalInCanonicalCoordinates, a.angle - a.prevAngle, l.position);
    }), this.registerDisposer(n), this.visibleLayerTracker = gP(this.viewer.layerManager, xo, this.viewer.visibleLayerRoles, this), this.registerDisposer(r.crossSectionBackgroundColor.changed.add(() => this.scheduleRedraw())), this.registerDisposer(n.visibility.add(this.visibility)), this.registerDisposer(n.viewChanged.add(() => {
      this.visible && e.scheduleRedraw();
    })), this.registerDisposer(r.showAxisLines.changed.add(() => {
      this.visible && this.scheduleRedraw();
    })), this.registerDisposer(r.showScaleBar.changed.add(() => {
      this.visible && this.context.scheduleRedraw();
    })), this.registerDisposer(r.scaleBarOptions.changed.add(() => {
      this.visible && this.context.scheduleRedraw();
    }));
  }
  flushBackendProjectionParameters() {
    this.sliceView.flushBackendProjectionParameters();
  }
  get displayDimensionRenderInfo() {
    return this.navigationState.displayDimensionRenderInfo;
  }
  // FIXME: use separate backend object for the panel
  get rpc() {
    return this.sliceView.rpc;
  }
  get rpcId() {
    return this.sliceView.rpcId;
  }
  get navigationState() {
    return this.sliceView.navigationState;
  }
  translateByViewportPixels(e, t) {
    this.viewer.navigationState.pose.updateDisplayPosition((r) => {
      wm(r, -e, -t, 0), yi(r, r, this.sliceView.projectionParameters.value.invViewMatrix);
    });
  }
  translateDataPointByViewportPixels(e, t, n, r) {
    const s = this.sliceView.projectionParameters.value;
    return yi(e, t, s.viewMatrix), wm(e, e[0] + n, e[1] + r, e[2]), yi(e, e, s.invViewMatrix), e;
  }
  isReady() {
    if (!this.visible)
      return false;
    const e = this.sliceView;
    if (this.ensureBoundsUpdated(), !e.isReady())
      return false;
    const t = {
      projectionParameters: e.projectionParameters.value,
      sliceView: e
    };
    for (const r of this.visibleLayerTracker.visibleLayers) {
      var n = de(r, 2);
      const s = n[0], a = n[1];
      if (!s.isReady(t, a))
        return false;
    }
    return true;
  }
  drawWithPicking(e) {
    const t = this.sliceView;
    if (!t.valid)
      return false;
    t.updateRendering();
    const n = t.projectionParameters.value, r = n.width, s = n.height, a = n.invViewProjectionMat;
    ru(e.invTransform, a);
    const l = this.gl;
    this.offscreenFramebuffer.bind(r, s), l.disable(WebGL2RenderingContext.SCISSOR_TEST), this.gl.clearColor(0, 0, 0, 0), l.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
    const d = q$, u = this.viewer.crossSectionBackgroundColor.value;
    d[0] = u[0], d[1] = u[1], d[2] = u[2], d[3] = 1, this.offscreenFramebuffer.bindSingle(io.COLOR), this.sliceViewRenderHelper.draw(t.offscreenFramebuffer.colorBuffers[0].texture, TT, this.colorFactor, d, 0, 0, 1, 1);
    const h = this.visibleLayerTracker.visibleLayers;
    let g = this.pickIDs;
    g.clear();
    const v = {
      wireFrame: this.viewer.wireFrame.value,
      projectionParameters: n,
      pickIDs: g,
      emitter: G$,
      emitColor: true,
      emitPickID: true,
      sliceView: t
    };
    this.offscreenFramebuffer.bind(r, s), l.enable(WebGL2RenderingContext.BLEND), l.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
    for (const C of h) {
      var y = de(C, 2);
      const w = y[0], b = y[1];
      w.draw(v, b);
    }
    if (l.disable(WebGL2RenderingContext.BLEND), this.viewer.showAxisLines.value || this.viewer.showScaleBar.value) {
      if (this.offscreenFramebuffer.bindSingle(io.COLOR), this.viewer.showAxisLines.value) {
        const C = Math.min(n.logicalWidth, n.logicalHeight) / 4 * 1.5, w = this.viewer.navigationState.zoomFactor.value;
        this.axesLineHelper.draw(IN(OI(n, C * w)));
      }
      this.viewer.showScaleBar.value && (l.enable(WebGL2RenderingContext.BLEND), l.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA), this.scaleBars.draw(n, this.navigationState.displayDimensionRenderInfo.value, this.navigationState.relativeDisplayScales.value, this.navigationState.zoomFactor.value, this.viewer.scaleBarOptions.value), l.disable(WebGL2RenderingContext.BLEND));
    }
    return this.offscreenFramebuffer.unbind(), this.setGLClippedViewport(), this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[io.COLOR].texture), true;
  }
  ensureBoundsUpdated() {
    super.ensureBoundsUpdated(), this.sliceView.projectionParameters.setViewport(this.renderViewport);
  }
  issuePickRequest(e, t) {
    this.offscreenFramebuffer.readPixelFloat32IntoBuffer(io.PICK, e - mn, t - mn, 0, ft, ft);
  }
  completePickRequest(e, t, n, r) {
    const s = this.viewer.mouseState;
    s.pickedRenderLayer = null, FI(n, 0, 4, e, t, r.viewportWidth, r.viewportHeight);
    const a = r.viewportWidth, l = r.viewportHeight, d = Pu.length, u = this.navigationState.position.value, h = u.length, g = this.navigationState.pose.displayDimensions.value, v = g.displayRank, y = g.displayDimensionIndices, C = (E, T, I) => {
      const R = e + E, P = t + T;
      qs[0] = 2 * R / a - 1, qs[1] = 2 * P / l - 1, qs[2] = 0, yi(qs, qs, r.invTransform), I.set(u);
      for (let L = 0; L < v; ++L)
        I[y[L]] = qs[L];
    };
    let w = s.unsnappedPosition;
    w.length !== h && (w = s.unsnappedPosition = new Float32Array(h)), s.coordinateSpace = this.navigationState.coordinateSpace.value, s.displayDimensions = g, C(0, 0, w);
    const b = (E, T, I) => {
      let R = s.position;
      R.length !== h && (R = s.position = new Float32Array(h)), C(E - mn, T - mn, R), this.pickIDs.setMouseState(s, I), s.setActive(true);
    };
    for (let E = 0; E < d; ++E) {
      const T = Pu[E], I = n[4 * E];
      if (I === 0) continue;
      const R = T % ft, P = (T - R) / ft;
      b(R, P, I);
      return;
    }
    b(mn, mn, 0);
  }
  /**
   * Zooms by the specified factor, maintaining the data position that projects to the current mouse
   * position.
   */
  zoomByMouse(e) {
    const t = this.navigationState;
    if (!t.valid)
      return;
    var r = this.sliceView.projectionParameters.value;
    const s = r.width, a = r.height, l = r.invViewMatrix;
    var d = r.displayDimensionRenderInfo;
    const u = d.displayDimensionIndices, h = d.displayRank;
    let g = this.mouseX, v = this.mouseY;
    g -= s / 2, v -= a / 2;
    const y = this.navigationState.position.value;
    for (let C = 0; C < h; ++C) {
      const w = u[C], b = l[C] * g + l[4 + C] * v;
      y[w] += b * (1 - e);
    }
    this.navigationState.position.changed.dispatch(), t.zoomBy(e);
  }
};
function GI(i, e) {
  let t = "";
  for (let n = 0; n <= e && (t = i.toFixed(n), parseFloat(t) !== i); ++n)
    ;
  return t;
}
var j$ = ["#f00", "#0f0", "#00f"];
var hE = St.fromObject({
  arrowup: { action: "move-up" },
  arrowdown: { action: "move-down" },
  wheel: { action: "adjust-via-wheel" },
  enter: { action: "commit" },
  escape: { action: "cancel" }
});
function J$(i) {
  if (i < 1 || i > 1024) {
    const e = Zn(i) | 0, t = i / 2 ** e;
    return `${GI(t, 1)}p${e}`;
  }
  return i.toString();
}
var K$ = [(i) => i.name, (i) => i.scaleFactor];
var Y$ = 2e3;
var X$ = class extends X {
  constructor(e, t, n, r = "px") {
    super(), this.displayDimensionRenderInfo = e, this.zoom = t, this.depthRange = n, this.displayUnit = r, this.element = document.createElement("div"), this.dimensionGridContainer = document.createElement("div"), this.depthGridContainer = document.createElement("div"), this.defaultCheckbox = document.createElement("input"), this.dimensionElements = _e(Array(3), (w, b) => {
      const E = document.createElement("div");
      E.classList.add("neuroglancer-display-dimensions-widget-dimension"), E.style.display = "contents", Ce(E, "adjust-via-wheel", (A) => {
        const O = A.detail.deltaY;
        O !== 0 && this.zoomDimension(b, dc(O));
      });
      const T = document.createElement("input");
      T.classList.add("neuroglancer-display-dimensions-widget-name"), T.title = "Change display dimensions", T.spellcheck = false, T.autocomplete = "off", T.style.color = j$[b], T.style.gridColumn = "1", T.style.gridRow = `${b + 1}`, T.addEventListener("focus", () => {
        T.select();
      }), E.appendChild(T);
      const I = document.createElement("span");
      I.classList.add("neuroglancer-display-dimensions-widget-scale-factor");
      const R = document.createElement("input");
      R.spellcheck = false, R.title = "Change relative scale at which dimension is displayed", R.autocomplete = "off", I.style.gridColumn = "2", I.style.gridRow = `${b + 1}`, R.addEventListener("focus", () => {
        R.select();
      }), I.appendChild(R), E.appendChild(I);
      const P = document.createElement("span");
      P.classList.add("neuroglancer-display-dimensions-widget-scale"), P.style.gridColumn = "3", P.style.gridRow = `${b + 1}`, E.appendChild(P), this.dimensionGridContainer.appendChild(E);
      const L = {
        name: T,
        container: E,
        scaleFactor: R,
        scale: P,
        scaleFactorModified: false
      };
      T.addEventListener("input", () => {
        Xn(T), this.updateNameValidity();
      }), Ce(T, "commit", () => {
        this.updateNames();
      }), T.addEventListener("blur", (A) => {
        const M = A.relatedTarget;
        this.dimensionElements.some((O) => O.name === M) || this.updateNames() || this.updateView();
      }), I.addEventListener("click", (A) => {
        A.target !== R && (R.focus(), A.preventDefault());
      }), R.addEventListener("input", () => {
        Xn(R), L.scaleFactorModified = true;
      }), Ce(R, "commit", () => {
        this.updateScaleFactors();
      }), R.addEventListener("blur", () => {
        this.updateScaleFactors() || this.updateView();
      });
      for (const A of K$)
        Ce(A(L), "move-up", () => {
          b !== 0 && A(this.dimensionElements[b - 1]).focus();
        }), Ce(A(L), "move-down", () => {
          b !== 2 && A(this.dimensionElements[b + 1]).focus();
        });
      return L;
    }), this.scheduleUpdateView = Ct(() => this.updateView());
    const s = this.element, a = this.dimensionGridContainer, l = this.defaultCheckbox, d = document.createElement("label"), u = this.registerCancellable(dt(() => {
      s.dataset.active = "false";
    }, Y$)), h = () => {
      s.dataset.active = "true", u();
    };
    this.registerDisposer(t.changed.add(h)), this.registerDisposer(e.relativeDisplayScales.changed.add(h)), this.registerDisposer(n.changed.add(h)), s.classList.add("neuroglancer-display-dimensions-widget"), s.appendChild(a), a.classList.add("neuroglancer-display-dimensions-widget-dimension-grid"), s.addEventListener("pointerleave", () => {
      const w = document.activeElement;
      w instanceof HTMLElement && s.contains(w) && w.blur();
    }), l.type = "checkbox", d.appendChild(l), d.appendChild(document.createTextNode("Default")), d.title = "Display first 3 dimensions", d.classList.add("neuroglancer-display-dimensions-widget-default"), l.addEventListener("change", () => {
      this.updateDefault();
    }), a.appendChild(d), this.registerDisposer(e), this.registerDisposer(n), this.registerDisposer(t.changed.add(this.scheduleUpdateView)), this.registerDisposer(e.changed.add(this.scheduleUpdateView));
    const g = this.registerDisposer(new Gi(s, hE));
    g.allShortcutsAreGlobal = true, this.registerDisposer(new Hr(s, hE)), Ce(a, "cancel", () => {
      this.updateView();
      const w = document.activeElement;
      w instanceof HTMLElement && s.contains(w) && w.blur();
    });
    const v = this.depthGridContainer;
    v.classList.add("neuroglancer-depth-range-widget-grid"), s.appendChild(v);
    const y = document.createElement("label"), C = document.createElement("input");
    C.type = "checkbox", y.classList.add("neuroglancer-depth-range-relative-checkbox-label"), C.classList.add("neuroglancer-depth-range-relative-checkbox"), y.appendChild(C), y.appendChild(document.createTextNode("Zoom-relative")), C.addEventListener("change", () => {
      const w = C.checked;
      let b = this.depthRange.value;
      w !== b < 0 && (w ? b = -b / this.zoom.value : b = -b * this.zoom.value, this.depthRange.value = b);
    }), y.title = "Depth range is multiplied by scale", s.appendChild(y), Ce(v, "adjust-via-wheel", (w) => {
      const E = w.detail.deltaY;
      if (E === 0)
        return;
      const T = this.depthRange.value;
      this.depthRange.value = T * 2 ** dc(E);
    }), this.registerDisposer(Or((w, b, { factors: E }) => {
      st(v);
      const T = b.displayRank, I = b.globalDimensionNames, R = b.displayDimensionIndices, P = b.displayDimensionUnits, L = b.displayDimensionScales, A = b.canonicalVoxelFactors, M = [], O = () => {
        C.checked = this.depthRange.value < 0;
        let U = this.depthRange.value;
        U < 0 && (U *= -this.zoom.value);
        for (const V of M) {
          const $ = V.input;
          $.value = ia(U * V.scale, V.unit, { precision: 2, elide1: false }), Xn($);
        }
      }, F = (U) => {
        const V = nc(U.input.value);
        if (V === void 0 || V.unit !== U.unit) return false;
        let $ = V.scale / U.scale;
        return this.depthRange.value < 0 && ($ = -$ / this.zoom.value), this.depthRange.value = $, true;
      };
      for (let U = 0; U < T; ++U) {
        const V = R[U], $ = I[V], B = P[U], ue = E[V];
        let se = M.find((Pe) => Pe.unit === B && Pe.factor === ue);
        if (se === void 0) {
          const Pe = document.createElement("div");
          Pe.title = "Visible depth range", Pe.style.display = "contents", v.appendChild(Pe);
          const ae = document.createElement("span");
          ae.textContent = "±", Pe.appendChild(ae);
          const Ee = document.createElement("input");
          Ee.spellcheck = false, Ee.autocomplete = "off", Ee.addEventListener("focus", () => {
            Ee.select();
          }), Ce(Ee, "commit", () => {
            F(se);
          }), Ee.addEventListener("change", () => {
            F(se) || O();
          }), Ee.addEventListener("input", () => {
            Xn(Ee);
          }), Pe.appendChild(Ee);
          const ce = document.createElement("span");
          ce.classList.add("neuroglancer-depth-range-widget-dimension-names"), Pe.appendChild(ce), se = {
            unit: B,
            factor: ue,
            dimensionNames: [],
            input: Ee,
            label: ce,
            scale: L[U] / A[U]
          }, M.push(se);
        }
        se.dimensionNames.push($);
      }
      for (const U of M)
        U.dimensionNames.length !== T && (U.label.textContent = U.dimensionNames.join(" "));
      w.registerDisposer(Ce(v, "cancel", () => {
        O();
        const U = document.activeElement;
        U instanceof HTMLElement && v.contains(U) && U.blur();
      }));
      const q = w.registerCancellable(Ct(O));
      w.registerDisposer(this.depthRange.changed.add(q)), w.registerDisposer(this.zoom.changed.add(q)), O();
    }, e, this.relativeDisplayScales)), this.updateView();
  }
  zoomDimension(e, t) {
    this.updateScaleFactors();
    const n = this.displayDimensions, r = this.relativeDisplayScales, a = n.value.displayDimensionIndices[e];
    if (a === -1) return;
    const l = r.value.factors, d = new Float64Array(l);
    d[a] *= 2 ** -t, r.setFactors(d);
  }
  updateNameValidity() {
    const e = this.dimensionElements, t = this.displayDimensions.value.displayDimensionIndices, n = e.map((d) => d.name.value), r = Ty(n), a = this.displayDimensions.coordinateSpace.value.names, l = n.length;
    for (let d = 0; d < l; ++d) {
      let u = r[d];
      const h = n[d];
      let g = -1;
      h.length === 0 ? u = true : (g = a.indexOf(h), g === -1 && (u = false));
      const v = e[d];
      v.name.dataset.isValid = u.toString(), v.container.dataset.isModified = (g !== t[d]).toString();
    }
  }
  get displayDimensions() {
    return this.displayDimensionRenderInfo.displayDimensions;
  }
  get relativeDisplayScales() {
    return this.displayDimensionRenderInfo.relativeDisplayScales;
  }
  updateNames() {
    const e = this.dimensionElements.map((l) => l.name.value).filter((l) => l.length > 0);
    if (!fh(e)) return false;
    const t = this.displayDimensionRenderInfo.displayDimensions;
    if (e.length === 0)
      return t.reset(), true;
    const n = new Int32Array(3);
    n.fill(-1);
    const s = t.coordinateSpace.value.names, a = e.length;
    for (let l = 0; l < a; ++l) {
      const d = s.indexOf(e[l]);
      if (d === -1) return false;
      n[l] = d;
    }
    return He(n, t.value.displayDimensionIndices) || t.setDimensionIndices(a, n), true;
  }
  updateDefault() {
    this.displayDimensions.default = this.defaultCheckbox.checked;
  }
  updateScaleFactors() {
    const e = this.displayDimensions, t = this.relativeDisplayScales;
    var n = e.value;
    const r = n.displayDimensionIndices, s = n.displayRank, a = t.value.factors, l = this.dimensionElements, d = new Float64Array(a);
    for (let u = 0; u < s; ++u) {
      const h = l[u];
      if (!h.scaleFactorModified) continue;
      const g = Number(h.scaleFactor.value), v = r[u];
      !Lt(g) || g <= 0 || (d[v] = g);
    }
    return He(d, a) || t.setFactors(d), true;
  }
  updateView() {
    const e = this.dimensionElements, t = this.displayDimensions.default;
    var n = this.displayDimensionRenderInfo.value;
    const r = n.displayDimensionIndices, s = n.canonicalVoxelFactors, a = n.displayDimensionUnits, l = n.displayDimensionScales, d = n.globalDimensionNames, u = this.relativeDisplayScales.value.factors;
    this.defaultCheckbox.checked = t;
    const h = this.zoom.value, g = r[0];
    let v = true;
    if (g !== -1) {
      const y = a[0], C = u[g];
      for (let w = 1; w < 3; ++w) {
        const b = r[w];
        if (b !== -1 && (a[w] !== y || u[b] !== C)) {
          v = false;
          break;
        }
      }
    }
    for (let y = 0; y < 3; ++y) {
      const C = r[y], w = e[y];
      if (delete w.name.dataset.isValid, w.container.dataset.isModified = (C === -1).toString(), C === -1)
        w.name.value = "", w.scale.textContent = "", w.scaleFactor.value = "";
      else {
        w.name.value = d[C];
        const b = l[y] * h / s[y];
        if (y === 0 || !v) {
          const E = ia(b, a[y], { precision: 2, elide1: false });
          w.scale.textContent = `${E}/${this.displayUnit}`;
        } else
          w.scale.textContent = "";
        w.scaleFactor.value = J$(u[C]);
      }
      Xn(w.name), Xn(w.scaleFactor);
    }
  }
  disposed() {
    Ut(this.element), super.disposed();
  }
};
var WI = new he([["xy", void 0], ["xz", SN(Wn(), Wn(), Math.PI / 2)], ["yz", bN(Wn(), Wn(), Math.PI / 2)]]);
var HI = "◻";
var av = new he([["4panel", "◱"], ["3d", HI]]);
function Z$(i, e) {
  let t;
  return e === void 0 ? t = i.navigationState.addRef() : t = new Lo(new To(i.navigationState.pose.position.addRef(), i.navigationState.pose.displayDimensionRenderInfo.addRef(), ko.makeRelative(i.navigationState.pose.orientation, e)), i.navigationState.zoomFactor.addRef(), i.navigationState.depthRange.addRef()), new Cu(i.chunkManager, i.layerManager, t, i.wireFrame);
}
function Yl(i, e) {
  return Z$(i, WI.get(e));
}
function Q$(i) {
  return new he([["xy", Yl(i, "xy")], ["xz", Yl(i, "xz")], ["yz", Yl(i, "yz")]]);
}
function qI(i) {
  return {
    crossSectionBackgroundColor: i.crossSectionBackgroundColor,
    perspectiveViewBackgroundColor: i.perspectiveViewBackgroundColor,
    selectionDetailsState: i.selectionDetailsState,
    mouseState: i.mouseState,
    layerManager: i.layerManager,
    showAxisLines: i.showAxisLines,
    wireFrame: i.wireFrame,
    visibleLayerRoles: i.visibleLayerRoles,
    selectedLayer: i.selectedLayer,
    visibility: i.visibility,
    scaleBarOptions: i.scaleBarOptions
  };
}
function yS(i) {
  const e = i.viewer;
  return H(H({}, qI(e)), { navigationState: e.perspectiveNavigationState, inputEventMap: e.inputEventBindings.perspectiveView, orthographicProjection: i.specification.orthographicProjection, showScaleBar: e.showScaleBar, rpc: e.chunkManager.rpc });
}
function Ru(i) {
  return H(H({}, qI(i)), { navigationState: i.navigationState, inputEventMap: i.inputEventBindings.sliceView });
}
function Ro(i, e) {
  const t = e.navigationState;
  e.element.appendChild(i.registerDisposer(new X$(t.pose.displayDimensionRenderInfo.addRef(), t.zoomFactor, t.depthRange.addRef(), e instanceof Bh ? "px" : "vh")).element);
}
function Ao(i, e, t) {
  const n = document.createElement("div");
  n.className = "neuroglancer-data-panel-layout-controls", i.registerDisposer(() => Ut(n));
  for (let r = 0; r < 2; ++r) {
    const s = t[Math.min(t.length - 1, r)];
    i.registerDisposer(Ce(e.element, r === 0 ? "toggle-layout" : "toggle-layout-alternative", (a) => {
      i.container.name = s, a.stopPropagation();
    }));
  }
  for (const r of t) {
    const s = document.createElement("button"), a = document.createElement("div");
    s.appendChild(a), a.textContent = av.get(r), s.title = `Switch to ${r} layout.`, s.addEventListener("click", () => {
      i.container.name = r;
    }), n.appendChild(s);
  }
  e.element.appendChild(n);
}
function eG(i, e) {
  const t = new Cu(i.chunkManager, i.layerManager, e.navigationState.addRef(), i.wireFrame), n = () => {
    const r = e.width.value, s = e.height.value;
    t.projectionParameters.setViewport({
      width: r,
      height: s,
      logicalWidth: r,
      logicalHeight: s,
      visibleLeftFraction: 0,
      visibleTopFraction: 0,
      visibleWidthFraction: 1,
      visibleHeightFraction: 1
    });
  };
  return t.registerDisposer(e.width.changed.add(n)), t.registerDisposer(e.height.changed.add(n)), n(), t;
}
function SS(i, e, t) {
  const n = new he();
  (() => {
    const s = new Ye();
    for (const l of t.values()) {
      if (s.add(l), n.has(l))
        continue;
      const d = eG(i, l);
      e.sliceViews.set(d, true), n.set(l, d);
    }
    for (const l of n) {
      var a = de(l, 2);
      const d = a[0], u = a[1];
      s.has(d) || e.sliceViews.delete(u);
    }
  })();
}
var tG = class extends X {
  constructor(e, t, n, r) {
    super(), this.container = e, this.rootElement = t, this.viewer = n;
    let s = Q$(n), a = n.display;
    const l = H(H({}, yS(e)), { showSliceViews: n.showPerspectiveSliceViews, showSliceViewsCheckbox: true }), d = H(H({}, Ru(n)), { showScaleBar: n.showScaleBar }), u = H(H({}, Ru(n)), { showScaleBar: new nn(false, false) }), h = (v, y, C, w) => {
      const b = this.registerDisposer(new Bh(a, y, s.get(v), C));
      return w && Ro(this, b), Ao(this, b, [v, `${v}-3d`]), b;
    };
    let g = [mi(1, Ks("column", [mi(1, Ks("row", [mi(1, (v) => {
      h("xy", v, d, true);
    }), mi(1, (v) => {
      h("xz", v, u, false);
    })])), mi(1, Ks("row", [mi(1, (v) => {
      let y = this.registerDisposer(new vS2(a, v, l));
      for (let C of s.values())
        y.sliceViews.set(C.addRef(), false);
      Ro(this, y), SS(n, y, r), Ao(this, y, ["3d"]);
    }), mi(1, (v) => {
      h("yz", v, u, false);
    })]))]))];
    Ks("row", g)(t);
  }
  disposed() {
    st(this.rootElement), super.disposed();
  }
};
var nG = class extends X {
  constructor(e, t, n, r, s, a) {
    super(), this.container = e, this.rootElement = t, this.viewer = n, this.direction = r;
    let l = Yl(n, s), d = n.display;
    const u = H(H({}, yS(e)), { showSliceViews: n.showPerspectiveSliceViews, showSliceViewsCheckbox: true }), h = H(H({}, Ru(n)), { showScaleBar: n.showScaleBar });
    mi(1, Ks(r, [mi(1, (g) => {
      const v = this.registerDisposer(new Bh(d, g, l, h));
      Ro(this, v), Ao(this, v, [s, "4panel"]);
    }), mi(1, (g) => {
      let v = this.registerDisposer(new vS2(d, g, u));
      v.sliceViews.set(l.addRef(), false), SS(n, v, a), Ro(this, v), Ao(this, v, ["3d", "4panel"]);
    })]))(t);
  }
  disposed() {
    st(this.rootElement), super.disposed();
  }
};
var iG = class extends X {
  constructor(e, t, n, r) {
    super(), this.container = e, this.rootElement = t, this.viewer = n;
    let s = Yl(n, r);
    const a = H(H({}, Ru(n)), { showScaleBar: n.showScaleBar });
    Ks("row", [mi(1, (l) => {
      const d = this.registerDisposer(new Bh(n.display, l, s, a));
      Ro(this, d), Ao(this, d, ["4panel", `${r}-3d`]);
    })])(t);
  }
  disposed() {
    st(this.rootElement), super.disposed();
  }
};
var rG = class extends X {
  constructor(e, t, n, r) {
    super(), this.container = e, this.rootElement = t, this.viewer = n;
    let s = H(H({}, yS(e)), { showSliceViews: new nn(false, false) });
    Ks("row", [mi(1, (a) => {
      const l = this.registerDisposer(new vS2(n.display, a, s));
      SS(n, l, r), Ro(this, l), Ao(this, l, ["4panel"]);
    })])(t);
  }
  disposed() {
    st(this.rootElement), super.disposed();
  }
};
var ov = new he([["4panel", {
  factory: (i, e, t, n) => new tG(i, e, t, n)
}], ["3d", {
  factory: (i, e, t, n) => new rG(i, e, t, n)
}]]);
for (const i of WI.keys()) {
  ov.set(i, {
    factory: (t, n, r) => new iG(t, n, r, i)
  });
  const e = `${i}-3d`;
  av.set(i, HI), av.set(e, "◫"), ov.set(e, {
    factory: (t, n, r, s) => new nG(t, n, r, "row", i, s)
  });
}
function jI(i) {
  let e = ov.get(i);
  if (e === void 0)
    throw new Error(`Invalid layout name: ${oe(i)}.`);
  return e;
}
function sG(i) {
  return jI(i), i;
}
var aG = class extends X {
  constructor(e) {
    super(), this.width = new fn(1e3, un), this.height = new fn(1e3, un), this.changed = new Le(), this.position = new $D(e.position.addRef()), this.position.changed.add(this.changed.dispatch), this.orientation = new Km(e.pose.orientation.addRef()), this.orientation.changed.add(this.changed.dispatch), this.width.changed.add(this.changed.dispatch), this.height.changed.add(this.changed.dispatch), this.scale = new Ym(e.zoomFactor.addRef(), e.zoomFactor.displayDimensionRenderInfo.addRef()), this.scale.changed.add(this.changed.dispatch), this.navigationState = this.registerDisposer(new Lo(new To(this.position.value, e.pose.displayDimensionRenderInfo.addRef(), this.orientation.value), this.scale.value, e.depthRange.addRef()));
  }
  restoreState(e) {
    me(e), Dn(e, "width", this.width), Dn(e, "height", this.height), Dn(e, "position", uc(this.position)), Dn(e, "orientation", this.orientation), Dn(e, "scale", this.scale), Dn(e, "zoom", uc(this.scale));
  }
  reset() {
    this.width.reset(), this.height.reset(), this.position.reset(), this.orientation.reset(), this.scale.reset();
  }
  toJSON() {
    return {
      width: this.width.toJSON(),
      height: this.height.toJSON(),
      position: this.position.toJSON(),
      orientation: this.orientation.toJSON(),
      scale: this.scale.toJSON()
    };
  }
};
var oG = class extends Ay {
  constructor(e) {
    super((t, n) => t.registerDisposer(t.registerDisposer(n).changed.add(this.changed.dispatch))), this.parentNavigationState = e, this.registerDisposer(e);
  }
  restoreState(e) {
    me(e);
    for (const t of hn(e)) {
      const n = new aG(this.parentNavigationState);
      try {
        this.set(t, n.addRef()), n.restoreState(e[t]);
      } finally {
        n.dispose();
      }
    }
  }
  reset() {
    this.clear();
  }
  toJSON() {
    if (this.size === 0) return;
    const e = {};
    for (const n of this) {
      var t = de(n, 2);
      const r = t[0], s = t[1];
      e[r] = s.toJSON();
    }
    return e;
  }
};
var lG = class extends X {
  constructor(e, t) {
    super(), this.changed = new Le(), this.orthographicProjection = new nn(false), this.type = new fn(t, sG), this.type.changed.add(this.changed.dispatch), this.crossSections = this.registerDisposer(new oG(e.addRef())), this.crossSections.changed.add(this.changed.dispatch), this.orthographicProjection.changed.add(this.changed.dispatch), this.registerDisposer(e);
  }
  reset() {
    this.crossSections.clear(), this.orthographicProjection.reset(), this.type.reset();
  }
  restoreState(e) {
    this.crossSections.clear(), this.orthographicProjection.reset(), typeof e == "string" ? this.type.restoreState(e) : (me(e), Y(e, "type", (t) => this.type.restoreState(t)), Y(e, "orthographicProjection", (t) => this.orthographicProjection.restoreState(t)), Y(e, "crossSections", (t) => t !== void 0 && this.crossSections.restoreState(t)));
  }
  toJSON() {
    const e = this.type, t = this.crossSections, r = this.orthographicProjection.toJSON();
    return t.size === 0 && r === void 0 ? e.value : {
      type: e.value,
      crossSections: t.toJSON(),
      orthographicProjection: r
    };
  }
};
var cG = class extends X {
  constructor(e, t) {
    super(), this.viewer = e, this.element = document.createElement("div"), this.specification = this.registerDisposer(new lG(this.viewer.navigationState.addRef(), t)), this.element.style.flex = "1";
    const n = this.registerCancellable(dt(() => this.updateLayout(), 0));
    this.specification.type.changed.add(n), Ce(this.element, "toggle-orthographic-projection", () => this.specification.orthographicProjection.toggle()), this.registerDisposer(this.viewer.display.updateStarted.add(() => n.flush())), n();
  }
  get name() {
    return this.specification.type.value;
  }
  set name(e) {
    this.specification.type.value = e;
  }
  get changed() {
    return this.specification.changed;
  }
  toJSON() {
    return this.specification.toJSON();
  }
  restoreState(e) {
    this.specification.restoreState(e);
  }
  reset() {
    this.specification.reset();
  }
  disposeLayout() {
    let e = this.layout;
    e !== void 0 && (e.dispose(), this.layout = void 0);
  }
  updateLayout() {
    this.disposeLayout(), this.layout = jI(this.name).factory(this, this.element, this.viewer, this.specification.crossSections);
  }
  disposed() {
    this.disposeLayout(), super.disposed();
  }
};
var JI = new he();
function va(i, e) {
  JI.set(i, e);
}
function dG(i) {
  const e = new a3(i.credentialsManager);
  for (const n of JI) {
    var t = de(n, 2);
    const r = t[0], s = t[1];
    e.register(r, s(i));
  }
  return e;
}
var oa = class _oa extends Error {
  constructor(e, t, n, r) {
    let s = `Fetching ${oe(e)} resulted in HTTP error ${t}`;
    n && (s += `: ${n}`), s += ".", super(s), this.name = "HttpError", this.message = s, this.url = e, this.status = t, this.statusText = n, r && (this.response = r);
  }
  static fromResponse(e) {
    return new _oa(e.url, e.status, e.statusText, e);
  }
  static fromRequestError(e, t) {
    if (t instanceof TypeError) {
      let n;
      return typeof e == "string" ? n = e : n = e.url, new _oa(n, 0, "Network or CORS error");
    }
    return t;
  }
};
async function fE(i, e) {
  let t;
  try {
    t = await fetch(i, e);
  } catch (n) {
    throw oa.fromRequestError(i, n);
  }
  if (!t.ok) throw oa.fromResponse(t);
  return t;
}
function uG(i) {
  return i.arrayBuffer();
}
function Wi(i) {
  return i.json();
}
async function ws(i, e, t, n = Qt) {
  if (n === Qt) {
    const a = await fE(i, e);
    return await t(a);
  }
  const r = new AbortController(), s = n.add(() => r.abort());
  try {
    const a = await fE(i, H(H({}, e), { signal: r.signal }));
    return await t(a);
  } finally {
    s();
  }
}
function _o(i) {
  const e = /^([^:\/]+):\/\/([^\/]+)((?:\/.*)?)$/;
  let t = i.match(e);
  if (t === null)
    throw new Error(`Invalid URL: ${oe(i)}`);
  return { protocol: t[1], host: t[2], path: t[3] };
}
function Fh(i) {
  return i instanceof oa ? i.status === 0 || i.status === 403 || i.status === 404 : false;
}
var hG = 32;
var fG = 3;
var pG = 500;
var gG = 1e4;
function pE(i) {
  return Math.min(2 ** i * pG, gG / 2) * (1 + Math.random());
}
async function bS(i, e, t, n, r, s, a = Qt) {
  let l;
  e: for (let d = 0; ; ) {
    XV(a), d > 1 && await new Ft((u) => setTimeout(u, pE(d - 2))), l = await i.get(l, a);
    t: for (let u = 0; ; )
      try {
        return await ws(typeof e == "function" ? e(l.credentials) : e, r(l.credentials, t), n, a);
      } catch (h) {
        if (h instanceof oa) {
          if (s(h, l.credentials) === "refresh") {
            if (++d === fG) throw h;
            continue e;
          }
          if (++u === hG) throw h;
          await new Ft((g) => setTimeout(g, pE(u - 1)));
          continue t;
        }
        throw h;
      }
  }
}
function Ys(i, e, t, n, r = Qt) {
  return i === void 0 ? ws(e, t, n, r) : bS(i, e, t, n, (s, a) => {
    if (!s.accessToken) return a;
    const l = new Headers(a.headers);
    return l.set("Authorization", `${s.tokenType} ${s.accessToken}`), H(H({}, a), { headers: l });
  }, (s, a) => {
    const l = s.status;
    if (l === 401)
      return "refresh";
    if (l === 504 || l === 503)
      return "retry";
    if (l === 403 && !a.accessToken)
      return "refresh";
    throw s;
  }, r);
}
async function mG(i, e, t, n, r) {
  const s = await Ys(
    i,
    `${e}?prefix=${encodeURIComponent(t)}&delimiter=${encodeURIComponent(n)}`,
    /*init=*/
    {},
    (h) => h.text(),
    r
  ), a = new DOMParser().parseFromString(s, "application/xml"), l = a.evaluate('//*[name()="CommonPrefixes"]/*[name()="Prefix"]', a, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null), d = [];
  for (let h = 0, g = l.snapshotLength; h < g; ++h)
    d.push(l.snapshotItem(h).textContent || "");
  const u = a.evaluate('//*[name()="Contents"]/*[name()="Key"]', a, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let h = 0, g = u.snapshotLength; h < g; ++h)
    d.push(u.snapshotItem(h).textContent || "");
  return d;
}
async function lv(i, e, t, n, r) {
  if (!n.startsWith("/")) throw null;
  const a = await mG(i, t, n.substring(1), "/", r);
  let l = n.lastIndexOf("/");
  return {
    offset: l + e.length + 1,
    completions: a.map((d) => ({ value: d.substring(l) }))
  };
}
var vG = class extends Gc {
  constructor(e) {
    super(), this.bucket = e, this.get = Nh(async () => {
      var t;
      const n = this.bucket, r = await ws(`https://s3.amazonaws.com/${n}?location`, {}, (d) => d.text()), a = new DOMParser().parseFromString(r, "application/xml").querySelector("LocationConstraint");
      if (a === null)
        throw new Error(`Unable to determine location of S3 bucket: ${n}`);
      return { region: ((t = a.textContent) === null || t === void 0 ? void 0 : t.trim()) || "us-east-1" };
    });
  }
};
var Bd;
function KI(i) {
  return Bd === void 0 && (Bd = new NI(), Bd.register("s3", (e) => new vG(e))), Bd.getCredentialsProvider("s3", i);
}
async function yG(i, e, t, n, r, s = Qt) {
  const l = (await i.get()).credentials.region;
  return await ws(`https://${e}.s3.${l}.amazonaws.com${t}`, n, r, s);
}
async function SG(i, e, t) {
  const s = (await KI(i).get()).credentials.region;
  return await lv(void 0, `s3://${i}`, `https://${i}.s3.${s}.amazonaws.com`, e, t);
}
function bG(i, e) {
  return i.getCredentialsProvider("middleauthapp", new URL(e).origin);
}
function Fd(i, e, t) {
  const n = /^\/([^\/]+)/, r = t.match(n);
  if (r !== null)
    return typeof NEUROGLANCER_PYTHON_INTEGRATION < "u" ? i.getCredentialsProvider("gcs", { bucket: r[1] }) : i.getCredentialsProvider("ngauth_gcs", { authServer: e, bucket: r[1] });
}
function Ko(i, e) {
  const t = _o(i);
  switch (t.protocol) {
    case "gs":
    case "gs+json":
    case "gs+xml":
      return {
        credentialsProvider: typeof NEUROGLANCER_PYTHON_INTEGRATION < "u" ? e.getCredentialsProvider("gcs", { bucket: t.host }) : void 0,
        url: i
      };
    case "gs+ngauth+http":
      return {
        credentialsProvider: Fd(e, `http://${t.host}`, t.path),
        url: "gs:/" + t.path
      };
    case "gs+ngauth+https":
      return {
        credentialsProvider: Fd(e, `https://${t.host}`, t.path),
        url: "gs:/" + t.path
      };
    case "gs+xml+ngauth+http":
      return {
        credentialsProvider: Fd(e, `http://${t.host}`, t.path),
        url: "gs+xml:/" + t.path
      };
    case "gs+xml+ngauth+https":
      return {
        credentialsProvider: Fd(e, `https://${t.host}`, t.path),
        url: "gs+xml:/" + t.path
      };
    case "middleauth+https":
      return i = i.substr(11), {
        credentialsProvider: bG(e, i),
        url: i
      };
    case "s3":
      return {
        credentialsProvider: KI(t.host),
        url: i
      };
    default:
      return {
        credentialsProvider: void 0,
        url: i
      };
  }
}
async function ya(i, e, t, n, r = Qt) {
  const s = _o(e);
  switch (s.protocol) {
    case "gs":
      return Ys(i, `https://www.googleapis.com/storage/v1/b/${s.host}/o/${encodeURIComponent(s.path.substring(1))}?alt=media&neuroglancerOrigin=${encodeURIComponent(location.origin)}`, t, n, r);
    case "gs+json":
      return Ys(i, `https://storage.googleapis.com/storage/v1/b/${s.host}/o/${encodeURIComponent(s.path.substring(1))}?alt=media`, t, n, r);
    case "gs+xml":
      return Ys(i, `https://storage.googleapis.com/${s.host}${s.path}`, t, n, r);
    case "s3":
      return yG(i, s.host, s.path, t, n, r);
    default:
      return Ys(i, e, t, n, r);
  }
}
var wG = typeof STATE_SERVERS < "u" && hn(STATE_SERVERS).length > 0;
var CG = class extends X {
  constructor(e) {
    if (super(), this.element = document.createElement("div"), this.button = Tt({ text: "Share", title: "Share State" }), typeof STATE_SERVERS > "u")
      throw new Error("Cannot construct StateSare without defining STATE_SERVERS");
    if (hn(STATE_SERVERS).length > 1) {
      const n = document.createElement("select");
      n.style.marginRight = "5px", this.registerDisposer(e.selectedStateServer.changed.add(() => {
        const r = e.selectedStateServer.value;
        iv(STATE_SERVERS).map((s) => s.url).includes(r) && (n.value = r);
      })), this.registerEventListener(n, "change", () => {
        e.selectedStateServer.value = n.value;
      });
      for (let r of _c(STATE_SERVERS)) {
        var t = de(r, 2);
        let s = t[0], a = t[1];
        const l = document.createElement("option");
        l.textContent = s, l.value = a.url, l.selected = !!a.default, n.appendChild(l);
      }
      this.element.appendChild(n), this.selectStateServerElement = n;
    }
    this.element.appendChild(this.button), this.registerEventListener(this.button, "click", () => {
      const n = this.selectStateServerElement ? this.selectStateServerElement.value : iv(STATE_SERVERS)[0].url, r = new URL(n).protocol;
      var s = Ko(n, Jo);
      const a = s.url, l = s.credentialsProvider;
      rt.forPromise(ya(l, a, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: oe(e.state.toJSON())
      }, Wi).then((d) => {
        const u = new URL(d);
        u.protocol = r;
        const h = `${window.location.origin}/#!${u}`;
        navigator.clipboard.writeText(h).then(() => {
          rt.showTemporaryMessage("Share link copied to clipboard");
        });
      }).catch(() => {
        rt.showTemporaryMessage("Could not access state server.", 4e3);
      }), {
        initialMessage: `Posting state to ${n}.`,
        delay: true,
        errorPrefix: ""
      });
    });
  }
  disposed() {
    this.element.remove(), super.disposed();
  }
};
function xG(i) {
  return i.startsWith("key") ? i.substring(3) : i.startsWith("digit") || i.startsWith("arrow") ? i.substring(5) : i;
}
function EG(i) {
  return i.split("+").map(xG).join("+");
}
var kG = H(H({}, ga), { side: "left", row: 1 });
var TG = class {
  constructor() {
    this.location = new Is(kG);
  }
  get changed() {
    return this.location.changed;
  }
  toJSON() {
    return ha(this.location.toJSON());
  }
  reset() {
    this.location.reset();
  }
  restoreState(e) {
    this.location.restoreState(e);
  }
};
var LG = class extends ma {
  constructor(e, t, n, r, s) {
    super(e, t.location), this.bindings = n, this.toolBinder = s, this.scroll = document.createElement("div"), this.addTitleBar({ title: "Help" });
    const a = document.createElement("div");
    a.classList.add("neuroglancer-help-body");
    const l = this.scroll;
    l.classList.add("neuroglancer-help-scroll-container"), a.appendChild(l), this.addBody(a);
    const d = this.registerCancellable(Ct(() => this.updateView()));
    this.registerDisposer(s.changed.add(d)), this.registerDisposer(r.layersChanged.add(d)), this.updateView();
  }
  updateView() {
    const e = this.scroll, t = this.bindings, n = this.toolBinder;
    st(e);
    const r = new he();
    function s(y, C) {
      for (const b of y.parents)
        b.label !== void 0 ? a(b.label, b) : s(b, C);
      for (const b of y.bindings.entries()) {
        var w = de(b, 2);
        const E = w[0], T = w[1], I = E.indexOf(":"), R = E.substring(I + 1);
        C.set(R, T.action);
      }
    }
    function a(y, C) {
      if (r.has(C))
        return;
      const w = {
        label: y,
        entries: new he()
      };
      s(C, w.entries), r.set(C, w);
    }
    for (const y of t) {
      var l = de(y, 2);
      const C = l[0], w = l[1];
      a(C, w);
    }
    const d = (y, C) => {
      let w = document.createElement("h2");
      w.textContent = y, e.appendChild(w);
      for (const E of C) {
        var b = de(E, 2);
        const T = b[0], I = b[1];
        let R = document.createElement("div");
        R.className = "dt", R.textContent = EG(T);
        let P = document.createElement("div");
        P.className = "dd", P.textContent = I, e.appendChild(R), e.appendChild(P);
      }
    }, u = new he();
    for (const y of n.bindings) {
      var h = de(y, 2);
      const C = h[0], w = h[1];
      let b = u.get(w.layer);
      b === void 0 && (b = [], u.set(w.layer, b)), b.push([`shift+key${C.toLowerCase()}`, w.description]);
    }
    const g = _e(u.entries());
    g.length > 0 && (g[0][0].manager.root.layerManager.updateNonArchivedLayerIndices(), g.sort((y, C) => y[0].managedLayer.nonArchivedLayerIndex - C[0].managedLayer.nonArchivedLayerIndex));
    for (const y of g) {
      var v = de(y, 2);
      const C = v[0], w = v[1];
      w.sort(), d(`Tool bindings for layer ${C.managedLayer.nonArchivedLayerIndex + 1}: ${C.managedLayer.name}`, w);
    }
    for (const y of r.values())
      d(y.label, y.entries);
  }
};
function DG(i, e) {
  i.style.display = "block";
  const t = i.offsetWidth, n = i.offsetHeight, r = document.documentElement.clientWidth, s = document.documentElement.clientHeight, a = document.documentElement.scrollLeft + Math.min(r - t, e.clientX), l = document.documentElement.scrollTop + Math.min(s - n, e.clientY);
  i.style.left = a + "px", i.style.top = l + "px";
}
var IG = class extends X {
  constructor(e) {
    super(), this.element = document.createElement("div"), this.parentDisposers = new he(), this.disabledValue = false, this.opened = new Le(), this.closed = new Le();
    const t = this.element;
    t.className = "neuroglancer-context-menu", t.style.display = "none", t.tabIndex = -1, document.body.appendChild(t), e !== void 0 && this.registerParent(e);
  }
  get disabled() {
    return this.disabledValue;
  }
  set disabled(e) {
    this.disabledValue !== e && (this.disabledValue = e, e && this.hide());
  }
  get open() {
    return this.menuDisposer !== void 0;
  }
  registerParent(e) {
    const t = this.parentDisposers;
    t.has(e) || t.set(e, Oi(e, "contextmenu", (n) => {
      this.show(n), n.stopPropagation(), n.preventDefault();
    }));
  }
  show(e) {
    if (this.disabledValue)
      return;
    this.hide();
    const t = this.element, n = Oi(
      document,
      "mousedown",
      (a) => {
        a.target instanceof Node && !t.contains(a.target) && this.hide();
      },
      /*capture=*/
      true
    ), r = Oi(
      document,
      "keydown",
      (a) => {
        a.code === "Escape" && this.hide();
      },
      /*capture=*/
      true
    ), s = () => {
      r(), n(), t.style.display = "none";
    };
    this.opened.dispatch(), DG(t, e), this.menuDisposer = s;
  }
  unregisterParent(e) {
    const t = this.parentDisposers, n = t.get(e);
    n !== void 0 && (n(), t.delete(e));
  }
  disposed() {
    const e = this.parentDisposers;
    for (const t of e.values())
      t();
    e.clear(), Ut(this.element);
  }
  hide() {
    this.menuDisposer !== void 0 && (this.menuDisposer(), this.menuDisposer = void 0, this.closed.dispatch());
  }
};
function PG(i) {
  return RN(new TextEncoder().encode(i));
}
function RG(i) {
  return new TextDecoder().decode(AN(i));
}
function AG(i, e) {
  if (i.startsWith(e))
    try {
      const t = RG(i.substring(e.length));
      return JSON.parse(t);
    } catch {
      return;
    }
}
function _G(i, e) {
  return i + PG(oe(e));
}
function MG(i, e) {
  for (const t of i) {
    const n = AG(t, e);
    if (n !== void 0)
      return { parameters: n, dragType: t };
  }
}
var YI;
function wS(i, e) {
  return i.dataTransfer.dropEffect = e, YI = e, e;
}
function cv() {
  return YI;
}
function NG(i) {
  return i.draggable = true, Oi(i, "dragstart", (e) => {
    e.stopPropagation(), e.preventDefault();
  });
}
var XI = "neuroglancer-layer\0";
var Si;
function ZI(i, e) {
  var t;
  i.dataTransfer.setData(_G(XI, e.layers.map((s) => ({ name: s.name, visible: s.visible }))), oe({ layers: e.layers.map((s) => s.toJSON()), layout: e.layoutSpec })), Si !== void 0 && Si.disposer();
  let n, r = () => {
    e.manager.unregisterDisposer(r);
    for (const s of e.layers)
      s.dispose();
    e.manager.dispose(), Si === n && (Si = void 0);
  };
  Si = n = {
    manager: e.manager.addRef(),
    layers: e.layers.map((s) => s.addRef()),
    layoutSpec: e.layoutSpec,
    isLayerListPanel: (t = e.isLayerListPanel) !== null && t !== void 0 ? t : false,
    disposer: r
  };
}
function Uh(i = "none") {
  if (Si !== void 0) {
    if (i === "move") {
      const e = new Ye(Si.layers);
      Si.manager.layerManager.filter((t) => !e.has(t));
    }
    Si.disposer();
  }
}
function Au(i) {
  return MG(i.dataTransfer.types, XI);
}
function QI(i) {
  if (Si !== void 0 && Si.manager.rootLayers === i.rootLayers)
    return Si;
}
var gE = class {
  /**
   * Called in the 'drop' event handler to actually initialize the layers if they are external.
   * Returns false if any layers failed to initialized.
   */
  initializeExternalLayers(e) {
    const t = this.dragType;
    if (t !== void 0)
      try {
        var n = JSON.parse(e.dataTransfer.getData(t));
        const s = n.layers, a = n.layout;
        if (!Array.isArray(s) || this.numSourceLayers !== s.length)
          throw new Error("Invalid layer drop data");
        this.layoutSpec = a;
        for (const l of this.layers) {
          var r = de(l, 2);
          const d = r[0], u = r[1];
          aW(d, s[u]);
        }
      } catch {
        return false;
      }
    return true;
  }
  updateArchiveStates(e) {
    const t = this.targetIsLayerListPanel, n = e.dataTransfer.dropEffect;
    for (const r of this.layers.keys()) {
      let s = t;
      t && !r.archived && n !== "copy" && this.sourceIsLayerListPanel && (s = false), (r.archived !== s || s && r.visible) && (r.archived = s, s && (r.visible = false), r.layerChanged.dispatch());
    }
  }
  get method() {
    return this.sourceManager !== void 0 ? this.manager === this.sourceManager && this.sourceIsLayerListPanel === this.targetIsLayerListPanel ? "move" : "link" : "copy";
  }
  compatibleWithMethod(e) {
    return this.method === e ? true : this.forceCopy && e !== "copy" ? false : !this.moveSupported && e === "move";
  }
};
function eP(i, e, t) {
  let n;
  i.shiftKey ? n = "copy" : i.ctrlKey && t ? n = "move" : n = e;
  let r = "";
  const s = (a) => {
    r !== "" && (r += ", "), r += a;
  };
  return e !== "none" && n !== e && (i.shiftKey ? s(`release SHIFT to ${e}`) : s(`release CONTROL to ${e}`)), n !== "copy" && s("hold SHIFT to copy"), n !== "move" && t && e !== "move" && s("hold CONTROL to move"), { dropEffect: n, dropEffectMessage: r };
}
function tP(i, e, t, n) {
  const r = QI(e);
  let s = false, a;
  return r === void 0 ? a = "copy" : n ? (r.isLayerListPanel || (s = true), a = "link") : r.manager === e && r.isLayerListPanel === t ? (a = "move", s = true) : t ? a = "none" : (r.isLayerListPanel || (s = true), a = "link"), eP(i, a, s);
}
function OG(i, e, t, n) {
  const r = tP(i, e, t, n);
  return wS(i, r.dropEffect), r;
}
function dv(i, e, t) {
  const n = t.forceCopy, r = t.newTarget;
  var s = t.isLayerListPanel;
  const a = s === void 0 ? false : s, l = QI(e);
  if (!n && l !== void 0) {
    const u = !r && l.manager === e && (l.isLayerListPanel === a || l.isLayerListPanel), h = new gE();
    return h.manager = e, h.numSourceLayers = l.layers.length, h.sourceManager = l.manager, h.targetIsLayerListPanel = a, h.sourceIsLayerListPanel = l.isLayerListPanel, h.moveSupported = u, h.layers = new he(), h.forceCopy = false, h.layoutSpec = l.layoutSpec, u ? l.layers.forEach((g, v) => {
      h.layers.set(g, v);
    }) : l.layers.forEach((g, v) => {
      (r || !e.layerManager.has(g)) && h.layers.set(g.addRef(), v);
    }), h;
  }
  const d = Au(i);
  if (d !== void 0)
    try {
      const u = Xe(d.parameters, (g, v) => {
        const y = Y(g, "name", Ae);
        let C = Y(g, "visible", na);
        const w = new kS(y, e);
        return a && (C = false), w.visible = C, w.archived = a, [w, v];
      }), h = new gE();
      return h.numSourceLayers = u.length, h.targetIsLayerListPanel = a, h.sourceIsLayerListPanel = false, h.sourceManager = void 0, h.moveSupported = false, h.forceCopy = l !== void 0, h.manager = e, h.dragType = d.dragType, h.layers = new he(u), h;
    } catch {
    }
}
function uv(i, e) {
  return i.moveSupported ? false : (i.manager.layerManager.filter((t) => !i.layers.has(t)), e !== void 0 && i.layers.has(e));
}
function zh(i, e, t, n = false) {
  function r(s, a) {
    let l = i.dropLayers;
    var d = a ? tP(
      s,
      i.manager,
      n,
      /*newTarget=*/
      false
    ) : { dropEffect: cv(), dropEffectMessage: "" };
    const u = d.dropEffect, h = d.dropEffectMessage;
    if (u === void 0) return;
    wS(s, u);
    let g = true;
    if (!(l !== void 0 && !l.compatibleWithMethod(u) && (i.dropLayers = void 0, uv(l, t)))) {
      if (l === void 0) {
        if (l = i.dropLayers = dv(s, i.manager, { forceCopy: u === "copy", newTarget: false, isLayerListPanel: n }), l === void 0)
          return;
        g = l.method === "move";
      }
      if (t !== void 0 && l.layers.has(t))
        return { dropLayers: l, dropEffect: u, dropEffectMessage: h };
      if (g) {
        const v = i.manager.layerManager, y = new Ye();
        let C = Number.POSITIVE_INFINITY;
        const w = v.managedLayers = v.managedLayers.filter((E, T) => l.layers.has(E) ? (C === Number.POSITIVE_INFINITY && (C = T), y.add(E), false) : true);
        let b;
        t !== void 0 ? (b = w.indexOf(t), C <= b && ++b) : b = w.length;
        for (const E of l.layers.keys())
          y.has(E) || l.layers.delete(E);
        w.splice(b, 0, ...l.layers.keys()), v.layersChanged.dispatch();
      } else {
        let v;
        t !== void 0 && (v = i.manager.layerManager.managedLayers.indexOf(t));
        for (const y of l.layers.keys())
          i.manager.add(y, v);
      }
      return { dropLayers: l, dropEffect: u, dropEffectMessage: h };
    }
  }
  e.addEventListener("dragenter", (s) => {
    r(
      s,
      /*updateDropEffect=*/
      true
    ) !== void 0 ? s.preventDefault() : In(i.element, "drop");
  }), e.addEventListener("drop", (s) => {
    var a;
    s.preventDefault(), i.dragEnterCount = 0, In(i.element, "drop");
    const l = (a = r(
      s,
      /*updateDropEffect=*/
      false
    )) === null || a === void 0 ? void 0 : a.dropLayers;
    if (i.dropLayers = void 0, l !== void 0) {
      if (!l.initializeExternalLayers(s)) {
        uv(l);
        return;
      }
      l.updateArchiveStates(s), Uh(l.method === "move" ? void 0 : s.dataTransfer.dropEffect);
    }
  }), e.addEventListener("dragover", (s) => {
    const a = r(
      s,
      /*updateDropEffect=*/
      true
    );
    if (a === void 0) {
      In(i.element, "drop");
      return;
    }
    const l = a.dropLayers, d = a.dropEffect, u = a.dropEffectMessage, h = l.layers.size;
    let g = "";
    const v = l.numSourceLayers === 1 ? "" : "s", y = l.numSourceLayers;
    if (d === "none")
      g = `Cannot link dragged layer${v} here`;
    else {
      const C = y === h ? `${y}` : `${h}/${y}`;
      g = `Drop to ${d} ${C} layer${v}`;
    }
    u && (g += ` (${u})`), sr(i.element, "drop", g), s.preventDefault(), s.stopPropagation();
  });
}
function nP(i, e, t, n) {
  e.draggable = true, e.addEventListener("dragstart", (r) => {
    sr(e, "drag", "Drag layer to another layer bar/panel (including in another Neuroglancer window), or to the left/top/right/bottom edge of a layer group"), ZI(r, {
      manager: i.manager,
      layers: [t],
      layoutSpec: n.getLayoutSpec(),
      isLayerListPanel: n.isLayerListPanel
    }), r.stopPropagation();
  }), e.addEventListener("dragend", () => {
    In(e, "drag"), Uh();
  });
}
function iP(i) {
  i.element.addEventListener("dragenter", () => {
    ++i.dragEnterCount;
  }), i.element.addEventListener("dragleave", () => {
    if (--i.dragEnterCount !== 0) return;
    In(i.element, "drop");
    const e = i.dropLayers;
    e !== void 0 && (uv(e), i.manager.layerManager.layersChanged.dispatch(), i.dropLayers = void 0);
  });
}
var VG = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='binIconTitle'%3e%3ctitle%20id='binIconTitle'%3eBin%3c/title%3e%3cpath%20d='M19%206L5%206M14%205L10%205M6%2010L6%2020C6%2020.6666667%206.33333333%2021%207%2021%207.66666667%2021%2011%2021%2017%2021%2017.6666667%2021%2018%2020.6666667%2018%2020%2018%2019.3333333%2018%2016%2018%2010'/%3e%3c/svg%3e";
function ms(i = {}) {
  const e = Tt(H({ svg: VG }, i)), t = e.firstElementChild;
  return t.style.fill = "white", e;
}
var mE = {};
var vE;
function BG() {
  if (vE) return mE;
  vE = 1;
  var i = BD(), e = yD(), t = aUn();
  return i(i.S, "String", {
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function(r) {
      for (var s = e(r.raw), a = t(s.length), l = arguments.length, d = [], u = 0; a > u; )
        d.push(String(s[u++])), u < l && d.push(String(arguments[u]));
      return d.join("");
    }
  }), mE;
}
var Zg;
var yE;
function FG() {
  return yE || (yE = 1, BG(), Zg = mR().String.raw), Zg;
}
var Qg;
var SE;
function UG() {
  return SE || (SE = 1, Qg = { default: FG(), __esModule: true }), Qg;
}
var zG = UG();
var $l = Ws(zG);
var Xd = "neuroglancer-position";
var bE = St.fromObject({
  arrowup: { action: "adjust-up" },
  arrowdown: { action: "adjust-down" },
  arrowleft: { action: "maybe-tab-backward", preventDefault: false },
  arrowright: { action: "maybe-tab-forward", preventDefault: false },
  tab: { action: "tab-forward" },
  "shift+tab": { action: "tab-backward" },
  wheel: { action: "adjust-via-wheel" },
  backspace: { action: "delete-backward", preventDefault: false },
  enter: { action: "commit" },
  escape: { action: "cancel" }
});
var $G = [(i) => i.nameElement, (i) => i.coordinate, (i) => i.scaleElement];
function Zd(i, e) {
  const t = i.coordinateArrays[e];
  return t === void 0 ? t : i.units[e] != "" || i.scales[e] !== 1 ? null : t;
}
var GG = class {
  constructor(e, t) {
    this.coordinateSpace = e, this.container = document.createElement("div"), this.nameContainer = document.createElement("span"), this.nameElement = document.createElement("input"), this.scaleContainer = document.createElement("span"), this.scaleElement = document.createElement("input"), this.coordinate = document.createElement("input"), this.coordinateLabel = document.createElement("span"), this.coordinateLabelWidth = 0, this.dropdownOwner = void 0, this.modified = false, this.draggingPosition = false, this.hasFocus = false;
    const n = this.container, r = this.scaleElement, s = this.scaleContainer, a = this.coordinate, l = this.nameElement, d = this.nameContainer, u = this.coordinateLabel;
    n.title = "", n.classList.add("neuroglancer-position-dimension"), n.draggable = true, n.tabIndex = -1, n.appendChild(d), n.appendChild(r), d.appendChild(l), d.title = "Drag to reorder, double click to rename.  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).", s.appendChild(r), l.classList.add("neuroglancer-position-dimension-name"), l.disabled = true, l.spellcheck = false, l.autocomplete = "off", l.required = true, l.placeholder = " ", s.classList.add("neuroglancer-position-dimension-scale-container"), r.classList.add("neuroglancer-position-dimension-scale"), r.disabled = true, r.spellcheck = false, r.autocomplete = "off", n.appendChild(s), n.appendChild(a), a.type = "text", a.classList.add("neuroglancer-position-dimension-coordinate"), a.spellcheck = false, a.autocomplete = "off", a.pattern = $l`(-?\d+(?:\.(?:\d+)?)?)`;
    const h = Zd(e, t);
    if (h != null) {
      let g = 0;
      for (const v of h.labels)
        g = Math.max(g, v.length);
      this.coordinateLabelWidth = g, u.style.width = `${g + 2}ch`, n.appendChild(u);
    }
    a.required = true, a.placeholder = " ", u.classList.add("neuroglancer-position-dimension-coordinate-label");
  }
};
function hv(i, e, t, n) {
  return Math.floor((i - e) * (n - 1) / (t - e));
}
function WG(i, e, t) {
  const n = i.boundingBoxes, r = i.bounds, s = Math.floor(r.lowerBounds[e]), a = Math.ceil(r.upperBounds[e] - 1);
  if (!Lt(s) || !Lt(a))
    return;
  const l = [], d = (h) => hv(h, s, a, t), u = i.rank;
  for (const h of n) {
    const g = dL(h, e, u);
    g !== void 0 && (g.lower = d(g.lower), g.upper = d(Math.ceil(g.upper - 1)), l.push(g));
  }
  return l.sort((h, g) => {
    const v = h.lower - g.lower;
    return v !== 0 ? v : g.upper - g.upper;
  }), cT(l, (h, g) => {
    if (g === 0) return true;
    const v = l[g - 1];
    return v.lower !== h.lower || v.upper !== h.upper;
  }), { lowerBound: s, upperBound: a, normalizedBounds: l };
}
var fv = 10;
var pv = 15;
var HG = 10;
var em = fv + pv + HG;
function qG(i, e, t) {
  e.clearRect(0, 0, i.width, i.height);
  const n = t.normalizedBounds;
  function r(l) {
    e.fillRect(0, l, fv, 1);
  }
  e.fillStyle = "#fff";
  for (const l of n) {
    const d = l.lower, u = l.upper;
    r(d), r(u);
  }
  const s = n.length;
  e.fillStyle = "#ccc";
  for (let l = 0; l < s; ++l) {
    var a = n[l];
    const d = a.lower, u = a.upper, h = Math.floor(l * pv / s), g = Math.max(1, pv / s);
    e.fillRect(h + fv, d, g, u + 1 - d);
  }
}
function wE(i, e) {
  Xn(i, e.length + 1);
}
function CE(i) {
  const e = i.value;
  Xn(i), i.parentElement.dataset.isEmpty = e === "" ? "true" : "false";
}
var $h = class extends X {
  constructor(e, t, { copyButton: n = true } = {}) {
    super(), this.position = e, this.combiner = t, this.element = document.createElement("div"), this.dimensionContainer = document.createElement("div"), this.coordinateSpace = void 0, this.dimensionWidgets = new he(), this.dimensionWidgetList = [], this.dragSource = void 0;
    const r = this.element, s = this.dimensionContainer;
    if (this.registerDisposer(e.coordinateSpace.changed.add(this.registerCancellable(Ct(() => this.updateDimensions())))), r.className = "neuroglancer-position-widget", s.style.display = "contents", r.appendChild(s), n) {
      const l = or({
        title: "Copy position to clipboard",
        onClick: () => {
          const d = oi(this.getPositionText());
          rt.showTemporaryMessage(d ? "Position copied to clipboard" : "Failed to copy position to clipboard");
        }
      });
      l.addEventListener("dragstart", (d) => {
        d.dataTransfer.setData(Xd, oe({ position: e.toJSON(), dimensions: e.coordinateSpace.value.names })), d.dataTransfer.setData("text", this.getPositionText()), d.stopPropagation();
      }), l.draggable = true, r.appendChild(l);
    }
    this.registerDisposer(e.changed.add(this.registerCancellable(Ct(() => this.updateView()))));
    const a = this.registerDisposer(new Gi(r, bE));
    a.allShortcutsAreGlobal = true, this.registerDisposer(new Hr(r, bE)), this.registerDisposer(Ce(r, "cancel", (l) => {
      this.coordinateSpace = void 0, this.updateView(), this.closeDropdown();
      const d = l.target;
      d instanceof HTMLElement && d.blur();
    })), this.updateView();
  }
  openRegularDropdown(e, t) {
    t.classList.add("neuroglancer-position-dimension-dropdown");
    const n = document.createElement("canvas"), r = n.getContext("2d"), s = document.createElement("div"), a = document.createElement("div");
    a.appendChild(s);
    const l = document.createTextNode("");
    s.appendChild(l);
    const d = document.createElement("div"), u = document.createElement("div");
    a.classList.add("neuroglancer-position-dimension-dropdown-lowerbound"), d.classList.add("neuroglancer-position-dimension-dropdown-upperbound"), u.classList.add("neuroglancer-position-dimension-dropdown-hoverposition"), t.appendChild(a), t.appendChild(d), t.appendChild(u), t.appendChild(n);
    const h = 100;
    n.width = em, n.height = h, d.style.marginTop = `${h - 1}px`;
    let g, v, y;
    const C = () => {
      const I = this.dimensionWidgetList.indexOf(e);
      if (I === -1) return;
      const R = e.coordinateSpace, P = WG(R, I, h);
      if (P === void 0 || R.bounds.lowerBounds[I] + 1 === R.bounds.upperBounds[I]) {
        t.style.display = "none", e.container.dataset.dropdownVisible = void 0;
        return;
      }
      e.container.dataset.dropdownVisible = "true", t.style.display = "";
      const L = P.lowerBound, A = P.upperBound;
      g = L, v = A, l.textContent = L.toString(), d.textContent = A.toString(), qG(n, r, P);
      const M = this.position.value[I];
      if (M >= L && M <= A && (r.fillStyle = "#f66", r.fillRect(0, hv(M, L, A, h), em, 1)), y !== void 0 && y >= L && y <= A) {
        r.fillStyle = "#66f";
        const O = hv(y, L, A, h);
        r.fillRect(0, O, em, 1), u.textContent = y.toString();
        const F = s.clientHeight;
        s.style.visibility = O > F ? "" : "hidden", d.style.visibility = O < h - F ? "" : "hidden", u.style.display = "", u.style.visibility = "visible", u.style.marginTop = `${O}px`;
      } else
        s.style.visibility = "", u.style.display = "none", d.style.visibility = "";
    }, w = e.dropdownOwner, b = w.registerCancellable(Ct(C));
    w.registerDisposer(this.position.changed.add(b));
    const E = (I) => {
      if (g === void 0 || v === void 0) return;
      const R = n.getBoundingClientRect();
      let P = (I.clientY - R.top) / R.height;
      return P = Math.max(0, P), P = Math.min(1, P), Math.round(P * (v - g)) + g;
    }, T = (I) => {
      const R = this.dimensionWidgetList.indexOf(e);
      if (R === -1) return;
      const P = E(I);
      if (P === void 0) return;
      const L = this.position, A = L.value;
      A[R] = P + 0.5, e.modified = false, L.value = A;
    };
    n.addEventListener("pointermove", (I) => {
      y = E(I), b();
    }), n.addEventListener("pointerleave", () => {
      y = void 0, b();
    }), n.addEventListener("pointerdown", (I) => {
      I.preventDefault(), I.stopPropagation(), !(I.ctrlKey || I.altKey || I.shiftKey || I.metaKey) && (Ui(I, (R) => {
        e.dropdownOwner !== void 0 && (y = void 0, T(R), b(), e.draggingPosition = true);
      }, () => {
        e.draggingPosition = false, this.updateDropdownVisibility(e);
      }), T(I));
    }), C();
  }
  openCoordinateArrayDropdown(e, t, n) {
    t.classList.add("neuroglancer-position-dimension-coordinate-dropdown");
    const r = n.coordinates, s = n.labels, a = r.length;
    t.style.setProperty("--neuroglancer-coordinate-label-width", `${e.coordinateLabelWidth}ch`);
    for (let l = 0; l < a; ++l) {
      const d = document.createElement("div");
      d.classList.add("neuroglancer-dimension-dropdown-coordinate-entry");
      const u = document.createElement("div");
      u.classList.add("neuroglancer-dimension-dropdown-coordinate");
      const h = document.createElement("div");
      h.classList.add("neuroglancer-dimension-dropdown-coordinate-label"), h.textContent = s[l], u.textContent = r[l].toString(), d.appendChild(u), d.appendChild(h), d.addEventListener("click", () => {
        const g = this.dimensionWidgetList.indexOf(e);
        if (g === -1) return;
        const v = this.position, y = v.value;
        y[g] = r[l] + 0.5, e.modified = false, v.value = y;
      }), t.appendChild(d);
    }
  }
  openDropdown(e) {
    if (e.dropdownOwner !== void 0) return;
    const t = this.dimensionWidgetList.indexOf(e);
    if (t === -1) return;
    this.closeDropdown();
    const n = e.dropdownOwner = new X(), r = document.createElement("div");
    r.draggable = true, r.addEventListener("dragstart", (a) => {
      a.stopPropagation(), a.preventDefault();
    }), r.addEventListener("pointerenter", () => {
      e.hasFocus = true;
    }), r.tabIndex = -1, e.container.appendChild(r);
    const s = Zd(e.coordinateSpace, t);
    s == null ? this.openRegularDropdown(e, r) : this.openCoordinateArrayDropdown(e, r, s), this.widgetWithOpenDropdown = e, n.registerDisposer(() => {
      Ut(r), e.dropdownOwner = void 0, delete e.container.dataset.dropdownVisible, this.widgetWithOpenDropdown = void 0;
    }), n.registerEventListener(document, "pointerdown", (a) => {
      const l = a.target;
      l instanceof Node && e.container.contains(l) || this.closeDropdown(e);
    }, { capture: true });
  }
  closeDropdown(e = this.widgetWithOpenDropdown) {
    if (e === void 0) return;
    const t = e.dropdownOwner;
    t !== void 0 && t.dispose();
  }
  pasteString(e, t) {
    for (; ; ) {
      e.coordinate.focus();
      const n = t.match(/^\s*(-?\d+(?:\.(?:\d+)?)?)((?:\s+(?![\s,]))|(?:\s*,\s*))?/);
      if (n === null) break;
      if (n[1] !== void 0 && document.execCommand("insertText", void 0, n[1]), n[2] !== void 0) {
        const r = this.dimensionWidgetList, s = r.indexOf(e);
        if (s === -1 || s + 1 === r.length)
          break;
        const a = t.substring(n[0].length);
        e = r[s + 1], t = a;
        continue;
      }
      break;
    }
  }
  reorderDimensionTo(e, t) {
    if (e === t) return;
    const n = this.position.coordinateSpace;
    n.value = SL(n.value, e, t);
  }
  updateDropdownVisibility(e) {
    e.hasFocus || e.draggingPosition ? this.openDropdown(e) : this.closeDropdown(e);
  }
  newDimension(e, t) {
    const n = new GG(e, t);
    n.container.addEventListener("dragstart", (r) => {
      this.dragSource = n, r.stopPropagation(), r.dataTransfer.setData("neuroglancer-dimension", "");
    }), n.container.addEventListener("dragenter", (r) => {
      const s = this.dragSource;
      if (s === void 0 || s === n) return;
      const a = this.dimensionWidgetList, l = a.indexOf(s), d = a.indexOf(n);
      l === -1 || d === -1 || (r.preventDefault(), this.reorderDimensionTo(d, l));
    }), n.container.addEventListener("dragend", (r) => {
      this.dragSource === n && (this.dragSource = void 0);
    }), n.nameContainer.addEventListener("dblclick", () => {
      n.nameElement.disabled = false, n.nameElement.focus(), n.nameElement.select();
    }), n.scaleContainer.addEventListener("dblclick", () => {
      n.scaleElement.disabled = false, n.scaleElement.focus(), n.scaleElement.select();
    }), n.coordinate.addEventListener("focus", () => {
      n.coordinate.select();
    }), n.container.addEventListener("focusin", () => {
      n.hasFocus = true, this.updateDropdownVisibility(n);
    }), n.container.addEventListener("focusout", (r) => {
      const s = r.relatedTarget;
      s instanceof Node && n.container.contains(s) || (n.hasFocus = false, this.updateDropdownVisibility(n));
    }), n.container.addEventListener("click", (r) => {
      (!(r.target instanceof HTMLInputElement) || r.target.disabled) && n.coordinate.focus();
    }), n.coordinate.addEventListener("paste", (r) => {
      const s = n.coordinate, a = s.value, l = r.clipboardData;
      if (l === null) return;
      let d = l.getData("text"), u = s.selectionEnd, h = s.selectionStart;
      if (h !== 0 || u !== a.length) {
        h == null && (h = 0), u == null && (u = 0);
        const g = d.match(/[^\-0-9\.]/);
        g !== null && (d = d.substring(0, g.index)), d.length > 0 && document.execCommand("insertText", void 0, d);
      } else
        this.pasteString(n, d);
      r.preventDefault(), r.stopPropagation();
    }), n.coordinate.addEventListener("input", () => {
      n.modified = true;
      const r = n.coordinate, s = r.value;
      let a = r.selectionDirection, l = r.selectionEnd, d = r.selectionStart;
      d === null && (d = 0), l === null && (l = d);
      let u = "";
      const h = /[^\-0-9\.]/g;
      u += s.substring(0, d).replace(h, "");
      const g = u.length;
      u += s.substring(d, l).replace(h, "");
      const v = u.length;
      u += s.substring(l).replace(h, ""), r.value = u, r.selectionStart = g, r.selectionEnd = v, r.selectionDirection = a, wE(r, u), l === d && l === s.length && s.match(/^(-?\d+(?:\.(?:\d+)?)?)((?:\s+(?![\s,]))|(?:\s*,\s*))$/) && this.selectAdjacentCoordinate(n, 1);
    }), n.nameElement.addEventListener("input", () => {
      const r = n.nameElement;
      Xn(r), this.updateNameValidity();
    }), n.scaleElement.addEventListener("input", () => {
      const r = n.scaleElement;
      CE(r), this.updateScaleValidity(n);
    }), n.coordinate.addEventListener("blur", (r) => {
      const s = r.relatedTarget;
      this.dimensionWidgetList.some((a) => a.coordinate === s) || n.modified && this.updatePosition();
    }), n.nameElement.addEventListener("blur", (r) => {
      n.nameElement.disabled = true;
      const s = r.relatedTarget;
      this.dimensionWidgetList.some((a) => a.nameElement === s) || this.updateNames() || this.forceUpdateDimensions();
    }), n.scaleElement.addEventListener("blur", (r) => {
      n.scaleElement.disabled = true;
      const s = r.relatedTarget;
      this.dimensionWidgetList.some((a) => a.scaleElement === s) || this.updateScales() || this.forceUpdateDimensions();
    }), Ce(n.container, "adjust-via-wheel", (r) => {
      const a = r.detail.deltaY;
      a !== 0 && this.adjustDimension(n, dc(a));
    }), Ce(n.container, "adjust-up", () => {
      this.adjustDimension(n, -1);
    }), Ce(n.container, "adjust-down", () => {
      this.adjustDimension(n, 1);
    });
    for (const r of $G) {
      const s = r(n);
      Ce(s, "maybe-tab-forward", (a) => {
        this.handleLeftRightMovement(a, n, 1, r);
      }), Ce(s, "maybe-tab-backward", (a) => {
        this.handleLeftRightMovement(a, n, -1, r);
      }), Ce(s, "tab-forward", () => {
        this.selectAdjacentField(n, 1, r);
      }), Ce(s, "tab-backward", () => {
        this.selectAdjacentField(n, -1, r);
      });
    }
    return Ce(n.coordinate, "commit", () => {
      this.updatePosition();
    }), Ce(n.nameElement, "commit", () => {
      this.updateNames();
    }), Ce(n.scaleElement, "commit", () => {
      this.updateScales();
    }), Ce(n.coordinate, "delete-backward", (r) => {
      r.stopPropagation();
      const s = n.coordinate;
      s.selectionStart === s.selectionEnd && s.selectionStart === 0 && (r.preventDefault(), this.selectAdjacentCoordinate(n, -1));
    }), n;
  }
  forceUpdateDimensions() {
    let e = this.position.coordinateSpace.value;
    e.valid || (e = Vr), this.coordinateSpace = e;
    const t = this.dimensionWidgets, n = this.dimensionWidgetList;
    n.length = 0;
    var r = e;
    const s = r.names, a = r.ids, l = r.scales, d = r.units;
    rr(this.dimensionContainer, a.map((h, g) => {
      let v = t.get(h);
      v === void 0 ? (v = this.newDimension(e, g), t.set(h, v)) : v.coordinateSpace = e;
      const y = s[g];
      v.nameElement.value = y, delete v.nameElement.dataset.isValid, Xn(v.nameElement);
      const C = Zd(e, g);
      C === void 0 ? v.container.dataset.coordinateArray = "none" : C === null ? v.container.dataset.coordinateArray = "invalid" : v.container.dataset.coordinateArray = "valid", v.scaleContainer.title = "Drag to reorder, double click to change scale", C === null && (v.scaleContainer.title += ".  Coordinate array disabled.  To use the coordinate array, remove the unit/scale.");
      var w = sL(l[g], d[g]);
      const b = w.scale, E = w.prefix, T = w.unit, I = `${b}${E}${T}`;
      return v.scaleElement.value = I, delete v.scaleElement.dataset.isValid, CE(v.scaleElement), n.push(v), v.container;
    }));
    for (const h of t) {
      var u = de(h, 2);
      const g = u[0], v = u[1];
      v.coordinateSpace !== e && (this.closeDropdown(v), t.delete(g));
    }
  }
  updateDimensions() {
    this.position.coordinateSpace.value !== this.coordinateSpace && this.forceUpdateDimensions();
  }
  selectAdjacentField(e, t, n) {
    const r = this.dimensionWidgetList;
    let s = r.indexOf(e);
    if (s !== -1)
      for (; ; ) {
        if (s += t, s < 0 || s >= r.length)
          return false;
        const a = r[s], l = n(a);
        if (l.style.display !== "none")
          return l.disabled = false, l.focus(), l.selectionStart = 0, l.selectionEnd = l.value.length, l.selectionDirection = t === 1 ? "forward" : "backward", true;
      }
  }
  selectAdjacentCoordinate(e, t) {
    return this.selectAdjacentField(e, t, (n) => n.coordinate);
  }
  handleLeftRightMovement(e, t, n, r) {
    e.stopPropagation();
    const s = r(t);
    s.selectionStart !== s.selectionEnd || s.selectionStart !== (n === 1 ? s.value.length : 0) || this.selectAdjacentField(t, n, r) && e.preventDefault();
  }
  updateNameValidity() {
    const e = this.dimensionWidgetList, t = e.map((s) => s.nameElement.value), n = t.length, r = this.combiner.getRenameValidity(t);
    for (let s = 0; s < n; ++s)
      e[s].nameElement.dataset.isValid = r[s] === false ? "false" : "true";
  }
  updateScaleValidity(e) {
    const t = nc(e.scaleElement.value) !== void 0;
    e.scaleElement.dataset.isValid = t.toString();
  }
  adjustDimension(e, t) {
    const n = this.dimensionWidgetList.indexOf(e);
    if (n === -1) return;
    this.updatePosition();
    const r = this.position;
    if (!r.valid)
      return;
    const a = r.coordinateSpace.value.bounds, l = Float32Array.from(r.value);
    let d = Math.floor(l[n] + t);
    if (t > 0) {
      const u = a.upperBounds[n];
      Lt(u) && (d = Math.min(d, Math.ceil(u - 1)));
    } else {
      const u = a.lowerBounds[n];
      Lt(u) && (d = Math.max(d, Math.floor(u)));
    }
    l[n] = d + 0.5, this.position.value = l, this.updateView();
  }
  updatePosition() {
    const e = this.dimensionWidgetList, t = this.position, n = t.value;
    if (n === void 0) return;
    const r = e.length;
    for (let s = 0; s < r; ++s) {
      const a = e[s];
      a.modified = false;
      const l = Number(a.coordinate.value);
      Lt(l) && (n[s] = l + (jn(l) ? 0.5 : 0));
    }
    t.value = n;
  }
  updateNames() {
    const e = this.dimensionWidgetList, t = this.position.coordinateSpace, n = t.value, r = e.map((d) => d.nameElement.value);
    if (this.combiner.getRenameValidity(r).includes(false)) return false;
    const s = n.names;
    if (He(s, r)) return false;
    const a = n.timestamps.map((d, u) => s[u] === r[u] ? d : Date.now()), l = H(H({}, n), { names: r, timestamps: a });
    return t.value = l, true;
  }
  updateScales() {
    const e = this.dimensionWidgetList, t = this.position.coordinateSpace, n = t.value, r = e.map((g) => nc(g.scaleElement.value));
    if (r.includes(void 0))
      return false;
    const s = Float64Array.from(r, (g) => g.scale), a = _e(r, (g) => g.unit), l = n.scales, d = n.units;
    if (He(l, s) && He(d, a)) return false;
    const u = n.timestamps.map((g, v) => s[v] === l[v] && a[v] === d[v] ? g : Date.now()), h = yt({
      valid: n.valid,
      rank: n.rank,
      scales: s,
      units: a,
      timestamps: u,
      ids: n.ids,
      names: n.names,
      boundingBoxes: n.boundingBoxes,
      coordinateArrays: n.coordinateArrays
    });
    return t.value = h, true;
  }
  getPositionText() {
    const e = this.position;
    return e.valid ? e.value.map((t) => Math.floor(t)).join(", ") : "";
  }
  updateView() {
    this.updateDimensions();
    const e = this.position.value, t = this.dimensionWidgetList, n = t.length;
    if (e === void 0)
      return;
    const r = this.coordinateSpace;
    for (let s = 0; s < n; ++s) {
      const a = t[s], l = a.coordinate, d = Math.floor(e[s]), u = d.toString();
      wE(l, u), l.value = u;
      const h = Zd(r, s);
      let g = "";
      if (h != null) {
        const y = h.coordinates, C = $M(y, d, (w, b) => w - b);
        C !== y.length && (g = h.labels[C]);
      }
      const v = a.coordinateLabel;
      v.textContent = g;
    }
  }
  disposed() {
    this.closeDropdown(), Ut(this.element), super.disposed();
  }
};
var jG = class extends X {
  constructor(e, t, n) {
    super(), this.element = e, this.mouseState = t, this.coordinateSpace = n, this.tempPosition = ze(), e.className = "neuroglancer-mouse-position-widget";
    const r = this.registerCancellable(Ct(() => this.updateView()));
    this.registerDisposer(t.changed.add(r)), this.registerDisposer(n.changed.add(r));
  }
  updateView() {
    let e = "";
    const t = this.mouseState, n = this.coordinateSpace.value;
    if (t.active && n !== void 0) {
      const r = t.position, s = n.rank, a = n.names;
      for (let l = 0; l < s; ++l)
        l !== 0 && (e += "  "), e += `${a[l]} ${Math.floor(r[l])}`;
    }
    this.element.textContent = e;
  }
  disposed() {
    Ut(this.element), super.disposed();
  }
};
var JG = class extends X {
  constructor(e, t) {
    var n;
    super(), this.layer = e, this.panel = t, this.element = document.createElement("div"), this.layerNumberElement = document.createElement("div"), this.labelElement = document.createElement("div"), this.visibleProgress = document.createElement("div"), this.prefetchProgress = document.createElement("div"), this.labelElementText = document.createTextNode(""), this.valueElement = document.createElement("div"), this.maxLength = 0, this.prevValueText = "";
    const r = this.element, s = this.labelElement, a = this.layerNumberElement, l = this.valueElement, d = this.visibleProgress, u = this.prefetchProgress, h = this.labelElementText;
    r.className = "neuroglancer-layer-item neuroglancer-noselect", r.appendChild(d), r.appendChild(u), s.className = "neuroglancer-layer-item-label", s.appendChild(h), d.className = "neuroglancer-layer-item-visible-progress", u.className = "neuroglancer-layer-item-prefetch-progress", a.className = "neuroglancer-layer-item-number", l.className = "neuroglancer-layer-item-value";
    const g = document.createElement("div");
    g.className = "neuroglancer-layer-item-value-container";
    const v = document.createElement("div");
    v.className = "neuroglancer-layer-item-button-container";
    const y = aS();
    y.title = "Remove layer from this layer group";
    const C = BU();
    C.title = "Refresh data", this.registerEventListener(C, "click", (E) => {
      E.stopPropagation();
      const T = this.layer.layer;
      if (T && T.dataSources && T.dataSources[0].loadState) {
        const I = T.dataSources[0].loadState;
        if (I instanceof Zy) {
          const R = I.dataSource;
          if (R && R.subsources[0] && R.subsources[0].subsource) {
            const P = R.subsources[0].subsource.annotation;
            (P == null ? void 0 : P.invalidateCache) && P.invalidateCache();
          }
        }
      }
    }), y.addEventListener("click", (E) => {
      this.panel.layerManager === this.panel.manager.rootLayers ? this.layer.setArchived(true) : this.layer.containers.size > 2 ? this.panel.layerManager.removeManagedLayer(this.layer) : this.layer.setArchived(true), E.stopPropagation();
    });
    const w = ms();
    w.title = "Delete this layer", w.addEventListener("click", (E) => {
      Qo(this.layer), E.stopPropagation();
    }), r.appendChild(a), g.appendChild(l), g.appendChild(v), v.appendChild(y), v.appendChild(w), r.appendChild(s), !((n = e.layer) === null || n === void 0) && n.allowingRefresh && r.appendChild(C), r.appendChild(g);
    const b = this.registerDisposer(new $h(e.localPosition, e.localCoordinateSpaceCombiner, { copyButton: false }));
    r.appendChild(b.element), b.element.addEventListener("click", (E) => {
      E.stopPropagation();
    }), b.element.addEventListener("dblclick", (E) => {
      E.stopPropagation();
    }), r.addEventListener("click", (E) => {
      E.ctrlKey ? t.selectedLayer.toggle(e) : E.altKey ? e.pickEnabled = !e.pickEnabled : e.setVisible(!e.visible);
    }), r.addEventListener("contextmenu", (E) => {
      t.selectedLayer.layer = e, t.selectedLayer.visible = true, E.stopPropagation(), E.preventDefault();
    }), nP(t, r, e, { getLayoutSpec: () => t.getLayoutSpecForDrag() }), zh(this.panel, r, this.layer);
  }
  update() {
    const e = this.layer, t = this.element;
    this.labelElementText.textContent = e.name, t.dataset.visible = e.visible.toString(), t.dataset.selected = (e === this.panel.selectedLayer.layer).toString(), t.dataset.pick = e.pickEnabled.toString();
    let n = `Click to ${e.visible ? "hide" : "show"}, control+click to show side panel`;
    e.supportsPickOption && (n += `, alt+click to ${e.pickEnabled ? "disable" : "enable"} spatial object selection`), n += ", drag to move, shift+drag to copy", t.title = n;
  }
  disposed() {
    this.element.remove(), super.disposed();
  }
};
var KG = class extends X {
  constructor(e, t, n, r, s, a) {
    super(), this.display = e, this.manager = t, this.viewerNavigationState = n, this.selectedLayer = r, this.getLayoutSpecForDrag = s, this.showLayerHoverValues = a, this.layerWidgets = new he(), this.element = document.createElement("div"), this.layerUpdateNeeded = true, this.valueUpdateNeeded = false, this.layerWidgetInsertionPoint = document.createElement("div"), this.positionWidget = this.registerDisposer(new $h(this.viewerNavigationState.position.value, this.manager.root.coordinateSpaceCombiner)), this.dragEnterCount = 0, this.scheduleUpdate = this.registerCancellable(Ct(() => this.update())), this.registerDisposer(r);
    const l = this.element;
    l.className = "neuroglancer-layer-panel", this.registerDisposer(t.layerSelectedValues.changed.add(() => {
      this.handleLayerValuesChanged();
    })), this.registerDisposer(t.layerManager.layersChanged.add(() => {
      this.handleLayersChanged();
    })), this.registerDisposer(r.changed.add(() => {
      this.handleLayersChanged();
    })), this.registerDisposer(a.changed.add(() => {
      this.handleLayerItemValueChanged();
    })), this.element.dataset.showHoverValues = this.showLayerHoverValues.value.toString(), this.layerWidgetInsertionPoint.style.display = "none", this.element.appendChild(this.layerWidgetInsertionPoint);
    let d = Tt({
      svg: Lu,
      title: "Click to add layer, control+click/right click/⌘+click to add local annotation layer."
    });
    d.classList.add("neuroglancer-layer-add-button");
    let u = this.dropZone = document.createElement("div");
    u.className = "neuroglancer-layer-panel-drop-zone";
    const h = (v) => {
      if (v.ctrlKey || v.metaKey || v.type === "contextmenu") {
        const y = SP(this.manager, "annotation", { type: "annotation", source: "local://annotations" });
        this.manager.add(y), this.selectedLayer.layer = y, this.selectedLayer.visible = true;
      } else
        this.addLayerMenu();
    };
    this.registerEventListener(d, "click", h), this.registerEventListener(d, "contextmenu", h), l.appendChild(d), l.appendChild(u), this.registerDisposer(NG(d)), l.appendChild(this.positionWidget.element);
    const g = () => {
      const v = this.viewerNavigationState.position.link.value;
      this.positionWidget.element.style.display = v === qt.LINKED ? "none" : "";
    };
    this.registerDisposer(this.viewerNavigationState.position.link.changed.add(g)), g(), this.update(), this.updateChunkStatistics(), iP(this), zh(this, u, void 0), this.registerDisposer(e.updateStarted.add(() => this.updateLayers())), this.registerDisposer(t.chunkManager.layerChunkStatisticsUpdated.add(this.registerCancellable(Ct(() => this.updateChunkStatistics()))));
  }
  get layerManager() {
    return this.manager.layerManager;
  }
  disposed() {
    this.layerWidgets.forEach((e) => e.dispose()), this.layerWidgets = void 0, Ut(this.element), super.disposed();
  }
  handleLayersChanged() {
    this.layerUpdateNeeded = true, this.handleLayerValuesChanged();
  }
  handleLayerValuesChanged() {
    this.valueUpdateNeeded || (this.valueUpdateNeeded = true, this.scheduleUpdate());
  }
  handleLayerItemValueChanged() {
    this.element.dataset.showHoverValues = this.showLayerHoverValues.value.toString();
  }
  update() {
    if (this.valueUpdateNeeded = false, this.updateLayers(), this.showLayerHoverValues.value === false)
      return;
    let e = this.manager.layerSelectedValues;
    for (let n of this.layerWidgets) {
      var t = de(n, 2);
      let r = t[0], s = t[1], a = r.layer, l = "";
      if (a !== null) {
        let d = e.get(a);
        if (d !== void 0) {
          const u = d.value;
          u !== void 0 && (l = "" + u);
        }
      }
      if (l !== s.prevValueText) {
        if (s.prevValueText = l, l.length > s.maxLength) {
          const d = s.maxLength = l.length;
          s.valueElement.style.width = `${d}ch`;
        }
        s.valueElement.textContent = l;
      }
    }
  }
  updateChunkStatistics() {
    for (const t of this.layerWidgets) {
      var e = de(t, 2);
      const n = e[0], r = e[1];
      let s = 0, a = 0, l = 0, d = 0;
      const u = n.layer;
      if (u !== null)
        for (const h of u.renderLayers) {
          const g = h.layerChunkProgressInfo;
          s += g.numVisibleChunksNeeded, a += g.numVisibleChunksAvailable, l += g.numPrefetchChunksNeeded, d += g.numPrefetchChunksAvailable;
        }
      r.visibleProgress.style.width = `${a / Math.max(1, s) * 100}%`, r.prefetchProgress.style.width = `${d / Math.max(1, l) * 100}%`;
    }
  }
  updateLayers() {
    var e;
    if (!this.layerUpdateNeeded)
      return;
    this.layerUpdateNeeded = false;
    let t = this.element, n = new Ye(), r = this.layerWidgetInsertionPoint.nextElementSibling;
    this.manager.rootLayers.updateNonArchivedLayerIndices();
    for (const l of this.manager.layerManager.managedLayers) {
      if (l.archived && !(!((e = this.dropLayers) === null || e === void 0) && e.layers.has(l))) continue;
      n.add(l);
      let d = this.layerWidgets.get(l);
      const u = l.nonArchivedLayerIndex;
      d === void 0 && (d = new JG(l, this), this.layerWidgets.set(l, d)), d.layerNumberElement.textContent = "" + (1 + u), d.update();
      var s = d;
      let h = s.element;
      h !== r && t.insertBefore(d.element, r), r = h.nextElementSibling;
    }
    for (let l of this.layerWidgets) {
      var a = de(l, 2);
      let d = a[0], u = a[1];
      n.has(d) || (this.layerWidgets.delete(d), u.dispose());
    }
  }
  addLayerMenu() {
    TP(this.manager, this.selectedLayer);
  }
};
function rP(i, e) {
  const t = Oi(i, "drop", (a) => {
    if (a.preventDefault(), a.dataTransfer.types.indexOf(Xd) !== -1) {
      a.stopPropagation();
      const l = me(JSON.parse(a.dataTransfer.getData(Xd))), d = Y(l, "dimensions", Ly), u = Y(l, "position", (y) => Xe(y, Dt));
      if (u.length !== d.length)
        throw new Error("length mismatch between position and dimensions");
      const h = u.length, g = e.coordinateSpace.value.names, v = e.value;
      for (let y = 0; y < h; ++y) {
        const C = g.indexOf(d[y]);
        C !== -1 && (v[C] = u[y]);
      }
      e.changed.dispatch();
    }
  }), n = (a) => {
    a.dataTransfer.types.indexOf(Xd) !== -1 && (a.dataTransfer.dropEffect = "link", a.preventDefault(), a.stopPropagation());
  }, r = Oi(i, "dragenter", n), s = Oi(i, "dragover", n);
  return () => {
    r(), s(), t();
  };
}
var sP = class extends X {
  constructor(e) {
    super(), this.model = e, this.element = document.createElement("select"), this.valueIndexMap = new he();
    const t = this.element, n = this.valueIndexMap;
    let r = 0;
    for (const s of hn(e.enumType))
      if (isNaN(Number(s))) {
        const a = document.createElement("option");
        a.textContent = a.value = s.toLowerCase(), t.appendChild(a), n.set(e.enumType[s], r), ++r;
      }
    this.registerDisposer(e.changed.add(() => this.updateView())), this.registerEventListener(t, "change", () => this.updateModel()), this.registerEventListener(t, "wheel", (s) => {
      s.preventDefault(), s.stopPropagation(), this.adjustViaWheel(s);
    }), this.updateView();
  }
  adjustViaWheel(e) {
    const t = this.element;
    let n = e.deltaY;
    n > 0 ? (t.selectedIndex = (t.options.length + t.selectedIndex - 1) % t.options.length, this.updateModel()) : n < 0 && (t.selectedIndex = (t.options.length + t.selectedIndex + 1) % t.options.length, this.updateModel());
  }
  updateView() {
    const e = this.element;
    e.selectedIndex = this.valueIndexMap.get(this.model.value);
  }
  updateModel() {
    this.model.restoreState(this.element.value);
  }
};
var CS = "neuroglancer-layer-group-viewer";
function xE(i) {
  return i.dataTransfer.types.indexOf(CS) !== -1;
}
var Zi;
function YG(i) {
  if (Zi && Zi.viewer.layerSpecification.rootLayers === i.rootLayers)
    return Zi.viewer;
}
function XG(i, e) {
  const t = YG(e);
  let n, r = false;
  return t === void 0 || t.layerSpecification === t.layerSpecification.root ? n = "copy" : (r = true, n = "move"), eP(i, n, r);
}
var ZG = class extends X {
  constructor(e) {
    super(), this.relativeDisplayScales = new G3(e.navigationState.pose.relativeDisplayScales.addRef()), this.displayDimensions = new H3(e.navigationState.pose.displayDimensions.addRef()), this.position = new $D(e.navigationState.position.addRef()), this.crossSectionOrientation = new Km(e.navigationState.pose.orientation.addRef()), this.displayDimensionRenderInfo = this.registerDisposer(new WD(this.relativeDisplayScales.value, this.displayDimensions.value)), this.crossSectionScale = new Ym(e.navigationState.zoomFactor.addRef(), this.displayDimensionRenderInfo.addRef()), this.crossSectionDepthRange = new g1(e.navigationState.depthRange.addRef(), this.displayDimensionRenderInfo), this.projectionDepthRange = new g1(e.perspectiveNavigationState.depthRange.addRef(), this.displayDimensionRenderInfo), this.navigationState = this.registerDisposer(new Lo(new To(this.position.value, this.displayDimensionRenderInfo.addRef(), this.crossSectionOrientation.value), this.crossSectionScale.value, this.crossSectionDepthRange.value)), this.projectionOrientation = new Km(e.perspectiveNavigationState.pose.orientation.addRef()), this.projectionScale = new Ym(e.perspectiveNavigationState.zoomFactor.addRef(), this.displayDimensionRenderInfo.addRef()), this.projectionNavigationState = this.registerDisposer(new Lo(new To(this.position.value.addRef(), this.displayDimensionRenderInfo.addRef(), this.projectionOrientation.value), this.projectionScale.value, this.projectionDepthRange.value));
  }
  copyToParent() {
    for (const e of [this.relativeDisplayScales, this.displayDimensions, this.position, this.crossSectionOrientation, this.crossSectionScale, this.projectionOrientation, this.projectionScale])
      e.copyToPeer();
  }
  register(e) {
    e.add("dimensionRenderScales", this.relativeDisplayScales), e.add("displayDimensions", this.displayDimensions), e.add("position", uc(this.position)), e.add("crossSectionOrientation", this.crossSectionOrientation), e.add("crossSectionScale", this.crossSectionScale), e.add("crossSectionDepth", this.crossSectionDepthRange), e.add("projectionOrientation", this.projectionOrientation), e.add("projectionScale", this.projectionScale), e.add("projectionDepth", this.projectionDepthRange);
  }
};
function QG(i, e) {
  const t = new IG(i), n = t.element;
  n.classList.add("neuroglancer-layer-group-viewer-context-menu");
  const r = document.createElement("button");
  r.textContent = "Remove layer group", n.appendChild(r), t.registerEventListener(r, "click", () => {
    e.layerSpecification.layerManager.clear();
  });
  const s = e.viewerNavigationState;
  for (const l of [["Render scale factors", s.relativeDisplayScales.link], ["Render dimensions", s.displayDimensions.link], ["Position", s.position.link], ["Cross-section orientation", s.crossSectionOrientation.link], ["Cross-section zoom", s.crossSectionScale.link], ["Cross-section depth range", s.crossSectionDepthRange.link], ["3-D projection orientation", s.projectionOrientation.link], ["3-D projection zoom", s.projectionScale.link], ["3-D projection depth range", s.projectionDepthRange.link]]) {
    var a = de(l, 2);
    const d = a[0], u = a[1], h = t.registerDisposer(new sP(u)), g = document.createElement("label");
    g.style.display = "flex", g.style.flexDirection = "row", g.style.whiteSpace = "nowrap", g.textContent = d, g.appendChild(h.element), n.appendChild(g);
  }
  return t;
}
var _u = class extends X {
  constructor(e, t, n = {}) {
    super(), this.element = e, this.viewerState = t, this.state = new Ch(), this.options = H({ showLayerPanel: new nn(true), showViewerMenu: false, showLayerHoverValues: new nn(true) }, n), this.layerSpecification = this.registerDisposer(t.layerSpecification), this.viewerNavigationState = this.registerDisposer(new ZG(t)), this.viewerNavigationState.register(this.state), this.layerSpecification instanceof wP ? this.state.add("layers", this.layerSpecification) : this.state.add("layers", {
      changed: this.layerSpecification.changed,
      toJSON: () => this.layerSpecification.layerManager.managedLayers.map((r) => r.name),
      reset: () => {
        throw new Error("not implemented");
      },
      restoreState: () => {
        throw new Error("not implemented");
      }
    }), e.classList.add("neuroglancer-layer-group-viewer"), this.registerDisposer(new Vh(e)), this.layout = this.registerDisposer(new cG(this, "xy")), this.state.add("layout", this.layout), this.registerActionBindings(), this.registerDisposer(this.layerManager.useDirectly()), this.registerDisposer(rP(e, this.navigationState.position)), this.registerDisposer(this.options.showLayerPanel.changed.add(this.registerCancellable(dt(() => this.updateUI(), 0)))), this.makeUI();
  }
  get perspectiveNavigationState() {
    return this.viewerNavigationState.projectionNavigationState;
  }
  get navigationState() {
    return this.viewerNavigationState.navigationState;
  }
  get selectionDetailsState() {
    return this.layerSpecification.root.selectionState;
  }
  // FIXME: don't make viewerState a property, just make these things properties directly
  get display() {
    return this.viewerState.display;
  }
  get selectedLayer() {
    return this.viewerState.selectedLayer;
  }
  get layerManager() {
    return this.layerSpecification.layerManager;
  }
  get chunkManager() {
    return this.layerSpecification.chunkManager;
  }
  get mouseState() {
    return this.viewerState.mouseState;
  }
  get showAxisLines() {
    return this.viewerState.showAxisLines;
  }
  get wireFrame() {
    return this.viewerState.wireFrame;
  }
  get showScaleBar() {
    return this.viewerState.showScaleBar;
  }
  get showPerspectiveSliceViews() {
    return this.viewerState.showPerspectiveSliceViews;
  }
  get inputEventBindings() {
    return this.viewerState.inputEventBindings;
  }
  get visibility() {
    return this.viewerState.visibility;
  }
  get visibleLayerRoles() {
    return this.viewerState.visibleLayerRoles;
  }
  get crossSectionBackgroundColor() {
    return this.viewerState.crossSectionBackgroundColor;
  }
  get perspectiveViewBackgroundColor() {
    return this.viewerState.perspectiveViewBackgroundColor;
  }
  get scaleBarOptions() {
    return this.viewerState.scaleBarOptions;
  }
  get changed() {
    return this.state.changed;
  }
  bindAction(e, t) {
    this.registerDisposer(Ce(this.element, e, t));
  }
  registerActionBindings() {
    this.bindAction("add-layer", () => {
      this.layerPanel && this.layerPanel.addLayerMenu();
    }), this.bindAction("t-", () => {
      this.navigationState.pose.translateNonDisplayDimension(0, -1);
    }), this.bindAction("t+", () => {
      this.navigationState.pose.translateNonDisplayDimension(0, 1);
    });
  }
  toJSON() {
    return H({ type: "viewer" }, this.state.toJSON());
  }
  reset() {
    this.state.reset();
  }
  restoreState(e) {
    this.state.restoreState(e), Dn(e, "crossSectionZoom", uc(this.viewerNavigationState.crossSectionScale)), Dn(e, "perspectiveZoom", uc(this.viewerNavigationState.projectionScale)), Dn(e, "perspectiveOrientation", this.viewerNavigationState.projectionOrientation);
  }
  makeUI() {
    this.element.style.flex = "1", this.element.style.display = "flex", this.element.style.flexDirection = "column", this.element.appendChild(this.layout.element), this.updateUI();
  }
  updateUI() {
    const e = this.options, t = e.showLayerPanel.value;
    if (this.layerPanel !== void 0 && !t) {
      this.layerPanel.dispose(), this.layerPanel = void 0;
      return;
    }
    if (t && this.layerPanel === void 0) {
      const n = this.layerPanel = new KG(this.display, this.layerSpecification, this.viewerNavigationState, this.viewerState.selectedLayer.addRef(), () => this.layout.toJSON(), this.options.showLayerHoverValues);
      if (e.showViewerMenu ? (n.registerDisposer(QG(n.element, this)), n.element.title = "Right click for options, drag to move/copy layer group.") : n.element.title = "Drag to move/copy layer group.", typeof NEUROGLANCER_SHOW_LAYER_BAR_EXTRA_BUTTONS < "u" && NEUROGLANCER_SHOW_LAYER_BAR_EXTRA_BUTTONS === true) {
        {
          const s = document.createElement("button");
          s.textContent = "Clear segments", s.title = 'De-select all objects ("x")', s.addEventListener("click", (a) => {
            nI(a, a, { action: "clear-segments" });
          }), n.element.appendChild(s);
        }
        for (const s of ["3d", "xy", "xz", "yz"]) {
          const a = document.createElement("button");
          a.textContent = s, a.title = `Switch to ${s} layout`, a.addEventListener("click", () => {
            let l;
            this.layout.name === s ? s !== "3d" ? l = `${s}-3d` : l = "4panel" : l = s, this.layout.name = l;
          }), n.element.appendChild(a);
        }
      }
      n.element.draggable = true;
      const r = n.element;
      r.addEventListener("dragstart", (s) => {
        sr(n.element, "drag", "Drag layer group to the left/top/right/bottom edge of a layer group, or to another layer bar/panel (including in another Neuroglancer window)"), ZI(s, {
          manager: this.layerSpecification,
          layers: this.layerManager.managedLayers,
          layoutSpec: this.layout.toJSON()
        });
        const a = () => {
          Zi && Zi.viewer === this && (Zi = void 0), this.unregisterDisposer(a);
        };
        Zi = { viewer: this, disposer: a }, this.registerDisposer(a);
        const l = this.toJSON();
        delete l.layers, s.dataTransfer.setData(CS, oe(l)), n.element.style.backgroundColor = "black", setTimeout(() => {
          n.element.style.backgroundColor = "";
        }, 0);
      }), n.element.addEventListener("dragend", () => {
        In(r, "drag"), Uh(), Zi !== void 0 && Zi.viewer === this && Zi.disposer();
      }), this.element.insertBefore(r, this.element.firstChild);
    }
  }
  disposed() {
    st(this.element);
    const e = this.layerPanel;
    e !== void 0 && (e.dispose(), this.layerPanel = void 0), super.disposed();
  }
};
var EE = li("layoutComponentContainer");
var Qd = class extends X {
  constructor(e, t, n) {
    super(), this.viewer = e, this.parent = n, this.changed = new Le(), this.element = document.createElement("div");
    const r = this.element;
    r.style.display = "flex", r.style.flex = "1", r.style.position = "relative", r.style.alignItems = "stretch", r[EE] = this, this.setSpecification(t);
    const s = [], a = (d) => {
      const u = document.createElement("div");
      u.className = "neuroglancer-layout-split-drop-zone";
      let h;
      switch (u.style[d] = "0", d) {
        case "left":
        case "right":
          h = "row", u.style.width = "10px", u.style.height = "100%";
          break;
        case "top":
        case "bottom":
          h = "column", u.style.height = "10px", u.style.width = "100%";
          break;
      }
      u.style.display = "none", s.push({ element: u, direction: h, orientation: d }), r.appendChild(u), oP(u, this.viewer.layerSpecification, () => this.split(d).newContainer.component, h === "row" ? "column" : "row");
    };
    a("left"), a("right"), a("top"), a("bottom");
    let l = false;
    r.addEventListener("dragenter", (d) => {
      if (!l && Au(d) !== void 0) {
        l = true;
        for (const u of s) {
          const h = u.element, g = u.direction, v = u.orientation;
          if (n !== void 0 && g === n.direction && ((v === "left" || v === "top") && n.get(0) !== this || (v === "bottom" || v === "right") && n.get(n.length - 1) !== this))
            continue;
          const y = this.component;
          y instanceof mv && y.direction === g || (h.style.display = "block");
        }
      }
    }, true), r.addEventListener(
      "drop",
      (d) => {
        if (l) {
          l = false;
          for (const u of s) {
            const h = u.element;
            h.style.display = "none";
          }
        }
      },
      /*capture=*/
      true
    ), r.addEventListener("dragleave", (d) => {
      const u = d.relatedTarget;
      if (l && !(u instanceof HTMLElement && this.element.contains(u))) {
        l = false;
        for (const h of s) {
          const g = h.element;
          g.style.display = "none";
        }
      }
    }, true);
  }
  unsetComponent() {
    const e = this.componentValue;
    e !== void 0 && (e.changed.remove(this.changed.dispatch), this.element.removeChild(e.element), e.dispose());
  }
  get component() {
    return this.componentValue;
  }
  setComponent(e) {
    if (this.unsetComponent(), this.componentValue = e, e.changed.add(this.changed.dispatch), this.element.appendChild(e.element), e instanceof _u) {
      const t = e.layerManager, n = e.registerCancellable(dt(() => {
        t.managedLayers.length === 0 && this.dispose();
      }, 0));
      e.registerDisposer(t.layersChanged.add(() => {
        t.managedLayers.length === 0 && n();
      })), n();
    } else if (e instanceof mv) {
      const t = e.registerCancellable(dt(() => {
        const n = e.length;
        if (n === 0 && this.parent !== void 0)
          this.dispose();
        else if (n === 1) {
          const r = e.get(0).component;
          let s;
          if (this.parent === void 0 && r instanceof _u) {
            s = r.layout.specification.toJSON(), r.viewerNavigationState.copyToParent();
            const a = r.layerManager.managedLayers, l = new Ye(a), d = r.layerSpecification;
            d.rootLayers.filter((g) => l.has(g) || g.archived);
            const u = [], h = d.rootLayers.managedLayers;
            for (let g = 0, v = h.length; g < v; ++g)
              l.has(h[g]) && u.push(g);
            for (let g = 0, v = a.length; g < v; ++g)
              h[u[g]] = a[g];
            d.rootLayers.layersChanged.dispatch();
          } else
            s = r.toJSON();
          this.setSpecification(s);
        }
      }, 0));
      e.registerDisposer(e.changed.add(() => {
        e.length < 2 && t();
      })), t();
    }
    this.changed.dispatch();
  }
  toJSON() {
    return this.component.toJSON();
  }
  setSpecification(e) {
    this.setComponent(e4(this, e));
  }
  static getFromElement(e) {
    return e[EE];
  }
  disposed() {
    this.unsetComponent(), this.componentValue = void 0, super.disposed();
  }
  split(e) {
    const t = {
      type: "viewer"
    }, n = this.parent;
    if (n !== void 0) {
      if (e === "left" && n.direction === "row" || e === "top" && n.direction === "column")
        return { newContainer: n.insertChild(t, this), existingContainer: this };
      if (e === "right" && n.direction === "row" || e === "bottom" && n.direction === "column")
        return { newContainer: n.insertChild(t), existingContainer: this };
    }
    let r;
    const s = this.component;
    s instanceof gv ? r = s.layerGroupViewer.toJSON() : r = s.toJSON();
    let a, l;
    const d = e === "left" || e === "right" ? "row" : "column";
    switch (e) {
      case "left":
      case "top":
        a = { type: d, children: [t, r] }, l = 0;
        break;
      case "right":
      case "bottom":
        a = { type: d, children: [r, t] }, l = 1;
        break;
    }
    this.setSpecification(a);
    const u = this.component;
    return {
      newContainer: u.get(l),
      existingContainer: u.get(1 - l)
    };
  }
};
function aP(i) {
  return {
    mouseState: i.mouseState,
    showAxisLines: i.showAxisLines,
    wireFrame: i.wireFrame,
    showScaleBar: i.showScaleBar,
    scaleBarOptions: i.scaleBarOptions,
    showPerspectiveSliceViews: i.showPerspectiveSliceViews,
    inputEventBindings: i.inputEventBindings,
    visibility: i.visibility,
    selectedLayer: i.selectedLayer,
    visibleLayerRoles: i.visibleLayerRoles,
    navigationState: i.navigationState.addRef(),
    perspectiveNavigationState: i.perspectiveNavigationState.addRef(),
    crossSectionBackgroundColor: i.crossSectionBackgroundColor,
    perspectiveViewBackgroundColor: i.perspectiveViewBackgroundColor
  };
}
var gv = class extends X {
  constructor(e, t, n) {
    super(), this.element = e, this.layerGroupViewer = this.registerDisposer(new _u(e, H({ display: n.display, layerSpecification: n.layerSpecification.addRef() }, aP(n)), {
      showLayerPanel: n.uiControlVisibility.showLayerPanel,
      showViewerMenu: false,
      showLayerHoverValues: n.uiControlVisibility.showLayerHoverValues
    })), this.layerGroupViewer.layout.restoreState(t);
  }
  toJSON() {
    return this.layerGroupViewer.layout.specification.toJSON();
  }
  get changed() {
    return this.layerGroupViewer.layout.changed;
  }
};
function oP(i, e, t, n) {
  i.addEventListener("dragenter", (r) => {
    Au(r) !== void 0 && i.classList.add("neuroglancer-drag-over");
  }), i.addEventListener("dragleave", () => {
    In(i, "drop"), i.classList.remove("neuroglancer-drag-over");
  }), i.addEventListener("dragover", (r) => {
    const s = (a, l) => {
      a.dropEffectMessage && (l += ` (${a.dropEffectMessage})`), sr(i, "drop", l), r.stopPropagation(), r.preventDefault();
    };
    if (xE(r)) {
      const a = XG(r, e);
      wS(r, a.dropEffect), s(a, `Drop to ${a.dropEffect} layer group as new ${n}`);
      return;
    }
    if (Au(r) !== void 0) {
      const a = OG(
        r,
        e,
        /*targetIsLayerListPanel=*/
        false,
        /*newTarget=*/
        true
      );
      s(a, `Drop to ${a.dropEffect} layer as new ${n}`);
      return;
    }
  }), i.addEventListener("drop", (r) => {
    i.classList.remove("neuroglancer-drag-over"), In(i, "drop");
    let s, a;
    if (xE(r)) {
      r.stopPropagation();
      try {
        a = JSON.parse(r.dataTransfer.getData(CS));
      } catch {
        return;
      }
      if (s = dv(r, e, { forceCopy: false, newTarget: true }), s === void 0) return;
    } else {
      if (s = dv(r, e, { forceCopy: cv() === "copy", newTarget: true }), s === void 0) return;
      a = s.layoutSpec;
    }
    if (!s.initializeExternalLayers(r)) {
      if (!s.moveSupported)
        for (const u of s.layers.keys())
          u.dispose();
      return;
    }
    r.preventDefault();
    const l = r.dataTransfer.dropEffect = cv();
    Uh(l);
    const d = t();
    s.updateArchiveStates(r);
    for (const u of s.layers.keys())
      d.layerSpecification.add(u);
    try {
      d.restoreState(a);
    } catch {
      d.layout.reset();
    }
  });
}
var mv = class extends X {
  constructor(e, t, n, r) {
    super(), this.element = e, this.direction = t, this.container = r, this.changed = new Le(), e.classList.add("neuroglancer-stack-layout"), e.classList.add(`neuroglancer-stack-layout-${t}`), e.style.display = "flex", e.style.flexDirection = t, e.appendChild(this.makeDropPlaceholder(this));
    for (const s of n)
      this.insertChild(s);
  }
  get length() {
    return (this.element.childElementCount - 1) / 2;
  }
  makeDropPlaceholder(e) {
    const t = document.createElement("div");
    return t.className = "neuroglancer-stack-layout-drop-placeholder", oP(t, this.viewer.layerSpecification, () => {
      const n = t.nextElementSibling;
      let r;
      return n !== null && (r = Qd.getFromElement(n)), this.insertChild({ type: "viewer", layers: [] }, r).component;
    }, this.direction === "row" ? "column" : "row"), e.registerDisposer(() => {
      Ut(t);
    }), t;
  }
  get viewer() {
    return this.container.viewer;
  }
  get(e) {
    return Qd.getFromElement(this.element.children[e * 2 + 1]);
  }
  insertChild(e, t) {
    const n = new Qd(this.viewer, e, this), r = this.makeDropPlaceholder(n);
    n.element.classList.add("neuroglancer-stack-layout-child"), n.registerDisposer(n.changed.add(this.changed.dispatch)), n.registerDisposer(() => {
      this.element.removeChild(n.element), this.changed.dispatch();
    });
    const s = t !== void 0 ? t.element : null;
    return this.element.insertBefore(n.element, s), this.element.insertBefore(r, s), this.changed.dispatch(), n;
  }
  disposed() {
    this.clear(), super.disposed();
  }
  clear() {
    for (; this.length !== 0; )
      this.get(0).dispose();
  }
  *[qn]() {
    const e = this.length;
    for (let t = 0; t < e; ++t)
      yield this.get(t);
  }
  toJSON() {
    return {
      type: this.direction,
      children: _e(this).map((e) => e.toJSON())
    };
  }
};
function e4(i, e) {
  const t = document.createElement("div");
  if (t.style.flex = "1", t.style.width = "0px", typeof e == "string") {
    if (i.parent !== void 0)
      throw new Error(`Invalid layout component specification: ${oe(e)}`);
    return new gv(t, e, i.viewer);
  }
  me(e);
  const n = Y(e, "type", Ae);
  switch (n) {
    case "row":
    case "column":
      return new mv(t, n, Y(e, "children", (r) => {
        const s = Xe(r, (a) => a);
        if (i.parent === void 0 && s.length === 0)
          throw new Error("Stack layout requires at least one child.");
        return s;
      }), i);
    case "viewer": {
      const r = i.viewer, s = new wP(r.layerSpecification.addRef()), a = new _u(t, H({ display: r.display, layerSpecification: s }, aP(r)), {
        showLayerPanel: r.uiControlVisibility.showLayerPanel,
        showViewerMenu: true,
        showLayerHoverValues: r.uiControlVisibility.showLayerHoverValues
      });
      try {
        a.restoreState(e);
      } catch (l) {
        throw a.dispose(), l;
      }
      return a;
    }
    default:
      return new gv(t, e, i.viewer);
  }
}
var t4 = class extends X {
  constructor(e, t) {
    super(), this.viewer = e, this.defaultSpecification = t, this.container = this.registerDisposer(new Qd(this.viewer, this.defaultSpecification, void 0));
  }
  get changed() {
    return this.container.changed;
  }
  get element() {
    return this.container.element;
  }
  reset() {
    this.container.setSpecification(this.defaultSpecification);
  }
  restoreState(e) {
    this.container.setSpecification(e);
  }
  disposed() {
    super.disposed();
  }
  toJSON() {
    return this.container.toJSON();
  }
};
var vv = 0;
var n4 = St.fromObject({
  escape: { action: "close" }
});
var Gh = class extends X {
  constructor() {
    super(), this.keyMap = new St(), this.keyMap.addParent(n4, Number.NEGATIVE_INFINITY), ++vv;
    let e = this.container = document.createElement("div");
    e.className = "overlay";
    let t = this.content = document.createElement("div");
    this.registerDisposer(new Vh(t)), t.className = "overlay-content", e.appendChild(t), document.body.appendChild(e), this.registerDisposer(new Gi(this.container, this.keyMap)), this.registerEventListener(e, "action:close", () => {
      this.dispose();
    }), t.focus();
  }
  disposed() {
    --vv, document.body.removeChild(this.container), super.disposed();
  }
};
var i4 = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20xmlns='http://www.w3.org/2000/svg'%20aria-labelledby='eyeCrossedIconTitle'%3e%3ctitle%20id='eyeCrossedIconTitle'%3eHidden%20(crossed%20eye)%3c/title%3e%3cpath%20d='M22%2012C22%2012%2019%2018%2012%2018C5%2018%202%2012%202%2012C2%2012%205%206%2012%206C19%206%2022%2012%2022%2012Z'/%3e%3ccircle%20cx='12'%20cy='12'%20r='3'/%3e%3cpath%20d='M3%2021L20%204'/%3e%3c/svg%3e";
var r4 = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20xmlns='http://www.w3.org/2000/svg'%20aria-labelledby='eyeIconTitle'%3e%3ctitle%20id='eyeIconTitle'%3eVisible%20(eye)%3c/title%3e%3cpath%20d='M22%2012C22%2012%2019%2018%2012%2018C5%2018%202%2012%202%2012C2%2012%205%206%2012%206C19%206%2022%2012%2022%2012Z'/%3e%3ccircle%20cx='12'%20cy='12'%20r='3'/%3e%3c/svg%3e";
var s4 = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='cursorIconTitle'%3e%3ctitle%20id='cursorIconTitle'%3eCursor%3c/title%3e%3cpolygon%20points='7%2020%207%204%2019%2016%2012%2016%207%2021'/%3e%3c/svg%3e";
var a4 = St.fromObject({
  escape: { action: "cancel" }
});
var lP = class extends X {
  constructor(e) {
    super(), this.layer = e, this.element = document.createElement("input");
    const t = this.element;
    t.classList.add("neuroglancer-layer-side-panel-name"), t.spellcheck = false, t.autocomplete = "off";
    const n = this.registerDisposer(new Gi(t, a4));
    n.allShortcutsAreGlobal = true, Ce(t, "cancel", (r) => {
      this.updateView(), t.blur(), r.stopPropagation(), r.preventDefault();
    }), t.title = "Rename layer", this.registerDisposer(e.layerChanged.add(() => this.updateView())), t.addEventListener("change", () => this.updateModel()), t.addEventListener("blur", () => this.updateModel()), this.updateView();
  }
  updateView() {
    this.element.value = this.layer.name;
  }
  updateModel() {
    EP(this.layer, this.element.value);
  }
};
var o4 = class extends X {
  constructor(e) {
    super(), this.layer = e, this.element = document.createElement("select"), this.measureElement = document.createElement("div");
    const t = this.element, n = this.measureElement;
    t.classList.add("neuroglancer-layer-side-panel-type"), n.classList.add("neuroglancer-layer-side-panel-type-measure"), t.title = "Change layer type", document.body.appendChild(n);
    for (const s of Nu) {
      var r = de(s, 2);
      const a = r[0], l = r[1];
      if (l.type !== a) continue;
      const d = document.createElement("option");
      d.textContent = l.typeAbbreviation, d.value = a, t.appendChild(d);
    }
    t.addEventListener("change", () => {
      const s = t.value, a = Nu.get(s);
      DS(this.layer.managedLayer, a);
    }), this.updateView();
  }
  updateView() {
    const e = this.layer.type, t = this.element, n = this.measureElement;
    n.textContent = this.layer.constructor.typeAbbreviation, t.value = e, t.style.width = `${n.offsetWidth}px`;
  }
  disposed() {
    this.measureElement.remove();
  }
};
var Mu = class _Mu extends ma {
  constructor(e, t) {
    super(e, t.location), this.panelState = t;
    const n = this.layer = t.layer, r = this.element;
    var s = this.addTitleBar({});
    const a = s.titleBar;
    a.classList.add("neuroglancer-layer-side-panel-title"), a.appendChild(this.registerDisposer(new o4(n)).element), a.appendChild(this.registerDisposer(new lP(n.managedLayer)).element), this.registerDisposer(_r((u) => {
      r.dataset.neuroglancerLayerVisible = u.toString();
    }, {
      get value() {
        return n.managedLayer.visible;
      },
      changed: n.managedLayer.layerChanged
    }));
    const l = this.registerDisposer(new Qi({
      get value() {
        return n.managedLayer.pickEnabled;
      },
      set value(u) {
        n.managedLayer.pickEnabled = u;
      },
      changed: n.managedLayer.layerChanged
    }, {
      svg: s4,
      enableTitle: "Spatial object selection: disabled",
      disableTitle: "Spatial object selection: enabled"
    }));
    this.registerDisposer(new fi({
      get value() {
        return n.managedLayer.supportsPickOption;
      },
      changed: n.managedLayer.layerChanged
    }, l.element)), a.appendChild(l.element);
    const d = {
      get value() {
        return t !== n.panels.panels[0];
      },
      set value(u) {
        u ? t.pin() : t.unpin();
      },
      changed: n.manager.root.layerManager.layersChanged
    };
    a.appendChild(this.registerDisposer(new Qi(d, {
      // Note: \ufe0e forces text display, as otherwise the pin icon
      // may as an emoji with color.
      text: "📌︎",
      enableTitle: "Pin panel to this layer",
      disableTitle: "Unpin panel to this layer"
    })).element), this.registerDisposer(_r((u) => {
      r.dataset.neuroglancerLayerPanelPinned = u.toString();
    }, d)), a.appendChild(ms({
      title: "Delete layer",
      onClick: () => {
        Qo(this.layer.managedLayer);
      }
    })), this.tabView = new Gz({
      makeTab: (u) => n.tabs.options.get(u).getter(),
      selectedTab: t.selectedTab,
      tabs: this.registerDisposer(new mT({
        get value() {
          return t.tabs.map((u) => ({
            id: u,
            label: n.tabs.options.get(u).label
          }));
        },
        changed: t.tabsChanged
      })),
      handleTabElement: (u, h) => {
        h.draggable = true, h.addEventListener("dragstart", (g) => {
          g.stopPropagation(), g.dataTransfer.setData("neuroglancer-side-panel", "");
          let v = "Drag tab to dock as new panel to the left/right/top/bottom of another panel";
          t.panels.panels.find((C) => C !== t && C.location.visible) && (v += `, or move tab to other ${oe(n.managedLayer.name)} panel`), sr(h, "drag", v), this.sidePanelManager.startDrag({
            dropAsNewPanel: (C) => {
              this.panelState.splitOffTab(u, H(H({}, DI), C));
            },
            canDropAsTabs: (C) => C instanceof _Mu && C.layer === this.layer && C !== this ? 1 : 0,
            dropAsTab: (C) => {
              this.panelState.moveTabTo(u, C.panelState);
            }
          }, g);
        }), h.addEventListener("dragend", (g) => {
          In(h, "drag"), this.sidePanelManager.endDrag();
        });
      }
    }, this.visibility), this.tabView.element.style.flex = "1", this.tabView.element.classList.add("neuroglancer-layer-side-panel-tab-view"), this.tabView.element.style.position = "relative", this.tabView.element.appendChild(this.makeTabDropZone()), this.addBody(this.tabView.element), this.registerDisposer(t.tabsChanged.add(() => {
      t.tabs.length === 0 && (this.location.visible = false);
    }));
  }
  makeDragSource() {
    return H(H({}, super.makeDragSource()), { canDropAsTabs: (e) => e instanceof _Mu && e.layer === this.layer && e !== this ? this.panelState.tabs.length : 0, dropAsTab: (e) => {
      this.panelState.mergeInto(e.panelState);
    } });
  }
  makeTabDropZone() {
    const e = document.createElement("div");
    return e.className = "neuroglancer-side-panel-drop-zone", e.style.position = "absolute", e.style.left = "20px", e.style.right = "20px", e.style.bottom = "20px", e.style.top = "20px", e.addEventListener("dragenter", (t) => {
      var n;
      const r = this.sidePanelManager.dragSource, s = (n = r == null ? void 0 : r.canDropAsTabs) === null || n === void 0 ? void 0 : n.call(r, this);
      s && (e.classList.add(co), sr(e, "drop", `Move ${s} ${s === 1 ? "tab" : "tabs"} to this panel`), t.preventDefault());
    }), e.addEventListener("dragleave", () => {
      In(e, "drop"), e.classList.remove(co);
    }), e.addEventListener("dragover", (t) => {
      var n;
      const r = this.sidePanelManager.dragSource;
      !((n = r == null ? void 0 : r.canDropAsTabs) === null || n === void 0) && n.call(r, this) && t.preventDefault();
    }), e.addEventListener("drop", (t) => {
      var n;
      In(e, "drop");
      const r = this.sidePanelManager.dragSource;
      !((n = r == null ? void 0 : r.canDropAsTabs) === null || n === void 0) && n.call(r, this) && (e.classList.remove(co), r.dropAsTab(this), t.preventDefault(), t.stopPropagation());
    }), e;
  }
};
var l4 = class extends X {
  constructor(e, t) {
    super(), this.sidePanelManager = e, this.selectedLayerState = t, this.layerSidePanels = new he(), this.generation = 0, this.layersNeedUpdate = true;
    const n = () => {
      this.layersNeedUpdate = true, this.sidePanelManager.display.scheduleRedraw();
    };
    this.registerDisposer(t.changed.add(n)), this.registerDisposer(t.layerManager.layersChanged.add(n)), this.registerDisposer(e.beforeRender.add(() => this.update()));
  }
  getSelectedUserLayer() {
    var e, t;
    return (t = (e = this.selectedLayerState.layer) === null || e === void 0 ? void 0 : e.layer) !== null && t !== void 0 ? t : void 0;
  }
  update() {
    var e;
    if (!this.layersNeedUpdate) return;
    const t = this.selectedLayerState.layerManager;
    let n = ++this.generation;
    this.layersNeedUpdate = false;
    const r = this.layerSidePanels, s = (l) => {
      let d = r.get(l);
      d === void 0 ? (d = {
        generation: n,
        unregister: this.sidePanelManager.registerPanel({
          location: l.location,
          makePanel: () => new Mu(this.sidePanelManager, l)
        })
      }, r.set(l, d)) : d.generation = n;
    };
    {
      const l = this.getSelectedUserLayer(), d = this.selectedLayerState.location;
      if (l === void 0 || !d.visible)
        this.placeholderSelectedLayerPanel === void 0 && (this.placeholderSelectedLayerPanel = this.sidePanelManager.registerPanel({ location: d, makePanel: () => new ma(this.sidePanelManager, d) }));
      else {
        (e = this.placeholderSelectedLayerPanel) === null || e === void 0 || e.call(this), this.placeholderSelectedLayerPanel = void 0;
        const u = l.panels.panels[0];
        u.location.value = d.value, s(u);
      }
    }
    for (const l of t.managedLayers) {
      const d = l.layer;
      if (d === null) continue;
      const u = d.panels.panels;
      for (let h = 1, g = u.length; h < g; ++h)
        s(u[h]);
    }
    for (const l of r) {
      var a = de(l, 2);
      const d = a[0], u = a[1];
      u.generation !== n && (u.unregister(), r.delete(d));
    }
  }
  disposed() {
    var e;
    (e = this.placeholderSelectedLayerPanel) === null || e === void 0 || e.call(this);
    for (const t of this.layerSidePanels.values()) {
      const n = t.unregister;
      n();
    }
  }
};
var c4 = H(H({}, ga), { side: "left", row: 0 });
var d4 = class {
  constructor() {
    this.location = new Is(c4);
  }
  get changed() {
    return this.location.changed;
  }
  restoreState(e) {
    e !== void 0 && this.location.restoreState(e);
  }
  reset() {
    this.location.reset();
  }
  toJSON() {
    return ha(this.location.toJSON());
  }
};
var u4 = class extends X {
  constructor(e) {
    super(), this.layer = e, this.element = document.createElement("div");
    const t = this.element, n = Tt({
      svg: r4,
      title: "Hide layer",
      onClick: () => {
        this.layer.setVisible(false);
      }
    }), r = Tt({
      svg: i4,
      title: "Show layer",
      onClick: () => {
        this.layer.setVisible(true);
      }
    });
    t.appendChild(r), t.appendChild(n);
    const s = () => {
      const a = this.layer.visible;
      n.style.display = a ? "" : "none", r.style.display = a ? "none" : "";
    };
    s(), this.registerDisposer(e.layerChanged.add(s));
  }
};
function h4(i) {
  const e = i.manager.root.selectedLayer, t = new Qi({
    get value() {
      return e.layer === i && e.visible;
    },
    set value(n) {
      n ? (e.layer = i, e.visible = true) : e.visible = false;
    },
    changed: e.changed
  }, {
    backgroundScheme: "dark",
    enableTitle: "Show layer side panel",
    disableTitle: "Hide layer side panel",
    svg: _I
  });
  return t.element.classList.add("neuroglancer-layer-list-panel-item-controls"), t;
}
var f4 = class extends X {
  constructor(e, t) {
    super(), this.panel = e, this.layer = t, this.element = document.createElement("div"), this.numberElement = document.createElement("div"), this.generation = -1;
    const n = this.element, r = this.numberElement;
    n.classList.add("neuroglancer-layer-list-panel-item"), r.classList.add("neuroglancer-layer-list-panel-item-number"), n.appendChild(this.registerDisposer(new Ls({
      get value() {
        return !t.archived;
      },
      set value(a) {
        t.setArchived(!a);
      },
      changed: t.layerChanged
    }, {
      enableTitle: "Archive layer (disable and remove from layer groups)",
      disableTitle: "Unarchive layer (enable and add to all layer groups)"
    })).element), n.appendChild(r), n.appendChild(this.registerDisposer(new u4(t)).element), n.appendChild(this.registerDisposer(new lP(t)).element), n.appendChild(this.registerDisposer(h4(t)).element);
    const s = ms({
      title: "Delete layer",
      onClick: () => {
        Qo(this.layer);
      }
    });
    s.classList.add("neuroglancer-layer-list-panel-item-delete"), n.appendChild(s), nP(e, n, t, { isLayerListPanel: true, getLayoutSpec: () => {
    } }), zh(
      e,
      n,
      t,
      /*allowArchived=*/
      true
    ), n.addEventListener("click", (a) => {
      a.ctrlKey ? (e.selectedLayer.toggle(t), a.preventDefault()) : a.altKey && (t.pickEnabled = !t.pickEnabled, a.preventDefault());
    }), n.addEventListener("contextmenu", (a) => {
      e.selectedLayer.toggle(t), a.stopPropagation(), a.preventDefault();
    });
  }
};
var p4 = class extends ma {
  constructor(e, t, n) {
    super(e, n.location), this.manager = t, this.state = n, this.items = new he(), this.itemContainer = document.createElement("div"), this.layerDropZone = document.createElement("div"), this.dragEnterCount = 0, this.generation = -1;
    const r = this.itemContainer, s = this.layerDropZone;
    var a = this.addTitleBar({ title: "" });
    const l = a.titleElement;
    this.titleElement = l, r.classList.add("neuroglancer-layer-list-panel-items"), this.addBody(r), s.style.flex = "1";
    const d = this.registerCancellable(Ct(() => this.render()));
    this.visibility.changed.add(d), this.registerDisposer(this.layerManager.layersChanged.add(d)), this.registerDisposer(this.selectedLayer.changed.add(d)), iP(this), zh(
      this,
      s,
      void 0,
      /*allowArchived=*/
      true
    ), this.render();
  }
  get layerManager() {
    return this.manager.layerManager;
  }
  get selectedLayer() {
    return this.manager.selectedLayer;
  }
  render() {
    const e = this, t = this.selectedLayer.layer, n = ++this.generation;
    let r = 0, s = 0, a = 0;
    this.layerManager.updateNonArchivedLayerIndices();
    function* l() {
      const u = e.items;
      let h = 0;
      for (const y of e.layerManager.managedLayers)
        y.archived || ++h;
      const g = `${(h + 1).toString().length}ch`;
      for (const y of e.layerManager.managedLayers) {
        y.visible ? ++r : y.archived ? ++a : ++s;
        let C = u.get(y);
        C === void 0 && (C = e.registerDisposer(new f4(e, y)), u.set(y, C)), C.generation = n;
        const w = y.nonArchivedLayerIndex;
        C.numberElement.style.width = g, w === -1 ? C.numberElement.style.visibility = "hidden" : (C.numberElement.style.visibility = "", C.numberElement.textContent = `${w + 1}`), C.element.dataset.selected = (y === t).toString(), C.element.dataset.archived = y.archived.toString(), yield C.element;
      }
      for (const y of u) {
        var v = de(y, 2);
        const C = v[0], w = v[1];
        n !== w.generation && (u.delete(C), e.unregisterDisposer(w), w.dispose());
      }
      yield e.layerDropZone;
    }
    rr(this.itemContainer, l());
    let d = "Layers";
    if (r || s || a) {
      d += " (";
      let u = "";
      r + s && (d += `${r}/${s + r} visible`, u = ", "), a && (d += `${u}${a} archived`), d += ")";
    }
    this.titleElement.textContent = d;
  }
};
var g4 = class extends X {
  constructor(e) {
    super(), this.layerManager = e, this.element = document.createElement("div");
    const t = this.registerCancellable(Ct(() => this.render()));
    this.registerDisposer(e.layersChanged.add(t)), this.render();
  }
  render() {
    let e = 0;
    const t = this.layerManager.managedLayers;
    for (const r of t)
      r.archived && ++e;
    const n = this.element;
    if (e !== 0) {
      const r = t.length;
      n.textContent = `${r - e}/${r}`;
    } else
      n.textContent = "";
  }
};
var kE = { exports: {} };
var eu = { exports: {} };
var m4 = eu.exports;
var TE;
function Yo() {
  return TE || (TE = 1, function(i, e) {
    (function(t, n) {
      i.exports = n();
    })(m4, function() {
      var t = navigator.userAgent, n = navigator.platform, r = /gecko\/\d/i.test(t), s = /MSIE \d/.test(t), a = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(t), l = /Edge\/(\d+)/.exec(t), d = s || a || l, u = d && (s ? document.documentMode || 6 : +(l || a)[1]), h = !l && /WebKit\//.test(t), g = h && /Qt\/\d+\.\d+/.test(t), v = !l && /Chrome\/(\d+)/.exec(t), y = v && +v[1], C = /Opera\//.test(t), w = /Apple Computer/.test(navigator.vendor), b = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(t), E = /PhantomJS/.test(t), T = w && (/Mobile\/\w+/.test(t) || navigator.maxTouchPoints > 2), I = /Android/.test(t), R = T || I || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(t), P = T || /Mac/.test(n), L = /\bCrOS\b/.test(t), A = /win/i.test(n), M = C && t.match(/Version\/(\d*\.\d*)/);
      M && (M = Number(M[1])), M && M >= 15 && (C = false, h = true);
      var O = P && (g || C && (M == null || M < 12.11)), F = r || d && u >= 9;
      function q(o) {
        return new RegExp("(^|\\s)" + o + "(?:$|\\s)\\s*");
      }
      var U = function(o, c) {
        var p = o.className, f = q(c).exec(p);
        if (f) {
          var m = p.slice(f.index + f[0].length);
          o.className = p.slice(0, f.index) + (m ? f[1] + m : "");
        }
      };
      function V(o) {
        for (var c = o.childNodes.length; c > 0; --c)
          o.removeChild(o.firstChild);
        return o;
      }
      function $(o, c) {
        return V(o).appendChild(c);
      }
      function B(o, c, p, f) {
        var m = document.createElement(o);
        if (p && (m.className = p), f && (m.style.cssText = f), typeof c == "string")
          m.appendChild(document.createTextNode(c));
        else if (c)
          for (var S = 0; S < c.length; ++S)
            m.appendChild(c[S]);
        return m;
      }
      function ue(o, c, p, f) {
        var m = B(o, c, p, f);
        return m.setAttribute("role", "presentation"), m;
      }
      var se;
      document.createRange ? se = function(o, c, p, f) {
        var m = document.createRange();
        return m.setEnd(f || o, p), m.setStart(o, c), m;
      } : se = function(o, c, p) {
        var f = document.body.createTextRange();
        try {
          f.moveToElementText(o.parentNode);
        } catch {
          return f;
        }
        return f.collapse(true), f.moveEnd("character", p), f.moveStart("character", c), f;
      };
      function Pe(o, c) {
        if (c.nodeType == 3 && (c = c.parentNode), o.contains)
          return o.contains(c);
        do
          if (c.nodeType == 11 && (c = c.host), c == o)
            return true;
        while (c = c.parentNode);
      }
      function ae(o) {
        var c = o.ownerDocument || o, p;
        try {
          p = o.activeElement;
        } catch {
          p = c.body || null;
        }
        for (; p && p.shadowRoot && p.shadowRoot.activeElement; )
          p = p.shadowRoot.activeElement;
        return p;
      }
      function Ee(o, c) {
        var p = o.className;
        q(c).test(p) || (o.className += (p ? " " : "") + c);
      }
      function ce(o, c) {
        for (var p = o.split(" "), f = 0; f < p.length; f++)
          p[f] && !q(p[f]).test(c) && (c += " " + p[f]);
        return c;
      }
      var ge = function(o) {
        o.select();
      };
      T ? ge = function(o) {
        o.selectionStart = 0, o.selectionEnd = o.value.length;
      } : d && (ge = function(o) {
        try {
          o.select();
        } catch {
        }
      });
      function Ne(o) {
        return o.display.wrapper.ownerDocument;
      }
      function Me(o) {
        return je(o.display.wrapper);
      }
      function je(o) {
        return o.getRootNode ? o.getRootNode() : o.ownerDocument;
      }
      function Oe(o) {
        return Ne(o).defaultView;
      }
      function Re(o) {
        var c = Array.prototype.slice.call(arguments, 1);
        return function() {
          return o.apply(null, c);
        };
      }
      function Ve(o, c, p) {
        c || (c = {});
        for (var f in o)
          o.hasOwnProperty(f) && (p !== false || !c.hasOwnProperty(f)) && (c[f] = o[f]);
        return c;
      }
      function qe(o, c, p, f, m) {
        c == null && (c = o.search(/[^\s\u00a0]/), c == -1 && (c = o.length));
        for (var S = f || 0, x = m || 0; ; ) {
          var k = o.indexOf("	", S);
          if (k < 0 || k >= c)
            return x + (c - S);
          x += k - S, x += p - x % p, S = k + 1;
        }
      }
      var We = function() {
        this.id = null, this.f = null, this.time = 0, this.handler = Re(this.onTimeout, this);
      };
      We.prototype.onTimeout = function(o) {
        o.id = 0, o.time <= +/* @__PURE__ */ new Date() ? o.f() : setTimeout(o.handler, o.time - +/* @__PURE__ */ new Date());
      }, We.prototype.set = function(o, c) {
        this.f = c;
        var p = +/* @__PURE__ */ new Date() + o;
        (!this.id || p < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, o), this.time = p);
      };
      function De(o, c) {
        for (var p = 0; p < o.length; ++p)
          if (o[p] == c)
            return p;
        return -1;
      }
      var et = 50, $t = { toString: function() {
        return "CodeMirror.Pass";
      } }, At = { scroll: false }, Z = { origin: "*mouse" }, ne = { origin: "+move" };
      function te(o, c, p) {
        for (var f = 0, m = 0; ; ) {
          var S = o.indexOf("	", f);
          S == -1 && (S = o.length);
          var x = S - f;
          if (S == o.length || m + x >= c)
            return f + Math.min(x, c - m);
          if (m += S - f, m += p - m % p, f = S + 1, m >= c)
            return f;
        }
      }
      var ve = [""];
      function ke(o) {
        for (; ve.length <= o; )
          ve.push(ye(ve) + " ");
        return ve[o];
      }
      function ye(o) {
        return o[o.length - 1];
      }
      function Je(o, c) {
        for (var p = [], f = 0; f < o.length; f++)
          p[f] = c(o[f], f);
        return p;
      }
      function it(o, c, p) {
        for (var f = 0, m = p(c); f < o.length && p(o[f]) <= m; )
          f++;
        o.splice(f, 0, c);
      }
      function pt() {
      }
      function gt(o, c) {
        var p;
        return Object.create ? p = Object.create(o) : (pt.prototype = o, p = new pt()), c && Ve(c, p), p;
      }
      var ot = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      function Gt(o) {
        return /\w/.test(o) || o > "" && (o.toUpperCase() != o.toLowerCase() || ot.test(o));
      }
      function mt(o, c) {
        return c ? c.source.indexOf("\\w") > -1 && Gt(o) ? true : c.test(o) : Gt(o);
      }
      function It(o) {
        for (var c in o)
          if (o.hasOwnProperty(c) && o[c])
            return false;
        return true;
      }
      var Wt = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
      function Ze(o) {
        return o.charCodeAt(0) >= 768 && Wt.test(o);
      }
      function _t(o, c, p) {
        for (; (p < 0 ? c > 0 : c < o.length) && Ze(o.charAt(c)); )
          c += p;
        return c;
      }
      function Pt(o, c, p) {
        for (var f = c > p ? -1 : 1; ; ) {
          if (c == p)
            return c;
          var m = (c + p) / 2, S = f < 0 ? Math.ceil(m) : Math.floor(m);
          if (S == c)
            return o(S) ? c : p;
          o(S) ? p = S : c = S + f;
        }
      }
      function ci(o, c, p, f) {
        if (!o)
          return f(c, p, "ltr", 0);
        for (var m = false, S = 0; S < o.length; ++S) {
          var x = o[S];
          (x.from < p && x.to > c || c == p && x.to == c) && (f(Math.max(x.from, c), Math.min(x.to, p), x.level == 1 ? "rtl" : "ltr", S), m = true);
        }
        m || f(c, p, "ltr");
      }
      var Hi = null;
      function jr(o, c, p) {
        var f;
        Hi = null;
        for (var m = 0; m < o.length; ++m) {
          var S = o[m];
          if (S.from < c && S.to > c)
            return m;
          S.to == c && (S.from != S.to && p == "before" ? f = m : Hi = m), S.from == c && (S.from != S.to && p != "before" ? f = m : Hi = m);
        }
        return f ?? Hi;
      }
      var Kh = /* @__PURE__ */ function() {
        var o = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", c = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
        function p(_) {
          return _ <= 247 ? o.charAt(_) : 1424 <= _ && _ <= 1524 ? "R" : 1536 <= _ && _ <= 1785 ? c.charAt(_ - 1536) : 1774 <= _ && _ <= 2220 ? "r" : 8192 <= _ && _ <= 8203 ? "w" : _ == 8204 ? "b" : "L";
        }
        var f = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, m = /[stwN]/, S = /[LRr]/, x = /[Lb1n]/, k = /[1n]/;
        function D(_, z, W) {
          this.level = _, this.from = z, this.to = W;
        }
        return function(_, z) {
          var W = z == "ltr" ? "L" : "R";
          if (_.length == 0 || z == "ltr" && !f.test(_))
            return false;
          for (var K = _.length, J = [], ee = 0; ee < K; ++ee)
            J.push(p(_.charCodeAt(ee)));
          for (var le = 0, pe = W; le < K; ++le) {
            var Se = J[le];
            Se == "m" ? J[le] = pe : pe = Se;
          }
          for (var Te = 0, be = W; Te < K; ++Te) {
            var Ie = J[Te];
            Ie == "1" && be == "r" ? J[Te] = "n" : S.test(Ie) && (be = Ie, Ie == "r" && (J[Te] = "R"));
          }
          for (var Ge = 1, Ue = J[0]; Ge < K - 1; ++Ge) {
            var Qe = J[Ge];
            Qe == "+" && Ue == "1" && J[Ge + 1] == "1" ? J[Ge] = "1" : Qe == "," && Ue == J[Ge + 1] && (Ue == "1" || Ue == "n") && (J[Ge] = Ue), Ue = Qe;
          }
          for (var Et = 0; Et < K; ++Et) {
            var ln = J[Et];
            if (ln == ",")
              J[Et] = "N";
            else if (ln == "%") {
              var Mt = void 0;
              for (Mt = Et + 1; Mt < K && J[Mt] == "%"; ++Mt)
                ;
              for (var Yn = Et && J[Et - 1] == "!" || Mt < K && J[Mt] == "1" ? "1" : "N", Fn = Et; Fn < Mt; ++Fn)
                J[Fn] = Yn;
              Et = Mt - 1;
            }
          }
          for (var Yt = 0, Un = W; Yt < K; ++Yt) {
            var pn = J[Yt];
            Un == "L" && pn == "1" ? J[Yt] = "L" : S.test(pn) && (Un = pn);
          }
          for (var tn = 0; tn < K; ++tn)
            if (m.test(J[tn])) {
              var Xt = void 0;
              for (Xt = tn + 1; Xt < K && m.test(J[Xt]); ++Xt)
                ;
              for (var Bt = (tn ? J[tn - 1] : W) == "L", zn = (Xt < K ? J[Xt] : W) == "L", Ha = Bt == zn ? Bt ? "L" : "R" : W, as = tn; as < Xt; ++as)
                J[as] = Ha;
              tn = Xt - 1;
            }
          for (var Cn = [], Yi, cn = 0; cn < K; )
            if (x.test(J[cn])) {
              var Wf = cn;
              for (++cn; cn < K && x.test(J[cn]); ++cn)
                ;
              Cn.push(new D(0, Wf, cn));
            } else {
              var wr = cn, Us = Cn.length, zs = z == "rtl" ? 1 : 0;
              for (++cn; cn < K && J[cn] != "L"; ++cn)
                ;
              for (var Tn = wr; Tn < cn; )
                if (k.test(J[Tn])) {
                  wr < Tn && (Cn.splice(Us, 0, new D(1, wr, Tn)), Us += zs);
                  var qa = Tn;
                  for (++Tn; Tn < cn && k.test(J[Tn]); ++Tn)
                    ;
                  Cn.splice(Us, 0, new D(2, qa, Tn)), Us += zs, wr = Tn;
                } else
                  ++Tn;
              wr < cn && Cn.splice(Us, 0, new D(1, wr, cn));
            }
          return z == "ltr" && (Cn[0].level == 1 && (Yi = _.match(/^\s+/)) && (Cn[0].from = Yi[0].length, Cn.unshift(new D(0, 0, Yi[0].length))), ye(Cn).level == 1 && (Yi = _.match(/\s+$/)) && (ye(Cn).to -= Yi[0].length, Cn.push(new D(0, K - Yi[0].length, K)))), z == "rtl" ? Cn.reverse() : Cn;
        };
      }();
      function tt(o, c) {
        var p = o.order;
        return p == null && (p = o.order = Kh(o.text, c)), p;
      }
      var qc = [], $e = function(o, c, p) {
        if (o.addEventListener)
          o.addEventListener(c, p, false);
        else if (o.attachEvent)
          o.attachEvent("on" + c, p);
        else {
          var f = o._handlers || (o._handlers = {});
          f[c] = (f[c] || qc).concat(p);
        }
      };
      function pr(o, c) {
        return o._handlers && o._handlers[c] || qc;
      }
      function Sn(o, c, p) {
        if (o.removeEventListener)
          o.removeEventListener(c, p, false);
        else if (o.detachEvent)
          o.detachEvent("on" + c, p);
        else {
          var f = o._handlers, m = f && f[c];
          if (m) {
            var S = De(m, p);
            S > -1 && (f[c] = m.slice(0, S).concat(m.slice(S + 1)));
          }
        }
      }
      function Nt(o, c) {
        var p = pr(o, c);
        if (p.length)
          for (var f = Array.prototype.slice.call(arguments, 2), m = 0; m < p.length; ++m)
            p[m].apply(null, f);
      }
      function Ot(o, c, p) {
        return typeof c == "string" && (c = { type: c, preventDefault: function() {
          this.defaultPrevented = true;
        } }), Nt(o, p || c.type, o, c), Nn(c) || c.codemirrorIgnore;
      }
      function di(o) {
        var c = o._handlers && o._handlers.cursorActivity;
        if (c)
          for (var p = o.curOp.cursorActivityHandlers || (o.curOp.cursorActivityHandlers = []), f = 0; f < c.length; ++f)
            De(p, c[f]) == -1 && p.push(c[f]);
      }
      function Jn(o, c) {
        return pr(o, c).length > 0;
      }
      function Ti(o) {
        o.prototype.on = function(c, p) {
          $e(this, c, p);
        }, o.prototype.off = function(c, p) {
          Sn(this, c, p);
        };
      }
      function bn(o) {
        o.preventDefault ? o.preventDefault() : o.returnValue = false;
      }
      function ba(o) {
        o.stopPropagation ? o.stopPropagation() : o.cancelBubble = true;
      }
      function Nn(o) {
        return o.defaultPrevented != null ? o.defaultPrevented : o.returnValue == false;
      }
      function Jr(o) {
        bn(o), ba(o);
      }
      function tl(o) {
        return o.target || o.srcElement;
      }
      function Li(o) {
        var c = o.which;
        return c == null && (o.button & 1 ? c = 1 : o.button & 2 ? c = 3 : o.button & 4 && (c = 2)), P && o.ctrlKey && c == 1 && (c = 3), c;
      }
      var Yh = function() {
        if (d && u < 9)
          return false;
        var o = B("div");
        return "draggable" in o || "dragDrop" in o;
      }(), wa;
      function jc(o) {
        if (wa == null) {
          var c = B("span", "​");
          $(o, B("span", [c, document.createTextNode("x")])), o.firstChild.offsetHeight != 0 && (wa = c.offsetWidth <= 1 && c.offsetHeight > 2 && !(d && u < 8));
        }
        var p = wa ? B("span", "​") : B("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
        return p.setAttribute("cm-text", ""), p;
      }
      var nl;
      function Kr(o) {
        if (nl != null)
          return nl;
        var c = $(o, document.createTextNode("AخA")), p = se(c, 0, 1).getBoundingClientRect(), f = se(c, 1, 2).getBoundingClientRect();
        return V(o), !p || p.left == p.right ? false : nl = f.right - p.right < 3;
      }
      var ui = `

b`.split(/\n/).length != 3 ? function(o) {
        for (var c = 0, p = [], f = o.length; c <= f; ) {
          var m = o.indexOf(`
`, c);
          m == -1 && (m = o.length);
          var S = o.slice(c, o.charAt(m - 1) == "\r" ? m - 1 : m), x = S.indexOf("\r");
          x != -1 ? (p.push(S.slice(0, x)), c += x + 1) : (p.push(S), c = m + 1);
        }
        return p;
      } : function(o) {
        return o.split(/\r\n?|\n/);
      }, Yr = window.getSelection ? function(o) {
        try {
          return o.selectionStart != o.selectionEnd;
        } catch {
          return false;
        }
      } : function(o) {
        var c;
        try {
          c = o.ownerDocument.selection.createRange();
        } catch {
        }
        return !c || c.parentElement() != o ? false : c.compareEndPoints("StartToEnd", c) != 0;
      }, Jc = function() {
        var o = B("div");
        return "oncopy" in o ? true : (o.setAttribute("oncopy", "return;"), typeof o.oncopy == "function");
      }(), Di = null;
      function Xh(o) {
        if (Di != null)
          return Di;
        var c = $(o, B("span", "x")), p = c.getBoundingClientRect(), f = se(c, 0, 1).getBoundingClientRect();
        return Di = Math.abs(p.left - f.left) > 1;
      }
      var Ca = {}, Ii = {};
      function Pi(o, c) {
        arguments.length > 2 && (c.dependencies = Array.prototype.slice.call(arguments, 2)), Ca[o] = c;
      }
      function Rs(o, c) {
        Ii[o] = c;
      }
      function xa(o) {
        if (typeof o == "string" && Ii.hasOwnProperty(o))
          o = Ii[o];
        else if (o && typeof o.name == "string" && Ii.hasOwnProperty(o.name)) {
          var c = Ii[o.name];
          typeof c == "string" && (c = { name: c }), o = gt(c, o), o.name = c.name;
        } else {
          if (typeof o == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(o))
            return xa("application/xml");
          if (typeof o == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(o))
            return xa("application/json");
        }
        return typeof o == "string" ? { name: o } : o || { name: "null" };
      }
      function Ea(o, c) {
        c = xa(c);
        var p = Ca[c.name];
        if (!p)
          return Ea(o, "text/plain");
        var f = p(o, c);
        if (Xr.hasOwnProperty(c.name)) {
          var m = Xr[c.name];
          for (var S in m)
            m.hasOwnProperty(S) && (f.hasOwnProperty(S) && (f["_" + S] = f[S]), f[S] = m[S]);
        }
        if (f.name = c.name, c.helperType && (f.helperType = c.helperType), c.modeProps)
          for (var x in c.modeProps)
            f[x] = c.modeProps[x];
        return f;
      }
      var Xr = {};
      function ka(o, c) {
        var p = Xr.hasOwnProperty(o) ? Xr[o] : Xr[o] = {};
        Ve(c, p);
      }
      function qi(o, c) {
        if (c === true)
          return c;
        if (o.copyState)
          return o.copyState(c);
        var p = {};
        for (var f in c) {
          var m = c[f];
          m instanceof Array && (m = m.concat([])), p[f] = m;
        }
        return p;
      }
      function il(o, c) {
        for (var p; o.innerMode && (p = o.innerMode(c), !(!p || p.mode == o)); )
          c = p.state, o = p.mode;
        return p || { mode: o, state: c };
      }
      function Ta(o, c, p) {
        return o.startState ? o.startState(c, p) : true;
      }
      var Vt = function(o, c, p) {
        this.pos = this.start = 0, this.string = o, this.tabSize = c || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = p;
      };
      Vt.prototype.eol = function() {
        return this.pos >= this.string.length;
      }, Vt.prototype.sol = function() {
        return this.pos == this.lineStart;
      }, Vt.prototype.peek = function() {
        return this.string.charAt(this.pos) || void 0;
      }, Vt.prototype.next = function() {
        if (this.pos < this.string.length)
          return this.string.charAt(this.pos++);
      }, Vt.prototype.eat = function(o) {
        var c = this.string.charAt(this.pos), p;
        if (typeof o == "string" ? p = c == o : p = c && (o.test ? o.test(c) : o(c)), p)
          return ++this.pos, c;
      }, Vt.prototype.eatWhile = function(o) {
        for (var c = this.pos; this.eat(o); )
          ;
        return this.pos > c;
      }, Vt.prototype.eatSpace = function() {
        for (var o = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
          ++this.pos;
        return this.pos > o;
      }, Vt.prototype.skipToEnd = function() {
        this.pos = this.string.length;
      }, Vt.prototype.skipTo = function(o) {
        var c = this.string.indexOf(o, this.pos);
        if (c > -1)
          return this.pos = c, true;
      }, Vt.prototype.backUp = function(o) {
        this.pos -= o;
      }, Vt.prototype.column = function() {
        return this.lastColumnPos < this.start && (this.lastColumnValue = qe(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? qe(this.string, this.lineStart, this.tabSize) : 0);
      }, Vt.prototype.indentation = function() {
        return qe(this.string, null, this.tabSize) - (this.lineStart ? qe(this.string, this.lineStart, this.tabSize) : 0);
      }, Vt.prototype.match = function(o, c, p) {
        if (typeof o == "string") {
          var f = function(x) {
            return p ? x.toLowerCase() : x;
          }, m = this.string.substr(this.pos, o.length);
          if (f(m) == f(o))
            return c !== false && (this.pos += o.length), true;
        } else {
          var S = this.string.slice(this.pos).match(o);
          return S && S.index > 0 ? null : (S && c !== false && (this.pos += S[0].length), S);
        }
      }, Vt.prototype.current = function() {
        return this.string.slice(this.start, this.pos);
      }, Vt.prototype.hideFirstChars = function(o, c) {
        this.lineStart += o;
        try {
          return c();
        } finally {
          this.lineStart -= o;
        }
      }, Vt.prototype.lookAhead = function(o) {
        var c = this.lineOracle;
        return c && c.lookAhead(o);
      }, Vt.prototype.baseToken = function() {
        var o = this.lineOracle;
        return o && o.baseToken(this.pos);
      };
      function Be(o, c) {
        if (c -= o.first, c < 0 || c >= o.size)
          throw new Error("There is no line " + (c + o.first) + " in the document.");
        for (var p = o; !p.lines; )
          for (var f = 0; ; ++f) {
            var m = p.children[f], S = m.chunkSize();
            if (c < S) {
              p = m;
              break;
            }
            c -= S;
          }
        return p.lines[c];
      }
      function gr(o, c, p) {
        var f = [], m = c.line;
        return o.iter(c.line, p.line + 1, function(S) {
          var x = S.text;
          m == p.line && (x = x.slice(0, p.ch)), m == c.line && (x = x.slice(c.ch)), f.push(x), ++m;
        }), f;
      }
      function rl(o, c, p) {
        var f = [];
        return o.iter(c, p, function(m) {
          f.push(m.text);
        }), f;
      }
      function ti(o, c) {
        var p = c - o.height;
        if (p)
          for (var f = o; f; f = f.parent)
            f.height += p;
      }
      function N(o) {
        if (o.parent == null)
          return null;
        for (var c = o.parent, p = De(c.lines, o), f = c.parent; f; c = f, f = f.parent)
          for (var m = 0; f.children[m] != c; ++m)
            p += f.children[m].chunkSize();
        return p + c.first;
      }
      function G(o, c) {
        var p = o.first;
        e: do {
          for (var f = 0; f < o.children.length; ++f) {
            var m = o.children[f], S = m.height;
            if (c < S) {
              o = m;
              continue e;
            }
            c -= S, p += m.chunkSize();
          }
          return p;
        } while (!o.lines);
        for (var x = 0; x < o.lines.length; ++x) {
          var k = o.lines[x], D = k.height;
          if (c < D)
            break;
          c -= D;
        }
        return p + x;
      }
      function ie(o, c) {
        return c >= o.first && c < o.first + o.size;
      }
      function fe(o, c) {
        return String(o.lineNumberFormatter(c + o.firstLineNumber));
      }
      function Q(o, c, p) {
        if (p === void 0 && (p = null), !(this instanceof Q))
          return new Q(o, c, p);
        this.line = o, this.ch = c, this.sticky = p;
      }
      function we(o, c) {
        return o.line - c.line || o.ch - c.ch;
      }
      function ut(o, c) {
        return o.sticky == c.sticky && we(o, c) == 0;
      }
      function rn(o) {
        return Q(o.line, o.ch);
      }
      function On(o, c) {
        return we(o, c) < 0 ? c : o;
      }
      function La(o, c) {
        return we(o, c) < 0 ? o : c;
      }
      function n0(o, c) {
        return Math.max(o.first, Math.min(c, o.first + o.size - 1));
      }
      function Ke(o, c) {
        if (c.line < o.first)
          return Q(o.first, 0);
        var p = o.first + o.size - 1;
        return c.line > p ? Q(p, Be(o, p).text.length) : NR(c, Be(o, c.line).text.length);
      }
      function NR(o, c) {
        var p = o.ch;
        return p == null || p > c ? Q(o.line, c) : p < 0 ? Q(o.line, 0) : o;
      }
      function i0(o, c) {
        for (var p = [], f = 0; f < c.length; f++)
          p[f] = Ke(o, c[f]);
        return p;
      }
      var Kc = function(o, c) {
        this.state = o, this.lookAhead = c;
      }, ji = function(o, c, p, f) {
        this.state = c, this.doc = o, this.line = p, this.maxLookAhead = f || 0, this.baseTokens = null, this.baseTokenPos = 1;
      };
      ji.prototype.lookAhead = function(o) {
        var c = this.doc.getLine(this.line + o);
        return c != null && o > this.maxLookAhead && (this.maxLookAhead = o), c;
      }, ji.prototype.baseToken = function(o) {
        if (!this.baseTokens)
          return null;
        for (; this.baseTokens[this.baseTokenPos] <= o; )
          this.baseTokenPos += 2;
        var c = this.baseTokens[this.baseTokenPos + 1];
        return {
          type: c && c.replace(/( |^)overlay .*/, ""),
          size: this.baseTokens[this.baseTokenPos] - o
        };
      }, ji.prototype.nextLine = function() {
        this.line++, this.maxLookAhead > 0 && this.maxLookAhead--;
      }, ji.fromSaved = function(o, c, p) {
        return c instanceof Kc ? new ji(o, qi(o.mode, c.state), p, c.lookAhead) : new ji(o, qi(o.mode, c), p);
      }, ji.prototype.save = function(o) {
        var c = o !== false ? qi(this.doc.mode, this.state) : this.state;
        return this.maxLookAhead > 0 ? new Kc(c, this.maxLookAhead) : c;
      };
      function r0(o, c, p, f) {
        var m = [o.state.modeGen], S = {};
        d0(
          o,
          c.text,
          o.doc.mode,
          p,
          function(_, z) {
            return m.push(_, z);
          },
          S,
          f
        );
        for (var x = p.state, k = function(_) {
          p.baseTokens = m;
          var z = o.state.overlays[_], W = 1, K = 0;
          p.state = true, d0(o, c.text, z.mode, p, function(J, ee) {
            for (var le = W; K < J; ) {
              var pe = m[W];
              pe > J && m.splice(W, 1, J, m[W + 1], pe), W += 2, K = Math.min(J, pe);
            }
            if (ee)
              if (z.opaque)
                m.splice(le, W - le, J, "overlay " + ee), W = le + 2;
              else
                for (; le < W; le += 2) {
                  var Se = m[le + 1];
                  m[le + 1] = (Se ? Se + " " : "") + "overlay " + ee;
                }
          }, S), p.state = x, p.baseTokens = null, p.baseTokenPos = 1;
        }, D = 0; D < o.state.overlays.length; ++D) k(D);
        return { styles: m, classes: S.bgClass || S.textClass ? S : null };
      }
      function s0(o, c, p) {
        if (!c.styles || c.styles[0] != o.state.modeGen) {
          var f = sl(o, N(c)), m = c.text.length > o.options.maxHighlightLength && qi(o.doc.mode, f.state), S = r0(o, c, f);
          m && (f.state = m), c.stateAfter = f.save(!m), c.styles = S.styles, S.classes ? c.styleClasses = S.classes : c.styleClasses && (c.styleClasses = null), p === o.doc.highlightFrontier && (o.doc.modeFrontier = Math.max(o.doc.modeFrontier, ++o.doc.highlightFrontier));
        }
        return c.styles;
      }
      function sl(o, c, p) {
        var f = o.doc, m = o.display;
        if (!f.mode.startState)
          return new ji(f, true, c);
        var S = OR(o, c, p), x = S > f.first && Be(f, S - 1).stateAfter, k = x ? ji.fromSaved(f, x, S) : new ji(f, Ta(f.mode), S);
        return f.iter(S, c, function(D) {
          Zh(o, D.text, k);
          var _ = k.line;
          D.stateAfter = _ == c - 1 || _ % 5 == 0 || _ >= m.viewFrom && _ < m.viewTo ? k.save() : null, k.nextLine();
        }), p && (f.modeFrontier = k.line), k;
      }
      function Zh(o, c, p, f) {
        var m = o.doc.mode, S = new Vt(c, o.options.tabSize, p);
        for (S.start = S.pos = f || 0, c == "" && a0(m, p.state); !S.eol(); )
          Qh(m, S, p.state), S.start = S.pos;
      }
      function a0(o, c) {
        if (o.blankLine)
          return o.blankLine(c);
        if (o.innerMode) {
          var p = il(o, c);
          if (p.mode.blankLine)
            return p.mode.blankLine(p.state);
        }
      }
      function Qh(o, c, p, f) {
        for (var m = 0; m < 10; m++) {
          f && (f[0] = il(o, p).mode);
          var S = o.token(c, p);
          if (c.pos > c.start)
            return S;
        }
        throw new Error("Mode " + o.name + " failed to advance stream.");
      }
      var o0 = function(o, c, p) {
        this.start = o.start, this.end = o.pos, this.string = o.current(), this.type = c || null, this.state = p;
      };
      function l0(o, c, p, f) {
        var m = o.doc, S = m.mode, x;
        c = Ke(m, c);
        var k = Be(m, c.line), D = sl(o, c.line, p), _ = new Vt(k.text, o.options.tabSize, D), z;
        for (f && (z = []); (f || _.pos < c.ch) && !_.eol(); )
          _.start = _.pos, x = Qh(S, _, D.state), f && z.push(new o0(_, x, qi(m.mode, D.state)));
        return f ? z : new o0(_, x, D.state);
      }
      function c0(o, c) {
        if (o)
          for (; ; ) {
            var p = o.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!p)
              break;
            o = o.slice(0, p.index) + o.slice(p.index + p[0].length);
            var f = p[1] ? "bgClass" : "textClass";
            c[f] == null ? c[f] = p[2] : new RegExp("(?:^|\\s)" + p[2] + "(?:$|\\s)").test(c[f]) || (c[f] += " " + p[2]);
          }
        return o;
      }
      function d0(o, c, p, f, m, S, x) {
        var k = p.flattenSpans;
        k == null && (k = o.options.flattenSpans);
        var D = 0, _ = null, z = new Vt(c, o.options.tabSize, f), W, K = o.options.addModeClass && [null];
        for (c == "" && c0(a0(p, f.state), S); !z.eol(); ) {
          if (z.pos > o.options.maxHighlightLength ? (k = false, x && Zh(o, c, f, z.pos), z.pos = c.length, W = null) : W = c0(Qh(p, z, f.state, K), S), K) {
            var J = K[0].name;
            J && (W = "m-" + (W ? J + " " + W : J));
          }
          if (!k || _ != W) {
            for (; D < z.start; )
              D = Math.min(z.start, D + 5e3), m(D, _);
            _ = W;
          }
          z.start = z.pos;
        }
        for (; D < z.pos; ) {
          var ee = Math.min(z.pos, D + 5e3);
          m(ee, _), D = ee;
        }
      }
      function OR(o, c, p) {
        for (var f, m, S = o.doc, x = p ? -1 : c - (o.doc.mode.innerMode ? 1e3 : 100), k = c; k > x; --k) {
          if (k <= S.first)
            return S.first;
          var D = Be(S, k - 1), _ = D.stateAfter;
          if (_ && (!p || k + (_ instanceof Kc ? _.lookAhead : 0) <= S.modeFrontier))
            return k;
          var z = qe(D.text, null, o.options.tabSize);
          (m == null || f > z) && (m = k - 1, f = z);
        }
        return m;
      }
      function VR(o, c) {
        if (o.modeFrontier = Math.min(o.modeFrontier, c), !(o.highlightFrontier < c - 10)) {
          for (var p = o.first, f = c - 1; f > p; f--) {
            var m = Be(o, f).stateAfter;
            if (m && (!(m instanceof Kc) || f + m.lookAhead < c)) {
              p = f + 1;
              break;
            }
          }
          o.highlightFrontier = Math.min(o.highlightFrontier, p);
        }
      }
      var u0 = false, mr = false;
      function BR2() {
        u0 = true;
      }
      function FR() {
        mr = true;
      }
      function Yc(o, c, p) {
        this.marker = o, this.from = c, this.to = p;
      }
      function al(o, c) {
        if (o)
          for (var p = 0; p < o.length; ++p) {
            var f = o[p];
            if (f.marker == c)
              return f;
          }
      }
      function UR(o, c) {
        for (var p, f = 0; f < o.length; ++f)
          o[f] != c && (p || (p = [])).push(o[f]);
        return p;
      }
      function zR(o, c, p) {
        var f = p && window.WeakSet && (p.markedSpans || (p.markedSpans = /* @__PURE__ */ new WeakSet()));
        f && o.markedSpans && f.has(o.markedSpans) ? o.markedSpans.push(c) : (o.markedSpans = o.markedSpans ? o.markedSpans.concat([c]) : [c], f && f.add(o.markedSpans)), c.marker.attachLine(o);
      }
      function $R(o, c, p) {
        var f;
        if (o)
          for (var m = 0; m < o.length; ++m) {
            var S = o[m], x = S.marker, k = S.from == null || (x.inclusiveLeft ? S.from <= c : S.from < c);
            if (k || S.from == c && x.type == "bookmark" && (!p || !S.marker.insertLeft)) {
              var D = S.to == null || (x.inclusiveRight ? S.to >= c : S.to > c);
              (f || (f = [])).push(new Yc(x, S.from, D ? null : S.to));
            }
          }
        return f;
      }
      function GR(o, c, p) {
        var f;
        if (o)
          for (var m = 0; m < o.length; ++m) {
            var S = o[m], x = S.marker, k = S.to == null || (x.inclusiveRight ? S.to >= c : S.to > c);
            if (k || S.from == c && x.type == "bookmark" && (!p || S.marker.insertLeft)) {
              var D = S.from == null || (x.inclusiveLeft ? S.from <= c : S.from < c);
              (f || (f = [])).push(new Yc(
                x,
                D ? null : S.from - c,
                S.to == null ? null : S.to - c
              ));
            }
          }
        return f;
      }
      function ef(o, c) {
        if (c.full)
          return null;
        var p = ie(o, c.from.line) && Be(o, c.from.line).markedSpans, f = ie(o, c.to.line) && Be(o, c.to.line).markedSpans;
        if (!p && !f)
          return null;
        var m = c.from.ch, S = c.to.ch, x = we(c.from, c.to) == 0, k = $R(p, m, x), D = GR(f, S, x), _ = c.text.length == 1, z = ye(c.text).length + (_ ? m : 0);
        if (k)
          for (var W = 0; W < k.length; ++W) {
            var K = k[W];
            if (K.to == null) {
              var J = al(D, K.marker);
              J ? _ && (K.to = J.to == null ? null : J.to + z) : K.to = m;
            }
          }
        if (D)
          for (var ee = 0; ee < D.length; ++ee) {
            var le = D[ee];
            if (le.to != null && (le.to += z), le.from == null) {
              var pe = al(k, le.marker);
              pe || (le.from = z, _ && (k || (k = [])).push(le));
            } else
              le.from += z, _ && (k || (k = [])).push(le);
          }
        k && (k = h0(k)), D && D != k && (D = h0(D));
        var Se = [k];
        if (!_) {
          var Te = c.text.length - 2, be;
          if (Te > 0 && k)
            for (var Ie = 0; Ie < k.length; ++Ie)
              k[Ie].to == null && (be || (be = [])).push(new Yc(k[Ie].marker, null, null));
          for (var Ge = 0; Ge < Te; ++Ge)
            Se.push(be);
          Se.push(D);
        }
        return Se;
      }
      function h0(o) {
        for (var c = 0; c < o.length; ++c) {
          var p = o[c];
          p.from != null && p.from == p.to && p.marker.clearWhenEmpty !== false && o.splice(c--, 1);
        }
        return o.length ? o : null;
      }
      function WR(o, c, p) {
        var f = null;
        if (o.iter(c.line, p.line + 1, function(J) {
          if (J.markedSpans)
            for (var ee = 0; ee < J.markedSpans.length; ++ee) {
              var le = J.markedSpans[ee].marker;
              le.readOnly && (!f || De(f, le) == -1) && (f || (f = [])).push(le);
            }
        }), !f)
          return null;
        for (var m = [{ from: c, to: p }], S = 0; S < f.length; ++S)
          for (var x = f[S], k = x.find(0), D = 0; D < m.length; ++D) {
            var _ = m[D];
            if (!(we(_.to, k.from) < 0 || we(_.from, k.to) > 0)) {
              var z = [D, 1], W = we(_.from, k.from), K = we(_.to, k.to);
              (W < 0 || !x.inclusiveLeft && !W) && z.push({ from: _.from, to: k.from }), (K > 0 || !x.inclusiveRight && !K) && z.push({ from: k.to, to: _.to }), m.splice.apply(m, z), D += z.length - 3;
            }
          }
        return m;
      }
      function f0(o) {
        var c = o.markedSpans;
        if (c) {
          for (var p = 0; p < c.length; ++p)
            c[p].marker.detachLine(o);
          o.markedSpans = null;
        }
      }
      function p0(o, c) {
        if (c) {
          for (var p = 0; p < c.length; ++p)
            c[p].marker.attachLine(o);
          o.markedSpans = c;
        }
      }
      function Xc(o) {
        return o.inclusiveLeft ? -1 : 0;
      }
      function Zc(o) {
        return o.inclusiveRight ? 1 : 0;
      }
      function tf(o, c) {
        var p = o.lines.length - c.lines.length;
        if (p != 0)
          return p;
        var f = o.find(), m = c.find(), S = we(f.from, m.from) || Xc(o) - Xc(c);
        if (S)
          return -S;
        var x = we(f.to, m.to) || Zc(o) - Zc(c);
        return x || c.id - o.id;
      }
      function g0(o, c) {
        var p = mr && o.markedSpans, f;
        if (p)
          for (var m = void 0, S = 0; S < p.length; ++S)
            m = p[S], m.marker.collapsed && (c ? m.from : m.to) == null && (!f || tf(f, m.marker) < 0) && (f = m.marker);
        return f;
      }
      function m0(o) {
        return g0(o, true);
      }
      function Qc(o) {
        return g0(o, false);
      }
      function HR(o, c) {
        var p = mr && o.markedSpans, f;
        if (p)
          for (var m = 0; m < p.length; ++m) {
            var S = p[m];
            S.marker.collapsed && (S.from == null || S.from < c) && (S.to == null || S.to > c) && (!f || tf(f, S.marker) < 0) && (f = S.marker);
          }
        return f;
      }
      function v0(o, c, p, f, m) {
        var S = Be(o, c), x = mr && S.markedSpans;
        if (x)
          for (var k = 0; k < x.length; ++k) {
            var D = x[k];
            if (D.marker.collapsed) {
              var _ = D.marker.find(0), z = we(_.from, p) || Xc(D.marker) - Xc(m), W = we(_.to, f) || Zc(D.marker) - Zc(m);
              if (!(z >= 0 && W <= 0 || z <= 0 && W >= 0) && (z <= 0 && (D.marker.inclusiveRight && m.inclusiveLeft ? we(_.to, p) >= 0 : we(_.to, p) > 0) || z >= 0 && (D.marker.inclusiveRight && m.inclusiveLeft ? we(_.from, f) <= 0 : we(_.from, f) < 0)))
                return true;
            }
          }
      }
      function Ri(o) {
        for (var c; c = m0(o); )
          o = c.find(-1, true).line;
        return o;
      }
      function qR(o) {
        for (var c; c = Qc(o); )
          o = c.find(1, true).line;
        return o;
      }
      function jR(o) {
        for (var c, p; c = Qc(o); )
          o = c.find(1, true).line, (p || (p = [])).push(o);
        return p;
      }
      function nf(o, c) {
        var p = Be(o, c), f = Ri(p);
        return p == f ? c : N(f);
      }
      function y0(o, c) {
        if (c > o.lastLine())
          return c;
        var p = Be(o, c), f;
        if (!Zr(o, p))
          return c;
        for (; f = Qc(p); )
          p = f.find(1, true).line;
        return N(p) + 1;
      }
      function Zr(o, c) {
        var p = mr && c.markedSpans;
        if (p) {
          for (var f = void 0, m = 0; m < p.length; ++m)
            if (f = p[m], !!f.marker.collapsed) {
              if (f.from == null)
                return true;
              if (!f.marker.widgetNode && f.from == 0 && f.marker.inclusiveLeft && rf(o, c, f))
                return true;
            }
        }
      }
      function rf(o, c, p) {
        if (p.to == null) {
          var f = p.marker.find(1, true);
          return rf(o, f.line, al(f.line.markedSpans, p.marker));
        }
        if (p.marker.inclusiveRight && p.to == c.text.length)
          return true;
        for (var m = void 0, S = 0; S < c.markedSpans.length; ++S)
          if (m = c.markedSpans[S], m.marker.collapsed && !m.marker.widgetNode && m.from == p.to && (m.to == null || m.to != p.from) && (m.marker.inclusiveLeft || p.marker.inclusiveRight) && rf(o, c, m))
            return true;
      }
      function vr(o) {
        o = Ri(o);
        for (var c = 0, p = o.parent, f = 0; f < p.lines.length; ++f) {
          var m = p.lines[f];
          if (m == o)
            break;
          c += m.height;
        }
        for (var S = p.parent; S; p = S, S = p.parent)
          for (var x = 0; x < S.children.length; ++x) {
            var k = S.children[x];
            if (k == p)
              break;
            c += k.height;
          }
        return c;
      }
      function ed(o) {
        if (o.height == 0)
          return 0;
        for (var c = o.text.length, p, f = o; p = m0(f); ) {
          var m = p.find(0, true);
          f = m.from.line, c += m.from.ch - m.to.ch;
        }
        for (f = o; p = Qc(f); ) {
          var S = p.find(0, true);
          c -= f.text.length - S.from.ch, f = S.to.line, c += f.text.length - S.to.ch;
        }
        return c;
      }
      function sf(o) {
        var c = o.display, p = o.doc;
        c.maxLine = Be(p, p.first), c.maxLineLength = ed(c.maxLine), c.maxLineChanged = true, p.iter(function(f) {
          var m = ed(f);
          m > c.maxLineLength && (c.maxLineLength = m, c.maxLine = f);
        });
      }
      var Da = function(o, c, p) {
        this.text = o, p0(this, c), this.height = p ? p(this) : 1;
      };
      Da.prototype.lineNo = function() {
        return N(this);
      }, Ti(Da);
      function JR(o, c, p, f) {
        o.text = c, o.stateAfter && (o.stateAfter = null), o.styles && (o.styles = null), o.order != null && (o.order = null), f0(o), p0(o, p);
        var m = f ? f(o) : 1;
        m != o.height && ti(o, m);
      }
      function KR(o) {
        o.parent = null, f0(o);
      }
      var YR = {}, XR = {};
      function S0(o, c) {
        if (!o || /^\s*$/.test(o))
          return null;
        var p = c.addModeClass ? XR : YR;
        return p[o] || (p[o] = o.replace(/\S+/g, "cm-$&"));
      }
      function b0(o, c) {
        var p = ue("span", null, null, h ? "padding-right: .1px" : null), f = {
          pre: ue("pre", [p], "CodeMirror-line"),
          content: p,
          col: 0,
          pos: 0,
          cm: o,
          trailingSpace: false,
          splitSpaces: o.getOption("lineWrapping")
        };
        c.measure = {};
        for (var m = 0; m <= (c.rest ? c.rest.length : 0); m++) {
          var S = m ? c.rest[m - 1] : c.line, x = void 0;
          f.pos = 0, f.addToken = QR, Kr(o.display.measure) && (x = tt(S, o.doc.direction)) && (f.addToken = tA(f.addToken, x)), f.map = [];
          var k = c != o.display.externalMeasured && N(S);
          nA(S, f, s0(o, S, k)), S.styleClasses && (S.styleClasses.bgClass && (f.bgClass = ce(S.styleClasses.bgClass, f.bgClass || "")), S.styleClasses.textClass && (f.textClass = ce(S.styleClasses.textClass, f.textClass || ""))), f.map.length == 0 && f.map.push(0, 0, f.content.appendChild(jc(o.display.measure))), m == 0 ? (c.measure.map = f.map, c.measure.cache = {}) : ((c.measure.maps || (c.measure.maps = [])).push(f.map), (c.measure.caches || (c.measure.caches = [])).push({}));
        }
        if (h) {
          var D = f.content.lastChild;
          (/\bcm-tab\b/.test(D.className) || D.querySelector && D.querySelector(".cm-tab")) && (f.content.className = "cm-tab-wrap-hack");
        }
        return Nt(o, "renderLine", o, c.line, f.pre), f.pre.className && (f.textClass = ce(f.pre.className, f.textClass || "")), f;
      }
      function ZR(o) {
        var c = B("span", "•", "cm-invalidchar");
        return c.title = "\\u" + o.charCodeAt(0).toString(16), c.setAttribute("aria-label", c.title), c;
      }
      function QR(o, c, p, f, m, S, x) {
        if (c) {
          var k = o.splitSpaces ? eA(c, o.trailingSpace) : c, D = o.cm.state.specialChars, _ = false, z;
          if (!D.test(c))
            o.col += c.length, z = document.createTextNode(k), o.map.push(o.pos, o.pos + c.length, z), d && u < 9 && (_ = true), o.pos += c.length;
          else {
            z = document.createDocumentFragment();
            for (var W = 0; ; ) {
              D.lastIndex = W;
              var K = D.exec(c), J = K ? K.index - W : c.length - W;
              if (J) {
                var ee = document.createTextNode(k.slice(W, W + J));
                d && u < 9 ? z.appendChild(B("span", [ee])) : z.appendChild(ee), o.map.push(o.pos, o.pos + J, ee), o.col += J, o.pos += J;
              }
              if (!K)
                break;
              W += J + 1;
              var le = void 0;
              if (K[0] == "	") {
                var pe = o.cm.options.tabSize, Se = pe - o.col % pe;
                le = z.appendChild(B("span", ke(Se), "cm-tab")), le.setAttribute("role", "presentation"), le.setAttribute("cm-text", "	"), o.col += Se;
              } else K[0] == "\r" || K[0] == `
` ? (le = z.appendChild(B("span", K[0] == "\r" ? "␍" : "␤", "cm-invalidchar")), le.setAttribute("cm-text", K[0]), o.col += 1) : (le = o.cm.options.specialCharPlaceholder(K[0]), le.setAttribute("cm-text", K[0]), d && u < 9 ? z.appendChild(B("span", [le])) : z.appendChild(le), o.col += 1);
              o.map.push(o.pos, o.pos + 1, le), o.pos++;
            }
          }
          if (o.trailingSpace = k.charCodeAt(c.length - 1) == 32, p || f || m || _ || S || x) {
            var Te = p || "";
            f && (Te += f), m && (Te += m);
            var be = B("span", [z], Te, S);
            if (x)
              for (var Ie in x)
                x.hasOwnProperty(Ie) && Ie != "style" && Ie != "class" && be.setAttribute(Ie, x[Ie]);
            return o.content.appendChild(be);
          }
          o.content.appendChild(z);
        }
      }
      function eA(o, c) {
        if (o.length > 1 && !/  /.test(o))
          return o;
        for (var p = c, f = "", m = 0; m < o.length; m++) {
          var S = o.charAt(m);
          S == " " && p && (m == o.length - 1 || o.charCodeAt(m + 1) == 32) && (S = " "), f += S, p = S == " ";
        }
        return f;
      }
      function tA(o, c) {
        return function(p, f, m, S, x, k, D) {
          m = m ? m + " cm-force-border" : "cm-force-border";
          for (var _ = p.pos, z = _ + f.length; ; ) {
            for (var W = void 0, K = 0; K < c.length && (W = c[K], !(W.to > _ && W.from <= _)); K++)
              ;
            if (W.to >= z)
              return o(p, f, m, S, x, k, D);
            o(p, f.slice(0, W.to - _), m, S, null, k, D), S = null, f = f.slice(W.to - _), _ = W.to;
          }
        };
      }
      function w0(o, c, p, f) {
        var m = !f && p.widgetNode;
        m && o.map.push(o.pos, o.pos + c, m), !f && o.cm.display.input.needsContentAttribute && (m || (m = o.content.appendChild(document.createElement("span"))), m.setAttribute("cm-marker", p.id)), m && (o.cm.display.input.setUneditable(m), o.content.appendChild(m)), o.pos += c, o.trailingSpace = false;
      }
      function nA(o, c, p) {
        var f = o.markedSpans, m = o.text, S = 0;
        if (!f) {
          for (var x = 1; x < p.length; x += 2)
            c.addToken(c, m.slice(S, S = p[x]), S0(p[x + 1], c.cm.options));
          return;
        }
        for (var k = m.length, D = 0, _ = 1, z = "", W, K, J = 0, ee, le, pe, Se, Te; ; ) {
          if (J == D) {
            ee = le = pe = K = "", Te = null, Se = null, J = 1 / 0;
            for (var be = [], Ie = void 0, Ge = 0; Ge < f.length; ++Ge) {
              var Ue = f[Ge], Qe = Ue.marker;
              if (Qe.type == "bookmark" && Ue.from == D && Qe.widgetNode)
                be.push(Qe);
              else if (Ue.from <= D && (Ue.to == null || Ue.to > D || Qe.collapsed && Ue.to == D && Ue.from == D)) {
                if (Ue.to != null && Ue.to != D && J > Ue.to && (J = Ue.to, le = ""), Qe.className && (ee += " " + Qe.className), Qe.css && (K = (K ? K + ";" : "") + Qe.css), Qe.startStyle && Ue.from == D && (pe += " " + Qe.startStyle), Qe.endStyle && Ue.to == J && (Ie || (Ie = [])).push(Qe.endStyle, Ue.to), Qe.title && ((Te || (Te = {})).title = Qe.title), Qe.attributes)
                  for (var Et in Qe.attributes)
                    (Te || (Te = {}))[Et] = Qe.attributes[Et];
                Qe.collapsed && (!Se || tf(Se.marker, Qe) < 0) && (Se = Ue);
              } else Ue.from > D && J > Ue.from && (J = Ue.from);
            }
            if (Ie)
              for (var ln = 0; ln < Ie.length; ln += 2)
                Ie[ln + 1] == J && (le += " " + Ie[ln]);
            if (!Se || Se.from == D)
              for (var Mt = 0; Mt < be.length; ++Mt)
                w0(c, 0, be[Mt]);
            if (Se && (Se.from || 0) == D) {
              if (w0(
                c,
                (Se.to == null ? k + 1 : Se.to) - D,
                Se.marker,
                Se.from == null
              ), Se.to == null)
                return;
              Se.to == D && (Se = false);
            }
          }
          if (D >= k)
            break;
          for (var Yn = Math.min(k, J); ; ) {
            if (z) {
              var Fn = D + z.length;
              if (!Se) {
                var Yt = Fn > Yn ? z.slice(0, Yn - D) : z;
                c.addToken(
                  c,
                  Yt,
                  W ? W + ee : ee,
                  pe,
                  D + Yt.length == J ? le : "",
                  K,
                  Te
                );
              }
              if (Fn >= Yn) {
                z = z.slice(Yn - D), D = Yn;
                break;
              }
              D = Fn, pe = "";
            }
            z = m.slice(S, S = p[_++]), W = S0(p[_++], c.cm.options);
          }
        }
      }
      function C0(o, c, p) {
        this.line = c, this.rest = jR(c), this.size = this.rest ? N(ye(this.rest)) - p + 1 : 1, this.node = this.text = null, this.hidden = Zr(o, c);
      }
      function td(o, c, p) {
        for (var f = [], m, S = c; S < p; S = m) {
          var x = new C0(o.doc, Be(o.doc, S), S);
          m = S + x.size, f.push(x);
        }
        return f;
      }
      var Ia = null;
      function iA(o) {
        Ia ? Ia.ops.push(o) : o.ownsGroup = Ia = {
          ops: [o],
          delayedCallbacks: []
        };
      }
      function rA(o) {
        var c = o.delayedCallbacks, p = 0;
        do {
          for (; p < c.length; p++)
            c[p].call(null);
          for (var f = 0; f < o.ops.length; f++) {
            var m = o.ops[f];
            if (m.cursorActivityHandlers)
              for (; m.cursorActivityCalled < m.cursorActivityHandlers.length; )
                m.cursorActivityHandlers[m.cursorActivityCalled++].call(null, m.cm);
          }
        } while (p < c.length);
      }
      function sA(o, c) {
        var p = o.ownsGroup;
        if (p)
          try {
            rA(p);
          } finally {
            Ia = null, c(p);
          }
      }
      var ol = null;
      function sn(o, c) {
        var p = pr(o, c);
        if (p.length) {
          var f = Array.prototype.slice.call(arguments, 2), m;
          Ia ? m = Ia.delayedCallbacks : ol ? m = ol : (m = ol = [], setTimeout(aA, 0));
          for (var S = function(k) {
            m.push(function() {
              return p[k].apply(null, f);
            });
          }, x = 0; x < p.length; ++x)
            S(x);
        }
      }
      function aA() {
        var o = ol;
        ol = null;
        for (var c = 0; c < o.length; ++c)
          o[c]();
      }
      function x0(o, c, p, f) {
        for (var m = 0; m < c.changes.length; m++) {
          var S = c.changes[m];
          S == "text" ? lA(o, c) : S == "gutter" ? k0(o, c, p, f) : S == "class" ? af(o, c) : S == "widget" && cA(o, c, f);
        }
        c.changes = null;
      }
      function ll(o) {
        return o.node == o.text && (o.node = B("div", null, null, "position: relative"), o.text.parentNode && o.text.parentNode.replaceChild(o.node, o.text), o.node.appendChild(o.text), d && u < 8 && (o.node.style.zIndex = 2)), o.node;
      }
      function oA(o, c) {
        var p = c.bgClass ? c.bgClass + " " + (c.line.bgClass || "") : c.line.bgClass;
        if (p && (p += " CodeMirror-linebackground"), c.background)
          p ? c.background.className = p : (c.background.parentNode.removeChild(c.background), c.background = null);
        else if (p) {
          var f = ll(c);
          c.background = f.insertBefore(B("div", null, p), f.firstChild), o.display.input.setUneditable(c.background);
        }
      }
      function E0(o, c) {
        var p = o.display.externalMeasured;
        return p && p.line == c.line ? (o.display.externalMeasured = null, c.measure = p.measure, p.built) : b0(o, c);
      }
      function lA(o, c) {
        var p = c.text.className, f = E0(o, c);
        c.text == c.node && (c.node = f.pre), c.text.parentNode.replaceChild(f.pre, c.text), c.text = f.pre, f.bgClass != c.bgClass || f.textClass != c.textClass ? (c.bgClass = f.bgClass, c.textClass = f.textClass, af(o, c)) : p && (c.text.className = p);
      }
      function af(o, c) {
        oA(o, c), c.line.wrapClass ? ll(c).className = c.line.wrapClass : c.node != c.text && (c.node.className = "");
        var p = c.textClass ? c.textClass + " " + (c.line.textClass || "") : c.line.textClass;
        c.text.className = p || "";
      }
      function k0(o, c, p, f) {
        if (c.gutter && (c.node.removeChild(c.gutter), c.gutter = null), c.gutterBackground && (c.node.removeChild(c.gutterBackground), c.gutterBackground = null), c.line.gutterClass) {
          var m = ll(c);
          c.gutterBackground = B(
            "div",
            null,
            "CodeMirror-gutter-background " + c.line.gutterClass,
            "left: " + (o.options.fixedGutter ? f.fixedPos : -f.gutterTotalWidth) + "px; width: " + f.gutterTotalWidth + "px"
          ), o.display.input.setUneditable(c.gutterBackground), m.insertBefore(c.gutterBackground, c.text);
        }
        var S = c.line.gutterMarkers;
        if (o.options.lineNumbers || S) {
          var x = ll(c), k = c.gutter = B("div", null, "CodeMirror-gutter-wrapper", "left: " + (o.options.fixedGutter ? f.fixedPos : -f.gutterTotalWidth) + "px");
          if (k.setAttribute("aria-hidden", "true"), o.display.input.setUneditable(k), x.insertBefore(k, c.text), c.line.gutterClass && (k.className += " " + c.line.gutterClass), o.options.lineNumbers && (!S || !S["CodeMirror-linenumbers"]) && (c.lineNumber = k.appendChild(
            B(
              "div",
              fe(o.options, p),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + f.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + o.display.lineNumInnerWidth + "px"
            )
          )), S)
            for (var D = 0; D < o.display.gutterSpecs.length; ++D) {
              var _ = o.display.gutterSpecs[D].className, z = S.hasOwnProperty(_) && S[_];
              z && k.appendChild(B(
                "div",
                [z],
                "CodeMirror-gutter-elt",
                "left: " + f.gutterLeft[_] + "px; width: " + f.gutterWidth[_] + "px"
              ));
            }
        }
      }
      function cA(o, c, p) {
        c.alignable && (c.alignable = null);
        for (var f = q("CodeMirror-linewidget"), m = c.node.firstChild, S = void 0; m; m = S)
          S = m.nextSibling, f.test(m.className) && c.node.removeChild(m);
        T0(o, c, p);
      }
      function dA(o, c, p, f) {
        var m = E0(o, c);
        return c.text = c.node = m.pre, m.bgClass && (c.bgClass = m.bgClass), m.textClass && (c.textClass = m.textClass), af(o, c), k0(o, c, p, f), T0(o, c, f), c.node;
      }
      function T0(o, c, p) {
        if (L0(o, c.line, c, p, true), c.rest)
          for (var f = 0; f < c.rest.length; f++)
            L0(o, c.rest[f], c, p, false);
      }
      function L0(o, c, p, f, m) {
        if (c.widgets)
          for (var S = ll(p), x = 0, k = c.widgets; x < k.length; ++x) {
            var D = k[x], _ = B("div", [D.node], "CodeMirror-linewidget" + (D.className ? " " + D.className : ""));
            D.handleMouseEvents || _.setAttribute("cm-ignore-events", "true"), uA(D, _, p, f), o.display.input.setUneditable(_), m && D.above ? S.insertBefore(_, p.gutter || p.text) : S.appendChild(_), sn(D, "redraw");
          }
      }
      function uA(o, c, p, f) {
        if (o.noHScroll) {
          (p.alignable || (p.alignable = [])).push(c);
          var m = f.wrapperWidth;
          c.style.left = f.fixedPos + "px", o.coverGutter || (m -= f.gutterTotalWidth, c.style.paddingLeft = f.gutterTotalWidth + "px"), c.style.width = m + "px";
        }
        o.coverGutter && (c.style.zIndex = 5, c.style.position = "relative", o.noHScroll || (c.style.marginLeft = -f.gutterTotalWidth + "px"));
      }
      function cl(o) {
        if (o.height != null)
          return o.height;
        var c = o.doc.cm;
        if (!c)
          return 0;
        if (!Pe(document.body, o.node)) {
          var p = "position: relative;";
          o.coverGutter && (p += "margin-left: -" + c.display.gutters.offsetWidth + "px;"), o.noHScroll && (p += "width: " + c.display.wrapper.clientWidth + "px;"), $(c.display.measure, B("div", [o.node], null, p));
        }
        return o.height = o.node.parentNode.offsetHeight;
      }
      function yr(o, c) {
        for (var p = tl(c); p != o.wrapper; p = p.parentNode)
          if (!p || p.nodeType == 1 && p.getAttribute("cm-ignore-events") == "true" || p.parentNode == o.sizer && p != o.mover)
            return true;
      }
      function nd(o) {
        return o.lineSpace.offsetTop;
      }
      function of(o) {
        return o.mover.offsetHeight - o.lineSpace.offsetHeight;
      }
      function D0(o) {
        if (o.cachedPaddingH)
          return o.cachedPaddingH;
        var c = $(o.measure, B("pre", "x", "CodeMirror-line-like")), p = window.getComputedStyle ? window.getComputedStyle(c) : c.currentStyle, f = { left: parseInt(p.paddingLeft), right: parseInt(p.paddingRight) };
        return !isNaN(f.left) && !isNaN(f.right) && (o.cachedPaddingH = f), f;
      }
      function Ji(o) {
        return et - o.display.nativeBarWidth;
      }
      function As(o) {
        return o.display.scroller.clientWidth - Ji(o) - o.display.barWidth;
      }
      function lf(o) {
        return o.display.scroller.clientHeight - Ji(o) - o.display.barHeight;
      }
      function hA(o, c, p) {
        var f = o.options.lineWrapping, m = f && As(o);
        if (!c.measure.heights || f && c.measure.width != m) {
          var S = c.measure.heights = [];
          if (f) {
            c.measure.width = m;
            for (var x = c.text.firstChild.getClientRects(), k = 0; k < x.length - 1; k++) {
              var D = x[k], _ = x[k + 1];
              Math.abs(D.bottom - _.bottom) > 2 && S.push((D.bottom + _.top) / 2 - p.top);
            }
          }
          S.push(p.bottom - p.top);
        }
      }
      function I0(o, c, p) {
        if (o.line == c)
          return { map: o.measure.map, cache: o.measure.cache };
        if (o.rest) {
          for (var f = 0; f < o.rest.length; f++)
            if (o.rest[f] == c)
              return { map: o.measure.maps[f], cache: o.measure.caches[f] };
          for (var m = 0; m < o.rest.length; m++)
            if (N(o.rest[m]) > p)
              return { map: o.measure.maps[m], cache: o.measure.caches[m], before: true };
        }
      }
      function fA(o, c) {
        c = Ri(c);
        var p = N(c), f = o.display.externalMeasured = new C0(o.doc, c, p);
        f.lineN = p;
        var m = f.built = b0(o, f);
        return f.text = m.pre, $(o.display.lineMeasure, m.pre), f;
      }
      function P0(o, c, p, f) {
        return Ki(o, Pa(o, c), p, f);
      }
      function cf(o, c) {
        if (c >= o.display.viewFrom && c < o.display.viewTo)
          return o.display.view[Ns(o, c)];
        var p = o.display.externalMeasured;
        if (p && c >= p.lineN && c < p.lineN + p.size)
          return p;
      }
      function Pa(o, c) {
        var p = N(c), f = cf(o, p);
        f && !f.text ? f = null : f && f.changes && (x0(o, f, p, pf(o)), o.curOp.forceUpdate = true), f || (f = fA(o, c));
        var m = I0(f, c, p);
        return {
          line: c,
          view: f,
          rect: null,
          map: m.map,
          cache: m.cache,
          before: m.before,
          hasHeights: false
        };
      }
      function Ki(o, c, p, f, m) {
        c.before && (p = -1);
        var S = p + (f || ""), x;
        return c.cache.hasOwnProperty(S) ? x = c.cache[S] : (c.rect || (c.rect = c.view.text.getBoundingClientRect()), c.hasHeights || (hA(o, c.view, c.rect), c.hasHeights = true), x = gA(o, c, p, f), x.bogus || (c.cache[S] = x)), {
          left: x.left,
          right: x.right,
          top: m ? x.rtop : x.top,
          bottom: m ? x.rbottom : x.bottom
        };
      }
      var R0 = { left: 0, right: 0, top: 0, bottom: 0 };
      function A0(o, c, p) {
        for (var f, m, S, x, k, D, _ = 0; _ < o.length; _ += 3)
          if (k = o[_], D = o[_ + 1], c < k ? (m = 0, S = 1, x = "left") : c < D ? (m = c - k, S = m + 1) : (_ == o.length - 3 || c == D && o[_ + 3] > c) && (S = D - k, m = S - 1, c >= D && (x = "right")), m != null) {
            if (f = o[_ + 2], k == D && p == (f.insertLeft ? "left" : "right") && (x = p), p == "left" && m == 0)
              for (; _ && o[_ - 2] == o[_ - 3] && o[_ - 1].insertLeft; )
                f = o[(_ -= 3) + 2], x = "left";
            if (p == "right" && m == D - k)
              for (; _ < o.length - 3 && o[_ + 3] == o[_ + 4] && !o[_ + 5].insertLeft; )
                f = o[(_ += 3) + 2], x = "right";
            break;
          }
        return { node: f, start: m, end: S, collapse: x, coverStart: k, coverEnd: D };
      }
      function pA(o, c) {
        var p = R0;
        if (c == "left")
          for (var f = 0; f < o.length && (p = o[f]).left == p.right; f++)
            ;
        else
          for (var m = o.length - 1; m >= 0 && (p = o[m]).left == p.right; m--)
            ;
        return p;
      }
      function gA(o, c, p, f) {
        var m = A0(c.map, p, f), S = m.node, x = m.start, k = m.end, D = m.collapse, _;
        if (S.nodeType == 3) {
          for (var z = 0; z < 4; z++) {
            for (; x && Ze(c.line.text.charAt(m.coverStart + x)); )
              --x;
            for (; m.coverStart + k < m.coverEnd && Ze(c.line.text.charAt(m.coverStart + k)); )
              ++k;
            if (d && u < 9 && x == 0 && k == m.coverEnd - m.coverStart ? _ = S.parentNode.getBoundingClientRect() : _ = pA(se(S, x, k).getClientRects(), f), _.left || _.right || x == 0)
              break;
            k = x, x = x - 1, D = "right";
          }
          d && u < 11 && (_ = mA(o.display.measure, _));
        } else {
          x > 0 && (D = f = "right");
          var W;
          o.options.lineWrapping && (W = S.getClientRects()).length > 1 ? _ = W[f == "right" ? W.length - 1 : 0] : _ = S.getBoundingClientRect();
        }
        if (d && u < 9 && !x && (!_ || !_.left && !_.right)) {
          var K = S.parentNode.getClientRects()[0];
          K ? _ = { left: K.left, right: K.left + Aa(o.display), top: K.top, bottom: K.bottom } : _ = R0;
        }
        for (var J = _.top - c.rect.top, ee = _.bottom - c.rect.top, le = (J + ee) / 2, pe = c.view.measure.heights, Se = 0; Se < pe.length - 1 && !(le < pe[Se]); Se++)
          ;
        var Te = Se ? pe[Se - 1] : 0, be = pe[Se], Ie = {
          left: (D == "right" ? _.right : _.left) - c.rect.left,
          right: (D == "left" ? _.left : _.right) - c.rect.left,
          top: Te,
          bottom: be
        };
        return !_.left && !_.right && (Ie.bogus = true), o.options.singleCursorHeightPerLine || (Ie.rtop = J, Ie.rbottom = ee), Ie;
      }
      function mA(o, c) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !Xh(o))
          return c;
        var p = screen.logicalXDPI / screen.deviceXDPI, f = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: c.left * p,
          right: c.right * p,
          top: c.top * f,
          bottom: c.bottom * f
        };
      }
      function _0(o) {
        if (o.measure && (o.measure.cache = {}, o.measure.heights = null, o.rest))
          for (var c = 0; c < o.rest.length; c++)
            o.measure.caches[c] = {};
      }
      function M0(o) {
        o.display.externalMeasure = null, V(o.display.lineMeasure);
        for (var c = 0; c < o.display.view.length; c++)
          _0(o.display.view[c]);
      }
      function dl(o) {
        M0(o), o.display.cachedCharWidth = o.display.cachedTextHeight = o.display.cachedPaddingH = null, o.options.lineWrapping || (o.display.maxLineChanged = true), o.display.lineNumChars = null;
      }
      function N0(o) {
        return v && I ? -(o.body.getBoundingClientRect().left - parseInt(getComputedStyle(o.body).marginLeft)) : o.defaultView.pageXOffset || (o.documentElement || o.body).scrollLeft;
      }
      function O0(o) {
        return v && I ? -(o.body.getBoundingClientRect().top - parseInt(getComputedStyle(o.body).marginTop)) : o.defaultView.pageYOffset || (o.documentElement || o.body).scrollTop;
      }
      function df(o) {
        var c = Ri(o), p = c.widgets, f = 0;
        if (p)
          for (var m = 0; m < p.length; ++m)
            p[m].above && (f += cl(p[m]));
        return f;
      }
      function id(o, c, p, f, m) {
        if (!m) {
          var S = df(c);
          p.top += S, p.bottom += S;
        }
        if (f == "line")
          return p;
        f || (f = "local");
        var x = vr(c);
        if (f == "local" ? x += nd(o.display) : x -= o.display.viewOffset, f == "page" || f == "window") {
          var k = o.display.lineSpace.getBoundingClientRect();
          x += k.top + (f == "window" ? 0 : O0(Ne(o)));
          var D = k.left + (f == "window" ? 0 : N0(Ne(o)));
          p.left += D, p.right += D;
        }
        return p.top += x, p.bottom += x, p;
      }
      function V0(o, c, p) {
        if (p == "div")
          return c;
        var f = c.left, m = c.top;
        if (p == "page")
          f -= N0(Ne(o)), m -= O0(Ne(o));
        else if (p == "local" || !p) {
          var S = o.display.sizer.getBoundingClientRect();
          f += S.left, m += S.top;
        }
        var x = o.display.lineSpace.getBoundingClientRect();
        return { left: f - x.left, top: m - x.top };
      }
      function rd(o, c, p, f, m) {
        return f || (f = Be(o.doc, c.line)), id(o, f, P0(o, f, c.ch, m), p);
      }
      function Ai(o, c, p, f, m, S) {
        f = f || Be(o.doc, c.line), m || (m = Pa(o, f));
        function x(ee, le) {
          var pe = Ki(o, m, ee, le ? "right" : "left", S);
          return le ? pe.left = pe.right : pe.right = pe.left, id(o, f, pe, p);
        }
        var k = tt(f, o.doc.direction), D = c.ch, _ = c.sticky;
        if (D >= f.text.length ? (D = f.text.length, _ = "before") : D <= 0 && (D = 0, _ = "after"), !k)
          return x(_ == "before" ? D - 1 : D, _ == "before");
        function z(ee, le, pe) {
          var Se = k[le], Te = Se.level == 1;
          return x(pe ? ee - 1 : ee, Te != pe);
        }
        var W = jr(k, D, _), K = Hi, J = z(D, W, _ == "before");
        return K != null && (J.other = z(D, K, _ != "before")), J;
      }
      function B0(o, c) {
        var p = 0;
        c = Ke(o.doc, c), o.options.lineWrapping || (p = Aa(o.display) * c.ch);
        var f = Be(o.doc, c.line), m = vr(f) + nd(o.display);
        return { left: p, right: p, top: m, bottom: m + f.height };
      }
      function uf(o, c, p, f, m) {
        var S = Q(o, c, p);
        return S.xRel = m, f && (S.outside = f), S;
      }
      function hf(o, c, p) {
        var f = o.doc;
        if (p += o.display.viewOffset, p < 0)
          return uf(f.first, 0, null, -1, -1);
        var m = G(f, p), S = f.first + f.size - 1;
        if (m > S)
          return uf(f.first + f.size - 1, Be(f, S).text.length, null, 1, 1);
        c < 0 && (c = 0);
        for (var x = Be(f, m); ; ) {
          var k = vA(o, x, m, c, p), D = HR(x, k.ch + (k.xRel > 0 || k.outside > 0 ? 1 : 0));
          if (!D)
            return k;
          var _ = D.find(1);
          if (_.line == m)
            return _;
          x = Be(f, m = _.line);
        }
      }
      function F0(o, c, p, f) {
        f -= df(c);
        var m = c.text.length, S = Pt(function(x) {
          return Ki(o, p, x - 1).bottom <= f;
        }, m, 0);
        return m = Pt(function(x) {
          return Ki(o, p, x).top > f;
        }, S, m), { begin: S, end: m };
      }
      function U0(o, c, p, f) {
        p || (p = Pa(o, c));
        var m = id(o, c, Ki(o, p, f), "line").top;
        return F0(o, c, p, m);
      }
      function ff(o, c, p, f) {
        return o.bottom <= p ? false : o.top > p ? true : (f ? o.left : o.right) > c;
      }
      function vA(o, c, p, f, m) {
        m -= vr(c);
        var S = Pa(o, c), x = df(c), k = 0, D = c.text.length, _ = true, z = tt(c, o.doc.direction);
        if (z) {
          var W = (o.options.lineWrapping ? SA : yA)(o, c, p, S, z, f, m);
          _ = W.level != 1, k = _ ? W.from : W.to - 1, D = _ ? W.to : W.from - 1;
        }
        var K = null, J = null, ee = Pt(function(Ge) {
          var Ue = Ki(o, S, Ge);
          return Ue.top += x, Ue.bottom += x, ff(Ue, f, m, false) ? (Ue.top <= m && Ue.left <= f && (K = Ge, J = Ue), true) : false;
        }, k, D), le, pe, Se = false;
        if (J) {
          var Te = f - J.left < J.right - f, be = Te == _;
          ee = K + (be ? 0 : 1), pe = be ? "after" : "before", le = Te ? J.left : J.right;
        } else {
          !_ && (ee == D || ee == k) && ee++, pe = ee == 0 ? "after" : ee == c.text.length ? "before" : Ki(o, S, ee - (_ ? 1 : 0)).bottom + x <= m == _ ? "after" : "before";
          var Ie = Ai(o, Q(p, ee, pe), "line", c, S);
          le = Ie.left, Se = m < Ie.top ? -1 : m >= Ie.bottom ? 1 : 0;
        }
        return ee = _t(c.text, ee, 1), uf(p, ee, pe, Se, f - le);
      }
      function yA(o, c, p, f, m, S, x) {
        var k = Pt(function(W) {
          var K = m[W], J = K.level != 1;
          return ff(Ai(
            o,
            Q(p, J ? K.to : K.from, J ? "before" : "after"),
            "line",
            c,
            f
          ), S, x, true);
        }, 0, m.length - 1), D = m[k];
        if (k > 0) {
          var _ = D.level != 1, z = Ai(
            o,
            Q(p, _ ? D.from : D.to, _ ? "after" : "before"),
            "line",
            c,
            f
          );
          ff(z, S, x, true) && z.top > x && (D = m[k - 1]);
        }
        return D;
      }
      function SA(o, c, p, f, m, S, x) {
        var k = F0(o, c, f, x), D = k.begin, _ = k.end;
        /\s/.test(c.text.charAt(_ - 1)) && _--;
        for (var z = null, W = null, K = 0; K < m.length; K++) {
          var J = m[K];
          if (!(J.from >= _ || J.to <= D)) {
            var ee = J.level != 1, le = Ki(o, f, ee ? Math.min(_, J.to) - 1 : Math.max(D, J.from)).right, pe = le < S ? S - le + 1e9 : le - S;
            (!z || W > pe) && (z = J, W = pe);
          }
        }
        return z || (z = m[m.length - 1]), z.from < D && (z = { from: D, to: z.to, level: z.level }), z.to > _ && (z = { from: z.from, to: _, level: z.level }), z;
      }
      var _s;
      function Ra(o) {
        if (o.cachedTextHeight != null)
          return o.cachedTextHeight;
        if (_s == null) {
          _s = B("pre", null, "CodeMirror-line-like");
          for (var c = 0; c < 49; ++c)
            _s.appendChild(document.createTextNode("x")), _s.appendChild(B("br"));
          _s.appendChild(document.createTextNode("x"));
        }
        $(o.measure, _s);
        var p = _s.offsetHeight / 50;
        return p > 3 && (o.cachedTextHeight = p), V(o.measure), p || 1;
      }
      function Aa(o) {
        if (o.cachedCharWidth != null)
          return o.cachedCharWidth;
        var c = B("span", "xxxxxxxxxx"), p = B("pre", [c], "CodeMirror-line-like");
        $(o.measure, p);
        var f = c.getBoundingClientRect(), m = (f.right - f.left) / 10;
        return m > 2 && (o.cachedCharWidth = m), m || 10;
      }
      function pf(o) {
        for (var c = o.display, p = {}, f = {}, m = c.gutters.clientLeft, S = c.gutters.firstChild, x = 0; S; S = S.nextSibling, ++x) {
          var k = o.display.gutterSpecs[x].className;
          p[k] = S.offsetLeft + S.clientLeft + m, f[k] = S.clientWidth;
        }
        return {
          fixedPos: gf(c),
          gutterTotalWidth: c.gutters.offsetWidth,
          gutterLeft: p,
          gutterWidth: f,
          wrapperWidth: c.wrapper.clientWidth
        };
      }
      function gf(o) {
        return o.scroller.getBoundingClientRect().left - o.sizer.getBoundingClientRect().left;
      }
      function z0(o) {
        var c = Ra(o.display), p = o.options.lineWrapping, f = p && Math.max(5, o.display.scroller.clientWidth / Aa(o.display) - 3);
        return function(m) {
          if (Zr(o.doc, m))
            return 0;
          var S = 0;
          if (m.widgets)
            for (var x = 0; x < m.widgets.length; x++)
              m.widgets[x].height && (S += m.widgets[x].height);
          return p ? S + (Math.ceil(m.text.length / f) || 1) * c : S + c;
        };
      }
      function mf(o) {
        var c = o.doc, p = z0(o);
        c.iter(function(f) {
          var m = p(f);
          m != f.height && ti(f, m);
        });
      }
      function Ms(o, c, p, f) {
        var m = o.display;
        if (!p && tl(c).getAttribute("cm-not-content") == "true")
          return null;
        var S, x, k = m.lineSpace.getBoundingClientRect();
        try {
          S = c.clientX - k.left, x = c.clientY - k.top;
        } catch {
          return null;
        }
        var D = hf(o, S, x), _;
        if (f && D.xRel > 0 && (_ = Be(o.doc, D.line).text).length == D.ch) {
          var z = qe(_, _.length, o.options.tabSize) - _.length;
          D = Q(D.line, Math.max(0, Math.round((S - D0(o.display).left) / Aa(o.display)) - z));
        }
        return D;
      }
      function Ns(o, c) {
        if (c >= o.display.viewTo || (c -= o.display.viewFrom, c < 0))
          return null;
        for (var p = o.display.view, f = 0; f < p.length; f++)
          if (c -= p[f].size, c < 0)
            return f;
      }
      function Vn(o, c, p, f) {
        c == null && (c = o.doc.first), p == null && (p = o.doc.first + o.doc.size), f || (f = 0);
        var m = o.display;
        if (f && p < m.viewTo && (m.updateLineNumbers == null || m.updateLineNumbers > c) && (m.updateLineNumbers = c), o.curOp.viewChanged = true, c >= m.viewTo)
          mr && nf(o.doc, c) < m.viewTo && es(o);
        else if (p <= m.viewFrom)
          mr && y0(o.doc, p + f) > m.viewFrom ? es(o) : (m.viewFrom += f, m.viewTo += f);
        else if (c <= m.viewFrom && p >= m.viewTo)
          es(o);
        else if (c <= m.viewFrom) {
          var S = sd(o, p, p + f, 1);
          S ? (m.view = m.view.slice(S.index), m.viewFrom = S.lineN, m.viewTo += f) : es(o);
        } else if (p >= m.viewTo) {
          var x = sd(o, c, c, -1);
          x ? (m.view = m.view.slice(0, x.index), m.viewTo = x.lineN) : es(o);
        } else {
          var k = sd(o, c, c, -1), D = sd(o, p, p + f, 1);
          k && D ? (m.view = m.view.slice(0, k.index).concat(td(o, k.lineN, D.lineN)).concat(m.view.slice(D.index)), m.viewTo += f) : es(o);
        }
        var _ = m.externalMeasured;
        _ && (p < _.lineN ? _.lineN += f : c < _.lineN + _.size && (m.externalMeasured = null));
      }
      function Qr(o, c, p) {
        o.curOp.viewChanged = true;
        var f = o.display, m = o.display.externalMeasured;
        if (m && c >= m.lineN && c < m.lineN + m.size && (f.externalMeasured = null), !(c < f.viewFrom || c >= f.viewTo)) {
          var S = f.view[Ns(o, c)];
          if (S.node != null) {
            var x = S.changes || (S.changes = []);
            De(x, p) == -1 && x.push(p);
          }
        }
      }
      function es(o) {
        o.display.viewFrom = o.display.viewTo = o.doc.first, o.display.view = [], o.display.viewOffset = 0;
      }
      function sd(o, c, p, f) {
        var m = Ns(o, c), S, x = o.display.view;
        if (!mr || p == o.doc.first + o.doc.size)
          return { index: m, lineN: p };
        for (var k = o.display.viewFrom, D = 0; D < m; D++)
          k += x[D].size;
        if (k != c) {
          if (f > 0) {
            if (m == x.length - 1)
              return null;
            S = k + x[m].size - c, m++;
          } else
            S = k - c;
          c += S, p += S;
        }
        for (; nf(o.doc, p) != p; ) {
          if (m == (f < 0 ? 0 : x.length - 1))
            return null;
          p += f * x[m - (f < 0 ? 1 : 0)].size, m += f;
        }
        return { index: m, lineN: p };
      }
      function bA(o, c, p) {
        var f = o.display, m = f.view;
        m.length == 0 || c >= f.viewTo || p <= f.viewFrom ? (f.view = td(o, c, p), f.viewFrom = c) : (f.viewFrom > c ? f.view = td(o, c, f.viewFrom).concat(f.view) : f.viewFrom < c && (f.view = f.view.slice(Ns(o, c))), f.viewFrom = c, f.viewTo < p ? f.view = f.view.concat(td(o, f.viewTo, p)) : f.viewTo > p && (f.view = f.view.slice(0, Ns(o, p)))), f.viewTo = p;
      }
      function $0(o) {
        for (var c = o.display.view, p = 0, f = 0; f < c.length; f++) {
          var m = c[f];
          !m.hidden && (!m.node || m.changes) && ++p;
        }
        return p;
      }
      function ul(o) {
        o.display.input.showSelection(o.display.input.prepareSelection());
      }
      function G0(o, c) {
        c === void 0 && (c = true);
        var p = o.doc, f = {}, m = f.cursors = document.createDocumentFragment(), S = f.selection = document.createDocumentFragment(), x = o.options.$customCursor;
        x && (c = true);
        for (var k = 0; k < p.sel.ranges.length; k++)
          if (!(!c && k == p.sel.primIndex)) {
            var D = p.sel.ranges[k];
            if (!(D.from().line >= o.display.viewTo || D.to().line < o.display.viewFrom)) {
              var _ = D.empty();
              if (x) {
                var z = x(o, D);
                z && vf(o, z, m);
              } else (_ || o.options.showCursorWhenSelecting) && vf(o, D.head, m);
              _ || wA(o, D, S);
            }
          }
        return f;
      }
      function vf(o, c, p) {
        var f = Ai(o, c, "div", null, null, !o.options.singleCursorHeightPerLine), m = p.appendChild(B("div", " ", "CodeMirror-cursor"));
        if (m.style.left = f.left + "px", m.style.top = f.top + "px", m.style.height = Math.max(0, f.bottom - f.top) * o.options.cursorHeight + "px", /\bcm-fat-cursor\b/.test(o.getWrapperElement().className)) {
          var S = rd(o, c, "div", null, null), x = S.right - S.left;
          m.style.width = (x > 0 ? x : o.defaultCharWidth()) + "px";
        }
        if (f.other) {
          var k = p.appendChild(B("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
          k.style.display = "", k.style.left = f.other.left + "px", k.style.top = f.other.top + "px", k.style.height = (f.other.bottom - f.other.top) * 0.85 + "px";
        }
      }
      function ad(o, c) {
        return o.top - c.top || o.left - c.left;
      }
      function wA(o, c, p) {
        var f = o.display, m = o.doc, S = document.createDocumentFragment(), x = D0(o.display), k = x.left, D = Math.max(f.sizerWidth, As(o) - f.sizer.offsetLeft) - x.right, _ = m.direction == "ltr";
        function z(be, Ie, Ge, Ue) {
          Ie < 0 && (Ie = 0), Ie = Math.round(Ie), Ue = Math.round(Ue), S.appendChild(B("div", null, "CodeMirror-selected", "position: absolute; left: " + be + `px;
                             top: ` + Ie + "px; width: " + (Ge ?? D - be) + `px;
                             height: ` + (Ue - Ie) + "px"));
        }
        function W(be, Ie, Ge) {
          var Ue = Be(m, be), Qe = Ue.text.length, Et, ln;
          function Mt(Yt, Un) {
            return rd(o, Q(be, Yt), "div", Ue, Un);
          }
          function Yn(Yt, Un, pn) {
            var tn = U0(o, Ue, null, Yt), Xt = Un == "ltr" == (pn == "after") ? "left" : "right", Bt = pn == "after" ? tn.begin : tn.end - (/\s/.test(Ue.text.charAt(tn.end - 1)) ? 2 : 1);
            return Mt(Bt, Xt)[Xt];
          }
          var Fn = tt(Ue, m.direction);
          return ci(Fn, Ie || 0, Ge ?? Qe, function(Yt, Un, pn, tn) {
            var Xt = pn == "ltr", Bt = Mt(Yt, Xt ? "left" : "right"), zn = Mt(Un - 1, Xt ? "right" : "left"), Ha = Ie == null && Yt == 0, as = Ge == null && Un == Qe, Cn = tn == 0, Yi = !Fn || tn == Fn.length - 1;
            if (zn.top - Bt.top <= 3) {
              var cn = (_ ? Ha : as) && Cn, Wf = (_ ? as : Ha) && Yi, wr = cn ? k : (Xt ? Bt : zn).left, Us = Wf ? D : (Xt ? zn : Bt).right;
              z(wr, Bt.top, Us - wr, Bt.bottom);
            } else {
              var zs, Tn, qa, Hf;
              Xt ? (zs = _ && Ha && Cn ? k : Bt.left, Tn = _ ? D : Yn(Yt, pn, "before"), qa = _ ? k : Yn(Un, pn, "after"), Hf = _ && as && Yi ? D : zn.right) : (zs = _ ? Yn(Yt, pn, "before") : k, Tn = !_ && Ha && Cn ? D : Bt.right, qa = !_ && as && Yi ? k : zn.left, Hf = _ ? Yn(Un, pn, "after") : D), z(zs, Bt.top, Tn - zs, Bt.bottom), Bt.bottom < zn.top && z(k, Bt.bottom, null, zn.top), z(qa, zn.top, Hf - qa, zn.bottom);
            }
            (!Et || ad(Bt, Et) < 0) && (Et = Bt), ad(zn, Et) < 0 && (Et = zn), (!ln || ad(Bt, ln) < 0) && (ln = Bt), ad(zn, ln) < 0 && (ln = zn);
          }), { start: Et, end: ln };
        }
        var K = c.from(), J = c.to();
        if (K.line == J.line)
          W(K.line, K.ch, J.ch);
        else {
          var ee = Be(m, K.line), le = Be(m, J.line), pe = Ri(ee) == Ri(le), Se = W(K.line, K.ch, pe ? ee.text.length + 1 : null).end, Te = W(J.line, pe ? 0 : null, J.ch).start;
          pe && (Se.top < Te.top - 2 ? (z(Se.right, Se.top, null, Se.bottom), z(k, Te.top, Te.left, Te.bottom)) : z(Se.right, Se.top, Te.left - Se.right, Se.bottom)), Se.bottom < Te.top && z(k, Se.bottom, null, Te.top);
        }
        p.appendChild(S);
      }
      function yf(o) {
        if (o.state.focused) {
          var c = o.display;
          clearInterval(c.blinker);
          var p = true;
          c.cursorDiv.style.visibility = "", o.options.cursorBlinkRate > 0 ? c.blinker = setInterval(function() {
            o.hasFocus() || _a(o), c.cursorDiv.style.visibility = (p = !p) ? "" : "hidden";
          }, o.options.cursorBlinkRate) : o.options.cursorBlinkRate < 0 && (c.cursorDiv.style.visibility = "hidden");
        }
      }
      function W0(o) {
        o.hasFocus() || (o.display.input.focus(), o.state.focused || bf(o));
      }
      function Sf(o) {
        o.state.delayingBlurEvent = true, setTimeout(function() {
          o.state.delayingBlurEvent && (o.state.delayingBlurEvent = false, o.state.focused && _a(o));
        }, 100);
      }
      function bf(o, c) {
        o.state.delayingBlurEvent && !o.state.draggingText && (o.state.delayingBlurEvent = false), o.options.readOnly != "nocursor" && (o.state.focused || (Nt(o, "focus", o, c), o.state.focused = true, Ee(o.display.wrapper, "CodeMirror-focused"), !o.curOp && o.display.selForContextMenu != o.doc.sel && (o.display.input.reset(), h && setTimeout(function() {
          return o.display.input.reset(true);
        }, 20)), o.display.input.receivedFocus()), yf(o));
      }
      function _a(o, c) {
        o.state.delayingBlurEvent || (o.state.focused && (Nt(o, "blur", o, c), o.state.focused = false, U(o.display.wrapper, "CodeMirror-focused")), clearInterval(o.display.blinker), setTimeout(function() {
          o.state.focused || (o.display.shift = false);
        }, 150));
      }
      function od(o) {
        for (var c = o.display, p = c.lineDiv.offsetTop, f = Math.max(0, c.scroller.getBoundingClientRect().top), m = c.lineDiv.getBoundingClientRect().top, S = 0, x = 0; x < c.view.length; x++) {
          var k = c.view[x], D = o.options.lineWrapping, _ = void 0, z = 0;
          if (!k.hidden) {
            if (m += k.line.height, d && u < 8) {
              var W = k.node.offsetTop + k.node.offsetHeight;
              _ = W - p, p = W;
            } else {
              var K = k.node.getBoundingClientRect();
              _ = K.bottom - K.top, !D && k.text.firstChild && (z = k.text.firstChild.getBoundingClientRect().right - K.left - 1);
            }
            var J = k.line.height - _;
            if ((J > 5e-3 || J < -5e-3) && (m < f && (S -= J), ti(k.line, _), H0(k.line), k.rest))
              for (var ee = 0; ee < k.rest.length; ee++)
                H0(k.rest[ee]);
            if (z > o.display.sizerWidth) {
              var le = Math.ceil(z / Aa(o.display));
              le > o.display.maxLineLength && (o.display.maxLineLength = le, o.display.maxLine = k.line, o.display.maxLineChanged = true);
            }
          }
        }
        Math.abs(S) > 2 && (c.scroller.scrollTop += S);
      }
      function H0(o) {
        if (o.widgets)
          for (var c = 0; c < o.widgets.length; ++c) {
            var p = o.widgets[c], f = p.node.parentNode;
            f && (p.height = f.offsetHeight);
          }
      }
      function ld(o, c, p) {
        var f = p && p.top != null ? Math.max(0, p.top) : o.scroller.scrollTop;
        f = Math.floor(f - nd(o));
        var m = p && p.bottom != null ? p.bottom : f + o.wrapper.clientHeight, S = G(c, f), x = G(c, m);
        if (p && p.ensure) {
          var k = p.ensure.from.line, D = p.ensure.to.line;
          k < S ? (S = k, x = G(c, vr(Be(c, k)) + o.wrapper.clientHeight)) : Math.min(D, c.lastLine()) >= x && (S = G(c, vr(Be(c, D)) - o.wrapper.clientHeight), x = D);
        }
        return { from: S, to: Math.max(x, S + 1) };
      }
      function CA(o, c) {
        if (!Ot(o, "scrollCursorIntoView")) {
          var p = o.display, f = p.sizer.getBoundingClientRect(), m = null, S = p.wrapper.ownerDocument;
          if (c.top + f.top < 0 ? m = true : c.bottom + f.top > (S.defaultView.innerHeight || S.documentElement.clientHeight) && (m = false), m != null && !E) {
            var x = B("div", "​", null, `position: absolute;
                         top: ` + (c.top - p.viewOffset - nd(o.display)) + `px;
                         height: ` + (c.bottom - c.top + Ji(o) + p.barHeight) + `px;
                         left: ` + c.left + "px; width: " + Math.max(2, c.right - c.left) + "px;");
            o.display.lineSpace.appendChild(x), x.scrollIntoView(m), o.display.lineSpace.removeChild(x);
          }
        }
      }
      function xA(o, c, p, f) {
        f == null && (f = 0);
        var m;
        !o.options.lineWrapping && c == p && (p = c.sticky == "before" ? Q(c.line, c.ch + 1, "before") : c, c = c.ch ? Q(c.line, c.sticky == "before" ? c.ch - 1 : c.ch, "after") : c);
        for (var S = 0; S < 5; S++) {
          var x = false, k = Ai(o, c), D = !p || p == c ? k : Ai(o, p);
          m = {
            left: Math.min(k.left, D.left),
            top: Math.min(k.top, D.top) - f,
            right: Math.max(k.left, D.left),
            bottom: Math.max(k.bottom, D.bottom) + f
          };
          var _ = wf(o, m), z = o.doc.scrollTop, W = o.doc.scrollLeft;
          if (_.scrollTop != null && (fl(o, _.scrollTop), Math.abs(o.doc.scrollTop - z) > 1 && (x = true)), _.scrollLeft != null && (Os(o, _.scrollLeft), Math.abs(o.doc.scrollLeft - W) > 1 && (x = true)), !x)
            break;
        }
        return m;
      }
      function EA(o, c) {
        var p = wf(o, c);
        p.scrollTop != null && fl(o, p.scrollTop), p.scrollLeft != null && Os(o, p.scrollLeft);
      }
      function wf(o, c) {
        var p = o.display, f = Ra(o.display);
        c.top < 0 && (c.top = 0);
        var m = o.curOp && o.curOp.scrollTop != null ? o.curOp.scrollTop : p.scroller.scrollTop, S = lf(o), x = {};
        c.bottom - c.top > S && (c.bottom = c.top + S);
        var k = o.doc.height + of(p), D = c.top < f, _ = c.bottom > k - f;
        if (c.top < m)
          x.scrollTop = D ? 0 : c.top;
        else if (c.bottom > m + S) {
          var z = Math.min(c.top, (_ ? k : c.bottom) - S);
          z != m && (x.scrollTop = z);
        }
        var W = o.options.fixedGutter ? 0 : p.gutters.offsetWidth, K = o.curOp && o.curOp.scrollLeft != null ? o.curOp.scrollLeft : p.scroller.scrollLeft - W, J = As(o) - p.gutters.offsetWidth, ee = c.right - c.left > J;
        return ee && (c.right = c.left + J), c.left < 10 ? x.scrollLeft = 0 : c.left < K ? x.scrollLeft = Math.max(0, c.left + W - (ee ? 0 : 10)) : c.right > J + K - 3 && (x.scrollLeft = c.right + (ee ? 0 : 10) - J), x;
      }
      function Cf(o, c) {
        c != null && (cd(o), o.curOp.scrollTop = (o.curOp.scrollTop == null ? o.doc.scrollTop : o.curOp.scrollTop) + c);
      }
      function Ma(o) {
        cd(o);
        var c = o.getCursor();
        o.curOp.scrollToPos = { from: c, to: c, margin: o.options.cursorScrollMargin };
      }
      function hl(o, c, p) {
        (c != null || p != null) && cd(o), c != null && (o.curOp.scrollLeft = c), p != null && (o.curOp.scrollTop = p);
      }
      function kA(o, c) {
        cd(o), o.curOp.scrollToPos = c;
      }
      function cd(o) {
        var c = o.curOp.scrollToPos;
        if (c) {
          o.curOp.scrollToPos = null;
          var p = B0(o, c.from), f = B0(o, c.to);
          q0(o, p, f, c.margin);
        }
      }
      function q0(o, c, p, f) {
        var m = wf(o, {
          left: Math.min(c.left, p.left),
          top: Math.min(c.top, p.top) - f,
          right: Math.max(c.right, p.right),
          bottom: Math.max(c.bottom, p.bottom) + f
        });
        hl(o, m.scrollLeft, m.scrollTop);
      }
      function fl(o, c) {
        Math.abs(o.doc.scrollTop - c) < 2 || (r || Ef(o, { top: c }), j0(o, c, true), r && Ef(o), ml(o, 100));
      }
      function j0(o, c, p) {
        c = Math.max(0, Math.min(o.display.scroller.scrollHeight - o.display.scroller.clientHeight, c)), !(o.display.scroller.scrollTop == c && !p) && (o.doc.scrollTop = c, o.display.scrollbars.setScrollTop(c), o.display.scroller.scrollTop != c && (o.display.scroller.scrollTop = c));
      }
      function Os(o, c, p, f) {
        c = Math.max(0, Math.min(c, o.display.scroller.scrollWidth - o.display.scroller.clientWidth)), !((p ? c == o.doc.scrollLeft : Math.abs(o.doc.scrollLeft - c) < 2) && !f) && (o.doc.scrollLeft = c, Z0(o), o.display.scroller.scrollLeft != c && (o.display.scroller.scrollLeft = c), o.display.scrollbars.setScrollLeft(c));
      }
      function pl(o) {
        var c = o.display, p = c.gutters.offsetWidth, f = Math.round(o.doc.height + of(o.display));
        return {
          clientHeight: c.scroller.clientHeight,
          viewHeight: c.wrapper.clientHeight,
          scrollWidth: c.scroller.scrollWidth,
          clientWidth: c.scroller.clientWidth,
          viewWidth: c.wrapper.clientWidth,
          barLeft: o.options.fixedGutter ? p : 0,
          docHeight: f,
          scrollHeight: f + Ji(o) + c.barHeight,
          nativeBarWidth: c.nativeBarWidth,
          gutterWidth: p
        };
      }
      var Vs = function(o, c, p) {
        this.cm = p;
        var f = this.vert = B("div", [B("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), m = this.horiz = B("div", [B("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        f.tabIndex = m.tabIndex = -1, o(f), o(m), $e(f, "scroll", function() {
          f.clientHeight && c(f.scrollTop, "vertical");
        }), $e(m, "scroll", function() {
          m.clientWidth && c(m.scrollLeft, "horizontal");
        }), this.checkedZeroWidth = false, d && u < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
      };
      Vs.prototype.update = function(o) {
        var c = o.scrollWidth > o.clientWidth + 1, p = o.scrollHeight > o.clientHeight + 1, f = o.nativeBarWidth;
        if (p) {
          this.vert.style.display = "block", this.vert.style.bottom = c ? f + "px" : "0";
          var m = o.viewHeight - (c ? f : 0);
          this.vert.firstChild.style.height = Math.max(0, o.scrollHeight - o.clientHeight + m) + "px";
        } else
          this.vert.scrollTop = 0, this.vert.style.display = "", this.vert.firstChild.style.height = "0";
        if (c) {
          this.horiz.style.display = "block", this.horiz.style.right = p ? f + "px" : "0", this.horiz.style.left = o.barLeft + "px";
          var S = o.viewWidth - o.barLeft - (p ? f : 0);
          this.horiz.firstChild.style.width = Math.max(0, o.scrollWidth - o.clientWidth + S) + "px";
        } else
          this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
        return !this.checkedZeroWidth && o.clientHeight > 0 && (f == 0 && this.zeroWidthHack(), this.checkedZeroWidth = true), { right: p ? f : 0, bottom: c ? f : 0 };
      }, Vs.prototype.setScrollLeft = function(o) {
        this.horiz.scrollLeft != o && (this.horiz.scrollLeft = o), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
      }, Vs.prototype.setScrollTop = function(o) {
        this.vert.scrollTop != o && (this.vert.scrollTop = o), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
      }, Vs.prototype.zeroWidthHack = function() {
        var o = P && !b ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = o, this.horiz.style.visibility = this.vert.style.visibility = "hidden", this.disableHoriz = new We(), this.disableVert = new We();
      }, Vs.prototype.enableZeroWidthBar = function(o, c, p) {
        o.style.visibility = "";
        function f() {
          var m = o.getBoundingClientRect(), S = p == "vert" ? document.elementFromPoint(m.right - 1, (m.top + m.bottom) / 2) : document.elementFromPoint((m.right + m.left) / 2, m.bottom - 1);
          S != o ? o.style.visibility = "hidden" : c.set(1e3, f);
        }
        c.set(1e3, f);
      }, Vs.prototype.clear = function() {
        var o = this.horiz.parentNode;
        o.removeChild(this.horiz), o.removeChild(this.vert);
      };
      var gl = function() {
      };
      gl.prototype.update = function() {
        return { bottom: 0, right: 0 };
      }, gl.prototype.setScrollLeft = function() {
      }, gl.prototype.setScrollTop = function() {
      }, gl.prototype.clear = function() {
      };
      function Na(o, c) {
        c || (c = pl(o));
        var p = o.display.barWidth, f = o.display.barHeight;
        J0(o, c);
        for (var m = 0; m < 4 && p != o.display.barWidth || f != o.display.barHeight; m++)
          p != o.display.barWidth && o.options.lineWrapping && od(o), J0(o, pl(o)), p = o.display.barWidth, f = o.display.barHeight;
      }
      function J0(o, c) {
        var p = o.display, f = p.scrollbars.update(c);
        p.sizer.style.paddingRight = (p.barWidth = f.right) + "px", p.sizer.style.paddingBottom = (p.barHeight = f.bottom) + "px", p.heightForcer.style.borderBottom = f.bottom + "px solid transparent", f.right && f.bottom ? (p.scrollbarFiller.style.display = "block", p.scrollbarFiller.style.height = f.bottom + "px", p.scrollbarFiller.style.width = f.right + "px") : p.scrollbarFiller.style.display = "", f.bottom && o.options.coverGutterNextToScrollbar && o.options.fixedGutter ? (p.gutterFiller.style.display = "block", p.gutterFiller.style.height = f.bottom + "px", p.gutterFiller.style.width = c.gutterWidth + "px") : p.gutterFiller.style.display = "";
      }
      var K0 = { native: Vs, null: gl };
      function Y0(o) {
        o.display.scrollbars && (o.display.scrollbars.clear(), o.display.scrollbars.addClass && U(o.display.wrapper, o.display.scrollbars.addClass)), o.display.scrollbars = new K0[o.options.scrollbarStyle](function(c) {
          o.display.wrapper.insertBefore(c, o.display.scrollbarFiller), $e(c, "mousedown", function() {
            o.state.focused && setTimeout(function() {
              return o.display.input.focus();
            }, 0);
          }), c.setAttribute("cm-not-content", "true");
        }, function(c, p) {
          p == "horizontal" ? Os(o, c) : fl(o, c);
        }, o), o.display.scrollbars.addClass && Ee(o.display.wrapper, o.display.scrollbars.addClass);
      }
      var TA = 0;
      function Bs(o) {
        o.curOp = {
          cm: o,
          viewChanged: false,
          // Flag that indicates that lines might need to be redrawn
          startHeight: o.doc.height,
          // Used to detect need to update scrollbar
          forceUpdate: false,
          // Used to force a redraw
          updateInput: 0,
          // Whether to reset the input textarea
          typing: false,
          // Whether this reset should be careful to leave existing text (for compositing)
          changeObjs: null,
          // Accumulated changes, for firing change events
          cursorActivityHandlers: null,
          // Set of handlers to fire cursorActivity on
          cursorActivityCalled: 0,
          // Tracks which cursorActivity handlers have been called already
          selectionChanged: false,
          // Whether the selection needs to be redrawn
          updateMaxLine: false,
          // Set when the widest line needs to be determined anew
          scrollLeft: null,
          scrollTop: null,
          // Intermediate scroll position, not pushed to DOM yet
          scrollToPos: null,
          // Used to scroll to a specific position
          focus: false,
          id: ++TA,
          // Unique ID
          markArrays: null
          // Used by addMarkedSpan
        }, iA(o.curOp);
      }
      function Fs(o) {
        var c = o.curOp;
        c && sA(c, function(p) {
          for (var f = 0; f < p.ops.length; f++)
            p.ops[f].cm.curOp = null;
          LA(p);
        });
      }
      function LA(o) {
        for (var c = o.ops, p = 0; p < c.length; p++)
          DA(c[p]);
        for (var f = 0; f < c.length; f++)
          IA(c[f]);
        for (var m = 0; m < c.length; m++)
          PA(c[m]);
        for (var S = 0; S < c.length; S++)
          RA(c[S]);
        for (var x = 0; x < c.length; x++)
          AA(c[x]);
      }
      function DA(o) {
        var c = o.cm, p = c.display;
        MA(c), o.updateMaxLine && sf(c), o.mustUpdate = o.viewChanged || o.forceUpdate || o.scrollTop != null || o.scrollToPos && (o.scrollToPos.from.line < p.viewFrom || o.scrollToPos.to.line >= p.viewTo) || p.maxLineChanged && c.options.lineWrapping, o.update = o.mustUpdate && new dd(c, o.mustUpdate && { top: o.scrollTop, ensure: o.scrollToPos }, o.forceUpdate);
      }
      function IA(o) {
        o.updatedDisplay = o.mustUpdate && xf(o.cm, o.update);
      }
      function PA(o) {
        var c = o.cm, p = c.display;
        o.updatedDisplay && od(c), o.barMeasure = pl(c), p.maxLineChanged && !c.options.lineWrapping && (o.adjustWidthTo = P0(c, p.maxLine, p.maxLine.text.length).left + 3, c.display.sizerWidth = o.adjustWidthTo, o.barMeasure.scrollWidth = Math.max(p.scroller.clientWidth, p.sizer.offsetLeft + o.adjustWidthTo + Ji(c) + c.display.barWidth), o.maxScrollLeft = Math.max(0, p.sizer.offsetLeft + o.adjustWidthTo - As(c))), (o.updatedDisplay || o.selectionChanged) && (o.preparedSelection = p.input.prepareSelection());
      }
      function RA(o) {
        var c = o.cm;
        o.adjustWidthTo != null && (c.display.sizer.style.minWidth = o.adjustWidthTo + "px", o.maxScrollLeft < c.doc.scrollLeft && Os(c, Math.min(c.display.scroller.scrollLeft, o.maxScrollLeft), true), c.display.maxLineChanged = false);
        var p = o.focus && o.focus == ae(Me(c));
        o.preparedSelection && c.display.input.showSelection(o.preparedSelection, p), (o.updatedDisplay || o.startHeight != c.doc.height) && Na(c, o.barMeasure), o.updatedDisplay && Tf(c, o.barMeasure), o.selectionChanged && yf(c), c.state.focused && o.updateInput && c.display.input.reset(o.typing), p && W0(o.cm);
      }
      function AA(o) {
        var c = o.cm, p = c.display, f = c.doc;
        if (o.updatedDisplay && X0(c, o.update), p.wheelStartX != null && (o.scrollTop != null || o.scrollLeft != null || o.scrollToPos) && (p.wheelStartX = p.wheelStartY = null), o.scrollTop != null && j0(c, o.scrollTop, o.forceScroll), o.scrollLeft != null && Os(c, o.scrollLeft, true, true), o.scrollToPos) {
          var m = xA(
            c,
            Ke(f, o.scrollToPos.from),
            Ke(f, o.scrollToPos.to),
            o.scrollToPos.margin
          );
          CA(c, m);
        }
        var S = o.maybeHiddenMarkers, x = o.maybeUnhiddenMarkers;
        if (S)
          for (var k = 0; k < S.length; ++k)
            S[k].lines.length || Nt(S[k], "hide");
        if (x)
          for (var D = 0; D < x.length; ++D)
            x[D].lines.length && Nt(x[D], "unhide");
        p.wrapper.offsetHeight && (f.scrollTop = c.display.scroller.scrollTop), o.changeObjs && Nt(c, "changes", c, o.changeObjs), o.update && o.update.finish();
      }
      function Kn(o, c) {
        if (o.curOp)
          return c();
        Bs(o);
        try {
          return c();
        } finally {
          Fs(o);
        }
      }
      function an(o, c) {
        return function() {
          if (o.curOp)
            return c.apply(o, arguments);
          Bs(o);
          try {
            return c.apply(o, arguments);
          } finally {
            Fs(o);
          }
        };
      }
      function kn(o) {
        return function() {
          if (this.curOp)
            return o.apply(this, arguments);
          Bs(this);
          try {
            return o.apply(this, arguments);
          } finally {
            Fs(this);
          }
        };
      }
      function on(o) {
        return function() {
          var c = this.cm;
          if (!c || c.curOp)
            return o.apply(this, arguments);
          Bs(c);
          try {
            return o.apply(this, arguments);
          } finally {
            Fs(c);
          }
        };
      }
      function ml(o, c) {
        o.doc.highlightFrontier < o.display.viewTo && o.state.highlight.set(c, Re(_A, o));
      }
      function _A(o) {
        var c = o.doc;
        if (!(c.highlightFrontier >= o.display.viewTo)) {
          var p = +/* @__PURE__ */ new Date() + o.options.workTime, f = sl(o, c.highlightFrontier), m = [];
          c.iter(f.line, Math.min(c.first + c.size, o.display.viewTo + 500), function(S) {
            if (f.line >= o.display.viewFrom) {
              var x = S.styles, k = S.text.length > o.options.maxHighlightLength ? qi(c.mode, f.state) : null, D = r0(o, S, f, true);
              k && (f.state = k), S.styles = D.styles;
              var _ = S.styleClasses, z = D.classes;
              z ? S.styleClasses = z : _ && (S.styleClasses = null);
              for (var W = !x || x.length != S.styles.length || _ != z && (!_ || !z || _.bgClass != z.bgClass || _.textClass != z.textClass), K = 0; !W && K < x.length; ++K)
                W = x[K] != S.styles[K];
              W && m.push(f.line), S.stateAfter = f.save(), f.nextLine();
            } else
              S.text.length <= o.options.maxHighlightLength && Zh(o, S.text, f), S.stateAfter = f.line % 5 == 0 ? f.save() : null, f.nextLine();
            if (+/* @__PURE__ */ new Date() > p)
              return ml(o, o.options.workDelay), true;
          }), c.highlightFrontier = f.line, c.modeFrontier = Math.max(c.modeFrontier, f.line), m.length && Kn(o, function() {
            for (var S = 0; S < m.length; S++)
              Qr(o, m[S], "text");
          });
        }
      }
      var dd = function(o, c, p) {
        var f = o.display;
        this.viewport = c, this.visible = ld(f, o.doc, c), this.editorIsHidden = !f.wrapper.offsetWidth, this.wrapperHeight = f.wrapper.clientHeight, this.wrapperWidth = f.wrapper.clientWidth, this.oldDisplayWidth = As(o), this.force = p, this.dims = pf(o), this.events = [];
      };
      dd.prototype.signal = function(o, c) {
        Jn(o, c) && this.events.push(arguments);
      }, dd.prototype.finish = function() {
        for (var o = 0; o < this.events.length; o++)
          Nt.apply(null, this.events[o]);
      };
      function MA(o) {
        var c = o.display;
        !c.scrollbarsClipped && c.scroller.offsetWidth && (c.nativeBarWidth = c.scroller.offsetWidth - c.scroller.clientWidth, c.heightForcer.style.height = Ji(o) + "px", c.sizer.style.marginBottom = -c.nativeBarWidth + "px", c.sizer.style.borderRightWidth = Ji(o) + "px", c.scrollbarsClipped = true);
      }
      function NA(o) {
        if (o.hasFocus())
          return null;
        var c = ae(Me(o));
        if (!c || !Pe(o.display.lineDiv, c))
          return null;
        var p = { activeElt: c };
        if (window.getSelection) {
          var f = Oe(o).getSelection();
          f.anchorNode && f.extend && Pe(o.display.lineDiv, f.anchorNode) && (p.anchorNode = f.anchorNode, p.anchorOffset = f.anchorOffset, p.focusNode = f.focusNode, p.focusOffset = f.focusOffset);
        }
        return p;
      }
      function OA(o) {
        if (!(!o || !o.activeElt || o.activeElt == ae(je(o.activeElt))) && (o.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(o.activeElt.nodeName) && o.anchorNode && Pe(document.body, o.anchorNode) && Pe(document.body, o.focusNode))) {
          var c = o.activeElt.ownerDocument, p = c.defaultView.getSelection(), f = c.createRange();
          f.setEnd(o.anchorNode, o.anchorOffset), f.collapse(false), p.removeAllRanges(), p.addRange(f), p.extend(o.focusNode, o.focusOffset);
        }
      }
      function xf(o, c) {
        var p = o.display, f = o.doc;
        if (c.editorIsHidden)
          return es(o), false;
        if (!c.force && c.visible.from >= p.viewFrom && c.visible.to <= p.viewTo && (p.updateLineNumbers == null || p.updateLineNumbers >= p.viewTo) && p.renderedView == p.view && $0(o) == 0)
          return false;
        Q0(o) && (es(o), c.dims = pf(o));
        var m = f.first + f.size, S = Math.max(c.visible.from - o.options.viewportMargin, f.first), x = Math.min(m, c.visible.to + o.options.viewportMargin);
        p.viewFrom < S && S - p.viewFrom < 20 && (S = Math.max(f.first, p.viewFrom)), p.viewTo > x && p.viewTo - x < 20 && (x = Math.min(m, p.viewTo)), mr && (S = nf(o.doc, S), x = y0(o.doc, x));
        var k = S != p.viewFrom || x != p.viewTo || p.lastWrapHeight != c.wrapperHeight || p.lastWrapWidth != c.wrapperWidth;
        bA(o, S, x), p.viewOffset = vr(Be(o.doc, p.viewFrom)), o.display.mover.style.top = p.viewOffset + "px";
        var D = $0(o);
        if (!k && D == 0 && !c.force && p.renderedView == p.view && (p.updateLineNumbers == null || p.updateLineNumbers >= p.viewTo))
          return false;
        var _ = NA(o);
        return D > 4 && (p.lineDiv.style.display = "none"), VA(o, p.updateLineNumbers, c.dims), D > 4 && (p.lineDiv.style.display = ""), p.renderedView = p.view, OA(_), V(p.cursorDiv), V(p.selectionDiv), p.gutters.style.height = p.sizer.style.minHeight = 0, k && (p.lastWrapHeight = c.wrapperHeight, p.lastWrapWidth = c.wrapperWidth, ml(o, 400)), p.updateLineNumbers = null, true;
      }
      function X0(o, c) {
        for (var p = c.viewport, f = true; ; f = false) {
          if (!f || !o.options.lineWrapping || c.oldDisplayWidth == As(o)) {
            if (p && p.top != null && (p = { top: Math.min(o.doc.height + of(o.display) - lf(o), p.top) }), c.visible = ld(o.display, o.doc, p), c.visible.from >= o.display.viewFrom && c.visible.to <= o.display.viewTo)
              break;
          } else f && (c.visible = ld(o.display, o.doc, p));
          if (!xf(o, c))
            break;
          od(o);
          var m = pl(o);
          ul(o), Na(o, m), Tf(o, m), c.force = false;
        }
        c.signal(o, "update", o), (o.display.viewFrom != o.display.reportedViewFrom || o.display.viewTo != o.display.reportedViewTo) && (c.signal(o, "viewportChange", o, o.display.viewFrom, o.display.viewTo), o.display.reportedViewFrom = o.display.viewFrom, o.display.reportedViewTo = o.display.viewTo);
      }
      function Ef(o, c) {
        var p = new dd(o, c);
        if (xf(o, p)) {
          od(o), X0(o, p);
          var f = pl(o);
          ul(o), Na(o, f), Tf(o, f), p.finish();
        }
      }
      function VA(o, c, p) {
        var f = o.display, m = o.options.lineNumbers, S = f.lineDiv, x = S.firstChild;
        function k(ee) {
          var le = ee.nextSibling;
          return h && P && o.display.currentWheelTarget == ee ? ee.style.display = "none" : ee.parentNode.removeChild(ee), le;
        }
        for (var D = f.view, _ = f.viewFrom, z = 0; z < D.length; z++) {
          var W = D[z];
          if (!W.hidden) if (!W.node || W.node.parentNode != S) {
            var K = dA(o, W, _, p);
            S.insertBefore(K, x);
          } else {
            for (; x != W.node; )
              x = k(x);
            var J = m && c != null && c <= _ && W.lineNumber;
            W.changes && (De(W.changes, "gutter") > -1 && (J = false), x0(o, W, _, p)), J && (V(W.lineNumber), W.lineNumber.appendChild(document.createTextNode(fe(o.options, _)))), x = W.node.nextSibling;
          }
          _ += W.size;
        }
        for (; x; )
          x = k(x);
      }
      function kf(o) {
        var c = o.gutters.offsetWidth;
        o.sizer.style.marginLeft = c + "px", sn(o, "gutterChanged", o);
      }
      function Tf(o, c) {
        o.display.sizer.style.minHeight = c.docHeight + "px", o.display.heightForcer.style.top = c.docHeight + "px", o.display.gutters.style.height = c.docHeight + o.display.barHeight + Ji(o) + "px";
      }
      function Z0(o) {
        var c = o.display, p = c.view;
        if (!(!c.alignWidgets && (!c.gutters.firstChild || !o.options.fixedGutter))) {
          for (var f = gf(c) - c.scroller.scrollLeft + o.doc.scrollLeft, m = c.gutters.offsetWidth, S = f + "px", x = 0; x < p.length; x++)
            if (!p[x].hidden) {
              o.options.fixedGutter && (p[x].gutter && (p[x].gutter.style.left = S), p[x].gutterBackground && (p[x].gutterBackground.style.left = S));
              var k = p[x].alignable;
              if (k)
                for (var D = 0; D < k.length; D++)
                  k[D].style.left = S;
            }
          o.options.fixedGutter && (c.gutters.style.left = f + m + "px");
        }
      }
      function Q0(o) {
        if (!o.options.lineNumbers)
          return false;
        var c = o.doc, p = fe(o.options, c.first + c.size - 1), f = o.display;
        if (p.length != f.lineNumChars) {
          var m = f.measure.appendChild(B(
            "div",
            [B("div", p)],
            "CodeMirror-linenumber CodeMirror-gutter-elt"
          )), S = m.firstChild.offsetWidth, x = m.offsetWidth - S;
          return f.lineGutter.style.width = "", f.lineNumInnerWidth = Math.max(S, f.lineGutter.offsetWidth - x) + 1, f.lineNumWidth = f.lineNumInnerWidth + x, f.lineNumChars = f.lineNumInnerWidth ? p.length : -1, f.lineGutter.style.width = f.lineNumWidth + "px", kf(o.display), true;
        }
        return false;
      }
      function Lf(o, c) {
        for (var p = [], f = false, m = 0; m < o.length; m++) {
          var S = o[m], x = null;
          if (typeof S != "string" && (x = S.style, S = S.className), S == "CodeMirror-linenumbers")
            if (c)
              f = true;
            else
              continue;
          p.push({ className: S, style: x });
        }
        return c && !f && p.push({ className: "CodeMirror-linenumbers", style: null }), p;
      }
      function eb(o) {
        var c = o.gutters, p = o.gutterSpecs;
        V(c), o.lineGutter = null;
        for (var f = 0; f < p.length; ++f) {
          var m = p[f], S = m.className, x = m.style, k = c.appendChild(B("div", null, "CodeMirror-gutter " + S));
          x && (k.style.cssText = x), S == "CodeMirror-linenumbers" && (o.lineGutter = k, k.style.width = (o.lineNumWidth || 1) + "px");
        }
        c.style.display = p.length ? "" : "none", kf(o);
      }
      function vl(o) {
        eb(o.display), Vn(o), Z0(o);
      }
      function BA(o, c, p, f) {
        var m = this;
        this.input = p, m.scrollbarFiller = B("div", null, "CodeMirror-scrollbar-filler"), m.scrollbarFiller.setAttribute("cm-not-content", "true"), m.gutterFiller = B("div", null, "CodeMirror-gutter-filler"), m.gutterFiller.setAttribute("cm-not-content", "true"), m.lineDiv = ue("div", null, "CodeMirror-code"), m.selectionDiv = B("div", null, null, "position: relative; z-index: 1"), m.cursorDiv = B("div", null, "CodeMirror-cursors"), m.measure = B("div", null, "CodeMirror-measure"), m.lineMeasure = B("div", null, "CodeMirror-measure"), m.lineSpace = ue(
          "div",
          [m.measure, m.lineMeasure, m.selectionDiv, m.cursorDiv, m.lineDiv],
          null,
          "position: relative; outline: none"
        );
        var S = ue("div", [m.lineSpace], "CodeMirror-lines");
        m.mover = B("div", [S], null, "position: relative"), m.sizer = B("div", [m.mover], "CodeMirror-sizer"), m.sizerWidth = null, m.heightForcer = B("div", null, null, "position: absolute; height: " + et + "px; width: 1px;"), m.gutters = B("div", null, "CodeMirror-gutters"), m.lineGutter = null, m.scroller = B("div", [m.sizer, m.heightForcer, m.gutters], "CodeMirror-scroll"), m.scroller.setAttribute("tabIndex", "-1"), m.wrapper = B("div", [m.scrollbarFiller, m.gutterFiller, m.scroller], "CodeMirror"), v && y >= 105 && (m.wrapper.style.clipPath = "inset(0px)"), m.wrapper.setAttribute("translate", "no"), d && u < 8 && (m.gutters.style.zIndex = -1, m.scroller.style.paddingRight = 0), !h && !(r && R) && (m.scroller.draggable = true), o && (o.appendChild ? o.appendChild(m.wrapper) : o(m.wrapper)), m.viewFrom = m.viewTo = c.first, m.reportedViewFrom = m.reportedViewTo = c.first, m.view = [], m.renderedView = null, m.externalMeasured = null, m.viewOffset = 0, m.lastWrapHeight = m.lastWrapWidth = 0, m.updateLineNumbers = null, m.nativeBarWidth = m.barHeight = m.barWidth = 0, m.scrollbarsClipped = false, m.lineNumWidth = m.lineNumInnerWidth = m.lineNumChars = null, m.alignWidgets = false, m.cachedCharWidth = m.cachedTextHeight = m.cachedPaddingH = null, m.maxLine = null, m.maxLineLength = 0, m.maxLineChanged = false, m.wheelDX = m.wheelDY = m.wheelStartX = m.wheelStartY = null, m.shift = false, m.selForContextMenu = null, m.activeTouch = null, m.gutterSpecs = Lf(f.gutters, f.lineNumbers), eb(m), p.init(m);
      }
      var ud = 0, Sr = null;
      d ? Sr = -0.53 : r ? Sr = 15 : v ? Sr = -0.7 : w && (Sr = -1 / 3);
      function tb(o) {
        var c = o.wheelDeltaX, p = o.wheelDeltaY;
        return c == null && o.detail && o.axis == o.HORIZONTAL_AXIS && (c = o.detail), p == null && o.detail && o.axis == o.VERTICAL_AXIS ? p = o.detail : p == null && (p = o.wheelDelta), { x: c, y: p };
      }
      function FA(o) {
        var c = tb(o);
        return c.x *= Sr, c.y *= Sr, c;
      }
      function nb(o, c) {
        v && y == 102 && (o.display.chromeScrollHack == null ? o.display.sizer.style.pointerEvents = "none" : clearTimeout(o.display.chromeScrollHack), o.display.chromeScrollHack = setTimeout(function() {
          o.display.chromeScrollHack = null, o.display.sizer.style.pointerEvents = "";
        }, 100));
        var p = tb(c), f = p.x, m = p.y, S = Sr;
        c.deltaMode === 0 && (f = c.deltaX, m = c.deltaY, S = 1);
        var x = o.display, k = x.scroller, D = k.scrollWidth > k.clientWidth, _ = k.scrollHeight > k.clientHeight;
        if (f && D || m && _) {
          if (m && P && h) {
            e: for (var z = c.target, W = x.view; z != k; z = z.parentNode)
              for (var K = 0; K < W.length; K++)
                if (W[K].node == z) {
                  o.display.currentWheelTarget = z;
                  break e;
                }
          }
          if (f && !r && !C && S != null) {
            m && _ && fl(o, Math.max(0, k.scrollTop + m * S)), Os(o, Math.max(0, k.scrollLeft + f * S)), (!m || m && _) && bn(c), x.wheelStartX = null;
            return;
          }
          if (m && S != null) {
            var J = m * S, ee = o.doc.scrollTop, le = ee + x.wrapper.clientHeight;
            J < 0 ? ee = Math.max(0, ee + J - 50) : le = Math.min(o.doc.height, le + J + 50), Ef(o, { top: ee, bottom: le });
          }
          ud < 20 && c.deltaMode !== 0 && (x.wheelStartX == null ? (x.wheelStartX = k.scrollLeft, x.wheelStartY = k.scrollTop, x.wheelDX = f, x.wheelDY = m, setTimeout(function() {
            if (x.wheelStartX != null) {
              var pe = k.scrollLeft - x.wheelStartX, Se = k.scrollTop - x.wheelStartY, Te = Se && x.wheelDY && Se / x.wheelDY || pe && x.wheelDX && pe / x.wheelDX;
              x.wheelStartX = x.wheelStartY = null, Te && (Sr = (Sr * ud + Te) / (ud + 1), ++ud);
            }
          }, 200)) : (x.wheelDX += f, x.wheelDY += m));
        }
      }
      var ni = function(o, c) {
        this.ranges = o, this.primIndex = c;
      };
      ni.prototype.primary = function() {
        return this.ranges[this.primIndex];
      }, ni.prototype.equals = function(o) {
        if (o == this)
          return true;
        if (o.primIndex != this.primIndex || o.ranges.length != this.ranges.length)
          return false;
        for (var c = 0; c < this.ranges.length; c++) {
          var p = this.ranges[c], f = o.ranges[c];
          if (!ut(p.anchor, f.anchor) || !ut(p.head, f.head))
            return false;
        }
        return true;
      }, ni.prototype.deepCopy = function() {
        for (var o = [], c = 0; c < this.ranges.length; c++)
          o[c] = new ht(rn(this.ranges[c].anchor), rn(this.ranges[c].head));
        return new ni(o, this.primIndex);
      }, ni.prototype.somethingSelected = function() {
        for (var o = 0; o < this.ranges.length; o++)
          if (!this.ranges[o].empty())
            return true;
        return false;
      }, ni.prototype.contains = function(o, c) {
        c || (c = o);
        for (var p = 0; p < this.ranges.length; p++) {
          var f = this.ranges[p];
          if (we(c, f.from()) >= 0 && we(o, f.to()) <= 0)
            return p;
        }
        return -1;
      };
      var ht = function(o, c) {
        this.anchor = o, this.head = c;
      };
      ht.prototype.from = function() {
        return La(this.anchor, this.head);
      }, ht.prototype.to = function() {
        return On(this.anchor, this.head);
      }, ht.prototype.empty = function() {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
      };
      function _i(o, c, p) {
        var f = o && o.options.selectionsMayTouch, m = c[p];
        c.sort(function(K, J) {
          return we(K.from(), J.from());
        }), p = De(c, m);
        for (var S = 1; S < c.length; S++) {
          var x = c[S], k = c[S - 1], D = we(k.to(), x.from());
          if (f && !x.empty() ? D > 0 : D >= 0) {
            var _ = La(k.from(), x.from()), z = On(k.to(), x.to()), W = k.empty() ? x.from() == x.head : k.from() == k.head;
            S <= p && --p, c.splice(--S, 2, new ht(W ? z : _, W ? _ : z));
          }
        }
        return new ni(c, p);
      }
      function ts(o, c) {
        return new ni([new ht(o, c || o)], 0);
      }
      function ns(o) {
        return o.text ? Q(
          o.from.line + o.text.length - 1,
          ye(o.text).length + (o.text.length == 1 ? o.from.ch : 0)
        ) : o.to;
      }
      function ib(o, c) {
        if (we(o, c.from) < 0)
          return o;
        if (we(o, c.to) <= 0)
          return ns(c);
        var p = o.line + c.text.length - (c.to.line - c.from.line) - 1, f = o.ch;
        return o.line == c.to.line && (f += ns(c).ch - c.to.ch), Q(p, f);
      }
      function Df(o, c) {
        for (var p = [], f = 0; f < o.sel.ranges.length; f++) {
          var m = o.sel.ranges[f];
          p.push(new ht(
            ib(m.anchor, c),
            ib(m.head, c)
          ));
        }
        return _i(o.cm, p, o.sel.primIndex);
      }
      function rb(o, c, p) {
        return o.line == c.line ? Q(p.line, o.ch - c.ch + p.ch) : Q(p.line + (o.line - c.line), o.ch);
      }
      function UA(o, c, p) {
        for (var f = [], m = Q(o.first, 0), S = m, x = 0; x < c.length; x++) {
          var k = c[x], D = rb(k.from, m, S), _ = rb(ns(k), m, S);
          if (m = k.to, S = _, p == "around") {
            var z = o.sel.ranges[x], W = we(z.head, z.anchor) < 0;
            f[x] = new ht(W ? _ : D, W ? D : _);
          } else
            f[x] = new ht(D, D);
        }
        return new ni(f, o.sel.primIndex);
      }
      function If(o) {
        o.doc.mode = Ea(o.options, o.doc.modeOption), yl(o);
      }
      function yl(o) {
        o.doc.iter(function(c) {
          c.stateAfter && (c.stateAfter = null), c.styles && (c.styles = null);
        }), o.doc.modeFrontier = o.doc.highlightFrontier = o.doc.first, ml(o, 100), o.state.modeGen++, o.curOp && Vn(o);
      }
      function sb(o, c) {
        return c.from.ch == 0 && c.to.ch == 0 && ye(c.text) == "" && (!o.cm || o.cm.options.wholeLineUpdateBefore);
      }
      function Pf(o, c, p, f) {
        function m(Te) {
          return p ? p[Te] : null;
        }
        function S(Te, be, Ie) {
          JR(Te, be, Ie, f), sn(Te, "change", Te, c);
        }
        function x(Te, be) {
          for (var Ie = [], Ge = Te; Ge < be; ++Ge)
            Ie.push(new Da(_[Ge], m(Ge), f));
          return Ie;
        }
        var k = c.from, D = c.to, _ = c.text, z = Be(o, k.line), W = Be(o, D.line), K = ye(_), J = m(_.length - 1), ee = D.line - k.line;
        if (c.full)
          o.insert(0, x(0, _.length)), o.remove(_.length, o.size - _.length);
        else if (sb(o, c)) {
          var le = x(0, _.length - 1);
          S(W, W.text, J), ee && o.remove(k.line, ee), le.length && o.insert(k.line, le);
        } else if (z == W)
          if (_.length == 1)
            S(z, z.text.slice(0, k.ch) + K + z.text.slice(D.ch), J);
          else {
            var pe = x(1, _.length - 1);
            pe.push(new Da(K + z.text.slice(D.ch), J, f)), S(z, z.text.slice(0, k.ch) + _[0], m(0)), o.insert(k.line + 1, pe);
          }
        else if (_.length == 1)
          S(z, z.text.slice(0, k.ch) + _[0] + W.text.slice(D.ch), m(0)), o.remove(k.line + 1, ee);
        else {
          S(z, z.text.slice(0, k.ch) + _[0], m(0)), S(W, K + W.text.slice(D.ch), J);
          var Se = x(1, _.length - 1);
          ee > 1 && o.remove(k.line + 1, ee - 1), o.insert(k.line + 1, Se);
        }
        sn(o, "change", o, c);
      }
      function is(o, c, p) {
        function f(m, S, x) {
          if (m.linked)
            for (var k = 0; k < m.linked.length; ++k) {
              var D = m.linked[k];
              if (D.doc != S) {
                var _ = x && D.sharedHist;
                p && !_ || (c(D.doc, _), f(D.doc, m, _));
              }
            }
        }
        f(o, null, true);
      }
      function ab(o, c) {
        if (c.cm)
          throw new Error("This document is already in use.");
        o.doc = c, c.cm = o, mf(o), If(o), ob(o), o.options.direction = c.direction, o.options.lineWrapping || sf(o), o.options.mode = c.modeOption, Vn(o);
      }
      function ob(o) {
        (o.doc.direction == "rtl" ? Ee : U)(o.display.lineDiv, "CodeMirror-rtl");
      }
      function zA(o) {
        Kn(o, function() {
          ob(o), Vn(o);
        });
      }
      function hd(o) {
        this.done = [], this.undone = [], this.undoDepth = o ? o.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = o ? o.maxGeneration : 1;
      }
      function Rf(o, c) {
        var p = { from: rn(c.from), to: ns(c), text: gr(o, c.from, c.to) };
        return db(o, p, c.from.line, c.to.line + 1), is(o, function(f) {
          return db(f, p, c.from.line, c.to.line + 1);
        }, true), p;
      }
      function lb(o) {
        for (; o.length; ) {
          var c = ye(o);
          if (c.ranges)
            o.pop();
          else
            break;
        }
      }
      function $A(o, c) {
        if (c)
          return lb(o.done), ye(o.done);
        if (o.done.length && !ye(o.done).ranges)
          return ye(o.done);
        if (o.done.length > 1 && !o.done[o.done.length - 2].ranges)
          return o.done.pop(), ye(o.done);
      }
      function cb(o, c, p, f) {
        var m = o.history;
        m.undone.length = 0;
        var S = +/* @__PURE__ */ new Date(), x, k;
        if ((m.lastOp == f || m.lastOrigin == c.origin && c.origin && (c.origin.charAt(0) == "+" && m.lastModTime > S - (o.cm ? o.cm.options.historyEventDelay : 500) || c.origin.charAt(0) == "*")) && (x = $A(m, m.lastOp == f)))
          k = ye(x.changes), we(c.from, c.to) == 0 && we(c.from, k.to) == 0 ? k.to = ns(c) : x.changes.push(Rf(o, c));
        else {
          var D = ye(m.done);
          for ((!D || !D.ranges) && fd(o.sel, m.done), x = {
            changes: [Rf(o, c)],
            generation: m.generation
          }, m.done.push(x); m.done.length > m.undoDepth; )
            m.done.shift(), m.done[0].ranges || m.done.shift();
        }
        m.done.push(p), m.generation = ++m.maxGeneration, m.lastModTime = m.lastSelTime = S, m.lastOp = m.lastSelOp = f, m.lastOrigin = m.lastSelOrigin = c.origin, k || Nt(o, "historyAdded");
      }
      function GA(o, c, p, f) {
        var m = c.charAt(0);
        return m == "*" || m == "+" && p.ranges.length == f.ranges.length && p.somethingSelected() == f.somethingSelected() && /* @__PURE__ */ new Date() - o.history.lastSelTime <= (o.cm ? o.cm.options.historyEventDelay : 500);
      }
      function WA(o, c, p, f) {
        var m = o.history, S = f && f.origin;
        p == m.lastSelOp || S && m.lastSelOrigin == S && (m.lastModTime == m.lastSelTime && m.lastOrigin == S || GA(o, S, ye(m.done), c)) ? m.done[m.done.length - 1] = c : fd(c, m.done), m.lastSelTime = +/* @__PURE__ */ new Date(), m.lastSelOrigin = S, m.lastSelOp = p, f && f.clearRedo !== false && lb(m.undone);
      }
      function fd(o, c) {
        var p = ye(c);
        p && p.ranges && p.equals(o) || c.push(o);
      }
      function db(o, c, p, f) {
        var m = c["spans_" + o.id], S = 0;
        o.iter(Math.max(o.first, p), Math.min(o.first + o.size, f), function(x) {
          x.markedSpans && ((m || (m = c["spans_" + o.id] = {}))[S] = x.markedSpans), ++S;
        });
      }
      function HA(o) {
        if (!o)
          return null;
        for (var c, p = 0; p < o.length; ++p)
          o[p].marker.explicitlyCleared ? c || (c = o.slice(0, p)) : c && c.push(o[p]);
        return c ? c.length ? c : null : o;
      }
      function qA(o, c) {
        var p = c["spans_" + o.id];
        if (!p)
          return null;
        for (var f = [], m = 0; m < c.text.length; ++m)
          f.push(HA(p[m]));
        return f;
      }
      function ub(o, c) {
        var p = qA(o, c), f = ef(o, c);
        if (!p)
          return f;
        if (!f)
          return p;
        for (var m = 0; m < p.length; ++m) {
          var S = p[m], x = f[m];
          if (S && x)
            e: for (var k = 0; k < x.length; ++k) {
              for (var D = x[k], _ = 0; _ < S.length; ++_)
                if (S[_].marker == D.marker)
                  continue e;
              S.push(D);
            }
          else x && (p[m] = x);
        }
        return p;
      }
      function Oa(o, c, p) {
        for (var f = [], m = 0; m < o.length; ++m) {
          var S = o[m];
          if (S.ranges) {
            f.push(p ? ni.prototype.deepCopy.call(S) : S);
            continue;
          }
          var x = S.changes, k = [];
          f.push({ changes: k });
          for (var D = 0; D < x.length; ++D) {
            var _ = x[D], z = void 0;
            if (k.push({ from: _.from, to: _.to, text: _.text }), c)
              for (var W in _)
                (z = W.match(/^spans_(\d+)$/)) && De(c, Number(z[1])) > -1 && (ye(k)[W] = _[W], delete _[W]);
          }
        }
        return f;
      }
      function Af(o, c, p, f) {
        if (f) {
          var m = o.anchor;
          if (p) {
            var S = we(c, m) < 0;
            S != we(p, m) < 0 ? (m = c, c = p) : S != we(c, p) < 0 && (c = p);
          }
          return new ht(m, c);
        } else
          return new ht(p || c, c);
      }
      function pd(o, c, p, f, m) {
        m == null && (m = o.cm && (o.cm.display.shift || o.extend)), wn(o, new ni([Af(o.sel.primary(), c, p, m)], 0), f);
      }
      function hb(o, c, p) {
        for (var f = [], m = o.cm && (o.cm.display.shift || o.extend), S = 0; S < o.sel.ranges.length; S++)
          f[S] = Af(o.sel.ranges[S], c[S], null, m);
        var x = _i(o.cm, f, o.sel.primIndex);
        wn(o, x, p);
      }
      function _f(o, c, p, f) {
        var m = o.sel.ranges.slice(0);
        m[c] = p, wn(o, _i(o.cm, m, o.sel.primIndex), f);
      }
      function fb(o, c, p, f) {
        wn(o, ts(c, p), f);
      }
      function jA(o, c, p) {
        var f = {
          ranges: c.ranges,
          update: function(m) {
            this.ranges = [];
            for (var S = 0; S < m.length; S++)
              this.ranges[S] = new ht(
                Ke(o, m[S].anchor),
                Ke(o, m[S].head)
              );
          },
          origin: p && p.origin
        };
        return Nt(o, "beforeSelectionChange", o, f), o.cm && Nt(o.cm, "beforeSelectionChange", o.cm, f), f.ranges != c.ranges ? _i(o.cm, f.ranges, f.ranges.length - 1) : c;
      }
      function pb(o, c, p) {
        var f = o.history.done, m = ye(f);
        m && m.ranges ? (f[f.length - 1] = c, gd(o, c, p)) : wn(o, c, p);
      }
      function wn(o, c, p) {
        gd(o, c, p), WA(o, o.sel, o.cm ? o.cm.curOp.id : NaN, p);
      }
      function gd(o, c, p) {
        (Jn(o, "beforeSelectionChange") || o.cm && Jn(o.cm, "beforeSelectionChange")) && (c = jA(o, c, p));
        var f = p && p.bias || (we(c.primary().head, o.sel.primary().head) < 0 ? -1 : 1);
        gb(o, vb(o, c, f, true)), !(p && p.scroll === false) && o.cm && o.cm.getOption("readOnly") != "nocursor" && Ma(o.cm);
      }
      function gb(o, c) {
        c.equals(o.sel) || (o.sel = c, o.cm && (o.cm.curOp.updateInput = 1, o.cm.curOp.selectionChanged = true, di(o.cm)), sn(o, "cursorActivity", o));
      }
      function mb(o) {
        gb(o, vb(o, o.sel, null, false));
      }
      function vb(o, c, p, f) {
        for (var m, S = 0; S < c.ranges.length; S++) {
          var x = c.ranges[S], k = c.ranges.length == o.sel.ranges.length && o.sel.ranges[S], D = md(o, x.anchor, k && k.anchor, p, f), _ = x.head == x.anchor ? D : md(o, x.head, k && k.head, p, f);
          (m || D != x.anchor || _ != x.head) && (m || (m = c.ranges.slice(0, S)), m[S] = new ht(D, _));
        }
        return m ? _i(o.cm, m, c.primIndex) : c;
      }
      function Va(o, c, p, f, m) {
        var S = Be(o, c.line);
        if (S.markedSpans)
          for (var x = 0; x < S.markedSpans.length; ++x) {
            var k = S.markedSpans[x], D = k.marker, _ = "selectLeft" in D ? !D.selectLeft : D.inclusiveLeft, z = "selectRight" in D ? !D.selectRight : D.inclusiveRight;
            if ((k.from == null || (_ ? k.from <= c.ch : k.from < c.ch)) && (k.to == null || (z ? k.to >= c.ch : k.to > c.ch))) {
              if (m && (Nt(D, "beforeCursorEnter"), D.explicitlyCleared))
                if (S.markedSpans) {
                  --x;
                  continue;
                } else
                  break;
              if (!D.atomic)
                continue;
              if (p) {
                var W = D.find(f < 0 ? 1 : -1), K = void 0;
                if ((f < 0 ? z : _) && (W = yb(o, W, -f, W && W.line == c.line ? S : null)), W && W.line == c.line && (K = we(W, p)) && (f < 0 ? K < 0 : K > 0))
                  return Va(o, W, c, f, m);
              }
              var J = D.find(f < 0 ? -1 : 1);
              return (f < 0 ? _ : z) && (J = yb(o, J, f, J.line == c.line ? S : null)), J ? Va(o, J, c, f, m) : null;
            }
          }
        return c;
      }
      function md(o, c, p, f, m) {
        var S = f || 1, x = Va(o, c, p, S, m) || !m && Va(o, c, p, S, true) || Va(o, c, p, -S, m) || !m && Va(o, c, p, -S, true);
        return x || (o.cantEdit = true, Q(o.first, 0));
      }
      function yb(o, c, p, f) {
        return p < 0 && c.ch == 0 ? c.line > o.first ? Ke(o, Q(c.line - 1)) : null : p > 0 && c.ch == (f || Be(o, c.line)).text.length ? c.line < o.first + o.size - 1 ? Q(c.line + 1, 0) : null : new Q(c.line, c.ch + p);
      }
      function Sb(o) {
        o.setSelection(Q(o.firstLine(), 0), Q(o.lastLine()), At);
      }
      function bb(o, c, p) {
        var f = {
          canceled: false,
          from: c.from,
          to: c.to,
          text: c.text,
          origin: c.origin,
          cancel: function() {
            return f.canceled = true;
          }
        };
        return p && (f.update = function(m, S, x, k) {
          m && (f.from = Ke(o, m)), S && (f.to = Ke(o, S)), x && (f.text = x), k !== void 0 && (f.origin = k);
        }), Nt(o, "beforeChange", o, f), o.cm && Nt(o.cm, "beforeChange", o.cm, f), f.canceled ? (o.cm && (o.cm.curOp.updateInput = 2), null) : { from: f.from, to: f.to, text: f.text, origin: f.origin };
      }
      function Ba(o, c, p) {
        if (o.cm) {
          if (!o.cm.curOp)
            return an(o.cm, Ba)(o, c, p);
          if (o.cm.state.suppressEdits)
            return;
        }
        if (!((Jn(o, "beforeChange") || o.cm && Jn(o.cm, "beforeChange")) && (c = bb(o, c, true), !c))) {
          var f = u0 && !p && WR(o, c.from, c.to);
          if (f)
            for (var m = f.length - 1; m >= 0; --m)
              wb(o, { from: f[m].from, to: f[m].to, text: m ? [""] : c.text, origin: c.origin });
          else
            wb(o, c);
        }
      }
      function wb(o, c) {
        if (!(c.text.length == 1 && c.text[0] == "" && we(c.from, c.to) == 0)) {
          var p = Df(o, c);
          cb(o, c, p, o.cm ? o.cm.curOp.id : NaN), Sl(o, c, p, ef(o, c));
          var f = [];
          is(o, function(m, S) {
            !S && De(f, m.history) == -1 && (kb(m.history, c), f.push(m.history)), Sl(m, c, null, ef(m, c));
          });
        }
      }
      function vd(o, c, p) {
        var f = o.cm && o.cm.state.suppressEdits;
        if (!(f && !p)) {
          for (var m = o.history, S, x = o.sel, k = c == "undo" ? m.done : m.undone, D = c == "undo" ? m.undone : m.done, _ = 0; _ < k.length && (S = k[_], !(p ? S.ranges && !S.equals(o.sel) : !S.ranges)); _++)
            ;
          if (_ != k.length) {
            for (m.lastOrigin = m.lastSelOrigin = null; ; )
              if (S = k.pop(), S.ranges) {
                if (fd(S, D), p && !S.equals(o.sel)) {
                  wn(o, S, { clearRedo: false });
                  return;
                }
                x = S;
              } else if (f) {
                k.push(S);
                return;
              } else
                break;
            var z = [];
            fd(x, D), D.push({ changes: z, generation: m.generation }), m.generation = S.generation || ++m.maxGeneration;
            for (var W = Jn(o, "beforeChange") || o.cm && Jn(o.cm, "beforeChange"), K = function(le) {
              var pe = S.changes[le];
              if (pe.origin = c, W && !bb(o, pe, false))
                return k.length = 0, {};
              z.push(Rf(o, pe));
              var Se = le ? Df(o, pe) : ye(k);
              Sl(o, pe, Se, ub(o, pe)), !le && o.cm && o.cm.scrollIntoView({ from: pe.from, to: ns(pe) });
              var Te = [];
              is(o, function(be, Ie) {
                !Ie && De(Te, be.history) == -1 && (kb(be.history, pe), Te.push(be.history)), Sl(be, pe, null, ub(be, pe));
              });
            }, J = S.changes.length - 1; J >= 0; --J) {
              var ee = K(J);
              if (ee) return ee.v;
            }
          }
        }
      }
      function Cb(o, c) {
        if (c != 0 && (o.first += c, o.sel = new ni(Je(o.sel.ranges, function(m) {
          return new ht(
            Q(m.anchor.line + c, m.anchor.ch),
            Q(m.head.line + c, m.head.ch)
          );
        }), o.sel.primIndex), o.cm)) {
          Vn(o.cm, o.first, o.first - c, c);
          for (var p = o.cm.display, f = p.viewFrom; f < p.viewTo; f++)
            Qr(o.cm, f, "gutter");
        }
      }
      function Sl(o, c, p, f) {
        if (o.cm && !o.cm.curOp)
          return an(o.cm, Sl)(o, c, p, f);
        if (c.to.line < o.first) {
          Cb(o, c.text.length - 1 - (c.to.line - c.from.line));
          return;
        }
        if (!(c.from.line > o.lastLine())) {
          if (c.from.line < o.first) {
            var m = c.text.length - 1 - (o.first - c.from.line);
            Cb(o, m), c = {
              from: Q(o.first, 0),
              to: Q(c.to.line + m, c.to.ch),
              text: [ye(c.text)],
              origin: c.origin
            };
          }
          var S = o.lastLine();
          c.to.line > S && (c = {
            from: c.from,
            to: Q(S, Be(o, S).text.length),
            text: [c.text[0]],
            origin: c.origin
          }), c.removed = gr(o, c.from, c.to), p || (p = Df(o, c)), o.cm ? JA(o.cm, c, f) : Pf(o, c, f), gd(o, p, At), o.cantEdit && md(o, Q(o.firstLine(), 0)) && (o.cantEdit = false);
        }
      }
      function JA(o, c, p) {
        var f = o.doc, m = o.display, S = c.from, x = c.to, k = false, D = S.line;
        o.options.lineWrapping || (D = N(Ri(Be(f, S.line))), f.iter(D, x.line + 1, function(J) {
          if (J == m.maxLine)
            return k = true, true;
        })), f.sel.contains(c.from, c.to) > -1 && di(o), Pf(f, c, p, z0(o)), o.options.lineWrapping || (f.iter(D, S.line + c.text.length, function(J) {
          var ee = ed(J);
          ee > m.maxLineLength && (m.maxLine = J, m.maxLineLength = ee, m.maxLineChanged = true, k = false);
        }), k && (o.curOp.updateMaxLine = true)), VR(f, S.line), ml(o, 400);
        var _ = c.text.length - (x.line - S.line) - 1;
        c.full ? Vn(o) : S.line == x.line && c.text.length == 1 && !sb(o.doc, c) ? Qr(o, S.line, "text") : Vn(o, S.line, x.line + 1, _);
        var z = Jn(o, "changes"), W = Jn(o, "change");
        if (W || z) {
          var K = {
            from: S,
            to: x,
            text: c.text,
            removed: c.removed,
            origin: c.origin
          };
          W && sn(o, "change", o, K), z && (o.curOp.changeObjs || (o.curOp.changeObjs = [])).push(K);
        }
        o.display.selForContextMenu = null;
      }
      function Fa(o, c, p, f, m) {
        var S;
        f || (f = p), we(f, p) < 0 && (S = [f, p], p = S[0], f = S[1]), typeof c == "string" && (c = o.splitLines(c)), Ba(o, { from: p, to: f, text: c, origin: m });
      }
      function xb(o, c, p, f) {
        p < o.line ? o.line += f : c < o.line && (o.line = c, o.ch = 0);
      }
      function Eb(o, c, p, f) {
        for (var m = 0; m < o.length; ++m) {
          var S = o[m], x = true;
          if (S.ranges) {
            S.copied || (S = o[m] = S.deepCopy(), S.copied = true);
            for (var k = 0; k < S.ranges.length; k++)
              xb(S.ranges[k].anchor, c, p, f), xb(S.ranges[k].head, c, p, f);
            continue;
          }
          for (var D = 0; D < S.changes.length; ++D) {
            var _ = S.changes[D];
            if (p < _.from.line)
              _.from = Q(_.from.line + f, _.from.ch), _.to = Q(_.to.line + f, _.to.ch);
            else if (c <= _.to.line) {
              x = false;
              break;
            }
          }
          x || (o.splice(0, m + 1), m = 0);
        }
      }
      function kb(o, c) {
        var p = c.from.line, f = c.to.line, m = c.text.length - (f - p) - 1;
        Eb(o.done, p, f, m), Eb(o.undone, p, f, m);
      }
      function bl(o, c, p, f) {
        var m = c, S = c;
        return typeof c == "number" ? S = Be(o, n0(o, c)) : m = N(c), m == null ? null : (f(S, m) && o.cm && Qr(o.cm, m, p), S);
      }
      function wl(o) {
        this.lines = o, this.parent = null;
        for (var c = 0, p = 0; p < o.length; ++p)
          o[p].parent = this, c += o[p].height;
        this.height = c;
      }
      wl.prototype = {
        chunkSize: function() {
          return this.lines.length;
        },
        // Remove the n lines at offset 'at'.
        removeInner: function(o, c) {
          for (var p = o, f = o + c; p < f; ++p) {
            var m = this.lines[p];
            this.height -= m.height, KR(m), sn(m, "delete");
          }
          this.lines.splice(o, c);
        },
        // Helper used to collapse a small branch into a single leaf.
        collapse: function(o) {
          o.push.apply(o, this.lines);
        },
        // Insert the given array of lines at offset 'at', count them as
        // having the given height.
        insertInner: function(o, c, p) {
          this.height += p, this.lines = this.lines.slice(0, o).concat(c).concat(this.lines.slice(o));
          for (var f = 0; f < c.length; ++f)
            c[f].parent = this;
        },
        // Used to iterate over a part of the tree.
        iterN: function(o, c, p) {
          for (var f = o + c; o < f; ++o)
            if (p(this.lines[o]))
              return true;
        }
      };
      function Cl(o) {
        this.children = o;
        for (var c = 0, p = 0, f = 0; f < o.length; ++f) {
          var m = o[f];
          c += m.chunkSize(), p += m.height, m.parent = this;
        }
        this.size = c, this.height = p, this.parent = null;
      }
      Cl.prototype = {
        chunkSize: function() {
          return this.size;
        },
        removeInner: function(o, c) {
          this.size -= c;
          for (var p = 0; p < this.children.length; ++p) {
            var f = this.children[p], m = f.chunkSize();
            if (o < m) {
              var S = Math.min(c, m - o), x = f.height;
              if (f.removeInner(o, S), this.height -= x - f.height, m == S && (this.children.splice(p--, 1), f.parent = null), (c -= S) == 0)
                break;
              o = 0;
            } else
              o -= m;
          }
          if (this.size - c < 25 && (this.children.length > 1 || !(this.children[0] instanceof wl))) {
            var k = [];
            this.collapse(k), this.children = [new wl(k)], this.children[0].parent = this;
          }
        },
        collapse: function(o) {
          for (var c = 0; c < this.children.length; ++c)
            this.children[c].collapse(o);
        },
        insertInner: function(o, c, p) {
          this.size += c.length, this.height += p;
          for (var f = 0; f < this.children.length; ++f) {
            var m = this.children[f], S = m.chunkSize();
            if (o <= S) {
              if (m.insertInner(o, c, p), m.lines && m.lines.length > 50) {
                for (var x = m.lines.length % 25 + 25, k = x; k < m.lines.length; ) {
                  var D = new wl(m.lines.slice(k, k += 25));
                  m.height -= D.height, this.children.splice(++f, 0, D), D.parent = this;
                }
                m.lines = m.lines.slice(0, x), this.maybeSpill();
              }
              break;
            }
            o -= S;
          }
        },
        // When a node has grown, check whether it should be split.
        maybeSpill: function() {
          if (!(this.children.length <= 10)) {
            var o = this;
            do {
              var c = o.children.splice(o.children.length - 5, 5), p = new Cl(c);
              if (o.parent) {
                o.size -= p.size, o.height -= p.height;
                var m = De(o.parent.children, o);
                o.parent.children.splice(m + 1, 0, p);
              } else {
                var f = new Cl(o.children);
                f.parent = o, o.children = [f, p], o = f;
              }
              p.parent = o.parent;
            } while (o.children.length > 10);
            o.parent.maybeSpill();
          }
        },
        iterN: function(o, c, p) {
          for (var f = 0; f < this.children.length; ++f) {
            var m = this.children[f], S = m.chunkSize();
            if (o < S) {
              var x = Math.min(c, S - o);
              if (m.iterN(o, x, p))
                return true;
              if ((c -= x) == 0)
                break;
              o = 0;
            } else
              o -= S;
          }
        }
      };
      var xl = function(o, c, p) {
        if (p)
          for (var f in p)
            p.hasOwnProperty(f) && (this[f] = p[f]);
        this.doc = o, this.node = c;
      };
      xl.prototype.clear = function() {
        var o = this.doc.cm, c = this.line.widgets, p = this.line, f = N(p);
        if (!(f == null || !c)) {
          for (var m = 0; m < c.length; ++m)
            c[m] == this && c.splice(m--, 1);
          c.length || (p.widgets = null);
          var S = cl(this);
          ti(p, Math.max(0, p.height - S)), o && (Kn(o, function() {
            Tb(o, p, -S), Qr(o, f, "widget");
          }), sn(o, "lineWidgetCleared", o, this, f));
        }
      }, xl.prototype.changed = function() {
        var o = this, c = this.height, p = this.doc.cm, f = this.line;
        this.height = null;
        var m = cl(this) - c;
        m && (Zr(this.doc, f) || ti(f, f.height + m), p && Kn(p, function() {
          p.curOp.forceUpdate = true, Tb(p, f, m), sn(p, "lineWidgetChanged", p, o, N(f));
        }));
      }, Ti(xl);
      function Tb(o, c, p) {
        vr(c) < (o.curOp && o.curOp.scrollTop || o.doc.scrollTop) && Cf(o, p);
      }
      function KA(o, c, p, f) {
        var m = new xl(o, p, f), S = o.cm;
        return S && m.noHScroll && (S.display.alignWidgets = true), bl(o, c, "widget", function(x) {
          var k = x.widgets || (x.widgets = []);
          if (m.insertAt == null ? k.push(m) : k.splice(Math.min(k.length, Math.max(0, m.insertAt)), 0, m), m.line = x, S && !Zr(o, x)) {
            var D = vr(x) < o.scrollTop;
            ti(x, x.height + cl(m)), D && Cf(S, m.height), S.curOp.forceUpdate = true;
          }
          return true;
        }), S && sn(S, "lineWidgetAdded", S, m, typeof c == "number" ? c : N(c)), m;
      }
      var Lb = 0, rs = function(o, c) {
        this.lines = [], this.type = c, this.doc = o, this.id = ++Lb;
      };
      rs.prototype.clear = function() {
        if (!this.explicitlyCleared) {
          var o = this.doc.cm, c = o && !o.curOp;
          if (c && Bs(o), Jn(this, "clear")) {
            var p = this.find();
            p && sn(this, "clear", p.from, p.to);
          }
          for (var f = null, m = null, S = 0; S < this.lines.length; ++S) {
            var x = this.lines[S], k = al(x.markedSpans, this);
            o && !this.collapsed ? Qr(o, N(x), "text") : o && (k.to != null && (m = N(x)), k.from != null && (f = N(x))), x.markedSpans = UR(x.markedSpans, k), k.from == null && this.collapsed && !Zr(this.doc, x) && o && ti(x, Ra(o.display));
          }
          if (o && this.collapsed && !o.options.lineWrapping)
            for (var D = 0; D < this.lines.length; ++D) {
              var _ = Ri(this.lines[D]), z = ed(_);
              z > o.display.maxLineLength && (o.display.maxLine = _, o.display.maxLineLength = z, o.display.maxLineChanged = true);
            }
          f != null && o && this.collapsed && Vn(o, f, m + 1), this.lines.length = 0, this.explicitlyCleared = true, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = false, o && mb(o.doc)), o && sn(o, "markerCleared", o, this, f, m), c && Fs(o), this.parent && this.parent.clear();
        }
      }, rs.prototype.find = function(o, c) {
        o == null && this.type == "bookmark" && (o = 1);
        for (var p, f, m = 0; m < this.lines.length; ++m) {
          var S = this.lines[m], x = al(S.markedSpans, this);
          if (x.from != null && (p = Q(c ? S : N(S), x.from), o == -1))
            return p;
          if (x.to != null && (f = Q(c ? S : N(S), x.to), o == 1))
            return f;
        }
        return p && { from: p, to: f };
      }, rs.prototype.changed = function() {
        var o = this, c = this.find(-1, true), p = this, f = this.doc.cm;
        !c || !f || Kn(f, function() {
          var m = c.line, S = N(c.line), x = cf(f, S);
          if (x && (_0(x), f.curOp.selectionChanged = f.curOp.forceUpdate = true), f.curOp.updateMaxLine = true, !Zr(p.doc, m) && p.height != null) {
            var k = p.height;
            p.height = null;
            var D = cl(p) - k;
            D && ti(m, m.height + D);
          }
          sn(f, "markerChanged", f, o);
        });
      }, rs.prototype.attachLine = function(o) {
        if (!this.lines.length && this.doc.cm) {
          var c = this.doc.cm.curOp;
          (!c.maybeHiddenMarkers || De(c.maybeHiddenMarkers, this) == -1) && (c.maybeUnhiddenMarkers || (c.maybeUnhiddenMarkers = [])).push(this);
        }
        this.lines.push(o);
      }, rs.prototype.detachLine = function(o) {
        if (this.lines.splice(De(this.lines, o), 1), !this.lines.length && this.doc.cm) {
          var c = this.doc.cm.curOp;
          (c.maybeHiddenMarkers || (c.maybeHiddenMarkers = [])).push(this);
        }
      }, Ti(rs);
      function Ua(o, c, p, f, m) {
        if (f && f.shared)
          return YA(o, c, p, f, m);
        if (o.cm && !o.cm.curOp)
          return an(o.cm, Ua)(o, c, p, f, m);
        var S = new rs(o, m), x = we(c, p);
        if (f && Ve(f, S, false), x > 0 || x == 0 && S.clearWhenEmpty !== false)
          return S;
        if (S.replacedWith && (S.collapsed = true, S.widgetNode = ue("span", [S.replacedWith], "CodeMirror-widget"), f.handleMouseEvents || S.widgetNode.setAttribute("cm-ignore-events", "true"), f.insertLeft && (S.widgetNode.insertLeft = true)), S.collapsed) {
          if (v0(o, c.line, c, p, S) || c.line != p.line && v0(o, p.line, c, p, S))
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          FR();
        }
        S.addToHistory && cb(o, { from: c, to: p, origin: "markText" }, o.sel, NaN);
        var k = c.line, D = o.cm, _;
        if (o.iter(k, p.line + 1, function(W) {
          D && S.collapsed && !D.options.lineWrapping && Ri(W) == D.display.maxLine && (_ = true), S.collapsed && k != c.line && ti(W, 0), zR(W, new Yc(
            S,
            k == c.line ? c.ch : null,
            k == p.line ? p.ch : null
          ), o.cm && o.cm.curOp), ++k;
        }), S.collapsed && o.iter(c.line, p.line + 1, function(W) {
          Zr(o, W) && ti(W, 0);
        }), S.clearOnEnter && $e(S, "beforeCursorEnter", function() {
          return S.clear();
        }), S.readOnly && (BR2(), (o.history.done.length || o.history.undone.length) && o.clearHistory()), S.collapsed && (S.id = ++Lb, S.atomic = true), D) {
          if (_ && (D.curOp.updateMaxLine = true), S.collapsed)
            Vn(D, c.line, p.line + 1);
          else if (S.className || S.startStyle || S.endStyle || S.css || S.attributes || S.title)
            for (var z = c.line; z <= p.line; z++)
              Qr(D, z, "text");
          S.atomic && mb(D.doc), sn(D, "markerAdded", D, S);
        }
        return S;
      }
      var El = function(o, c) {
        this.markers = o, this.primary = c;
        for (var p = 0; p < o.length; ++p)
          o[p].parent = this;
      };
      El.prototype.clear = function() {
        if (!this.explicitlyCleared) {
          this.explicitlyCleared = true;
          for (var o = 0; o < this.markers.length; ++o)
            this.markers[o].clear();
          sn(this, "clear");
        }
      }, El.prototype.find = function(o, c) {
        return this.primary.find(o, c);
      }, Ti(El);
      function YA(o, c, p, f, m) {
        f = Ve(f), f.shared = false;
        var S = [Ua(o, c, p, f, m)], x = S[0], k = f.widgetNode;
        return is(o, function(D) {
          k && (f.widgetNode = k.cloneNode(true)), S.push(Ua(D, Ke(D, c), Ke(D, p), f, m));
          for (var _ = 0; _ < D.linked.length; ++_)
            if (D.linked[_].isParent)
              return;
          x = ye(S);
        }), new El(S, x);
      }
      function Db(o) {
        return o.findMarks(Q(o.first, 0), o.clipPos(Q(o.lastLine())), function(c) {
          return c.parent;
        });
      }
      function XA(o, c) {
        for (var p = 0; p < c.length; p++) {
          var f = c[p], m = f.find(), S = o.clipPos(m.from), x = o.clipPos(m.to);
          if (we(S, x)) {
            var k = Ua(o, S, x, f.primary, f.primary.type);
            f.markers.push(k), k.parent = f;
          }
        }
      }
      function ZA(o) {
        for (var c = function(f) {
          var m = o[f], S = [m.primary.doc];
          is(m.primary.doc, function(D) {
            return S.push(D);
          });
          for (var x = 0; x < m.markers.length; x++) {
            var k = m.markers[x];
            De(S, k.doc) == -1 && (k.parent = null, m.markers.splice(x--, 1));
          }
        }, p = 0; p < o.length; p++) c(p);
      }
      var QA = 0, Bn = function(o, c, p, f, m) {
        if (!(this instanceof Bn))
          return new Bn(o, c, p, f, m);
        p == null && (p = 0), Cl.call(this, [new wl([new Da("", null)])]), this.first = p, this.scrollTop = this.scrollLeft = 0, this.cantEdit = false, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = p;
        var S = Q(p, 0);
        this.sel = ts(S), this.history = new hd(null), this.id = ++QA, this.modeOption = c, this.lineSep = f, this.direction = m == "rtl" ? "rtl" : "ltr", this.extend = false, typeof o == "string" && (o = this.splitLines(o)), Pf(this, { from: S, to: S, text: o }), wn(this, ts(S), At);
      };
      Bn.prototype = gt(Cl.prototype, {
        constructor: Bn,
        // Iterate over the document. Supports two forms -- with only one
        // argument, it calls that for each line in the document. With
        // three, it iterates over the range given by the first two (with
        // the second being non-inclusive).
        iter: function(o, c, p) {
          p ? this.iterN(o - this.first, c - o, p) : this.iterN(this.first, this.first + this.size, o);
        },
        // Non-public interface for adding and removing lines.
        insert: function(o, c) {
          for (var p = 0, f = 0; f < c.length; ++f)
            p += c[f].height;
          this.insertInner(o - this.first, c, p);
        },
        remove: function(o, c) {
          this.removeInner(o - this.first, c);
        },
        // From here, the methods are part of the public interface. Most
        // are also available from CodeMirror (editor) instances.
        getValue: function(o) {
          var c = rl(this, this.first, this.first + this.size);
          return o === false ? c : c.join(o || this.lineSeparator());
        },
        setValue: on(function(o) {
          var c = Q(this.first, 0), p = this.first + this.size - 1;
          Ba(this, {
            from: c,
            to: Q(p, Be(this, p).text.length),
            text: this.splitLines(o),
            origin: "setValue",
            full: true
          }, true), this.cm && hl(this.cm, 0, 0), wn(this, ts(c), At);
        }),
        replaceRange: function(o, c, p, f) {
          c = Ke(this, c), p = p ? Ke(this, p) : c, Fa(this, o, c, p, f);
        },
        getRange: function(o, c, p) {
          var f = gr(this, Ke(this, o), Ke(this, c));
          return p === false ? f : p === "" ? f.join("") : f.join(p || this.lineSeparator());
        },
        getLine: function(o) {
          var c = this.getLineHandle(o);
          return c && c.text;
        },
        getLineHandle: function(o) {
          if (ie(this, o))
            return Be(this, o);
        },
        getLineNumber: function(o) {
          return N(o);
        },
        getLineHandleVisualStart: function(o) {
          return typeof o == "number" && (o = Be(this, o)), Ri(o);
        },
        lineCount: function() {
          return this.size;
        },
        firstLine: function() {
          return this.first;
        },
        lastLine: function() {
          return this.first + this.size - 1;
        },
        clipPos: function(o) {
          return Ke(this, o);
        },
        getCursor: function(o) {
          var c = this.sel.primary(), p;
          return o == null || o == "head" ? p = c.head : o == "anchor" ? p = c.anchor : o == "end" || o == "to" || o === false ? p = c.to() : p = c.from(), p;
        },
        listSelections: function() {
          return this.sel.ranges;
        },
        somethingSelected: function() {
          return this.sel.somethingSelected();
        },
        setCursor: on(function(o, c, p) {
          fb(this, Ke(this, typeof o == "number" ? Q(o, c || 0) : o), null, p);
        }),
        setSelection: on(function(o, c, p) {
          fb(this, Ke(this, o), Ke(this, c || o), p);
        }),
        extendSelection: on(function(o, c, p) {
          pd(this, Ke(this, o), c && Ke(this, c), p);
        }),
        extendSelections: on(function(o, c) {
          hb(this, i0(this, o), c);
        }),
        extendSelectionsBy: on(function(o, c) {
          var p = Je(this.sel.ranges, o);
          hb(this, i0(this, p), c);
        }),
        setSelections: on(function(o, c, p) {
          if (o.length) {
            for (var f = [], m = 0; m < o.length; m++)
              f[m] = new ht(
                Ke(this, o[m].anchor),
                Ke(this, o[m].head || o[m].anchor)
              );
            c == null && (c = Math.min(o.length - 1, this.sel.primIndex)), wn(this, _i(this.cm, f, c), p);
          }
        }),
        addSelection: on(function(o, c, p) {
          var f = this.sel.ranges.slice(0);
          f.push(new ht(Ke(this, o), Ke(this, c || o))), wn(this, _i(this.cm, f, f.length - 1), p);
        }),
        getSelection: function(o) {
          for (var c = this.sel.ranges, p, f = 0; f < c.length; f++) {
            var m = gr(this, c[f].from(), c[f].to());
            p = p ? p.concat(m) : m;
          }
          return o === false ? p : p.join(o || this.lineSeparator());
        },
        getSelections: function(o) {
          for (var c = [], p = this.sel.ranges, f = 0; f < p.length; f++) {
            var m = gr(this, p[f].from(), p[f].to());
            o !== false && (m = m.join(o || this.lineSeparator())), c[f] = m;
          }
          return c;
        },
        replaceSelection: function(o, c, p) {
          for (var f = [], m = 0; m < this.sel.ranges.length; m++)
            f[m] = o;
          this.replaceSelections(f, c, p || "+input");
        },
        replaceSelections: on(function(o, c, p) {
          for (var f = [], m = this.sel, S = 0; S < m.ranges.length; S++) {
            var x = m.ranges[S];
            f[S] = { from: x.from(), to: x.to(), text: this.splitLines(o[S]), origin: p };
          }
          for (var k = c && c != "end" && UA(this, f, c), D = f.length - 1; D >= 0; D--)
            Ba(this, f[D]);
          k ? pb(this, k) : this.cm && Ma(this.cm);
        }),
        undo: on(function() {
          vd(this, "undo");
        }),
        redo: on(function() {
          vd(this, "redo");
        }),
        undoSelection: on(function() {
          vd(this, "undo", true);
        }),
        redoSelection: on(function() {
          vd(this, "redo", true);
        }),
        setExtending: function(o) {
          this.extend = o;
        },
        getExtending: function() {
          return this.extend;
        },
        historySize: function() {
          for (var o = this.history, c = 0, p = 0, f = 0; f < o.done.length; f++)
            o.done[f].ranges || ++c;
          for (var m = 0; m < o.undone.length; m++)
            o.undone[m].ranges || ++p;
          return { undo: c, redo: p };
        },
        clearHistory: function() {
          var o = this;
          this.history = new hd(this.history), is(this, function(c) {
            return c.history = o.history;
          }, true);
        },
        markClean: function() {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function(o) {
          return o && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation;
        },
        isClean: function(o) {
          return this.history.generation == (o || this.cleanGeneration);
        },
        getHistory: function() {
          return {
            done: Oa(this.history.done),
            undone: Oa(this.history.undone)
          };
        },
        setHistory: function(o) {
          var c = this.history = new hd(this.history);
          c.done = Oa(o.done.slice(0), null, true), c.undone = Oa(o.undone.slice(0), null, true);
        },
        setGutterMarker: on(function(o, c, p) {
          return bl(this, o, "gutter", function(f) {
            var m = f.gutterMarkers || (f.gutterMarkers = {});
            return m[c] = p, !p && It(m) && (f.gutterMarkers = null), true;
          });
        }),
        clearGutter: on(function(o) {
          var c = this;
          this.iter(function(p) {
            p.gutterMarkers && p.gutterMarkers[o] && bl(c, p, "gutter", function() {
              return p.gutterMarkers[o] = null, It(p.gutterMarkers) && (p.gutterMarkers = null), true;
            });
          });
        }),
        lineInfo: function(o) {
          var c;
          if (typeof o == "number") {
            if (!ie(this, o) || (c = o, o = Be(this, o), !o))
              return null;
          } else if (c = N(o), c == null)
            return null;
          return {
            line: c,
            handle: o,
            text: o.text,
            gutterMarkers: o.gutterMarkers,
            textClass: o.textClass,
            bgClass: o.bgClass,
            wrapClass: o.wrapClass,
            widgets: o.widgets
          };
        },
        addLineClass: on(function(o, c, p) {
          return bl(this, o, c == "gutter" ? "gutter" : "class", function(f) {
            var m = c == "text" ? "textClass" : c == "background" ? "bgClass" : c == "gutter" ? "gutterClass" : "wrapClass";
            if (!f[m])
              f[m] = p;
            else {
              if (q(p).test(f[m]))
                return false;
              f[m] += " " + p;
            }
            return true;
          });
        }),
        removeLineClass: on(function(o, c, p) {
          return bl(this, o, c == "gutter" ? "gutter" : "class", function(f) {
            var m = c == "text" ? "textClass" : c == "background" ? "bgClass" : c == "gutter" ? "gutterClass" : "wrapClass", S = f[m];
            if (S)
              if (p == null)
                f[m] = null;
              else {
                var x = S.match(q(p));
                if (!x)
                  return false;
                var k = x.index + x[0].length;
                f[m] = S.slice(0, x.index) + (!x.index || k == S.length ? "" : " ") + S.slice(k) || null;
              }
            else return false;
            return true;
          });
        }),
        addLineWidget: on(function(o, c, p) {
          return KA(this, o, c, p);
        }),
        removeLineWidget: function(o) {
          o.clear();
        },
        markText: function(o, c, p) {
          return Ua(this, Ke(this, o), Ke(this, c), p, p && p.type || "range");
        },
        setBookmark: function(o, c) {
          var p = {
            replacedWith: c && (c.nodeType == null ? c.widget : c),
            insertLeft: c && c.insertLeft,
            clearWhenEmpty: false,
            shared: c && c.shared,
            handleMouseEvents: c && c.handleMouseEvents
          };
          return o = Ke(this, o), Ua(this, o, o, p, "bookmark");
        },
        findMarksAt: function(o) {
          o = Ke(this, o);
          var c = [], p = Be(this, o.line).markedSpans;
          if (p)
            for (var f = 0; f < p.length; ++f) {
              var m = p[f];
              (m.from == null || m.from <= o.ch) && (m.to == null || m.to >= o.ch) && c.push(m.marker.parent || m.marker);
            }
          return c;
        },
        findMarks: function(o, c, p) {
          o = Ke(this, o), c = Ke(this, c);
          var f = [], m = o.line;
          return this.iter(o.line, c.line + 1, function(S) {
            var x = S.markedSpans;
            if (x)
              for (var k = 0; k < x.length; k++) {
                var D = x[k];
                !(D.to != null && m == o.line && o.ch >= D.to || D.from == null && m != o.line || D.from != null && m == c.line && D.from >= c.ch) && (!p || p(D.marker)) && f.push(D.marker.parent || D.marker);
              }
            ++m;
          }), f;
        },
        getAllMarks: function() {
          var o = [];
          return this.iter(function(c) {
            var p = c.markedSpans;
            if (p)
              for (var f = 0; f < p.length; ++f)
                p[f].from != null && o.push(p[f].marker);
          }), o;
        },
        posFromIndex: function(o) {
          var c, p = this.first, f = this.lineSeparator().length;
          return this.iter(function(m) {
            var S = m.text.length + f;
            if (S > o)
              return c = o, true;
            o -= S, ++p;
          }), Ke(this, Q(p, c));
        },
        indexFromPos: function(o) {
          o = Ke(this, o);
          var c = o.ch;
          if (o.line < this.first || o.ch < 0)
            return 0;
          var p = this.lineSeparator().length;
          return this.iter(this.first, o.line, function(f) {
            c += f.text.length + p;
          }), c;
        },
        copy: function(o) {
          var c = new Bn(
            rl(this, this.first, this.first + this.size),
            this.modeOption,
            this.first,
            this.lineSep,
            this.direction
          );
          return c.scrollTop = this.scrollTop, c.scrollLeft = this.scrollLeft, c.sel = this.sel, c.extend = false, o && (c.history.undoDepth = this.history.undoDepth, c.setHistory(this.getHistory())), c;
        },
        linkedDoc: function(o) {
          o || (o = {});
          var c = this.first, p = this.first + this.size;
          o.from != null && o.from > c && (c = o.from), o.to != null && o.to < p && (p = o.to);
          var f = new Bn(rl(this, c, p), o.mode || this.modeOption, c, this.lineSep, this.direction);
          return o.sharedHist && (f.history = this.history), (this.linked || (this.linked = [])).push({ doc: f, sharedHist: o.sharedHist }), f.linked = [{ doc: this, isParent: true, sharedHist: o.sharedHist }], XA(f, Db(this)), f;
        },
        unlinkDoc: function(o) {
          if (o instanceof Rt && (o = o.doc), this.linked)
            for (var c = 0; c < this.linked.length; ++c) {
              var p = this.linked[c];
              if (p.doc == o) {
                this.linked.splice(c, 1), o.unlinkDoc(this), ZA(Db(this));
                break;
              }
            }
          if (o.history == this.history) {
            var f = [o.id];
            is(o, function(m) {
              return f.push(m.id);
            }, true), o.history = new hd(null), o.history.done = Oa(this.history.done, f), o.history.undone = Oa(this.history.undone, f);
          }
        },
        iterLinkedDocs: function(o) {
          is(this, o);
        },
        getMode: function() {
          return this.mode;
        },
        getEditor: function() {
          return this.cm;
        },
        splitLines: function(o) {
          return this.lineSep ? o.split(this.lineSep) : ui(o);
        },
        lineSeparator: function() {
          return this.lineSep || `
`;
        },
        setDirection: on(function(o) {
          o != "rtl" && (o = "ltr"), o != this.direction && (this.direction = o, this.iter(function(c) {
            return c.order = null;
          }), this.cm && zA(this.cm));
        })
      }), Bn.prototype.eachLine = Bn.prototype.iter;
      var Ib = 0;
      function e_(o) {
        var c = this;
        if (Pb(c), !(Ot(c, o) || yr(c.display, o))) {
          bn(o), d && (Ib = +/* @__PURE__ */ new Date());
          var p = Ms(c, o, true), f = o.dataTransfer.files;
          if (!(!p || c.isReadOnly()))
            if (f && f.length && window.FileReader && window.File)
              for (var m = f.length, S = Array(m), x = 0, k = function() {
                ++x == m && an(c, function() {
                  p = Ke(c.doc, p);
                  var J = {
                    from: p,
                    to: p,
                    text: c.doc.splitLines(
                      S.filter(function(ee) {
                        return ee != null;
                      }).join(c.doc.lineSeparator())
                    ),
                    origin: "paste"
                  };
                  Ba(c.doc, J), pb(c.doc, ts(Ke(c.doc, p), Ke(c.doc, ns(J))));
                })();
              }, D = function(J, ee) {
                if (c.options.allowDropFileTypes && De(c.options.allowDropFileTypes, J.type) == -1) {
                  k();
                  return;
                }
                var le = new FileReader();
                le.onerror = function() {
                  return k();
                }, le.onload = function() {
                  var pe = le.result;
                  if (/[\x00-\x08\x0e-\x1f]{2}/.test(pe)) {
                    k();
                    return;
                  }
                  S[ee] = pe, k();
                }, le.readAsText(J);
              }, _ = 0; _ < f.length; _++)
                D(f[_], _);
            else {
              if (c.state.draggingText && c.doc.sel.contains(p) > -1) {
                c.state.draggingText(o), setTimeout(function() {
                  return c.display.input.focus();
                }, 20);
                return;
              }
              try {
                var z = o.dataTransfer.getData("Text");
                if (z) {
                  var W;
                  if (c.state.draggingText && !c.state.draggingText.copy && (W = c.listSelections()), gd(c.doc, ts(p, p)), W)
                    for (var K = 0; K < W.length; ++K)
                      Fa(c.doc, "", W[K].anchor, W[K].head, "drag");
                  c.replaceSelection(z, "around", "paste"), c.display.input.focus();
                }
              } catch {
              }
            }
        }
      }
      function t_(o, c) {
        if (d && (!o.state.draggingText || +/* @__PURE__ */ new Date() - Ib < 100)) {
          Jr(c);
          return;
        }
        if (!(Ot(o, c) || yr(o.display, c)) && (c.dataTransfer.setData("Text", o.getSelection()), c.dataTransfer.effectAllowed = "copyMove", c.dataTransfer.setDragImage && !w)) {
          var p = B("img", null, null, "position: fixed; left: 0; top: 0;");
          p.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", C && (p.width = p.height = 1, o.display.wrapper.appendChild(p), p._top = p.offsetTop), c.dataTransfer.setDragImage(p, 0, 0), C && p.parentNode.removeChild(p);
        }
      }
      function n_(o, c) {
        var p = Ms(o, c);
        if (p) {
          var f = document.createDocumentFragment();
          vf(o, p, f), o.display.dragCursor || (o.display.dragCursor = B("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), o.display.lineSpace.insertBefore(o.display.dragCursor, o.display.cursorDiv)), $(o.display.dragCursor, f);
        }
      }
      function Pb(o) {
        o.display.dragCursor && (o.display.lineSpace.removeChild(o.display.dragCursor), o.display.dragCursor = null);
      }
      function Rb(o) {
        if (document.getElementsByClassName) {
          for (var c = document.getElementsByClassName("CodeMirror"), p = [], f = 0; f < c.length; f++) {
            var m = c[f].CodeMirror;
            m && p.push(m);
          }
          p.length && p[0].operation(function() {
            for (var S = 0; S < p.length; S++)
              o(p[S]);
          });
        }
      }
      var Ab = false;
      function i_() {
        Ab || (r_(), Ab = true);
      }
      function r_() {
        var o;
        $e(window, "resize", function() {
          o == null && (o = setTimeout(function() {
            o = null, Rb(s_);
          }, 100));
        }), $e(window, "blur", function() {
          return Rb(_a);
        });
      }
      function s_(o) {
        var c = o.display;
        c.cachedCharWidth = c.cachedTextHeight = c.cachedPaddingH = null, c.scrollbarsClipped = false, o.setSize();
      }
      for (var ss = {
        3: "Pause",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        145: "ScrollLock",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        224: "Mod",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      }, kl = 0; kl < 10; kl++)
        ss[kl + 48] = ss[kl + 96] = String(kl);
      for (var yd = 65; yd <= 90; yd++)
        ss[yd] = String.fromCharCode(yd);
      for (var Tl = 1; Tl <= 12; Tl++)
        ss[Tl + 111] = ss[Tl + 63235] = "F" + Tl;
      var br = {};
      br.basic = {
        Left: "goCharLeft",
        Right: "goCharRight",
        Up: "goLineUp",
        Down: "goLineDown",
        End: "goLineEnd",
        Home: "goLineStartSmart",
        PageUp: "goPageUp",
        PageDown: "goPageDown",
        Delete: "delCharAfter",
        Backspace: "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        Tab: "defaultTab",
        "Shift-Tab": "indentAuto",
        Enter: "newlineAndIndent",
        Insert: "toggleOverwrite",
        Esc: "singleSelection"
      }, br.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        fallthrough: "basic"
      }, br.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
      }, br.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        fallthrough: ["basic", "emacsy"]
      }, br.default = P ? br.macDefault : br.pcDefault;
      function a_(o) {
        var c = o.split(/-(?!$)/);
        o = c[c.length - 1];
        for (var p, f, m, S, x = 0; x < c.length - 1; x++) {
          var k = c[x];
          if (/^(cmd|meta|m)$/i.test(k))
            S = true;
          else if (/^a(lt)?$/i.test(k))
            p = true;
          else if (/^(c|ctrl|control)$/i.test(k))
            f = true;
          else if (/^s(hift)?$/i.test(k))
            m = true;
          else
            throw new Error("Unrecognized modifier name: " + k);
        }
        return p && (o = "Alt-" + o), f && (o = "Ctrl-" + o), S && (o = "Cmd-" + o), m && (o = "Shift-" + o), o;
      }
      function o_(o) {
        var c = {};
        for (var p in o)
          if (o.hasOwnProperty(p)) {
            var f = o[p];
            if (/^(name|fallthrough|(de|at)tach)$/.test(p))
              continue;
            if (f == "...") {
              delete o[p];
              continue;
            }
            for (var m = Je(p.split(" "), a_), S = 0; S < m.length; S++) {
              var x = void 0, k = void 0;
              S == m.length - 1 ? (k = m.join(" "), x = f) : (k = m.slice(0, S + 1).join(" "), x = "...");
              var D = c[k];
              if (!D)
                c[k] = x;
              else if (D != x)
                throw new Error("Inconsistent bindings for " + k);
            }
            delete o[p];
          }
        for (var _ in c)
          o[_] = c[_];
        return o;
      }
      function za(o, c, p, f) {
        c = Sd(c);
        var m = c.call ? c.call(o, f) : c[o];
        if (m === false)
          return "nothing";
        if (m === "...")
          return "multi";
        if (m != null && p(m))
          return "handled";
        if (c.fallthrough) {
          if (Object.prototype.toString.call(c.fallthrough) != "[object Array]")
            return za(o, c.fallthrough, p, f);
          for (var S = 0; S < c.fallthrough.length; S++) {
            var x = za(o, c.fallthrough[S], p, f);
            if (x)
              return x;
          }
        }
      }
      function _b(o) {
        var c = typeof o == "string" ? o : ss[o.keyCode];
        return c == "Ctrl" || c == "Alt" || c == "Shift" || c == "Mod";
      }
      function Mb(o, c, p) {
        var f = o;
        return c.altKey && f != "Alt" && (o = "Alt-" + o), (O ? c.metaKey : c.ctrlKey) && f != "Ctrl" && (o = "Ctrl-" + o), (O ? c.ctrlKey : c.metaKey) && f != "Mod" && (o = "Cmd-" + o), !p && c.shiftKey && f != "Shift" && (o = "Shift-" + o), o;
      }
      function Nb(o, c) {
        if (C && o.keyCode == 34 && o.char)
          return false;
        var p = ss[o.keyCode];
        return p == null || o.altGraphKey ? false : (o.keyCode == 3 && o.code && (p = o.code), Mb(p, o, c));
      }
      function Sd(o) {
        return typeof o == "string" ? br[o] : o;
      }
      function $a(o, c) {
        for (var p = o.doc.sel.ranges, f = [], m = 0; m < p.length; m++) {
          for (var S = c(p[m]); f.length && we(S.from, ye(f).to) <= 0; ) {
            var x = f.pop();
            if (we(x.from, S.from) < 0) {
              S.from = x.from;
              break;
            }
          }
          f.push(S);
        }
        Kn(o, function() {
          for (var k = f.length - 1; k >= 0; k--)
            Fa(o.doc, "", f[k].from, f[k].to, "+delete");
          Ma(o);
        });
      }
      function Mf(o, c, p) {
        var f = _t(o.text, c + p, p);
        return f < 0 || f > o.text.length ? null : f;
      }
      function Nf(o, c, p) {
        var f = Mf(o, c.ch, p);
        return f == null ? null : new Q(c.line, f, p < 0 ? "after" : "before");
      }
      function Of(o, c, p, f, m) {
        if (o) {
          c.doc.direction == "rtl" && (m = -m);
          var S = tt(p, c.doc.direction);
          if (S) {
            var x = m < 0 ? ye(S) : S[0], k = m < 0 == (x.level == 1), D = k ? "after" : "before", _;
            if (x.level > 0 || c.doc.direction == "rtl") {
              var z = Pa(c, p);
              _ = m < 0 ? p.text.length - 1 : 0;
              var W = Ki(c, z, _).top;
              _ = Pt(function(K) {
                return Ki(c, z, K).top == W;
              }, m < 0 == (x.level == 1) ? x.from : x.to - 1, _), D == "before" && (_ = Mf(p, _, 1));
            } else
              _ = m < 0 ? x.to : x.from;
            return new Q(f, _, D);
          }
        }
        return new Q(f, m < 0 ? p.text.length : 0, m < 0 ? "before" : "after");
      }
      function l_(o, c, p, f) {
        var m = tt(c, o.doc.direction);
        if (!m)
          return Nf(c, p, f);
        p.ch >= c.text.length ? (p.ch = c.text.length, p.sticky = "before") : p.ch <= 0 && (p.ch = 0, p.sticky = "after");
        var S = jr(m, p.ch, p.sticky), x = m[S];
        if (o.doc.direction == "ltr" && x.level % 2 == 0 && (f > 0 ? x.to > p.ch : x.from < p.ch))
          return Nf(c, p, f);
        var k = function(Se, Te) {
          return Mf(c, Se instanceof Q ? Se.ch : Se, Te);
        }, D, _ = function(Se) {
          return o.options.lineWrapping ? (D = D || Pa(o, c), U0(o, c, D, Se)) : { begin: 0, end: c.text.length };
        }, z = _(p.sticky == "before" ? k(p, -1) : p.ch);
        if (o.doc.direction == "rtl" || x.level == 1) {
          var W = x.level == 1 == f < 0, K = k(p, W ? 1 : -1);
          if (K != null && (W ? K <= x.to && K <= z.end : K >= x.from && K >= z.begin)) {
            var J = W ? "before" : "after";
            return new Q(p.line, K, J);
          }
        }
        var ee = function(Se, Te, be) {
          for (var Ie = function(Et, ln) {
            return ln ? new Q(p.line, k(Et, 1), "before") : new Q(p.line, Et, "after");
          }; Se >= 0 && Se < m.length; Se += Te) {
            var Ge = m[Se], Ue = Te > 0 == (Ge.level != 1), Qe = Ue ? be.begin : k(be.end, -1);
            if (Ge.from <= Qe && Qe < Ge.to || (Qe = Ue ? Ge.from : k(Ge.to, -1), be.begin <= Qe && Qe < be.end))
              return Ie(Qe, Ue);
          }
        }, le = ee(S + f, f, z);
        if (le)
          return le;
        var pe = f > 0 ? z.end : k(z.begin, -1);
        return pe != null && !(f > 0 && pe == c.text.length) && (le = ee(f > 0 ? 0 : m.length - 1, f, _(pe)), le) ? le : null;
      }
      var Ll = {
        selectAll: Sb,
        singleSelection: function(o) {
          return o.setSelection(o.getCursor("anchor"), o.getCursor("head"), At);
        },
        killLine: function(o) {
          return $a(o, function(c) {
            if (c.empty()) {
              var p = Be(o.doc, c.head.line).text.length;
              return c.head.ch == p && c.head.line < o.lastLine() ? { from: c.head, to: Q(c.head.line + 1, 0) } : { from: c.head, to: Q(c.head.line, p) };
            } else
              return { from: c.from(), to: c.to() };
          });
        },
        deleteLine: function(o) {
          return $a(o, function(c) {
            return {
              from: Q(c.from().line, 0),
              to: Ke(o.doc, Q(c.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function(o) {
          return $a(o, function(c) {
            return {
              from: Q(c.from().line, 0),
              to: c.from()
            };
          });
        },
        delWrappedLineLeft: function(o) {
          return $a(o, function(c) {
            var p = o.charCoords(c.head, "div").top + 5, f = o.coordsChar({ left: 0, top: p }, "div");
            return { from: f, to: c.from() };
          });
        },
        delWrappedLineRight: function(o) {
          return $a(o, function(c) {
            var p = o.charCoords(c.head, "div").top + 5, f = o.coordsChar({ left: o.display.lineDiv.offsetWidth + 100, top: p }, "div");
            return { from: c.from(), to: f };
          });
        },
        undo: function(o) {
          return o.undo();
        },
        redo: function(o) {
          return o.redo();
        },
        undoSelection: function(o) {
          return o.undoSelection();
        },
        redoSelection: function(o) {
          return o.redoSelection();
        },
        goDocStart: function(o) {
          return o.extendSelection(Q(o.firstLine(), 0));
        },
        goDocEnd: function(o) {
          return o.extendSelection(Q(o.lastLine()));
        },
        goLineStart: function(o) {
          return o.extendSelectionsBy(
            function(c) {
              return Ob(o, c.head.line);
            },
            { origin: "+move", bias: 1 }
          );
        },
        goLineStartSmart: function(o) {
          return o.extendSelectionsBy(
            function(c) {
              return Vb(o, c.head);
            },
            { origin: "+move", bias: 1 }
          );
        },
        goLineEnd: function(o) {
          return o.extendSelectionsBy(
            function(c) {
              return c_(o, c.head.line);
            },
            { origin: "+move", bias: -1 }
          );
        },
        goLineRight: function(o) {
          return o.extendSelectionsBy(function(c) {
            var p = o.cursorCoords(c.head, "div").top + 5;
            return o.coordsChar({ left: o.display.lineDiv.offsetWidth + 100, top: p }, "div");
          }, ne);
        },
        goLineLeft: function(o) {
          return o.extendSelectionsBy(function(c) {
            var p = o.cursorCoords(c.head, "div").top + 5;
            return o.coordsChar({ left: 0, top: p }, "div");
          }, ne);
        },
        goLineLeftSmart: function(o) {
          return o.extendSelectionsBy(function(c) {
            var p = o.cursorCoords(c.head, "div").top + 5, f = o.coordsChar({ left: 0, top: p }, "div");
            return f.ch < o.getLine(f.line).search(/\S/) ? Vb(o, c.head) : f;
          }, ne);
        },
        goLineUp: function(o) {
          return o.moveV(-1, "line");
        },
        goLineDown: function(o) {
          return o.moveV(1, "line");
        },
        goPageUp: function(o) {
          return o.moveV(-1, "page");
        },
        goPageDown: function(o) {
          return o.moveV(1, "page");
        },
        goCharLeft: function(o) {
          return o.moveH(-1, "char");
        },
        goCharRight: function(o) {
          return o.moveH(1, "char");
        },
        goColumnLeft: function(o) {
          return o.moveH(-1, "column");
        },
        goColumnRight: function(o) {
          return o.moveH(1, "column");
        },
        goWordLeft: function(o) {
          return o.moveH(-1, "word");
        },
        goGroupRight: function(o) {
          return o.moveH(1, "group");
        },
        goGroupLeft: function(o) {
          return o.moveH(-1, "group");
        },
        goWordRight: function(o) {
          return o.moveH(1, "word");
        },
        delCharBefore: function(o) {
          return o.deleteH(-1, "codepoint");
        },
        delCharAfter: function(o) {
          return o.deleteH(1, "char");
        },
        delWordBefore: function(o) {
          return o.deleteH(-1, "word");
        },
        delWordAfter: function(o) {
          return o.deleteH(1, "word");
        },
        delGroupBefore: function(o) {
          return o.deleteH(-1, "group");
        },
        delGroupAfter: function(o) {
          return o.deleteH(1, "group");
        },
        indentAuto: function(o) {
          return o.indentSelection("smart");
        },
        indentMore: function(o) {
          return o.indentSelection("add");
        },
        indentLess: function(o) {
          return o.indentSelection("subtract");
        },
        insertTab: function(o) {
          return o.replaceSelection("	");
        },
        insertSoftTab: function(o) {
          for (var c = [], p = o.listSelections(), f = o.options.tabSize, m = 0; m < p.length; m++) {
            var S = p[m].from(), x = qe(o.getLine(S.line), S.ch, f);
            c.push(ke(f - x % f));
          }
          o.replaceSelections(c);
        },
        defaultTab: function(o) {
          o.somethingSelected() ? o.indentSelection("add") : o.execCommand("insertTab");
        },
        // Swap the two chars left and right of each selection's head.
        // Move cursor behind the two swapped characters afterwards.
        //
        // Doesn't consider line feeds a character.
        // Doesn't scan more than one line above to find a character.
        // Doesn't do anything on an empty line.
        // Doesn't do anything with non-empty selections.
        transposeChars: function(o) {
          return Kn(o, function() {
            for (var c = o.listSelections(), p = [], f = 0; f < c.length; f++)
              if (c[f].empty()) {
                var m = c[f].head, S = Be(o.doc, m.line).text;
                if (S) {
                  if (m.ch == S.length && (m = new Q(m.line, m.ch - 1)), m.ch > 0)
                    m = new Q(m.line, m.ch + 1), o.replaceRange(
                      S.charAt(m.ch - 1) + S.charAt(m.ch - 2),
                      Q(m.line, m.ch - 2),
                      m,
                      "+transpose"
                    );
                  else if (m.line > o.doc.first) {
                    var x = Be(o.doc, m.line - 1).text;
                    x && (m = new Q(m.line, 1), o.replaceRange(
                      S.charAt(0) + o.doc.lineSeparator() + x.charAt(x.length - 1),
                      Q(m.line - 1, x.length - 1),
                      m,
                      "+transpose"
                    ));
                  }
                }
                p.push(new ht(m, m));
              }
            o.setSelections(p);
          });
        },
        newlineAndIndent: function(o) {
          return Kn(o, function() {
            for (var c = o.listSelections(), p = c.length - 1; p >= 0; p--)
              o.replaceRange(o.doc.lineSeparator(), c[p].anchor, c[p].head, "+input");
            c = o.listSelections();
            for (var f = 0; f < c.length; f++)
              o.indentLine(c[f].from().line, null, true);
            Ma(o);
          });
        },
        openLine: function(o) {
          return o.replaceSelection(`
`, "start");
        },
        toggleOverwrite: function(o) {
          return o.toggleOverwrite();
        }
      };
      function Ob(o, c) {
        var p = Be(o.doc, c), f = Ri(p);
        return f != p && (c = N(f)), Of(true, o, f, c, 1);
      }
      function c_(o, c) {
        var p = Be(o.doc, c), f = qR(p);
        return f != p && (c = N(f)), Of(true, o, p, c, -1);
      }
      function Vb(o, c) {
        var p = Ob(o, c.line), f = Be(o.doc, p.line), m = tt(f, o.doc.direction);
        if (!m || m[0].level == 0) {
          var S = Math.max(p.ch, f.text.search(/\S/)), x = c.line == p.line && c.ch <= S && c.ch;
          return Q(p.line, x ? 0 : S, p.sticky);
        }
        return p;
      }
      function bd(o, c, p) {
        if (typeof c == "string" && (c = Ll[c], !c))
          return false;
        o.display.input.ensurePolled();
        var f = o.display.shift, m = false;
        try {
          o.isReadOnly() && (o.state.suppressEdits = true), p && (o.display.shift = false), m = c(o) != $t;
        } finally {
          o.display.shift = f, o.state.suppressEdits = false;
        }
        return m;
      }
      function d_(o, c, p) {
        for (var f = 0; f < o.state.keyMaps.length; f++) {
          var m = za(c, o.state.keyMaps[f], p, o);
          if (m)
            return m;
        }
        return o.options.extraKeys && za(c, o.options.extraKeys, p, o) || za(c, o.options.keyMap, p, o);
      }
      var u_ = new We();
      function Dl(o, c, p, f) {
        var m = o.state.keySeq;
        if (m) {
          if (_b(c))
            return "handled";
          if (/\'$/.test(c) ? o.state.keySeq = null : u_.set(50, function() {
            o.state.keySeq == m && (o.state.keySeq = null, o.display.input.reset());
          }), Bb(o, m + " " + c, p, f))
            return true;
        }
        return Bb(o, c, p, f);
      }
      function Bb(o, c, p, f) {
        var m = d_(o, c, f);
        return m == "multi" && (o.state.keySeq = c), m == "handled" && sn(o, "keyHandled", o, c, p), (m == "handled" || m == "multi") && (bn(p), yf(o)), !!m;
      }
      function Fb(o, c) {
        var p = Nb(c, true);
        return p ? c.shiftKey && !o.state.keySeq ? Dl(o, "Shift-" + p, c, function(f) {
          return bd(o, f, true);
        }) || Dl(o, p, c, function(f) {
          if (typeof f == "string" ? /^go[A-Z]/.test(f) : f.motion)
            return bd(o, f);
        }) : Dl(o, p, c, function(f) {
          return bd(o, f);
        }) : false;
      }
      function h_(o, c, p) {
        return Dl(o, "'" + p + "'", c, function(f) {
          return bd(o, f, true);
        });
      }
      var Vf = null;
      function Ub(o) {
        var c = this;
        if (!(o.target && o.target != c.display.input.getField()) && (c.curOp.focus = ae(Me(c)), !Ot(c, o))) {
          d && u < 11 && o.keyCode == 27 && (o.returnValue = false);
          var p = o.keyCode;
          c.display.shift = p == 16 || o.shiftKey;
          var f = Fb(c, o);
          C && (Vf = f ? p : null, !f && p == 88 && !Jc && (P ? o.metaKey : o.ctrlKey) && c.replaceSelection("", null, "cut")), r && !P && !f && p == 46 && o.shiftKey && !o.ctrlKey && document.execCommand && document.execCommand("cut"), p == 18 && !/\bCodeMirror-crosshair\b/.test(c.display.lineDiv.className) && f_(c);
        }
      }
      function f_(o) {
        var c = o.display.lineDiv;
        Ee(c, "CodeMirror-crosshair");
        function p(f) {
          (f.keyCode == 18 || !f.altKey) && (U(c, "CodeMirror-crosshair"), Sn(document, "keyup", p), Sn(document, "mouseover", p));
        }
        $e(document, "keyup", p), $e(document, "mouseover", p);
      }
      function zb(o) {
        o.keyCode == 16 && (this.doc.sel.shift = false), Ot(this, o);
      }
      function $b(o) {
        var c = this;
        if (!(o.target && o.target != c.display.input.getField()) && !(yr(c.display, o) || Ot(c, o) || o.ctrlKey && !o.altKey || P && o.metaKey)) {
          var p = o.keyCode, f = o.charCode;
          if (C && p == Vf) {
            Vf = null, bn(o);
            return;
          }
          if (!(C && (!o.which || o.which < 10) && Fb(c, o))) {
            var m = String.fromCharCode(f ?? p);
            m != "\b" && (h_(c, o, m) || c.display.input.onKeyPress(o));
          }
        }
      }
      var p_ = 400, Bf = function(o, c, p) {
        this.time = o, this.pos = c, this.button = p;
      };
      Bf.prototype.compare = function(o, c, p) {
        return this.time + p_ > o && we(c, this.pos) == 0 && p == this.button;
      };
      var Il, Pl;
      function g_(o, c) {
        var p = +/* @__PURE__ */ new Date();
        return Pl && Pl.compare(p, o, c) ? (Il = Pl = null, "triple") : Il && Il.compare(p, o, c) ? (Pl = new Bf(p, o, c), Il = null, "double") : (Il = new Bf(p, o, c), Pl = null, "single");
      }
      function Gb(o) {
        var c = this, p = c.display;
        if (!(Ot(c, o) || p.activeTouch && p.input.supportsTouch())) {
          if (p.input.ensurePolled(), p.shift = o.shiftKey, yr(p, o)) {
            h || (p.scroller.draggable = false, setTimeout(function() {
              return p.scroller.draggable = true;
            }, 100));
            return;
          }
          if (!Ff(c, o)) {
            var f = Ms(c, o), m = Li(o), S = f ? g_(f, m) : "single";
            Oe(c).focus(), m == 1 && c.state.selectingText && c.state.selectingText(o), !(f && m_(c, m, f, S, o)) && (m == 1 ? f ? y_(c, f, S, o) : tl(o) == p.scroller && bn(o) : m == 2 ? (f && pd(c.doc, f), setTimeout(function() {
              return p.input.focus();
            }, 20)) : m == 3 && (F ? c.display.input.onContextMenu(o) : Sf(c)));
          }
        }
      }
      function m_(o, c, p, f, m) {
        var S = "Click";
        return f == "double" ? S = "Double" + S : f == "triple" && (S = "Triple" + S), S = (c == 1 ? "Left" : c == 2 ? "Middle" : "Right") + S, Dl(o, Mb(S, m), m, function(x) {
          if (typeof x == "string" && (x = Ll[x]), !x)
            return false;
          var k = false;
          try {
            o.isReadOnly() && (o.state.suppressEdits = true), k = x(o, p) != $t;
          } finally {
            o.state.suppressEdits = false;
          }
          return k;
        });
      }
      function v_(o, c, p) {
        var f = o.getOption("configureMouse"), m = f ? f(o, c, p) : {};
        if (m.unit == null) {
          var S = L ? p.shiftKey && p.metaKey : p.altKey;
          m.unit = S ? "rectangle" : c == "single" ? "char" : c == "double" ? "word" : "line";
        }
        return (m.extend == null || o.doc.extend) && (m.extend = o.doc.extend || p.shiftKey), m.addNew == null && (m.addNew = P ? p.metaKey : p.ctrlKey), m.moveOnDrag == null && (m.moveOnDrag = !(P ? p.altKey : p.ctrlKey)), m;
      }
      function y_(o, c, p, f) {
        d ? setTimeout(Re(W0, o), 0) : o.curOp.focus = ae(Me(o));
        var m = v_(o, p, f), S = o.doc.sel, x;
        o.options.dragDrop && Yh && !o.isReadOnly() && p == "single" && (x = S.contains(c)) > -1 && (we((x = S.ranges[x]).from(), c) < 0 || c.xRel > 0) && (we(x.to(), c) > 0 || c.xRel < 0) ? S_(o, f, c, m) : b_(o, f, c, m);
      }
      function S_(o, c, p, f) {
        var m = o.display, S = false, x = an(o, function(_) {
          h && (m.scroller.draggable = false), o.state.draggingText = false, o.state.delayingBlurEvent && (o.hasFocus() ? o.state.delayingBlurEvent = false : Sf(o)), Sn(m.wrapper.ownerDocument, "mouseup", x), Sn(m.wrapper.ownerDocument, "mousemove", k), Sn(m.scroller, "dragstart", D), Sn(m.scroller, "drop", x), S || (bn(_), f.addNew || pd(o.doc, p, null, null, f.extend), h && !w || d && u == 9 ? setTimeout(function() {
            m.wrapper.ownerDocument.body.focus({ preventScroll: true }), m.input.focus();
          }, 20) : m.input.focus());
        }), k = function(_) {
          S = S || Math.abs(c.clientX - _.clientX) + Math.abs(c.clientY - _.clientY) >= 10;
        }, D = function() {
          return S = true;
        };
        h && (m.scroller.draggable = true), o.state.draggingText = x, x.copy = !f.moveOnDrag, $e(m.wrapper.ownerDocument, "mouseup", x), $e(m.wrapper.ownerDocument, "mousemove", k), $e(m.scroller, "dragstart", D), $e(m.scroller, "drop", x), o.state.delayingBlurEvent = true, setTimeout(function() {
          return m.input.focus();
        }, 20), m.scroller.dragDrop && m.scroller.dragDrop();
      }
      function Wb(o, c, p) {
        if (p == "char")
          return new ht(c, c);
        if (p == "word")
          return o.findWordAt(c);
        if (p == "line")
          return new ht(Q(c.line, 0), Ke(o.doc, Q(c.line + 1, 0)));
        var f = p(o, c);
        return new ht(f.from, f.to);
      }
      function b_(o, c, p, f) {
        d && Sf(o);
        var m = o.display, S = o.doc;
        bn(c);
        var x, k, D = S.sel, _ = D.ranges;
        if (f.addNew && !f.extend ? (k = S.sel.contains(p), k > -1 ? x = _[k] : x = new ht(p, p)) : (x = S.sel.primary(), k = S.sel.primIndex), f.unit == "rectangle")
          f.addNew || (x = new ht(p, p)), p = Ms(o, c, true, true), k = -1;
        else {
          var z = Wb(o, p, f.unit);
          f.extend ? x = Af(x, z.anchor, z.head, f.extend) : x = z;
        }
        f.addNew ? k == -1 ? (k = _.length, wn(
          S,
          _i(o, _.concat([x]), k),
          { scroll: false, origin: "*mouse" }
        )) : _.length > 1 && _[k].empty() && f.unit == "char" && !f.extend ? (wn(
          S,
          _i(o, _.slice(0, k).concat(_.slice(k + 1)), 0),
          { scroll: false, origin: "*mouse" }
        ), D = S.sel) : _f(S, k, x, Z) : (k = 0, wn(S, new ni([x], 0), Z), D = S.sel);
        var W = p;
        function K(be) {
          if (we(W, be) != 0)
            if (W = be, f.unit == "rectangle") {
              for (var Ie = [], Ge = o.options.tabSize, Ue = qe(Be(S, p.line).text, p.ch, Ge), Qe = qe(Be(S, be.line).text, be.ch, Ge), Et = Math.min(Ue, Qe), ln = Math.max(Ue, Qe), Mt = Math.min(p.line, be.line), Yn = Math.min(o.lastLine(), Math.max(p.line, be.line)); Mt <= Yn; Mt++) {
                var Fn = Be(S, Mt).text, Yt = te(Fn, Et, Ge);
                Et == ln ? Ie.push(new ht(Q(Mt, Yt), Q(Mt, Yt))) : Fn.length > Yt && Ie.push(new ht(Q(Mt, Yt), Q(Mt, te(Fn, ln, Ge))));
              }
              Ie.length || Ie.push(new ht(p, p)), wn(
                S,
                _i(o, D.ranges.slice(0, k).concat(Ie), k),
                { origin: "*mouse", scroll: false }
              ), o.scrollIntoView(be);
            } else {
              var Un = x, pn = Wb(o, be, f.unit), tn = Un.anchor, Xt;
              we(pn.anchor, tn) > 0 ? (Xt = pn.head, tn = La(Un.from(), pn.anchor)) : (Xt = pn.anchor, tn = On(Un.to(), pn.head));
              var Bt = D.ranges.slice(0);
              Bt[k] = w_(o, new ht(Ke(S, tn), Xt)), wn(S, _i(o, Bt, k), Z);
            }
        }
        var J = m.wrapper.getBoundingClientRect(), ee = 0;
        function le(be) {
          var Ie = ++ee, Ge = Ms(o, be, true, f.unit == "rectangle");
          if (Ge)
            if (we(Ge, W) != 0) {
              o.curOp.focus = ae(Me(o)), K(Ge);
              var Ue = ld(m, S);
              (Ge.line >= Ue.to || Ge.line < Ue.from) && setTimeout(an(o, function() {
                ee == Ie && le(be);
              }), 150);
            } else {
              var Qe = be.clientY < J.top ? -20 : be.clientY > J.bottom ? 20 : 0;
              Qe && setTimeout(an(o, function() {
                ee == Ie && (m.scroller.scrollTop += Qe, le(be));
              }), 50);
            }
        }
        function pe(be) {
          o.state.selectingText = false, ee = 1 / 0, be && (bn(be), m.input.focus()), Sn(m.wrapper.ownerDocument, "mousemove", Se), Sn(m.wrapper.ownerDocument, "mouseup", Te), S.history.lastSelOrigin = null;
        }
        var Se = an(o, function(be) {
          be.buttons === 0 || !Li(be) ? pe(be) : le(be);
        }), Te = an(o, pe);
        o.state.selectingText = Te, $e(m.wrapper.ownerDocument, "mousemove", Se), $e(m.wrapper.ownerDocument, "mouseup", Te);
      }
      function w_(o, c) {
        var p = c.anchor, f = c.head, m = Be(o.doc, p.line);
        if (we(p, f) == 0 && p.sticky == f.sticky)
          return c;
        var S = tt(m);
        if (!S)
          return c;
        var x = jr(S, p.ch, p.sticky), k = S[x];
        if (k.from != p.ch && k.to != p.ch)
          return c;
        var D = x + (k.from == p.ch == (k.level != 1) ? 0 : 1);
        if (D == 0 || D == S.length)
          return c;
        var _;
        if (f.line != p.line)
          _ = (f.line - p.line) * (o.doc.direction == "ltr" ? 1 : -1) > 0;
        else {
          var z = jr(S, f.ch, f.sticky), W = z - x || (f.ch - p.ch) * (k.level == 1 ? -1 : 1);
          z == D - 1 || z == D ? _ = W < 0 : _ = W > 0;
        }
        var K = S[D + (_ ? -1 : 0)], J = _ == (K.level == 1), ee = J ? K.from : K.to, le = J ? "after" : "before";
        return p.ch == ee && p.sticky == le ? c : new ht(new Q(p.line, ee, le), f);
      }
      function Hb(o, c, p, f) {
        var m, S;
        if (c.touches)
          m = c.touches[0].clientX, S = c.touches[0].clientY;
        else
          try {
            m = c.clientX, S = c.clientY;
          } catch {
            return false;
          }
        if (m >= Math.floor(o.display.gutters.getBoundingClientRect().right))
          return false;
        f && bn(c);
        var x = o.display, k = x.lineDiv.getBoundingClientRect();
        if (S > k.bottom || !Jn(o, p))
          return Nn(c);
        S -= k.top - x.viewOffset;
        for (var D = 0; D < o.display.gutterSpecs.length; ++D) {
          var _ = x.gutters.childNodes[D];
          if (_ && _.getBoundingClientRect().right >= m) {
            var z = G(o.doc, S), W = o.display.gutterSpecs[D];
            return Nt(o, p, o, z, W.className, c), Nn(c);
          }
        }
      }
      function Ff(o, c) {
        return Hb(o, c, "gutterClick", true);
      }
      function qb(o, c) {
        yr(o.display, c) || C_(o, c) || Ot(o, c, "contextmenu") || F || o.display.input.onContextMenu(c);
      }
      function C_(o, c) {
        return Jn(o, "gutterContextMenu") ? Hb(o, c, "gutterContextMenu", false) : false;
      }
      function jb(o) {
        o.display.wrapper.className = o.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + o.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), dl(o);
      }
      var Ga = { toString: function() {
        return "CodeMirror.Init";
      } }, Jb = {}, wd = {};
      function x_(o) {
        var c = o.optionHandlers;
        function p(f, m, S, x) {
          o.defaults[f] = m, S && (c[f] = x ? function(k, D, _) {
            _ != Ga && S(k, D, _);
          } : S);
        }
        o.defineOption = p, o.Init = Ga, p("value", "", function(f, m) {
          return f.setValue(m);
        }, true), p("mode", null, function(f, m) {
          f.doc.modeOption = m, If(f);
        }, true), p("indentUnit", 2, If, true), p("indentWithTabs", false), p("smartIndent", true), p("tabSize", 4, function(f) {
          yl(f), dl(f), Vn(f);
        }, true), p("lineSeparator", null, function(f, m) {
          if (f.doc.lineSep = m, !!m) {
            var S = [], x = f.doc.first;
            f.doc.iter(function(D) {
              for (var _ = 0; ; ) {
                var z = D.text.indexOf(m, _);
                if (z == -1)
                  break;
                _ = z + m.length, S.push(Q(x, z));
              }
              x++;
            });
            for (var k = S.length - 1; k >= 0; k--)
              Fa(f.doc, m, S[k], Q(S[k].line, S[k].ch + m.length));
          }
        }), p("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function(f, m, S) {
          f.state.specialChars = new RegExp(m.source + (m.test("	") ? "" : "|	"), "g"), S != Ga && f.refresh();
        }), p("specialCharPlaceholder", ZR, function(f) {
          return f.refresh();
        }, true), p("electricChars", true), p("inputStyle", R ? "contenteditable" : "textarea", function() {
          throw new Error("inputStyle can not (yet) be changed in a running editor");
        }, true), p("spellcheck", false, function(f, m) {
          return f.getInputField().spellcheck = m;
        }, true), p("autocorrect", false, function(f, m) {
          return f.getInputField().autocorrect = m;
        }, true), p("autocapitalize", false, function(f, m) {
          return f.getInputField().autocapitalize = m;
        }, true), p("rtlMoveVisually", !A), p("wholeLineUpdateBefore", true), p("theme", "default", function(f) {
          jb(f), vl(f);
        }, true), p("keyMap", "default", function(f, m, S) {
          var x = Sd(m), k = S != Ga && Sd(S);
          k && k.detach && k.detach(f, x), x.attach && x.attach(f, k || null);
        }), p("extraKeys", null), p("configureMouse", null), p("lineWrapping", false, k_, true), p("gutters", [], function(f, m) {
          f.display.gutterSpecs = Lf(m, f.options.lineNumbers), vl(f);
        }, true), p("fixedGutter", true, function(f, m) {
          f.display.gutters.style.left = m ? gf(f.display) + "px" : "0", f.refresh();
        }, true), p("coverGutterNextToScrollbar", false, function(f) {
          return Na(f);
        }, true), p("scrollbarStyle", "native", function(f) {
          Y0(f), Na(f), f.display.scrollbars.setScrollTop(f.doc.scrollTop), f.display.scrollbars.setScrollLeft(f.doc.scrollLeft);
        }, true), p("lineNumbers", false, function(f, m) {
          f.display.gutterSpecs = Lf(f.options.gutters, m), vl(f);
        }, true), p("firstLineNumber", 1, vl, true), p("lineNumberFormatter", function(f) {
          return f;
        }, vl, true), p("showCursorWhenSelecting", false, ul, true), p("resetSelectionOnContextMenu", true), p("lineWiseCopyCut", true), p("pasteLinesPerSelection", true), p("selectionsMayTouch", false), p("readOnly", false, function(f, m) {
          m == "nocursor" && (_a(f), f.display.input.blur()), f.display.input.readOnlyChanged(m);
        }), p("screenReaderLabel", null, function(f, m) {
          m = m === "" ? null : m, f.display.input.screenReaderLabelChanged(m);
        }), p("disableInput", false, function(f, m) {
          m || f.display.input.reset();
        }, true), p("dragDrop", true, E_), p("allowDropFileTypes", null), p("cursorBlinkRate", 530), p("cursorScrollMargin", 0), p("cursorHeight", 1, ul, true), p("singleCursorHeightPerLine", true, ul, true), p("workTime", 100), p("workDelay", 100), p("flattenSpans", true, yl, true), p("addModeClass", false, yl, true), p("pollInterval", 100), p("undoDepth", 200, function(f, m) {
          return f.doc.history.undoDepth = m;
        }), p("historyEventDelay", 1250), p("viewportMargin", 10, function(f) {
          return f.refresh();
        }, true), p("maxHighlightLength", 1e4, yl, true), p("moveInputWithCursor", true, function(f, m) {
          m || f.display.input.resetPosition();
        }), p("tabindex", null, function(f, m) {
          return f.display.input.getField().tabIndex = m || "";
        }), p("autofocus", null), p("direction", "ltr", function(f, m) {
          return f.doc.setDirection(m);
        }, true), p("phrases", null);
      }
      function E_(o, c, p) {
        var f = p && p != Ga;
        if (!c != !f) {
          var m = o.display.dragFunctions, S = c ? $e : Sn;
          S(o.display.scroller, "dragstart", m.start), S(o.display.scroller, "dragenter", m.enter), S(o.display.scroller, "dragover", m.over), S(o.display.scroller, "dragleave", m.leave), S(o.display.scroller, "drop", m.drop);
        }
      }
      function k_(o) {
        o.options.lineWrapping ? (Ee(o.display.wrapper, "CodeMirror-wrap"), o.display.sizer.style.minWidth = "", o.display.sizerWidth = null) : (U(o.display.wrapper, "CodeMirror-wrap"), sf(o)), mf(o), Vn(o), dl(o), setTimeout(function() {
          return Na(o);
        }, 100);
      }
      function Rt(o, c) {
        var p = this;
        if (!(this instanceof Rt))
          return new Rt(o, c);
        this.options = c = c ? Ve(c) : {}, Ve(Jb, c, false);
        var f = c.value;
        typeof f == "string" ? f = new Bn(f, c.mode, null, c.lineSeparator, c.direction) : c.mode && (f.modeOption = c.mode), this.doc = f;
        var m = new Rt.inputStyles[c.inputStyle](this), S = this.display = new BA(o, f, m, c);
        S.wrapper.CodeMirror = this, jb(this), c.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), Y0(this), this.state = {
          keyMaps: [],
          // stores maps added by addKeyMap
          overlays: [],
          // highlighting overlays, as added by addOverlay
          modeGen: 0,
          // bumped when mode/overlay changes, used to invalidate highlighting info
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false,
          // used to disable editing during key handlers when in readOnly mode
          pasteIncoming: -1,
          cutIncoming: -1,
          // help recognize paste/cut edits in input.poll
          selectingText: false,
          draggingText: false,
          highlight: new We(),
          // stores highlight worker timeout
          keySeq: null,
          // Unfinished key sequence
          specialChars: null
        }, c.autofocus && !R && S.input.focus(), d && u < 11 && setTimeout(function() {
          return p.display.input.reset(true);
        }, 20), T_(this), i_(), Bs(this), this.curOp.forceUpdate = true, ab(this, f), c.autofocus && !R || this.hasFocus() ? setTimeout(function() {
          p.hasFocus() && !p.state.focused && bf(p);
        }, 20) : _a(this);
        for (var x in wd)
          wd.hasOwnProperty(x) && wd[x](this, c[x], Ga);
        Q0(this), c.finishInit && c.finishInit(this);
        for (var k = 0; k < Uf.length; ++k)
          Uf[k](this);
        Fs(this), h && c.lineWrapping && getComputedStyle(S.lineDiv).textRendering == "optimizelegibility" && (S.lineDiv.style.textRendering = "auto");
      }
      Rt.defaults = Jb, Rt.optionHandlers = wd;
      function T_(o) {
        var c = o.display;
        $e(c.scroller, "mousedown", an(o, Gb)), d && u < 11 ? $e(c.scroller, "dblclick", an(o, function(D) {
          if (!Ot(o, D)) {
            var _ = Ms(o, D);
            if (!(!_ || Ff(o, D) || yr(o.display, D))) {
              bn(D);
              var z = o.findWordAt(_);
              pd(o.doc, z.anchor, z.head);
            }
          }
        })) : $e(c.scroller, "dblclick", function(D) {
          return Ot(o, D) || bn(D);
        }), $e(c.scroller, "contextmenu", function(D) {
          return qb(o, D);
        }), $e(c.input.getField(), "contextmenu", function(D) {
          c.scroller.contains(D.target) || qb(o, D);
        });
        var p, f = { end: 0 };
        function m() {
          c.activeTouch && (p = setTimeout(function() {
            return c.activeTouch = null;
          }, 1e3), f = c.activeTouch, f.end = +/* @__PURE__ */ new Date());
        }
        function S(D) {
          if (D.touches.length != 1)
            return false;
          var _ = D.touches[0];
          return _.radiusX <= 1 && _.radiusY <= 1;
        }
        function x(D, _) {
          if (_.left == null)
            return true;
          var z = _.left - D.left, W = _.top - D.top;
          return z * z + W * W > 20 * 20;
        }
        $e(c.scroller, "touchstart", function(D) {
          if (!Ot(o, D) && !S(D) && !Ff(o, D)) {
            c.input.ensurePolled(), clearTimeout(p);
            var _ = +/* @__PURE__ */ new Date();
            c.activeTouch = {
              start: _,
              moved: false,
              prev: _ - f.end <= 300 ? f : null
            }, D.touches.length == 1 && (c.activeTouch.left = D.touches[0].pageX, c.activeTouch.top = D.touches[0].pageY);
          }
        }), $e(c.scroller, "touchmove", function() {
          c.activeTouch && (c.activeTouch.moved = true);
        }), $e(c.scroller, "touchend", function(D) {
          var _ = c.activeTouch;
          if (_ && !yr(c, D) && _.left != null && !_.moved && /* @__PURE__ */ new Date() - _.start < 300) {
            var z = o.coordsChar(c.activeTouch, "page"), W;
            !_.prev || x(_, _.prev) ? W = new ht(z, z) : !_.prev.prev || x(_, _.prev.prev) ? W = o.findWordAt(z) : W = new ht(Q(z.line, 0), Ke(o.doc, Q(z.line + 1, 0))), o.setSelection(W.anchor, W.head), o.focus(), bn(D);
          }
          m();
        }), $e(c.scroller, "touchcancel", m), $e(c.scroller, "scroll", function() {
          c.scroller.clientHeight && (fl(o, c.scroller.scrollTop), Os(o, c.scroller.scrollLeft, true), Nt(o, "scroll", o));
        }), $e(c.scroller, "mousewheel", function(D) {
          return nb(o, D);
        }), $e(c.scroller, "DOMMouseScroll", function(D) {
          return nb(o, D);
        }), $e(c.wrapper, "scroll", function() {
          return c.wrapper.scrollTop = c.wrapper.scrollLeft = 0;
        }), c.dragFunctions = {
          enter: function(D) {
            Ot(o, D) || Jr(D);
          },
          over: function(D) {
            Ot(o, D) || (n_(o, D), Jr(D));
          },
          start: function(D) {
            return t_(o, D);
          },
          drop: an(o, e_),
          leave: function(D) {
            Ot(o, D) || Pb(o);
          }
        };
        var k = c.input.getField();
        $e(k, "keyup", function(D) {
          return zb.call(o, D);
        }), $e(k, "keydown", an(o, Ub)), $e(k, "keypress", an(o, $b)), $e(k, "focus", function(D) {
          return bf(o, D);
        }), $e(k, "blur", function(D) {
          return _a(o, D);
        });
      }
      var Uf = [];
      Rt.defineInitHook = function(o) {
        return Uf.push(o);
      };
      function Rl(o, c, p, f) {
        var m = o.doc, S;
        p == null && (p = "add"), p == "smart" && (m.mode.indent ? S = sl(o, c).state : p = "prev");
        var x = o.options.tabSize, k = Be(m, c), D = qe(k.text, null, x);
        k.stateAfter && (k.stateAfter = null);
        var _ = k.text.match(/^\s*/)[0], z;
        if (!f && !/\S/.test(k.text))
          z = 0, p = "not";
        else if (p == "smart" && (z = m.mode.indent(S, k.text.slice(_.length), k.text), z == $t || z > 150)) {
          if (!f)
            return;
          p = "prev";
        }
        p == "prev" ? c > m.first ? z = qe(Be(m, c - 1).text, null, x) : z = 0 : p == "add" ? z = D + o.options.indentUnit : p == "subtract" ? z = D - o.options.indentUnit : typeof p == "number" && (z = D + p), z = Math.max(0, z);
        var W = "", K = 0;
        if (o.options.indentWithTabs)
          for (var J = Math.floor(z / x); J; --J)
            K += x, W += "	";
        if (K < z && (W += ke(z - K)), W != _)
          return Fa(m, W, Q(c, 0), Q(c, _.length), "+input"), k.stateAfter = null, true;
        for (var ee = 0; ee < m.sel.ranges.length; ee++) {
          var le = m.sel.ranges[ee];
          if (le.head.line == c && le.head.ch < _.length) {
            var pe = Q(c, _.length);
            _f(m, ee, new ht(pe, pe));
            break;
          }
        }
      }
      var Mi = null;
      function Cd(o) {
        Mi = o;
      }
      function zf(o, c, p, f, m) {
        var S = o.doc;
        o.display.shift = false, f || (f = S.sel);
        var x = +/* @__PURE__ */ new Date() - 200, k = m == "paste" || o.state.pasteIncoming > x, D = ui(c), _ = null;
        if (k && f.ranges.length > 1)
          if (Mi && Mi.text.join(`
`) == c) {
            if (f.ranges.length % Mi.text.length == 0) {
              _ = [];
              for (var z = 0; z < Mi.text.length; z++)
                _.push(S.splitLines(Mi.text[z]));
            }
          } else D.length == f.ranges.length && o.options.pasteLinesPerSelection && (_ = Je(D, function(Se) {
            return [Se];
          }));
        for (var W = o.curOp.updateInput, K = f.ranges.length - 1; K >= 0; K--) {
          var J = f.ranges[K], ee = J.from(), le = J.to();
          J.empty() && (p && p > 0 ? ee = Q(ee.line, ee.ch - p) : o.state.overwrite && !k ? le = Q(le.line, Math.min(Be(S, le.line).text.length, le.ch + ye(D).length)) : k && Mi && Mi.lineWise && Mi.text.join(`
`) == D.join(`
`) && (ee = le = Q(ee.line, 0)));
          var pe = {
            from: ee,
            to: le,
            text: _ ? _[K % _.length] : D,
            origin: m || (k ? "paste" : o.state.cutIncoming > x ? "cut" : "+input")
          };
          Ba(o.doc, pe), sn(o, "inputRead", o, pe);
        }
        c && !k && Yb(o, c), Ma(o), o.curOp.updateInput < 2 && (o.curOp.updateInput = W), o.curOp.typing = true, o.state.pasteIncoming = o.state.cutIncoming = -1;
      }
      function Kb(o, c) {
        var p = o.clipboardData && o.clipboardData.getData("Text");
        if (p)
          return o.preventDefault(), !c.isReadOnly() && !c.options.disableInput && c.hasFocus() && Kn(c, function() {
            return zf(c, p, 0, null, "paste");
          }), true;
      }
      function Yb(o, c) {
        if (!(!o.options.electricChars || !o.options.smartIndent))
          for (var p = o.doc.sel, f = p.ranges.length - 1; f >= 0; f--) {
            var m = p.ranges[f];
            if (!(m.head.ch > 100 || f && p.ranges[f - 1].head.line == m.head.line)) {
              var S = o.getModeAt(m.head), x = false;
              if (S.electricChars) {
                for (var k = 0; k < S.electricChars.length; k++)
                  if (c.indexOf(S.electricChars.charAt(k)) > -1) {
                    x = Rl(o, m.head.line, "smart");
                    break;
                  }
              } else S.electricInput && S.electricInput.test(Be(o.doc, m.head.line).text.slice(0, m.head.ch)) && (x = Rl(o, m.head.line, "smart"));
              x && sn(o, "electricInput", o, m.head.line);
            }
          }
      }
      function Xb(o) {
        for (var c = [], p = [], f = 0; f < o.doc.sel.ranges.length; f++) {
          var m = o.doc.sel.ranges[f].head.line, S = { anchor: Q(m, 0), head: Q(m + 1, 0) };
          p.push(S), c.push(o.getRange(S.anchor, S.head));
        }
        return { text: c, ranges: p };
      }
      function $f(o, c, p, f) {
        o.setAttribute("autocorrect", p ? "on" : "off"), o.setAttribute("autocapitalize", f ? "on" : "off"), o.setAttribute("spellcheck", !!c);
      }
      function Zb() {
        var o = B("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none"), c = B("div", [o], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        return h ? o.style.width = "1000px" : o.setAttribute("wrap", "off"), T && (o.style.border = "1px solid black"), c;
      }
      function L_(o) {
        var c = o.optionHandlers, p = o.helpers = {};
        o.prototype = {
          constructor: o,
          focus: function() {
            Oe(this).focus(), this.display.input.focus();
          },
          setOption: function(f, m) {
            var S = this.options, x = S[f];
            S[f] == m && f != "mode" || (S[f] = m, c.hasOwnProperty(f) && an(this, c[f])(this, m, x), Nt(this, "optionChange", this, f));
          },
          getOption: function(f) {
            return this.options[f];
          },
          getDoc: function() {
            return this.doc;
          },
          addKeyMap: function(f, m) {
            this.state.keyMaps[m ? "push" : "unshift"](Sd(f));
          },
          removeKeyMap: function(f) {
            for (var m = this.state.keyMaps, S = 0; S < m.length; ++S)
              if (m[S] == f || m[S].name == f)
                return m.splice(S, 1), true;
          },
          addOverlay: kn(function(f, m) {
            var S = f.token ? f : o.getMode(this.options, f);
            if (S.startState)
              throw new Error("Overlays may not be stateful.");
            it(
              this.state.overlays,
              {
                mode: S,
                modeSpec: f,
                opaque: m && m.opaque,
                priority: m && m.priority || 0
              },
              function(x) {
                return x.priority;
              }
            ), this.state.modeGen++, Vn(this);
          }),
          removeOverlay: kn(function(f) {
            for (var m = this.state.overlays, S = 0; S < m.length; ++S) {
              var x = m[S].modeSpec;
              if (x == f || typeof f == "string" && x.name == f) {
                m.splice(S, 1), this.state.modeGen++, Vn(this);
                return;
              }
            }
          }),
          indentLine: kn(function(f, m, S) {
            typeof m != "string" && typeof m != "number" && (m == null ? m = this.options.smartIndent ? "smart" : "prev" : m = m ? "add" : "subtract"), ie(this.doc, f) && Rl(this, f, m, S);
          }),
          indentSelection: kn(function(f) {
            for (var m = this.doc.sel.ranges, S = -1, x = 0; x < m.length; x++) {
              var k = m[x];
              if (k.empty())
                k.head.line > S && (Rl(this, k.head.line, f, true), S = k.head.line, x == this.doc.sel.primIndex && Ma(this));
              else {
                var D = k.from(), _ = k.to(), z = Math.max(S, D.line);
                S = Math.min(this.lastLine(), _.line - (_.ch ? 0 : 1)) + 1;
                for (var W = z; W < S; ++W)
                  Rl(this, W, f);
                var K = this.doc.sel.ranges;
                D.ch == 0 && m.length == K.length && K[x].from().ch > 0 && _f(this.doc, x, new ht(D, K[x].to()), At);
              }
            }
          }),
          // Fetch the parser token for a given character. Useful for hacks
          // that want to inspect the mode state (say, for completion).
          getTokenAt: function(f, m) {
            return l0(this, f, m);
          },
          getLineTokens: function(f, m) {
            return l0(this, Q(f), m, true);
          },
          getTokenTypeAt: function(f) {
            f = Ke(this.doc, f);
            var m = s0(this, Be(this.doc, f.line)), S = 0, x = (m.length - 1) / 2, k = f.ch, D;
            if (k == 0)
              D = m[2];
            else
              for (; ; ) {
                var _ = S + x >> 1;
                if ((_ ? m[_ * 2 - 1] : 0) >= k)
                  x = _;
                else if (m[_ * 2 + 1] < k)
                  S = _ + 1;
                else {
                  D = m[_ * 2 + 2];
                  break;
                }
              }
            var z = D ? D.indexOf("overlay ") : -1;
            return z < 0 ? D : z == 0 ? null : D.slice(0, z - 1);
          },
          getModeAt: function(f) {
            var m = this.doc.mode;
            return m.innerMode ? o.innerMode(m, this.getTokenAt(f).state).mode : m;
          },
          getHelper: function(f, m) {
            return this.getHelpers(f, m)[0];
          },
          getHelpers: function(f, m) {
            var S = [];
            if (!p.hasOwnProperty(m))
              return S;
            var x = p[m], k = this.getModeAt(f);
            if (typeof k[m] == "string")
              x[k[m]] && S.push(x[k[m]]);
            else if (k[m])
              for (var D = 0; D < k[m].length; D++) {
                var _ = x[k[m][D]];
                _ && S.push(_);
              }
            else k.helperType && x[k.helperType] ? S.push(x[k.helperType]) : x[k.name] && S.push(x[k.name]);
            for (var z = 0; z < x._global.length; z++) {
              var W = x._global[z];
              W.pred(k, this) && De(S, W.val) == -1 && S.push(W.val);
            }
            return S;
          },
          getStateAfter: function(f, m) {
            var S = this.doc;
            return f = n0(S, f ?? S.first + S.size - 1), sl(this, f + 1, m).state;
          },
          cursorCoords: function(f, m) {
            var S, x = this.doc.sel.primary();
            return f == null ? S = x.head : typeof f == "object" ? S = Ke(this.doc, f) : S = f ? x.from() : x.to(), Ai(this, S, m || "page");
          },
          charCoords: function(f, m) {
            return rd(this, Ke(this.doc, f), m || "page");
          },
          coordsChar: function(f, m) {
            return f = V0(this, f, m || "page"), hf(this, f.left, f.top);
          },
          lineAtHeight: function(f, m) {
            return f = V0(this, { top: f, left: 0 }, m || "page").top, G(this.doc, f + this.display.viewOffset);
          },
          heightAtLine: function(f, m, S) {
            var x = false, k;
            if (typeof f == "number") {
              var D = this.doc.first + this.doc.size - 1;
              f < this.doc.first ? f = this.doc.first : f > D && (f = D, x = true), k = Be(this.doc, f);
            } else
              k = f;
            return id(this, k, { top: 0, left: 0 }, m || "page", S || x).top + (x ? this.doc.height - vr(k) : 0);
          },
          defaultTextHeight: function() {
            return Ra(this.display);
          },
          defaultCharWidth: function() {
            return Aa(this.display);
          },
          getViewport: function() {
            return { from: this.display.viewFrom, to: this.display.viewTo };
          },
          addWidget: function(f, m, S, x, k) {
            var D = this.display;
            f = Ai(this, Ke(this.doc, f));
            var _ = f.bottom, z = f.left;
            if (m.style.position = "absolute", m.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(m), D.sizer.appendChild(m), x == "over")
              _ = f.top;
            else if (x == "above" || x == "near") {
              var W = Math.max(D.wrapper.clientHeight, this.doc.height), K = Math.max(D.sizer.clientWidth, D.lineSpace.clientWidth);
              (x == "above" || f.bottom + m.offsetHeight > W) && f.top > m.offsetHeight ? _ = f.top - m.offsetHeight : f.bottom + m.offsetHeight <= W && (_ = f.bottom), z + m.offsetWidth > K && (z = K - m.offsetWidth);
            }
            m.style.top = _ + "px", m.style.left = m.style.right = "", k == "right" ? (z = D.sizer.clientWidth - m.offsetWidth, m.style.right = "0px") : (k == "left" ? z = 0 : k == "middle" && (z = (D.sizer.clientWidth - m.offsetWidth) / 2), m.style.left = z + "px"), S && EA(this, { left: z, top: _, right: z + m.offsetWidth, bottom: _ + m.offsetHeight });
          },
          triggerOnKeyDown: kn(Ub),
          triggerOnKeyPress: kn($b),
          triggerOnKeyUp: zb,
          triggerOnMouseDown: kn(Gb),
          execCommand: function(f) {
            if (Ll.hasOwnProperty(f))
              return Ll[f].call(null, this);
          },
          triggerElectric: kn(function(f) {
            Yb(this, f);
          }),
          findPosH: function(f, m, S, x) {
            var k = 1;
            m < 0 && (k = -1, m = -m);
            for (var D = Ke(this.doc, f), _ = 0; _ < m && (D = Gf(this.doc, D, k, S, x), !D.hitSide); ++_)
              ;
            return D;
          },
          moveH: kn(function(f, m) {
            var S = this;
            this.extendSelectionsBy(function(x) {
              return S.display.shift || S.doc.extend || x.empty() ? Gf(S.doc, x.head, f, m, S.options.rtlMoveVisually) : f < 0 ? x.from() : x.to();
            }, ne);
          }),
          deleteH: kn(function(f, m) {
            var S = this.doc.sel, x = this.doc;
            S.somethingSelected() ? x.replaceSelection("", null, "+delete") : $a(this, function(k) {
              var D = Gf(x, k.head, f, m, false);
              return f < 0 ? { from: D, to: k.head } : { from: k.head, to: D };
            });
          }),
          findPosV: function(f, m, S, x) {
            var k = 1, D = x;
            m < 0 && (k = -1, m = -m);
            for (var _ = Ke(this.doc, f), z = 0; z < m; ++z) {
              var W = Ai(this, _, "div");
              if (D == null ? D = W.left : W.left = D, _ = Qb(this, W, k, S), _.hitSide)
                break;
            }
            return _;
          },
          moveV: kn(function(f, m) {
            var S = this, x = this.doc, k = [], D = !this.display.shift && !x.extend && x.sel.somethingSelected();
            if (x.extendSelectionsBy(function(z) {
              if (D)
                return f < 0 ? z.from() : z.to();
              var W = Ai(S, z.head, "div");
              z.goalColumn != null && (W.left = z.goalColumn), k.push(W.left);
              var K = Qb(S, W, f, m);
              return m == "page" && z == x.sel.primary() && Cf(S, rd(S, K, "div").top - W.top), K;
            }, ne), k.length)
              for (var _ = 0; _ < x.sel.ranges.length; _++)
                x.sel.ranges[_].goalColumn = k[_];
          }),
          // Find the word at the given position (as returned by coordsChar).
          findWordAt: function(f) {
            var m = this.doc, S = Be(m, f.line).text, x = f.ch, k = f.ch;
            if (S) {
              var D = this.getHelper(f, "wordChars");
              (f.sticky == "before" || k == S.length) && x ? --x : ++k;
              for (var _ = S.charAt(x), z = mt(_, D) ? function(W) {
                return mt(W, D);
              } : /\s/.test(_) ? function(W) {
                return /\s/.test(W);
              } : function(W) {
                return !/\s/.test(W) && !mt(W);
              }; x > 0 && z(S.charAt(x - 1)); )
                --x;
              for (; k < S.length && z(S.charAt(k)); )
                ++k;
            }
            return new ht(Q(f.line, x), Q(f.line, k));
          },
          toggleOverwrite: function(f) {
            f != null && f == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? Ee(this.display.cursorDiv, "CodeMirror-overwrite") : U(this.display.cursorDiv, "CodeMirror-overwrite"), Nt(this, "overwriteToggle", this, this.state.overwrite));
          },
          hasFocus: function() {
            return this.display.input.getField() == ae(Me(this));
          },
          isReadOnly: function() {
            return !!(this.options.readOnly || this.doc.cantEdit);
          },
          scrollTo: kn(function(f, m) {
            hl(this, f, m);
          }),
          getScrollInfo: function() {
            var f = this.display.scroller;
            return {
              left: f.scrollLeft,
              top: f.scrollTop,
              height: f.scrollHeight - Ji(this) - this.display.barHeight,
              width: f.scrollWidth - Ji(this) - this.display.barWidth,
              clientHeight: lf(this),
              clientWidth: As(this)
            };
          },
          scrollIntoView: kn(function(f, m) {
            f == null ? (f = { from: this.doc.sel.primary().head, to: null }, m == null && (m = this.options.cursorScrollMargin)) : typeof f == "number" ? f = { from: Q(f, 0), to: null } : f.from == null && (f = { from: f, to: null }), f.to || (f.to = f.from), f.margin = m || 0, f.from.line != null ? kA(this, f) : q0(this, f.from, f.to, f.margin);
          }),
          setSize: kn(function(f, m) {
            var S = this, x = function(D) {
              return typeof D == "number" || /^\d+$/.test(String(D)) ? D + "px" : D;
            };
            f != null && (this.display.wrapper.style.width = x(f)), m != null && (this.display.wrapper.style.height = x(m)), this.options.lineWrapping && M0(this);
            var k = this.display.viewFrom;
            this.doc.iter(k, this.display.viewTo, function(D) {
              if (D.widgets) {
                for (var _ = 0; _ < D.widgets.length; _++)
                  if (D.widgets[_].noHScroll) {
                    Qr(S, k, "widget");
                    break;
                  }
              }
              ++k;
            }), this.curOp.forceUpdate = true, Nt(this, "refresh", this);
          }),
          operation: function(f) {
            return Kn(this, f);
          },
          startOperation: function() {
            return Bs(this);
          },
          endOperation: function() {
            return Fs(this);
          },
          refresh: kn(function() {
            var f = this.display.cachedTextHeight;
            Vn(this), this.curOp.forceUpdate = true, dl(this), hl(this, this.doc.scrollLeft, this.doc.scrollTop), kf(this.display), (f == null || Math.abs(f - Ra(this.display)) > 0.5 || this.options.lineWrapping) && mf(this), Nt(this, "refresh", this);
          }),
          swapDoc: kn(function(f) {
            var m = this.doc;
            return m.cm = null, this.state.selectingText && this.state.selectingText(), ab(this, f), dl(this), this.display.input.reset(), hl(this, f.scrollLeft, f.scrollTop), this.curOp.forceScroll = true, sn(this, "swapDoc", this, m), m;
          }),
          phrase: function(f) {
            var m = this.options.phrases;
            return m && Object.prototype.hasOwnProperty.call(m, f) ? m[f] : f;
          },
          getInputField: function() {
            return this.display.input.getField();
          },
          getWrapperElement: function() {
            return this.display.wrapper;
          },
          getScrollerElement: function() {
            return this.display.scroller;
          },
          getGutterElement: function() {
            return this.display.gutters;
          }
        }, Ti(o), o.registerHelper = function(f, m, S) {
          p.hasOwnProperty(f) || (p[f] = o[f] = { _global: [] }), p[f][m] = S;
        }, o.registerGlobalHelper = function(f, m, S, x) {
          o.registerHelper(f, m, x), p[f]._global.push({ pred: S, val: x });
        };
      }
      function Gf(o, c, p, f, m) {
        var S = c, x = p, k = Be(o, c.line), D = m && o.direction == "rtl" ? -p : p;
        function _() {
          var Te = c.line + D;
          return Te < o.first || Te >= o.first + o.size ? false : (c = new Q(Te, c.ch, c.sticky), k = Be(o, Te));
        }
        function z(Te) {
          var be;
          if (f == "codepoint") {
            var Ie = k.text.charCodeAt(c.ch + (p > 0 ? 0 : -1));
            if (isNaN(Ie))
              be = null;
            else {
              var Ge = p > 0 ? Ie >= 55296 && Ie < 56320 : Ie >= 56320 && Ie < 57343;
              be = new Q(c.line, Math.max(0, Math.min(k.text.length, c.ch + p * (Ge ? 2 : 1))), -p);
            }
          } else m ? be = l_(o.cm, k, c, p) : be = Nf(k, c, p);
          if (be == null)
            if (!Te && _())
              c = Of(m, o.cm, k, c.line, D);
            else
              return false;
          else
            c = be;
          return true;
        }
        if (f == "char" || f == "codepoint")
          z();
        else if (f == "column")
          z(true);
        else if (f == "word" || f == "group")
          for (var W = null, K = f == "group", J = o.cm && o.cm.getHelper(c, "wordChars"), ee = true; !(p < 0 && !z(!ee)); ee = false) {
            var le = k.text.charAt(c.ch) || `
`, pe = mt(le, J) ? "w" : K && le == `
` ? "n" : !K || /\s/.test(le) ? null : "p";
            if (K && !ee && !pe && (pe = "s"), W && W != pe) {
              p < 0 && (p = 1, z(), c.sticky = "after");
              break;
            }
            if (pe && (W = pe), p > 0 && !z(!ee))
              break;
          }
        var Se = md(o, c, S, x, true);
        return ut(S, Se) && (Se.hitSide = true), Se;
      }
      function Qb(o, c, p, f) {
        var m = o.doc, S = c.left, x;
        if (f == "page") {
          var k = Math.min(o.display.wrapper.clientHeight, Oe(o).innerHeight || m(o).documentElement.clientHeight), D = Math.max(k - 0.5 * Ra(o.display), 3);
          x = (p > 0 ? c.bottom : c.top) + p * D;
        } else f == "line" && (x = p > 0 ? c.bottom + 3 : c.top - 3);
        for (var _; _ = hf(o, S, x), !!_.outside; ) {
          if (p < 0 ? x <= 0 : x >= m.height) {
            _.hitSide = true;
            break;
          }
          x += p * 5;
        }
        return _;
      }
      var bt = function(o) {
        this.cm = o, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new We(), this.composing = null, this.gracePeriod = false, this.readDOMTimeout = null;
      };
      bt.prototype.init = function(o) {
        var c = this, p = this, f = p.cm, m = p.div = o.lineDiv;
        m.contentEditable = true, $f(m, f.options.spellcheck, f.options.autocorrect, f.options.autocapitalize);
        function S(k) {
          for (var D = k.target; D; D = D.parentNode) {
            if (D == m)
              return true;
            if (/\bCodeMirror-(?:line)?widget\b/.test(D.className))
              break;
          }
          return false;
        }
        $e(m, "paste", function(k) {
          !S(k) || Ot(f, k) || Kb(k, f) || u <= 11 && setTimeout(an(f, function() {
            return c.updateFromDOM();
          }), 20);
        }), $e(m, "compositionstart", function(k) {
          c.composing = { data: k.data, done: false };
        }), $e(m, "compositionupdate", function(k) {
          c.composing || (c.composing = { data: k.data, done: false });
        }), $e(m, "compositionend", function(k) {
          c.composing && (k.data != c.composing.data && c.readFromDOMSoon(), c.composing.done = true);
        }), $e(m, "touchstart", function() {
          return p.forceCompositionEnd();
        }), $e(m, "input", function() {
          c.composing || c.readFromDOMSoon();
        });
        function x(k) {
          if (!(!S(k) || Ot(f, k))) {
            if (f.somethingSelected())
              Cd({ lineWise: false, text: f.getSelections() }), k.type == "cut" && f.replaceSelection("", null, "cut");
            else if (f.options.lineWiseCopyCut) {
              var D = Xb(f);
              Cd({ lineWise: true, text: D.text }), k.type == "cut" && f.operation(function() {
                f.setSelections(D.ranges, 0, At), f.replaceSelection("", null, "cut");
              });
            } else
              return;
            if (k.clipboardData) {
              k.clipboardData.clearData();
              var _ = Mi.text.join(`
`);
              if (k.clipboardData.setData("Text", _), k.clipboardData.getData("Text") == _) {
                k.preventDefault();
                return;
              }
            }
            var z = Zb(), W = z.firstChild;
            $f(W), f.display.lineSpace.insertBefore(z, f.display.lineSpace.firstChild), W.value = Mi.text.join(`
`);
            var K = ae(je(m));
            ge(W), setTimeout(function() {
              f.display.lineSpace.removeChild(z), K.focus(), K == m && p.showPrimarySelection();
            }, 50);
          }
        }
        $e(m, "copy", x), $e(m, "cut", x);
      }, bt.prototype.screenReaderLabelChanged = function(o) {
        o ? this.div.setAttribute("aria-label", o) : this.div.removeAttribute("aria-label");
      }, bt.prototype.prepareSelection = function() {
        var o = G0(this.cm, false);
        return o.focus = ae(je(this.div)) == this.div, o;
      }, bt.prototype.showSelection = function(o, c) {
        !o || !this.cm.display.view.length || ((o.focus || c) && this.showPrimarySelection(), this.showMultipleSelections(o));
      }, bt.prototype.getSelection = function() {
        return this.cm.display.wrapper.ownerDocument.getSelection();
      }, bt.prototype.showPrimarySelection = function() {
        var o = this.getSelection(), c = this.cm, p = c.doc.sel.primary(), f = p.from(), m = p.to();
        if (c.display.viewTo == c.display.viewFrom || f.line >= c.display.viewTo || m.line < c.display.viewFrom) {
          o.removeAllRanges();
          return;
        }
        var S = xd(c, o.anchorNode, o.anchorOffset), x = xd(c, o.focusNode, o.focusOffset);
        if (!(S && !S.bad && x && !x.bad && we(La(S, x), f) == 0 && we(On(S, x), m) == 0)) {
          var k = c.display.view, D = f.line >= c.display.viewFrom && ew(c, f) || { node: k[0].measure.map[2], offset: 0 }, _ = m.line < c.display.viewTo && ew(c, m);
          if (!_) {
            var z = k[k.length - 1].measure, W = z.maps ? z.maps[z.maps.length - 1] : z.map;
            _ = { node: W[W.length - 1], offset: W[W.length - 2] - W[W.length - 3] };
          }
          if (!D || !_) {
            o.removeAllRanges();
            return;
          }
          var K = o.rangeCount && o.getRangeAt(0), J;
          try {
            J = se(D.node, D.offset, _.offset, _.node);
          } catch {
          }
          J && (!r && c.state.focused ? (o.collapse(D.node, D.offset), J.collapsed || (o.removeAllRanges(), o.addRange(J))) : (o.removeAllRanges(), o.addRange(J)), K && o.anchorNode == null ? o.addRange(K) : r && this.startGracePeriod()), this.rememberSelection();
        }
      }, bt.prototype.startGracePeriod = function() {
        var o = this;
        clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
          o.gracePeriod = false, o.selectionChanged() && o.cm.operation(function() {
            return o.cm.curOp.selectionChanged = true;
          });
        }, 20);
      }, bt.prototype.showMultipleSelections = function(o) {
        $(this.cm.display.cursorDiv, o.cursors), $(this.cm.display.selectionDiv, o.selection);
      }, bt.prototype.rememberSelection = function() {
        var o = this.getSelection();
        this.lastAnchorNode = o.anchorNode, this.lastAnchorOffset = o.anchorOffset, this.lastFocusNode = o.focusNode, this.lastFocusOffset = o.focusOffset;
      }, bt.prototype.selectionInEditor = function() {
        var o = this.getSelection();
        if (!o.rangeCount)
          return false;
        var c = o.getRangeAt(0).commonAncestorContainer;
        return Pe(this.div, c);
      }, bt.prototype.focus = function() {
        this.cm.options.readOnly != "nocursor" && ((!this.selectionInEditor() || ae(je(this.div)) != this.div) && this.showSelection(this.prepareSelection(), true), this.div.focus());
      }, bt.prototype.blur = function() {
        this.div.blur();
      }, bt.prototype.getField = function() {
        return this.div;
      }, bt.prototype.supportsTouch = function() {
        return true;
      }, bt.prototype.receivedFocus = function() {
        var o = this, c = this;
        this.selectionInEditor() ? setTimeout(function() {
          return o.pollSelection();
        }, 20) : Kn(this.cm, function() {
          return c.cm.curOp.selectionChanged = true;
        });
        function p() {
          c.cm.state.focused && (c.pollSelection(), c.polling.set(c.cm.options.pollInterval, p));
        }
        this.polling.set(this.cm.options.pollInterval, p);
      }, bt.prototype.selectionChanged = function() {
        var o = this.getSelection();
        return o.anchorNode != this.lastAnchorNode || o.anchorOffset != this.lastAnchorOffset || o.focusNode != this.lastFocusNode || o.focusOffset != this.lastFocusOffset;
      }, bt.prototype.pollSelection = function() {
        if (!(this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())) {
          var o = this.getSelection(), c = this.cm;
          if (I && v && this.cm.display.gutterSpecs.length && D_(o.anchorNode)) {
            this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs }), this.blur(), this.focus();
            return;
          }
          if (!this.composing) {
            this.rememberSelection();
            var p = xd(c, o.anchorNode, o.anchorOffset), f = xd(c, o.focusNode, o.focusOffset);
            p && f && Kn(c, function() {
              wn(c.doc, ts(p, f), At), (p.bad || f.bad) && (c.curOp.selectionChanged = true);
            });
          }
        }
      }, bt.prototype.pollContent = function() {
        this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
        var o = this.cm, c = o.display, p = o.doc.sel.primary(), f = p.from(), m = p.to();
        if (f.ch == 0 && f.line > o.firstLine() && (f = Q(f.line - 1, Be(o.doc, f.line - 1).length)), m.ch == Be(o.doc, m.line).text.length && m.line < o.lastLine() && (m = Q(m.line + 1, 0)), f.line < c.viewFrom || m.line > c.viewTo - 1)
          return false;
        var S, x, k;
        f.line == c.viewFrom || (S = Ns(o, f.line)) == 0 ? (x = N(c.view[0].line), k = c.view[0].node) : (x = N(c.view[S].line), k = c.view[S - 1].node.nextSibling);
        var D = Ns(o, m.line), _, z;
        if (D == c.view.length - 1 ? (_ = c.viewTo - 1, z = c.lineDiv.lastChild) : (_ = N(c.view[D + 1].line) - 1, z = c.view[D + 1].node.previousSibling), !k)
          return false;
        for (var W = o.doc.splitLines(I_(o, k, z, x, _)), K = gr(o.doc, Q(x, 0), Q(_, Be(o.doc, _).text.length)); W.length > 1 && K.length > 1; )
          if (ye(W) == ye(K))
            W.pop(), K.pop(), _--;
          else if (W[0] == K[0])
            W.shift(), K.shift(), x++;
          else
            break;
        for (var J = 0, ee = 0, le = W[0], pe = K[0], Se = Math.min(le.length, pe.length); J < Se && le.charCodeAt(J) == pe.charCodeAt(J); )
          ++J;
        for (var Te = ye(W), be = ye(K), Ie = Math.min(
          Te.length - (W.length == 1 ? J : 0),
          be.length - (K.length == 1 ? J : 0)
        ); ee < Ie && Te.charCodeAt(Te.length - ee - 1) == be.charCodeAt(be.length - ee - 1); )
          ++ee;
        if (W.length == 1 && K.length == 1 && x == f.line)
          for (; J && J > f.ch && Te.charCodeAt(Te.length - ee - 1) == be.charCodeAt(be.length - ee - 1); )
            J--, ee++;
        W[W.length - 1] = Te.slice(0, Te.length - ee).replace(/^\u200b+/, ""), W[0] = W[0].slice(J).replace(/\u200b+$/, "");
        var Ge = Q(x, J), Ue = Q(_, K.length ? ye(K).length - ee : 0);
        if (W.length > 1 || W[0] || we(Ge, Ue))
          return Fa(o.doc, W, Ge, Ue, "+input"), true;
      }, bt.prototype.ensurePolled = function() {
        this.forceCompositionEnd();
      }, bt.prototype.reset = function() {
        this.forceCompositionEnd();
      }, bt.prototype.forceCompositionEnd = function() {
        this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus());
      }, bt.prototype.readFromDOMSoon = function() {
        var o = this;
        this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout(function() {
          if (o.readDOMTimeout = null, o.composing)
            if (o.composing.done)
              o.composing = null;
            else
              return;
          o.updateFromDOM();
        }, 80));
      }, bt.prototype.updateFromDOM = function() {
        var o = this;
        (this.cm.isReadOnly() || !this.pollContent()) && Kn(this.cm, function() {
          return Vn(o.cm);
        });
      }, bt.prototype.setUneditable = function(o) {
        o.contentEditable = "false";
      }, bt.prototype.onKeyPress = function(o) {
        o.charCode == 0 || this.composing || (o.preventDefault(), this.cm.isReadOnly() || an(this.cm, zf)(this.cm, String.fromCharCode(o.charCode == null ? o.keyCode : o.charCode), 0));
      }, bt.prototype.readOnlyChanged = function(o) {
        this.div.contentEditable = String(o != "nocursor");
      }, bt.prototype.onContextMenu = function() {
      }, bt.prototype.resetPosition = function() {
      }, bt.prototype.needsContentAttribute = true;
      function ew(o, c) {
        var p = cf(o, c.line);
        if (!p || p.hidden)
          return null;
        var f = Be(o.doc, c.line), m = I0(p, f, c.line), S = tt(f, o.doc.direction), x = "left";
        if (S) {
          var k = jr(S, c.ch);
          x = k % 2 ? "right" : "left";
        }
        var D = A0(m.map, c.ch, x);
        return D.offset = D.collapse == "right" ? D.end : D.start, D;
      }
      function D_(o) {
        for (var c = o; c; c = c.parentNode)
          if (/CodeMirror-gutter-wrapper/.test(c.className))
            return true;
        return false;
      }
      function Wa(o, c) {
        return c && (o.bad = true), o;
      }
      function I_(o, c, p, f, m) {
        var S = "", x = false, k = o.doc.lineSeparator(), D = false;
        function _(J) {
          return function(ee) {
            return ee.id == J;
          };
        }
        function z() {
          x && (S += k, D && (S += k), x = D = false);
        }
        function W(J) {
          J && (z(), S += J);
        }
        function K(J) {
          if (J.nodeType == 1) {
            var ee = J.getAttribute("cm-text");
            if (ee) {
              W(ee);
              return;
            }
            var le = J.getAttribute("cm-marker"), pe;
            if (le) {
              var Se = o.findMarks(Q(f, 0), Q(m + 1, 0), _(+le));
              Se.length && (pe = Se[0].find(0)) && W(gr(o.doc, pe.from, pe.to).join(k));
              return;
            }
            if (J.getAttribute("contenteditable") == "false")
              return;
            var Te = /^(pre|div|p|li|table|br)$/i.test(J.nodeName);
            if (!/^br$/i.test(J.nodeName) && J.textContent.length == 0)
              return;
            Te && z();
            for (var be = 0; be < J.childNodes.length; be++)
              K(J.childNodes[be]);
            /^(pre|p)$/i.test(J.nodeName) && (D = true), Te && (x = true);
          } else J.nodeType == 3 && W(J.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
        }
        for (; K(c), c != p; )
          c = c.nextSibling, D = false;
        return S;
      }
      function xd(o, c, p) {
        var f;
        if (c == o.display.lineDiv) {
          if (f = o.display.lineDiv.childNodes[p], !f)
            return Wa(o.clipPos(Q(o.display.viewTo - 1)), true);
          c = null, p = 0;
        } else
          for (f = c; ; f = f.parentNode) {
            if (!f || f == o.display.lineDiv)
              return null;
            if (f.parentNode && f.parentNode == o.display.lineDiv)
              break;
          }
        for (var m = 0; m < o.display.view.length; m++) {
          var S = o.display.view[m];
          if (S.node == f)
            return P_(S, c, p);
        }
      }
      function P_(o, c, p) {
        var f = o.text.firstChild, m = false;
        if (!c || !Pe(f, c))
          return Wa(Q(N(o.line), 0), true);
        if (c == f && (m = true, c = f.childNodes[p], p = 0, !c)) {
          var S = o.rest ? ye(o.rest) : o.line;
          return Wa(Q(N(S), S.text.length), m);
        }
        var x = c.nodeType == 3 ? c : null, k = c;
        for (!x && c.childNodes.length == 1 && c.firstChild.nodeType == 3 && (x = c.firstChild, p && (p = x.nodeValue.length)); k.parentNode != f; )
          k = k.parentNode;
        var D = o.measure, _ = D.maps;
        function z(pe, Se, Te) {
          for (var be = -1; be < (_ ? _.length : 0); be++)
            for (var Ie = be < 0 ? D.map : _[be], Ge = 0; Ge < Ie.length; Ge += 3) {
              var Ue = Ie[Ge + 2];
              if (Ue == pe || Ue == Se) {
                var Qe = N(be < 0 ? o.line : o.rest[be]), Et = Ie[Ge] + Te;
                return (Te < 0 || Ue != pe) && (Et = Ie[Ge + (Te ? 1 : 0)]), Q(Qe, Et);
              }
            }
        }
        var W = z(x, k, p);
        if (W)
          return Wa(W, m);
        for (var K = k.nextSibling, J = x ? x.nodeValue.length - p : 0; K; K = K.nextSibling) {
          if (W = z(K, K.firstChild, 0), W)
            return Wa(Q(W.line, W.ch - J), m);
          J += K.textContent.length;
        }
        for (var ee = k.previousSibling, le = p; ee; ee = ee.previousSibling) {
          if (W = z(ee, ee.firstChild, -1), W)
            return Wa(Q(W.line, W.ch + le), m);
          le += ee.textContent.length;
        }
      }
      var Ht = function(o) {
        this.cm = o, this.prevInput = "", this.pollingFast = false, this.polling = new We(), this.hasSelection = false, this.composing = null, this.resetting = false;
      };
      Ht.prototype.init = function(o) {
        var c = this, p = this, f = this.cm;
        this.createField(o);
        var m = this.textarea;
        o.wrapper.insertBefore(this.wrapper, o.wrapper.firstChild), T && (m.style.width = "0px"), $e(m, "input", function() {
          d && u >= 9 && c.hasSelection && (c.hasSelection = null), p.poll();
        }), $e(m, "paste", function(x) {
          Ot(f, x) || Kb(x, f) || (f.state.pasteIncoming = +/* @__PURE__ */ new Date(), p.fastPoll());
        });
        function S(x) {
          if (!Ot(f, x)) {
            if (f.somethingSelected())
              Cd({ lineWise: false, text: f.getSelections() });
            else if (f.options.lineWiseCopyCut) {
              var k = Xb(f);
              Cd({ lineWise: true, text: k.text }), x.type == "cut" ? f.setSelections(k.ranges, null, At) : (p.prevInput = "", m.value = k.text.join(`
`), ge(m));
            } else
              return;
            x.type == "cut" && (f.state.cutIncoming = +/* @__PURE__ */ new Date());
          }
        }
        $e(m, "cut", S), $e(m, "copy", S), $e(o.scroller, "paste", function(x) {
          if (!(yr(o, x) || Ot(f, x))) {
            if (!m.dispatchEvent) {
              f.state.pasteIncoming = +/* @__PURE__ */ new Date(), p.focus();
              return;
            }
            var k = new Event("paste");
            k.clipboardData = x.clipboardData, m.dispatchEvent(k);
          }
        }), $e(o.lineSpace, "selectstart", function(x) {
          yr(o, x) || bn(x);
        }), $e(m, "compositionstart", function() {
          var x = f.getCursor("from");
          p.composing && p.composing.range.clear(), p.composing = {
            start: x,
            range: f.markText(x, f.getCursor("to"), { className: "CodeMirror-composing" })
          };
        }), $e(m, "compositionend", function() {
          p.composing && (p.poll(), p.composing.range.clear(), p.composing = null);
        });
      }, Ht.prototype.createField = function(o) {
        this.wrapper = Zb(), this.textarea = this.wrapper.firstChild;
        var c = this.cm.options;
        $f(this.textarea, c.spellcheck, c.autocorrect, c.autocapitalize);
      }, Ht.prototype.screenReaderLabelChanged = function(o) {
        o ? this.textarea.setAttribute("aria-label", o) : this.textarea.removeAttribute("aria-label");
      }, Ht.prototype.prepareSelection = function() {
        var o = this.cm, c = o.display, p = o.doc, f = G0(o);
        if (o.options.moveInputWithCursor) {
          var m = Ai(o, p.sel.primary().head, "div"), S = c.wrapper.getBoundingClientRect(), x = c.lineDiv.getBoundingClientRect();
          f.teTop = Math.max(0, Math.min(
            c.wrapper.clientHeight - 10,
            m.top + x.top - S.top
          )), f.teLeft = Math.max(0, Math.min(
            c.wrapper.clientWidth - 10,
            m.left + x.left - S.left
          ));
        }
        return f;
      }, Ht.prototype.showSelection = function(o) {
        var c = this.cm, p = c.display;
        $(p.cursorDiv, o.cursors), $(p.selectionDiv, o.selection), o.teTop != null && (this.wrapper.style.top = o.teTop + "px", this.wrapper.style.left = o.teLeft + "px");
      }, Ht.prototype.reset = function(o) {
        if (!(this.contextMenuPending || this.composing && o)) {
          var c = this.cm;
          if (this.resetting = true, c.somethingSelected()) {
            this.prevInput = "";
            var p = c.getSelection();
            this.textarea.value = p, c.state.focused && ge(this.textarea), d && u >= 9 && (this.hasSelection = p);
          } else o || (this.prevInput = this.textarea.value = "", d && u >= 9 && (this.hasSelection = null));
          this.resetting = false;
        }
      }, Ht.prototype.getField = function() {
        return this.textarea;
      }, Ht.prototype.supportsTouch = function() {
        return false;
      }, Ht.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor" && (!R || ae(je(this.textarea)) != this.textarea))
          try {
            this.textarea.focus();
          } catch {
          }
      }, Ht.prototype.blur = function() {
        this.textarea.blur();
      }, Ht.prototype.resetPosition = function() {
        this.wrapper.style.top = this.wrapper.style.left = 0;
      }, Ht.prototype.receivedFocus = function() {
        this.slowPoll();
      }, Ht.prototype.slowPoll = function() {
        var o = this;
        this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
          o.poll(), o.cm.state.focused && o.slowPoll();
        });
      }, Ht.prototype.fastPoll = function() {
        var o = false, c = this;
        c.pollingFast = true;
        function p() {
          var f = c.poll();
          !f && !o ? (o = true, c.polling.set(60, p)) : (c.pollingFast = false, c.slowPoll());
        }
        c.polling.set(20, p);
      }, Ht.prototype.poll = function() {
        var o = this, c = this.cm, p = this.textarea, f = this.prevInput;
        if (this.contextMenuPending || this.resetting || !c.state.focused || Yr(p) && !f && !this.composing || c.isReadOnly() || c.options.disableInput || c.state.keySeq)
          return false;
        var m = p.value;
        if (m == f && !c.somethingSelected())
          return false;
        if (d && u >= 9 && this.hasSelection === m || P && /[\uf700-\uf7ff]/.test(m))
          return c.display.input.reset(), false;
        if (c.doc.sel == c.display.selForContextMenu) {
          var S = m.charCodeAt(0);
          if (S == 8203 && !f && (f = "​"), S == 8666)
            return this.reset(), this.cm.execCommand("undo");
        }
        for (var x = 0, k = Math.min(f.length, m.length); x < k && f.charCodeAt(x) == m.charCodeAt(x); )
          ++x;
        return Kn(c, function() {
          zf(
            c,
            m.slice(x),
            f.length - x,
            null,
            o.composing ? "*compose" : null
          ), m.length > 1e3 || m.indexOf(`
`) > -1 ? p.value = o.prevInput = "" : o.prevInput = m, o.composing && (o.composing.range.clear(), o.composing.range = c.markText(
            o.composing.start,
            c.getCursor("to"),
            { className: "CodeMirror-composing" }
          ));
        }), true;
      }, Ht.prototype.ensurePolled = function() {
        this.pollingFast && this.poll() && (this.pollingFast = false);
      }, Ht.prototype.onKeyPress = function() {
        d && u >= 9 && (this.hasSelection = null), this.fastPoll();
      }, Ht.prototype.onContextMenu = function(o) {
        var c = this, p = c.cm, f = p.display, m = c.textarea;
        c.contextMenuPending && c.contextMenuPending();
        var S = Ms(p, o), x = f.scroller.scrollTop;
        if (!S || C)
          return;
        var k = p.options.resetSelectionOnContextMenu;
        k && p.doc.sel.contains(S) == -1 && an(p, wn)(p.doc, ts(S), At);
        var D = m.style.cssText, _ = c.wrapper.style.cssText, z = c.wrapper.offsetParent.getBoundingClientRect();
        c.wrapper.style.cssText = "position: static", m.style.cssText = `position: absolute; width: 30px; height: 30px;
      top: ` + (o.clientY - z.top - 5) + "px; left: " + (o.clientX - z.left - 5) + `px;
      z-index: 1000; background: ` + (d ? "rgba(255, 255, 255, .05)" : "transparent") + `;
      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`;
        var W;
        h && (W = m.ownerDocument.defaultView.scrollY), f.input.focus(), h && m.ownerDocument.defaultView.scrollTo(null, W), f.input.reset(), p.somethingSelected() || (m.value = c.prevInput = " "), c.contextMenuPending = J, f.selForContextMenu = p.doc.sel, clearTimeout(f.detectingSelectAll);
        function K() {
          if (m.selectionStart != null) {
            var le = p.somethingSelected(), pe = "​" + (le ? m.value : "");
            m.value = "⇚", m.value = pe, c.prevInput = le ? "" : "​", m.selectionStart = 1, m.selectionEnd = pe.length, f.selForContextMenu = p.doc.sel;
          }
        }
        function J() {
          if (c.contextMenuPending == J && (c.contextMenuPending = false, c.wrapper.style.cssText = _, m.style.cssText = D, d && u < 9 && f.scrollbars.setScrollTop(f.scroller.scrollTop = x), m.selectionStart != null)) {
            (!d || d && u < 9) && K();
            var le = 0, pe = function() {
              f.selForContextMenu == p.doc.sel && m.selectionStart == 0 && m.selectionEnd > 0 && c.prevInput == "​" ? an(p, Sb)(p) : le++ < 10 ? f.detectingSelectAll = setTimeout(pe, 500) : (f.selForContextMenu = null, f.input.reset());
            };
            f.detectingSelectAll = setTimeout(pe, 200);
          }
        }
        if (d && u >= 9 && K(), F) {
          Jr(o);
          var ee = function() {
            Sn(window, "mouseup", ee), setTimeout(J, 20);
          };
          $e(window, "mouseup", ee);
        } else
          setTimeout(J, 50);
      }, Ht.prototype.readOnlyChanged = function(o) {
        o || this.reset(), this.textarea.disabled = o == "nocursor", this.textarea.readOnly = !!o;
      }, Ht.prototype.setUneditable = function() {
      }, Ht.prototype.needsContentAttribute = false;
      function R_(o, c) {
        if (c = c ? Ve(c) : {}, c.value = o.value, !c.tabindex && o.tabIndex && (c.tabindex = o.tabIndex), !c.placeholder && o.placeholder && (c.placeholder = o.placeholder), c.autofocus == null) {
          var p = ae(je(o));
          c.autofocus = p == o || o.getAttribute("autofocus") != null && p == document.body;
        }
        function f() {
          o.value = k.getValue();
        }
        var m;
        if (o.form && ($e(o.form, "submit", f), !c.leaveSubmitMethodAlone)) {
          var S = o.form;
          m = S.submit;
          try {
            var x = S.submit = function() {
              f(), S.submit = m, S.submit(), S.submit = x;
            };
          } catch {
          }
        }
        c.finishInit = function(D) {
          D.save = f, D.getTextArea = function() {
            return o;
          }, D.toTextArea = function() {
            D.toTextArea = isNaN, f(), o.parentNode.removeChild(D.getWrapperElement()), o.style.display = "", o.form && (Sn(o.form, "submit", f), !c.leaveSubmitMethodAlone && typeof o.form.submit == "function" && (o.form.submit = m));
          };
        }, o.style.display = "none";
        var k = Rt(
          function(D) {
            return o.parentNode.insertBefore(D, o.nextSibling);
          },
          c
        );
        return k;
      }
      function A_(o) {
        o.off = Sn, o.on = $e, o.wheelEventPixels = FA, o.Doc = Bn, o.splitLines = ui, o.countColumn = qe, o.findColumn = te, o.isWordChar = Gt, o.Pass = $t, o.signal = Nt, o.Line = Da, o.changeEnd = ns, o.scrollbarModel = K0, o.Pos = Q, o.cmpPos = we, o.modes = Ca, o.mimeModes = Ii, o.resolveMode = xa, o.getMode = Ea, o.modeExtensions = Xr, o.extendMode = ka, o.copyState = qi, o.startState = Ta, o.innerMode = il, o.commands = Ll, o.keyMap = br, o.keyName = Nb, o.isModifierKey = _b, o.lookupKey = za, o.normalizeKeyMap = o_, o.StringStream = Vt, o.SharedTextMarker = El, o.TextMarker = rs, o.LineWidget = xl, o.e_preventDefault = bn, o.e_stopPropagation = ba, o.e_stop = Jr, o.addClass = Ee, o.contains = Pe, o.rmClass = U, o.keyNames = ss;
      }
      x_(Rt), L_(Rt);
      var __ = "iter insert remove copy getEditor constructor".split(" ");
      for (var Ed in Bn.prototype)
        Bn.prototype.hasOwnProperty(Ed) && De(__, Ed) < 0 && (Rt.prototype[Ed] = /* @__PURE__ */ function(o) {
          return function() {
            return o.apply(this.doc, arguments);
          };
        }(Bn.prototype[Ed]));
      return Ti(Bn), Rt.inputStyles = { textarea: Ht, contenteditable: bt }, Rt.defineMode = function(o) {
        !Rt.defaults.mode && o != "null" && (Rt.defaults.mode = o), Pi.apply(this, arguments);
      }, Rt.defineMIME = Rs, Rt.defineMode("null", function() {
        return { token: function(o) {
          return o.skipToEnd();
        } };
      }), Rt.defineMIME("text/plain", "null"), Rt.defineExtension = function(o, c) {
        Rt.prototype[o] = c;
      }, Rt.defineDocExtension = function(o, c) {
        Bn.prototype[o] = c;
      }, Rt.fromTextArea = R_, A_(Rt), Rt.version = "5.65.18", Rt;
    });
  }(eu)), eu.exports;
}
var LE;
function v4() {
  return LE || (LE = 1, function(i, e) {
    (function(t) {
      t(Yo());
    })(function(t) {
      t.defineMode("javascript", function(n, r) {
        var s = n.indentUnit, a = r.statementIndent, l = r.jsonld, d = r.json || l, u = r.trackScope !== false, h = r.typescript, g = r.wordCharacters || /[\w$\xa1-\uffff]/, v = function() {
          function N(rn) {
            return { type: rn, style: "keyword" };
          }
          var G = N("keyword a"), ie = N("keyword b"), fe = N("keyword c"), Q = N("keyword d"), we = N("operator"), ut = { type: "atom", style: "atom" };
          return {
            if: N("if"),
            while: G,
            with: G,
            else: ie,
            do: ie,
            try: ie,
            finally: ie,
            return: Q,
            break: Q,
            continue: Q,
            new: N("new"),
            delete: fe,
            void: fe,
            throw: fe,
            debugger: N("debugger"),
            var: N("var"),
            const: N("var"),
            let: N("var"),
            function: N("function"),
            catch: N("catch"),
            for: N("for"),
            switch: N("switch"),
            case: N("case"),
            default: N("default"),
            in: we,
            typeof: we,
            instanceof: we,
            true: ut,
            false: ut,
            null: ut,
            undefined: ut,
            NaN: ut,
            Infinity: ut,
            this: N("this"),
            class: N("class"),
            super: N("atom"),
            yield: fe,
            export: N("export"),
            import: N("import"),
            extends: fe,
            await: fe
          };
        }(), y = /[+\-*&%=<>!?|~^@]/, C = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
        function w(N) {
          for (var G = false, ie, fe = false; (ie = N.next()) != null; ) {
            if (!G) {
              if (ie == "/" && !fe) return;
              ie == "[" ? fe = true : fe && ie == "]" && (fe = false);
            }
            G = !G && ie == "\\";
          }
        }
        var b, E;
        function T(N, G, ie) {
          return b = N, E = ie, G;
        }
        function I(N, G) {
          var ie = N.next();
          if (ie == '"' || ie == "'")
            return G.tokenize = R(ie), G.tokenize(N, G);
          if (ie == "." && N.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/))
            return T("number", "number");
          if (ie == "." && N.match(".."))
            return T("spread", "meta");
          if (/[\[\]{}\(\),;\:\.]/.test(ie))
            return T(ie);
          if (ie == "=" && N.eat(">"))
            return T("=>", "operator");
          if (ie == "0" && N.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/))
            return T("number", "number");
          if (/\d/.test(ie))
            return N.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), T("number", "number");
          if (ie == "/")
            return N.eat("*") ? (G.tokenize = P, P(N, G)) : N.eat("/") ? (N.skipToEnd(), T("comment", "comment")) : ti(N, G, 1) ? (w(N), N.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), T("regexp", "string-2")) : (N.eat("="), T("operator", "operator", N.current()));
          if (ie == "`")
            return G.tokenize = L, L(N, G);
          if (ie == "#" && N.peek() == "!")
            return N.skipToEnd(), T("meta", "meta");
          if (ie == "#" && N.eatWhile(g))
            return T("variable", "property");
          if (ie == "<" && N.match("!--") || ie == "-" && N.match("->") && !/\S/.test(N.string.slice(0, N.start)))
            return N.skipToEnd(), T("comment", "comment");
          if (y.test(ie))
            return (ie != ">" || !G.lexical || G.lexical.type != ">") && (N.eat("=") ? (ie == "!" || ie == "=") && N.eat("=") : /[<>*+\-|&?]/.test(ie) && (N.eat(ie), ie == ">" && N.eat(ie))), ie == "?" && N.eat(".") ? T(".") : T("operator", "operator", N.current());
          if (g.test(ie)) {
            N.eatWhile(g);
            var fe = N.current();
            if (G.lastType != ".") {
              if (v.propertyIsEnumerable(fe)) {
                var Q = v[fe];
                return T(Q.type, Q.style, fe);
              }
              if (fe == "async" && N.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
                return T("async", "keyword", fe);
            }
            return T("variable", "variable", fe);
          }
        }
        function R(N) {
          return function(G, ie) {
            var fe = false, Q;
            if (l && G.peek() == "@" && G.match(C))
              return ie.tokenize = I, T("jsonld-keyword", "meta");
            for (; (Q = G.next()) != null && !(Q == N && !fe); )
              fe = !fe && Q == "\\";
            return fe || (ie.tokenize = I), T("string", "string");
          };
        }
        function P(N, G) {
          for (var ie = false, fe; fe = N.next(); ) {
            if (fe == "/" && ie) {
              G.tokenize = I;
              break;
            }
            ie = fe == "*";
          }
          return T("comment", "comment");
        }
        function L(N, G) {
          for (var ie = false, fe; (fe = N.next()) != null; ) {
            if (!ie && (fe == "`" || fe == "$" && N.eat("{"))) {
              G.tokenize = I;
              break;
            }
            ie = !ie && fe == "\\";
          }
          return T("quasi", "string-2", N.current());
        }
        var A = "([{}])";
        function M(N, G) {
          G.fatArrowAt && (G.fatArrowAt = null);
          var ie = N.string.indexOf("=>", N.start);
          if (!(ie < 0)) {
            if (h) {
              var fe = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(N.string.slice(N.start, ie));
              fe && (ie = fe.index);
            }
            for (var Q = 0, we = false, ut = ie - 1; ut >= 0; --ut) {
              var rn = N.string.charAt(ut), On = A.indexOf(rn);
              if (On >= 0 && On < 3) {
                if (!Q) {
                  ++ut;
                  break;
                }
                if (--Q == 0) {
                  rn == "(" && (we = true);
                  break;
                }
              } else if (On >= 3 && On < 6)
                ++Q;
              else if (g.test(rn))
                we = true;
              else if (/["'\/`]/.test(rn))
                for (; ; --ut) {
                  if (ut == 0) return;
                  var La = N.string.charAt(ut - 1);
                  if (La == rn && N.string.charAt(ut - 2) != "\\") {
                    ut--;
                    break;
                  }
                }
              else if (we && !Q) {
                ++ut;
                break;
              }
            }
            we && !Q && (G.fatArrowAt = ut);
          }
        }
        var O = {
          atom: true,
          number: true,
          variable: true,
          string: true,
          regexp: true,
          this: true,
          import: true,
          "jsonld-keyword": true
        };
        function F(N, G, ie, fe, Q, we) {
          this.indented = N, this.column = G, this.type = ie, this.prev = Q, this.info = we, fe != null && (this.align = fe);
        }
        function q(N, G) {
          if (!u) return false;
          for (var ie = N.localVars; ie; ie = ie.next)
            if (ie.name == G) return true;
          for (var fe = N.context; fe; fe = fe.prev)
            for (var ie = fe.vars; ie; ie = ie.next)
              if (ie.name == G) return true;
        }
        function U(N, G, ie, fe, Q) {
          var we = N.cc;
          for (V.state = N, V.stream = Q, V.marked = null, V.cc = we, V.style = G, N.lexical.hasOwnProperty("align") || (N.lexical.align = true); ; ) {
            var ut = we.length ? we.pop() : d ? De : qe;
            if (ut(ie, fe)) {
              for (; we.length && we[we.length - 1].lex; )
                we.pop()();
              return V.marked ? V.marked : ie == "variable" && q(N, fe) ? "variable-2" : G;
            }
          }
        }
        var V = { state: null, marked: null, cc: null };
        function $() {
          for (var N = arguments.length - 1; N >= 0; N--) V.cc.push(arguments[N]);
        }
        function B() {
          return $.apply(null, arguments), true;
        }
        function ue(N, G) {
          for (var ie = G; ie; ie = ie.next) if (ie.name == N) return true;
          return false;
        }
        function se(N) {
          var G = V.state;
          if (V.marked = "def", !!u) {
            if (G.context) {
              if (G.lexical.info == "var" && G.context && G.context.block) {
                var ie = Pe(N, G.context);
                if (ie != null) {
                  G.context = ie;
                  return;
                }
              } else if (!ue(N, G.localVars)) {
                G.localVars = new ce(N, G.localVars);
                return;
              }
            }
            r.globalVars && !ue(N, G.globalVars) && (G.globalVars = new ce(N, G.globalVars));
          }
        }
        function Pe(N, G) {
          if (G)
            if (G.block) {
              var ie = Pe(N, G.prev);
              return ie ? ie == G.prev ? G : new Ee(ie, G.vars, true) : null;
            } else return ue(N, G.vars) ? G : new Ee(G.prev, new ce(N, G.vars), false);
          else return null;
        }
        function ae(N) {
          return N == "public" || N == "private" || N == "protected" || N == "abstract" || N == "readonly";
        }
        function Ee(N, G, ie) {
          this.prev = N, this.vars = G, this.block = ie;
        }
        function ce(N, G) {
          this.name = N, this.next = G;
        }
        var ge = new ce("this", new ce("arguments", null));
        function Ne() {
          V.state.context = new Ee(V.state.context, V.state.localVars, false), V.state.localVars = ge;
        }
        function Me() {
          V.state.context = new Ee(V.state.context, V.state.localVars, true), V.state.localVars = null;
        }
        Ne.lex = Me.lex = true;
        function je() {
          V.state.localVars = V.state.context.vars, V.state.context = V.state.context.prev;
        }
        je.lex = true;
        function Oe(N, G) {
          var ie = function() {
            var fe = V.state, Q = fe.indented;
            if (fe.lexical.type == "stat") Q = fe.lexical.indented;
            else for (var we = fe.lexical; we && we.type == ")" && we.align; we = we.prev)
              Q = we.indented;
            fe.lexical = new F(Q, V.stream.column(), N, null, fe.lexical, G);
          };
          return ie.lex = true, ie;
        }
        function Re() {
          var N = V.state;
          N.lexical.prev && (N.lexical.type == ")" && (N.indented = N.lexical.indented), N.lexical = N.lexical.prev);
        }
        Re.lex = true;
        function Ve(N) {
          function G(ie) {
            return ie == N ? B() : N == ";" || ie == "}" || ie == ")" || ie == "]" ? $() : B(G);
          }
          return G;
        }
        function qe(N, G) {
          return N == "var" ? B(Oe("vardef", G), ba, Ve(";"), Re) : N == "keyword a" ? B(Oe("form"), $t, qe, Re) : N == "keyword b" ? B(Oe("form"), qe, Re) : N == "keyword d" ? V.stream.match(/^\s*$/, false) ? B() : B(Oe("stat"), Z, Ve(";"), Re) : N == "debugger" ? B(Ve(";")) : N == "{" ? B(Oe("}"), Me, Pt, Re, je) : N == ";" ? B() : N == "if" ? (V.state.lexical.info == "else" && V.state.cc[V.state.cc.length - 1] == Re && V.state.cc.pop()(), B(Oe("form"), $t, qe, Re, wa)) : N == "function" ? B(ui) : N == "for" ? B(Oe("form"), Me, jc, qe, je, Re) : N == "class" || h && G == "interface" ? (V.marked = "keyword", B(Oe("form", N == "class" ? N : G), Ca, Re)) : N == "variable" ? h && G == "declare" ? (V.marked = "keyword", B(qe)) : h && (G == "module" || G == "enum" || G == "type") && V.stream.match(/^\s*\w/, false) ? (V.marked = "keyword", G == "enum" ? B(Be) : G == "type" ? B(Jc, Ve("operator"), tt, Ve(";")) : B(Oe("form"), Nn, Ve("{"), Oe("}"), Pt, Re, Re)) : h && G == "namespace" ? (V.marked = "keyword", B(Oe("form"), De, qe, Re)) : h && G == "abstract" ? (V.marked = "keyword", B(qe)) : B(Oe("stat"), ot) : N == "switch" ? B(
            Oe("form"),
            $t,
            Ve("{"),
            Oe("}", "switch"),
            Me,
            Pt,
            Re,
            Re,
            je
          ) : N == "case" ? B(De, Ve(":")) : N == "default" ? B(Ve(":")) : N == "catch" ? B(Oe("form"), Ne, We, qe, Re, je) : N == "export" ? B(Oe("stat"), xa, Re) : N == "import" ? B(Oe("stat"), Xr, Re) : N == "async" ? B(qe) : G == "@" ? B(De, qe) : $(Oe("stat"), De, Ve(";"), Re);
        }
        function We(N) {
          if (N == "(") return B(Di, Ve(")"));
        }
        function De(N, G) {
          return At(N, G, false);
        }
        function et(N, G) {
          return At(N, G, true);
        }
        function $t(N) {
          return N != "(" ? $() : B(Oe(")"), Z, Ve(")"), Re);
        }
        function At(N, G, ie) {
          if (V.state.fatArrowAt == V.stream.start) {
            var fe = ie ? Je : ye;
            if (N == "(") return B(Ne, Oe(")"), Ze(Di, ")"), Re, Ve("=>"), fe, je);
            if (N == "variable") return $(Ne, Nn, Ve("=>"), fe, je);
          }
          var Q = ie ? te : ne;
          return O.hasOwnProperty(N) ? B(Q) : N == "function" ? B(ui, Q) : N == "class" || h && G == "interface" ? (V.marked = "keyword", B(Oe("form"), Xh, Re)) : N == "keyword c" || N == "async" ? B(ie ? et : De) : N == "(" ? B(Oe(")"), Z, Ve(")"), Re, Q) : N == "operator" || N == "spread" ? B(ie ? et : De) : N == "[" ? B(Oe("]"), Vt, Re, Q) : N == "{" ? _t(mt, "}", null, Q) : N == "quasi" ? $(ve, Q) : N == "new" ? B(it(ie)) : B();
        }
        function Z(N) {
          return N.match(/[;\}\)\],]/) ? $() : $(De);
        }
        function ne(N, G) {
          return N == "," ? B(Z) : te(N, G, false);
        }
        function te(N, G, ie) {
          var fe = ie == false ? ne : te, Q = ie == false ? De : et;
          if (N == "=>") return B(Ne, ie ? Je : ye, je);
          if (N == "operator")
            return /\+\+|--/.test(G) || h && G == "!" ? B(fe) : h && G == "<" && V.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false) ? B(Oe(">"), Ze(tt, ">"), Re, fe) : G == "?" ? B(De, Ve(":"), Q) : B(Q);
          if (N == "quasi")
            return $(ve, fe);
          if (N != ";") {
            if (N == "(") return _t(et, ")", "call", fe);
            if (N == ".") return B(Gt, fe);
            if (N == "[") return B(Oe("]"), Z, Ve("]"), Re, fe);
            if (h && G == "as")
              return V.marked = "keyword", B(tt, fe);
            if (N == "regexp")
              return V.state.lastType = V.marked = "operator", V.stream.backUp(V.stream.pos - V.stream.start - 1), B(Q);
          }
        }
        function ve(N, G) {
          return N != "quasi" ? $() : G.slice(G.length - 2) != "${" ? B(ve) : B(Z, ke);
        }
        function ke(N) {
          if (N == "}")
            return V.marked = "string-2", V.state.tokenize = L, B(ve);
        }
        function ye(N) {
          return M(V.stream, V.state), $(N == "{" ? qe : De);
        }
        function Je(N) {
          return M(V.stream, V.state), $(N == "{" ? qe : et);
        }
        function it(N) {
          return function(G) {
            return G == "." ? B(N ? gt : pt) : G == "variable" && h ? B(Jn, N ? te : ne) : $(N ? et : De);
          };
        }
        function pt(N, G) {
          if (G == "target")
            return V.marked = "keyword", B(ne);
        }
        function gt(N, G) {
          if (G == "target")
            return V.marked = "keyword", B(te);
        }
        function ot(N) {
          return N == ":" ? B(Re, qe) : $(ne, Ve(";"), Re);
        }
        function Gt(N) {
          if (N == "variable")
            return V.marked = "property", B();
        }
        function mt(N, G) {
          if (N == "async")
            return V.marked = "property", B(mt);
          if (N == "variable" || V.style == "keyword") {
            if (V.marked = "property", G == "get" || G == "set") return B(It);
            var ie;
            return h && V.state.fatArrowAt == V.stream.start && (ie = V.stream.match(/^\s*:\s*/, false)) && (V.state.fatArrowAt = V.stream.pos + ie[0].length), B(Wt);
          } else {
            if (N == "number" || N == "string")
              return V.marked = l ? "property" : V.style + " property", B(Wt);
            if (N == "jsonld-keyword")
              return B(Wt);
            if (h && ae(G))
              return V.marked = "keyword", B(mt);
            if (N == "[")
              return B(De, ci, Ve("]"), Wt);
            if (N == "spread")
              return B(et, Wt);
            if (G == "*")
              return V.marked = "keyword", B(mt);
            if (N == ":")
              return $(Wt);
          }
        }
        function It(N) {
          return N != "variable" ? $(Wt) : (V.marked = "property", B(ui));
        }
        function Wt(N) {
          if (N == ":") return B(et);
          if (N == "(") return $(ui);
        }
        function Ze(N, G, ie) {
          function fe(Q, we) {
            if (ie ? ie.indexOf(Q) > -1 : Q == ",") {
              var ut = V.state.lexical;
              return ut.info == "call" && (ut.pos = (ut.pos || 0) + 1), B(function(rn, On) {
                return rn == G || On == G ? $() : $(N);
              }, fe);
            }
            return Q == G || we == G ? B() : ie && ie.indexOf(";") > -1 ? $(N) : B(Ve(G));
          }
          return function(Q, we) {
            return Q == G || we == G ? B() : $(N, fe);
          };
        }
        function _t(N, G, ie) {
          for (var fe = 3; fe < arguments.length; fe++)
            V.cc.push(arguments[fe]);
          return B(Oe(G, ie), Ze(N, G), Re);
        }
        function Pt(N) {
          return N == "}" ? B() : $(qe, Pt);
        }
        function ci(N, G) {
          if (h) {
            if (N == ":") return B(tt);
            if (G == "?") return B(ci);
          }
        }
        function Hi(N, G) {
          if (h && (N == ":" || G == "in")) return B(tt);
        }
        function jr(N) {
          if (h && N == ":")
            return V.stream.match(/^\s*\w+\s+is\b/, false) ? B(De, Kh, tt) : B(tt);
        }
        function Kh(N, G) {
          if (G == "is")
            return V.marked = "keyword", B();
        }
        function tt(N, G) {
          if (G == "keyof" || G == "typeof" || G == "infer" || G == "readonly")
            return V.marked = "keyword", B(G == "typeof" ? et : tt);
          if (N == "variable" || G == "void")
            return V.marked = "type", B(di);
          if (G == "|" || G == "&") return B(tt);
          if (N == "string" || N == "number" || N == "atom") return B(di);
          if (N == "[") return B(Oe("]"), Ze(tt, "]", ","), Re, di);
          if (N == "{") return B(Oe("}"), $e, Re, di);
          if (N == "(") return B(Ze(Ot, ")"), qc, di);
          if (N == "<") return B(Ze(tt, ">"), tt);
          if (N == "quasi")
            return $(Sn, di);
        }
        function qc(N) {
          if (N == "=>") return B(tt);
        }
        function $e(N) {
          return N.match(/[\}\)\]]/) ? B() : N == "," || N == ";" ? B($e) : $(pr, $e);
        }
        function pr(N, G) {
          if (N == "variable" || V.style == "keyword")
            return V.marked = "property", B(pr);
          if (G == "?" || N == "number" || N == "string")
            return B(pr);
          if (N == ":")
            return B(tt);
          if (N == "[")
            return B(Ve("variable"), Hi, Ve("]"), pr);
          if (N == "(")
            return $(Yr, pr);
          if (!N.match(/[;\}\)\],]/))
            return B();
        }
        function Sn(N, G) {
          return N != "quasi" ? $() : G.slice(G.length - 2) != "${" ? B(Sn) : B(tt, Nt);
        }
        function Nt(N) {
          if (N == "}")
            return V.marked = "string-2", V.state.tokenize = L, B(Sn);
        }
        function Ot(N, G) {
          return N == "variable" && V.stream.match(/^\s*[?:]/, false) || G == "?" ? B(Ot) : N == ":" ? B(tt) : N == "spread" ? B(Ot) : $(tt);
        }
        function di(N, G) {
          if (G == "<") return B(Oe(">"), Ze(tt, ">"), Re, di);
          if (G == "|" || N == "." || G == "&") return B(tt);
          if (N == "[") return B(tt, Ve("]"), di);
          if (G == "extends" || G == "implements")
            return V.marked = "keyword", B(tt);
          if (G == "?") return B(tt, Ve(":"), tt);
        }
        function Jn(N, G) {
          if (G == "<") return B(Oe(">"), Ze(tt, ">"), Re, di);
        }
        function Ti() {
          return $(tt, bn);
        }
        function bn(N, G) {
          if (G == "=") return B(tt);
        }
        function ba(N, G) {
          return G == "enum" ? (V.marked = "keyword", B(Be)) : $(Nn, ci, Li, Yh);
        }
        function Nn(N, G) {
          if (h && ae(G))
            return V.marked = "keyword", B(Nn);
          if (N == "variable")
            return se(G), B();
          if (N == "spread") return B(Nn);
          if (N == "[") return _t(tl, "]");
          if (N == "{") return _t(Jr, "}");
        }
        function Jr(N, G) {
          return N == "variable" && !V.stream.match(/^\s*:/, false) ? (se(G), B(Li)) : (N == "variable" && (V.marked = "property"), N == "spread" ? B(Nn) : N == "}" ? $() : N == "[" ? B(De, Ve("]"), Ve(":"), Jr) : B(Ve(":"), Nn, Li));
        }
        function tl() {
          return $(Nn, Li);
        }
        function Li(N, G) {
          if (G == "=") return B(et);
        }
        function Yh(N) {
          if (N == ",") return B(ba);
        }
        function wa(N, G) {
          if (N == "keyword b" && G == "else") return B(Oe("form", "else"), qe, Re);
        }
        function jc(N, G) {
          if (G == "await") return B(jc);
          if (N == "(") return B(Oe(")"), nl, Re);
        }
        function nl(N) {
          return N == "var" ? B(ba, Kr) : N == "variable" ? B(Kr) : $(Kr);
        }
        function Kr(N, G) {
          return N == ")" ? B() : N == ";" ? B(Kr) : G == "in" || G == "of" ? (V.marked = "keyword", B(De, Kr)) : $(De, Kr);
        }
        function ui(N, G) {
          if (G == "*")
            return V.marked = "keyword", B(ui);
          if (N == "variable")
            return se(G), B(ui);
          if (N == "(") return B(Ne, Oe(")"), Ze(Di, ")"), Re, jr, qe, je);
          if (h && G == "<") return B(Oe(">"), Ze(Ti, ">"), Re, ui);
        }
        function Yr(N, G) {
          if (G == "*")
            return V.marked = "keyword", B(Yr);
          if (N == "variable")
            return se(G), B(Yr);
          if (N == "(") return B(Ne, Oe(")"), Ze(Di, ")"), Re, jr, je);
          if (h && G == "<") return B(Oe(">"), Ze(Ti, ">"), Re, Yr);
        }
        function Jc(N, G) {
          if (N == "keyword" || N == "variable")
            return V.marked = "type", B(Jc);
          if (G == "<")
            return B(Oe(">"), Ze(Ti, ">"), Re);
        }
        function Di(N, G) {
          return G == "@" && B(De, Di), N == "spread" ? B(Di) : h && ae(G) ? (V.marked = "keyword", B(Di)) : h && N == "this" ? B(ci, Li) : $(Nn, ci, Li);
        }
        function Xh(N, G) {
          return N == "variable" ? Ca(N, G) : Ii(N, G);
        }
        function Ca(N, G) {
          if (N == "variable")
            return se(G), B(Ii);
        }
        function Ii(N, G) {
          if (G == "<") return B(Oe(">"), Ze(Ti, ">"), Re, Ii);
          if (G == "extends" || G == "implements" || h && N == ",")
            return G == "implements" && (V.marked = "keyword"), B(h ? tt : De, Ii);
          if (N == "{") return B(Oe("}"), Pi, Re);
        }
        function Pi(N, G) {
          if (N == "async" || N == "variable" && (G == "static" || G == "get" || G == "set" || h && ae(G)) && V.stream.match(/^\s+#?[\w$\xa1-\uffff]/, false))
            return V.marked = "keyword", B(Pi);
          if (N == "variable" || V.style == "keyword")
            return V.marked = "property", B(Rs, Pi);
          if (N == "number" || N == "string") return B(Rs, Pi);
          if (N == "[")
            return B(De, ci, Ve("]"), Rs, Pi);
          if (G == "*")
            return V.marked = "keyword", B(Pi);
          if (h && N == "(") return $(Yr, Pi);
          if (N == ";" || N == ",") return B(Pi);
          if (N == "}") return B();
          if (G == "@") return B(De, Pi);
        }
        function Rs(N, G) {
          if (G == "!" || G == "?") return B(Rs);
          if (N == ":") return B(tt, Li);
          if (G == "=") return B(et);
          var ie = V.state.lexical.prev, fe = ie && ie.info == "interface";
          return $(fe ? Yr : ui);
        }
        function xa(N, G) {
          return G == "*" ? (V.marked = "keyword", B(Ta, Ve(";"))) : G == "default" ? (V.marked = "keyword", B(De, Ve(";"))) : N == "{" ? B(Ze(Ea, "}"), Ta, Ve(";")) : $(qe);
        }
        function Ea(N, G) {
          if (G == "as")
            return V.marked = "keyword", B(Ve("variable"));
          if (N == "variable") return $(et, Ea);
        }
        function Xr(N) {
          return N == "string" ? B() : N == "(" ? $(De) : N == "." ? $(ne) : $(ka, qi, Ta);
        }
        function ka(N, G) {
          return N == "{" ? _t(ka, "}") : (N == "variable" && se(G), G == "*" && (V.marked = "keyword"), B(il));
        }
        function qi(N) {
          if (N == ",") return B(ka, qi);
        }
        function il(N, G) {
          if (G == "as")
            return V.marked = "keyword", B(ka);
        }
        function Ta(N, G) {
          if (G == "from")
            return V.marked = "keyword", B(De);
        }
        function Vt(N) {
          return N == "]" ? B() : $(Ze(et, "]"));
        }
        function Be() {
          return $(Oe("form"), Nn, Ve("{"), Oe("}"), Ze(gr, "}"), Re, Re);
        }
        function gr() {
          return $(Nn, Li);
        }
        function rl(N, G) {
          return N.lastType == "operator" || N.lastType == "," || y.test(G.charAt(0)) || /[,.]/.test(G.charAt(0));
        }
        function ti(N, G, ie) {
          return G.tokenize == I && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(G.lastType) || G.lastType == "quasi" && /\{\s*$/.test(N.string.slice(0, N.pos - (ie || 0)));
        }
        return {
          startState: function(N) {
            var G = {
              tokenize: I,
              lastType: "sof",
              cc: [],
              lexical: new F((N || 0) - s, 0, "block", false),
              localVars: r.localVars,
              context: r.localVars && new Ee(null, null, false),
              indented: N || 0
            };
            return r.globalVars && typeof r.globalVars == "object" && (G.globalVars = r.globalVars), G;
          },
          token: function(N, G) {
            if (N.sol() && (G.lexical.hasOwnProperty("align") || (G.lexical.align = false), G.indented = N.indentation(), M(N, G)), G.tokenize != P && N.eatSpace()) return null;
            var ie = G.tokenize(N, G);
            return b == "comment" ? ie : (G.lastType = b == "operator" && (E == "++" || E == "--") ? "incdec" : b, U(G, ie, b, E, N));
          },
          indent: function(N, G) {
            if (N.tokenize == P || N.tokenize == L) return t.Pass;
            if (N.tokenize != I) return 0;
            var ie = G && G.charAt(0), fe = N.lexical, Q;
            if (!/^\s*else\b/.test(G)) for (var we = N.cc.length - 1; we >= 0; --we) {
              var ut = N.cc[we];
              if (ut == Re) fe = fe.prev;
              else if (ut != wa && ut != je) break;
            }
            for (; (fe.type == "stat" || fe.type == "form") && (ie == "}" || (Q = N.cc[N.cc.length - 1]) && (Q == ne || Q == te) && !/^[,\.=+\-*:?[\(]/.test(G)); )
              fe = fe.prev;
            a && fe.type == ")" && fe.prev.type == "stat" && (fe = fe.prev);
            var rn = fe.type, On = ie == rn;
            return rn == "vardef" ? fe.indented + (N.lastType == "operator" || N.lastType == "," ? fe.info.length + 1 : 0) : rn == "form" && ie == "{" ? fe.indented : rn == "form" ? fe.indented + s : rn == "stat" ? fe.indented + (rl(N, G) ? a || s : 0) : fe.info == "switch" && !On && r.doubleIndentSwitch != false ? fe.indented + (/^(?:case|default)\b/.test(G) ? s : 2 * s) : fe.align ? fe.column + (On ? 0 : 1) : fe.indented + (On ? 0 : s);
          },
          electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
          blockCommentStart: d ? null : "/*",
          blockCommentEnd: d ? null : "*/",
          blockCommentContinue: d ? null : " * ",
          lineComment: d ? null : "//",
          fold: "brace",
          closeBrackets: "()[]{}''\"\"``",
          helperType: d ? "json" : "javascript",
          jsonldMode: l,
          jsonMode: d,
          expressionAllowed: ti,
          skipExpression: function(N) {
            U(N, "atom", "atom", "true", new t.StringStream("", 2, null));
          }
        };
      }), t.registerHelper("wordChars", "javascript", /[\w$]/), t.defineMIME("text/javascript", "javascript"), t.defineMIME("text/ecmascript", "javascript"), t.defineMIME("application/javascript", "javascript"), t.defineMIME("application/x-javascript", "javascript"), t.defineMIME("application/ecmascript", "javascript"), t.defineMIME("application/json", { name: "javascript", json: true }), t.defineMIME("application/x-json", { name: "javascript", json: true }), t.defineMIME("application/manifest+json", { name: "javascript", json: true }), t.defineMIME("application/ld+json", { name: "javascript", jsonld: true }), t.defineMIME("text/typescript", { name: "javascript", typescript: true }), t.defineMIME("application/typescript", { name: "javascript", typescript: true });
    });
  }()), kE.exports;
}
v4();
var DE = { exports: {} };
var IE;
function cP() {
  return IE || (IE = 1, function(i, e) {
    (function(t) {
      t(Yo());
    })(function(t) {
      function n(l, d, u, h) {
        if (u && u.call) {
          var g = u;
          u = null;
        } else
          var g = a(l, u, "rangeFinder");
        typeof d == "number" && (d = t.Pos(d, 0));
        var v = a(l, u, "minFoldSize");
        function y(E) {
          var T = g(l, d);
          if (!T || T.to.line - T.from.line < v) return null;
          if (h === "fold") return T;
          for (var I = l.findMarksAt(T.from), R = 0; R < I.length; ++R)
            if (I[R].__isFold) {
              if (!E) return null;
              T.cleared = true, I[R].clear();
            }
          return T;
        }
        var C = y(true);
        if (a(l, u, "scanUp")) for (; !C && d.line > l.firstLine(); )
          d = t.Pos(d.line - 1, 0), C = y(false);
        if (!(!C || C.cleared || h === "unfold")) {
          var w = r(l, u, C);
          t.on(w, "mousedown", function(E) {
            b.clear(), t.e_preventDefault(E);
          });
          var b = l.markText(C.from, C.to, {
            replacedWith: w,
            clearOnEnter: a(l, u, "clearOnEnter"),
            __isFold: true
          });
          b.on("clear", function(E, T) {
            t.signal(l, "unfold", l, E, T);
          }), t.signal(l, "fold", l, C.from, C.to);
        }
      }
      function r(l, d, u) {
        var h = a(l, d, "widget");
        if (typeof h == "function" && (h = h(u.from, u.to)), typeof h == "string") {
          var g = document.createTextNode(h);
          h = document.createElement("span"), h.appendChild(g), h.className = "CodeMirror-foldmarker";
        } else h && (h = h.cloneNode(true));
        return h;
      }
      t.newFoldFunction = function(l, d) {
        return function(u, h) {
          n(u, h, { rangeFinder: l, widget: d });
        };
      }, t.defineExtension("foldCode", function(l, d, u) {
        n(this, l, d, u);
      }), t.defineExtension("isFolded", function(l) {
        for (var d = this.findMarksAt(l), u = 0; u < d.length; ++u)
          if (d[u].__isFold) return true;
      }), t.commands.toggleFold = function(l) {
        l.foldCode(l.getCursor());
      }, t.commands.fold = function(l) {
        l.foldCode(l.getCursor(), null, "fold");
      }, t.commands.unfold = function(l) {
        l.foldCode(l.getCursor(), { scanUp: false }, "unfold");
      }, t.commands.foldAll = function(l) {
        l.operation(function() {
          for (var d = l.firstLine(), u = l.lastLine(); d <= u; d++)
            l.foldCode(t.Pos(d, 0), { scanUp: false }, "fold");
        });
      }, t.commands.unfoldAll = function(l) {
        l.operation(function() {
          for (var d = l.firstLine(), u = l.lastLine(); d <= u; d++)
            l.foldCode(t.Pos(d, 0), { scanUp: false }, "unfold");
        });
      }, t.registerHelper("fold", "combine", function() {
        var l = Array.prototype.slice.call(arguments, 0);
        return function(d, u) {
          for (var h = 0; h < l.length; ++h) {
            var g = l[h](d, u);
            if (g) return g;
          }
        };
      }), t.registerHelper("fold", "auto", function(l, d) {
        for (var u = l.getHelpers(d, "fold"), h = 0; h < u.length; h++) {
          var g = u[h](l, d);
          if (g) return g;
        }
      });
      var s = {
        rangeFinder: t.fold.auto,
        widget: "↔",
        minFoldSize: 0,
        scanUp: false,
        clearOnEnter: true
      };
      t.defineOption("foldOptions", null);
      function a(l, d, u) {
        if (d && d[u] !== void 0)
          return d[u];
        var h = l.options.foldOptions;
        return h && h[u] !== void 0 ? h[u] : s[u];
      }
      t.defineExtension("foldOption", function(l, d) {
        return a(this, l, d);
      });
    });
  }()), DE.exports;
}
cP();
var PE = { exports: {} };
var RE;
function y4() {
  return RE || (RE = 1, function(i, e) {
    (function(t) {
      t(Yo(), cP());
    })(function(t) {
      t.defineOption("foldGutter", false, function(b, E, T) {
        T && T != t.Init && (b.clearGutter(b.state.foldGutter.options.gutter), b.state.foldGutter = null, b.off("gutterClick", g), b.off("changes", y), b.off("viewportChange", C), b.off("fold", w), b.off("unfold", w), b.off("swapDoc", y), b.off("optionChange", v)), E && (b.state.foldGutter = new r(s(E)), h(b), b.on("gutterClick", g), b.on("changes", y), b.on("viewportChange", C), b.on("fold", w), b.on("unfold", w), b.on("swapDoc", y), b.on("optionChange", v));
      });
      var n = t.Pos;
      function r(b) {
        this.options = b, this.from = this.to = 0;
      }
      function s(b) {
        return b === true && (b = {}), b.gutter == null && (b.gutter = "CodeMirror-foldgutter"), b.indicatorOpen == null && (b.indicatorOpen = "CodeMirror-foldgutter-open"), b.indicatorFolded == null && (b.indicatorFolded = "CodeMirror-foldgutter-folded"), b;
      }
      function a(b, E) {
        for (var T = b.findMarks(n(E, 0), n(E + 1, 0)), I = 0; I < T.length; ++I)
          if (T[I].__isFold) {
            var R = T[I].find(-1);
            if (R && R.line === E)
              return T[I];
          }
      }
      function l(b) {
        if (typeof b == "string") {
          var E = document.createElement("div");
          return E.className = b + " CodeMirror-guttermarker-subtle", E;
        } else
          return b.cloneNode(true);
      }
      function d(b, E, T) {
        var I = b.state.foldGutter.options, R = E - 1, P = b.foldOption(I, "minFoldSize"), L = b.foldOption(I, "rangeFinder"), A = typeof I.indicatorFolded == "string" && u(I.indicatorFolded), M = typeof I.indicatorOpen == "string" && u(I.indicatorOpen);
        b.eachLine(E, T, function(O) {
          ++R;
          var F = null, q = O.gutterMarkers;
          if (q && (q = q[I.gutter]), a(b, R)) {
            if (A && q && A.test(q.className)) return;
            F = l(I.indicatorFolded);
          } else {
            var U = n(R, 0), V = L && L(b, U);
            if (V && V.to.line - V.from.line >= P) {
              if (M && q && M.test(q.className)) return;
              F = l(I.indicatorOpen);
            }
          }
          !F && !q || b.setGutterMarker(O, I.gutter, F);
        });
      }
      function u(b) {
        return new RegExp("(^|\\s)" + b + "(?:$|\\s)\\s*");
      }
      function h(b) {
        var E = b.getViewport(), T = b.state.foldGutter;
        T && (b.operation(function() {
          d(b, E.from, E.to);
        }), T.from = E.from, T.to = E.to);
      }
      function g(b, E, T) {
        var I = b.state.foldGutter;
        if (I) {
          var R = I.options;
          if (T == R.gutter) {
            var P = a(b, E);
            P ? P.clear() : b.foldCode(n(E, 0), R);
          }
        }
      }
      function v(b, E) {
        E == "mode" && y(b);
      }
      function y(b) {
        var E = b.state.foldGutter;
        if (E) {
          var T = E.options;
          E.from = E.to = 0, clearTimeout(E.changeUpdate), E.changeUpdate = setTimeout(function() {
            h(b);
          }, T.foldOnChangeTimeSpan || 600);
        }
      }
      function C(b) {
        var E = b.state.foldGutter;
        if (E) {
          var T = E.options;
          clearTimeout(E.changeUpdate), E.changeUpdate = setTimeout(function() {
            var I = b.getViewport();
            E.from == E.to || I.from - E.to > 20 || E.from - I.to > 20 ? h(b) : b.operation(function() {
              I.from < E.from && (d(b, I.from, E.from), E.from = I.from), I.to > E.to && (d(b, E.to, I.to), E.to = I.to);
            });
          }, T.updateViewportTimeSpan || 400);
        }
      }
      function w(b, E) {
        var T = b.state.foldGutter;
        if (T) {
          var I = E.line;
          I >= T.from && I < T.to && d(b, I, I + 1);
        }
      }
    });
  }()), PE.exports;
}
y4();
var AE = { exports: {} };
var _E;
function S4() {
  return _E || (_E = 1, function(i, e) {
    (function(t) {
      t(Yo());
    })(function(t) {
      function n(r) {
        return function(s, a) {
          var l = a.line, d = s.getLine(l);
          function u(w) {
            for (var b, E = a.ch, T = 0; ; ) {
              var I = E <= 0 ? -1 : d.lastIndexOf(w[0], E - 1);
              if (I == -1) {
                if (T == 1) break;
                T = 1, E = d.length;
                continue;
              }
              if (T == 1 && I < a.ch) break;
              if (b = s.getTokenTypeAt(t.Pos(l, I + 1)), !/^(comment|string)/.test(b)) return { ch: I + 1, tokenType: b, pair: w };
              E = I - 1;
            }
          }
          function h(w) {
            var b = 1, E = s.lastLine(), T, I = w.ch, R;
            e: for (var P = l; P <= E; ++P)
              for (var L = s.getLine(P), A = P == l ? I : 0; ; ) {
                var M = L.indexOf(w.pair[0], A), O = L.indexOf(w.pair[1], A);
                if (M < 0 && (M = L.length), O < 0 && (O = L.length), A = Math.min(M, O), A == L.length) break;
                if (s.getTokenTypeAt(t.Pos(P, A + 1)) == w.tokenType) {
                  if (A == M) ++b;
                  else if (!--b) {
                    T = P, R = A;
                    break e;
                  }
                }
                ++A;
              }
            return T == null || l == T ? null : {
              from: t.Pos(l, I),
              to: t.Pos(T, R)
            };
          }
          for (var g = [], v = 0; v < r.length; v++) {
            var y = u(r[v]);
            y && g.push(y);
          }
          g.sort(function(w, b) {
            return w.ch - b.ch;
          });
          for (var v = 0; v < g.length; v++) {
            var C = h(g[v]);
            if (C) return C;
          }
          return null;
        };
      }
      t.registerHelper("fold", "brace", n([["{", "}"], ["[", "]"]])), t.registerHelper("fold", "brace-paren", n([["{", "}"], ["[", "]"], ["(", ")"]])), t.registerHelper("fold", "import", function(r, s) {
        function a(v) {
          if (v < r.firstLine() || v > r.lastLine()) return null;
          var y = r.getTokenAt(t.Pos(v, 1));
          if (/\S/.test(y.string) || (y = r.getTokenAt(t.Pos(v, y.end + 1))), y.type != "keyword" || y.string != "import") return null;
          for (var C = v, w = Math.min(r.lastLine(), v + 10); C <= w; ++C) {
            var b = r.getLine(C), E = b.indexOf(";");
            if (E != -1) return { startCh: y.end, end: t.Pos(C, E) };
          }
        }
        var l = s.line, d = a(l), u;
        if (!d || a(l - 1) || (u = a(l - 2)) && u.end.line == l - 1)
          return null;
        for (var h = d.end; ; ) {
          var g = a(h.line + 1);
          if (g == null) break;
          h = g.end;
        }
        return { from: r.clipPos(t.Pos(l, d.startCh + 1)), to: h };
      }), t.registerHelper("fold", "include", function(r, s) {
        function a(g) {
          if (g < r.firstLine() || g > r.lastLine()) return null;
          var v = r.getTokenAt(t.Pos(g, 1));
          if (/\S/.test(v.string) || (v = r.getTokenAt(t.Pos(g, v.end + 1))), v.type == "meta" && v.string.slice(0, 8) == "#include") return v.start + 8;
        }
        var l = s.line, d = a(l);
        if (d == null || a(l - 1) != null) return null;
        for (var u = l; ; ) {
          var h = a(u + 1);
          if (h == null) break;
          ++u;
        }
        return {
          from: t.Pos(l, d + 1),
          to: r.clipPos(t.Pos(u))
        };
      });
    });
  }()), AE.exports;
}
S4();
var b4 = Yo();
var hs = Ws(b4);
var w4 = 100;
var C4 = class extends Gh {
  constructor(e) {
    super(), this.viewer = e, this.parsedValue = null, this.debouncedValueUpdater = dt(() => {
      const s = this.textEditor.getValue();
      try {
        const a = JSON.parse(s);
        this.parsedValue = a, this.applyButton.disabled = false, this.textEditor.setOption("lint", void 0);
      } catch (a) {
        this.parsedValue = null, this.applyButton.disabled = true;
        let l = 0, d = 0, u = "Unknown parse error";
        if (a instanceof Error) {
          const h = a.message.match(/^((?:.|\n)*) in JSON at position ([0-9]+)$/);
          if (h !== null) {
            u = h[1];
            const g = parseInt(h[2], 10), y = s.substring(0, g).split(`
`);
            l = y.length - 1, d = y[y.length - 1].length;
          } else
            u = a.message;
        }
        this.textEditor.setOption("lint", {
          getAnnotations: () => [{
            message: u,
            severity: "error",
            from: hs.Pos(l, d)
          }]
        });
      }
    }, w4), this.content.classList.add("neuroglancer-state-editor");
    const t = this.applyButton = document.createElement("button");
    t.textContent = "Apply changes", this.content.appendChild(t), t.addEventListener("click", () => this.applyChanges()), t.disabled = true;
    const n = this.closeButton = document.createElement("button");
    n.classList.add("close-button"), n.textContent = "Close", this.content.appendChild(n), n.addEventListener("click", () => this.dispose());
    const r = this.downloadButton = document.createElement("button");
    r.textContent = "Download", r.title = "Download state as a JSON file", this.content.appendChild(r), r.addEventListener("click", () => this.downloadState()), this.textEditor = hs((s) => {
    }, {
      value: "",
      mode: { name: "javascript", json: true },
      foldGutter: true,
      gutters: ["CodeMirror-lint-markers", "CodeMirror-foldgutter"]
    }), this.updateView(), this.textEditor.on("change", () => {
      this.debouncedValueUpdater();
    }), this.content.appendChild(this.textEditor.getWrapperElement()), this.textEditor.refresh();
  }
  downloadState() {
    const e = document.createElement("a"), t = new Blob([this.getJson()], { type: "text/json" }), n = URL.createObjectURL(t);
    e.href = n, e.download = "state.json", e.click(), document.body.removeChild(e);
  }
  applyChanges() {
    this.parsedValue !== null && (this.viewer.state.reset(), this.viewer.state.restoreState(this.parsedValue)), this.applyButton.disabled = true;
  }
  updateView() {
    this.textEditor.setValue(this.getJson()), this.textEditor.execCommand("foldAll"), this.textEditor.execCommand("unfold");
  }
  getJson() {
    return oe(xh(this.viewer.state).value, null, "  ");
  }
};
var Ud = {};
var ME;
function x4() {
  if (ME) return Ud;
  ME = 1, Ud.__esModule = true;
  var i = lT(), e = t(i);
  function t(n) {
    return n && n.__esModule ? n : { default: n };
  }
  return Ud.default = function(n) {
    return Array.isArray(n) ? n : (0, e.default)(n);
  }, Ud;
}
var E4 = x4();
var k4 = Ws(E4);
var T4 = {
  side: "bottom",
  size: 100,
  minSize: 50,
  row: 0,
  col: 0,
  flex: 1,
  visible: false
};
var L4 = class {
  constructor() {
    this.location = new Is(T4);
  }
  get changed() {
    return this.location.changed;
  }
  restoreState(e) {
    this.location.restoreState(e);
  }
  reset() {
    this.location.reset();
  }
  toJSON() {
    return ha(this.location.toJSON());
  }
};
function D4(i) {
  const e = new he();
  function t(n, r) {
    if (typeof n != "object") {
      e.set(r, "" + n);
      return;
    }
    for (const s of hn(n))
      t(n[s], r + "." + s);
  }
  return t(i, ""), e;
}
function I4(i) {
  const e = new Ye();
  e.add(".type");
  const t = new Ye();
  function n(r, s) {
    for (const a of e)
      if (i[r].get(a) !== i[s].get(a))
        return true;
    return false;
  }
  for (let r = 0, s = i.length; r < s; ++r) {
    for (const l of i[r].keys())
      t.add(l);
    let a = [];
    for (let l = 0; l < r; ++l)
      n(r, l) || a.push(l);
    for (; a.length > 0; ) {
      let l = a, d;
      for (const u of t) {
        if (e.has(u)) continue;
        const h = [];
        for (const g of a)
          i[g].get(u) === i[r].get(u) && h.push(g);
        if (h.length < l.length && (l = h, d = u), h.length === 0) break;
      }
      if (d === void 0) break;
      a = l, e.add(d);
    }
  }
  return _e(e);
}
function P4(i, e) {
  const t = {};
  for (const n of e) {
    const r = i.get(n);
    if (r !== void 0) {
      if (n === "") return r;
      t[n] = r;
    }
  }
  return oe(t);
}
function R4(i) {
  return H({ type: i.RPC_TYPE_ID }, i.key || {});
}
function A4(i) {
  const e = i.map(D4), t = I4(e);
  return e.map((n) => P4(n, t));
}
var _4 = 1e3;
var tm = [{
  label: "Visible chunks/T",
  key: "visibleChunksTotal",
  getter: (i) => {
    let e = 0;
    for (let t = 0; t < EL; ++t)
      e += i[$s(t, xr.VISIBLE) * ds + Er.numChunks];
    return e;
  }
}, {
  label: "Visible chunks/D",
  key: "visibleChunksDownloading",
  getter: (i) => i[$s(kt.DOWNLOADING, xr.VISIBLE) * ds + Er.numChunks]
}, {
  label: "Visible chunks/M",
  key: "visibleChunksSystemMemory",
  getter: (i) => i[$s(kt.SYSTEM_MEMORY, xr.VISIBLE) * ds + Er.numChunks] + i[$s(kt.SYSTEM_MEMORY_WORKER, xr.VISIBLE) * ds + Er.numChunks]
}, {
  label: "Visible chunks/G",
  key: "visibleChunksGpuMemory",
  getter: (i) => i[$s(kt.GPU_MEMORY, xr.VISIBLE) * ds + Er.numChunks]
}, {
  label: "Visible chunks/F",
  key: "visibleChunksFailed",
  getter: (i) => i[$s(kt.FAILED, xr.VISIBLE) * ds + Er.numChunks]
}, {
  label: "Visible memory",
  key: "visibleGpuMemory",
  getter: (i) => i[$s(kt.GPU_MEMORY, xr.VISIBLE) * ds + Er.gpuMemoryBytes]
}, {
  label: "Download latency",
  key: "downloadLatency",
  getter: (i) => i[ix(vu.totalTime)] / i[ix(vu.totalChunks)]
}];
var M4 = class extends ma {
  constructor(e, t, n) {
    super(e, n.location), this.chunkQueueManager = t, this.displayState = n, this.data = void 0, this.requestDataTimerId = -1, this.dataRequested = false, this.body = document.createElement("div"), this.debouncedUpdateView = this.registerCancellable(dt(() => this.updateView(), 0));
    const r = this.body;
    r.classList.add("neuroglancer-statistics-panel-body"), this.addTitleBar({ title: "Chunk statistics" }), this.addBody(r), this.requestData();
  }
  disposed() {
    window.clearTimeout(this.requestDataTimerId), super.disposed();
  }
  requestData() {
    if (this.dataRequested) return;
    const e = this.chunkQueueManager;
    this.dataRequested = true, e.getStatistics().then((t) => {
      this.dataRequested = false, this.data = t, this.debouncedUpdateView(), this.requestDataTimerId = window.setTimeout(() => {
        this.requestDataTimerId = -1, this.requestData();
      }, _4);
    });
  }
  updateView() {
    const e = this.data;
    if (e === void 0) return;
    const t = document.createElement("table"), n = [];
    for (const u of e) {
      var r = de(u, 2);
      const h = r[0], g = r[1], v = [h];
      for (const y of tm) {
        const C = y.getter;
        v.push(C(g));
      }
      n.push(v);
    }
    const s = A4(n.map((u) => R4(u[0]))), a = new he();
    s.forEach((u, h) => {
      a.set(n[h][0], u);
    });
    {
      const u = document.createElement("thead");
      let h = document.createElement("tr");
      u.appendChild(h);
      const g = (y) => {
        const C = document.createElement("td");
        C.textContent = y, h.appendChild(C);
      };
      g("Name");
      let v;
      for (const y of tm) {
        const C = y.label, w = C.indexOf("/");
        let b = C;
        if (w !== -1) {
          if (b = C.substring(0, w), b === v) {
            ++h.lastElementChild.colSpan;
            continue;
          }
          v = b;
        }
        g(b);
      }
      h = document.createElement("tr"), u.appendChild(h);
      {
        const y = document.createElement("td");
        h.appendChild(y);
      }
      for (const y of tm) {
        const C = y.label, w = C.indexOf("/");
        let b = "";
        w !== -1 && (b = C.substring(w + 1));
        const E = document.createElement("td");
        E.textContent = b, h.appendChild(E);
      }
      t.appendChild(u);
    }
    const l = document.createElement("tbody");
    for (const u of n) {
      var d = k4(u);
      const h = d[0], g = d.slice(1), v = document.createElement("tr"), y = (C) => {
        const w = document.createElement("td");
        w.textContent = C, v.appendChild(w);
      };
      y(a.get(h));
      for (const C of g)
        y("" + C);
      l.appendChild(v);
    }
    t.appendChild(l), st(this.body), this.body.appendChild(t);
  }
};
var xS = class extends X {
  constructor(e, t = () => wt(1, 0, 0)) {
    super(), this.model = e, this.getDefaultColor = t, this.element = document.createElement("input");
    const n = this.element;
    n.classList.add("neuroglancer-color-widget"), n.type = "color", n.addEventListener("change", () => this.updateModel()), n.addEventListener("input", () => this.updateModel()), n.addEventListener("wheel", (r) => {
      r.stopPropagation(), r.preventDefault(), this.adjustHueViaWheel(r);
    }), this.registerDisposer(e.changed.add(() => this.updateView())), this.updateView();
  }
  getRGB() {
    var e;
    return (e = this.model.value) !== null && e !== void 0 ? e : this.getDefaultColor();
  }
  updateView() {
    this.element.value = Hn(this.getRGB());
  }
  updateModel() {
    this.model.value = ua(this.element.value);
  }
  adjustHueViaWheel(e) {
    const t = this.getRGB(), n = ze();
    SU(n, t[0], t[1], t[2]);
    const r = e.deltaY;
    let s = Math.round(n[0] * 256);
    s += r > 0 ? 1 : r < 0 ? -1 : 0, s = (s + 256) % 256, n[0] = s / 256, ku(n, n[0], n[1], n[2]), this.model.value = n;
  }
};
var N4 = class extends X {
  constructor(e, t = {}) {
    super(), this.model = e, this.element = document.createElement("label"), this.inputElement = document.createElement("input");
    let n = t.validator, r = t.label;
    const s = this.element, a = this.inputElement;
    n === void 0 && (e instanceof fn ? n = e.validator : n = (l) => l), this.validator = n, r !== void 0 && (s.textContent = r), s.appendChild(a), s.className = "neuroglancer-number-input", a.type = "text", this.registerDisposer(this.model.changed.add(() => this.updateView())), this.registerEventListener(a, "change", () => this.updateModel()), this.updateView();
  }
  updateView() {
    this.inputElement.value = "" + this.model.value;
  }
  updateModel() {
    let e = parseFloat(this.inputElement.value.trim());
    if (er(e)) {
      this.updateView();
      return;
    }
    try {
      e = this.validator(e), this.model.value = e;
    } catch {
      this.updateView();
    }
  }
  disposed() {
    Ut(this.element), super.disposed();
  }
};
var dP = class extends X {
  constructor(e) {
    super(), this.model = e, this.element = document.createElement("input"), this.registerDisposer(e.changed.add(() => this.updateView()));
    const t = this.element;
    t.type = "text", this.registerEventListener(t, "change", () => this.updateModel()), this.updateView();
  }
  disposed() {
    Ut(this.element);
  }
  updateView() {
    var e;
    this.element.value = ((e = this.model.value) !== null && e !== void 0 ? e : "") + "";
  }
  updateModel() {
    try {
      this.model.restoreState(this.element.value);
    } catch {
    }
    this.updateView();
  }
};
var O4 = H(H({}, ga), { side: "left", row: 2 });
var V4 = class {
  constructor() {
    this.location = new Is(O4);
  }
  get changed() {
    return this.location.changed;
  }
  toJSON() {
    return ha(this.location.toJSON());
  }
  reset() {
    this.location.reset();
  }
  restoreState(e) {
    this.location.restoreState(e);
  }
};
var B4 = class extends ma {
  constructor(e, t, n) {
    super(e, t.location), this.addTitleBar({ title: "Settings" });
    const r = document.createElement("div");
    r.classList.add("neuroglancer-settings-body");
    let s = document.createElement("div");
    s.classList.add("neuroglancer-settings-scroll-container"), r.appendChild(s), this.addBody(r);
    {
      const u = this.registerDisposer(new dP(n.title));
      u.element.placeholder = "Title", u.element.classList.add("neuroglancer-settings-title"), s.appendChild(u.element);
    }
    const a = (u, h) => {
      const g = this.registerDisposer(new N4(h, { label: u }));
      g.element.classList.add("neuroglancer-settings-limit-widget"), s.appendChild(g.element);
    };
    a("GPU memory limit", n.chunkQueueManager.capacities.gpuMemory.sizeLimit), a("System memory limit", n.chunkQueueManager.capacities.systemMemory.sizeLimit), a("Concurrent chunk requests", n.chunkQueueManager.capacities.download.itemLimit);
    const l = (u, h) => {
      const g = document.createElement("label");
      g.textContent = u;
      const v = this.registerDisposer(new Ls(h));
      g.appendChild(v.element), s.appendChild(g);
    };
    l("Show axis lines", n.showAxisLines), l("Show scale bar", n.showScaleBar), l("Show cross sections in 3-d", n.showPerspectiveSliceViews), l("Show default annotations", n.showDefaultAnnotations), l("Show chunk statistics", n.statisticsDisplayState.location.watchableVisible), l("Wire frame rendering", n.wireFrame), l("Enable prefetching", n.chunkQueueManager.enablePrefetch);
    const d = (u, h) => {
      const g = document.createElement("label");
      g.textContent = u;
      const v = this.registerDisposer(new xS(h));
      g.appendChild(v.element), s.appendChild(g);
    };
    d("Cross-section background", n.crossSectionBackgroundColor), d("Projection background", n.perspectiveViewBackgroundColor);
  }
};
var F4 = class extends X {
  constructor(e, t) {
    super(), this.selectedLayer = e, this.toolBinder = t, this.element = document.createElement("div"), this.viewContext = void 0, this.updateView = this.registerCancellable(Ct(() => {
      let r = this.viewContext;
      r !== void 0 && (this.unregisterDisposer(r), r.dispose()), this.viewContext = r = this.registerDisposer(new X()), st(this.element);
      const s = this.selectedTool;
      s !== void 0 && this.element.appendChild(this.makeWidget(r, s));
      const a = _e(this.toolBinder.bindings);
      a.sort(([d], [u]) => Ac(d, u));
      for (const d of a) {
        var l = de(d, 2);
        const u = l[1];
        this.element.appendChild(this.makeWidget(r, u));
      }
    }));
    const n = this.element;
    n.className = "neuroglancer-annotation-tool-status", this.registerDisposer(e.changed.add(() => this.selectedLayerChanged())), this.registerDisposer(t.changed.add(this.updateView)), this.registerDisposer(this.selectedLayer.layerManager.layersChanged.add(this.updateView)), this.selectedLayerChanged();
  }
  get selectedTool() {
    const e = this.selectedLayer.layer;
    if (e === void 0)
      return;
    const t = e.layer;
    if (t !== null)
      return t.tool.value;
  }
  selectedLayerChanged() {
    let e = this.unbindPreviousLayer;
    e !== void 0 && e();
    const t = this.selectedLayer.layer;
    t !== void 0 && (this.unbindPreviousLayer = t.specificationChanged.add(() => {
      this.updateView();
    })), this.updateView();
  }
  disposed() {
    const e = this.unbindPreviousLayer;
    e !== void 0 && e(), this.unbindPreviousLayer = void 0;
  }
  makeWidget(e, t) {
    const n = document.createElement("div");
    n.title = "dblclick → unbind", t instanceof Po && (n.title += ", click → bind key"), n.className = "neuroglancer-annotation-tool-status-widget";
    const r = document.createElement("div");
    r.className = "neuroglancer-annotation-tool-status-widget-layer-number";
    const s = t.layer.managedLayer;
    s.manager.rootLayers.updateNonArchivedLayerIndices();
    const a = s.nonArchivedLayerIndex;
    r.textContent = (a + 1).toString();
    const l = document.createElement("div");
    if (l.className = "neuroglancer-annotation-tool-status-widget-description", l.textContent = t.description, n.addEventListener("dblclick", () => {
      t instanceof II ? t.layer.tool.value = void 0 : this.toolBinder.set(t.keyBinding, void 0);
    }), t instanceof Po) {
      const d = document.createElement("div");
      d.className = "neuroglancer-annotation-tool-status-widget-key", d.textContent = t.keyBinding, n.appendChild(d), AI(e, n, (u) => t.layer.toolBinder.set(u, t.addRef()));
    }
    return n.appendChild(r), n.appendChild(l), n;
  }
};
function ES(i) {
  return encodeURI(i).replace(/[!'()*;,]/g, function(e) {
    return "%" + e.charCodeAt(0).toString(16).toUpperCase();
  });
}
var U4 = class extends X {
  constructor(e, t, n = {}) {
    super(), this.root = e, this.credentialsManager = t, this.parseError = new vt(void 0);
    var r = n.updateDelayMilliseconds;
    const s = r === void 0 ? 200 : r;
    var a = n.defaultFragment;
    const l = a === void 0 ? "{}" : a;
    this.registerEventListener(window, "hashchange", () => this.updateFromUrlHash());
    const d = dt(() => this.setUrlHash(), s);
    this.registerDisposer(e.changed.add(d)), this.registerDisposer(() => d.cancel()), this.defaultFragment = l;
  }
  /**
   * Sets the URL hash to match the current state.
   */
  setUrlHash() {
    const e = xh(this.root);
    if (e.generation !== this.prevStateGeneration) {
      this.prevStateGeneration = e.generation;
      let n = ES(oe(e.value));
      n !== this.prevStateString && (this.prevStateString = n, decodeURIComponent(n) === "{}" ? history.replaceState(null, "", "#") : history.replaceState(null, "", "#!" + n));
    }
  }
  /**
   * Sets the current state to match the URL hash.  If it is desired to initialize the state based
   * on the URL hash, then this should be called immediately after construction.
   */
  updateFromUrlHash() {
    try {
      let t = location.href.replace(/^[^#]+/, "");
      if ((t === "" || t === "#" || t === "#!") && (t = "#!" + this.defaultFragment), t.match(/^#!([a-z][a-z\d+-.]*):\/\//)) {
        const n = t.substring(2);
        var e = Ko(n, this.credentialsManager);
        const r = e.url, s = e.credentialsProvider;
        rt.forPromise(ya(s, r, {}, Wi).then((a) => {
          me(a), this.root.reset(), this.root.restoreState(a);
        }), { initialMessage: `Loading state from ${n}`, errorPrefix: "Error loading state:" });
      } else if (t.startsWith("#!+")) {
        t = t.slice(3), t = decodeURIComponent(t);
        let n = du(t);
        me(n), this.root.restoreState(n), this.prevStateString = void 0;
      } else if (t.startsWith("#!")) {
        if (t = t.slice(2), t = decodeURIComponent(t), t === this.prevStateString)
          return;
        this.prevStateString = t, this.root.reset();
        let n = du(t);
        me(n), this.root.restoreState(n);
      } else
        throw new Error('URL hash is expected to be of the form "#!{...}" or "#!+{...}".');
      this.parseError.value = void 0;
    } catch (t) {
      this.parseError.value = t;
    }
  }
};
var z4 = Object.freeze(Object.defineProperty({
  __proto__: null,
  UrlHashBinding: U4,
  encodeFragment: ES
}, Symbol.toStringTag, { value: "Module" }));
var $4 = class extends X {
  constructor(e, t, n = "") {
    super(), this.gl = e, this.frameNumberCounter = t;
    const r = n + "chunk_worker.bundle.js";
    this.worker = typeof n == "string" ? new Worker(r) : n, this.chunkQueueManager = this.registerDisposer(new Gm(new nB(this.worker), this.gl, this.frameNumberCounter, {
      gpuMemory: new Id({ defaultItemLimit: 1e6, defaultSizeLimit: 1e9 }),
      systemMemory: new Id({ defaultItemLimit: 1e7, defaultSizeLimit: 2e9 }),
      download: new Id({ defaultItemLimit: 100, defaultSizeLimit: Number.POSITIVE_INFINITY }),
      compute: new Id({ defaultItemLimit: 128, defaultSizeLimit: 5e8 })
    })), this.chunkQueueManager.registerDisposer(() => this.worker.terminate()), this.chunkManager = this.registerDisposer(new Wm(this.chunkQueueManager));
  }
  get rpc() {
    return this.chunkQueueManager.rpc;
  }
};
var uP = ["showHelpButton", "showSettingsButton", "showEditStateButton", "showLayerListPanelButton", "showSelectionPanelButton", "showLayerSidePanelButton", "showLocation", "showAnnotationToolStatus"];
var hP = [...uP, "showLayerPanel", "showLayerHoverValues"];
var fP = [...hP, "showUIControls", "showPanelBorders"];
function G4() {
  return Object.fromEntries(fP.map((i) => [i, new nn(true)]));
}
function W4(i, e) {
  for (const t of fP) {
    const n = e[t];
    n !== void 0 && (i[t].value = n);
  }
}
var H4 = typeof NEUROGLANCER_OVERRIDE_DEFAULT_VIEWER_OPTIONS < "u" ? NEUROGLANCER_OVERRIDE_DEFAULT_VIEWER_OPTIONS : {
  showLayerDialog: true,
  resetStateWhenEmpty: true
};
var q4 = class extends Ch {
  constructor(e) {
    super(), this.viewer = e, this.add("title", e.title), this.add("dimensions", e.coordinateSpace), this.add("relativeDisplayScales", e.relativeDisplayScales), this.add("displayDimensions", e.displayDimensions), this.add("position", e.position), this.add("crossSectionOrientation", e.crossSectionOrientation), this.add("crossSectionScale", e.crossSectionScale), this.add("crossSectionDepth", e.crossSectionDepthRange), this.add("projectionOrientation", e.projectionOrientation), this.add("projectionScale", e.projectionScale), this.add("projectionDepth", e.projectionDepthRange), this.add("layers", e.layerSpecification), this.add("showAxisLines", e.showAxisLines), this.add("wireFrame", e.wireFrame), this.add("showScaleBar", e.showScaleBar), this.add("showDefaultAnnotations", e.showDefaultAnnotations), this.add("showSlices", e.showPerspectiveSliceViews), this.add("gpuMemoryLimit", e.dataContext.chunkQueueManager.capacities.gpuMemory.sizeLimit), this.add("prefetch", e.dataContext.chunkQueueManager.enablePrefetch), this.add("systemMemoryLimit", e.dataContext.chunkQueueManager.capacities.systemMemory.sizeLimit), this.add("concurrentDownloads", e.dataContext.chunkQueueManager.capacities.download.itemLimit), this.add("selectedLayer", e.selectedLayer), this.add("crossSectionBackgroundColor", e.crossSectionBackgroundColor), this.add("projectionBackgroundColor", e.perspectiveViewBackgroundColor), this.add("layout", e.layout), this.add("statistics", e.statisticsDisplayState), this.add("helpPanel", e.helpPanelState), this.add("settingsPanel", e.settingsPanelState), this.add("selection", e.selectionDetailsState), this.add("layerListPanel", e.layerListPanelState), this.add("partialViewport", e.partialViewport), this.add("selectedStateServer", e.selectedStateServer);
  }
  restoreState(e) {
    const t = this.viewer;
    super.restoreState(e), xe(e, "navigation", (n) => {
      me(n), xe(n, "pose", (r) => {
        me(r), xe(r, "position", (s) => {
          me(s), Dn(s, "voxelCoordinates", t.position), xe(s, "voxelSize", (a) => {
            const l = lt(new Float64Array(3), a, yn);
            for (let d = 0; d < 3; ++d)
              l[d] *= 1e-9;
            t.coordinateSpace.value = yt({
              valid: false,
              names: ["x", "y", "z"],
              units: ["m", "m", "m"],
              scales: l
            });
          });
        }), Dn(r, "orientation", t.crossSectionOrientation);
      }), Dn(n, "zoomFactor", t.crossSectionScale.legacyJsonView);
    }), Dn(e, "perspectiveOrientation", t.projectionOrientation), Dn(e, "perspectiveZoom", t.projectionScale.legacyJsonView), Dn(e, "perspectiveViewBackgroundColor", t.perspectiveViewBackgroundColor);
  }
};
var vs = {
  expectingExternalUI: false
};
var j4 = class extends X {
  constructor(e, t = {}) {
    super(), this.display = e, this.title = new fn(void 0, Ae), this.coordinateSpace = new Ey(), this.position = this.registerDisposer(new Js(this.coordinateSpace)), this.relativeDisplayScales = this.registerDisposer(new GD(this.coordinateSpace)), this.displayDimensions = this.registerDisposer(new HD(this.coordinateSpace)), this.displayDimensionRenderInfo = this.registerDisposer(new WD(this.relativeDisplayScales.addRef(), this.displayDimensions.addRef())), this.crossSectionOrientation = this.registerDisposer(new ko()), this.crossSectionScale = this.registerDisposer(new q3(this.displayDimensionRenderInfo.addRef())), this.projectionOrientation = this.registerDisposer(new ko()), this.crossSectionDepthRange = this.registerDisposer(new Xm(-10, this.displayDimensionRenderInfo)), this.projectionDepthRange = this.registerDisposer(new Xm(-50, this.displayDimensionRenderInfo)), this.projectionScale = this.registerDisposer(new j3(this.displayDimensionRenderInfo.addRef())), this.navigationState = this.registerDisposer(new Lo(new To(this.position.addRef(), this.displayDimensionRenderInfo.addRef(), this.crossSectionOrientation.addRef()), this.crossSectionScale.addRef(), this.crossSectionDepthRange.addRef())), this.perspectiveNavigationState = this.registerDisposer(new Lo(new To(this.position.addRef(), this.displayDimensionRenderInfo.addRef(), this.projectionOrientation.addRef()), this.projectionScale.addRef(), this.projectionDepthRange.addRef())), this.mouseState = new X4(), this.layerManager = this.registerDisposer(new pP()), this.selectedLayer = this.registerDisposer(new rW(this.layerManager.addRef())), this.showAxisLines = new nn(true, true), this.wireFrame = new nn(false, false), this.showScaleBar = new nn(true, true), this.showPerspectiveSliceViews = new nn(true, true), this.visibleLayerRoles = lB(), this.showDefaultAnnotations = new nn(true, true), this.crossSectionBackgroundColor = new Ql(wt(0.5, 0.5, 0.5)), this.perspectiveViewBackgroundColor = new Ql(wt(0, 0, 0)), this.scaleBarOptions = new M$(), this.partialViewport = new MV(), this.statisticsDisplayState = new L4(), this.helpPanelState = new TG(), this.settingsPanelState = new V4(), this.layerSelectedValues = this.registerDisposer(new Z4(this.layerManager, this.mouseState)), this.selectionDetailsState = this.registerDisposer(new Q4(this.coordinateSpace, this.layerSelectedValues)), this.selectedStateServer = new fn("", Ae), this.layerListPanelState = new d4(), this.resetInitiated = new Le(), this.makeUrlFromState = (I) => vs.expectingExternalUI ? "/#!" + ES(oe(I)) : window.location.toString(), this.uiControlVisibility = {}, this.visible = true, this.toolInputEventMapBinder = (I, R) => {
      R.registerDisposer(this.inputEventBindings.sliceView.addParent(I, Number.POSITIVE_INFINITY)), R.registerDisposer(this.inputEventBindings.perspectiveView.addParent(I, Number.POSITIVE_INFINITY));
    }, this.toolBinder = this.registerDisposer(new t$(this.toolInputEventMapBinder));
    var n = t.dataContext;
    const r = n === void 0 ? new $4(e.gl, e, t.bundleRoot) : n;
    var s = t.visibility;
    const a = s === void 0 ? new Zt(Zt.VISIBLE) : s;
    var l = t.inputEventBindings;
    const d = l === void 0 ? {
      global: new St(),
      sliceView: new St(),
      perspectiveView: new St()
    } : l;
    var u = t.element;
    const h = u === void 0 ? e.makeCanvasOverlayElement() : u;
    var g = t.dataSourceProvider;
    const v = g === void 0 ? dG({ credentialsManager: Jo }) : g;
    var y = t.uiConfiguration;
    const C = y === void 0 ? G4() : y;
    this.visibility = a, this.inputEventBindings = d, this.element = h, this.dataSourceProvider = v, this.uiConfiguration = C, this.registerDisposer(_r((I) => {
      this.display.applyWindowedViewportToElement(h, I);
    }, this.partialViewport)), this.registerDisposer(() => Ut(this.element)), this.dataContext = this.registerDisposer(r), W4(C, t);
    const w = H(H({}, H4), t), b = w.resetStateWhenEmpty, E = w.showLayerDialog;
    for (const I of hP)
      this.uiControlVisibility[I] = this.makeUiControlVisibilityState(I);
    this.registerDisposer(this.uiConfiguration.showPanelBorders.changed.add(() => {
      this.updateShowBorders();
    })), this.showLayerDialog = E, this.resetStateWhenEmpty = b, this.layerSpecification = new oW(this.display, this.dataSourceProvider, this.layerManager, this.chunkManager, this.selectionDetailsState, this.selectedLayer, this.navigationState.coordinateSpace, this.navigationState.pose.position, this.toolBinder), this.registerDisposer(e.updateStarted.add(() => {
      this.onUpdateDisplay();
    })), this.showDefaultAnnotations.changed.add(() => {
      this.showDefaultAnnotations.value ? this.visibleLayerRoles.add(Ei.DEFAULT_ANNOTATION) : this.visibleLayerRoles.delete(Ei.DEFAULT_ANNOTATION);
    }), this.registerDisposer(this.navigationState.changed.add(() => {
      this.handleNavigationStateChanged();
    }));
    const T = this.registerCancellable(dt(() => {
      !this.wasDisposed && this.layerManager.managedLayers.length === 0 && this.resetStateWhenEmpty && (this.navigationState.reset(), this.perspectiveNavigationState.pose.orientation.reset(), this.perspectiveNavigationState.zoomFactor.reset(), this.resetInitiated.dispatch(), !vv && this.showLayerDialog && this.visibility.visible && TP(this.layerSpecification, this.selectedLayer));
    }));
    this.layerManager.layersChanged.add(T), T(), this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(() => {
      this.layerSelectedValues.handleLayerChange();
    })), this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(() => {
      this.visible && e.scheduleRedraw();
    })), this.makeUI(), this.updateShowBorders(), this.registerActionListeners(), this.registerEventActionBindings(), this.registerDisposer(rP(h, this.navigationState.position)), this.state = new q4(this);
  }
  get chunkManager() {
    return this.dataContext.chunkManager;
  }
  get chunkQueueManager() {
    return this.dataContext.chunkQueueManager;
  }
  get expectingExternalUI() {
    return vs.expectingExternalUI;
  }
  set expectingExternalUI(e) {
    vs.expectingExternalUI = e;
  }
  makeUiControlVisibilityState(e) {
    const t = this.uiConfiguration.showUIControls, n = this.uiConfiguration[e];
    return this.registerDisposer(dC((r, s) => r && s, t, n));
  }
  get inputEventMap() {
    return this.inputEventBindings.global;
  }
  updateShowBorders() {
    const e = this.element, t = "neuroglancer-show-panel-borders";
    this.uiConfiguration.showPanelBorders.value ? e.classList.add(t) : e.classList.remove(t);
  }
  makeUI() {
    const e = this.element;
    e.classList.add("neuroglancer-viewer"), e.classList.add("neuroglancer-noselect"), e.style.display = "flex", e.style.flexDirection = "column";
    const t = document.createElement("div");
    t.classList.add("neuroglancer-viewer-top-row"), t.style.display = "flex", t.style.flexDirection = "row", t.style.alignItems = "stretch";
    const n = this.registerDisposer(new $h(this.navigationState.position, this.layerSpecification.coordinateSpaceCombiner));
    this.registerDisposer(new fi(this.uiControlVisibility.showLocation, n.element)), t.appendChild(n.element);
    const r = this.registerDisposer(new jG(document.createElement("div"), this.mouseState, this.navigationState.coordinateSpace));
    if (r.element.style.flex = "1", r.element.style.alignSelf = "center", this.registerDisposer(new fi(this.uiControlVisibility.showLocation, r.element)), t.appendChild(r.element), typeof NEUROGLANCER_CREDIT_LINK < "u") {
      let l = NEUROGLANCER_CREDIT_LINK;
      Array.isArray(l) || (l = [l]);
      for (const d of l) {
        const u = d.url, h = d.text, g = document.createElement("a");
        g.style.marginRight = "5px", g.href = u, g.textContent = h, g.style.fontFamily = "sans-serif", g.style.color = "yellow", g.target = "_blank", t.appendChild(g);
      }
    }
    const s = this.registerDisposer(new F4(this.selectedLayer, this.toolBinder));
    if (t.appendChild(s.element), this.registerDisposer(new fi(this.uiControlVisibility.showAnnotationToolStatus, s.element)), wG) {
      const l = this.registerDisposer(new CG(this));
      t.appendChild(l.element);
    }
    {
      const l = this.layerListPanelState, d = this.registerDisposer(new Qi(l.location.watchableVisible, {
        svg: a$,
        backgroundScheme: "dark",
        enableTitle: "Show layer list panel",
        disableTitle: "Hide layer list panel"
      }));
      d.element.insertAdjacentElement("afterbegin", this.registerDisposer(new g4(this.layerManager)).element), this.registerDisposer(new fi(this.uiControlVisibility.showLayerListPanelButton, d.element)), t.appendChild(d.element);
    }
    {
      const l = this.selectionDetailsState, d = this.registerDisposer(new Qi(l.location.watchableVisible, {
        svg: o$,
        backgroundScheme: "dark",
        enableTitle: "Show selection details panel",
        disableTitle: "Hide selection details panel"
      }));
      this.registerDisposer(new fi(this.uiControlVisibility.showSelectionPanelButton, d.element)), t.appendChild(d.element);
    }
    {
      const l = this.selectedLayer, d = this.registerDisposer(new Qi({
        get value() {
          return l.visible;
        },
        set value(u) {
          l.visible = u;
        },
        changed: l.location.locationChanged
      }, {
        svg: _I,
        backgroundScheme: "dark",
        enableTitle: "Show layer side panel",
        disableTitle: "Hide layer side panel"
      }));
      this.registerDisposer(new fi(this.uiControlVisibility.showLayerSidePanelButton, d.element)), t.appendChild(d.element);
    }
    {
      const l = Tt({ text: "{}", title: "Edit JSON state" });
      this.registerEventListener(l, "click", () => {
        this.editJsonState();
      }), this.registerDisposer(new fi(this.uiControlVisibility.showEditStateButton, l)), t.appendChild(l);
    }
    {
      const l = or({
        title: "Copy view URL to clipboard",
        onClick: () => {
          const d = oi(this.makeUrlFromState(this.state.toJSON()));
          rt.showTemporaryMessage(d ? "URL copied to clipboard" : "Failed to copy URL to clipboard");
        }
      });
      t.appendChild(l);
    }
    {
      const l = this.helpPanelState, d = this.registerDisposer(new Qi(l.location.watchableVisible, {
        text: "?",
        backgroundScheme: "dark",
        enableTitle: "Show help panel",
        disableTitle: "Hide help panel"
      }));
      this.registerDisposer(new fi(this.uiControlVisibility.showHelpButton, d.element)), t.appendChild(d.element);
    }
    {
      const l = this.settingsPanelState, d = this.registerDisposer(new Qi(l.location.watchableVisible, {
        svg: l$,
        backgroundScheme: "dark",
        enableTitle: "Show settings panel",
        disableTitle: "Hide settings panel"
      }));
      this.registerDisposer(new fi(this.uiControlVisibility.showSettingsButton, d.element)), t.appendChild(d.element);
    }
    this.registerDisposer(new fi(dC((...l) => l.reduce((d, u) => d || u, false), ...uP.map((l) => this.uiControlVisibility[l])), t)), e.appendChild(t), this.layout = this.registerDisposer(new t4(this, "4panel")), this.sidePanelManager = this.registerDisposer(new zU(this.display, this.layout.element, this.visibility)), this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.layerListPanelState.location,
      makePanel: () => new p4(this.sidePanelManager, this.layerSpecification, this.layerListPanelState)
    })), this.registerDisposer(new l4(this.sidePanelManager, this.selectedLayer.addRef())), this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.selectionDetailsState.location,
      makePanel: () => new _1(this.sidePanelManager, this.selectionDetailsState, this.layerSpecification, this.selectedLayer)
    })), e.appendChild(this.sidePanelManager.element), this.closeSelectionTab = () => {
      for (const l of this.sidePanelManager.registeredPanels)
        l.panel instanceof _1 && l.panel.close();
    }, this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.statisticsDisplayState.location,
      makePanel: () => new M4(this.sidePanelManager, this.chunkQueueManager, this.statisticsDisplayState)
    })), this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.helpPanelState.location,
      makePanel: () => {
        const l = this.inputEventBindings;
        return new LG(this.sidePanelManager, this.helpPanelState, [["Global", l.global], ["Cross section view", l.sliceView], ["3-D projection view", l.perspectiveView]], this.layerManager, this.toolBinder);
      }
    })), this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.settingsPanelState.location,
      makePanel: () => new B4(this.sidePanelManager, this.settingsPanelState, this)
    }));
    const a = () => {
      const l = this.visibility.visible;
      l !== this.visible && (e.style.visibility = l ? "inherit" : "hidden", this.visible = l);
    };
    a(), this.registerDisposer(this.visibility.changed.add(a));
  }
  /**
   * Called once by the constructor to set up event handlers.
   */
  registerEventActionBindings() {
    const e = this.element;
    this.registerDisposer(new Gi(e, this.inputEventMap)), this.registerDisposer(new Vh(e));
  }
  bindAction(e, t) {
    this.registerDisposer(Ce(this.element, e, t));
  }
  bindCallback(e, t) {
    const n = () => {
      t(this);
    };
    this.registerDisposer(Ce(this.element, e, n));
  }
  /**
   * Called once by the constructor to register the action listeners.
   */
  registerActionListeners() {
    for (const e of ["recolor", "clear-segments"])
      this.bindAction(e, () => {
        this.layerManager.invokeAction(e), this.closeSelectionTab && this.closeSelectionTab();
      });
    for (const e of ["select"])
      this.bindAction(e, () => {
        this.mouseState.updateUnconditionally(), this.layerManager.invokeAction(e);
      });
    for (const e of ["copy-segment-id", "add-copy-segment-id"])
      this.bindAction(e, () => {
        this.mouseState.updateUnconditionally(), this.layerManager.invokeAction(e, this.selectedLayer.layer);
      });
    this.bindAction("help", () => this.toggleHelpPanel());
    for (let e = 1; e <= 9; ++e)
      this.bindAction(`toggle-layer-${e}`, () => {
        const t = this.layerManager.getLayerByNonArchivedIndex(e - 1);
        t !== void 0 && t.setVisible(!t.visible);
      }), this.bindAction(`toggle-pick-layer-${e}`, () => {
        const t = this.layerManager.getLayerByNonArchivedIndex(e - 1);
        t !== void 0 && (t.pickEnabled = !t.pickEnabled);
      }), this.bindAction(`select-layer-${e}`, () => {
        const t = this.layerManager.getLayerByNonArchivedIndex(e - 1);
        t !== void 0 && (this.selectedLayer.layer = t, this.selectedLayer.visible = true);
      });
    for (let e = 0; e < 26; ++e) {
      const t = String.fromCharCode(65 + e);
      this.bindAction(`tool-${t}`, () => {
        this.activateTool(t);
      });
    }
    this.bindAction("annotate", () => {
      const e = this.selectedLayer.layer;
      if (e === void 0) {
        rt.showTemporaryMessage("The annotate command requires a layer to be selected.");
        return;
      }
      const t = e.layer;
      if (t === null || t.tool.value === void 0) {
        rt.showTemporaryMessage(`The selected layer (${oe(e.name)}) does not have an active annotation tool.`);
        return;
      }
      t.tool.value.trigger(this.mouseState);
    }), this.bindAction("toggle-axis-lines", () => this.showAxisLines.toggle()), this.bindAction("toggle-scale-bar", () => this.showScaleBar.toggle()), this.bindAction("toggle-default-annotations", () => this.showDefaultAnnotations.toggle()), this.bindAction("toggle-show-slices", () => this.showPerspectiveSliceViews.toggle()), this.bindAction("toggle-show-statistics", () => this.showStatistics());
  }
  toggleHelpPanel() {
    this.helpPanelState.location.visible = !this.helpPanelState.location.visible;
  }
  activateTool(e) {
    this.toolBinder.activate(e);
  }
  editJsonState() {
    new C4(this);
  }
  copyJsonStateToUrl() {
    oi(this.makeUrlFromState(this.state.toJSON()));
  }
  showStatistics(e = void 0) {
    e === void 0 && (e = !this.statisticsDisplayState.location.visible), this.statisticsDisplayState.location.visible = e;
  }
  get gl() {
    return this.display.gl;
  }
  onUpdateDisplay() {
    this.visible && (this.dataContext.chunkQueueManager.chunkUpdateDeadline = null);
  }
  handleNavigationStateChanged() {
    if (this.visible) {
      let e = this.dataContext.chunkQueueManager;
      e.chunkUpdateDeadline === null && (e.chunkUpdateDeadline = Date.now() + 10);
    }
  }
};
var NE = "tool";
var OE = "toolBindings";
var nm = "localPosition";
var VE = "localDimensions";
var BE = "source";
var J4 = "transform";
var FE = "pick";
var K4 = class {
  constructor() {
    this.callbacks = [];
  }
  defer(e) {
    this.callbacks.push(e);
  }
};
var Xo = class extends X {
  constructor(e) {
    super(), this.managedLayer = e, this.pick = new nn(true, true), this.layersChanged = new Le(), this.readyStateChanged = new Le(), this.specificationChanged = new Le(), this.renderLayers = new Array(), this.loadingCounter = 1, this.tabs = this.registerDisposer(new zz()), this.panels = new Yz(this), this.tool = this.registerDisposer(new e$(this)), this.toolBinder = new n$(this), this.dataSourcesChanged = new Le(), this.dataSources = [], this.allowingRefresh = false, this.localCoordinateSpaceCombiner.includeDimensionPredicate = pL, this.tabs.changed.add(this.specificationChanged.dispatch), this.panels.specificationChanged.add(this.specificationChanged.dispatch), this.tool.changed.add(this.specificationChanged.dispatch), this.toolBinder.changed.add(this.specificationChanged.dispatch), this.localPosition.changed.add(this.specificationChanged.dispatch), this.pick.changed.add(this.specificationChanged.dispatch), this.pick.changed.add(this.layersChanged.dispatch), this.dataSourcesChanged.add(this.specificationChanged.dispatch), this.dataSourcesChanged.add(() => this.updateDataSubsourceActivations()), this.tabs.add("source", {
      label: "Source",
      order: -100,
      getter: () => new Jz(this)
    });
  }
  get localPosition() {
    return this.managedLayer.localPosition;
  }
  get localCoordinateSpaceCombiner() {
    return this.managedLayer.localCoordinateSpaceCombiner;
  }
  get localCoordinateSpace() {
    return this.managedLayer.localCoordinateSpace;
  }
  get type() {
    return this.constructor.type;
  }
  initializeSelectionState(e) {
    e.generation = -1, e.localPositionValid = false, e.localPosition = go, e.localCoordinateSpace = void 0, e.annotationId = void 0, e.annotationType = void 0, e.annotationBuffer = void 0, e.annotationIndex = void 0, e.annotationCount = void 0, e.annotationSourceIndex = void 0, e.annotationSubsource = void 0, e.annotationPartIndex = void 0, e.value = void 0;
  }
  resetSelectionState(e) {
    e.localPositionValid = false, e.annotationId = void 0, e.value = void 0;
  }
  selectionStateFromJson(e, t) {
    const r = (e.localCoordinateSpace = this.localCoordinateSpace.value).rank;
    if (r !== 0) {
      const a = xe(t, nm, (l) => lt(new Float32Array(r), l, Dt));
      a === void 0 ? e.localPositionValid = false : (e.localPositionValid = true, e.localPosition = a);
    }
    (e.annotationId = xe(t, "annotationId", Ae)) !== void 0 && (e.annotationSourceIndex = xe(t, "annotationSource", gn, 0), e.annotationPartIndex = xe(t, "annotationPart", gn), e.annotationSubsource = xe(t, "annotationSubsource", Ae)), e.value = t.value;
  }
  // Derived classes should override.
  displaySelectionState(e, t, n) {
    return false;
  }
  selectionStateToJson(e, t) {
    const n = {};
    if (e.localPositionValid) {
      const r = e.localPosition;
      r.length > 0 && (n.localPosition = _e(r));
    }
    return e.annotationId !== void 0 && (n.annotationId = e.annotationId, n.annotationPart = e.annotationPartIndex, n.annotationSource = e.annotationSourceIndex, n.annotationSubsource = e.annotationSubsource), e.value != null && (n.value = e.value), n;
  }
  captureSelectionState(e, t) {
    e.localCoordinateSpace = this.localCoordinateSpace.value;
    const n = this.localPosition.value;
    let r = e.localPosition;
    r.length !== n.length ? e.localPosition = n.slice() : r.set(n), e.localPositionValid = true, e.value = this.getValueAt(t.position, t);
  }
  copySelectionState(e, t) {
    e.generation = t.generation, e.localPositionValid = t.localPositionValid, e.localCoordinateSpace = t.localCoordinateSpace;
    const n = t.localPosition;
    e.localPosition.length !== n.length ? e.localPosition = n.slice() : e.localPosition.set(n), e.annotationId = t.annotationId, e.annotationType = t.annotationType, e.annotationBuffer = t.annotationBuffer, e.annotationIndex = t.annotationIndex, e.annotationCount = t.annotationCount, e.annotationSourceIndex = t.annotationSourceIndex, e.annotationSubsource = t.annotationSubsource, e.annotationPartIndex = t.annotationPartIndex, e.value = t.value;
  }
  get isReady() {
    return this.loadingCounter === 0;
  }
  get manager() {
    return this.managedLayer.manager;
  }
  canAddDataSource() {
    return true;
  }
  addDataSource(e) {
    const t = new x3(this, e);
    return this.dataSources.push(t), this.dataSourcesChanged.dispatch(), t;
  }
  // Should be overridden by derived classes.
  activateDataSubsources(e) {
  }
  updateDataSubsourceActivations() {
    function* e() {
      for (const t of this.dataSources) {
        const n = t.loadState;
        if (!(n === void 0 || n.error !== void 0))
          for (const r of n.subsources)
            if (r.enabled)
              yield r;
            else {
              const s = r.activated;
              r.messages.clearMessages(), s !== void 0 && (s.dispose(), r.activated = void 0, n.activatedSubsourcesChanged.dispatch());
            }
      }
    }
    this.activateDataSubsources(e.call(this));
  }
  decrementLoadingCounter() {
    --this.loadingCounter === 0 && this.readyStateChanged.dispatch();
  }
  markLoading() {
    const e = this.localCoordinateSpaceCombiner.retain(), t = this.manager.root.coordinateSpaceCombiner.retain();
    return ++this.loadingCounter === 1 && this.readyStateChanged.dispatch(), () => {
      e(), t(), this.decrementLoadingCounter();
    };
  }
  addCoordinateSpace(e) {
    const t = this.manager.root.coordinateSpaceCombiner.bind(e), n = this.localCoordinateSpaceCombiner.bind(e);
    return () => {
      t(), n();
    };
  }
  initializationDone() {
    const e = this.selectionState = {};
    this.initializeSelectionState(e), this.decrementLoadingCounter();
  }
  getLegacyDataSourceSpecifications(e, t, n, r) {
    return e === void 0 ? [] : [Jl(e, n)];
  }
  getDataSourceSpecifications(e) {
    let t, n = Y(e, BE, (s) => Array.isArray(s) ? s.map((a) => Jl(a)) : typeof s == "object" ? [Jl(s)] : (t = s, []));
    const r = Y(e, J4, hV);
    return n.push(...this.getLegacyDataSourceSpecifications(t, e, r, n)), n = n.filter((s) => s.url), n.length === 0 && n.push(_D()), n;
  }
  restoreState(e) {
    this.tool.restoreState(e[NE]), this.toolBinder.restoreState(e[OE]), this.panels.restoreState(e), this.localCoordinateSpace.restoreState(e[VE]), this.localPosition.restoreState(e[nm]), this.constructor.supportsPickOption && this.pick.restoreState(e[FE]);
    for (const t of this.getDataSourceSpecifications(e))
      this.addDataSource(t);
  }
  addRenderLayer(e) {
    this.renderLayers.push(e);
    const t = this.layersChanged;
    return e.layerChanged.add(t.dispatch), e.userLayer = this, t.dispatch(), () => this.removeRenderLayer(e);
  }
  removeRenderLayer(e) {
    const t = this.renderLayers, n = this.layersChanged, r = t.indexOf(e);
    if (r === -1)
      throw new Error("Attempted to remove invalid RenderLayer");
    t.splice(r, 1), e.layerChanged.remove(n.dispatch), e.userLayer = void 0, e.dispose(), n.dispatch();
  }
  disposed() {
    const e = this.layersChanged;
    ho(this.dataSources);
    for (const t of this.renderLayers)
      t.layerChanged.remove(e.dispatch), t.dispose();
    this.renderLayers.length = 0, super.disposed();
  }
  getValueAt(e, t) {
    let n, r = this.renderLayers, s = t.pickedRenderLayer;
    if (s !== null && r.indexOf(s) !== -1 && (n = s.transformPickedValue(t), n = this.transformPickedValue(n), n != null))
      return n;
    for (let a of r)
      if (n = a.getValueAt(e), n != null)
        break;
    return this.transformPickedValue(n);
  }
  transformPickedValue(e) {
    return e;
  }
  toJSON() {
    return H({ type: this.type, [BE]: Y4(this.dataSources), [NE]: this.tool.toJSON(), [OE]: this.toolBinder.toJSON(), [VE]: this.localCoordinateSpace.toJSON(), [nm]: this.localPosition.toJSON(), [FE]: this.pick.toJSON() }, this.panels.toJSON());
  }
  // Derived classes should override.
  handleAction(e, t) {
  }
  selectedValueToJson(e) {
    return e;
  }
  selectedValueFromJson(e) {
    return e;
  }
  setLayerPosition(e, t) {
    const n = this.manager.root.globalPosition, r = this.localPosition;
    e ? (iC(n.value, t, e.globalToRenderLayerDimensions), iC(r.value, t, e.localToRenderLayerDimensions)) : n.value.set(t), r.changed.dispatch(), n.changed.dispatch();
  }
};
Xo.supportsPickOption = false;
function Y4(i) {
  if (i.length !== 0)
    return i.length === 1 ? i[0].toJSON() : i.map((e) => e.toJSON());
}
var kS = class extends X {
  /**
   * If layer is not null, tranfers ownership of a reference.
   */
  constructor(e, t) {
    super(), this.manager = t, this.localCoordinateSpace = new Ey(), this.localCoordinateSpaceCombiner = new Dy(this.localCoordinateSpace, ql), this.localPosition = this.registerDisposer(new Js(this.localCoordinateSpace)), this.nonArchivedLayerIndex = -1, this.readyStateChanged = new Le(), this.layerChanged = new Le(), this.specificationChanged = new Le(), this.containers = new Ye(), this.layer_ = null, this.visible = true, this.archived = false, this.name_ = e;
  }
  get layer() {
    return this.layer_;
  }
  /**
   * If layer is not null, tranfers ownership of a reference.
   */
  set layer(e) {
    let t = this.layer_;
    if (t != null && (this.unregisterUserLayer(), t.dispose()), this.layer_ = e, e != null) {
      const n = [e.layersChanged.add(this.layerChanged.dispatch), e.readyStateChanged.add(this.readyStateChanged.dispatch), e.specificationChanged.add(this.specificationChanged.dispatch)];
      this.unregisterUserLayer = () => {
        n.forEach((r) => r());
      }, this.readyStateChanged.dispatch(), this.layerChanged.dispatch();
    }
  }
  isReady() {
    const e = this.layer;
    return e !== null && e.isReady;
  }
  get name() {
    return this.name_;
  }
  set name(e) {
    e !== this.name_ && (this.name_ = e, this.layerChanged.dispatch());
  }
  get supportsPickOption() {
    const e = this.layer;
    return e !== null && e.constructor.supportsPickOption;
  }
  get pickEnabled() {
    const e = this.layer;
    return e !== null && e.constructor.supportsPickOption && e.pick.value;
  }
  set pickEnabled(e) {
    const t = this.layer;
    t !== null && t.constructor.supportsPickOption && (t.pick.value = e);
  }
  toJSON() {
    let e = this.layer;
    if (e === null)
      return;
    let t = e.toJSON();
    return t.name = this.name, this.visible || (this.archived ? t.archived = true : t.visible = false), t;
  }
  setVisible(e) {
    if (e !== this.visible) {
      if (e && this.archived) {
        this.visible = true, this.setArchived(false);
        return;
      }
      this.visible = e, this.layerChanged.dispatch();
    }
  }
  setArchived(e) {
    if (this.archived !== e) {
      if (e === true) {
        this.visible = false, this.archived = true;
        for (const t of this.manager.root.subsets) {
          const n = t.layerManager;
          n.has(this) && n.removeManagedLayer(this);
        }
      } else {
        for (const t of this.manager.root.subsets) {
          const n = t.layerManager;
          n.has(this) || n.addManagedLayer(this.addRef());
        }
        this.archived = false;
      }
      this.layerChanged.dispatch();
    }
  }
  disposed() {
    this.layer = null, super.disposed();
  }
};
var pP = class extends X {
  constructor() {
    super(), this.managedLayers = new Array(), this.layerSet = new Ye(), this.layersChanged = new Le(), this.readyStateChanged = new Le(), this.specificationChanged = new Le(), this.boundPositions = new v3(), this.numDirectUsers = 0, this.nonArchivedLayerIndexGeneration = -1, this.renderLayerToManagedLayerMapGeneration = -1, this.renderLayerToManagedLayerMap_ = new he(), this.scheduleRemoveLayersWithSingleRef = this.registerCancellable(dt(() => this.removeLayersWithSingleRef(), 0)), this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef);
  }
  updateNonArchivedLayerIndices() {
    const e = this.layersChanged.count;
    if (e === this.nonArchivedLayerIndexGeneration) return;
    this.nonArchivedLayerIndexGeneration = e;
    let t = 0;
    for (const n of this.managedLayers)
      n.archived || (n.nonArchivedLayerIndex = t++);
    for (const n of this.managedLayers)
      n.archived && (n.nonArchivedLayerIndex = t++);
  }
  getLayerByNonArchivedIndex(e) {
    let t = 0;
    for (const n of this.managedLayers)
      if (!n.archived) {
        if (t === e) return n;
        ++t;
      }
  }
  get renderLayerToManagedLayerMap() {
    const e = this.layersChanged.count, t = this.renderLayerToManagedLayerMap_;
    if (this.renderLayerToManagedLayerMapGeneration !== e) {
      this.renderLayerToManagedLayerMapGeneration = e, t.clear();
      for (const n of this.managedLayers) {
        const r = n.layer;
        if (r !== null)
          for (const s of r.renderLayers)
            t.set(s, n);
      }
    }
    return t;
  }
  filter(e) {
    let t = false;
    this.managedLayers = this.managedLayers.filter((n) => e(n) ? true : (this.unbindManagedLayer(n), this.layerSet.delete(n), t = true, false)), t && this.layersChanged.dispatch();
  }
  removeLayersWithSingleRef() {
    this.numDirectUsers > 0 || this.filter((e) => e.refCount !== 1 || e.archived);
  }
  updateSignalBindings(e, t) {
    t(e.layerChanged, this.layersChanged.dispatch), t(e.readyStateChanged, this.readyStateChanged.dispatch), t(e.specificationChanged, this.specificationChanged.dispatch);
  }
  useDirectly() {
    return ++this.numDirectUsers === 1 && this.layersChanged.remove(this.scheduleRemoveLayersWithSingleRef), () => {
      --this.numDirectUsers === 0 && (this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef), this.scheduleRemoveLayersWithSingleRef());
    };
  }
  /**
   * Assumes ownership of an existing reference to managedLayer.
   */
  addManagedLayer(e, t) {
    return this.updateSignalBindings(e, s$), this.layerSet.add(e), e.containers.add(this), t === void 0 && (t = this.managedLayers.length), this.managedLayers.splice(t, 0, e), this.layersChanged.dispatch(), this.readyStateChanged.dispatch(), e;
  }
  *readyRenderLayers() {
    for (let e of this.managedLayers)
      !e.visible || !e.layer || (yield* e.layer.renderLayers);
  }
  unbindManagedLayer(e) {
    this.updateSignalBindings(e, r$), e.containers.delete(this), e.manager.rootLayers.layersChanged.dispatch(), e.dispose();
  }
  clear() {
    for (let e of this.managedLayers)
      this.unbindManagedLayer(e);
    this.managedLayers.length = 0, this.layerSet.clear(), this.layersChanged.dispatch();
  }
  remove(e) {
    const t = this.managedLayers[e];
    this.unbindManagedLayer(t), this.managedLayers.splice(e, 1), this.layerSet.delete(t), this.layersChanged.dispatch();
  }
  removeManagedLayer(e) {
    let t = this.managedLayers.indexOf(e);
    if (t === -1)
      throw new Error("Internal error: invalid managed layer.");
    this.remove(t);
  }
  reorderManagedLayer(e, t) {
    const n = this.managedLayers.length;
    if (e === t || e < 0 || e >= n || t < 0 || t >= n)
      return;
    var r = this.managedLayers.splice(e, 1), s = de(r, 1);
    let a = s[0];
    this.managedLayers.splice(t, 0, a), this.layersChanged.dispatch();
  }
  disposed() {
    this.clear(), super.disposed();
  }
  getLayerByName(e) {
    return this.managedLayers.find((t) => t.name === e);
  }
  getUniqueLayerName(e) {
    let t = e, n = 0;
    for (; this.getLayerByName(t) !== void 0; )
      t = e + ++n;
    return t;
  }
  has(e) {
    return this.layerSet.has(e);
  }
  get renderLayers() {
    let e = this;
    return {
      *[qn]() {
        for (let t of e.managedLayers)
          if (t.layer !== null)
            for (let n of t.layer.renderLayers)
              yield n;
      }
    };
  }
  get visibleRenderLayers() {
    let e = this;
    return {
      *[qn]() {
        for (let t of e.managedLayers)
          if (!(t.layer === null || !t.visible))
            for (let n of t.layer.renderLayers)
              yield n;
      }
    };
  }
  invokeAction(e, t) {
    const n = new K4();
    for (let r of this.managedLayers) {
      if (r.layer === null || !r.visible || t !== void 0 && r !== t)
        continue;
      let s = r.layer;
      s.handleAction(e, n);
      for (let a of s.renderLayers)
        a.handleAction(e);
    }
    for (const r of n.callbacks)
      r();
  }
};
var X4 = class {
  constructor() {
    this.changed = new Le(), this.coordinateSpace = Vr, this.position = go, this.unsnappedPosition = go, this.active = false, this.displayDimensions = void 0, this.pickedRenderLayer = null, this.pickedValue = new re(0, 0), this.pickedOffset = 0, this.pickedAnnotationLayer = void 0, this.pickedAnnotationId = void 0, this.pickedAnnotationBuffer = void 0, this.pickedAnnotationBufferBaseOffset = void 0, this.pickedAnnotationIndex = void 0, this.pickedAnnotationCount = void 0, this.pickedAnnotationType = void 0, this.forcerFunction = void 0;
  }
  removeForcer(e) {
    e === this.forcerFunction && (this.forcerFunction = void 0, this.setActive(false));
  }
  setForcer(e) {
    this.forcerFunction = e, e === void 0 && this.setActive(false);
  }
  updateUnconditionally() {
    const e = this.forcerFunction;
    return e === void 0 ? false : (e(), this.active);
  }
  setActive(e) {
    (this.active !== e || e === true) && (this.active = e, this.changed.dispatch());
  }
};
var Z4 = class extends X {
  constructor(e, t) {
    super(), this.layerManager = e, this.mouseState = t, this.changed = new Le(), this.needsUpdate = true, this.registerDisposer(t.changed.add(() => {
      this.handleChange();
    })), this.registerDisposer(e.layersChanged.add(() => {
      this.handleLayerChange();
    }));
  }
  /**
   * This should be called when the layer data may have changed, due to the set of managed layers
   * changing or new data having been received.
   */
  handleLayerChange() {
    this.mouseState.active && this.handleChange();
  }
  handleChange() {
    this.needsUpdate = true, this.changed.dispatch();
  }
  update() {
    if (!this.needsUpdate)
      return;
    this.needsUpdate = false;
    let e = this.mouseState;
    const t = this.changed.count;
    if (e.active)
      for (const n of this.layerManager.managedLayers) {
        const r = n.layer;
        if (n.visible && r !== null) {
          const s = r.selectionState;
          s && (r.resetSelectionState(s), s.generation = t, r.captureSelectionState(s, e));
        }
      }
  }
  get(e) {
    this.update();
    const t = e.selectionState;
    if (!(t && t.generation !== this.changed.count))
      return t;
  }
  toJSON() {
    this.update();
    const e = {};
    for (const t of this.layerManager.managedLayers) {
      const n = t.layer;
      if (n) {
        const r = this.get(n);
        r !== void 0 && (e[t.name] = n.selectionStateToJson(r, true));
      }
    }
    return e;
  }
};
var UE = 10;
var yv = H(H({}, ga), { minSize: 150, row: 1 });
var zE = H(H({}, yv), { visible: true });
var Q4 = class extends X {
  constructor(e, t) {
    super(), this.coordinateSpace = e, this.layerSelectedValues = t, this.changed = new Le(), this.history = [], this.historyIndex = 0, this.location = new Is(yv), this.pin = new vt(true), this.registerDisposer(Or((n, r) => {
      r || (this.capture(true), n.registerDisposer(t.changed.add(n.registerCancellable(wh(() => this.capture(true), 100, { leading: true, trailing: true })))));
    }, this.pin)), this.pin.changed.add(this.changed.dispatch), this.location.changed.add(this.changed.dispatch);
  }
  get value() {
    return this.value_;
  }
  goBack() {
    const e = this.pin.value ? this.historyIndex : this.history.length;
    e > 0 && (this.historyIndex = e - 1, this.value_ = this.history[e - 1], this.pin.value = true, this.changed.dispatch());
  }
  canGoBack() {
    return (this.pin.value ? this.historyIndex : this.history.length) > 0;
  }
  canGoForward() {
    return this.pin.value ? this.historyIndex + 1 < this.history.length : false;
  }
  goForward() {
    if (!this.pin.value) return;
    const e = this.historyIndex;
    e + 1 < this.history.length && (this.historyIndex = e + 1, this.value_ = this.history[e + 1], this.changed.dispatch());
  }
  set value(e) {
    if (e !== this.value_) {
      if (this.value_ = e, e !== void 0 && this.pin.value) {
        const t = this.history;
        t.length = Math.min(t.length, this.historyIndex + 1), t.push(e), t.length > UE && t.splice(0, t.length - UE), this.historyIndex = t.length - 1;
      }
      this.changed.dispatch();
    }
  }
  captureSingleLayerState(e, t, n = true, r = true) {
    if (n === false && (!this.location.visible || this.pin.value)) return;
    const s = {};
    e.initializeSelectionState(s), t(s) && (r && (this.location.visible = true), n === true ? this.pin.value = true : n === "toggle" && (this.pin.value = !this.pin.value), this.value = {
      layers: [{ layer: e, state: s }],
      coordinateSpace: this.coordinateSpace.value,
      position: void 0
    });
  }
  reset() {
    this.location.reset(), this.pin.value = false, this.value = void 0;
  }
  toJSON() {
    const e = this.value;
    let t;
    if (this.location.visible) {
      if (t = this.location.toJSON(H(H({}, zE), { visible: !vs.expectingExternalUI })), this.pin.value && e !== void 0) {
        const n = {};
        for (const r of e.layers) {
          let a = r.layer.selectionStateToJson(r.state, false);
          hn(a).length === 0 && (a = void 0), n[r.layer.managedLayer.name] = a;
        }
        e.position !== void 0 && (t.position = _e(e.position)), t.layers = n;
      }
    } else
      t = this.location.toJSON(yv), t = ha(t), t !== void 0 && (t.visible = false);
    return t;
  }
  select(e = true) {
    const t = this.pin;
    e && (this.location.visible = true), t.value = !t.value, t.value && this.capture();
  }
  capture(e = false) {
    const t = eW(this.layerSelectedValues);
    e && t === void 0 || (this.value = t);
  }
  restoreState(e) {
    if (e === void 0) {
      this.pin.value = true, this.value = void 0;
      return;
    }
    if (e === null) {
      this.pin.value = false, this.location.visible = true, this.value = void 0;
      return;
    }
    me(e), this.location.restoreState(e, H(H({}, zE), { visible: !vs.expectingExternalUI }));
    const t = this.coordinateSpace.value, n = t.rank > 0 ? xe(e, "position", (s) => lt(new Float32Array(t.rank), s, Dt)) : void 0, r = [];
    xe(e, "layers", (s) => {
      me(s);
      const a = this.layerSelectedValues.layerManager;
      for (const d of _c(s)) {
        var l = de(d, 2);
        const u = l[0], h = l[1], g = a.getLayerByName(u);
        if (g === void 0) return;
        const v = g.layer;
        if (v === null) return;
        me(h);
        const y = {};
        v.initializeSelectionState(y), v.selectionStateFromJson(y, h), r.push({ layer: v, state: y });
      }
    }), this.pin.value = r.length > 0 || n !== void 0, this.value = { position: n, coordinateSpace: t, layers: r };
  }
};
function eW(i) {
  const e = i.mouseState;
  if (!e.active) return;
  const t = [];
  for (const n of i.layerManager.managedLayers) {
    const r = n.layer;
    if (r === null) continue;
    const s = i.get(r);
    if (s === void 0) continue;
    const a = {};
    r.initializeSelectionState(a), r.copySelectionState(a, s), t.push({
      layer: r,
      state: a
    });
  }
  return {
    position: e.position.slice(),
    coordinateSpace: e.coordinateSpace,
    layers: t
  };
}
var tW = class extends X {
  constructor(e) {
    super(), this.view = e, this.messages = new Uo(), this.seenGeneration = -1, this.state = void 0;
  }
};
var nW = 0;
var iW = class extends X {
  constructor(e, t, n, r, s, a) {
    super(), this.layerManager = e, this.renderLayerType = t, this.view = n, this.roles = r, this.layerAdded = s, this.visibility = a, this.visibleLayers_ = new he(), this.debouncedUpdateVisibleLayers = this.registerCancellable(dt(() => this.updateVisibleLayers(), 0)), this.registerDisposer(e.layersChanged.add(this.debouncedUpdateVisibleLayers)), this.registerDisposer(r.changed.add(this.debouncedUpdateVisibleLayers)), this.updateVisibleLayers();
  }
  disposed() {
    this.visibleLayers.forEach((e) => e.dispose()), this.visibleLayers.clear(), super.disposed();
  }
  updateVisibleLayers() {
    const e = ++nW, t = this.visibleLayers_, n = this.renderLayerType, r = this.layerAdded, s = this.roles;
    for (let l of this.layerManager.readyRenderLayers())
      if (l instanceof n && s.has(l.role)) {
        let d = l, u = t.get(d);
        u === void 0 && (u = new tW(this.view), u.registerDisposer(d.messages.addChild(u.messages)), u.registerDisposer(d.addRef()), u.registerDisposer(d.visibility.add(this.visibility)), t.set(d, u), r(d, u), d.attach(u)), u.seenGeneration = e;
      }
    for (const l of t) {
      var a = de(l, 2);
      const d = a[0], u = a[1];
      u.seenGeneration !== e && (t.delete(d), u.dispose());
    }
  }
  get visibleLayers() {
    return this.debouncedUpdateVisibleLayers.flush(), this.visibleLayers_;
  }
};
function gP(i, e, t, n, r) {
  return n.registerDisposer(new iW(i, e, n, t, (s, a) => {
    a.registerDisposer(s.redrawNeeded.add(() => n.scheduleRedraw()));
    const l = s.backend;
    l && (l.rpc.invoke(VV, { layer: l.rpcId, view: n.rpcId }), a.registerDisposer(() => l.rpc.invoke(BV, { layer: l.rpcId, view: n.rpcId }))), n.scheduleRedraw(), a.registerDisposer(() => n.scheduleRedraw());
  }, n.visibility));
}
var rW = class extends X {
  constructor(e) {
    super(), this.layerManager = e, this.changed = new Le(), this.location = new Is(Kz), this.registerDisposer(e), this.location.changed.add(() => {
      var t, n;
      this.changed.dispatch();
      const r = (n = (t = this.layer) === null || t === void 0 ? void 0 : t.layer) !== null && n !== void 0 ? n : void 0;
      if (r !== void 0) {
        const s = this.location.value;
        if (s.visible) {
          const a = r.panels.panels[0];
          a.location.value !== s && (a.location.value = s, a.location.locationChanged.dispatch());
        }
      }
    });
  }
  get layer() {
    return this.layer_;
  }
  get visible() {
    return this.location.visible;
  }
  toggle(e) {
    this.layer === e && this.visible ? this.visible = false : (this.layer = e, this.visible = true);
  }
  set visible(e) {
    let t = this.layer_;
    if (e === true && t === void 0) {
      const n = this.layerManager.managedLayers;
      n.length > 0 ? t = this.layer = n[0] : e = false;
    }
    if (e === true && t !== void 0) {
      const n = t.layer;
      (n === null || n.panels.panels[0].tabs.length === 0) && (e = false);
    }
    this.visible !== e && (this.location.visible = e, !e && t !== void 0 && this.maybeDeleteNewLayer(t), this.changed.dispatch());
  }
  maybeDeleteNewLayer(e) {
    if (e.wasDisposed) return;
    const t = e.layer;
    t !== null && t instanceof zr && (t.dataSources.some((n) => n.spec.url.length !== 0) || Qo(e));
  }
  set layer(e) {
    if (e === this.layer_)
      return;
    const t = this.layer_;
    if (t !== void 0 && (this.existingLayerDisposer(), this.existingLayerDisposer = void 0, this.maybeDeleteNewLayer(t)), this.layer_ = e, e !== void 0) {
      const n = () => {
        this.layer_ = void 0, this.visible = false, this.existingLayerDisposer = void 0, this.changed.dispatch();
      };
      e.registerDisposer(n);
      const r = e.specificationChanged.add(() => {
        this.changed.dispatch();
      });
      this.existingLayerDisposer = () => {
        const s = e.layer;
        if (s !== null) {
          const a = s.tool.value;
          a !== void 0 && a.deactivate();
        }
        e.unregisterDisposer(n), r();
      };
    } else
      this.location.visible = false;
    this.changed.dispatch();
  }
  toJSON() {
    const e = this.location.toJSON();
    return this.layer !== void 0 && (e.layer = this.layer.name), ha(e);
  }
  restoreState(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    me(e), this.location.restoreState(e);
    const t = Y(e, "layer", Ci), n = t !== void 0 ? this.layerManager.getLayerByName(t) : void 0;
    n === void 0 && (this.visible = false), this.layer = n;
  }
  reset() {
    this.location.reset(), this.layer = void 0;
  }
};
var sW = class extends X {
  constructor(e, t) {
    super(), this.layerManager = e, this.filter = t, this.changed = new Le(), this.validate = dt(() => {
      const n = this.layerName_;
      if (n !== void 0) {
        const r = this.layerManager.getLayerByName(n);
        r !== void 0 && this.filter(r) ? (this.layer_ = r, this.changed.dispatch()) : (this.layer_ = void 0, this.layerName_ = void 0, this.changed.dispatch());
      }
    }, 0), this.registerDisposer(e), this.registerDisposer(e.specificationChanged.add(() => {
      const n = this.layer_;
      if (n !== void 0)
        if (!this.layerManager.layerSet.has(n) || !this.filter(n))
          this.layer_ = void 0, this.layerName_ = void 0, this.changed.dispatch();
        else {
          const r = n.name;
          r !== this.layerName_ && (this.layerName_ = r, this.changed.dispatch());
        }
    }));
  }
  get layer() {
    return this.layer_;
  }
  get layerName() {
    return this.layerName_;
  }
  set layer(e) {
    this.layer_ !== e && (e !== void 0 && this.layerManager.layerSet.has(e) && this.filter(e) ? (this.layer_ = e, this.layerName_ = e.name) : (this.layer_ = void 0, this.layerName_ = void 0), this.changed.dispatch());
  }
  set layerName(e) {
    e !== this.layerName_ && (this.layer_ = void 0, this.layerName_ = e, this.changed.dispatch(), this.validate());
  }
  restoreState(e) {
    const t = Ci(e);
    this.layerName = t;
  }
  toJSON() {
    const e = this.layer_;
    return e !== void 0 ? e.name : this.layerName_;
  }
  reset() {
    this.layerName_ = void 0, this.layer_ = void 0, this.changed.dispatch();
  }
};
var $E = class extends X {
  constructor(e, t, n, r) {
    super(), this.layerManager = e, this.layer = t, this.predicate = n, this.getGroup = r, this.linkedLayers_ = new Ye(), this.changed = new Le(), this.linkedLayersChanged = new Le(), this.root_ = t;
    const s = this;
    this.root = {
      get value() {
        return s.root_;
      },
      changed: s.changed
    };
  }
  get linkedLayers() {
    return this.linkedLayers_;
  }
  get rootGroup() {
    return this.getGroup(this.root.value);
  }
  reset() {
    this.isolate();
  }
  restoreState(e) {
    if (e === void 0) return;
    const t = Ae(e);
    this.linkByName(t);
  }
  toJSON() {
    const e = this.root.value;
    if (e !== this.layer)
      return e.managedLayer.name;
  }
  isolate(e = true) {
    const t = this.getGroup, n = this.layer, r = this.root_;
    if (r === n) {
      const a = this.linkedLayers_;
      if (a.size !== 0) {
        for (const l of a) {
          const d = t(l);
          d.root_ = l, d.changed.dispatch();
        }
        a.clear(), this.linkedLayersChanged.dispatch();
      }
      return;
    }
    const s = t(r);
    s.linkedLayers_.delete(n), s.linkedLayersChanged.dispatch(), this.root_ = n, e && this.changed.dispatch();
  }
  linkByName(e) {
    const n = this.layer.managedLayer, s = this.layerManager.getLayerByName(e);
    if (s === void 0 || s === n) return;
    const a = s.layer;
    a !== null && this.predicate(a) && this.linkToLayer(a);
  }
  linkToLayer(e) {
    if (e === this.layer || this.root_ === e) return;
    this.root_ !== this.layer && this.isolate(
      /*notifyChanged=*/
      false
    );
    const t = this.getGroup, n = t(e).root_;
    if (n === this.layer) return;
    const r = t(n);
    r.linkedLayers_.add(this.layer), r.linkedLayersChanged.dispatch(), this.root_ = n, this.changed.dispatch();
  }
  disposed() {
    this.isolate(
      /*notifyChanged=*/
      false
    );
  }
};
function mP(i, e) {
  const t = xe(e, "type", Ae, "auto");
  i.archived = xe(e, "archived", na, false), i.archived ? i.visible = false : i.visible = xe(e, "visible", na, true);
  const n = Nu.get(t) || zr;
  return i.layer = new n(i), e;
}
function vP(i, e) {
  try {
    const t = i.layer;
    if (t === null) return;
    t.restoreState(e), t.initializationDone();
  } catch (t) {
    throw Qo(i), t;
  }
}
function yP(i, e) {
  try {
    me(e), mP(i, e), vP(i, e);
  } catch (t) {
    throw Qo(i), t;
  }
}
function aW(i, e) {
  try {
    yP(i, e);
  } catch (t) {
    new rt().setErrorMessage(t instanceof Error ? t.message : "" + t);
  }
}
function SP(i, e, t) {
  const n = new kS(e, i);
  return yP(n, t), n;
}
var bP = class extends X {
  constructor() {
    super(...arguments), this.changed = new Le();
  }
};
var oW = class extends bP {
  constructor(e, t, n, r, s, a, l, d, u) {
    super(), this.display = e, this.dataSourceProviderRegistry = t, this.layerManager = n, this.chunkManager = r, this.selectionState = s, this.selectedLayer = a, this.coordinateSpace = l, this.globalPosition = d, this.toolBinder = u, this.coordinateSpaceCombiner = new Dy(this.coordinateSpace, oV), this.subsets = new Ye(), this.layerSelectedValues = this.selectionState.layerSelectedValues, this.registerDisposer(n.layersChanged.add(this.changed.dispatch)), this.registerDisposer(n.specificationChanged.add(this.changed.dispatch));
  }
  get rpc() {
    return this.chunkManager.rpc;
  }
  get root() {
    return this;
  }
  reset() {
    this.layerManager.clear();
  }
  restoreState(e) {
    this.layerManager.clear();
    let t;
    Array.isArray(e) ? t = e : (me(e), t = _c(e).map(([r, s]) => typeof s == "string" ? { name: r, source: s } : (me(s), H(H({}, s), { name: r }))));
    const n = [];
    for (const r of t) {
      me(r);
      const s = this.layerManager.getUniqueLayerName(Y(r, "name", Ae)), a = new kS(s, this);
      try {
        mP(a, r), this.layerManager.addManagedLayer(a), n.push({ managedLayer: a, spec: r });
      } catch (l) {
        a.dispose(), new rt().setErrorMessage(`Error creating layer ${oe(s)}: ` + (l instanceof Error) ? l.message : "" + l);
      }
    }
    for (const r of n) {
      const s = r.managedLayer, a = r.spec;
      try {
        vP(s, a);
      } catch (l) {
        new rt().setErrorMessage(`Error creating layer ${oe(name)}: ` + (l instanceof Error) ? l.message : "" + l);
      }
    }
  }
  add(e, t) {
    this.layerManager.managedLayers.indexOf(e) === -1 && (e.name = this.layerManager.getUniqueLayerName(e.name)), this.layerManager.addManagedLayer(e, t);
  }
  toJSON() {
    const e = [];
    let t = 0;
    for (let n of this.layerManager.managedLayers) {
      const r = n.toJSON();
      r != null && (e.push(r), ++t);
    }
    if (t !== 0)
      return e;
  }
  get rootLayers() {
    return this.layerManager;
  }
};
var wP = class extends bP {
  constructor(e) {
    super(), this.master = e, this.changed = new Le(), this.layerManager = this.registerDisposer(new pP()), this.registerDisposer(e);
    const t = this.layerManager;
    this.registerDisposer(t.layersChanged.add(this.changed.dispatch)), this.registerDisposer(t.specificationChanged.add(this.changed.dispatch)), e.subsets.add(this);
  }
  get rpc() {
    return this.master.rpc;
  }
  get dataSourceProviderRegistry() {
    return this.master.dataSourceProviderRegistry;
  }
  get chunkManager() {
    return this.master.chunkManager;
  }
  get layerSelectedValues() {
    return this.master.layerSelectedValues;
  }
  get root() {
    return this.master;
  }
  disposed() {
    super.disposed(), this.master.subsets.delete(this);
  }
  reset() {
    this.layerManager.clear();
  }
  restoreState(e) {
    const t = this.master.layerManager, n = [];
    for (const r of new Ye(Xe(e, Ae))) {
      const s = t.getLayerByName(r);
      if (s === void 0)
        throw new Error(`Undefined layer referenced in subset specification: ${oe(r)}`);
      s.archived || n.push(s);
    }
    this.layerManager.clear();
    for (const r of n)
      this.layerManager.addManagedLayer(r.addRef());
  }
  toJSON() {
    return this.layerManager.managedLayers.map((e) => e.name);
  }
  add(e, t) {
    this.master.layerManager.managedLayers.indexOf(e) === -1 && (e.name = this.master.layerManager.getUniqueLayerName(e.name), this.master.layerManager.addManagedLayer(e.addRef())), this.layerManager.addManagedLayer(e, t);
  }
  get rootLayers() {
    return this.master.rootLayers;
  }
};
var Nu = new he();
var TS2 = new he();
var CP = [(i) => {
  const e = i.volume;
  if (e === void 0) return;
  const t = TS2.get(e.volumeType);
  if (t !== void 0)
    return { layerConstructor: t, priority: 0 };
}];
function Zo(i, e = i.type) {
  Nu.set(e, i);
}
function LS(i) {
  CP.push(i);
}
function xP(i, e) {
  TS2.set(i, e);
}
function DS(i, e) {
  const t = i.layer;
  if (t === null) return;
  const n = t.toJSON(), r = new e(i);
  r.restoreState(n), r.initializationDone(), i.layer = r;
}
function EP(i, e) {
  return e !== i.name ? (e = i.manager.root.layerManager.getUniqueLayerName(e), i.name = e, i.layerChanged.dispatch(), true) : false;
}
function Qo(i) {
  if (!i.wasDisposed)
    for (const e of i.containers)
      e.removeManagedLayer(i);
}
function Sv(i, e) {
  return i === void 0 ? e : e === void 0 ? i : i.priority < e.priority ? e : i;
}
function lW(i) {
  let e;
  for (const n of CP)
    e = Sv(e, n(i));
  const t = i.volume;
  if (t !== void 0) {
    const n = TS2.get(t.volumeType);
    n !== void 0 && (e = Sv(e, { layerConstructor: n, priority: 0 }));
  }
  return e;
}
function kP(i) {
  let e;
  for (const t of i) {
    const r = t.subsourceEntry.subsource;
    e = Sv(e, lW(r));
  }
  return e;
}
var zr = class extends Xo {
  activateDataSubsources(e) {
    var t;
    this.detectedLayerConstructor = (t = kP(e)) === null || t === void 0 ? void 0 : t.layerConstructor;
  }
};
zr.type = "new";
zr.typeAbbreviation = "new";
var IS = class extends Xo {
  activateDataSubsources(e) {
    var t;
    const n = (t = kP(e)) === null || t === void 0 ? void 0 : t.layerConstructor;
    n !== void 0 && DS(this.managedLayer, n);
  }
};
IS.type = "auto";
IS.typeAbbreviation = "auto";
function TP(i, e) {
  const t = SP(i, "new layer", { type: "new" });
  i.add(t), e.layer = t, e.visible = true;
}
Zo(zr);
Zo(IS);
function GE(i, e) {
  return e = tr(e, 3432918353) >>> 0, e = (e << 15 | e >>> 17) >>> 0, e = tr(e, 461845907) >>> 0, i ^= e, i = (i << 13 | i >>> 19) >>> 0, i = tr(i, 5) + 3864292196 >>> 0, i;
}
function cW(i, e) {
  return i ^= e, i ^= i >>> 16, i = tr(i, 2246822507) >>> 0, i ^= i >>> 13, i *= 3266489909, i ^= i >>> 16, i >>> 0;
}
function LP(i, e, t) {
  let n = i;
  return n = GE(n, e), n = GE(n, t), cW(n, 8);
}
var dW = class extends Wr {
  constructor(e, t) {
    super(e, t), this.properties = t.properties;
  }
  static encodeOptions(e) {
    return { properties: e.properties };
  }
};
function uW(i, e, t) {
  const n = i.length - 1;
  for (; ; ) {
    if (e = e & n, i[e] === 0) {
      i[e] = t;
      return;
    }
    ++e;
  }
}
function Ou(i, e) {
  return e <= 255 ? new Uint8Array(i) : e <= 65535 ? new Uint16Array(i) : new Uint32Array(i);
}
function hW(i) {
  const e = i.length / 2, n = 2 ** (Math.ceil(Zn(e)) + 1), r = Ou(n, e + 1);
  for (let s = 0; s < e; ++s) {
    const a = i[2 * s], l = i[2 * s + 1];
    uW(r, LP(
      /*seed=*/
      0,
      a,
      l
    ), s + 1);
  }
  return r;
}
function fW(i, e, t, n) {
  let r = LP(
    /*seed=*/
    0,
    t,
    n
  );
  const s = i.length - 1;
  for (; ; ) {
    r = r & s;
    let a = i[r];
    if (a === 0) return -1;
    if (--a, e[2 * a] === t && e[2 * a + 1] === n)
      return a;
    ++r;
  }
}
var DP = class {
  constructor(e) {
    this.inlineProperties = e.inlineProperties;
  }
};
var pW = class {
  constructor(e) {
    var t;
    this.segmentPropertyMap = e;
    const n = e.inlineProperties;
    n !== void 0 && (this.inlineIdToIndex = hW(n.ids)), this.tags = n == null ? void 0 : n.properties.find((r) => r.type === "tags"), this.labels = n == null ? void 0 : n.properties.find((r) => r.type === "label"), this.numericalProperties = (t = n == null ? void 0 : n.properties.filter((r) => r.type === "number")) !== null && t !== void 0 ? t : [];
  }
  getSegmentInlineIndex(e) {
    const t = this.inlineIdToIndex;
    return t === void 0 ? -1 : fW(t, this.segmentPropertyMap.inlineProperties.ids, e.low, e.high);
  }
  getSegmentLabel(e) {
    const t = this.getSegmentInlineIndex(e);
    if (t === -1) return;
    const n = this.labels, r = this.tags;
    let s = "";
    if (n !== void 0 && (s = n.values[t]), r !== void 0) {
      const a = r.tags;
      let d = r.values[t];
      for (let u = 0, h = d.length; u < h; ++u) {
        const g = a[d.charCodeAt(u)];
        s.length > 0 && (s += " "), s += "#", s += g;
      }
    }
    if (s.length !== 0)
      return s;
  }
};
function IP(i, e, t) {
  for (let n = 0, r = t.length; n < r; ++n)
    e[t[n]] = i[n];
}
function gW(i) {
  const e = i.length;
  if (e === 0) return true;
  let t = i[0], n = i[1];
  for (let r = 0; r < e; r += 2) {
    const s = i[r], a = i[r + 1];
    if ((a - n || s - t) <= 0) return false;
    t = s, n = a;
  }
  return true;
}
function mW(i) {
  const e = i.ids;
  if (gW(e))
    return i;
  const t = e.length / 2, n = Ou(t, t - 1);
  for (let a = 0; a < t; ++a)
    n[a] = a;
  n.sort((a, l) => {
    const d = e[a * 2], u = e[a * 2 + 1], h = e[l * 2], g = e[l * 2 + 1];
    return u - g || d - h;
  });
  const r = new Uint32Array(t * 2);
  for (let a = 0; a < t; ++a) {
    const l = n[a];
    r[a * 2] = e[l * 2], r[a * 2 + 1] = e[l * 2 + 1];
  }
  const s = i.properties.map((a) => {
    const l = a.values, d = new l.constructor(t);
    for (let u = 0; u < t; ++u)
      d[u] = l[n[u]];
    return H(H({}, a), { values: d });
  });
  return { ids: r, properties: s };
}
function vW(i, e, t) {
  const n = new Array(e);
  return n.fill(""), IP(i.values, n, t), H(H({}, i), { values: n });
}
function yW(i, e, t) {
  const n = new Float32Array(e);
  return n.fill(Number.NaN), IP(i.values, n, t), H(H({}, i), { values: n });
}
function WE(i, e, t) {
  const n = i.type;
  return n === "label" || n === "description" || n === "string" || n === "tags" ? vW(i, e, t) : yW(i, e, t);
}
function SW(i, e) {
  if (i === void 0) return e;
  if (e === void 0) return i;
  let t = 0;
  const n = i.ids.length / 2, r = e.ids.length / 2, s = new Uint32Array(n), a = new Uint32Array(r), l = i.ids, d = e.ids;
  JM(n, r, (g, v) => {
    const y = l[2 * g + 1], C = l[2 * g], w = d[2 * v + 1], b = d[2 * v];
    return y - w || C - b;
  }, (g) => {
    s[g] = t, ++t;
  }, (g) => {
    a[g] = t, ++t;
  }, (g, v) => {
    s[g] = t, a[v] = t, ++t;
  });
  let u;
  if (t === n)
    u = l;
  else if (t === r)
    u = d;
  else {
    u = new Uint32Array(t * 2);
    for (let g = 0; g < n; ++g) {
      const v = s[g];
      u[2 * v] = l[2 * g], u[2 * v + 1] = l[2 * g + 1];
    }
    for (let g = 0; g < r; ++g) {
      const v = a[g];
      u[2 * v] = d[2 * g], u[2 * v + 1] = d[2 * g + 1];
    }
  }
  const h = [];
  if (t === n)
    h.push(...i.properties);
  else
    for (const g of i.properties)
      h.push(WE(g, t, s));
  if (t === r)
    h.push(...e.properties);
  else
    for (const g of e.properties)
      h.push(WE(g, t, a));
  return { ids: u, properties: h };
}
function bW(i, e) {
  return new DP({
    inlineProperties: SW(i.inlineProperties, e.inlineProperties)
  });
}
function wW(i) {
  for (; ; ) {
    if (i.length === 0) return;
    if (i.length === 1) return i[0];
    const e = [];
    for (let t = 0, n = i.length; t < n; t += 2)
      t + 1 === n ? e.push(i[t]) : e.push(bW(i[t], i[t + 1]));
    i = e;
  }
}
function CW(i, e) {
  return i.memoize.getUncounted({ id: "getPreprocessedSegmentPropertyMap", maps: e.map((t) => En(t)) }, () => {
    const t = wW(e);
    if (t !== void 0)
      return new pW(t);
  });
}
var xW = /^[,\s]*[0-9]+(?:[,\s]+[0-9]+)*[,\s]*$/;
function EW(i, e) {
  var t;
  if (e.match(xW) !== null) {
    const g = e.split(/[\s,]+/), v = [], y = new Ye();
    for (let C = 0, w = g.length; C < w; ++C) {
      const b = g[C];
      if (b === "") continue;
      const E = new re();
      if (!E.tryParseString(b))
        continue;
      const T = E.toString();
      y.has(T) || (y.add(T), v.push(E));
    }
    return v.sort(re.compare), { ids: v };
  }
  const n = {
    regexp: void 0,
    prefix: void 0,
    includeTags: [],
    excludeTags: [],
    numericalConstraints: [],
    sortBy: [],
    includeColumns: []
  }, r = (t = i == null ? void 0 : i.segmentPropertyMap.inlineProperties) === null || t === void 0 ? void 0 : t.properties, s = i == null ? void 0 : i.tags, a = (s == null ? void 0 : s.tags) || [], l = a.map((g) => g.toLowerCase()), d = i == null ? void 0 : i.labels, u = [];
  let h;
  for (let g = 0; g < e.length; g = h) {
    let v = e.indexOf(" ", g), y;
    if (v === -1 ? h = v = e.length : h = v + 1, y = e.substring(g, v), y.length === 0) continue;
    const C = (b, E) => {
      const T = b.toLowerCase(), I = l.indexOf(T);
      if (I === -1) {
        u.push({ begin: E, end: v, message: `Invalid tag: ${b}` });
        return;
      }
      if (b = a[I], n.includeTags.includes(b) || n.excludeTags.includes(b)) {
        u.push({ begin: E, end: v, message: `Duplicate tag: ${b}` });
        return;
      }
      return b;
    };
    if (y.startsWith("#")) {
      const b = C(y.substring(1), g + 1);
      b !== void 0 && n.includeTags.push(b);
      continue;
    }
    if (y.startsWith("-#")) {
      const b = C(y.substring(2), g + 2);
      b !== void 0 && n.excludeTags.push(b);
      continue;
    }
    if (y.startsWith("<") || y.startsWith(">")) {
      let b = y.substring(1).toLowerCase();
      if (b !== "id" && b !== "label") {
        const E = r == null ? void 0 : r.find((T) => T.id.toLowerCase() === b && (T.type === "number" || T.type === "label" || T.type === "string"));
        if (E === void 0) {
          u.push({ begin: g + 1, end: v, message: `Invalid field: ${b}` });
          continue;
        }
        b = E.id;
      }
      if (n.sortBy.find((E) => E.fieldId === b) !== void 0) {
        u.push({ begin: g + 1, end: v, message: `Duplicate sort field: ${b}` });
        continue;
      }
      n.sortBy.push({ order: y[0], fieldId: b });
      continue;
    }
    if (y.startsWith("|")) {
      let b = y.substring(1).toLowerCase();
      if (b === "id" || b === "label") continue;
      const E = r == null ? void 0 : r.find((T) => T.id.toLowerCase() === b && (T.type === "number" || T.type === "string"));
      if (E === void 0) {
        u.push({ begin: g + 1, end: v, message: `Invalid field: ${b}` });
        continue;
      }
      if (b = E.id, n.sortBy.find((T) => T.fieldId === b) || n.includeColumns.find((T) => T === b))
        continue;
      n.includeColumns.push(b);
      continue;
    }
    if (y.startsWith("/")) {
      if (n.regexp !== void 0) {
        u.push({ begin: g, end: v, message: "Only one regular expression allowed" });
        continue;
      }
      if (n.prefix !== void 0) {
        u.push({
          begin: g,
          end: v,
          message: "Prefix cannot be combined with regular expression"
        });
        continue;
      }
      if (d === void 0) {
        u.push({ begin: g, end: v, message: "No label property" });
        continue;
      }
      try {
        n.regexp = new RegExp(y.substring(1));
      } catch {
        u.push({ begin: g, end: v, message: "Invalid regular expression syntax" });
      }
      continue;
    }
    const w = y.match(/^([a-zA-Z][a-zA-Z0-9_]*)(<|<=|=|>=|>)([0-9.].*)$/);
    if (w !== null) {
      let b = w[1].toLowerCase();
      const E = w[2], T = i == null ? void 0 : i.numericalProperties.find((O) => O.id.toLowerCase() === b);
      if (T === void 0) {
        u.push({
          begin: g,
          end: g + b.length,
          message: `Invalid numerical field: ${b}`
        });
        continue;
      }
      b = T.id;
      let I;
      try {
        I = xc(T.dataType, w[3]);
      } catch (O) {
        u.push({
          begin: g + w[1].length + w[2].length,
          end: v,
          message: O.message
        });
        continue;
      }
      let R = n.numericalConstraints.find((O) => O.fieldId === b);
      R === void 0 && (R = { fieldId: b, bounds: T.bounds }, n.numericalConstraints.push(R));
      const P = tc(T.bounds, R.bounds[0]), L = tc(T.bounds, R.bounds[1]);
      let A = L, M = P;
      switch (E) {
        case "<":
          A = hu(T.dataType, I, -1);
          break;
        case "<=":
          A = I;
          break;
        case "=":
          A = M = I;
          break;
        case ">=":
          M = I;
          break;
        case ">":
          M = hu(T.dataType, I, 1);
          break;
      }
      if (M = xi(P, M) > 0 ? P : M, A = xi(L, A) < 0 ? L : A, xi(M, A) > 0) {
        u.push({ begin: g, end: v, message: "Constraint would not match any values" });
        continue;
      }
      R.bounds = [M, A];
      continue;
    }
    if (n.regexp !== void 0) {
      u.push({
        begin: g,
        end: v,
        message: "Prefix cannot be combined with regular expression"
      });
      continue;
    }
    if (d === void 0) {
      u.push({ begin: g, end: v, message: "No label property" });
      continue;
    }
    n.prefix !== void 0 ? n.prefix += ` ${y}` : n.prefix = y;
  }
  return u.length > 0 ? { errors: u } : (n.sortBy.length === 0 && n.sortBy.push({ fieldId: PP(i), order: "<" }), n);
}
function im(i) {
  return "\\u" + i.toString(16).padStart(4, "0");
}
function kW(i, e) {
  var t;
  if (e.errors !== void 0)
    return { query: e, total: -1, count: 0, errors: e.errors };
  if (e.ids !== void 0) {
    const P = e.ids;
    return { query: e, total: -1, explicitIds: P, count: P.length };
  }
  const n = (t = i == null ? void 0 : i.segmentPropertyMap) === null || t === void 0 ? void 0 : t.inlineProperties;
  if (n === void 0)
    return {
      query: e,
      count: 0,
      total: -1
    };
  const r = n == null ? void 0 : n.properties, s = n.ids.length / 2;
  let a = Ou(s, s);
  for (let P = 0; P < s; ++P)
    a[P] = P;
  const l = (P) => {
    let L = a.length, A = 0;
    for (let M = 0; M < L; ++M) {
      const O = a[M];
      P(O) && (a[A] = O, ++A);
    }
    a = a.subarray(0, A);
  };
  if (e.regexp !== void 0 || e.prefix !== void 0) {
    const P = i.labels.values, L = e.regexp, A = e.prefix;
    L !== void 0 && l((M) => P[M].match(L) !== null), A !== void 0 && l((M) => P[M].startsWith(A));
  }
  const d = e.includeTags, u = e.excludeTags, h = i.tags;
  if (d.length > 0 || u.length > 0) {
    const P = h.values, L = h.tags, A = [];
    for (const U of d)
      A.push([L.indexOf(U), 1]);
    for (const U of u)
      A.push([L.indexOf(U), 0]);
    A.sort((U, V) => U[0] - V[0]);
    let M = "^", O = 0;
    const F = (U) => {
      U < O || (M += `[${im(O)}-${im(U)}]*`);
    };
    for (const U of A) {
      var g = de(U, 2);
      const V = g[0], $ = g[1];
      F(V - 1), $ && (M += im(V)), O = V + 1;
    }
    F(65535), M += "$";
    const q = new RegExp(M);
    l((U) => P[U].match(q) !== null);
  }
  let v, y;
  const C = e.numericalConstraints;
  if (C.length > 0) {
    const P = i.numericalProperties, L = C.length, A = 2 ** L - 1;
    v = Ou(a.length, A);
    for (let F = 0; F < L; ++F) {
      const q = C[F], V = P.find((se) => se.id === q.fieldId).values, $ = 2 ** F;
      var w = de(q.bounds, 2);
      const B = w[0], ue = w[1];
      for (let se = 0, Pe = a.length; se < Pe; ++se) {
        const ae = V[a[se]];
        v[se] |= $ * (ae >= B && ae <= ue);
      }
    }
    y = a, a = y.slice();
    let M = a.length, O = 0;
    for (let F = 0; F < M; ++F)
      v[F] === A && (a[O] = a[F], ++O);
    a = a.subarray(0, O);
  }
  let b = [];
  if (h !== void 0) {
    const P = [], L = h.tags, A = h.values, M = new Uint32Array(L.length);
    for (let O = 0, F = a.length; O < F; ++O) {
      const q = A[a[O]];
      for (let U = 0, V = q.length; U < V; ++U)
        ++M[q.charCodeAt(U)];
    }
    for (let O = 0, F = L.length; O < F; ++O) {
      const q = M[O], U = L[O], V = { tag: U, tagIndex: O, count: M[O] };
      e.includeTags.includes(U) || e.excludeTags.includes(U) ? P.push(V) : q > 0 && b.push(V);
    }
    P.push(...b), b = P;
  }
  const E = (P, L) => {
    if (P.type !== "number") {
      const A = P.values;
      a.sort((M, O) => Ac(A[M], A[O]) * L);
    } else {
      const A = P.values;
      a.sort((M, O) => (A[M] - A[O]) * L);
    }
  }, T = (P) => {
    h !== void 0 && E(h, P);
    const L = i == null ? void 0 : i.labels;
    L !== void 0 && E(L, P);
  }, I = e.sortBy;
  for (let P = I.length - 1; P >= 0; --P) {
    var R = I[P];
    const L = R.fieldId, A = R.order, M = A === "<" ? 1 : -1;
    if (L === "id") {
      if (P + 1 === I.length) {
        if (A === "<")
          continue;
        a.reverse();
        continue;
      }
      a.sort((O, F) => M * (O - F));
      continue;
    } else L === "label" ? T(M) : E(r.find((O) => O.id === L), M);
  }
  return {
    query: e,
    intermediateIndices: y,
    intermediateIndicesMask: v,
    indices: a,
    tags: b,
    count: a.length,
    total: s
  };
}
function TW(i, e, t) {
  const r = e.values;
  var s = de(t, 2);
  const a = s[0], l = s[1], d = l <= a ? 0 : 256 / (l - a), u = new Uint32Array(258), h = i.query.numericalConstraints, g = h.findIndex((v) => v.fieldId === e.id);
  if (g === -1) {
    const v = i.indices;
    for (let y = 0, C = v.length; y < C; ++y) {
      const w = r[v[y]];
      isNaN(w) || ++u[Math.min(255, Math.max(-1, (w - a) * d)) + 1 >>> 0];
    }
  } else {
    const v = i.intermediateIndices, y = i.intermediateIndicesMask, C = 2 ** h.length - 1 - 2 ** g;
    for (let w = 0, b = v.length; w < b; ++w)
      if ((y[w] & C) == C) {
        const T = r[v[w]];
        isNaN(T) || ++u[Math.min(255, Math.max(-1, (T - a) * d)) + 1 >>> 0];
      }
  }
  return { queryResult: i, histogram: u, window: t };
}
function LW(i, e, t, n) {
  if (i === void 0) {
    t.length = 0, n.length = 0;
    return;
  }
  const r = i.numericalProperties, s = r.length;
  if ((e == null ? void 0 : e.indices) === void 0) {
    t.length = 0;
    return;
  }
  for (let l = 0; l < s; ++l) {
    const d = t[l], u = n[l], h = r[l];
    d !== void 0 && d.queryResult === e && Pr(h.dataType, d.window, u) || (t[l] = TW(e, h, u));
  }
}
function PP(i) {
  return (i == null ? void 0 : i.tags) || (i == null ? void 0 : i.labels) ? "label" : "id";
}
function DW(i, e) {
  var t = e;
  const n = t.ids;
  if (n !== void 0)
    return n.map((g) => g.toString()).join(", ");
  let r = "";
  e = e;
  var s = e;
  const a = s.prefix, l = s.regexp;
  a !== void 0 ? r = a : l !== void 0 && (r = `/${l}`);
  for (const g of e.includeTags)
    r.length > 0 && (r += " "), r += `#${g}`;
  for (const g of e.excludeTags)
    r.length > 0 && (r += " "), r += `-#${g}`;
  for (const g of e.numericalConstraints) {
    const v = g.fieldId, y = g.bounds;
    var d = de(y, 2);
    const C = d[0], w = d[1], b = i.numericalProperties.find((E) => E.id === v);
    if (!Pr(b.dataType, b.bounds, y)) {
      if (xi(C, w) === 0) {
        r.length > 0 && (r += " "), r += `${v}=${C}`;
        continue;
      }
      if (xi(C, b.bounds[0]) > 0) {
        r.length > 0 && (r += " ");
        const E = hu(b.dataType, C, -1), T = C.toString(), I = E.toString();
        b.dataType !== j.FLOAT32 || T.length <= I.length ? r += `${v}>=${T}` : r += `${v}>${I}`;
      }
      if (xi(w, b.bounds[1]) < 0) {
        r.length > 0 && (r += " ");
        const E = hu(b.dataType, w, 1), T = w.toString(), I = E.toString();
        b.dataType !== j.FLOAT32 || T.length <= I.length ? r += `${v}<=${T}` : r += `${v}<${I}`;
      }
    }
  }
  var u = e;
  let h = u.sortBy;
  if (h.length === 1) {
    const g = h[0];
    g.order === "<" && g.fieldId === PP(i) && (h = []);
  }
  for (const g of h)
    r.length > 0 && (r += " "), r += `${g.order}${g.fieldId}`;
  for (const g of e.includeColumns)
    r.length > 0 && (r += " "), r += `|${g}`;
  return r;
}
var rm = new re();
function tu(i, e, t) {
  if (e === void 0) return;
  const n = e.explicitIds;
  if (n !== void 0) {
    n.forEach(t);
    return;
  }
  const r = e.indices;
  if (r !== void 0) {
    var s = i == null ? void 0 : i.segmentPropertyMap.inlineProperties;
    const a = s.ids;
    for (let l = 0, d = r.length; l < d; ++l) {
      const u = r[l];
      rm.low = a[u * 2], rm.high = a[u * 2 + 1], t(rm, l);
    }
  }
}
function IW(i, e, t) {
  if (t.size === 0) return 0;
  let n = 0;
  return tu(i, e, (r) => {
    t.has(r) && ++n;
  }), n;
}
function HE(i, e, t, n) {
  const r = i.includeTags.filter((a) => a !== e), s = i.excludeTags.filter((a) => a !== e);
  return n === true && (t ? r : s).push(e), H(H({}, i), { includeTags: r, excludeTags: s });
}
function PW(i) {
  return i.ids !== void 0 ? false : i.errors !== void 0 ? true : !(i.numericalConstraints.length > 0 || i.includeTags.length > 0 || i.excludeTags.length > 0 || i.prefix || i.regexp);
}
function PS(i, e) {
  if (i === void 0 || i.ids !== void 0 || i.errors !== void 0) return false;
  const t = i.sortBy, n = i.includeColumns;
  return t.find((r) => r.fieldId === e) !== void 0 || n.includes(e);
}
var nu = li("disjoint_sets:rank");
var Rr = li("disjoint_sets:parent");
var Vu = li("disjoint_sets:next");
var Gl = li("disjoint_sets:prev");
function sm(i) {
  let e = i, t = i[Rr];
  for (; t !== i; )
    i = t, t = i[Rr];
  for (i = e[Rr]; t !== i; )
    e[Rr] = t, e = i, i = e[Rr];
  return t;
}
function RW(i, e) {
  let t = i[nu], n = e[nu];
  return t > n ? (e[Rr] = i, i) : (i[Rr] = e, t === n && (e[nu] = n + 1), e);
}
function AW(i, e) {
  let t = i[Gl], n = e[Gl];
  e[Gl] = t, t[Vu] = e, i[Gl] = n, n[Vu] = i;
}
function* qE(i) {
  let e = i;
  do
    yield e, e = e[Vu];
  while (e !== i);
}
function _W(i) {
  i[Rr] = i, i[nu] = 0, i[Vu] = i[Gl] = i;
}
var Xa = li("disjoint_sets:min");
function jE(i) {
  return i[Rr] === i;
}
var RP = class {
  constructor() {
    this.map = new he(), this.visibleSegmentEquivalencePolicy = new vt(Bi.MIN_REPRESENTATIVE), this.generation = 0;
  }
  has(e) {
    let t = e.toString();
    return this.map.get(t) !== void 0;
  }
  get(e) {
    let t = e.toString(), n = this.map.get(t);
    return n === void 0 ? e : sm(n)[Xa];
  }
  isMinElement(e) {
    let t = this.get(e);
    return t === e || re.equal(t, e);
  }
  makeSet(e) {
    let t = e.toString(), n = this.map, r = n.get(t);
    return r === void 0 ? (r = e.clone(), _W(r), r[Xa] = r, n.set(t, r), r) : sm(r);
  }
  /**
   * Union the sets containing `a` and `b`.
   * @returns `false` if `a` and `b` are already in the same set, otherwise `true`.
   */
  link(e, t) {
    if (e = this.makeSet(e), t = this.makeSet(t), e === t)
      return false;
    this.generation++;
    let n = RW(e, t);
    AW(e, t);
    let r = e[Xa], s = t[Xa];
    const a = (this.visibleSegmentEquivalencePolicy.value & Bi.MAX_REPRESENTATIVE) !== 0;
    return n[Xa] = re.less(r, s) === a ? s : r, true;
  }
  linkAll(e) {
    for (let t = 1, n = e.length; t < n; ++t)
      this.link(e[0], e[t]);
  }
  /**
   * Unlinks all members of the specified set.
   */
  deleteSet(e) {
    const t = this.map;
    let n = false;
    for (const r of this.setElements(e))
      t.delete(r.toString()), n = true;
    return n;
  }
  *setElements(e) {
    let t = e.toString(), n = this.map.get(t);
    n === void 0 ? yield e : yield* qE(n);
  }
  clear() {
    let e = this.map;
    return e.size === 0 ? false : (++this.generation, e.clear(), true);
  }
  get size() {
    return this.map.size;
  }
  *mappings(e = new Array(2)) {
    for (let t of this.map.values())
      e[0] = t, e[1] = sm(t)[Xa], yield e;
  }
  *roots() {
    for (let e of this.map.values())
      jE(e) && (yield e);
  }
  [qn]() {
    return this.mappings();
  }
  /**
   * Returns an array of arrays of strings, where the arrays contained in the outer array correspond
   * to the disjoint sets, and the strings are the base-10 string representations of the members of
   * each set.  The members are sorted in numerical order, and the sets are sorted in numerical
   * order of their smallest elements.
   */
  toJSON() {
    let e = new Array();
    for (let t of this.map.values())
      if (jE(t)) {
        let n = new Array();
        for (let r of qE(t))
          n.push(r);
        n.sort(re.compare), e.push(n);
      }
    return e.sort((t, n) => re.compare(t[0], n[0])), e.map((t) => t.map((n) => n.toString()));
  }
};
var MW = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
var bv;
var NW = "DisjointUint64Sets";
var AP = "DisjointUint64Sets.add";
var _P = "DisjointUint64Sets.clear";
var MP = "DisjointUint64Sets.highBitRepresentativeChanged";
var NP = "DisjointUint64Sets.deleteSet";
var mc = bv = class extends ph {
  constructor() {
    super(...arguments), this.disjointSets = new RP(), this.changed = new Le();
  }
  /**
   * For compatibility with `WatchableValueInterface`.
   */
  get value() {
    return this;
  }
  static makeWithCounterpart(e, t) {
    let n = new this();
    return n.disjointSets.visibleSegmentEquivalencePolicy = t, n.registerDisposer(t.changed.add(() => {
      JE(n);
    })), n.initializeCounterpart(e), t.value && JE(n), n;
  }
  disposed() {
    this.disjointSets = void 0, this.changed = void 0, super.disposed();
  }
  link(e, t) {
    if (this.disjointSets.link(e, t)) {
      let n = this.rpc;
      return n && n.invoke(AP, { id: this.rpcId, al: e.low, ah: e.high, bl: t.low, bh: t.high }), this.changed.dispatch(), true;
    }
    return false;
  }
  linkAll(e) {
    for (let t = 1, n = e.length; t < n; ++t)
      this.link(e[0], e[t]);
  }
  has(e) {
    return this.disjointSets.has(e);
  }
  get(e) {
    return this.disjointSets.get(e);
  }
  clear() {
    if (this.disjointSets.clear()) {
      let e = this.rpc;
      e && e.invoke(_P, { id: this.rpcId }), this.changed.dispatch();
    }
  }
  setElements(e) {
    return this.disjointSets.setElements(e);
  }
  deleteSet(e) {
    if (this.disjointSets.deleteSet(e)) {
      let t = this.rpc;
      t && t.invoke(NP, { id: this.rpcId, l: e.low, h: e.high }), this.changed.dispatch();
    }
  }
  get size() {
    return this.disjointSets.size;
  }
  toJSON() {
    return this.disjointSets.toJSON();
  }
  /**
   * Restores the state from a JSON representation.
   */
  restoreState(e) {
    if (e !== void 0) {
      let t = [new re(), new re()];
      Xe(e, (n) => {
        Xe(n, (r, s) => {
          t[s % 2].parseString(String(r), 10), s !== 0 && this.link(t[0], t[1]);
        });
      });
    }
  }
  assignFrom(e) {
    this.clear(), e instanceof bv && (e = e.disjointSets);
    for (const n of e) {
      var t = de(n, 2);
      const r = t[0], s = t[1];
      this.link(r, s);
    }
  }
};
mc = bv = MW([gh(NW)], mc);
var uo = new re();
var am = new re();
zt(AP, function(i) {
  let e = this.get(i.id);
  uo.low = i.al, uo.high = i.ah, am.low = i.bl, am.high = i.bh, e.disjointSets.link(uo, am) && e.changed.dispatch();
});
zt(_P, function(i) {
  let e = this.get(i.id);
  e.disjointSets.clear() && e.changed.dispatch();
});
function JE(i) {
  i.rpc.invoke(MP, { id: i.rpcId, value: i.disjointSets.visibleSegmentEquivalencePolicy.value });
}
zt(MP, function(i) {
  let e = this.get(i.id);
  e.disjointSets.visibleSegmentEquivalencePolicy.value = i.value;
});
zt(NP, function(i) {
  let e = this.get(i.id);
  uo.low = i.l, uo.high = i.h, e.disjointSets.deleteSet(uo) && e.changed.dispatch();
});
var OW = class extends FF {
  constructor() {
    super(...arguments), this.spanningTreeEdges = new he(), this.equivalences = new mc(), this.connections = new Ye(), this.changed = new ct();
  }
  link(e, t) {
    this.equivalences.link(e, t);
    for (const n of this.connections)
      n.segmentsState.segmentEquivalences.link(e, t);
  }
  linkAll(e) {
    this.equivalences.linkAll(e);
    for (const t of this.connections)
      t.segmentsState.segmentEquivalences.linkAll(e);
  }
  deleteSet(e) {
    this.equivalences.deleteSet(e);
    for (const t of this.connections)
      t.segmentsState.segmentEquivalences.deleteSet(e);
  }
  normalizeAll() {
    for (const e of this.connections)
      om(e.segmentsState.visibleSegments, e.segmentsState.segmentEquivalences.disjointSets);
  }
  addSpanningTreeEdge(e, t) {
    const n = e.toString(), r = t.toString(), s = this.spanningTreeEdges;
    let a = s.get(n);
    a === void 0 && (a = new Ye(), s.set(n, a));
    let l = s.get(r);
    l === void 0 && (l = new Ye(), s.set(r, l)), a.add(r), l.add(n);
  }
  removeSpanningTreeEdge(e, t) {
    const n = e.toString(), r = t.toString(), s = this.spanningTreeEdges, a = s.get(n), l = s.get(r);
    a.delete(r), a.size === 0 && s.delete(n), l.delete(n), l.size === 0 && s.delete(r);
  }
  *getSpanningTreeNeighbors(e) {
    const t = new re(), n = this.spanningTreeEdges.get(e.toString());
    if (n !== void 0)
      for (const r of n)
        t.parseString(r), yield t;
  }
  restoreState(e) {
    const t = this.equivalences, n = this.spanningTreeEdges;
    if (t.clear(), n.clear(), e === void 0)
      return;
    const r = [new re(), new re()];
    Xe(e, (s) => {
      Xe(s, (a, l) => {
        r[l % 2].parseString(String(a), 10), l !== 0 && t.link(r[0], r[1]) && this.addSpanningTreeEdge(r[0], r[1]);
      });
    });
  }
  toJSON() {
    const e = this.spanningTreeEdges;
    if (e.size === 0) return;
    const t = new Array();
    for (let r of e) {
      var n = de(r, 2);
      let s = n[0], a = n[1];
      const l = re.parseString(s);
      for (const d of a) {
        const u = re.parseString(d);
        re.compare(l, u) > 0 || t.push([l, u]);
      }
    }
    return t.sort((r, s) => re.compare(r[0], s[0]) || re.compare(r[1], s[1])), t.map((r) => r.map((s) => s.toString()));
  }
  get visibleSegmentEquivalencePolicy() {
    return Bi.MIN_REPRESENTATIVE;
  }
  async merge(e, t) {
    const n = this.equivalences;
    return re.equal(n.get(e), n.get(t)) ? e : (this.addSpanningTreeEdge(e, t), this.link(e, t), this.normalizeAll(), this.changed.dispatch(), n.get(e));
  }
  async split(e, t) {
    const n = this.computeSplit(e, t);
    if (n === void 0)
      throw new Error("Segments are already split");
    const r = n.includeBaseSegments, s = n.includeRepresentative, a = n.excludeBaseSegments, l = n.excludeRepresentative, d = this.equivalences;
    this.deleteSet(e), this.linkAll(r), this.linkAll(a);
    const u = (v, y) => {
      for (const C of v)
        for (const w of this.getSpanningTreeNeighbors(C))
          re.equal(d.get(w), y) || this.removeSpanningTreeEdge(C, w);
    }, h = d.get(e), g = d.get(t);
    u(r, h), u(a, g);
    for (const v of this.connections) {
      const y = v.segmentsState.visibleSegments;
      y.has(l) && (y.delete(l), y.add(s));
    }
    return this.normalizeAll(), this.changed.dispatch(), { include: h, exclude: g };
  }
  trackSegment(e, t) {
    return () => {
    };
  }
  computeSplit(e, t) {
    const n = this.equivalences, r = n.get(e);
    if (!re.equal(r, n.get(t)))
      return;
    const s = new RP();
    for (const g of n.setElements(r))
      if (!re.equal(g, t))
        for (const v of this.getSpanningTreeNeighbors(g))
          re.equal(v, t) || s.link(g, v);
    const a = [], l = [], d = s.get(e);
    let u = e, h = t;
    for (const g of n.setElements(r))
      re.equal(s.get(g), d) ? (a.push(g), re.compare(g, u) < 0 && (u = g)) : (l.push(g), re.compare(g, h) < 0 && (h = g));
    return a.sort(re.compare), l.sort(re.compare), {
      includeBaseSegments: a,
      includeRepresentative: u,
      excludeBaseSegments: l,
      excludeRepresentative: h
    };
  }
  connect(e) {
    const t = new VW(this, e);
    return e.segmentEquivalences.assignFrom(this.equivalences), om(e.visibleSegments, e.segmentEquivalences.disjointSets), t.registerDisposer(e.visibleSegments.changed.add(t.registerCancellable(dt(() => om(e.visibleSegments, e.segmentEquivalences.disjointSets), 0)))), this.connections.add(t), t.registerDisposer(() => {
      this.connections.delete(t);
    }), t;
  }
};
function om(i, e) {
  const t = [];
  for (const n of i.unsafeKeys()) {
    const r = e.get(n);
    re.equal(n, r) || (t.push(r), i.delete(n));
  }
  for (const n of t)
    i.add(n);
}
var VW = class extends UF {
  computeSplit(e, t) {
    return this.graph.computeSplit(e, t);
  }
};
var Pn;
(function(i) {
  i[i.UNKNOWN = 0] = "UNKNOWN", i[i.IMAGE = 1] = "IMAGE", i[i.SEGMENTATION = 2] = "SEGMENTATION";
})(Pn || (Pn = {}));
function KE(i) {
  const e = i.rank, t = i.dataType, n = i.compressedSegmentationBlockSize;
  var r = i.baseVoxelOffset;
  const s = r === void 0 ? new Float32Array(e) : r;
  return H(H({}, Dc(i)), {
    compressedSegmentationBlockSize: n,
    baseVoxelOffset: s,
    dataType: t
  });
}
function BW(i) {
  if (i.compressedSegmentationBlockSize !== void 0 || i.volumeType !== Pn.SEGMENTATION && !i.volumeSourceOptions.discreteValues)
    return false;
  switch (i.dataType) {
    case j.UINT32:
    case j.UINT64:
      break;
    default:
      return false;
  }
  switch (i.rank) {
    case 3:
      return true;
    case 4:
      return i.chunkDataSize[3] === 1;
    default:
      return false;
  }
}
function FW(i) {
  let e = i.rank, t = i.lowerVoxelBound, n = i.upperVoxelBound;
  if (!BW(i))
    return KE(i);
  var r = i.volumeSourceOptions;
  let s = r.displayRank, a = r.multiscaleToViewTransform, l = i.chunkToMultiscaleTransform, d = i.chunkToViewTransform;
  d === void 0 && (d = hh(
    new Float32Array(e * s),
    s,
    //
    a,
    s,
    //
    l,
    e + 1,
    //
    s,
    e,
    e
  ));
  const u = i.maxCompressedSegmentationBlockSize, h = i.chunkDataSize;
  return KE(H(H({}, i), { compressedSegmentationBlockSize: Float32Array.from(wu({
    rank: e,
    chunkToViewTransform: d,
    displayRank: s,
    lowerVoxelBound: t,
    upperVoxelBound: n,
    maxVoxelsPerChunkLog2: 9,
    maxBlockSize: u === void 0 ? h : JO(new Uint32Array(e), h, u)
  })) }));
}
function Wc(i) {
  const e = i.rank;
  var t = i.volumeSourceOptions;
  const n = t.displayRank, r = t.multiscaleToViewTransform, s = t.modelChannelDimensionIndices, a = i.chunkToMultiscaleTransform, l = hh(
    new Float32Array(n * e),
    n,
    //
    r,
    n,
    //
    a,
    e + 1,
    //
    n,
    e,
    e
  );
  let d = i.minBlockSize;
  d === void 0 ? (d = new Uint32Array(e), d.fill(1)) : d = new Uint32Array(d);
  const u = i.lowerVoxelBound, h = i.upperVoxelBound;
  if (s.length !== 0)
    for (const y of ch(a, e, s)) {
      let C = h[y];
      u !== void 0 && (C -= u[y]), d[y] = C;
    }
  var g = i.chunkDataSizes;
  return (g === void 0 ? yF(H(H({}, i), {
    minBlockSize: d,
    chunkToViewTransform: l,
    displayRank: n
  })) : g).map((y) => FW(H(H({}, i), { chunkDataSize: y, chunkToViewTransform: l })));
}
var UW = ze();
var zW = ze();
var YE = 1e-3;
var $W = 1e-3;
function GW(i) {
  let e = 0;
  for (var t = 0; t < 3; ++t)
    i[t] < 0 && (e += 1 << t);
  return e;
}
var OP = new Float32Array([0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1]);
var WW = (() => {
  const i = [0, 1, 2, 4, 5, 3, 6, 7], e = [0, 1, 2, 5, 3, 4, 6, 7], t = [0, 1, 1, 4, 4, 7, 4, 7, 1, 5, 0, 1, 1, 4, 4, 7, 0, 2, 2, 5, 5, 7, 5, 7, 2, 6, 0, 2, 2, 5, 5, 7, 0, 3, 3, 6, 6, 7, 6, 7, 3, 4, 0, 3, 3, 6, 6, 7], n = [0, 1, 2, 3, 4, 5, 6, 7, 1, 4, 5, 0, 3, 7, 2, 6, 2, 6, 0, 5, 7, 3, 1, 4, 3, 0, 6, 4, 1, 2, 7, 5, 4, 3, 7, 1, 0, 6, 5, 2, 5, 2, 1, 7, 6, 0, 4, 3, 6, 7, 3, 2, 5, 4, 0, 1, 7, 5, 4, 6, 2, 1, 3, 0], r = new Int32Array(8 * 8 * 6);
  for (let s = 0; s < 8; ++s)
    for (let a = 0; a < t.length; ++a) {
      const l = e[s] * 8 + t[a];
      r[s * 8 * 6 + a] = i[n[l]];
    }
  return r;
})();
function Bu(i) {
  i.addUniform("highp vec3", "uPlaneNormal"), i.addUniform("highp float", "uPlaneDistance"), i.addUniform("highp ivec2", "uVertexIndex", 24), i.addUniform("highp vec3", "uVertexBasePosition", 8), i.addInitializer((e) => {
    e.gl.uniform3fv(e.uniform("uVertexBasePosition"), OP);
  }), i.addVertexCode(`
vec3 getBoundingBoxPlaneIntersectionVertexPosition(vec3 chunkSize, vec3 boxLower, vec3 lowerClipBound, vec3 upperClipBound, int vertexIndex, float planeDistance) {
  for (int e = 0; e < 4; ++e) {
    highp ivec2 vidx = uVertexIndex[vertexIndex*4 + e];
    highp vec3 v1 = max(lowerClipBound, min(upperClipBound, chunkSize * uVertexBasePosition[vidx.x] + boxLower));
    highp vec3 v2 = max(lowerClipBound, min(upperClipBound, chunkSize * uVertexBasePosition[vidx.y] + boxLower));
    highp vec3 vDir = v2 - v1;
    highp float denom = dot(vDir, uPlaneNormal);
    if (abs(denom) > ${$W}) {
      highp float lambda = (planeDistance - dot(v1, uPlaneNormal)) / denom;
      if ((lambda >= -${YE}) && (lambda <= (1.0 + ${YE}))) {
        lambda = clamp(lambda, 0.0, 1.0);
        highp vec3 position = v1 + lambda * vDir;
        return position;
      }
    }
  }
  return vec3(0, 0, 0);
}
vec3 getBoundingBoxPlaneIntersectionVertexPosition(vec3 chunkSize, vec3 boxLower, vec3 lowerClipBound, vec3 upperClipBound, int vertexIndex) {
  return getBoundingBoxPlaneIntersectionVertexPosition(chunkSize, boxLower, lowerClipBound, upperClipBound, vertexIndex, uPlaneDistance);
}
`);
}
function HW(i, e, t) {
  const n = i.gl;
  n.uniform3fv(i.uniform("uPlaneNormal"), e), n.uniform1f(i.uniform("uPlaneDistance"), t);
  const r = GW(e);
  n.uniform2iv(i.uniform("uVertexIndex"), WW.subarray(r * 48, (r + 1) * 48));
}
function RS(i, e, t, n, r) {
  const s = DT(UW, e, n);
  su(s, s);
  const a = uy(yi(zW, t, r), s);
  HW(i, s, a);
}
var qW = 1e-3;
var jW = nt();
function JW(i, e) {
  if (Ur(i), Bu(i), i.addUniform("highp vec3", "uTranslation"), i.addUniform("highp mat4", "uProjectionMatrix"), i.addUniform("highp vec3", "uChunkDataSize"), i.addUniform("highp vec3", "uLowerClipBound"), i.addUniform("highp vec3", "uUpperClipBound"), e) {
    dr(i), i.setVertexMain(`
int vertexIndex1 = gl_VertexID / ${gs};
int vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;
vec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex1);
vec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex2);
emitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),
         uProjectionMatrix * vec4(vertexPosition2, 1.0),
         2.0);
`), i.setFragmentMain(`
emit(vec4(1.0, 1.0, 1.0, getLineAlpha()));
`);
    return;
  }
  i.addVarying("highp vec3", "vChunkPosition"), i.setVertexMain(`
vec3 position = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, gl_VertexID);
gl_Position = uProjectionMatrix * vec4(position, 1.0);
gl_Position.z = 0.0;
vChunkPosition = (position - uTranslation) +
    ${qW} * abs(uPlaneNormal);
`);
}
function KW(i, e, t) {
  t && hr(
    i,
    e,
    /*featherWidthInPixels=*/
    1
  );
}
function YW(i, e, t, n, r, s) {
  const a = t.projectionParameters.value, l = a.centerDataPosition;
  RS(e, a.viewportNormalInGlobalCoordinates, l, s.transform, s.invTransform), i.uniformMatrix4fv(e.uniform("uProjectionMatrix"), false, vn(jW, n, s.transform)), i.uniform3fv(e.uniform("uLowerClipBound"), r.lowerClipDisplayBound), i.uniform3fv(e.uniform("uUpperClipBound"), r.upperClipDisplayBound);
}
function XW(i, e, t) {
  i.uniform3fv(e.uniform("uChunkDataSize"), t);
}
function ZW(i, e, t, n) {
  i.uniform3fv(e.uniform("uTranslation"), t), n ? ur(e.gl, 6, 1) : i.drawArrays(i.TRIANGLE_FAN, 0, 6);
}
function QW(i, e, t) {
  return i > e ? t > i ? i : e > t ? e : t : t > e ? e : i > t ? i : t;
}
var VP = class extends Jy {
  constructor(e, t) {
    var n = t.shaderError;
    const r = n === void 0 ? vh() : n, s = t.shaderParameters;
    super(e.chunkManager, e, t);
    const a = this.gl;
    this.vertexIdHelper = this.registerDisposer(fr.get(a)), this.shaderParameters = s;
    const l = t.channelCoordinateSpace;
    this.channelCoordinateSpace = l === void 0 ? ta(Vr) : l, this.registerDisposer(s.changed.add(this.redrawNeeded.dispatch));
    const d = this.registerDisposer(wi((u, h) => ({ numChannelDimensions: u.rank, dataHistogramChannelSpecifications: h }), [this.channelCoordinateSpace, this.dataHistogramSpecifications.channels]));
    this.shaderGetter = My(this, a, {
      memoizeKey: `volume/RenderLayer:${En(this.constructor)}`,
      fallbackParameters: t.fallbackShaderParameters,
      parameters: s,
      encodeParameters: t.encodeShaderParameters,
      shaderError: r,
      extraParameters: d,
      defineShader: (u, h, g, v) => {
        const y = h.chunkFormat, C = h.dataHistogramsEnabled, w = v.dataHistogramChannelSpecifications, b = v.numChannelDimensions;
        if (JW(u, y === null), u.addOutputBuffer("vec4", "v4f_fragData0", 0), u.addFragmentCode(`
void emit(vec4 color) {
  v4f_fragData0 = color;
}
`), y === null)
          return;
        CI(u, y, b, "vChunkPosition");
        const E = w.length;
        if (C && E > 0) {
          let T = "";
          const I = y.dataType;
          for (let R = 0; R < E; ++R) {
            const P = w[R].channel, L = `out_histogram${R}`;
            u.addOutputBuffer("vec4", L, 1 + R);
            const A = `getDataValue(${P.join(",")})`, M = `invlerpForHistogram${R}`;
            u.addFragmentCode(aD(
              u,
              M,
              I,
              /*clamp=*/
              false
            )), u.addFragmentCode(`
float getHistogramValue${R}() {
  return invlerpForHistogram${R}(${A});
}
`), T += `{
float x = getHistogramValue${R}();
if (x < 0.0) x = 0.0;
else if (x > 1.0) x = 1.0;
else x = (1.0 + x * 253.0) / 255.0;
${L} = vec4(x, x, x, 1.0);
}`;
          }
          u.addFragmentCode(`void userMain();
void main() {
  ${T}
  userMain();
}
#define main userMain
`);
        }
        this.defineShader(u, g);
      },
      getContextKey: (u) => {
        var h;
        return `${(h = u.chunkFormat) === null || h === void 0 ? void 0 : h.shaderKey}/${u.dataHistogramsEnabled}`;
      }
    }), this.tempChunkPosition = new Float32Array(e.rank), this.initializeCounterpart();
  }
  get dataType() {
    return this.multiscaleSource.dataType;
  }
  getValueAt(e) {
    let t = this.tempChunkPosition;
    for (const n of this.visibleSourcesList) {
      const r = n.source, s = n.chunkTransform;
      if (!ic(t, e, this.localPosition.value, s.layerRank, s.combinedGlobalLocalToChunkTransform))
        continue;
      const a = r.getValueAt(t, s);
      if (a != null)
        return a;
    }
    return null;
  }
  beginChunkFormat(e, t, n) {
    const r = this.gl, s = this.dataHistogramSpecifications.visibility.visible, a = this.shaderGetter({ chunkFormat: t, dataHistogramsEnabled: s }), l = a.shader, d = a.parameters, u = a.fallback;
    if (l !== null && (l.bind(), KW(l, n, t === null), t !== null)) {
      if (s) {
        const g = a.extraParameters.dataHistogramChannelSpecifications.length, v = this.dataHistogramSpecifications.bounds.value;
        for (let y = 0; y < g; ++y)
          Uy(l, `invlerpForHistogram${y}`, t.dataType, v[y]);
      }
      this.initializeShader(e, l, d, u), t.beginDrawing(r, l);
    }
    return a;
  }
  endSlice(e, t, n) {
  }
  draw(e) {
    const t = e.sliceView, r = t.visibleLayers.get(this).visibleSources;
    if (r.length === 0)
      return;
    const s = e.projectionParameters, a = e.wireFrame, l = this.gl;
    this.vertexIdHelper.enable();
    const d = ze(), u = this.renderScaleHistogram;
    u !== void 0 && u.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
    let h, g = null, v;
    const y = ze(), C = () => {
      g !== null && (v !== null && v.endDrawing(l, g), this.endSlice(t, g, h.parameters));
    };
    let w = true;
    for (const b of r) {
      const E = Hy(s, b.chunkLayout), T = b.chunkTransform.channelToChunkDimensionIndices, I = b.source, R = b.fixedPositionWithinChunk, P = b.chunkDisplayDimensionIndices;
      for (const V of P)
        R[V] = 0;
      const L = a ? null : I.chunkFormat;
      if (L !== v && (v = L, C(), h = this.beginChunkFormat(t, L, s), g = h.shader), g === null) continue;
      const A = I.chunks;
      y.fill(1);
      let M = E.size, O;
      const F = I.spec.rank;
      YW(l, g, t, s.viewProjectionMat, b, E), L !== null && L.beginSource(l, g), w = true;
      let q = 0, U = 0;
      if (t.forEachVisibleChunk(b, E, (V) => {
        let $ = A.get(V);
        if ($ && $.state === kt.GPU_MEMORY) {
          let B = $.chunkDataSize;
          if (B !== O) {
            O = B;
            for (let se = 0; se < 3; ++se) {
              const Pe = P[se];
              y[se] = Pe === -1 || Pe >= F ? 1 : O[Pe];
            }
            XW(l, g, y);
          }
          const ue = $.chunkGridPosition;
          for (let se = 0; se < 3; ++se) {
            const Pe = P[se];
            d[se] = Pe === -1 || Pe >= F ? 0 : M[se] * ue[Pe];
          }
          L !== null && L.bindChunk(l, g, $, R, P, T, w), w = false, ZW(l, g, d, a), ++q;
        } else
          ++U;
      }), (q !== 0 || U !== 0) && u !== void 0) {
        const V = b.effectiveVoxelSize, $ = QW(V[0], V[1], V[2]);
        u.add($, $ / s.pixelSize, q, U);
      }
    }
    if (C(), this.vertexIdHelper.disable(), !e.wireFrame) {
      const b = this.getDataHistogramCount();
      b > 0 && t.computeHistograms(b, this.dataHistogramSpecifications);
    }
  }
};
var XE = class {
  constructor(e) {
    this.disjointSets = e, this.generation = Number.NaN, this.hashMap = new Qy();
  }
  update() {
    let e = this.disjointSets;
    const t = e.generation;
    if (this.generation !== t) {
      this.generation = t;
      let r = this.hashMap;
      r.clear();
      for (let s of e.mappings()) {
        var n = de(s, 2);
        let a = n[0], l = n[1];
        r.set(a, l);
      }
    }
  }
};
var lm = class extends VP {
  constructor(e, t) {
    super(e, {
      shaderParameters: new vT((n) => ({
        hasEquivalences: n.registerDisposer(wi((r) => r.size !== 0, [t.segmentationGroupState.value.segmentEquivalences])),
        hasSegmentStatedColors: n.registerDisposer(wi((r) => r.size !== 0, [t.segmentStatedColors])),
        hasSegmentDefaultColor: n.registerDisposer(wi((r) => r !== void 0, [t.segmentDefaultColor])),
        hideSegmentZero: t.hideSegmentZero,
        baseSegmentColoring: t.baseSegmentColoring
      })),
      transform: t.transform,
      renderScaleHistogram: t.renderScaleHistogram,
      renderScaleTarget: t.renderScaleTarget,
      localPosition: t.localPosition
    }), this.displayState = t, this.segmentationGroupState = this.displayState.segmentationGroupState.value, this.segmentColorShaderManager = new bU("segmentColorHash"), this.segmentStatedColorShaderManager = new wU("segmentStatedColor"), this.hashTableManager = new XD("visibleSegments"), this.gpuHashTable = this.registerDisposer(Vl.get(this.gl, this.segmentationGroupState.visibleSegments.hashTable)), this.gpuTemporaryHashTable = Vl.get(this.gl, this.segmentationGroupState.temporaryVisibleSegments.hashTable), this.equivalencesShaderManager = new ZD("equivalences"), this.equivalencesHashMap = new XE(this.segmentationGroupState.segmentEquivalences.disjointSets), this.temporaryEquivalencesHashMap = new XE(this.segmentationGroupState.temporarySegmentEquivalences.disjointSets), this.gpuEquivalencesHashTable = this.registerDisposer(Vl.get(this.gl, this.equivalencesHashMap.hashMap)), this.gpuTemporaryEquivalencesHashTable = this.registerDisposer(Vl.get(this.gl, this.temporaryEquivalencesHashMap.hashMap)), this.registerDisposer(this.shaderParameters), cS(t, this), this.registerDisposer(t.selectedAlpha.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(t.notSelectedAlpha.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(t.ignoreNullVisibleSet.changed.add(this.redrawNeeded.dispatch));
  }
  disposed() {
    var e;
    (e = this.gpuSegmentStatedColorHashTable) === null || e === void 0 || e.dispose();
  }
  getSources(e) {
    return this.multiscaleSource.getSources(H(H({}, e), { discreteValues: true }));
  }
  defineShader(e, t) {
    this.hashTableManager.defineShader(e);
    let n = `
uint64_t getUint64DataValue() {
  uint64_t x = toUint64(getDataValue());
`;
    n += `return x;
}
`, e.addFragmentCode(n), t.hasEquivalences ? (this.equivalencesShaderManager.defineShader(e), e.addFragmentCode(`
uint64_t getMappedObjectId(uint64_t value) {
  uint64_t mappedValue;
  if (${this.equivalencesShaderManager.getFunctionName}(value, mappedValue)) {
    return mappedValue;
  }
  return value;
}
`)) : e.addFragmentCode(`
uint64_t getMappedObjectId(uint64_t value) {
  return value;
}
`), e.addUniform("highp uvec2", "uSelectedSegment"), e.addUniform("highp uint", "uShowAllSegments"), e.addUniform("highp float", "uSelectedAlpha"), e.addUniform("highp float", "uNotSelectedAlpha"), e.addUniform("highp float", "uSaturation");
    let r = `
  uint64_t baseValue = getUint64DataValue();
  uint64_t value = getMappedObjectId(baseValue);
  uint64_t valueForColor = ${t.baseSegmentColoring ? "baseValue" : "value"};

  float alpha = uSelectedAlpha;
  float saturation = uSaturation;
`;
    t.hideSegmentZero && (r += `
  if (value.value[0] == 0u && value.value[1] == 0u) {
    emit(vec4(vec4(0, 0, 0, 0)));
    return;
  }
`), r += `
  bool has = uShowAllSegments != 0u ? true : ${this.hashTableManager.hasFunctionName}(value);
  if (uSelectedSegment == value.value) {
    float adjustment = has ? 0.5 : 0.75;
    if (saturation > adjustment) {
      saturation -= adjustment;
    } else {
      saturation += adjustment;
    }
  } else if (!has) {
    alpha = uNotSelectedAlpha;
  }
`;
    let s = `vec3 getMappedIdColor(uint64_t value) {
`;
    t.hasSegmentStatedColors && (this.segmentStatedColorShaderManager.defineShader(e), s += `
  vec3 rgb;
  if (${this.segmentStatedColorShaderManager.getFunctionName}(value, rgb)) {
    return rgb;
  }
`), t.hasSegmentDefaultColor ? (e.addUniform("highp vec3", "uSegmentDefaultColor"), s += `  return uSegmentDefaultColor;
`) : (this.segmentColorShaderManager.defineShader(e), s += `  return segmentColorHash(value);
`), s += `
}
`, e.addFragmentCode(s), r += `
  vec3 rgb = getMappedIdColor(valueForColor);
  emit(vec4(mix(vec3(1.0,1.0,1.0), rgb, saturation), alpha));
`, e.setFragmentMain(r);
  }
  initializeShader(e, t, n) {
    const r = this.gl, s = this.displayState, a = this.segmentationGroupState, l = this.displayState.segmentSelectionState;
    var d = this.displayState;
    const u = d.segmentDefaultColor.value, h = d.segmentColorHash.value, g = yD2(a), v = this.displayState.ignoreNullVisibleSet.value;
    let y = 0, C = 0;
    if (l.hasSelectedSegment) {
      let w = l.selectedSegment;
      y = w.low, C = w.high;
    }
    if (r.uniform1f(t.uniform("uSelectedAlpha"), s.selectedAlpha.value), r.uniform1f(t.uniform("uSaturation"), s.saturation.value), r.uniform1f(t.uniform("uNotSelectedAlpha"), s.notSelectedAlpha.value), r.uniform2ui(t.uniform("uSelectedSegment"), y, C), r.uniform1ui(t.uniform("uShowAllSegments"), g.hashTable.size || !v ? 0 : 1), this.hashTableManager.enable(r, t, a.useTemporaryVisibleSegments.value ? this.gpuTemporaryHashTable : this.gpuHashTable), n.hasEquivalences) {
      const w = a.useTemporarySegmentEquivalences.value;
      (w ? this.temporaryEquivalencesHashMap : this.equivalencesHashMap).update(), this.equivalencesShaderManager.enable(r, t, w ? this.gpuTemporaryEquivalencesHashTable : this.gpuEquivalencesHashTable);
    }
    if (u === void 0 ? this.segmentColorShaderManager.enable(r, t, h) : r.uniform3fv(t.uniform("uSegmentDefaultColor"), u), n.hasSegmentStatedColors) {
      const w = this.displayState.segmentStatedColors.value;
      let b = this.gpuSegmentStatedColorHashTable;
      (b === void 0 || b.hashTable !== w.hashTable) && (b == null ? void 0 : b.dispose(), this.gpuSegmentStatedColorHashTable = b = Vl.get(r, w.hashTable)), this.segmentStatedColorShaderManager.enable(r, t, b);
    }
  }
  endSlice(e, t, n) {
    const r = this.gl;
    this.hashTableManager.disable(r, t), n.hasEquivalences && this.equivalencesShaderManager.disable(r, t), n.hasSegmentStatedColors && this.segmentStatedColorShaderManager.disable(r, t), super.endSlice(e, t, n);
  }
};
function Wl(i = 0.5) {
  return new fn(i, gy);
}
var AS = 12;
var BP = 8;
var eH = 6;
var tH = `
vec3 getBoxFaceVertexPosition(int vertexIndex) {
  const vec3 vertexPositions[] = vec3[](
  // Front face
  vec3(0.0, 0.0,  1.0), // 0
  vec3(1.0, 0.0,  1.0), // 1
  vec3(1.0,  1.0,  1.0), // 2
  vec3(0.0,  1.0,  1.0), // 3

  // Back face
  vec3(0.0, 0.0, 0.0), // 4
  vec3(0.0,  1.0, 0.0), // 5
  vec3(1.0,  1.0, 0.0), // 6
  vec3(1.0, 0.0, 0.0), // 7

  // Top face
  vec3(0.0,  1.0, 0.0), // 8
  vec3(0.0,  1.0,  1.0), // 9
  vec3(1.0,  1.0,  1.0), // 10
  vec3(1.0,  1.0, 0.0), // 11

  // Bottom face
  vec3(0.0, 0.0, 0.0), // 12
  vec3( 1.0, 0.0, 0.0), // 13
  vec3( 1.0, 0.0,  1.0), // 14
  vec3(0.0, 0.0,  1.0), // 15

  // Right face
  vec3( 1.0, 0.0, 0.0), // 16
  vec3( 1.0,  1.0, 0.0), // 17
  vec3( 1.0,  1.0,  1.0), // 18
  vec3( 1.0, 0.0,  1.0), // 19

  // Left face
  vec3(0.0, 0.0, 0.0), // 20
  vec3(0.0, 0.0,  1.0), // 21
  vec3(0.0,  1.0,  1.0), // 22
  vec3(0.0,  1.0, 0.0) // 23
  );
  const int indices[] = int[](
    0,  1,  2,      0,  2,  3,    // front
    4,  5,  6,      4,  6,  7,    // back
    8,  9,  10,     8,  10, 11,   // top
    12, 13, 14,     12, 14, 15,   // bottom
    16, 17, 18,     16, 18, 19,   // right
    20, 21, 22,     20, 22, 23   // left
  );
  return vertexPositions[indices[vertexIndex]];
}
`;
function nH(i, e, t) {
  i.drawArraysInstanced(WebGL2RenderingContext.TRIANGLES, 0, 6 * eH * e, t);
}
var FP = 0;
var Fu = FP + 1;
var Ln = Fu + BP;
var UP = Ln + AS;
var iH = UP + 6;
var rH = Float32Array.from([
  // a1
  0,
  0,
  0,
  // b1
  0,
  0,
  1,
  // c1
  Ln + 0,
  // a2
  1,
  0,
  0,
  // b2
  1,
  0,
  1,
  // c2
  Ln + 1,
  // a3
  0,
  1,
  0,
  // b3
  0,
  1,
  1,
  // c3
  Ln + 2,
  // a4
  1,
  1,
  0,
  // b4
  1,
  1,
  1,
  // c4
  Ln + 3,
  // a5
  0,
  0,
  0,
  // b5
  0,
  1,
  0,
  // c5
  Ln + 4,
  // a6
  0,
  0,
  1,
  // b6
  0,
  1,
  1,
  // c6
  Ln + 5,
  // a7
  1,
  0,
  0,
  // b7
  1,
  1,
  0,
  // c7
  Ln + 6,
  // a8
  1,
  0,
  1,
  // b8
  1,
  1,
  1,
  // c8
  Ln + 7,
  // a9
  0,
  0,
  0,
  // b9
  1,
  0,
  0,
  // c9
  Ln + 8,
  // a10
  0,
  0,
  1,
  // b10
  1,
  0,
  1,
  // c10
  Ln + 9,
  // a11
  0,
  1,
  0,
  // b11
  1,
  1,
  0,
  // c11
  Ln + 10,
  // a12
  0,
  1,
  1,
  // b12
  1,
  1,
  1,
  // c12
  Ln + 11
]);
var ZE = nt();
var cs = new Float32Array(6);
var zP = class extends Ic {
  constructor() {
    super(...arguments), this.vertexIdHelper = this.registerDisposer(fr.get(this.gl));
  }
  defineShader(e) {
    Ur(e);
    const t = this.rank;
    Tc(
      e,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "Bounds",
      t,
      2
    ), e.addUniform("vec3", "uModelSpaceBoundOffsets", 2);
  }
  enable(e, t, n) {
    ys(ZE, t.modelViewProjectionMatrix), PN(ZE, cs);
    const r = t.chunkDisplayTransform.numChunkDisplayDims;
    for (let s = 0; s < r; ++s)
      cs[s] = 0, cs[s + 3] = 0;
    for (let s = r; s < 3; ++s) {
      const a = Math.abs(cs[s + 3] - cs[s]);
      cs[s] -= a, cs[s + 3] += a;
    }
    super.enable(e, t, (s) => {
      const a = s.vertexShaderInputBinders.Bounds;
      a.enable(1);
      const l = this.gl;
      l.uniform3fv(s.uniform("uModelSpaceBoundOffsets"), cs), l.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), a.bind(this.geometryDataStride, t.bufferOffset);
      const d = this.vertexIdHelper;
      d.enable(), n(s), d.disable(), a.disable();
    });
  }
};
function $P(i) {
  i.addVertexCode(`
void setBoundingBoxBorderWidth(float width) {}
void setBoundingBoxBorderColor(vec4 color) {}
`);
}
function GP(i) {
  i.addVertexCode(`
void setBoundingBoxFillColor(vec4 color) {}
`);
}
function wv(i) {
  GP(i), i.addVertexCode(`
float ng_lineWidth;
void setBoundingBoxBorderWidth(float size) {
  ng_lineWidth = size;
}
void setBoundingBoxBorderColor(vec4 color) {
  vColor = color;
}
`);
}
function sH(i) {
  $P(i), i.addVertexCode(`
void setBoundingBoxFillColor(vec4 color) {
  vColor = color;
}
`);
}
var aH = class extends zP {
  constructor() {
    super(...arguments), this.edgeBoxCornerOffsetsBuffer = this.registerDisposer(Qn.fromData(this.gl, ym(
      rH,
      /*majorDimension=*/
      7,
      /*minorTiles=*/
      1,
      /*majorTiles=*/
      gs
    ))), this.edgeShaderGetter = this.getDependentShader("annotation/boundingBox/projection/border", (e) => {
      const t = this.rank;
      this.defineShader(e), dr(e), e.addAttribute("highp vec3", "aBoxCornerOffset1"), e.addAttribute("highp vec4", "aBoxCornerOffset2"), e.addVarying("highp float", "vClipCoefficient"), wv(e), e.setVertexMain(`
float modelPositionA[${t}] = getBounds0();
float modelPositionB[${t}] = getBounds1();
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
vec3 endpointA = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset1);
vec3 endpointB = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset2.xyz);
vClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
ng_lineWidth = 1.0;
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(endpointA, 1.0),
         uModelViewProjection * vec4(endpointB, 1.0),
         ng_lineWidth);
${this.setPartIndex(e, "uint(aBoxCornerOffset2.w)")};
`), e.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, getLineAlpha() * vClipCoefficient));
`);
    }), this.boxCornerOffsetsBuffer = this.registerDisposer(Qn.fromData(this.gl, ym(
      OP,
      /*majorDimension=*/
      3,
      /*minorTiles=*/
      1,
      /*majorTiles=*/
      pS
    ))), this.cornerShaderGetter = this.getDependentShader("annotation/boundingBox/projection/corner", (e) => {
      const t = this.rank;
      this.defineShader(e), Bc(e, this.targetIsSliceView), e.addAttribute("highp vec3", "aBoxCornerOffset"), e.addVarying("highp float", "vClipCoefficient"), wv(e), e.setVertexMain(`
float modelPositionA[${t}] = getBounds0();
float modelPositionB[${t}] = getBounds1();
vClipCoefficient = getMaxEndpointSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
vec3 vertexPosition = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset);
emitCircle(uModelViewProjection * vec4(vertexPosition, 1.0), ng_lineWidth, 0.0);
uint cornerIndex = uint(aBoxCornerOffset.x + aBoxCornerOffset.y * 2.0 + aBoxCornerOffset.z * 4.0);
uint cornerPickOffset = ${Fu}u + cornerIndex;
${this.setPartIndex(e, "cornerPickOffset")};
`), e.setFragmentMain(`
vec4 borderColor = vec4(0.0, 0.0, 0.0, 1.0);
vec4 color = getCircleColor(vColor, borderColor);
color.a *= vClipCoefficient;
emitAnnotation(color);
`);
    });
  }
  drawEdges(e) {
    const t = this.gl;
    this.enable(this.edgeShaderGetter, e, (n) => {
      const r = n.attribute("aBoxCornerOffset1"), s = n.attribute("aBoxCornerOffset2");
      this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(
        r,
        /*components=*/
        3,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT,
        /*normalized=*/
        false,
        /*stride=*/
        4 * 7,
        /*offset=*/
        0
      ), this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(
        s,
        /*components=*/
        4,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT,
        /*normalized=*/
        false,
        /*stride=*/
        4 * 7,
        /*offset=*/
        4 * 3
      ), hr(
        n,
        e.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      ), ur(t, AS, e.count), t.disableVertexAttribArray(r), t.disableVertexAttribArray(s);
    });
  }
  drawCorners(e) {
    const t = this.gl;
    this.enable(this.cornerShaderGetter, e, (n) => {
      const r = n.attribute("aBoxCornerOffset");
      this.boxCornerOffsetsBuffer.bindToVertexAttrib(
        r,
        /*components=*/
        3,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT,
        /*normalized=*/
        false
      ), Fc(n, e.renderContext.projectionParameters, { featherWidthInPixels: 0 }), Uc(n.gl, BP, e.count), t.disableVertexAttribArray(r);
    });
  }
  draw(e) {
    this.drawEdges(e), this.drawCorners(e);
  }
};
var oH = class extends zP {
  constructor() {
    super(...arguments), this.faceShaderGetter = this.getDependentShader("annotation/boundingBox/crossSection/face", (e) => {
      const t = this.rank;
      super.defineShader(e), Bu(e), dr(e), e.addVarying("highp float", "vClipCoefficient"), wv(e), e.setVertexMain(`
float modelPositionA[${t}] = getBounds0();
float modelPositionB[${t}] = getBounds1();
for (int i = 0; i < ${t}; ++i) {
  float a = modelPositionA[i];
  float b = modelPositionB[i];
  modelPositionA[i] = min(a, b);
  modelPositionB[i] = max(a, b);
}
vClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
int vertexIndex1 = gl_VertexID / ${gs};
int vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;
vec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex1);
vec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex2);
ng_lineWidth = 1.0;
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(vertexPosition1, 1.0),
         uModelViewProjection * vec4(vertexPosition2, 1.0),
         ng_lineWidth);
${this.setPartIndex(e)};
`), e.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() * vClipCoefficient));
`);
    }), this.fillShaderGetter = this.getDependentShader("annotation/boundingBox/crossSection/fill", (e) => {
      const t = this.rank;
      super.defineShader(e), Bu(e), e.addVarying("highp float", "vClipCoefficient"), sH(e), e.setVertexMain(`
float modelPositionA[${t}] = getBounds0();
float modelPositionB[${t}] = getBounds1();
for (int i = 0; i < ${t}; ++i) {
  float a = modelPositionA[i];
  float b = modelPositionB[i];
  modelPositionA[i] = min(a, b);
  modelPositionB[i] = max(a, b);
}
vClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
int vertexIndex = gl_VertexID;
vec3 vertexPosition = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex);
gl_Position = uModelViewProjection * vec4(vertexPosition, 1);
${this.invokeUserMain}
${this.setPartIndex(e)};
`), e.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, vColor.a * vClipCoefficient));
`);
    });
  }
  enableForBoundingBox(e, t, n) {
    super.enable(e, t, (r) => {
      const s = t.renderContext.sliceView.projectionParameters.value;
      RS(r, s.viewportNormalInGlobalCoordinates, s.centerDataPosition, t.renderSubspaceModelMatrix, t.renderSubspaceInvModelMatrix), n(r);
    });
  }
  draw(e) {
    this.shaderControlState.parseResult.value.code.match(/\bsetBoundingBoxFillColor\b/) && this.enableForBoundingBox(this.fillShaderGetter, e, () => {
      mB(this.gl, WebGL2RenderingContext.TRIANGLE_FAN, 0, 6, e.count);
    }), this.enableForBoundingBox(this.faceShaderGetter, e, (t) => {
      hr(
        t,
        e.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      ), ur(t.gl, 6, e.count);
    });
  }
};
function lH(i, e) {
  const t = i.length;
  for (let n = 0; n < t; ++n) {
    const r = e[n], s = e[n + t], a = i[n];
    i[n] = Math.abs(r - a) < Math.abs(s - a) ? r : s;
  }
}
Pc(Fe.AXIS_ALIGNED_BOUNDING_BOX, {
  sliceViewRenderHelper: oH,
  perspectiveViewRenderHelper: aH,
  defineShaderNoOpSetters(i) {
    GP(i), $P(i);
  },
  pickIdsPerInstance: iH,
  snapPosition(i, e, t, n) {
    const r = i.length, s = new Float32Array(e, t, r * 2);
    n >= Fu && n < Ln && lH(i, s);
  },
  getRepresentativePoint(i, e, t) {
    t === FP || t >= Fu && t < Ln || t >= Ln && t < UP, i.set(e.pointA);
  },
  updateViaRepresentativePoint(i, e, t) {
    const n = e.length, r = i.pointA, s = i.pointB, a = new Float32Array(n), l = new Float32Array(n);
    for (let d = 0; d < n; ++d) {
      const u = a[d] = e[d];
      l[d] = s[d] + (u - r[d]);
    }
    return H(H({}, i), { pointA: a, pointB: l });
  }
});
var Qa = 0;
var Cv = Qa + 1;
var cH = Cv + 2;
function WP2(i) {
  i.addVertexCode(`
void setEndpointMarkerSize(float startSize, float endSize) {}
void setEndpointMarkerBorderWidth(float startSize, float endSize) {}
void setEndpointMarkerColor(vec4 startColor, vec4 endColor) {}
void setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {}
`);
}
function HP(i) {
  i.addVertexCode(`
void setLineWidth(float width) {}
void setLineColor(vec4 startColor, vec4 endColor) {}
`);
}
var QE = class extends Ic {
  constructor() {
    super(...arguments), this.vertexIdHelper = this.registerDisposer(fr.get(this.gl)), this.edgeShaderGetter = this.getDependentShader("annotation/line/edge", (e) => {
      const t = this.rank;
      this.defineShader(e), dr(e), e.addVarying(`highp float[${t}]`, "vModelPosition"), e.addVertexCode(`
float ng_LineWidth;
`), WP2(e), e.addVertexCode(`
void setLineWidth(float width) {
  ng_LineWidth = width;
}
void setLineColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, getLineEndpointCoefficient());
}
`), e.setVertexMain(`
float modelPositionA[${t}] = getVertexPosition0();
float modelPositionB[${t}] = getVertexPosition1();
for (int i = 0; i < ${t}; ++i) {
  vModelPosition[i] = mix(modelPositionA[i], modelPositionB[i], getLineEndpointCoefficient());
}
ng_LineWidth = 1.0;
vColor = vec4(0.0, 0.0, 0.0, 0.0);
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionA), 1.0),
         uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionB), 1.0),
         ng_LineWidth);
${this.setPartIndex(e)};
`), e.setFragmentMain(`
float clipCoefficient = getSubspaceClipCoefficient(vModelPosition);
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() *
                                ${this.getCrossSectionFadeFactor()} *
                                clipCoefficient));
`);
    }), this.endpointShaderGetter = this.getDependentShader("annotation/line/endpoint", (e) => {
      const t = this.rank;
      this.defineShader(e), Bc(e, this.targetIsSliceView), e.addVarying("highp float", "vClipCoefficient"), e.addVarying("highp vec4", "vBorderColor"), HP(e), e.addVertexCode(`
float ng_markerDiameter;
float ng_markerBorderWidth;
int getEndpointIndex() {
  return gl_VertexID / ${pS};
}
void setEndpointMarkerSize(float startSize, float endSize) {
  ng_markerDiameter = mix(startSize, endSize, float(getEndpointIndex()));
}
void setEndpointMarkerBorderWidth(float startSize, float endSize) {
  ng_markerBorderWidth = mix(startSize, endSize, float(getEndpointIndex()));
}
void setEndpointMarkerColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, float(getEndpointIndex()));
}
void setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {
  vBorderColor = mix(startColor, endColor, float(getEndpointIndex()));
}
`), e.setVertexMain(`
float modelPosition[${t}] = getVertexPosition0();
float modelPositionB[${t}] = getVertexPosition1();
for (int i = 0; i < ${t}; ++i) {
  modelPosition[i] = mix(modelPosition[i], modelPositionB[i], float(getEndpointIndex()));
}
vClipCoefficient = getSubspaceClipCoefficient(modelPosition);
vColor = vec4(0.0, 0.0, 0.0, 0.0);
vBorderColor = vec4(0.0, 0.0, 0.0, 1.0);
ng_markerDiameter = 5.0;
ng_markerBorderWidth = 1.0;
${this.invokeUserMain}
emitCircle(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);
${this.setPartIndex(e, "uint(getEndpointIndex()) + 1u")};
`), e.setFragmentMain(`
vec4 color = getCircleColor(vColor, vBorderColor);
color.a *= vClipCoefficient;
emitAnnotation(color);
`);
    });
  }
  defineShader(e) {
    Ur(e);
    const t = this.rank;
    Tc(
      e,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "VertexPosition",
      t,
      2
    );
  }
  enable(e, t, n) {
    super.enable(e, t, (r) => {
      const s = r.vertexShaderInputBinders.VertexPosition;
      s.enable(1), this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), s.bind(this.geometryDataStride, t.bufferOffset);
      const a = this.vertexIdHelper;
      a.enable(), n(r), a.disable(), s.disable();
    });
  }
  drawEdges(e) {
    this.enable(this.edgeShaderGetter, e, (t) => {
      hr(
        t,
        e.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      ), ur(t.gl, 1, e.count);
    });
  }
  drawEndpoints(e) {
    this.enable(this.endpointShaderGetter, e, (t) => {
      Fc(t, e.renderContext.projectionParameters, { featherWidthInPixels: 0.5 }), Uc(t.gl, 2, e.count);
    });
  }
  draw(e) {
    this.drawEdges(e), this.drawEndpoints(e);
  }
};
function dH(i, e) {
  const t = i.length;
  IT(i, e.subarray(0, t), e.subarray(t), i);
}
function uH(i, e, t) {
  const n = i.length, r = n * t;
  for (let s = 0; s < n; ++s)
    i[s] = e[r + s];
}
Pc(Fe.LINE, {
  sliceViewRenderHelper: QE,
  perspectiveViewRenderHelper: QE,
  defineShaderNoOpSetters(i) {
    WP2(i), HP(i);
  },
  pickIdsPerInstance: cH,
  snapPosition(i, e, t, n) {
    const r = i.length, s = new Float32Array(e, t, r * 2);
    n === Qa ? dH(i, s) : uH(i, s, n - Cv);
  },
  getRepresentativePoint(i, e, t) {
    i.set(t === Qa || t === Cv ? e.pointA : e.pointB);
  },
  updateViaRepresentativePoint(i, e, t) {
    let n = H({}, i);
    const r = e.length;
    switch (t) {
      case Qa: {
        const s = i.pointA, a = i.pointB, l = new Float32Array(r), d = new Float32Array(r);
        for (let u = 0; u < r; ++u) {
          const h = l[u] = e[u];
          d[u] = a[u] + (h - s[u]);
        }
        return H(H({}, i), { pointA: l, pointB: d });
      }
      case Qa + 1:
        return H(H({}, i), { pointA: new Float32Array(e) });
      case Qa + 2:
        return H(H({}, i), { pointB: new Float32Array(e) });
    }
    return n;
  }
});
var ek = class extends Ic {
  constructor() {
    super(...arguments), this.shaderGetter3d = this.getDependentShader("annotation/point:3d", (e) => {
      Ur(e), Bc(
        e,
        /*crossSectionFade=*/
        this.targetIsSliceView
      ), this.defineShaderCommon(e), e.addVertexMain(`
emitCircle(uModelViewProjection *
           vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);
`), e.setFragmentMain(`
vec4 color = getCircleColor(vColor, vBorderColor);
emitAnnotation(color);
`);
    }), this.makeShaderGetter2d = (e) => this.getDependentShader(`annotation/point:2d:${e}`, (t) => {
      Ur(t), dr(
        t,
        /*rounded=*/
        true
      ), this.defineShaderCommon(t), t.addVertexMain(`
vec3 subspacePositionA = projectModelVectorToSubspace(modelPosition);
vec3 subspacePositionB = subspacePositionA;
vec4 baseProjection = uModelViewProjection * vec4(subspacePositionA, 1.0);
vec4 zCoeffs = uModelViewProjection[${e}];
float minZ = 1e30;
float maxZ = -1e30;
for (int i = 0; i < 3; ++i) {
  // Want: baseProjection[i] + z * zCoeffs[i] = -2.0 * (baseProjection.w - z * zCoeffs.w)
  //  i.e. baseProjection[i] + 2.0 * baseProjection.w < -z * (2.0 * zCoeffs.w + zCoeffs[i])
  //  i.e. baseProjection[i] + 2.0 * baseProjection.w < -z * k1
  float k1 = 2.0 * zCoeffs.w + zCoeffs[i];
  float q1 = -(baseProjection[i] + 2.0 * baseProjection.w) / k1;
  if (k1 != 0.0) {
    minZ = min(minZ, q1);
    maxZ = max(maxZ, q1);
  }
  // Want: baseProjection[i] + z * zCoeffs[i] = 2.0 * (baseProjection.w + z * zCoeffs.w)
  //  i.e. baseProjection[i] - 2.0 * baseProjection.w > z * (2.0 * zCoeffs.w - zCoeffs[i])
  //  i.e. baseProjection[i] - 2.0 * baseProjection.w > z * k2
  float k2 = 2.0 * zCoeffs.w - zCoeffs[i];
  float q2 = (baseProjection[i] - 2.0 * baseProjection.w) / k2;
  if (k2 != 0.0) {
    minZ = min(minZ, q2);
    maxZ = max(maxZ, q2);
  }
}
if (minZ > maxZ) minZ = maxZ = 0.0;
subspacePositionA[${e}] = minZ;
subspacePositionB[${e}] = maxZ;
emitLine(uModelViewProjection, subspacePositionA, subspacePositionB, ng_markerDiameter, ng_markerBorderWidth);
`), t.setFragmentMain(`
vec4 color = getRoundedLineColor(vColor, vBorderColor);
emitAnnotation(vec4(color.rgb, color.a * ${this.getCrossSectionFadeFactor()}));
`);
    }), this.shaderGetter2d = this.makeShaderGetter2d(2), this.shaderGetter1d = this.makeShaderGetter2d(1), this.vertexIdHelper = this.registerDisposer(fr.get(this.gl));
  }
  defineShaderCommon(e) {
    const t = this.rank;
    Tc(
      e,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "VertexPosition",
      t
    ), e.addVarying("highp vec4", "vBorderColor"), e.addVertexCode(`
float ng_markerDiameter;
float ng_markerBorderWidth;
void setPointMarkerSize(float size) {
  ng_markerDiameter = size;
}
void setPointMarkerBorderWidth(float size) {
  ng_markerBorderWidth = size;
}
void setPointMarkerColor(vec4 color) {
  vColor = color;
}
void setPointMarkerBorderColor(vec4 color) {
  vBorderColor = color;
}
`), e.addVertexMain(`
ng_markerDiameter = 5.0;
ng_markerBorderWidth = 1.0;
vBorderColor = vec4(0.0, 0.0, 0.0, 1.0);
float modelPosition[${t}] = getVertexPosition0();
float clipCoefficient = getSubspaceClipCoefficient(modelPosition);
if (clipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
${this.invokeUserMain}
vColor.a *= clipCoefficient;
vBorderColor.a *= clipCoefficient;
${this.setPartIndex(e)};
`);
  }
  enable(e, t, n) {
    super.enable(e, t, (r) => {
      const s = r.vertexShaderInputBinders.VertexPosition;
      s.enable(1), this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), s.bind(this.geometryDataStride, t.bufferOffset);
      const a = this.vertexIdHelper;
      a.enable(), n(r), a.disable(), s.disable();
    });
  }
  draw(e) {
    const t = e.chunkDisplayTransform.numChunkDisplayDims;
    switch (t) {
      case 3:
        this.enable(this.shaderGetter3d, e, (n) => {
          Fc(n, e.renderContext.projectionParameters, { featherWidthInPixels: 1 }), Uc(n.gl, 1, e.count);
        });
        break;
      case 2:
      case 1:
        this.enable(t === 2 ? this.shaderGetter2d : this.shaderGetter1d, e, (n) => {
          hr(
            n,
            e.renderContext.projectionParameters,
            /*featherWidthInPixels=*/
            1
          ), ur(n.gl, 1, e.count);
        });
        break;
    }
  }
};
Pc(Fe.POINT, {
  sliceViewRenderHelper: ek,
  perspectiveViewRenderHelper: ek,
  defineShaderNoOpSetters(i) {
    i.addVertexCode(`
void setPointMarkerSize(float size) {}
void setPointMarkerBorderWidth(float size) {}
void setPointMarkerColor(vec4 color) {}
void setPointMarkerBorderColor(vec4 color) {}
`);
  },
  pickIdsPerInstance: 1,
  snapPosition(i, e, t) {
    i.set(new Float32Array(e, t, i.length));
  },
  getRepresentativePoint(i, e) {
    i.set(e.point);
  },
  updateViaRepresentativePoint(i, e) {
    return H(H({}, i), { point: new Float32Array(e) });
  }
});
var qP = `
struct EllipseQuadraticForm {
  highp float A;  // x*x coefficient
  highp float B;  // x*y coefficient
  highp float C;  // y*y coefficient
  highp float D;  // x coefficient
  highp float E;  // y coefficient
  highp float F;  // 1 coefficient
};
`;
var hH = [qP, `
EllipseQuadraticForm computeCrossSectionEllipse(mat3 A, vec3 c) {
  EllipseQuadraticForm p;
  p.A = A[0][0];
  p.B = A[0][1] + A[1][0];
  p.C = A[1][1];
  p.D = -2.0 * c[0] * A[0][0] - c[1] * (A[0][1] + A[1][0]) +
        c[2] * (A[0][2] + A[2][0]);
  p.E = -c[0] * (A[0][1] + A[1][0]) - 2.0 * c[1] * A[1][1] +
        c[2] * (A[1][2] + A[2][1]);
  p.F = c[0] * c[0] * A[0][0] + c[0] * c[1] * (A[0][1] + A[1][0]) -
        c[0] * c[2] * (A[0][2] + A[2][0]) + c[1] * c[1] * A[1][1] -
        c[1] * c[2] * (A[1][2] + A[2][1]) + c[2] * c[2] * A[2][2] - 1.0;
  return p;
}
`];
var fH = `
struct CenterOrientEllipse {
  vec2 k;   // center
  vec2 u1;  // minor axis direction
  vec2 u2;  // major axis direction
  float a;  // semimajor axis
  float b;  // semiminor axis
  bool valid; // indicates if the ellipse is valid
};
`;
var pH = [qP, fH, `
CenterOrientEllipse computeCenterOrientEllipse(EllipseQuadraticForm p) {
  CenterOrientEllipse r;
  float a11 = p.A;
  float a12 = p.B / 2.0;
  float a22 = p.C;
  float b1 = p.D;
  float b2 = p.E;
  float c = p.F;
  float kdenom = 2.0 * (a12 * a12 - a11 * a22);
  float k1 = r.k.x = (a22 * b1 - a12 * b2) / kdenom;
  float k2 = r.k.y = (a11 * b2 - a12 * b1) / kdenom;
  float mu = 1.0 / (a11 * k1 * k1 + 2.0 * a12 * k1 * k2 + a22 * k2 * k2 - c);
  float m11 = mu * a11;
  float m12 = mu * a12;
  float m22 = mu * a22;
  float lambdaTerm1 = m11 + m22;
  float lambdaTerm2 = sqrt((m11 - m22) * (m11 - m22) + 4.0 * m12 * m12);
  float lambda1 = ((lambdaTerm1 + lambdaTerm2) / 2.0);
  float lambda2 = ((lambdaTerm1 - lambdaTerm2) / 2.0);
  r.a = 1.0 / sqrt(lambda1);
  r.b = 1.0 / sqrt(lambda2);
  r.valid = lambda1 > 0.0 && lambda2 > 0.0;
  if (abs(m11 - m22) < 1e-6 && abs(m12) < 1e-6) {
    r.u1 = vec2(1.0, 0.0);
  } else if (m11 >= m22) {
    r.u1 = normalize(vec2(lambda1 - m22, m12));
  } else {
    r.u1 = normalize(vec2(m12, lambda1 - m11));
  }
  r.u2 = vec2(-r.u1.y, r.u1.x);
  return r;
}
`];
var tk = nt();
var jP = class extends Ic {
  defineShader(e) {
    const t = this.rank;
    Tc(
      e,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "CenterAndRadii",
      t,
      2
    ), e.addVertexCode(`
struct SubspaceParams {
  highp vec3 subspaceCenter;
  highp vec3 subspaceRadii;
  highp float clipCoefficient;
  bool cull;
};
SubspaceParams getSubspaceParams() {
  SubspaceParams params;
  highp float modelCenter[${t}] = getCenterAndRadii0();
  highp float modelRadii[${t}] = getCenterAndRadii1();
  float radiusAdjustment = 1.0;
  float clipCoefficient = 1.0;
  for (int i = 0; i < ${t}; ++i) {
    float r = modelRadii[i];
    float c = modelCenter[i];
    float x = uModelClipBounds[i];
    float clipRadius = uModelClipBounds[i + ${t}];
    if (r != 0.0 && clipRadius != 0.0) {
      float d = c - x;
      d = d * d;
      radiusAdjustment -= d / (r * r);
    }
    float e = abs(x - clamp(x, c - r, c + r)) * clipRadius;
    clipCoefficient *= max(0.0, 1.0 - e);
  }
  radiusAdjustment = sqrt(max(0.0, radiusAdjustment));
  params.subspaceCenter = projectModelVectorToSubspace(modelCenter);
  params.subspaceRadii = projectModelVectorToSubspace(modelRadii) * radiusAdjustment;
  params.clipCoefficient = clipCoefficient;
  params.cull = clipCoefficient == 0.0 || radiusAdjustment == 0.0;
  return params;
}
void setEllipsoidFillColor(vec4 color) {
  vColor = color;
}
`);
  }
  enable(e, t, n) {
    super.enable(e, t, (r) => {
      const s = r.vertexShaderInputBinders.CenterAndRadii;
      s.enable(1), this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), s.bind(this.geometryDataStride, t.bufferOffset), n(r), s.disable();
    });
  }
};
var gH = class extends jP {
  constructor() {
    super(...arguments), this.sphereRenderHelper = this.registerDisposer(new SI(this.gl, 10, 10)), this.shaderGetter = this.getDependentShader("annotation/ellipsoid/projection", (e) => {
      this.defineShader(e), this.sphereRenderHelper.defineShader(e), e.addUniform("highp vec4", "uLightDirection"), e.addUniform("highp mat4", "uNormalTransform"), e.addVarying("highp float", "vClipCoefficient"), e.setVertexMain(`
SubspaceParams params = getSubspaceParams();
if (params.cull) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vClipCoefficient = params.clipCoefficient;
${this.invokeUserMain}
emitSphere(uModelViewProjection, uNormalTransform, params.subspaceCenter, params.subspaceRadii, uLightDirection);
${this.setPartIndex(e)};
`), e.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb * vLightingFactor, vColor.a * vClipCoefficient));
`);
    }), this.tempLightVec = new Float32Array(4);
  }
  draw(e) {
    this.enable(this.shaderGetter, e, (t) => {
      const n = t.gl;
      let r = this.tempLightVec;
      var s = e.renderContext;
      let a = s.lightDirection, l = s.ambientLighting, d = s.directionalLighting;
      dy(r, a, d), r[3] = l, n.uniform4fv(t.uniform("uLightDirection"), r), n.uniformMatrix4fv(
        t.uniform("uNormalTransform"),
        /*transpose=*/
        false,
        cy(nt(), e.renderSubspaceInvModelMatrix)
      ), this.sphereRenderHelper.draw(t, e.count);
    });
  }
};
var mH = class extends jP {
  constructor() {
    super(...arguments), this.shaderGetter = this.getDependentShader("annotation/ellipsoid/crossSection", (e) => {
      Ur(e), this.defineShader(e), e.addUniform("highp mat4", "uViewportToObject"), e.addUniform("highp mat4", "uObjectToViewport"), e.addUniform("highp mat4", "uViewportToDevice"), e.addAttribute("highp vec2", "aCornerOffset"), e.addVarying("highp vec2", "vCircleCoord"), e.addVarying("highp float", "vClipCoefficient"), e.addVertexCode(hH), e.addVertexCode(pH), e.addVertexCode(hS), e.setVertexMain(`
SubspaceParams params = getSubspaceParams();
if (params.cull) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vClipCoefficient = params.clipCoefficient;
mat3 Aobject = mat3(0.0);
for (int i = 0; i < 3; ++i) {
  float r = max(params.subspaceRadii[i], 1e-3);
  Aobject[i][i] = 1.0 / (r * r);
}
mat3 RviewportToObject = mat3(uViewportToObject);
mat3 Aviewport = transpose(RviewportToObject) * Aobject * RviewportToObject;
vec3 cViewport = (uObjectToViewport * vec4(params.subspaceCenter, 1.0)).xyz;
EllipseQuadraticForm quadraticForm = computeCrossSectionEllipse(Aviewport, cViewport);
vec2 u1, u2;
float a, b;
CenterOrientEllipse centerOrient = computeCenterOrientEllipse(quadraticForm);
vec2 cornerOffset = getQuadVertexPosition(vec2(-1.0, -1.0), vec2(1.0, 1.0));
vec2 viewportCorner = centerOrient.k +
  centerOrient.u1 * cornerOffset.x * centerOrient.a +
  centerOrient.u2 * cornerOffset.y * centerOrient.b;
if (centerOrient.valid) {
  gl_Position = uViewportToDevice * vec4(viewportCorner, 0.0, 1.0);
} else {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
}
vCircleCoord = cornerOffset;
${this.invokeUserMain}
${this.setPartIndex(e)};
`), e.setFragmentMain(`
if (dot(vCircleCoord, vCircleCoord) > 1.0) {
  discard;
}
emitAnnotation(vec4(vColor.rgb, vColor.a * vClipCoefficient));
`);
    }), this.vertexIdHelper = this.registerDisposer(fr.get(this.gl));
  }
  draw(e) {
    this.enable(this.shaderGetter, e, (t) => {
      const n = t.gl, r = e.renderContext.sliceView.projectionParameters.value, s = vn(tk, e.renderSubspaceInvModelMatrix, r.invViewMatrix);
      n.uniformMatrix4fv(
        t.uniform("uViewportToObject"),
        /*transpose=*/
        false,
        s
      ), n.uniformMatrix4fv(
        t.uniform("uViewportToDevice"),
        /*transpose=*/
        false,
        r.projectionMat
      );
      const a = tk;
      ys(a, s), n.uniformMatrix4fv(
        t.uniform("uObjectToViewport"),
        /*transpose=*/
        false,
        a
      );
      const l = this.vertexIdHelper;
      l.enable(), fS(n, 1, e.count), l.disable();
    });
  }
};
Pc(Fe.ELLIPSOID, {
  sliceViewRenderHelper: mH,
  perspectiveViewRenderHelper: gH,
  defineShaderNoOpSetters(i) {
    i.addVertexCode(`
void setEllipsoidFillColor(vec4 color) {}
`);
  },
  pickIdsPerInstance: 1,
  snapPosition: () => {
  },
  getRepresentativePoint(i, e) {
    i.set(e.center);
  },
  updateViaRepresentativePoint(i, e) {
    return H(H({}, i), { center: new Float32Array(e) });
  }
});
var eo = 0;
var xv = eo + 1;
var vH = xv + 2;
function Ev(i) {
  i.addVertexCode(`
 void setAxisEndpointMarkerSize(float startSize, float endSize) {}
 void setAxisEndpointMarkerBorderWidth(float startSize, float endSize) {}
 void setAxisEndpointMarkerColor(vec4 startColor, vec4 endColor) {}
 void setAxisEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {}
 `);
}
function kv(i) {
  i.addVertexCode(`
 void setAxisWidth(float width) {}
 void setAxisColor(vec4 startColor, vec4 endColor) {}
 `);
}
function Tv(i) {
  i.addVertexCode(`
 void setSphereColor(vec4 color) {}
 `);
}
var nk = class extends Ic {
  constructor() {
    super(...arguments), this.sphereShader = this.registerDisposer(new dz(this.gl)), this.vertexIdHelper = this.registerDisposer(fr.get(this.gl)), this.edgeShaderGetter = this.getDependentShader("annotation/sphere/axis", (e) => {
      const t = this.rank;
      this.defineShader(e), dr(e), e.addVarying(`highp float[${t}]`, "vModelPosition"), e.addVertexCode(`
float ng_LineWidth;
`), Ev(e), Tv(e), e.addVertexCode(`
void setAxisWidth(float width) {
  ng_LineWidth = width;
}
void setAxisColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, getLineEndpointCoefficient());
}
`), e.setVertexMain(`
float modelPositionA[${t}] = getVertexPosition0();
float modelPositionB[${t}] = getVertexPosition1();
for (int i = 0; i < ${t}; ++i) {
  vModelPosition[i] = mix(modelPositionA[i], modelPositionB[i], getLineEndpointCoefficient());
}
ng_LineWidth = 1.0;
vColor = vec4(0.0, 0.0, 0.0, 0.0);
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionA), 1.0),
         uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionB), 1.0),
         ng_LineWidth);
${this.setPartIndex(e)};
`), e.setFragmentMain(`
float clipCoefficient = getSubspaceClipCoefficient(vModelPosition);
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() *
                                ${this.getCrossSectionFadeFactor()} *
                                clipCoefficient));
`);
    }), this.endpointShaderGetter = this.getDependentShader("annotation/sphere/endpoint", (e) => {
      const t = this.rank;
      this.defineShader(e), Bc(e, this.targetIsSliceView), e.addVarying("highp float", "vClipCoefficient"), e.addVarying("highp vec4", "vBorderColor"), kv(e), Tv(e), e.addVertexCode(`
float ng_markerDiameter;
float ng_markerBorderWidth;
int getEndpointIndex() {
  return gl_VertexID / ${pS};
}
void setAxisEndpointMarkerSize(float startSize, float endSize) {
  ng_markerDiameter = mix(startSize, endSize, float(getEndpointIndex()));
}
void setAxisEndpointMarkerBorderWidth(float startSize, float endSize) {
  ng_markerBorderWidth = mix(startSize, endSize, float(getEndpointIndex()));
}
void setAxisEndpointMarkerColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, float(getEndpointIndex()));
}
void setAxisEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {
  vBorderColor = mix(startColor, endColor, float(getEndpointIndex()));
}
`), e.setVertexMain(`
float modelPosition[${t}] = getVertexPosition0();
float modelPositionB[${t}] = getVertexPosition1();
for (int i = 0; i < ${t}; ++i) {
  modelPosition[i] = mix(modelPosition[i], modelPositionB[i], float(getEndpointIndex()));
}
vClipCoefficient = getSubspaceClipCoefficient(modelPosition);
vColor = vec4(0.0, 0.0, 0.0, 0.0);
vBorderColor = vec4(0.0, 0.0, 0.0, 1.0);
ng_markerDiameter = 5.0;
ng_markerBorderWidth = 1.0;
${this.invokeUserMain}
emitCircle(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);
${this.setPartIndex(e, "uint(getEndpointIndex()) + 1u")};
`), e.setFragmentMain(`
vec4 color = getCircleColor(vColor, vBorderColor);
color.a *= vClipCoefficient;
emitAnnotation(color);
`);
    }), this.sphereShadeGetter = this.getDependentShader("annotation/sphere/sphere", (e) => {
      const t = this.rank;
      this.defineShader(e), this.sphereShader.defineShader(e), e.addVarying("highp float", "vClipCoefficient"), kv(e), Ev(e), e.addVertexCode(`
 void setSphereColor(vec4 color) {
   vColor = color;
 }
 `), e.setVertexMain(`
 float modelPosition[${t}] = getVertexPosition0();
 float modelPositionB[${t}] = getVertexPosition1();
 float diameter = 0.0;
 for (int i = 0; i < ${t}; ++i) {
   float dx = modelPosition[i] - modelPositionB[i];
   diameter += dx * dx;
   modelPosition[i] = (modelPosition[i] + modelPositionB[i]) * 0.5;
 }
 float radius = sqrt(diameter) * 0.5;
 if (radius > 0.0) {
   vClipCoefficient = getRadiusAdjustment(vec3(modelPosition[0], modelPosition[1], modelPosition[2]), radius);
 } else {
   vClipCoefficient = 1.0;
 }

 // vClipCoefficient = getSubspaceClipCoefficient(modelPosition);
 vColor = vec4(1.0, 0.0, 0.0, 0.5);
 // vColor = vec4(defaultColor(), 0.5);
 ${this.invokeUserMain}
 // float radius = diameter * 0.5;
 emitSphere(uModelViewProjection, uNormalTransform, projectModelVectorToSubspace(modelPosition), vec3(radius, radius, radius), uLightDirection);
 ${this.setPartIndex(e)};
 `), e.setFragmentMain(`
     vec4 color = vColor;
     color.a *= vClipCoefficient;
     emitAnnotation(color);
 `);
    });
  }
  defineShader(e) {
    Ur(e);
    const t = this.rank;
    Tc(
      e,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "VertexPosition",
      t,
      2
    );
  }
  enable(e, t, n, r = true) {
    super.enable(e, t, (s) => {
      const a = s.vertexShaderInputBinders.VertexPosition;
      a.enable(1), this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), a.bind(this.serializedBytesPerAnnotation, t.bufferOffset);
      const l = this.vertexIdHelper;
      r && l.enable(), n(s), r && l.disable(), a.disable();
    });
  }
  drawEdges(e) {
    this.enable(this.edgeShaderGetter, e, (t) => {
      hr(
        t,
        e.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      ), ur(t.gl, 1, e.count);
    });
  }
  drawEndpoints(e) {
    this.enable(this.endpointShaderGetter, e, (t) => {
      Fc(t, e.renderContext.projectionParameters, { featherWidthInPixels: 0.5 }), Uc(t.gl, 2, e.count);
    });
  }
  drawSphere(e) {
    this.enable(this.sphereShadeGetter, e, (t) => {
      this.sphereShader.draw(t, e, e.count);
    }, false);
  }
  draw(e) {
    this.drawEdges(e), this.drawEndpoints(e), this.drawSphere(e);
  }
};
function yH(i, e) {
  const t = i.length;
  IT(i, e.subarray(0, t), e.subarray(t), i);
}
function SH(i, e, t) {
  const n = i.length, r = n * t;
  for (let s = 0; s < n; ++s)
    i[s] = e[r + s];
}
Pc(Fe.SPHERE, {
  sliceViewRenderHelper: nk,
  perspectiveViewRenderHelper: nk,
  defineShaderNoOpSetters(i) {
    Ev(i), kv(i), Tv(i);
  },
  pickIdsPerInstance: vH,
  snapPosition(i, e, t, n) {
    const r = i.length, s = new Float32Array(e, t, r * 2);
    n === eo ? yH(i, s) : SH(i, s, n - xv);
  },
  getRepresentativePoint(i, e, t) {
    i.set(t === eo || t === xv ? e.pointA : e.pointB);
  },
  updateViaRepresentativePoint(i, e, t) {
    let n = H({}, i);
    const r = e.length;
    switch (t) {
      case eo: {
        const s = i.pointA, a = i.pointB, l = new Float32Array(r), d = new Float32Array(r);
        for (let u = 0; u < r; ++u) {
          const h = l[u] = e[u];
          d[u] = a[u] + (h - s[u]);
        }
        return H(H({}, i), { pointA: l, pointB: d });
      }
      case eo + 1:
        return H(H({}, i), { pointA: new Float32Array(e) });
      case eo + 2:
        return H(H({}, i), { pointB: new Float32Array(e) });
    }
    return n;
  }
});
var JP = nt();
var KP = ze();
function YP(i) {
  i.addUniform("highp vec3", "uTranslation"), i.addUniform("highp mat4", "uProjectionMatrix"), i.addUniform("highp vec3", "uChunkDataSize"), i.addUniform("highp vec3", "uLowerClipBound"), i.addUniform("highp vec3", "uUpperClipBound"), i.setFragmentMain(`
emit(vec4(1.0, 1.0, 1.0, getLineAlpha()), 0u);
`);
}
var bH = {
  defineShader(i) {
    YP(i), dr(i), i.addVertexCode(`
const vec3[24] boxCornerOffsets = vec3[](
  vec3(0, 0, 0), vec3(0, 0, 1),  // e1
  vec3(1, 0, 0), vec3(1, 0, 1),  // e2
  vec3(0, 1, 0), vec3(0, 1, 1),  // e3
  vec3(1, 1, 0), vec3(1, 1, 1),  // e4
  vec3(0, 0, 0), vec3(0, 1, 0),  // e5
  vec3(0, 0, 1), vec3(0, 1, 1),  // e6
  vec3(1, 0, 0), vec3(1, 1, 0),  // e7
  vec3(1, 0, 1), vec3(1, 1, 1),  // e8
  vec3(0, 0, 0), vec3(1, 0, 0),  // e9
  vec3(0, 0, 1), vec3(1, 0, 1),  // e10
  vec3(0, 1, 0), vec3(1, 1, 0),  // e11
  vec3(0, 1, 1), vec3(1, 1, 1)  // e12
);
`), i.setVertexMain(`
int edgeIndex = gl_VertexID / ${gs};
vec3 cornerA = max(uLowerClipBound, min(uUpperClipBound, uTranslation));
vec3 cornerB = max(uLowerClipBound, min(uUpperClipBound, uTranslation + uChunkDataSize));
vec3 vertexPosition1 = mix(cornerA, cornerB, boxCornerOffsets[edgeIndex * 2]);
vec3 vertexPosition2 = mix(cornerA, cornerB, boxCornerOffsets[edgeIndex * 2 + 1]);
emitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),
         uProjectionMatrix * vec4(vertexPosition2, 1.0),
         2.0);
`);
  },
  initialize(i, e) {
    hr(
      i,
      e,
      /*featherWidthInPixels=*/
      1
    );
  },
  draw(i, e, t) {
    const n = i.gl, r = JP, s = e.chunkLayout;
    vn(r, t.viewProjectionMat, s.transform), n.uniformMatrix4fv(
      i.uniform("uProjectionMatrix"),
      /*transpose=*/
      false,
      r
    ), n.uniform3fv(i.uniform("uChunkDataSize"), s.size), n.uniform3fv(i.uniform("uLowerClipBound"), e.lowerClipDisplayBound), n.uniform3fv(i.uniform("uUpperClipBound"), e.upperClipDisplayBound);
    const a = s.size, l = e.curPositionInChunks, d = e.chunkDisplayDimensionIndices, u = KP;
    for (let h = 0; h < 3; ++h) {
      const g = d[h];
      u[h] = (g === -1 ? 0 : l[g]) * a[h];
    }
    n.uniform3fv(i.uniform("uTranslation"), u), ur(n, AS, 1);
  }
};
var wH = {
  defineShader(i) {
    Bu(i), YP(i), dr(i), i.setVertexMain(`
int vertexIndex1 = gl_VertexID / ${gs};
int vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;
vec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex1);
vec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex2);
emitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),
         uProjectionMatrix * vec4(vertexPosition2, 1.0),
         2.0);
`);
  },
  initialize(i, e) {
    hr(
      i,
      e,
      /*featherWidthInPixels=*/
      1
    );
  },
  draw(i, e, t) {
    const n = i.gl, r = JP, s = e.chunkLayout;
    vn(r, t.viewProjectionMat, s.transform), n.uniformMatrix4fv(
      i.uniform("uProjectionMatrix"),
      /*transpose=*/
      false,
      r
    ), n.uniform3fv(i.uniform("uChunkDataSize"), s.size), n.uniform3fv(i.uniform("uLowerClipBound"), e.lowerClipDisplayBound), n.uniform3fv(i.uniform("uUpperClipBound"), e.upperClipDisplayBound);
    const a = s.size, l = e.curPositionInChunks, d = e.chunkDisplayDimensionIndices, u = KP;
    for (let h = 0; h < 3; ++h) {
      const g = d[h];
      u[h] = (g === -1 ? 0 : l[g]) * a[h];
    }
    n.uniform3fv(i.uniform("uTranslation"), u), RS(i, t.viewportNormalInGlobalCoordinates, t.centerDataPosition, s.transform, s.invTransform), ur(n, 6, 1);
  }
};
var CH = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
var xH = nt();
function EH(i) {
  if (i !== void 0)
    return (e) => {
      const t = e.relatedSegments;
      if (t === void 0)
        return false;
      for (let r = 0, s = t.length; r < s; ++r) {
        const a = i[r];
        if (a == null) continue;
        var n = a.segmentationGroupState.value;
        const l = n.visibleSegments, d = n.segmentEquivalences;
        for (const u of t[r])
          if (l.has(d.get(u)))
            return true;
      }
      return false;
    };
}
function kH(i, e) {
  const t = new NO(i.annotationPropertySerializers);
  for (const n of i)
    (e === void 0 || e(n)) && t.add(n);
  return t.serialize();
}
var Lv = class extends mh(Rc) {
  constructor(e, t, n, r) {
    super(r), this.chunkManager = e, this.source = t, this.segmentationStates = n, this.initializeCounterpart(this.chunkManager.rpc, {
      chunkManager: this.chunkManager.rpcId,
      source: t.rpcId,
      segmentationStates: this.serializeDisplayState()
    });
    const s = () => {
      const a = { id: this.rpcId, segmentationStates: this.serializeDisplayState() };
      this.rpc.invoke(NF, a);
    };
    this.registerDisposer(n.changed.add(s));
  }
  serializeDisplayState() {
    const e = this.segmentationStates.value;
    if (e !== void 0)
      return e.map((t) => t == null ? t : dS(t.segmentationGroupState.value));
  }
};
Lv = CH([ki(MF)], Lv);
var TH = class extends X {
  constructor(e, t) {
    super(), this.chunkManager = e, this.state = t, this.layerChunkProgressInfo = new Iy(), this.numPickIds = 0, this.generation = -1, this.redrawNeeded = new Le(), this.serializedAnnotations = void 0, this.handleChangeAffectingBuffer = () => {
      this.generation = -1, this.redrawNeeded.dispatch();
    }, this.segmentationStates = this.registerDisposer(wi((r) => {
      var s = this.state;
      const a = s.displayState, l = s.source, d = a.relationshipStates;
      return a.displayUnfiltered.value ? void 0 : l.relationships.map((u) => {
        const h = d.get(u);
        return h.showMatches.value ? h.segmentationState.value : void 0;
      });
    }, [this.state.displayState.relationshipStates], (r, s) => r === void 0 || s === void 0 ? r === s : He(r, s))), this.registerDisposer(t), this.registerDisposer(this.source.changed.add(this.handleChangeAffectingBuffer)), this.registerDisposer(Or((r, s) => {
      if (this.handleChangeAffectingBuffer(), s !== void 0)
        for (const a of s)
          a != null && r.registerDisposer(fo((l, d) => {
            l.registerDisposer(d.visibleSegments.changed.add(() => this.handleChangeAffectingBuffer())), l.registerDisposer(d.segmentEquivalences.changed.add(() => this.handleChangeAffectingBuffer()));
          }, a.segmentationGroupState));
    }, this.segmentationStates)), this.source instanceof po || (this.sharedObject = this.registerDisposer(new Lv(e, this.source, this.segmentationStates, this.layerChunkProgressInfo)));
    const n = this.state.displayState;
    this.registerDisposer(n.color.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(n.shader.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(n.shaderControls.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.hoverState.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.transform.changed.add(this.redrawNeeded.dispatch));
  }
  get source() {
    return this.state.source;
  }
  get transform() {
    return this.state.transform;
  }
  get hoverState() {
    return this.state.displayState.hoverState;
  }
  get visibility() {
    const e = this.sharedObject;
    if (e !== void 0)
      return e.visibility;
  }
  get gl() {
    return this.chunkManager.gl;
  }
  updateBuffer() {
    const e = this.source;
    if (e instanceof po) {
      const t = e.changed.count;
      if (this.generation !== t) {
        let n = this.buffer;
        n === void 0 && (n = this.buffer = this.registerDisposer(new Qn(this.chunkManager.gl))), this.generation = t;
        const r = this.serializedAnnotations = kH(e, EH(this.segmentationStates.value));
        n.setData(this.serializedAnnotations.data), this.numPickIds = kD(r);
      }
    }
  }
};
function XP(i) {
  const t = i.chunkTransform.modelTransform.unpaddedRank, n = new Float32Array(t * 2), r = new Float32Array(t * 3);
  r.fill(0), n.fill(1, t);
  const s = i.numChunkDisplayDims, a = i.chunkDisplayDimensionIndices;
  for (let l = 0; l < s; ++l) {
    const d = a[l];
    n[t + d] = 0, r[d * 3 + l] = 1;
  }
  return { modelClipBounds: n, renderSubspaceTransform: r };
}
function ik(i, e, t) {
  t.clearMessages();
  const n = (u) => {
    t.addMessage({ severity: ar.error, message: u });
  };
  if (i.error !== void 0)
    return n(i.error);
  const r = CL(i.modelTransform, e.displayDimensionIndices);
  let s;
  try {
    s = xL(i, r);
  } catch (u) {
    return n(u.message);
  }
  var a = XP(s);
  const l = a.modelClipBounds, d = a.renderSubspaceTransform;
  return { chunkTransform: i, chunkDisplayTransform: s, modelClipBounds: l, renderSubspaceTransform: d };
}
function _S(i, e) {
  class t extends i {
    constructor(r, s) {
      super(), this.base = r, this.renderScaleHistogram = s, this.curRank = -1, this.renderHelpers = [], this.isAnnotation = true;
      const a = r.visibility;
      a !== void 0 && this.registerDisposer(a.add(this.visibility)), this.registerDisposer(this.renderScaleHistogram.visibility.add(this.visibility)), this.registerDisposer(() => {
        for (const l of this.renderHelpers)
          l.dispose();
      }), this.role = r.state.role, this.registerDisposer(r.redrawNeeded.add(this.redrawNeeded.dispatch)), this.handleRankChanged();
    }
    handleRankChanged() {
      const r = this.base.source.rank;
      if (r === this.curRank) return;
      this.curRank = r, this.tempChunkPosition = new Float32Array(r);
      const s = this.renderHelpers, a = this.gl;
      for (const u of s)
        u.dispose();
      const l = this.base.source.properties, d = this.base.state.displayState;
      for (const u of Mr) {
        const h = jl(u), g = h[e], v = s[u] = new g(a, u, r, l, d.shaderControls, d.fallbackShaderControls, d.shaderError);
        v.pickIdsPerInstance = h.pickIdsPerInstance, v.targetIsSliceView = e === "sliceViewRenderHelper";
      }
    }
    attach(r) {
      super.attach(r), this.handleRankChanged();
      const s = this.chunkTransform, a = r.view.displayDimensionRenderInfo.value;
      r.state = {
        chunkTransform: s,
        displayDimensionRenderInfo: a,
        chunkRenderParameters: ik(s, a, r.messages)
      };
    }
    updateAttachmentState(r) {
      const s = r.state;
      this.handleRankChanged();
      const a = this.chunkTransform, l = r.view.displayDimensionRenderInfo.value;
      return s !== void 0 && s.chunkTransform === a && s.displayDimensionRenderInfo === l ? s.chunkRenderParameters : (s.chunkTransform = a, s.displayDimensionRenderInfo = l, s.chunkRenderParameters = ik(a, l, r.messages));
    }
    get chunkTransform() {
      return this.base.state.chunkTransform.value;
    }
    updateModelClipBounds(r, s) {
      const a = s.modelClipBounds, l = this.curRank, d = s.chunkTransform;
      ic(a.subarray(0, l), r.projectionParameters.globalPosition, this.base.state.localPosition.value, d.layerRank, d.combinedGlobalLocalToChunkTransform);
    }
    get gl() {
      return this.base.chunkManager.gl;
    }
    drawGeometryChunkData(r, s, a, l = 1) {
      if (!r.bufferValid) {
        let d = r.buffer;
        d === void 0 && (d = r.buffer = new Qn(this.gl));
        const u = r.serializedAnnotations;
        d.setData(u.data), r.numPickIds = kD(u), r.bufferValid = true;
      }
      this.drawGeometry(r, s, a, l);
    }
    drawGeometry(r, s, a, l = 1) {
      const d = this.base, u = a.chunkDisplayTransform, h = r.serializedAnnotations, g = h.typeToIdMaps, v = h.typeToOffset;
      let y = 0;
      s.emitPickID && (y = s.pickIDs.register(this, r.numPickIds, 0, 0, r));
      const C = d.hoverState.value, w = vn(xH, s.projectionParameters.viewProjectionMat, u.displaySubspaceModelMatrix), b = {
        annotationLayer: d,
        renderContext: s,
        selectedIndex: 0,
        basePickId: y,
        buffer: r.buffer,
        bufferOffset: 0,
        count: 0,
        modelViewProjectionMatrix: w,
        modelClipBounds: a.modelClipBounds,
        subspaceMatrix: a.renderSubspaceTransform,
        renderSubspaceModelMatrix: u.displaySubspaceModelMatrix,
        renderSubspaceInvModelMatrix: u.displaySubspaceInvModelMatrix,
        chunkDisplayTransform: u
      };
      for (const E of Mr) {
        const T = g[E];
        let I = T.size;
        if (I > 0) {
          const R = jl(E);
          let P = 4294967295;
          if (C !== void 0) {
            const L = T.get(C.id);
            L !== void 0 && (P = L * R.pickIdsPerInstance);
          }
          I = Math.round(I * l), b.count = I, b.bufferOffset = v[E], b.selectedIndex = P, this.renderHelpers[E].draw(b), b.basePickId += I * R.pickIdsPerInstance;
        }
      }
    }
    updateMouseState(r, s, a, l) {
      const u = l.serializedAnnotations, h = u.typeToIds, g = u.typeToOffset, v = this.curRank, y = this.chunkTransform;
      if (y.error === void 0)
        for (const C of Mr) {
          const w = h[C], b = jl(C), E = b.pickIdsPerInstance;
          if (a < w.length * E) {
            const T = Math.floor(a / E), I = w[T], R = a % E;
            r.pickedAnnotationId = I, r.pickedAnnotationLayer = this.base.state, r.pickedOffset = R, r.pickedAnnotationBuffer = u.data.buffer, r.pickedAnnotationType = C, r.pickedAnnotationBufferBaseOffset = u.data.byteOffset + g[C], r.pickedAnnotationIndex = T, r.pickedAnnotationCount = w.length;
            const P = this.tempChunkPosition, L = y.chunkToLayerTransform, A = y.combinedGlobalLocalToChunkTransform, M = y.layerRank, O = y.modelTransform.globalToRenderLayerDimensions, F = r.position;
            if (!ic(P, F, this.base.state.localPosition.value, M, A))
              return;
            const q = this.base.source.annotationPropertySerializers[C];
            b.snapPosition(P, r.pickedAnnotationBuffer, r.pickedAnnotationBufferBaseOffset + r.pickedAnnotationIndex * q.propertyGroupBytes[0], R);
            const U = O.length;
            for (let V = 0; V < U; ++V) {
              const $ = O[V];
              if ($ === -1) continue;
              let B = L[(v + 1) * v + $];
              for (let ue = 0; ue < v; ++ue)
                B += P[ue] * L[ue * (M + 1) + $];
              Lt(B) && (F[V] = B);
            }
            return;
          }
          a -= w.length * E;
        }
    }
    transformPickedValue(r) {
      const s = r.pickedAnnotationBuffer;
      if (s === void 0) return;
      const a = this.base.source.properties;
      if (a.length === 0) return;
      const l = r.pickedAnnotationBufferBaseOffset, d = r.pickedAnnotationType, u = r.pickedAnnotationIndex, h = r.pickedAnnotationCount, g = this.base.source.annotationPropertySerializers, v = new Array(a.length);
      return g[d].deserialize(
        new DataView(s),
        l,
        u,
        h,
        /*isLittleEndian=*/
        ai.LITTLE === wc,
        v
      ), xO(a[0], v[0]);
    }
    isReady() {
      const s = this.base.source;
      if (!(s instanceof Fi))
        return true;
      const a = this.base.segmentationStates.value;
      if (a === void 0) return true;
      for (let l = 0, d = a.length; l < d; ++l) {
        const u = a[l];
        if (u === null) return false;
        if (u === void 0) continue;
        const h = s.segmentFilteredSources[l].chunks;
        let g = false;
        if ($o(u.segmentationGroupState.value, (v) => {
          const y = ir(v);
          h.has(y) || (g = true);
        }), g) return false;
      }
      return true;
    }
  }
  return t;
}
var ZP2 = (i) => class extends i {
  constructor() {
    super(...arguments), this.layerChunkProgressInfo = this.base.layerChunkProgressInfo;
  }
  draw(t, n) {
    const r = this.updateAttachmentState(n);
    if (this.curRank === 0 || r === void 0) return;
    this.updateModelClipBounds(t, r);
    const s = this.base.source;
    if (s instanceof po) {
      const a = this.base;
      a.updateBuffer(), this.drawGeometry(a, t, r);
    } else {
      const a = this.renderScaleHistogram;
      a.begin(this.base.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber), this.drawGeometryChunkData(s.temporary.data, t, r);
      const l = this.base.segmentationStates.value;
      let d = 0, u = 0;
      if (l !== void 0)
        for (let h = 0, g = l.length; h < g; ++h) {
          const v = l[h];
          if (v == null) continue;
          const y = s.segmentFilteredSources[h].chunks;
          $o(v.segmentationGroupState.value, (C) => {
            const w = ir(C), b = y.get(w);
            if (b !== void 0 && b.state === kt.GPU_MEMORY) {
              const E = b.data;
              if (E === void 0) return;
              this.drawGeometryChunkData(E, t, r), ++d;
            } else
              ++u;
          });
        }
      a.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, d, u);
    }
  }
};
var QP = _S(Ho, "perspectiveViewRenderHelper");
var LH = class extends ZP2(QP) {
};
var e2 = (i) => {
  class e extends i {
    constructor(n) {
      super(n.annotationLayer, n.renderScaleHistogram), this.wireFrameRenderHelper = this instanceof xo ? wH : bH, this.wireFrameShaderGetter = vo(this, this.gl, {
        memoizeKey: `annotation/wireFrameShader:${this instanceof xo}`,
        parameters: ta(void 0),
        defineShader: (a) => {
          this.wireFrameRenderHelper.defineShader(a);
        }
      }), this.renderScaleTarget = n.renderScaleTarget, this.registerDisposer(this.renderScaleTarget.changed.add(this.redrawNeeded.dispatch));
      const r = this.registerDisposer(new Rc(this.layerChunkProgressInfo)), s = this.base.chunkManager.rpc;
      r.RPC_TYPE_ID = AF, r.initializeCounterpart(s, {
        chunkManager: this.base.chunkManager.rpcId,
        localPosition: this.registerDisposer(An.makeFromExisting(s, this.base.state.localPosition)).rpcId,
        renderScaleTarget: this.registerDisposer(An.makeFromExisting(s, this.renderScaleTarget)).rpcId
      }), this.backend = r;
    }
    attach(n) {
      super.attach(n), n.state.sources = n.registerDisposer(Or((r, s, a) => {
        const l = Yy(a, s, (d) => this.base.state.source.getSources(d), n.messages, this);
        for (const d of l)
          for (const u of d)
            r.registerDisposer(u.source), H(u, XP(u.chunkDisplayTransform));
        return n.view.flushBackendProjectionParameters(), this.backend.rpc.invoke(_F, {
          layer: this.backend.rpcId,
          view: n.view.rpcId,
          displayDimensionRenderInfo: a,
          sources: Ky(l)
        }), this.redrawNeeded.dispatch(), l;
      }, this.base.state.transform, n.view.displayDimensionRenderInfo));
    }
    draw(n, r) {
      const s = this.updateAttachmentState(r);
      if (this.curRank === 0 || s === void 0) return;
      const a = r.state.sources.value;
      if (a.length === 0) return;
      this.updateModelClipBounds(n, s);
      const l = this.renderScaleHistogram;
      l.begin(this.base.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
      const d = n.projectionParameters;
      let u;
      if (n.wireFrame) {
        var h = this.wireFrameShaderGetter(n.emitter);
        const g = h.shader;
        if (g === null) return;
        g.bind(), this.wireFrameRenderHelper.initialize(g, d), u = g;
      }
      VF(d, this.base.state.localPosition.value, this.renderScaleTarget.value, a[0], () => {
      }, (g, v, y, C, w) => {
        const b = g.source.chunks.get(g.curPositionInChunks.join());
        let E;
        if (b === void 0 || b.state !== kt.GPU_MEMORY)
          E = 0;
        else {
          const T = b.data;
          if (T === void 0)
            return;
          u !== void 0 ? this.wireFrameRenderHelper.draw(u, g, d) : this.drawGeometryChunkData(T, n, s, y), E = 1;
        }
        l.add(C, w, E, 1 - E);
      });
    }
  }
  return e;
};
var DH = e2(QP);
var IH = e2(_S(xo, "sliceViewRenderHelper"));
var PH = ZP2(_S(xo, "sliceViewRenderHelper"));
var RH = class extends X {
  constructor() {
    super(...arguments), this.changed = new Le(), this.isLoadingChanged = new Le(), this.states = [], this.relationships = [], this.loadingCount = 0;
  }
  get value() {
    return this.states;
  }
  get isLoading() {
    return this.loadingCount !== 0;
  }
  markLoading() {
    return this.loadingCount++, () => {
      --this.loadingCount === 0 && this.isLoadingChanged.dispatch();
    };
  }
  sort() {
    this.states.sort((e, t) => {
      let n = e.sourceIndex - t.sourceIndex;
      return n !== 0 ? n : e.subsourceIndex - t.subsourceIndex;
    });
  }
  updateRelationships() {
    const e = new Ye();
    for (const t of this.states)
      for (const n of t.source.relationships)
        e.add(n);
    this.relationships = _e(e);
  }
  add(e) {
    return this.states.push(e), this.sort(), this.updateRelationships(), this.changed.dispatch(), () => {
      const t = this.states.indexOf(e);
      this.states.splice(t, 1), this.updateRelationships(), this.changed.dispatch();
    };
  }
};
function AH(i, e) {
  switch (e.type) {
    case Fe.AXIS_ALIGNED_BOUNDING_BOX:
    case Fe.LINE:
    case Fe.SPHERE:
      aL(i, e.pointA, e.pointB), jO(i, i, 0.5);
      break;
    case Fe.POINT:
      i.set(e.point);
      break;
    case Fe.ELLIPSOID:
      i.set(e.center);
      break;
  }
}
function t2(i, e, t) {
  e.error === void 0 && i.setLayerPosition(e.modelTransform, t);
}
function n2(i, e, t) {
  const n = e.layerRank, r = new Float32Array(n);
  Gn[i.type].visitGeometry(i, (s, a) => {
    r.set(s);
    const l = new Float32Array(n);
    (a ? nL : Ar)(l, e.chunkToLayerTransform, n + 1, r, n), t(l, a);
  });
}
var _H = class extends qr {
  constructor(e, t) {
    super(), this.layer = e, this.displayState = t, this.previousSelectedState = void 0, this.previousHoverId = void 0, this.previousHoverAnnotationLayerState = void 0, this.virtualListSource = {
      length: 0,
      render: (y) => this.render(y),
      changed: new ct()
    }, this.virtualList = new gS({ source: this.virtualListSource }), this.listElements = [], this.updated = false, this.mutableControls = document.createElement("div"), this.headerRow = document.createElement("div"), this.attachedAnnotationStates = new he(), this.forceUpdateView = () => {
      this.updated = false, this.updateView();
    }, this.globalDimensionIndices = [], this.localDimensionIndices = [], this.curCoordinateSpaceGeneration = -1, this.prevCoordinateSpaceGeneration = -1, this.columnWidths = [], this.gridTemplate = "", this.selectedAnnotationState = nr((y, C) => {
      var w;
      if (y === void 0) return;
      const b = this.layer, E = (w = y.layers.find((R) => R.layer === b)) === null || w === void 0 ? void 0 : w.state;
      if (E === void 0) return;
      const T = E.annotationId;
      if (T === void 0) return;
      const I = this.annotationStates.states.find((R) => R.sourceIndex === E.annotationSourceIndex && (E.annotationSubsource === void 0 || R.subsourceId === E.annotationSubsource));
      if (I !== void 0)
        return { annotationId: T, annotationLayerState: I, pin: C };
    }, this.layer.manager.root.selectionState, this.layer.manager.root.selectionState.pin), this.element.classList.add("neuroglancer-annotation-layer-view"), this.registerDisposer(this.visibility.changed.add(() => this.updateView())), this.registerDisposer(e.annotationStates.changed.add(() => this.updateAttachedAnnotationLayerStates())), this.headerRow.classList.add("neuroglancer-annotation-list-header");
    const n = document.createElement("div");
    n.className = "neuroglancer-annotation-toolbox", e.initializeAnnotationLayerViewTab(this);
    const r = this.registerDisposer(new xS(this.displayState.color));
    r.element.title = "Change annotation display color", this.registerDisposer(new fi(nr((y) => y.match(/\bdefaultColor\b/) !== null, t.shaderControls.processedFragmentMain), r.element)), n.appendChild(r.element);
    const s = this.mutableControls, a = Tt({
      text: Gn[Fe.POINT].icon,
      title: "Annotate point",
      onClick: () => {
        this.layer.tool.value = new c2(this.layer, {});
      }
    });
    s.appendChild(a);
    const l = Tt({
      text: Gn[Fe.AXIS_ALIGNED_BOUNDING_BOX].icon,
      title: "Annotate bounding box",
      onClick: () => {
        this.layer.tool.value = new NS(this.layer, {});
      }
    });
    s.appendChild(l);
    const d = Tt({
      text: Gn[Fe.LINE].icon,
      title: "Annotate line",
      onClick: () => {
        this.layer.tool.value = new OS(this.layer, {});
      }
    });
    s.appendChild(d);
    const u = Tt({
      text: Gn[Fe.SPHERE].icon,
      title: "Annotate Sphere",
      onClick: () => {
        this.layer.tool.value = new VS(this.layer, {});
      }
    });
    s.appendChild(u);
    const h = Tt({
      text: Gn[Fe.ELLIPSOID].icon,
      title: "Annotate ellipsoid",
      onClick: () => {
        this.layer.tool.value = new u2(this.layer, {});
      }
    });
    s.appendChild(h), n.appendChild(s), this.element.appendChild(n), this.element.appendChild(this.headerRow);
    const g = this.virtualList;
    g.element.classList.add("neuroglancer-annotation-list"), this.element.appendChild(g.element), this.virtualList.element.addEventListener("mouseleave", () => {
      this.displayState.hoverState.value = void 0;
    });
    const v = LU();
    this.registerDisposer(new Hr(this.virtualList.element, v)), this.virtualList.element.title = v.describe(), this.registerDisposer(this.displayState.hoverState.changed.add(() => this.updateHoverView())), this.registerDisposer(this.selectedAnnotationState.changed.add(() => this.updateSelectionView())), this.registerDisposer(this.layer.localCoordinateSpace.changed.add(() => {
      this.updateCoordinateSpace(), this.updateView();
    })), this.registerDisposer(this.layer.manager.root.coordinateSpace.changed.add(() => {
      this.updateCoordinateSpace(), this.updateView();
    })), this.updateCoordinateSpace(), this.updateAttachedAnnotationLayerStates(), this.updateSelectionView();
  }
  get annotationStates() {
    return this.layer.annotationStates;
  }
  updateAttachedAnnotationLayerStates() {
    const e = this.annotationStates.states, t = this.attachedAnnotationStates, n = new he();
    for (const s of t) {
      var r = de(s, 2);
      const a = r[0], l = r[1];
      e.includes(a) || (t.delete(a), l.refCounted.dispose());
    }
    for (const s of e) {
      const a = t.get(s);
      if (a !== void 0) {
        n.set(s, a);
        continue;
      }
      const l = s.source, d = new X();
      (l instanceof po || l instanceof Fi) && (d.registerDisposer(l.childAdded.add((u) => this.addAnnotationElement(u, s))), d.registerDisposer(l.childUpdated.add((u) => this.updateAnnotationElement(u, s))), d.registerDisposer(l.childDeleted.add((u) => this.deleteAnnotationElement(u, s))), d.registerDisposer(l.childRefreshed.add(() => this.clearAnnotationElement(s)))), d.registerDisposer(s.transform.changed.add(this.forceUpdateView)), n.set(s, { refCounted: d, annotations: [], idToIndex: new he(), listOffset: 0 });
    }
    this.attachedAnnotationStates = n, t.clear(), this.updateCoordinateSpace(), this.forceUpdateView();
  }
  updateCoordinateSpace() {
    const e = this.layer.localCoordinateSpace.value, t = this.layer.manager.root.coordinateSpace.value, n = [], r = [];
    for (let s = 0, a = t.rank; s < a; ++s)
      this.annotationStates.states.some((l) => {
        const d = l.transform.value;
        return d.error !== void 0 ? false : d.globalToRenderLayerDimensions[s] !== -1;
      }) && n.push(s);
    for (let s = 0, a = e.rank; s < a; ++s)
      this.annotationStates.states.some((l) => {
        const d = l.transform.value;
        return d.error !== void 0 ? false : d.localToRenderLayerDimensions[s] !== -1;
      }) && r.push(s);
    (!He(n, this.globalDimensionIndices) || !He(r, this.localDimensionIndices)) && (this.localDimensionIndices = r, this.globalDimensionIndices = n, ++this.curCoordinateSpaceGeneration);
  }
  getRenderedAnnotationListElement(e, t, n = false) {
    const r = this.attachedAnnotationStates.get(e);
    if (r == null) return;
    const s = r.idToIndex.get(t);
    if (s === void 0) return;
    const a = r.listOffset + s;
    return n && this.virtualList.scrollItemIntoView(s), this.virtualList.getItemElement(a);
  }
  clearSelectionClass() {
    const e = this.previousSelectedState;
    if (e === void 0) return;
    this.previousSelectedState = void 0;
    const t = this.getRenderedAnnotationListElement(e.annotationLayerState, e.annotationId);
    t !== void 0 && t.classList.remove("neuroglancer-annotation-selected");
  }
  clearHoverClass() {
    const e = this.previousHoverId, t = this.previousHoverAnnotationLayerState;
    if (t !== void 0) {
      this.previousHoverAnnotationLayerState = void 0, this.previousHoverId = void 0;
      const n = this.getRenderedAnnotationListElement(t, e);
      n !== void 0 && n.classList.remove("neuroglancer-annotation-hover");
    }
  }
  updateSelectionView() {
    const e = this.selectedAnnotationState.value, t = this.previousSelectedState;
    if (t === e || t !== void 0 && e !== void 0 && t.annotationId === e.annotationId && t.annotationLayerState === e.annotationLayerState && t.pin === e.pin || (this.clearSelectionClass(), this.previousSelectedState = e, e === void 0)) return;
    const n = this.getRenderedAnnotationListElement(
      e.annotationLayerState,
      e.annotationId,
      /*scrollIntoView=*/
      e.pin
    );
    n !== void 0 && n.classList.add("neuroglancer-annotation-selected");
  }
  updateHoverView() {
    const e = this.displayState.hoverState.value;
    let t, n;
    e !== void 0 && (t = e.id, n = e.annotationLayerState);
    const r = this.previousHoverId, s = this.previousHoverAnnotationLayerState;
    if (t === r && n === s || (this.clearHoverClass(), this.previousHoverId = t, this.previousHoverAnnotationLayerState = n, t === void 0)) return;
    const a = this.getRenderedAnnotationListElement(n, t);
    a !== void 0 && a.classList.add("neuroglancer-annotation-hover");
  }
  render(e) {
    var t = this.listElements[e];
    const n = t.annotation, r = t.state;
    return this.makeAnnotationListElement(n, r);
  }
  setColumnWidth(e, t) {
    t += 2;
    const n = this.columnWidths;
    n[e] > t || (n[e] = t, this.element.style.setProperty(`--neuroglancer-column-${e}-width`, `${t}ch`));
  }
  updateView() {
    if (!this.visible)
      return;
    if (this.curCoordinateSpaceGeneration !== this.prevCoordinateSpaceGeneration) {
      this.updated = false;
      const s = this.columnWidths;
      s.length = 0;
      const a = this.headerRow, l = document.createElement("div");
      l.style.gridColumn = "symbol";
      const d = document.createElement("div");
      d.style.gridColumn = "delete", st(a), a.appendChild(l);
      let u = 0, h = "[symbol] 2ch";
      const g = (C, w) => {
        const b = document.createElement("div");
        b.classList.add("neuroglancer-annotations-view-dimension");
        const E = document.createElement("span");
        E.classList.add("neuroglancer-annotations-view-dimension-name"), E.textContent = C.names[w];
        const T = document.createElement("scale");
        T.classList.add("neuroglancer-annotations-view-dimension-scale"), T.textContent = ia(C.scales[w], C.units[w], { precision: 2 }), b.appendChild(E), b.appendChild(T), b.style.gridColumn = `dim ${u + 1}`, this.setColumnWidth(u, T.textContent.length + E.textContent.length + 3), h += ` [dim] var(--neuroglancer-column-${u}-width)`, ++u, a.appendChild(b);
      }, v = this.layer.manager.root.coordinateSpace.value;
      for (const C of this.globalDimensionIndices)
        g(v, C);
      const y = this.layer.localCoordinateSpace.value;
      for (const C of this.localDimensionIndices)
        g(y, C);
      a.appendChild(d), h += " [delete] 2ch", this.gridTemplate = h, a.style.gridTemplateColumns = h, this.prevCoordinateSpaceGeneration = this.curCoordinateSpaceGeneration;
    }
    if (this.updated)
      return;
    let e = false;
    const t = this.listElements;
    t.length = 0;
    for (const s of this.attachedAnnotationStates) {
      var n = de(s, 2);
      const a = n[0], l = n[1];
      if (a.source.readonly || (e = true), a.chunkTransform.value.error !== void 0) continue;
      const d = a.source, u = _e(d);
      l.annotations = u;
      const h = l.idToIndex;
      h.clear();
      for (let g = 0, v = u.length; g < v; ++g)
        h.set(u[g].id, g);
      for (const g of u)
        t.push({ state: a, annotation: g });
    }
    const r = this.virtualListSource.length;
    this.updateListLength(), this.virtualListSource.changed.dispatch([{ retainCount: 0, deleteCount: r, insertCount: t.length }]), this.mutableControls.style.display = e ? "contents" : "none", this.resetOnUpdate();
  }
  updateListLength() {
    let e = 0;
    for (const t of this.attachedAnnotationStates.values())
      t.listOffset = e, e += t.annotations.length;
    this.virtualListSource.length = e;
  }
  clearAnnotationElement(e) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const t = this.attachedAnnotationStates.get(e);
    if (t !== void 0) {
      const n = t.annotations.length;
      t.annotations = [], t.idToIndex.clear(), this.listElements = [], this.updateListLength(), this.virtualListSource.changed.dispatch([{ retainCount: 0, deleteCount: n, insertCount: 0 }]);
    }
    this.resetOnUpdate();
  }
  addAnnotationElement(e, t) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const n = this.attachedAnnotationStates.get(t);
    if (n !== void 0) {
      const r = n.annotations.length;
      n.annotations.push(e), n.idToIndex.set(e.id, r);
      const s = n.listOffset + r;
      this.listElements.splice(s, 0, { state: t, annotation: e }), this.updateListLength(), this.virtualListSource.changed.dispatch([{ retainCount: s, deleteCount: 0, insertCount: 1 }]);
    }
    this.resetOnUpdate();
  }
  updateAnnotationElement(e, t) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const n = this.attachedAnnotationStates.get(t);
    if (n !== void 0) {
      const r = n.idToIndex.get(e.id);
      if (r !== void 0) {
        const s = n.listOffset + r;
        n.annotations[r] = e, this.listElements[s].annotation = e, this.virtualListSource.changed.dispatch([{ retainCount: s, deleteCount: 1, insertCount: 1 }]);
      }
    }
    this.resetOnUpdate();
  }
  deleteAnnotationElement(e, t) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const n = this.attachedAnnotationStates.get(t);
    if (n !== void 0) {
      const r = n.idToIndex, s = r.get(e);
      if (s !== void 0) {
        const a = n.listOffset + s, l = n.annotations;
        l.splice(s, 1), r.delete(e);
        for (let d = s, u = l.length; d < u; ++d)
          r.set(l[d].id, d);
        this.listElements.splice(a, 1), this.updateListLength(), this.virtualListSource.changed.dispatch([{ retainCount: a, deleteCount: 1, insertCount: 0 }]);
      }
    }
    this.resetOnUpdate();
  }
  resetOnUpdate() {
    this.clearHoverClass(), this.clearSelectionClass(), this.updated = true, this.updateHoverView(), this.updateSelectionView();
  }
  makeAnnotationListElement(e, t) {
    const n = t.chunkTransform.value, r = document.createElement("div");
    r.classList.add("neuroglancer-annotation-list-entry"), r.style.gridTemplateColumns = this.gridTemplate;
    const s = document.createElement("div");
    s.className = "neuroglancer-annotation-icon", s.textContent = Gn[e.type].icon, r.appendChild(s);
    let a;
    const l = () => {
      t.source.readonly || a === void 0 && (a = ms({
        title: "Delete annotation",
        onClick: (h) => {
          h.stopPropagation(), h.preventDefault();
          const g = t.source.getReference(e.id);
          try {
            t.source.delete(g);
          } finally {
            g.dispose();
          }
        }
      }), a.classList.add("neuroglancer-annotation-list-entry-delete"), r.appendChild(a));
    };
    let d = 0;
    if (n2(e, n, (h, g) => {
      ++d;
      const v = document.createElement("div");
      v.className = "neuroglancer-annotation-position", r.appendChild(v);
      let y = 0;
      const C = (w, b) => {
        for (const E of w) {
          const T = b[E];
          if (T !== -1) {
            const I = Math.floor(h[T]), R = document.createElement("div"), P = I.toString();
            R.textContent = P, R.classList.add("neuroglancer-annotation-coordinate"), R.style.gridColumn = `dim ${y + 1}`, this.setColumnWidth(y, P.length), v.appendChild(R);
          }
          ++y;
        }
      };
      C(this.globalDimensionIndices, n.modelTransform.globalToRenderLayerDimensions), C(this.localDimensionIndices, n.modelTransform.localToRenderLayerDimensions), l();
    }), e.description) {
      ++d;
      const h = document.createElement("div");
      h.classList.add("neuroglancer-annotation-description"), h.textContent = e.description, r.appendChild(h);
    }
    s.style.gridRow = `span ${d}`, a !== void 0 && (a.style.gridRow = `span ${d}`), r.addEventListener("mouseenter", () => {
      this.displayState.hoverState.value = {
        id: e.id,
        partIndex: 0,
        annotationLayerState: t
      }, this.layer.selectAnnotation(t, e.id, false);
    }), r.addEventListener("action:select-position", (h) => {
      h.stopPropagation(), this.layer.selectAnnotation(t, e.id, "toggle");
    }), r.addEventListener("action:pin-annotation", (h) => {
      h.stopPropagation(), this.layer.selectAnnotation(t, e.id, true);
    }), r.addEventListener("action:move-to-annotation", (h) => {
      h.stopPropagation(), h.preventDefault();
      const g = n.layerRank, v = new Float32Array(g), y = new Float32Array(g);
      AH(v, e), Ar(y, n.chunkToLayerTransform, g + 1, v, g), t2(this.layer, n, y);
    });
    const u = this.selectedAnnotationState.value;
    return u !== void 0 && u.annotationLayerState === t && u.annotationId === e.id && r.classList.add("neuroglancer-annotation-selected"), r;
  }
};
var MH = class extends qr {
  constructor(e) {
    super(), this.layer = e, this.layerView = this.registerDisposer(new _H(this.layer, this.layer.annotationDisplayState));
    const t = this.element;
    t.classList.add("neuroglancer-annotations-tab"), t.appendChild(this.layerView.element);
  }
};
function Mo(i) {
  let e = [];
  const t = i.source.relationships, n = i.displayState.relationshipStates;
  for (let r = 0, s = t.length; r < s; ++r) {
    const a = n.get(t[r]).segmentationState.value;
    if (a != null && a.segmentSelectionState.hasSelectedSegment) {
      e[r] = [a.segmentSelectionState.selectedSegment.clone()];
      continue;
    }
    e[r] = [];
  }
  return e;
}
var i2 = class extends II {
  constructor(e, t) {
    super(e);
  }
  get annotationLayer() {
    for (const e of this.layer.annotationStates.states)
      if (!e.source.readonly) return e;
  }
};
var r2 = "annotatePoint";
var s2 = "annotateLine";
var a2 = "annotateBoundingBox";
var o2 = "annotateEllipsoid";
var l2 = "annotateSphere";
var c2 = class extends i2 {
  constructor() {
    super(...arguments), this.sourceSignalUpdated = false;
  }
  trigger(e) {
    const t = this.annotationLayer;
    if (t !== void 0 && e.updateUnconditionally()) {
      const n = vc(e, t);
      if (n === void 0) return;
      const r = {
        id: "",
        description: "",
        relatedSegments: Mo(t),
        point: n,
        type: Fe.POINT,
        properties: t.source.properties.map((a) => a.default)
      }, s = t.source.add(
        r,
        /*commit=*/
        true
      );
      t.source instanceof Fi ? this.sourceSignalUpdated || (t.source.childAdded.add((a) => {
        a.source === void 0 && this.layer.selectAnnotation(t, a.id, true, !vs.expectingExternalUI);
      }), this.sourceSignalUpdated = true) : this.layer.selectAnnotation(t, s.id, true), s.dispose();
    }
  }
  get description() {
    return "annotate point";
  }
  toJSON() {
    return r2;
  }
};
function vc(i, e) {
  const t = e.chunkTransform.value;
  if (t.error !== void 0) return;
  const n = new Float32Array(t.modelTransform.unpaddedRank);
  if (ic(n, i.unsnappedPosition, e.localPosition.value, t.layerRank, t.combinedGlobalLocalToChunkTransform))
    return n;
}
var d2 = class extends i2 {
  trigger(e) {
    const t = this.annotationLayer;
    if (t !== void 0 && e.updateUnconditionally()) {
      const n = () => {
        const r = this.inProgressAnnotation, s = r.reference, a = this.getUpdatedAnnotation(s.value, e, t);
        oe(_m(a, t.source)) !== oe(_m(s.value, t.source)) && (r.annotationLayer.source.update(s, a), this.layer.selectAnnotation(t, s.id, true, !vs.expectingExternalUI));
      };
      if (this.inProgressAnnotation === void 0) {
        const r = t.source.add(
          this.getInitialAnnotation(e, t),
          /*commit=*/
          false
        );
        this.layer.selectAnnotation(t, r.id, true, !vs.expectingExternalUI);
        const s = e.changed.add(n), a = () => {
          s(), r.dispose();
        };
        this.inProgressAnnotation = {
          annotationLayer: t,
          reference: r,
          disposer: a
        };
      } else
        n(), this.inProgressAnnotation.annotationLayer.source.commit(this.inProgressAnnotation.reference), this.inProgressAnnotation.disposer(), this.inProgressAnnotation = void 0;
    }
  }
  disposed() {
    this.deactivate(), super.disposed();
  }
  deactivate() {
    this.inProgressAnnotation !== void 0 && (this.inProgressAnnotation.annotationLayer.source.delete(this.inProgressAnnotation.reference), this.inProgressAnnotation.disposer(), this.inProgressAnnotation = void 0);
  }
};
var MS = class extends d2 {
  getInitialAnnotation(e, t) {
    const n = vc(e, t);
    return {
      id: "",
      type: this.annotationType,
      description: "",
      pointA: n,
      pointB: n,
      properties: t.source.properties.map((r) => r.default)
    };
  }
  getUpdatedAnnotation(e, t, n) {
    const r = vc(t, n);
    return r === void 0 ? e : H(H({}, e), { pointB: r });
  }
};
var NS = class extends MS {
  get description() {
    return "annotate bounding box";
  }
  getUpdatedAnnotation(e, t, n) {
    const r = super.getUpdatedAnnotation(e, t, n), s = r.pointA, a = r.pointB, l = s.length;
    for (let d = 0; d < l; ++d)
      s[d] === a[d] && (a[d] += 1);
    return r;
  }
  toJSON() {
    return a2;
  }
};
NS.prototype.annotationType = Fe.AXIS_ALIGNED_BOUNDING_BOX;
var OS = class extends MS {
  get description() {
    return "annotate line";
  }
  getInitialAnnotation(e, t) {
    const n = super.getInitialAnnotation(e, t);
    return this.initialRelationships = n.relatedSegments = Mo(t), n;
  }
  getUpdatedAnnotation(e, t, n) {
    const r = super.getUpdatedAnnotation(e, t, n), s = this.initialRelationships, a = Mo(n);
    return s === void 0 ? r.relatedSegments = a : r.relatedSegments = _e(a, (l, d) => {
      const u = s[d];
      return l = l.filter((h) => u.findIndex((g) => re.equal(h, g)) === -1), [...u, ...l];
    }), r;
  }
  toJSON() {
    return s2;
  }
};
OS.prototype.annotationType = Fe.LINE;
var VS = class extends MS {
  get description() {
    return "annotate sphere";
  }
  getInitialAnnotation(e, t) {
    const n = super.getInitialAnnotation(e, t);
    return this.initialRelationships = n.relatedSegments = Mo(t), n;
  }
  getUpdatedAnnotation(e, t, n) {
    const r = super.getUpdatedAnnotation(e, t, n), s = this.initialRelationships, a = Mo(n);
    return s === void 0 ? r.relatedSegments = a : r.relatedSegments = _e(a, (l, d) => {
      const u = s[d];
      return l = l.filter((h) => u.findIndex((g) => re.equal(h, g)) === -1), [...u, ...l];
    }), r;
  }
  toJSON() {
    return l2;
  }
};
VS.prototype.annotationType = Fe.SPHERE;
var u2 = class extends d2 {
  getInitialAnnotation(e, t) {
    const n = vc(e, t);
    return {
      type: Fe.ELLIPSOID,
      id: "",
      description: "",
      segments: Mo(t),
      center: n,
      radii: wt(0, 0, 0),
      properties: t.source.properties.map((r) => r.default)
    };
  }
  getUpdatedAnnotation(e, t, n) {
    const r = vc(t, n);
    if (r === void 0) return e;
    const s = e.center, a = s.length;
    for (let l = 0; l < a; ++l)
      r[l] = Math.abs(s[l] - r[l]);
    return H(H({}, e), { radii: r });
  }
  get description() {
    return "annotate ellipsoid";
  }
  toJSON() {
    return o2;
  }
};
$c(r2, (i, e) => new c2(i, e));
$c(a2, (i, e) => new NS(i, e));
$c(s2, (i, e) => new OS(i, e));
$c(o2, (i, e) => new u2(i, e));
$c(l2, (i, e) => new VS(i, e));
var NH = St.fromObject({
  enter: { action: "commit" },
  escape: { action: "cancel" }
});
function OH(i, e, t, n) {
  return new lr(t, (r, s, a) => {
    const l = document.createElement("div");
    l.classList.add("neuroglancer-related-segment-list"), r != null && a.registerDisposer(Do(r, l));
    const d = document.createElement("div");
    d.classList.add("neuroglancer-related-segment-list-header");
    const u = or({
      title: "Copy segment IDs",
      onClick: () => {
        oi(e.map((C) => C.toString()).join(", "));
      }
    });
    d.appendChild(u);
    let h;
    if (r != null && (h = document.createElement("input"), h.type = "checkbox", h.addEventListener("change", () => {
      const C = r.segmentationGroupState.value.visibleSegments, w = e.some((b) => !C.has(b));
      for (const b of e)
        C.set(b, w);
    }), d.appendChild(h)), n !== void 0) {
      const C = ms({
        title: "Remove all IDs",
        onClick: () => {
          n([]);
        }
      });
      d.appendChild(C);
    }
    const g = document.createElement("span");
    if (g.classList.add("neuroglancer-related-segment-list-title"), g.textContent = i, d.appendChild(g), n !== void 0) {
      const C = kI({
        title: "Add related segment ID",
        onClick: () => {
          const w = new X(), b = a.registerDisposer(fT(w)), E = document.createElement("div");
          E.classList.add("neuroglancer-segment-list-entry"), E.classList.add("neuroglancer-segment-list-entry-new");
          const T = or({});
          if (T.classList.add("neuroglancer-segment-list-entry-copy"), E.appendChild(T), r != null) {
            const A = document.createElement("input");
            A.classList.add("neuroglancer-segment-list-entry-visible-checkbox"), A.type = "checkbox", E.appendChild(A);
          }
          const I = ms({
            title: "Cancel adding new segment ID",
            onClick: () => {
              b();
            }
          });
          I.classList.add("neuroglancer-segment-list-entry-delete"), E.appendChild(I);
          const R = document.createElement("input");
          R.autocomplete = "off", R.spellcheck = false, R.classList.add("neuroglancer-segment-list-entry-id");
          const P = w.registerDisposer(new Gi(R, NH));
          P.allShortcutsAreGlobal = true;
          const L = () => {
            const A = new re();
            if (A.tryParseString(R.value))
              return R.dataset.valid = "true", A;
            R.dataset.valid = "false";
          };
          L(), R.addEventListener("input", () => {
            L();
          }), R.addEventListener("blur", () => {
            const A = L();
            A !== void 0 && n([...e, A]), b();
          }), Ce(R, "cancel", b), Ce(R, "commit", () => {
            const A = L();
            A !== void 0 && n([...e, A]), b();
          }), E.appendChild(R), l.appendChild(E), R.focus(), w.registerDisposer(() => {
            R.value = "", E.remove();
          });
        }
      });
      d.appendChild(C);
    }
    l.appendChild(d);
    const v = [], y = qo.make(
      r ?? void 0,
      /*includeMapped=*/
      false
    );
    for (const C of e) {
      const w = y.get(C);
      if (v.push(w), n !== void 0) {
        const b = ms({
          title: "Remove ID",
          onClick: (E) => {
            n(e.filter((T) => !re.equal(T, C))), E.stopPropagation();
          }
        });
        b.classList.add("neuroglancer-segment-list-entry-delete"), w.children[0].appendChild(b);
      }
      l.appendChild(w);
    }
    if (r != null) {
      const C = a.registerCancellable(Ct(() => {
        const w = r.segmentationGroupState.value.visibleSegments;
        let b = 0;
        for (const E of e)
          w.has(E) && ++b;
        for (const E of v)
          y.update(E);
        h.checked = b === e.length && b > 0, h.indeterminate = b > 0 && b < e.length;
      }));
      C(), C.flush(), jo(r, a, C), a.registerDisposer(r.segmentationGroupState.changed.add(C));
    }
    s.appendChild(l);
  });
}
var rk = "annotationColor";
function BS(i) {
  class e extends i {
    constructor(...n) {
      super(...n), this.annotationStates = this.registerDisposer(new RH()), this.annotationDisplayState = new cF(), this.annotationCrossSectionRenderScaleHistogram = new Co(), this.annotationCrossSectionRenderScaleTarget = sa(8), this.annotationProjectionRenderScaleHistogram = new Co(), this.annotationProjectionRenderScaleTarget = sa(8), this.annotationDisplayState.color.changed.add(this.specificationChanged.dispatch), this.annotationDisplayState.shader.changed.add(this.specificationChanged.dispatch), this.annotationDisplayState.shaderControls.changed.add(this.specificationChanged.dispatch), this.tabs.add("annotations", { label: "Annotations", order: 10, getter: () => new MH(this) });
      let r;
      const s = () => {
        const l = this.isReady;
        l && r !== void 0 ? (r(), r = void 0) : !l && r === void 0 && (r = this.annotationStates.markLoading());
      };
      this.readyStateChanged.add(s), s();
      const a = this.manager.layerSelectedValues.mouseState;
      this.registerDisposer(a.changed.add(() => {
        if (a.active) {
          const l = a.pickedAnnotationLayer;
          if (l !== void 0 && this.annotationStates.states.includes(l)) {
            const d = this.annotationDisplayState.hoverState.value;
            (d === void 0 || d.id !== a.pickedAnnotationId || d.partIndex !== a.pickedOffset || d.annotationLayerState !== l) && (this.annotationDisplayState.hoverState.value = {
              id: a.pickedAnnotationId,
              partIndex: a.pickedOffset,
              annotationLayerState: l
            });
            return;
          }
        }
        this.annotationDisplayState.hoverState.value = void 0;
      }));
    }
    initializeAnnotationLayerViewTab(n) {
    }
    restoreState(n) {
      super.restoreState(n), this.annotationDisplayState.color.restoreState(n[rk]);
    }
    captureSelectionState(n, r) {
      super.captureSelectionState(n, r);
      const s = r.pickedAnnotationLayer;
      s === void 0 || !this.annotationStates.states.includes(s) || (n.annotationId = r.pickedAnnotationId, n.annotationType = r.pickedAnnotationType, n.annotationBuffer = new Uint8Array(r.pickedAnnotationBuffer, r.pickedAnnotationBufferBaseOffset), n.annotationIndex = r.pickedAnnotationIndex, n.annotationCount = r.pickedAnnotationCount, n.annotationPartIndex = r.pickedOffset, n.annotationSourceIndex = s.sourceIndex, n.annotationSubsource = s.subsourceId);
    }
    displayAnnotationState(n, r, s) {
      if (n.annotationId === void 0) return false;
      const a = this.annotationStates.states.find((d) => d.sourceIndex === n.annotationSourceIndex && (n.annotationSubsource === void 0 || d.subsourceId === n.annotationSubsource));
      if (a === void 0) return false;
      a.source instanceof Fi;
      const l = s.registerDisposer(a.source.getReference(n.annotationId));
      return r.appendChild(s.registerDisposer(new lr(s.registerDisposer(new vT(() => ({
        annotation: l,
        chunkTransform: a.chunkTransform
      }))), ({ annotation: d, chunkTransform: u }, h, g) => {
        let v;
        if (d == null)
          if (n.annotationType !== void 0 && n.annotationBuffer !== void 0) {
            const w = Gn[n.annotationType], b = a.source.rank, E = w.serializedBytes(b), T = n.annotationBuffer.byteOffset, I = new DataView(n.annotationBuffer.buffer), R = ai.LITTLE === wc, P = a.source.properties, L = new QT(b, E, P), A = n.annotationIndex, M = n.annotationCount;
            d = w.deserialize(I, T + L.propertyGroupBytes[0] * A, R, b, n.annotationId), L.deserialize(I, T, A, M, R, d.properties = new Array(P.length)), a.source.hasNonSerializedProperties() && (v = "Loading...");
          } else
            v = d === null ? "Annotation not found" : "Loading...";
        if (d != null) {
          const w = u.error === void 0 ? u.layerRank : 0, b = document.createElement("div");
          b.classList.add("neuroglancer-selected-annotation-details-position-grid"), b.style.gridTemplateColumns = `[icon] 0fr [copy] 0fr repeat(${w}, [dim] 0fr [coord] 0fr) [move] 0fr [delete] 0fr`, h.appendChild(b);
          const E = Gn[d.type], T = document.createElement("div");
          if (T.className = "neuroglancer-selected-annotation-details-icon", T.textContent = E.icon, b.appendChild(T), w !== 0) {
            const O = u.modelTransform.layerDimensionNames;
            for (let F = 0; F < w; ++F) {
              const q = document.createElement("div");
              q.classList.add("neuroglancer-selected-annotation-details-position-dim"), q.textContent = O[F], q.style.gridColumn = `dim ${F + 1}`, b.appendChild(q);
            }
            n2(d, u, (F, q) => {
              const U = or({
                title: "Copy position",
                onClick: () => {
                  oi(F.map((V) => Math.floor(V)).join(", "));
                }
              });
              U.style.gridColumn = "copy", b.appendChild(U);
              for (let V = 0; V < w; ++V) {
                const $ = document.createElement("div");
                $.classList.add("neuroglancer-selected-annotation-details-position-coord"), $.style.gridColumn = `coord ${V + 1}`, $.textContent = Math.floor(F[V]).toString(), b.appendChild($);
              }
              if (!q) {
                const V = lI({
                  title: "Move to position",
                  onClick: () => {
                    t2(this, u, F);
                  }
                });
                V.style.gridColumn = "move", b.appendChild(V);
              }
            });
          }
          if (!a.source.readonly) {
            const O = ms({
              title: "Delete annotation",
              onClick: () => {
                a.source.delete(l);
              }
            });
            O.classList.add("neuroglancer-selected-annotation-details-delete"), b.appendChild(O);
          }
          var y = a.source;
          const I = y.relationships, R = y.properties, P = a.source.readonly;
          for (let O = 0, F = R.length; O < F; ++O) {
            const q = R[O], U = document.createElement("label");
            U.classList.add("neuroglancer-annotation-property");
            const V = document.createElement("span");
            V.classList.add("neuroglancer-annotation-property-label"), V.textContent = q.identifier, U.appendChild(V);
            const $ = q.description;
            $ !== void 0 && (U.title = $);
            const B = d.properties[O], ue = document.createElement("span");
            switch (ue.classList.add("neuroglancer-annotation-property-value"), q.type) {
              case "rgb": {
                const se = Xs(B), Pe = Hn(se);
                ue.textContent = Pe, ue.style.backgroundColor = Pe, ue.style.color = cu(se) ? "white" : "black";
                break;
              }
              case "rgba": {
                const se = Xs(B);
                ue.textContent = Hn(dh(B)), ue.style.backgroundColor = Hn(Xs(B)), ue.style.color = cu(se) ? "white" : "black";
                break;
              }
              default:
                ue.textContent = eL(q, B);
                break;
            }
            U.appendChild(ue), h.appendChild(U);
          }
          var C = d;
          const L = C.relatedSegments;
          for (let O = 0, F = I.length; O < F; ++O) {
            const q = L === void 0 ? [] : L[O];
            if (q.length === 0 && P) continue;
            const U = O, V = I[O];
            h.appendChild(g.registerDisposer(OH(V, q, a.displayState.relationshipStates.get(V).segmentationState, P ? void 0 : ($) => {
              const B = l.value;
              if (B == null)
                return;
              let ue = B.relatedSegments;
              ue === void 0 ? ue = a.source.relationships.map(() => []) : ue = ue.slice(), ue[U] = $;
              const se = H(H({}, B), { relatedSegments: ue });
              a.source.update(l, se), a.source.commit(l);
            })).element);
          }
          let A = null, M = a.source;
          if (M instanceof Fi && M.makeEditWidget && (A = M.makeEditWidget(l), A && (A.className = "neuroglancer-annotation-details-description", h.appendChild(A))), (!a.source.readonly || d.description) && A === null)
            if (a.source.readonly) {
              const O = document.createElement("div");
              O.className = "neuroglancer-annotation-details-description", O.textContent = d.description || "", h.appendChild(O);
            } else {
              const O = document.createElement("textarea");
              O.value = d.description || "", O.rows = 3, O.className = "neuroglancer-annotation-details-description", O.placeholder = "Description", O.addEventListener("change", () => {
                const F = O.value;
                a.source.update(l, H(H({}, d), { description: F || void 0 })), a.source.commit(l);
              }), h.appendChild(O);
            }
        }
        if (v !== void 0) {
          const w = document.createElement("div");
          w.classList.add("neuroglancer-selection-annotation-status"), w.textContent = v, h.appendChild(w);
        }
      })).element), true;
    }
    displaySelectionState(n, r, s) {
      let a = this.displayAnnotationState(n, r, s);
      return super.displaySelectionState(n, r, s) && (a = true), a;
    }
    addLocalAnnotations(n, r, s) {
      const a = n.subsourceEntry, l = new $m({
        localPosition: this.localPosition,
        transform: n.getRenderLayerTransform(),
        source: r,
        displayState: this.annotationDisplayState,
        dataSource: n.loadedDataSource.layerDataSource,
        subsourceIndex: n.subsourceIndex,
        subsourceId: a.id,
        role: s
      });
      this.addAnnotationLayerState(l, n);
    }
    addStaticAnnotations(n) {
      const s = n.subsourceEntry.subsource.staticAnnotations;
      return s === void 0 ? false : (n.activate(() => {
        this.addLocalAnnotations(n, s, Ei.DEFAULT_ANNOTATION);
      }), true);
    }
    addAnnotationLayerState(n, r) {
      const s = r.activated;
      s.registerDisposer(this.annotationStates.add(n));
      const a = new TH(this.manager.chunkManager, n.addRef());
      if (a.source instanceof Fi) {
        const l = new IH({
          annotationLayer: a.addRef(),
          renderScaleTarget: this.annotationCrossSectionRenderScaleTarget,
          renderScaleHistogram: this.annotationCrossSectionRenderScaleHistogram
        });
        s.registerDisposer(r.messages.addChild(l.messages));
        const d = new DH({
          annotationLayer: a.addRef(),
          renderScaleTarget: this.annotationProjectionRenderScaleTarget,
          renderScaleHistogram: this.annotationProjectionRenderScaleHistogram
        });
        s.registerDisposer(r.messages.addChild(d.messages)), s.registerDisposer(Or((u, h) => {
          h && (u.registerDisposer(this.addRenderLayer(l.addRef())), u.registerDisposer(this.addRenderLayer(d.addRef())));
        }, this.annotationDisplayState.displayUnfiltered));
      }
      {
        const l = new PH(a, this.annotationCrossSectionRenderScaleHistogram);
        s.registerDisposer(this.addRenderLayer(l)), s.registerDisposer(r.messages.addChild(l.messages));
      }
      {
        const l = new LH(a.addRef(), this.annotationProjectionRenderScaleHistogram);
        s.registerDisposer(this.addRenderLayer(l)), s.registerDisposer(r.messages.addChild(l.messages));
      }
    }
    selectAnnotation(n, r, s, a = true) {
      this.manager.root.selectionState.captureSingleLayerState(this, (l) => (l.annotationId = r, l.annotationSourceIndex = n.sourceIndex, l.annotationSubsource = n.subsourceId, true), s, a);
    }
    toJSON() {
      const n = super.toJSON();
      return n[rk] = this.annotationDisplayState.color.toJSON(), n;
    }
  }
  return e;
}
var sk = St.fromObject({
  "shift?+mousedown0": { action: "set" },
  "shift?+alt+mousedown0": { action: "adjust-window-via-drag" },
  "shift?+wheel": { action: "zoom-via-wheel" }
});
var h2 = class extends X {
  constructor(e, t, n, r) {
    super(), this.element = e, this.dataType = t, this.getModel = n, this.setModel = r, e.title = sk.describe(), this.registerDisposer(new Hr(e, sk)), Ce(e, "set", (s) => {
      const a = s.detail, l = this.getModel(), d = this.getTargetValue(a);
      if (d === void 0) return;
      const u = Hl(l.window, l.range), h = SO(u, d), g = (v) => {
        const y = this.getModel();
        this.setModel(Uu(y, "range", h, v));
      };
      g(d), Ui(a, (v) => {
        const y = this.getTargetValue(v);
        y !== void 0 && g(y);
      });
    }), Ce(e, "adjust-window-via-drag", (s) => {
      const a = s.detail, l = this.getTargetFraction(a), d = this.getWindowLerp(l), u = l < 0.5 ? 0 : 1, h = (g) => {
        const v = this.getModel();
        this.setModel(Uu(v, "window", u, g));
      };
      Ui(a, (g) => {
        const v = this.getModel().window, y = this.getTargetFraction(g);
        h(u === 0 ? Ir([d, v[1]], this.dataType, -y / (1 - y)) : Ir([v[0], d], this.dataType, 1 / y));
      });
    }), Ce(e, "zoom-via-wheel", (s) => {
      const a = s.detail, l = Iu(a), d = this.getTargetFraction(a), u = this.dataType, h = this.getModel(), g = Ir(h.window, u, d * (1 - l)), v = Ir(h.window, u, (1 - d) * l + d);
      this.setModel(H(H({}, h), { window: [g, v], range: h.range }));
    });
  }
  getTargetFraction(e) {
    const t = this.element.getBoundingClientRect();
    return (e.clientX - t.left) / t.width;
  }
  getWindowLerp(e) {
    return Ir(this.getModel().window, this.dataType, e);
  }
  getTargetValue(e) {
    const t = this.getTargetFraction(e);
    if (Lt(t))
      return this.getWindowLerp(t);
  }
};
var ak = li("histogramSamplerTexture");
function Uu(i, e, t, n, r = false) {
  const s = H({}, i), a = i[e];
  if (s[e] = [a[0], a[1]], s[e][t] = n, e === "window" && xi(n, a[1 - t]) * (2 * t - 1) < 0 && (s[e][1 - t] = n), e === "range" && r) {
    const l = [i.window[0], i.window[1]];
    for (let d = 0; d < 2; ++d)
      xi(n, l[d]) * (2 * d - 1) > 0 && (l[d] = n);
    s.window = l;
  }
  return s;
}
var VH = 254;
var Ul = VH + 1;
var BH = class extends RL {
  constructor(e) {
    super(e.display, document.createElement("div"), e.visibility), this.parent = e, this.controller = this.registerDisposer(new h2(this.element, this.parent.dataType, () => this.parent.trackable.value, (n) => {
      this.parent.trackable.value = n;
    })), this.dataValuesBuffer = this.registerDisposer(ac(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, () => {
      const n = new Uint8Array(Ul * gs);
      for (let r = 0; r < Ul; ++r)
        for (let s = 0; s < gs; ++s)
          n[r * gs + s] = r;
      return n;
    })).value, this.lineShader = this.registerDisposer((() => {
      const n = new ra(this.gl);
      return dr(n), n.addTextureSampler("sampler2D", "uHistogramSampler", ak), n.addOutputBuffer("vec4", "out_color", 0), n.addAttribute("uint", "aDataValue"), n.addUniform("float", "uBoundsFraction"), n.addVertexCode(`
float getCount(int i) {
  return texelFetch(uHistogramSampler, ivec2(i, 0), 0).x;
}
vec4 getVertex(float cdf, int i) {
  float x;
  if (i == 0) {
    x = -1.0;
  } else if (i == 255) {
    x = 1.0;
  } else {
    x = float(i) / 254.0 * uBoundsFraction * 2.0 - 1.0;
  }
  return vec4(x, cdf * (2.0 - uLineParams.y) - 1.0 + uLineParams.y * 0.5, 0.0, 1.0);
}
`), n.setVertexMain(`
int lineNumber = int(aDataValue);
int dataValue = lineNumber;
float cumSum = 0.0;
for (int i = 0; i <= dataValue; ++i) {
  cumSum += getCount(i);
}
float total = cumSum + getCount(dataValue + 1);
float cumSumEnd = dataValue == ${Ul - 1} ? cumSum : total;
if (dataValue == ${Ul - 1}) {
  cumSum + getCount(dataValue + 1);
}
for (int i = dataValue + 2; i < 256; ++i) {
  total += getCount(i);
}
total = max(total, 1.0);
float cdf1 = cumSum / total;
float cdf2 = cumSumEnd / total;
emitLine(getVertex(cdf1, lineNumber), getVertex(cdf2, lineNumber + 1), 1.0);
`), n.setFragmentMain(`
out_color = vec4(0.0, 1.0, 1.0, getLineAlpha());
`), n.build();
    })()), this.regionCornersBuffer = oc(this.gl, 0, -1, 1, 1), this.regionShader = this.registerDisposer((() => {
      const n = new ra(this.gl);
      return n.addAttribute("vec2", "aVertexPosition"), n.addUniform("vec2", "uBounds"), n.addUniform("vec4", "uColor"), n.addOutputBuffer("vec4", "out_color", 0), n.setVertexMain(`
gl_Position = vec4(mix(uBounds[0], uBounds[1], aVertexPosition.x) * 2.0 - 1.0, aVertexPosition.y, 0.0, 1.0);
`), n.setFragmentMain(`
out_color = uColor;
`), n.build();
    })()), this.element.classList.add("neuroglancer-invlerp-cdfpanel");
  }
  get drawOrder() {
    return 100;
  }
  drawIndirect() {
    const e = this.lineShader, t = this.gl, n = this.regionShader;
    var r = this.parent;
    const s = r.dataType, a = r.trackable.value;
    this.setGLLogicalViewport(), t.clearColor(0, 0, 0, 0), t.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT), t.enable(WebGL2RenderingContext.BLEND), t.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA), t.disable(WebGL2RenderingContext.DEPTH_TEST), t.disable(WebGL2RenderingContext.STENCIL_TEST);
    {
      n.bind(), t.uniform4f(n.uniform("uColor"), 0.2, 0.2, 0.2, 1);
      const l = pi(a.window, a.range[0]), d = pi(a.window, a.range[1]), u = fu(s, a.window);
      t.uniform2f(n.uniform("uBounds"), Math.min(l, d) * u, Math.max(l, d) * u + (1 - u));
      const h = n.attribute("aVertexPosition");
      this.regionCornersBuffer.bindToVertexAttrib(
        h,
        /*componentsPerVertexAttribute=*/
        2,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT
      ), t.drawArrays(WebGL2RenderingContext.TRIANGLE_FAN, 0, 4), t.disableVertexAttribArray(h);
    }
    if (this.parent.histogramSpecifications.producerVisibility.visible) {
      const l = this.renderViewport;
      e.bind(), hr(
        e,
        { width: l.logicalWidth, height: l.logicalHeight },
        /*featherWidthInPixels=*/
        1
      );
      const d = e.textureUnit(ak);
      t.uniform1f(e.uniform("uBoundsFraction"), fu(s, a.window)), t.activeTexture(WebGL2RenderingContext.TEXTURE0 + d), t.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.parent.texture), yo(t);
      const u = e.attribute("aDataValue");
      this.dataValuesBuffer.bindToVertexAttribI(
        u,
        /*componentsPerVertexAttribute=*/
        1,
        /*attributeType=*/
        WebGL2RenderingContext.UNSIGNED_BYTE
      ), ur(
        t,
        /*linesPerInstance=*/
        Ul,
        /*numInstances=*/
        1
      ), t.disableVertexAttribArray(u), t.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
    }
    t.disable(WebGL2RenderingContext.BLEND);
  }
  isReady() {
    return true;
  }
};
function FH() {
}
var UH = class extends RL {
  constructor(e) {
    super(e.display, document.createElement("div"), e.visibility), this.parent = e, this.cornersBuffer = oc(this.gl, -1, -1, 1, 1), this.element.classList.add("neuroglancer-invlerp-legend-panel");
    const n = this.shaderOptions = e.legendShaderOptions;
    this.shaderGetter = vo(this, this.gl, H(H({}, n), { memoizeKey: { id: "colorLegendShader", base: n.memoizeKey }, defineShader: (r, s, a) => {
      r.addOutputBuffer("vec4", "v4f_fragData0", 0), r.addAttribute("vec2", "aVertexPosition"), r.addUniform("float", "uLegendOffset"), r.addVarying("float", "vLinearPosition"), r.setVertexMain(`
gl_Position = vec4(aVertexPosition, 0.0, 1.0);
vLinearPosition = -uLegendOffset + ((aVertexPosition.x + 1.0) * 0.5) * (1.0 + 2.0 * uLegendOffset);
`);
      const l = this.parent.dataType, d = xn(l);
      r.addFragmentCode(JB(r, "ng_colorLegendLerp", l)), r.addFragmentCode(`
void emit(vec4 v) {
  v4f_fragData0 = v;
}
${d} getDataValue() {
  return ng_colorLegendLerp(vLinearPosition);
}
${d} getDataValue(int dummyChannel) {
  return getDataValue();
}
${d} getInterpolatedDataValue() {
  return getDataValue();
}
${d} getInterpolatedDataValue(int dummyChannel) {
  return getDataValue();
}
`), n.defineShader(r, s, a);
    } }));
  }
  drawIndirect() {
    const e = this.shaderGetter(FH), t = e.shader;
    if (t === null) return;
    this.setGLLogicalViewport();
    const n = this.gl;
    n.clearColor(0, 0, 0, 0), n.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT), t.bind(), this.shaderOptions.initializeShader(e), n.enable(WebGL2RenderingContext.BLEND);
    var r = this.parent;
    const s = r.trackable.value.window, a = r.dataType;
    Uy(t, "ng_colorLegendLerp", this.parent.dataType, s);
    const l = bO(a, s);
    n.uniform1f(t.uniform("uLegendOffset"), Lt(l) ? l : 0), n.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA), n.disable(WebGL2RenderingContext.DEPTH_TEST), n.disable(WebGL2RenderingContext.STENCIL_TEST);
    const d = t.attribute("aVertexPosition");
    this.cornersBuffer.bindToVertexAttrib(
      d,
      /*componentsPerVertexAttribute=*/
      2,
      /*attributeType=*/
      WebGL2RenderingContext.FLOAT
    ), n.drawArrays(WebGL2RenderingContext.TRIANGLE_FAN, 0, 4), n.disableVertexAttribArray(d);
  }
  isReady() {
    return true;
  }
};
function ok(i, e) {
  const t = document.createElement("input");
  return t.addEventListener("focus", () => {
    t.select();
  }), t.classList.add("neuroglancer-invlerp-widget-bound"), t.classList.add(`neuroglancer-invlerp-widget-${i}-bound`), t.type = "text", t.spellcheck = false, t.autocomplete = "off", t.title = i === "range" ? `Data value that maps to ${e}` : `${e === 0 ? "Lower" : "Upper"} bound for distribution`, t;
}
function lk(i, e, t) {
  const n = document.createElement("div");
  n.classList.add("neuroglancer-invlerp-widget-bounds"), n.classList.add(`neuroglancer-invlerp-widget-${i}-bounds`);
  const r = [ok(i, 0), ok(i, 1)];
  for (let a = 0; a < 2; ++a) {
    const l = r[a];
    l.addEventListener("input", () => {
      f2(l);
    }), l.addEventListener("change", () => {
      const d = t.value, u = d[i];
      try {
        const h = xc(e, l.value);
        t.value = Uu(
          d,
          i,
          a,
          h,
          /*fitRangeInWindow=*/
          true
        );
      } catch {
        Dv(l, u[a]);
      }
    });
  }
  let s;
  return n.appendChild(r[0]), n.appendChild(r[1]), i === "range" && (s = [document.createElement("div"), document.createElement("div"), document.createElement("div")], s[1].classList.add("neuroglancer-invlerp-widget-range-spacer"), n.insertBefore(s[0], r[0]), n.insertBefore(s[1], r[1]), n.appendChild(s[2])), { container: n, inputs: r, spacers: s };
}
function f2(i) {
  Xn(i, Math.max(1, i.value.length + 0.1));
}
function Dv(i, e) {
  let t;
  e instanceof re || jn(e) ? t = e.toString() : t = e.toPrecision(6), i.value = t, f2(i);
}
function p2(i) {
  const e = i.value, t = e.range;
  i.value = H(H({}, e), { range: [t[1], t[0]] });
}
function zH(i, e, t) {
  const n = e.value, r = Ir(n.range, i, 0.5 - t / 2), s = Ir(n.range, i, 0.5 + t / 2);
  e.value = H(H({}, n), { range: [r, s] });
}
function $H(i, e, t, n, r) {
  const s = Math.exp(r), a = e.value, l = Ir(t, i, 0.5 - s / 2 + n), d = Ir(t, i, 0.5 + s / 2 + n);
  e.value = H(H({}, a), { range: [l, d] });
}
var GH = class extends qr {
  constructor(e, t, n, r, s, a, l) {
    super(e), this.display = t, this.dataType = n, this.trackable = r, this.histogramSpecifications = s, this.histogramIndex = a, this.legendShaderOptions = l, this.cdfPanel = this.registerDisposer(new BH(this)), this.boundElements = {
      range: lk("range", this.dataType, this.trackable),
      window: lk("window", this.dataType, this.trackable)
    }, this.registerDisposer(s.visibility.add(this.visibility));
    const d = this.element, u = this.boundElements;
    if (l !== void 0) {
      const g = this.registerDisposer(new UH(this));
      d.appendChild(g.element);
    }
    const h = (g) => {
      const v = Tt({
        svg: g,
        title: "Invert range",
        onClick: () => {
          this.invertRange();
        }
      });
      return u.range.spacers[1].appendChild(v), v;
    };
    this.invertArrows = [h(tI), h(eI)], d.appendChild(u.range.container), d.appendChild(this.cdfPanel.element), d.classList.add("neuroglancer-invlerp-widget"), d.appendChild(u.window.container), this.updateView(), this.registerDisposer(r.changed.add(this.registerCancellable(Ct(() => this.updateView()))));
  }
  get texture() {
    return this.histogramSpecifications.getFramebuffers(this.display.gl)[this.histogramIndex].colorBuffers[0].texture;
  }
  invertRange() {
    p2(this.trackable);
  }
  updateView() {
    const e = this.boundElements, t = this.trackable.value, n = this.dataType;
    for (let g = 0; g < 2; ++g)
      Dv(e.range.inputs[g], t.range[g]), Dv(e.window.inputs[g], t.window[g]);
    const r = xi(t.range[0], t.range[1]) > 0;
    e.range.container.style.flexDirection = r ? "row-reverse" : "row";
    const s = Hl(t.window, t.range), a = e.range.spacers, l = fu(n, t.window), d = pi(t.window, s[r ? 1 : 0]) * l, u = pi(t.window, s[r ? 0 : 1]) * l + (1 - l);
    a[r ? 2 : 0].style.width = `${d * 100}%`, a[r ? 0 : 2].style.width = `${(1 - u) * 100}%`;
    const h = this.invertArrows;
    h[r ? 1 : 0].style.display = "", h[r ? 0 : 1].style.display = "none";
  }
};
var FS = "mergeSegments";
var US = "splitSegments";
var WH = St.fromObject({
  "at:shift?+mousedown0": { action: "merge-segments" },
  "at:shift?+mousedown2": { action: "set-anchor" }
});
var HH = St.fromObject({
  "at:shift?+mousedown0": { action: "split-segments" },
  "at:shift?+alt+mousedown0": { action: "split-and-select-segments" },
  "at:shift?+mousedown2": { action: "set-anchor" }
});
var qH = class extends Po {
  constructor(e) {
    super(e), this.lastAnchorBaseSegment = new vt(void 0);
    const t = () => {
      const n = e.anchorSegment.value;
      if (n === void 0) return;
      const r = e.displayState.segmentSelectionState;
      if (!r.hasSelectedSegment) return;
      const s = e.displayState.segmentationGroupState.value.segmentEquivalences, a = s.get(n);
      if (!re.equal(r.selectedSegment, a)) return;
      const l = r.baseSelectedSegment, d = zF(l), u = s.disjointSets.visibleSegmentEquivalencePolicy.value;
      u & Bi.NONREPRESENTATIVE_EXCLUDED && d || u & Bi.REPRESENTATIVE_EXCLUDED && !d || (this.lastAnchorBaseSegment.value = l.clone());
    };
    this.registerDisposer(e.displayState.segmentSelectionState.changed.add(t)), this.registerDisposer(e.anchorSegment.changed.add(t));
  }
  toJSON() {
    return FS;
  }
  activate(e) {
    const t = this.layer.displayState.segmentationGroupState.value, n = () => {
      let h = this.layer.anchorSegment.value, g = this.lastAnchorBaseSegment.value;
      if (h === void 0)
        return { anchorSegment: void 0, error: "Select anchor segment for merge" };
      const v = t.segmentEquivalences.get(h);
      return t.visibleSegments.has(v) ? g === void 0 || !re.equal(t.segmentEquivalences.get(g), v) ? {
        anchorSegment: h,
        error: "Hover over base segment within anchor segment that is closest to merge location"
      } : { anchorSegment: g, error: void 0 } : { anchorSegment: h, error: "Anchor segment must be in visible set" };
    }, r = () => {
      var h = n();
      let g = h.anchorSegment, v = h.error;
      if (g === void 0 || v !== void 0)
        return { anchorSegment: g, error: v, otherSegment: void 0, anchorSegmentValid: false };
      const y = this.layer.displayState, C = y.segmentSelectionState.baseValue;
      return C === void 0 || re.equal(y.segmentSelectionState.selectedSegment, t.segmentEquivalences.get(g)) ? {
        anchorSegment: g,
        otherSegment: void 0,
        error: "Hover over segment to merge",
        anchorSegmentValid: true
      } : { anchorSegment: g, otherSegment: C, error: void 0, anchorSegmentValid: true };
    };
    var s = Mh(e);
    const a = s.body, l = s.header;
    l.textContent = "Merge segments", a.classList.add("neuroglancer-merge-segments-status"), e.bindInputEventMap(WH), e.registerDisposer(() => {
      fc(t);
    });
    const d = () => {
      st(a);
      const h = this.layer.displayState;
      var g = r();
      let v = g.anchorSegment, y = g.otherSegment, C = g.anchorSegmentValid, w = g.error;
      const b = (T) => {
        const I = Dh(this.layer.displayState, T);
        return I.classList.add("neuroglancer-segment-list-entry-double-line"), I;
      };
      if (v !== void 0 && a.appendChild(b(aa(h, v))), w !== void 0) {
        const T = document.createElement("span");
        T.textContent = w, a.appendChild(T);
      }
      if (y !== void 0) {
        const T = document.createElement("span");
        T.textContent = " merge ", a.appendChild(T), a.appendChild(b(aa(h, y)));
      }
      const E = t.segmentEquivalences;
      if (C) {
        t.useTemporaryVisibleSegments.value = true;
        const T = t.temporaryVisibleSegments;
        T.clear(), T.add(E.get(v)), y !== void 0 && T.add(E.get(y));
      } else {
        fc(t);
        return;
      }
    };
    d(), e.registerDisposer(Do(this.layer.displayState, a));
    const u = e.registerCancellable(Ct(d));
    jo(this.layer.displayState, e, u), e.registerDisposer(this.layer.anchorSegment.changed.add(u)), e.registerDisposer(this.lastAnchorBaseSegment.changed.add(u)), e.bindAction("merge-segments", (h) => {
      h.stopPropagation(), (async () => {
        const g = t.graph.value;
        if (g === void 0) return;
        var v = r();
        const y = v.anchorSegment, C = v.otherSegment, w = v.error;
        if (!(y === void 0 || C === void 0 || w !== void 0))
          try {
            await g.merge(y, C), rt.showTemporaryMessage("Merge performed");
          } catch (b) {
            rt.showTemporaryMessage(`Merge failed: ${b}`);
          }
      })();
    }), e.bindAction("set-anchor", (h) => {
      h.stopPropagation();
      const v = this.layer.displayState.segmentSelectionState.baseValue;
      if (v === void 0) return;
      const y = this.layer.anchorSegment.value;
      if (t.visibleSegments.add(v), y === void 0 || !re.equal(y, v)) {
        this.layer.anchorSegment.value = v.clone();
        return;
      }
    });
  }
  get description() {
    return "merge";
  }
};
var jH = class extends Po {
  toJSON() {
    return US;
  }
  activate(e) {
    const t = this.layer.displayState.segmentationGroupState.value, n = () => {
      let g = this.layer.anchorSegment.value;
      if (g === void 0)
        return { anchorSegment: void 0, error: "Select anchor segment for split" };
      const v = t.segmentEquivalences.get(g);
      return t.visibleSegments.has(v) ? { anchorSegment: g, error: void 0 } : { anchorSegment: g, error: "Anchor segment must be in visible set" };
    };
    var r = Mh(e);
    const s = r.body, a = r.header;
    a.textContent = "Split segments", s.classList.add("neuroglancer-merge-segments-status"), e.bindInputEventMap(HH);
    const l = () => {
      var g = n();
      let v = g.anchorSegment, y = g.error;
      if (v === void 0 || y !== void 0)
        return { anchorSegment: v, error: y, otherSegment: void 0, anchorSegmentValid: false };
      const C = this.layer.displayState, w = C.segmentSelectionState.baseValue;
      return w === void 0 || !re.equal(C.segmentSelectionState.selectedSegment, t.segmentEquivalences.get(v)) || re.equal(w, v) ? {
        anchorSegment: v,
        otherSegment: void 0,
        anchorSegmentValid: true,
        error: "Hover over base segment to seed split"
      } : { anchorSegment: v, otherSegment: w, anchorSegmentValid: true, error: void 0 };
    };
    e.registerDisposer(() => {
      fc(t);
    });
    const d = () => {
      st(s);
      const g = this.layer.displayState;
      var v = l();
      let y = v.anchorSegment, C = v.otherSegment, w = v.anchorSegmentValid, b = v.error, E, T;
      (() => {
        const P = t.segmentEquivalences, L = this.layer.graphConnection;
        if (!w || L === void 0) {
          fc(t);
          return;
        } else {
          if (t.useTemporaryVisibleSegments.value = true, C !== void 0) {
            const M = L.computeSplit(y, C);
            if (M !== void 0) {
              E = new Fr(y, M.includeRepresentative), T = new Fr(C, M.excludeRepresentative), t.useTemporarySegmentEquivalences.value = true;
              const O = M.includeRepresentative, F = M.excludeRepresentative, q = t.temporarySegmentEquivalences;
              q.clear();
              for (const V of M.includeBaseSegments)
                q.link(V, O);
              for (const V of M.excludeBaseSegments)
                q.link(V, F);
              const U = t.temporaryVisibleSegments;
              U.clear(), U.add(O), U.add(F);
              return;
            }
          }
          t.useTemporarySegmentEquivalences.value = false;
          const A = t.temporaryVisibleSegments;
          A.clear(), A.add(P.get(y));
        }
      })();
      const R = (P) => {
        const L = Dh(this.layer.displayState, P);
        return L.classList.add("neuroglancer-segment-list-entry-double-line"), L;
      };
      if (y !== void 0 && s.appendChild(R(E ?? aa(g, y))), b !== void 0) {
        const P = document.createElement("span");
        P.textContent = b, s.appendChild(P);
      }
      if (T !== void 0) {
        const P = document.createElement("span");
        P.textContent = " split ", s.appendChild(P), s.appendChild(R(T));
      }
    };
    e.registerDisposer(Do(this.layer.displayState, s)), d();
    const u = e.registerCancellable(Ct(d));
    jo(this.layer.displayState, e, u), e.registerDisposer(this.layer.anchorSegment.changed.add(u));
    const h = async (g) => {
      const v = t.graph.value;
      if (v === void 0) return;
      var y = l();
      const C = y.anchorSegment, w = y.otherSegment, b = y.error;
      if (!(C === void 0 || w === void 0 || b !== void 0))
        try {
          await v.split(C, w), g && t.visibleSegments.add(t.segmentEquivalences.get(w)), rt.showTemporaryMessage("Split performed");
        } catch (E) {
          rt.showTemporaryMessage(`Split failed: ${E}`);
        }
    };
    e.bindAction("split-segments", (g) => {
      g.stopPropagation(), h(
        /*select=*/
        false
      );
    }), e.bindAction("split-and-select-segments", (g) => {
      g.stopPropagation(), h(
        /*select=*/
        true
      );
    }), e.bindAction("set-anchor", (g) => {
      g.stopPropagation();
      const y = this.layer.displayState.segmentSelectionState.baseValue;
      if (y === void 0) return;
      t.visibleSegments.add(y);
      const C = this.layer.anchorSegment.value;
      if (C === void 0 || !re.equal(C, y)) {
        this.layer.anchorSegment.value = y.clone();
        return;
      }
    });
  }
  get description() {
    return "split";
  }
};
function JH() {
  gc(Mn, FS, (i) => new qH(i)), gc(Mn, US, (i) => new jH(i));
}
var zS = "selectSegments";
var Iv = "mousedown0";
var KH = St.fromObject({
  [`at:alt?+shift?+${Iv}`]: "drag-select-segments"
});
var $n;
(function(i) {
  i[i.IDLE = 0] = "IDLE", i[i.SELECT = 1] = "SELECT", i[i.DESELECT = 2] = "DESELECT";
})($n || ($n = {}));
var YH = class extends Po {
  constructor(e) {
    super(e);
  }
  toJSON() {
    return zS;
  }
  activate(e) {
    const t = this.layer;
    var n = Mh(e);
    const r = n.body, s = n.header;
    let a = $n.IDLE, l = false;
    e.bindInputEventMap(KH);
    const d = () => Du.value & 2 ? $n.DESELECT : $n.SELECT, u = (y) => {
      a !== y && (a = y, l = false, h());
    }, h = () => {
      st(r);
      const y = document.createElement("span");
      switch (a) {
        case $n.IDLE:
          s.textContent = "Select/Deselect segments", y.textContent = `${Iv} to select segments; alt+${Iv} to deselect segments.`;
          break;
        case $n.SELECT:
        case $n.DESELECT:
          s.textContent = `${a == $n.SELECT ? "Select" : "Deselect"} segments`, y.textContent = `Drag to ${a == $n.SELECT ? "select" : "deselect"} segments (${t.displayState.segmentationGroupState.value.visibleSegments.size} selected).`;
      }
      r.appendChild(y);
    };
    h();
    const g = () => {
      if (a == $n.IDLE)
        return;
      const y = t.displayState.segmentSelectionState;
      if (y.hasSelectedSegment) {
        const C = y.selectedSegment, w = t.displayState.segmentationGroupState.value.visibleSegments;
        switch (a) {
          case $n.SELECT:
            w.add(C);
            break;
          case $n.DESELECT:
            w.delete(C);
            break;
        }
      }
    };
    e.registerDisposer(t.displayState.segmentSelectionState.changed.add(() => {
      l && g();
    })), e.registerDisposer(t.displayState.segmentationGroupState.value.visibleSegments.changed.add(h)), e.registerDisposer(Du.changed.add(() => {
      a != $n.IDLE && u(d());
    }));
    const v = (y, C) => {
      y.stopPropagation(), u(C), g();
      const w = y.detail.screenX, b = y.detail.screenY;
      Ui(y.detail, (E, T, I) => {
        if (!l) {
          const R = E.screenX - w, P = E.screenY - b;
          R * R + P * P > 25 && (g(), l = true);
        }
      }, (E) => {
        l = false, u($n.IDLE);
      });
    };
    e.bindAction("drag-select-segments", (y) => v(y, d()));
  }
  get description() {
    return "select";
  }
};
function XH() {
  gc(Mn, zS, (i) => new YH(i));
}
var ZH = new re();
var QH = class extends X {
  constructor(e, t, n, r) {
    super(), this.query = e, this.segmentPropertyMap = t, this.segmentationDisplayState = n, this.parentElement = r, this.changed = new ct(), this.explicitSegmentsVisible = false, this.visibleSegmentsGeneration = -1, this.queryResult = new vt(void 0), this.statusText = new vt(""), this.selectedMatches = 0, this.matchStatusTextPrefix = "", this.debouncedUpdate = dt(() => this.update(), 0), this.render = (s) => {
      const a = this.explicitSegments;
      let l, d = false;
      if (a !== void 0 && s < a.length)
        l = a[s], d = this.explicitSegmentsVisible;
      else {
        a !== void 0 && (s -= a.length), l = ZH;
        const h = this.queryResult.value.indices[s], g = this.segmentPropertyMap.segmentPropertyMap.inlineProperties.ids;
        l.low = g[h * 2], l.high = g[h * 2 + 1];
      }
      const u = this.segmentWidgetFactory.get(l);
      return d && (u.dataset.visibleList = "true"), u;
    }, this.update(), this.registerDisposer(n.segmentationGroupState.value.visibleSegments.changed.add(this.debouncedUpdate)), this.registerDisposer(e.changed.add(this.debouncedUpdate));
  }
  get numMatches() {
    var e, t;
    return (t = (e = this.queryResult.value) === null || e === void 0 ? void 0 : e.count) !== null && t !== void 0 ? t : 0;
  }
  update() {
    var e;
    const t = this.query.value, n = this.segmentPropertyMap, r = this.queryResult.value;
    let s;
    if (this.prevQuery === t)
      s = r;
    else {
      const b = EW(n, t);
      s = kW(n, b);
    }
    const a = [];
    let l = false, d = "";
    const u = this.segmentationDisplayState.segmentationGroupState.value.visibleSegments, h = u.changed.count, g = this.visibleSegmentsGeneration, v = PW(s.query);
    if (v) {
      if (g !== h || this.explicitSegments === void 0 || !this.explicitSegmentsVisible) {
        this.visibleSegmentsGeneration = h;
        const b = _e(u, (T) => T.clone());
        b.sort(re.compare);
        const E = this.explicitSegments;
        E === void 0 ? (this.explicitSegments = b, a.push({ retainCount: 0, insertCount: b.length, deleteCount: 0 })) : a.push(...jM(E, b, re.compare)), this.explicitSegments = b, l = true;
      } else
        a.push({ retainCount: this.explicitSegments.length, deleteCount: 0, insertCount: 0 });
      this.explicitSegmentsVisible = true;
    } else
      this.visibleSegmentsGeneration = h, this.explicitSegments !== void 0 && this.explicitSegmentsVisible && (a.push({ deleteCount: this.explicitSegments.length, retainCount: 0, insertCount: 0 }), this.explicitSegments = void 0, l = true), this.explicitSegmentsVisible = false;
    var y = s;
    const C = y.explicitIds;
    if (C !== void 0 ? this.explicitSegments = C : this.explicitSegmentsVisible || (this.explicitSegments = void 0), r !== s && (a.push({
      retainCount: 0,
      deleteCount: (e = r == null ? void 0 : r.count) !== null && e !== void 0 ? e : 0,
      insertCount: s.count
    }), l = true, this.queryResult.value = s), s.explicitIds !== void 0 ? d = `${s.count} ids` : v ? d = `${s.count} listed ids` : s.total > 0 && (d = `${s.count}/${s.total} matches`), r !== s || h !== g) {
      let b = d, E = 0;
      n !== void 0 && s.count > 0 && (E = IW(n, s, u), b += ` (${E} visible)`), this.selectedMatches = E, this.statusText.value = b;
    }
    this.prevQuery = t, this.matchStatusTextPrefix = d;
    const w = this.explicitSegments;
    this.length = (this.explicitSegmentsVisible ? w.length : 0) + s.count, l && this.changed.dispatch(a);
  }
  updateRendering(e) {
    this.segmentWidgetFactory.update(e);
  }
  updateRenderedItems(e) {
    e.forEachRenderedItem((t) => {
      this.updateRendering(t);
    });
  }
};
var ck = St.fromObject({
  enter: { action: "toggle-listed" },
  "shift+enter": { action: "hide-listed" },
  "control+enter": { action: "hide-all" },
  escape: { action: "cancel" }
});
var e6 = 100;
function g2(i) {
  Xn(i, Math.max(1, i.value.length + 0.1));
}
function cm(i, e) {
  let t;
  if (jn(e))
    t = e.toString();
  else {
    const n = e.toString(), r = e.toPrecision(6);
    t = n.length < r.length ? n : r;
  }
  i.value = t, g2(i);
}
function t6(i, e) {
  const t = document.createElement("input");
  return t.addEventListener("focus", () => {
    t.select();
  }), t.classList.add(`neuroglancer-segment-query-result-numerical-plot-${i}-bound`), t.classList.add("neuroglancer-segment-query-result-numerical-plot-bound"), t.type = "text", t.spellcheck = false, t.autocomplete = "off", t.title = (e === 0 ? "Lower" : "Upper") + " bound " + (i === "range" ? "range" : "for distribution"), t.addEventListener("input", () => {
    g2(t);
  }), t;
}
function n6(i, e, t) {
  if (i === void 0 || i.indices === void 0) return;
  const n = i.query;
  let r = n.sortBy, s = n.includeColumns;
  PS(n, t) ? (r = r.filter((l) => l.fieldId !== t), s = s.filter((l) => l !== t)) : s.push(t), e(H(H({}, n), { sortBy: r, includeColumns: s }));
}
function m2(i, e, t) {
  var n;
  const r = i == null ? void 0 : i.query, s = r == null ? void 0 : r.sortBy;
  if (s === void 0) return;
  const a = r.includeColumns, d = ((n = s.find((h) => h.fieldId === t)) === null || n === void 0 ? void 0 : n.order) === "<" ? ">" : "<", u = a.filter((h) => h !== t);
  for (const h of s)
    h.fieldId !== "id" && h.fieldId !== "label" && h.fieldId !== t && u.push(h.fieldId);
  e(H(H({}, r), { sortBy: [{ fieldId: t, order: d }], includeColumns: u }));
}
function v2(i, e, t) {
  var n, r;
  const s = (n = i == null ? void 0 : i.query) === null || n === void 0 ? void 0 : n.sortBy, a = (r = s == null ? void 0 : s.find((l) => l.fieldId === t)) === null || r === void 0 ? void 0 : r.order;
  e.textContent = a === ">" ? "▼" : "▲", e.style.visibility = a === void 0 ? "" : "visible", e.title = `Sort by ${t} in ${a === "<" ? "descending" : "ascending"} order`;
}
var i6 = class extends X {
  constructor(e, t, n) {
    super(), this.segmentPropertyMap = e, this.queryResult = t, this.setQuery = n, this.propertyHistograms = [], this.bounds = {
      window: new vt([]),
      range: new vt([])
    }, this.throttledUpdate = this.registerCancellable(wh(() => this.updateHistograms(), 100)), this.debouncedRender = this.registerCancellable(Ct(() => this.updateHistogramRenderings())), this.debouncedSetQuery = this.registerCancellable(dt(() => this.setQueryFromBounds(), 200));
    const r = e == null ? void 0 : e.numericalProperties, s = [];
    let a;
    if (r !== void 0 && r.length > 0) {
      a = document.createElement("details");
      const l = document.createElement("summary");
      l.textContent = `${r.length} numerical propert${r.length > 1 ? "ies" : "y"}`, a.appendChild(l), a.classList.add("neuroglancer-segment-query-result-numerical-list");
      const d = this.bounds.window.value;
      for (let u = 0, h = r.length; u < h; ++u) {
        const g = r[u], v = this.makeNumericalPropertySummary(u, g);
        s.push(v), a.appendChild(v.element), d[u] = g.bounds;
      }
    }
    this.listElement = a, this.properties = s, this.registerDisposer(this.queryResult.changed.add(() => {
      this.handleNewQueryResult();
    })), this.registerDisposer(this.bounds.window.changed.add(this.throttledUpdate)), this.registerDisposer(this.bounds.window.changed.add(this.debouncedRender)), this.registerDisposer(this.bounds.range.changed.add(this.debouncedRender)), this.registerDisposer(this.bounds.range.changed.add(this.debouncedSetQuery)), this.handleNewQueryResult();
  }
  setQueryFromBounds() {
    const e = this.queryResult.value;
    if (e === void 0 || e.indices === void 0) return;
    const t = e.query, n = [], r = this.bounds.range.value, s = this.properties;
    for (let a = 0, l = s.length; a < l; ++a) {
      const d = s[a].property;
      n.push({ fieldId: d.id, bounds: r[a] });
    }
    this.setQuery(H(H({}, t), { numericalConstraints: n }));
  }
  getBounds(e) {
    const t = this.bounds;
    return { range: t.range.value[e], window: t.window.value[e] };
  }
  setBounds(e, t) {
    const n = this.properties[e].property;
    let r = Hl(n.bounds, t.range);
    xi(r[0], r[1]) > 0 && (r = [r[1], r[0]]);
    const s = Hl(n.bounds, t.window), a = this.getBounds(e), l = this.properties[e].property.dataType;
    Pr(l, s, a.window) || (this.bounds.window.value[e] = s, this.bounds.window.changed.dispatch()), Pr(l, r, a.range) || (this.bounds.range.value[e] = r, this.bounds.range.changed.dispatch());
  }
  setBound(e, t, n, r) {
    const a = this.segmentPropertyMap.numericalProperties[n].bounds;
    r = tc(a, r);
    const l = this.getBounds(n), d = Uu(
      l,
      e,
      t,
      r,
      /*fitRangeInWindow=*/
      true
    );
    this.setBounds(n, d);
  }
  handleNewQueryResult() {
    const e = this.queryResult.value;
    if (this.listElement !== void 0) {
      if ((e == null ? void 0 : e.indices) !== void 0) {
        const n = e.query.numericalConstraints, r = this.segmentPropertyMap.numericalProperties, s = this.bounds.range.value, a = n.length, l = r.length;
        s.length = l;
        for (let d = 0; d < l; ++d)
          s[d] = r[d].bounds;
        for (let d = 0; d < a; ++d) {
          const u = n[d], h = r.findIndex((g) => g.id === u.fieldId);
          s[h] = u.bounds;
        }
      }
      this.updateHistograms(), this.throttledUpdate.cancel();
    }
  }
  updateHistograms() {
    const e = this.queryResult.value;
    this.listElement !== void 0 && (LW(this.segmentPropertyMap, e, this.propertyHistograms, this.bounds.window.value), this.updateHistogramRenderings());
  }
  updateHistogramRenderings() {
    this.debouncedRender.cancel();
    const e = this.listElement;
    if (e === void 0) return;
    const t = this.propertyHistograms;
    if (t.length === 0) {
      e.style.display = "none";
      return;
    }
    e.style.display = "";
    const n = this.properties;
    for (let r = 0, s = n.length; r < s; ++r)
      this.updateNumericalPropertySummary(r, n[r], t[r]);
  }
  makeNumericalPropertySummary(e, t) {
    const n = document.createElement("div");
    n.classList.add("neuroglancer-segment-query-result-numerical-plot-container");
    const r = document.createElement("img");
    r.classList.add("neuroglancer-segment-query-result-numerical-plot");
    const s = new h2(r, t.dataType, () => this.getBounds(e), (h) => this.setBounds(e, h)), a = document.createElement("span");
    a.classList.add("neuroglancer-segment-query-result-numerical-plot-sort");
    const l = document.createElement("input");
    l.type = "checkbox", l.addEventListener("click", () => {
      n6(this.queryResult.value, this.setQuery, t.id);
    });
    const d = (h) => {
      const g = document.createElement("div");
      g.classList.add("neuroglancer-segment-query-result-numerical-plot-bounds"), g.classList.add(`neuroglancer-segment-query-result-numerical-plot-bounds-${h}`);
      const v = (w) => {
        const b = t6(h, w);
        return b.addEventListener("change", () => {
          if (this.bounds[h].value[e] !== void 0) {
            try {
              const T = xc(t.dataType, b.value);
              this.setBound(h, w, e, T), this.bounds[h].changed.dispatch();
            } catch {
            }
            cm(b, this.bounds[h].value[e][w]);
          }
        }), b;
      }, y = [v(0), v(1)];
      let C;
      if (h === "range") {
        C = [document.createElement("div"), document.createElement("div"), document.createElement("div")], C[1].classList.add("neuroglancer-segment-query-result-numerical-plot-bound-constraint-spacer"), C[1].appendChild(l);
        const w = document.createElement("span");
        w.classList.add("neuroglancer-segment-query-result-numerical-plot-label"), w.appendChild(document.createTextNode(t.id)), w.appendChild(a), w.addEventListener("click", () => {
          m2(this.queryResult.value, this.setQuery, t.id);
        }), C[1].appendChild(w);
        const b = t.description;
        b && (C[1].title = b), g.appendChild(C[0]), g.appendChild(y[0]);
        const E = document.createElement("div");
        E.textContent = "≤", E.classList.add("neuroglancer-segment-query-result-numerical-plot-bound-constraint-symbol"), g.appendChild(E), g.appendChild(C[1]);
        const T = document.createElement("div");
        T.textContent = "≤", T.classList.add("neuroglancer-segment-query-result-numerical-plot-bound-constraint-symbol"), g.appendChild(T), g.appendChild(y[1]), g.appendChild(C[2]);
      } else
        g.appendChild(y[0]), g.appendChild(y[1]);
      return { container: g, spacers: C, inputs: y };
    }, u = {
      range: d("range"),
      window: d("window")
    };
    return n.appendChild(u.range.container), n.appendChild(r), n.appendChild(u.window.container), {
      property: t,
      controller: s,
      element: n,
      plotImg: r,
      boundElements: u,
      bounds: {
        window: [NaN, NaN],
        range: [NaN, NaN]
      },
      propertyHistogram: void 0,
      columnCheckbox: l,
      sortIcon: a
    };
  }
  updateNumericalPropertySummary(e, t, n) {
    const r = t.bounds.window, s = this.bounds.window.value[e], a = t.bounds.range, l = this.bounds.range.value[e], d = t.property, u = this.queryResult.value, h = PS(u == null ? void 0 : u.query, d.id);
    if (t.columnCheckbox.checked = h, t.columnCheckbox.title = h ? "Remove column from result table" : "Add column to result table", v2(u, t.sortIcon, d.id), t.propertyHistogram === n && Pr(d.dataType, r, s) && Pr(d.dataType, a, l))
      return;
    const g = n.histogram, v = "http://www.w3.org/2000/svg", y = document.createElementNS(v, "svg");
    y.setAttribute("width", "1"), y.setAttribute("height", "1"), y.setAttribute("preserveAspectRatio", "none");
    const C = document.createElementNS(v, "rect"), w = pi(s, l[0]), b = pi(s, l[1]);
    C.setAttribute("x", `${w}`), C.setAttribute("y", "0"), C.setAttribute("width", `${b - w}`), C.setAttribute("height", "1"), C.setAttribute("fill", "#4f4f4f"), y.appendChild(C);
    const E = g.length, T = (O, F, q) => {
      const U = document.createElementNS(v, "polyline");
      let V = "", $ = 0;
      for (let ae = O; ae < q; ++ae)
        $ += g[ae];
      if ($ === 0) return;
      const B = pi(s, n.window[0]), ue = pi(s, n.window[1]), se = (ae, Ee) => {
        const ce = ae / (E - 2), ge = B * (1 - ce) + ue * ce;
        V += ` ${ge},${1 - Ee}`;
      };
      O !== 0 && se(O, 0);
      let Pe = 0;
      for (let ae = O; ae < F; ++ae) {
        const Ee = g[ae];
        Pe += Ee, se(ae, Pe / $);
      }
      return U.setAttribute("fill", "none"), U.setAttribute("stroke-width", "1px"), U.setAttribute("points", V), U.setAttribute("vector-effect", "non-scaling-stroke"), U;
    };
    {
      const O = T(0, E - 1, E);
      O !== void 0 && (O.setAttribute("stroke", "cyan"), y.appendChild(O));
    }
    if (!Pr(d.dataType, d.bounds, l)) {
      const O = Math.floor(Math.max(0, Math.min(1, pi(n.window, l[0]))) * (E - 2)), F = Math.ceil(Math.max(0, Math.min(1, pi(n.window, l[1]))) * (E - 2)), q = T(O, F, F);
      q !== void 0 && (q.setAttribute("stroke", "white"), y.appendChild(q));
    }
    const I = new XMLSerializer().serializeToString(y);
    t.plotImg.src = `data:image/svg+xml;base64,${btoa(I)}`, t.propertyHistogram = n;
    for (let O = 0; O < 2; ++O)
      r[O] = s[O], cm(t.boundElements.window.inputs[O], s[O]), a[O] = l[O], cm(t.boundElements.range.inputs[O], l[O]);
    const R = t.boundElements.range.spacers, P = Hl(s, l), L = fu(d.dataType, s), A = pi(s, P[0]) * L, M = pi(s, P[1]) * L + (1 - L);
    R[0].style.width = `${A * 100}%`, R[2].style.width = `${(1 - M) * 100}%`;
  }
};
function r6(i, e) {
  const t = i.tags;
  if (t === void 0 || t.length === 0) return;
  const n = i.query, r = document.createElement("div");
  r.classList.add("neuroglancer-segment-query-result-tag-list");
  for (const s of t) {
    const a = s.tag, l = s.count, d = document.createElement("div");
    d.classList.add("neuroglancer-segment-query-result-tag");
    const u = document.createElement("span");
    u.classList.add("neuroglancer-segment-query-result-tag-name"), u.textContent = a, r.appendChild(d);
    const h = n.includeTags.includes(a), g = n.excludeTags.includes(a);
    let v;
    h ? v = "Remove tag from required set" : g ? v = "Remove tag from excluded set" : v = "Add tag to required set", u.addEventListener("click", () => {
      e(HE(n, a, true, !h && !g));
    }), u.title = v;
    const y = h || g, C = (b) => {
      const E = b ? l : i.count - l, T = document.createElement("div");
      if (T.classList.add("neuroglancer-segment-query-result-tag-toggle"), T.classList.add(`neuroglancer-segment-query-result-tag-${b ? "include" : "exclude"}`), d.appendChild(T), !y && E === 0) return;
      const I = b ? h : g;
      T.appendChild(new Qi({
        get value() {
          return I;
        },
        set value(R) {
          e(HE(n, a, b, R));
        },
        changed: pT
      }, {
        text: b ? "+" : "-",
        enableTitle: `Add tag to ${b ? "required" : "exclusion"} set`,
        disableTitle: `Remove tag from ${b ? "required" : "exclusion"} set`,
        backgroundScheme: "dark"
      }).element);
    };
    C(true), C(false), d.appendChild(u);
    const w = document.createElement("span");
    w.classList.add("neuroglancer-segment-query-result-tag-count"), y || (w.textContent = l.toString()), d.appendChild(w);
  }
  return r;
}
var s6 = class extends qr {
  constructor(e) {
    super(), this.layer = e;
    const t = this.element;
    t.classList.add("neuroglancer-segment-display-tab"), t.appendChild(this.registerDisposer(new lr(e.displayState.segmentationGroupState.value.graph, (d, u, h) => {
      if (d === void 0) return;
      const g = document.createElement("div");
      g.className = "neuroglancer-segmentation-toolbox", g.appendChild(Kg(h, e, {
        toolJson: FS,
        label: "Merge",
        title: "Merge segments"
      })), g.appendChild(Kg(h, e, {
        toolJson: US,
        label: "Split",
        title: "Split segments"
      })), u.appendChild(g);
    })).element);
    const n = document.createElement("div");
    n.className = "neuroglancer-segmentation-toolbox", n.appendChild(Kg(this, e, {
      toolJson: zS,
      label: "Select",
      title: "Select/Deselect segments"
    })), t.appendChild(n);
    const r = document.createElement("input");
    r.classList.add("neuroglancer-segment-list-query"), r.addEventListener("focus", () => {
      r.select();
    });
    const s = this.registerDisposer(new Gi(r, ck));
    s.allShortcutsAreGlobal = true;
    const a = this.layer.displayState.segmentQuery, l = this.registerCancellable(dt(() => {
      a.value = r.value;
    }, 200));
    r.autocomplete = "off", r.title = ck.describe(), r.spellcheck = false, r.placeholder = "Enter ID, name prefix or /regexp", this.registerDisposer(_r((d) => {
      r.value = d;
    }, a)), this.registerDisposer(_r((d) => {
      Date.now() - d < 100 && (setTimeout(() => {
        r.focus();
      }, 0), this.layer.segmentQueryFocusTime.value = Number.NEGATIVE_INFINITY);
    }, this.layer.segmentQueryFocusTime)), t.appendChild(r), t.appendChild(this.registerDisposer(new lr(
      // segmentLabelMap is guaranteed to change if segmentationGroupState changes.
      e.displayState.segmentPropertyMap,
      (d, u, h) => {
        const g = (ae) => {
          r.focus(), r.select();
          const Ee = DW(d, ae);
          document.execCommand("insertText", false, Ee), a.value = Ee, r.select();
        }, v = h.registerDisposer(new QH(a, d, e.displayState, u)), y = e.displayState.segmentationGroupState.value, C = document.createElement("ul");
        C.classList.add("neuroglancer-segment-query-errors"), u.appendChild(C);
        const w = document.createElement("div");
        w.classList.add("neuroglancer-segment-query-result-statistics");
        const b = document.createElement("span"), E = document.createElement("input");
        E.type = "checkbox", E.checked = true, E.title = "Deselect all segment IDs", E.addEventListener("change", () => {
          y.visibleSegments.clear();
        });
        const T = or({
          title: "Copy visible segment IDs",
          onClick: () => {
            const ae = _e(y.visibleSegments, (Ee) => Ee.clone());
            ae.sort(re.compare), oi(ae.join(", "));
          }
        }), I = document.createElement("span");
        b.appendChild(T), b.appendChild(E), b.appendChild(I);
        const R = document.createElement("span"), P = document.createElement("input"), L = or({
          onClick: () => {
            l(), l.flush(), v.debouncedUpdate.flush();
            const ae = v.queryResult.value;
            if (ae === void 0) return;
            const Ee = new Array(ae.count);
            tu(d, ae, (ce, ge) => {
              Ee[ge] = ce.toString();
            }), oi(Ee.join(", "));
          }
        });
        P.type = "checkbox";
        const A = () => {
          l(), l.flush(), v.debouncedUpdate.flush();
          const ae = v.queryResult.value;
          if (ae === void 0) return;
          const Ee = y.visibleSegments, ce = v.selectedMatches, ge = ce !== ae.count;
          if (ge && ae.count - ce > e6) {
            if (!U)
              return U = true, M.textContent = `Confirm: show ${ae.count - ce} segments?`, false;
            U = false, q();
          }
          return tu(d, ae, (Ne) => {
            Ee.set(Ne, ge);
          }), true;
        };
        P.addEventListener("click", (ae) => {
          A() || ae.preventDefault();
        });
        const M = document.createElement("span");
        R.appendChild(L), R.appendChild(P), R.appendChild(M), b.classList.add("neuroglancer-segment-list-status"), R.classList.add("neuroglancer-segment-list-status"), u.appendChild(w);
        const O = document.createElement("div");
        O.classList.add("neuroglancer-segment-query-result-statistics-separator"), u.appendChild(O), u.appendChild(R), u.appendChild(b);
        let F = -1;
        const q = () => {
          const ae = y.visibleSegments.size;
          F !== ae && (F = ae, I.textContent = `${ae} visible in total`, E.checked = ae > 0, E.style.visibility = ae ? "visible" : "hidden", T.style.visibility = ae ? "visible" : "hidden"), M.textContent = v.statusText.value;
          const Ee = v.numMatches, ce = v.selectedMatches;
          L.style.visibility = Ee ? "visible" : "hidden", L.title = `Copy ${Ee} segment ID(s)`, P.style.visibility = Ee ? "visible" : "hidden", ce === 0 ? (P.checked = false, P.indeterminate = false, P.title = `Show ${Ee} segment ID(s)`) : ce === Ee ? (P.checked = true, P.indeterminate = false, P.title = `Hide ${ce} segment ID(s)`) : (P.checked = true, P.indeterminate = true, P.title = `Show ${Ee - ce} segment ID(s)`);
        };
        q(), v.statusText.changed.add(q), h.registerDisposer(y.visibleSegments.changed.add(q));
        let U = false;
        h.registerEventListener(r, "input", () => {
          l(), U && (U = false, q());
        }), h.registerDisposer(Ce(r, "cancel", () => {
          r.focus(), r.select(), document.execCommand("delete"), r.blur(), r.value = "", a.value = "", U = false, q();
        })), h.registerDisposer(Ce(r, "toggle-listed", A)), h.registerDisposer(Ce(r, "hide-all", () => {
          y.visibleSegments.clear();
        })), h.registerDisposer(Ce(r, "hide-listed", () => {
          l(), l.flush(), v.debouncedUpdate.flush();
          const ae = y.visibleSegments;
          if (a.value === "")
            ae.clear();
          else {
            const Ee = v.queryResult.value;
            if (Ee === void 0) return;
            tu(d, Ee, (ce) => {
              ae.delete(ce);
            });
          }
        }));
        const V = h.registerDisposer(new gS({ source: v, horizontalScroll: true })), $ = h.registerCancellable(Ct(() => {
          v.updateRenderedItems(V);
        })), B = this.layer.displayState;
        h.registerDisposer(B.segmentSelectionState.changed.add($)), h.registerDisposer(y.visibleSegments.changed.add($)), h.registerDisposer(B.segmentColorHash.changed.add($)), h.registerDisposer(B.segmentStatedColors.changed.add($)), h.registerDisposer(B.segmentDefaultColor.changed.add($)), V.element.classList.add("neuroglancer-segment-list"), h.registerDisposer(e.bindSegmentListWidth(V.element)), h.registerDisposer(new Hr(V.element, Lh()));
        const ue = h.registerDisposer(new i6(d, v.queryResult, g));
        {
          const ae = ue.listElement;
          ae !== void 0 && w.appendChild(ae);
        }
        let se;
        const Pe = (ae) => {
          const Ee = ae == null ? void 0 : ae.errors;
          if (st(C), Ee !== void 0)
            for (const ce of Ee) {
              const ge = document.createElement("li");
              ge.textContent = ce.message, C.appendChild(ge);
            }
        };
        _r((ae) => {
          if (v.segmentWidgetFactory = new uI(v.segmentationDisplayState, v.parentElement, (ce) => PS(ae == null ? void 0 : ae.query, ce.id)), V.scrollToTop(), st(V.header), d !== void 0) {
            const ce = v.segmentWidgetFactory.getHeader();
            ce.container.classList.add("neuroglancer-segment-list-header");
            for (const ge of ce.propertyLabels) {
              const Ne = ge.label, Me = ge.sortIcon, je = ge.id;
              Ne.addEventListener("click", () => {
                m2(v.queryResult.value, g, je);
              }), v2(ae, Me, je);
            }
            V.header.appendChild(ce.container);
          }
          if (Pe(ae), O.style.display = "none", se == null ? void 0 : se.remove(), ae === void 0) return;
          let Ee = ae.query;
          Ee.errors !== void 0 || Ee.ids !== void 0 || (se = r6(ae, g), se !== void 0 && w.appendChild(se), (ue.properties.length > 0 || se !== void 0) && (O.style.display = ""));
        }, v.queryResult), u.appendChild(V.element);
      }
    )).element);
  }
};
function $S(i = {}) {
  return Tt(H({ text: "?" }, i));
}
function y2(i, e, t, n) {
  const r = document.createElement("label");
  r.classList.add("neuroglancer-layer-control-container");
  const s = document.createElement("div");
  s.classList.add("neuroglancer-layer-control-label-container");
  const a = document.createElement("div");
  a.classList.add("neuroglancer-layer-control-label"), s.appendChild(a);
  const l = document.createElement("div");
  l.classList.add("neuroglancer-layer-control-label-text-container"), l.appendChild(document.createTextNode(t.label)), a.appendChild(l), t.title && (a.title = t.title), r.appendChild(s);
  var d = t.makeControl(e, i, { labelContainer: s, labelTextContainer: l, display: e.manager.root.display, visibility: n });
  const u = d.control, h = d.controlElement;
  return h.classList.add("neuroglancer-layer-control-control"), r.appendChild(h), { controlContainer: r, label: a, labelContainer: s, labelTextContainer: l, control: u };
}
var S2 = class extends Po {
  constructor(e, t) {
    super(e), this.options = t;
  }
  activate(e) {
    const t = this.options, n = this.layer, r = t.isValid;
    if (r !== void 0 && !r(n).value) return;
    var s = Mh(e);
    const a = s.header, l = s.body;
    var d = y2(e, n, t, new Zt(Zt.VISIBLE));
    const u = d.controlContainer, h = d.control, g = d.labelContainer;
    a.appendChild(g), l.appendChild(u), t.activateTool(e, h);
  }
  get description() {
    var e;
    const t = this.options;
    return (e = t.toolDescription) !== null && e !== void 0 ? e : t.label;
  }
  toJSON() {
    return this.options.toolJson;
  }
};
function dk(i, e, t, n) {
  var r = y2(i, e, t, n);
  const s = r.controlContainer, a = r.label;
  return s.classList.add("neuroglancer-layer-options-control-container"), a.prepend(i.registerDisposer(new RI(e, t.toolJson)).element), s;
}
function GS(i, e, t, n) {
  const r = n.isValid;
  return r === void 0 ? dk(i, e, n, t) : i.registerDisposer(new lr(r(e), (s, a, l) => {
    s && a.appendChild(dk(l, e, n, t));
  }, t)).element;
}
function b2(i, e) {
  const t = e.toolJson, n = typeof t == "string" ? t : t.type;
  gc(i, n, (r) => new S2(r, e));
}
var uk = class extends X {
  constructor(e) {
    super(), this.group = e, this.element = document.createElement("div"), this.topRow = document.createElement("div"), this.label = document.createElement("label"), this.selectElement = document.createElement("select"), this.linkedLayers = document.createElement("div"), this.unlinkButton = document.createElement("button");
    const t = this.element, n = this.label, r = this.topRow, s = this.selectElement, a = this.linkedLayers, l = this.unlinkButton;
    r.appendChild(n), r.appendChild(s), r.appendChild(l), l.textContent = "Unlink", l.addEventListener("click", () => {
      this.group.isolate();
    }), t.appendChild(r), t.appendChild(a), this.updateView();
    const d = dt(() => this.updateView(), 0);
    this.registerEventListener(s, "change", () => {
      this.updateModel(), d();
    }), this.registerDisposer(this.group.changed.add(d)), this.registerDisposer(this.group.linkedLayersChanged.add(d)), this.registerDisposer(this.group.layerManager.layersChanged.add(d));
  }
  updateModel() {
    const e = this.selectElement.value;
    e === "" && this.group.root.value !== this.group.layer ? this.group.isolate() : this.group.linkByName(e);
  }
  updateView() {
    var e;
    const t = this.selectElement, n = this.group, r = n.predicate;
    st(t);
    const s = this.group.rootGroup.linkedLayers.size !== 0;
    this.unlinkButton.style.display = s ? "" : "none";
    const a = this.linkedLayers, l = n.linkedLayers.size !== 0;
    if (a.style.display = l ? "" : "none", this.unlinkButton.textContent = l ? "Unlink all" : "Unlink", l) {
      this.element.style.display = "", t.style.display = "none", st(a);
      for (const d of n.linkedLayers) {
        const u = document.createElement("div");
        u.classList.add("neuroglancer-linked-layer-widget-layer");
        const h = aS({
          title: "Unlink layer",
          onClick: () => {
            this.group.getGroup(d).isolate();
          }
        });
        u.appendChild(h), u.appendChild(document.createTextNode(d.managedLayer.name)), a.appendChild(u);
      }
    } else {
      t.style.display = "";
      const d = document.createElement("option");
      t.appendChild(d);
      let u = 0;
      for (const h of this.group.layerManager.managedLayers) {
        const g = h.layer;
        if (g !== null && g !== n.layer && r(g)) {
          ++u;
          const v = document.createElement("option"), y = h.name;
          v.textContent = y, v.value = y, t.appendChild(v);
        }
      }
      t.value = (e = n.toJSON()) !== null && e !== void 0 ? e : "", this.element.style.display = u === 0 ? "none" : "";
    }
  }
};
var a6 = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='maximiseIconTitle'%3e%3ctitle%20id='maximiseIconTitle'%3eMaximise%20View%3c/title%3e%3cpolyline%20points='21%2016%2021%2021%2016%2021'/%3e%3cpolyline%20points='8%2021%203%2021%203%2016'/%3e%3cpolyline%20points='16%203%2021%203%2021%208'/%3e%3cpolyline%20points='3%208%203%203%208%203'/%3e%3c/svg%3e";
function WS(i = {}) {
  return Tt(H({ svg: a6 }, i));
}
var hk = { exports: {} };
var fk;
function o6() {
  return fk || (fk = 1, function(i, e) {
    (function(t) {
      t(Yo());
    })(function(t) {
      var n = "CodeMirror-lint-markers", r = "CodeMirror-lint-line-";
      function s(A, M, O) {
        var F = document.createElement("div");
        F.className = "CodeMirror-lint-tooltip cm-s-" + A.options.theme, F.appendChild(O.cloneNode(true)), A.state.lint.options.selfContain ? A.getWrapperElement().appendChild(F) : document.body.appendChild(F);
        function q(U) {
          if (!F.parentNode) return t.off(document, "mousemove", q);
          var V = Math.max(0, U.clientY - F.offsetHeight - 5), $ = Math.max(0, Math.min(U.clientX + 5, F.ownerDocument.defaultView.innerWidth - F.offsetWidth));
          F.style.top = V + "px", F.style.left = $ + "px";
        }
        return t.on(document, "mousemove", q), q(M), F.style.opacity != null && (F.style.opacity = 1), F;
      }
      function a(A) {
        A.parentNode && A.parentNode.removeChild(A);
      }
      function l(A) {
        A.parentNode && (A.style.opacity == null && a(A), A.style.opacity = 0, setTimeout(function() {
          a(A);
        }, 600));
      }
      function d(A, M, O, F) {
        var q = s(A, M, O);
        function U() {
          t.off(F, "mouseout", U), q && (l(q), q = null);
        }
        var V = setInterval(function() {
          if (q) for (var $ = F; ; $ = $.parentNode) {
            if ($ && $.nodeType == 11 && ($ = $.host), $ == document.body) return;
            if (!$) {
              U();
              break;
            }
          }
          if (!q) return clearInterval(V);
        }, 400);
        t.on(F, "mouseout", U);
      }
      function u(A, M, O) {
        this.marked = [], M instanceof Function && (M = { getAnnotations: M }), (!M || M === true) && (M = {}), this.options = {}, this.linterOptions = M.options || {};
        for (var F in h) this.options[F] = h[F];
        for (var F in M)
          h.hasOwnProperty(F) ? M[F] != null && (this.options[F] = M[F]) : M.options || (this.linterOptions[F] = M[F]);
        this.timeout = null, this.hasGutter = O, this.onMouseOver = function(q) {
          L(A, q);
        }, this.waitingFor = 0;
      }
      var h = {
        highlightLines: false,
        tooltips: true,
        delay: 500,
        lintOnChange: true,
        getAnnotations: null,
        async: false,
        selfContain: null,
        formatAnnotation: null,
        onUpdateLinting: null
      };
      function g(A) {
        var M = A.state.lint;
        M.hasGutter && A.clearGutter(n), M.options.highlightLines && v(A);
        for (var O = 0; O < M.marked.length; ++O)
          M.marked[O].clear();
        M.marked.length = 0;
      }
      function v(A) {
        A.eachLine(function(M) {
          var O = M.wrapClass && /\bCodeMirror-lint-line-\w+\b/.exec(M.wrapClass);
          O && A.removeLineClass(M, "wrap", O[0]);
        });
      }
      function y(A, M, O, F, q) {
        var U = document.createElement("div"), V = U;
        return U.className = "CodeMirror-lint-marker CodeMirror-lint-marker-" + O, F && (V = U.appendChild(document.createElement("div")), V.className = "CodeMirror-lint-marker CodeMirror-lint-marker-multiple"), q != false && t.on(V, "mouseover", function($) {
          d(A, $, M, V);
        }), U;
      }
      function C(A, M) {
        return A == "error" ? A : M;
      }
      function w(A) {
        for (var M = [], O = 0; O < A.length; ++O) {
          var F = A[O], q = F.from.line;
          (M[q] || (M[q] = [])).push(F);
        }
        return M;
      }
      function b(A) {
        var M = A.severity;
        M || (M = "error");
        var O = document.createElement("div");
        return O.className = "CodeMirror-lint-message CodeMirror-lint-message-" + M, typeof A.messageHTML < "u" ? O.innerHTML = A.messageHTML : O.appendChild(document.createTextNode(A.message)), O;
      }
      function E(A, M) {
        var O = A.state.lint, F = ++O.waitingFor;
        function q() {
          F = -1, A.off("change", q);
        }
        A.on("change", q), M(A.getValue(), function(U, V) {
          A.off("change", q), O.waitingFor == F && (V && U instanceof t && (U = V), A.operation(function() {
            I(A, U);
          }));
        }, O.linterOptions, A);
      }
      function T(A) {
        var M = A.state.lint;
        if (M) {
          var O = M.options, F = O.getAnnotations || A.getHelper(t.Pos(0, 0), "lint");
          if (F)
            if (O.async || F.async)
              E(A, F);
            else {
              var q = F(A.getValue(), M.linterOptions, A);
              if (!q) return;
              q.then ? q.then(function(U) {
                A.operation(function() {
                  I(A, U);
                });
              }) : A.operation(function() {
                I(A, q);
              });
            }
        }
      }
      function I(A, M) {
        var O = A.state.lint;
        if (O) {
          var F = O.options;
          g(A);
          for (var q = w(M), U = 0; U < q.length; ++U) {
            var V = q[U];
            if (V) {
              for (var $ = null, B = O.hasGutter && document.createDocumentFragment(), ue = 0; ue < V.length; ++ue) {
                var se = V[ue], Pe = se.severity;
                Pe || (Pe = "error"), $ = C($, Pe), F.formatAnnotation && (se = F.formatAnnotation(se)), O.hasGutter && B.appendChild(b(se)), se.to && O.marked.push(A.markText(se.from, se.to, {
                  className: "CodeMirror-lint-mark CodeMirror-lint-mark-" + Pe,
                  __annotation: se
                }));
              }
              O.hasGutter && A.setGutterMarker(U, n, y(
                A,
                B,
                $,
                V.length > 1,
                F.tooltips
              )), F.highlightLines && A.addLineClass(U, "wrap", r + $);
            }
          }
          F.onUpdateLinting && F.onUpdateLinting(M, q, A);
        }
      }
      function R(A) {
        var M = A.state.lint;
        M && (clearTimeout(M.timeout), M.timeout = setTimeout(function() {
          T(A);
        }, M.options.delay));
      }
      function P(A, M, O) {
        for (var F = O.target || O.srcElement, q = document.createDocumentFragment(), U = 0; U < M.length; U++) {
          var V = M[U];
          q.appendChild(b(V));
        }
        d(A, O, q, F);
      }
      function L(A, M) {
        var O = M.target || M.srcElement;
        if (/\bCodeMirror-lint-mark-/.test(O.className)) {
          for (var F = O.getBoundingClientRect(), q = (F.left + F.right) / 2, U = (F.top + F.bottom) / 2, V = A.findMarksAt(A.coordsChar({ left: q, top: U }, "client")), $ = [], B = 0; B < V.length; ++B) {
            var ue = V[B].__annotation;
            ue && $.push(ue);
          }
          $.length && P(A, $, M);
        }
      }
      t.defineOption("lint", false, function(A, M, O) {
        if (O && O != t.Init && (g(A), A.state.lint.options.lintOnChange !== false && A.off("change", R), t.off(A.getWrapperElement(), "mouseover", A.state.lint.onMouseOver), clearTimeout(A.state.lint.timeout), delete A.state.lint), M) {
          for (var F = A.getOption("gutters"), q = false, U = 0; U < F.length; ++U) F[U] == n && (q = true);
          var V = A.state.lint = new u(A, M, q);
          V.options.lintOnChange && A.on("change", R), V.options.tooltips != false && V.options.tooltips != "gutter" && t.on(A.getWrapperElement(), "mouseover", V.onMouseOver), T(A);
        }
      }), t.defineExtension("performLint", function() {
        T(this);
      });
    });
  }()), hk.exports;
}
o6();
var dm;
var pk;
function l6() {
  return pk || (pk = 1, dm = function(i) {
    i.defineMode("glsl", function(s, a) {
      var l = s.indentUnit, d = a.keywords || e(t), u = a.builtins || e(n), h = a.blockKeywords || e("case do else for if switch while struct"), g = a.atoms || e("null"), v = a.hooks || {}, y = a.multiLineStrings, C = /[+\-*&%=<>!?|\/]/, w;
      function b(L, A) {
        var M = L.next();
        if (v[M]) {
          var O = v[M](L, A);
          if (O !== false) return O;
        }
        if (M == '"' || M == "'")
          return A.tokenize = E(M), A.tokenize(L, A);
        if (/[\[\]{}\(\),;\:\.]/.test(M))
          return w = M, "bracket";
        if (/\d/.test(M))
          return L.eatWhile(/[\w\.]/), "number";
        if (M == "/") {
          if (L.eat("*"))
            return A.tokenize = T, T(L, A);
          if (L.eat("/"))
            return L.skipToEnd(), "comment";
        }
        if (M == "#")
          return L.eatWhile(/[\S]+/), L.eatWhile(/[\s]+/), L.eatWhile(/[\S]+/), L.eatWhile(/[\s]+/), "comment";
        if (C.test(M))
          return L.eatWhile(C), "operator";
        L.eatWhile(/[\w\$_]/);
        var F = L.current();
        return d.propertyIsEnumerable(F) ? (h.propertyIsEnumerable(F) && (w = "newstatement"), "keyword") : u.propertyIsEnumerable(F) ? "builtin" : g.propertyIsEnumerable(F) ? "atom" : "word";
      }
      function E(L) {
        return function(A, M) {
          for (var O = false, F, q = false; (F = A.next()) != null; ) {
            if (F == L && !O) {
              q = true;
              break;
            }
            O = !O && F == "\\";
          }
          return (q || !(O || y)) && (M.tokenize = b), "string";
        };
      }
      function T(L, A) {
        for (var M = false, O; O = L.next(); ) {
          if (O == "/" && M) {
            A.tokenize = b;
            break;
          }
          M = O == "*";
        }
        return "comment";
      }
      function I(L, A, M, O, F) {
        this.indented = L, this.column = A, this.type = M, this.align = O, this.prev = F;
      }
      function R(L, A, M) {
        return L.context = new I(L.indented, A, M, null, L.context);
      }
      function P(L) {
        var A = L.context.type;
        return (A == ")" || A == "]" || A == "}") && (L.indented = L.context.indented), L.context = L.context.prev;
      }
      return {
        startState: function(L) {
          return {
            tokenize: null,
            context: new I((L || 0) - l, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },
        token: function(L, A) {
          var M = A.context;
          if (L.sol() && (M.align == null && (M.align = false), A.indented = L.indentation(), A.startOfLine = true), L.eatSpace()) return null;
          w = null;
          var O = (A.tokenize || b)(L, A);
          if (O == "comment" || O == "meta") return O;
          if (M.align == null && (M.align = true), (w == ";" || w == ":") && M.type == "statement") P(A);
          else if (w == "{") R(A, L.column(), "}");
          else if (w == "[") R(A, L.column(), "]");
          else if (w == "(") R(A, L.column(), ")");
          else if (w == "}") {
            for (; M.type == "statement"; ) M = P(A);
            for (M.type == "}" && (M = P(A)); M.type == "statement"; ) M = P(A);
          } else w == M.type ? P(A) : (M.type == "}" || M.type == "top" || M.type == "statement" && w == "newstatement") && R(A, L.column(), "statement");
          return A.startOfLine = false, O;
        },
        indent: function(L, A) {
          if (L.tokenize != b && L.tokenize != null) return 0;
          var M = A && A.charAt(0), O = L.context, F = M == O.type;
          return O.type == "statement" ? O.indented + (M == "{" ? 0 : l) : O.align ? O.column + (F ? 0 : 1) : O.indented + (F ? 0 : l);
        },
        electricChars: "{}"
      };
    });
    function e(s) {
      for (var a = {}, l = s.split(" "), d = 0; d < l.length; ++d) a[l[d]] = true;
      return a;
    }
    var t = "attribute const uniform varying break continue do for while if else in out inout float int void bool true false lowp mediump highp precision invariant discard return mat2 mat3 mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 sampler2D samplerCube struct gl_FragCoord gl_FragColor", n = "radians degrees sin cos tan asin acos atan pow exp log exp2 log2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not dFdx dFdy fwidth texture2D texture2DProj texture2DLod texture2DProjLod textureCube textureCubeLod require export";
    function r(s, a) {
      return a.startOfLine ? (s.skipToEnd(), "meta") : false;
    }
    (function() {
      i.defineMIME("text/x-glsl", {
        name: "glsl",
        keywords: e(t),
        builtins: e(n),
        blockKeywords: e("case do else for if switch while struct"),
        atoms: e("null"),
        hooks: { "#": r }
      });
    })();
  }), dm;
}
var c6 = l6();
var d6 = Ws(c6);
d6(hs);
var u6 = 500;
var HS = class extends X {
  constructor(e) {
    super(), this.state = e, this.changingValue = false, this.debouncedValueUpdater = dt(() => {
      this.changingValue = true;
      try {
        this.state.fragmentMain.value = this.textEditor.getValue();
      } finally {
        this.changingValue = false;
      }
    }, u6), this.textEditor = hs((r) => {
    }, {
      value: this.state.fragmentMain.value,
      mode: "glsl",
      gutters: ["CodeMirror-lint-markers"]
    }), this.textEditor.on("change", () => {
      this.setValidState(void 0), this.debouncedValueUpdater();
    }), this.registerDisposer(this.state.fragmentMain.changed.add(() => {
      this.changingValue || this.textEditor.setValue(this.state.fragmentMain.value);
    })), this.element.classList.add("neuroglancer-shader-code-widget"), this.registerDisposer(this.state.shaderError.changed.add(() => {
      this.updateErrorState();
    }));
    const t = this.state.shaderControlState;
    t !== void 0 && this.registerDisposer(t.parseErrors.changed.add(() => {
      this.updateErrorState();
    })), this.updateErrorState();
    const n = new IntersectionObserver((r) => {
      r.some((s) => s.isIntersecting) && this.textEditor.refresh();
    }, {
      root: document.body
    });
    n.observe(this.element), this.registerDisposer(() => n.disconnect());
  }
  get element() {
    return this.textEditor.getWrapperElement();
  }
  updateErrorState() {
    var e = this.state.sourceStringNumber;
    const t = e === void 0 ? 1 : e, n = this.state.shaderError.value;
    let r;
    const s = this.state.shaderControlState;
    s !== void 0 ? r = s.parseErrors.value : r = [], n === void 0 && r.length === 0 ? this.setValidState(void 0) : n != null || r.length !== 0 ? (this.textEditor.setOption("lint", {
      getAnnotations: () => {
        const a = [];
        for (const l of r)
          a.push({
            message: l.message,
            severity: "error",
            from: hs.Pos(l.line)
          });
        if (n != null)
          if (n.name === "ShaderCompilationError")
            for (const l of n.errorMessages)
              a.push({
                message: l.message,
                severity: "error",
                from: hs.Pos(l.file === t && l.line || 0)
              });
          else n.name === "ShaderLinkError" ? a.push({
            message: n.log,
            severity: "error",
            from: hs.Pos(0)
          }) : a.push({
            message: n.message,
            severity: "error",
            from: hs.Pos(0)
          });
        return a;
      }
    }), this.setValidState(false)) : (this.textEditor.setOption("lint", void 0), this.setValidState(true));
  }
  setValidState(e) {
    let t = this.element;
    t.classList.remove("invalid-input"), t.classList.remove("valid-input"), e === true ? t.classList.add("valid-input") : e === false && t.classList.add("invalid-input");
  }
  disposed() {
    this.debouncedValueUpdater.flush(), this.debouncedValueUpdater = void 0, Ut(this.element), this.textEditor = void 0, super.disposed();
  }
};
var h6 = St.fromObject({
  "at:shift+wheel": { action: "adjust-contrast-via-wheel" },
  "at:shift+mousedown0": { action: "adjust-via-drag" },
  "at:shift+mousedown2": { action: "invert-range" }
});
function f6(i) {
  return {
    makeControl: (e, t, n) => {
      var r = i(e);
      const s = r.watchableValue, a = r.channelCoordinateSpaceCombiner, l = r.dataType, d = r.defaultChannel, u = r.histogramSpecifications, h = r.legendShaderOptions, g = r.histogramIndex;
      if (a !== void 0 && d.length !== 0) {
        const y = t.registerDisposer(new Js(a.combined)), C = t.registerDisposer(new $h(y, a, { copyButton: false }));
        t.registerDisposer(y.changed.add(() => {
          const b = y.value, E = _e(b, (I) => Math.floor(I)), T = s.value;
          He(T.channel, E) || (s.value = H(H({}, s.value), { channel: E }));
        }));
        const w = () => {
          const b = y.value, E = s.value;
          He(b, E.channel) || (b.set(E.channel), y.changed.dispatch());
        };
        w(), t.registerDisposer(s.changed.add(w)), n.labelContainer.appendChild(C.element);
      }
      const v = t.registerDisposer(new GH(n.visibility, n.display, l, s, u, g, d.length === 0 ? h : void 0));
      return { control: v, controlElement: v.element };
    },
    activateTool: (e, t) => {
      e.bindInputEventMap(h6), e.bindAction("adjust-contrast-via-wheel", (n) => {
        n.stopPropagation();
        const r = Iu(n.detail);
        zH(t.dataType, t.trackable, r);
      }), e.bindAction("adjust-via-drag", (n) => {
        n.stopPropagation();
        let r = n.detail.screenX, s = n.detail.screenY, a = t.trackable.value.range, l = a, d = r, u = s;
        Ui(n.detail, (h) => {
          const g = t.trackable.value.range, v = h.screenX, y = h.screenY;
          Pr(t.dataType, g, l) || (a = g, r = d, s = u), $H(t.dataType, t.trackable, a, (y - s) * 2 / screen.height, (v - r) * 4 / screen.width), l = t.trackable.value.range, d = v, u = y;
        });
      }), e.bindAction("invert-range", (n) => {
        n.stopPropagation(), p2(t.trackable);
      });
    }
  };
}
function Xl(i) {
  return {
    makeControl: (e, t) => {
      const n = i(e), r = t.registerDisposer(new Ls(n));
      return { control: r, controlElement: r.element };
    },
    activateTool: (e, t) => {
      t.model.value = !t.model.value;
    }
  };
}
var p6 = St.fromObject({
  "at:shift+wheel": { action: "adjust-hue-via-wheel" }
});
function w2(i) {
  return {
    makeControl: (e, t) => {
      const n = i(e), r = t.registerDisposer(new xS(n));
      return { control: r, controlElement: r.element };
    },
    activateTool: (e, t) => {
      e.bindInputEventMap(p6), e.bindAction("adjust-via-wheel", (n) => {
        n.stopPropagation(), n.preventDefault(), t.adjustHueViaWheel(n.detail);
      });
    }
  };
}
var g6 = class extends X {
  constructor(e, { min: t = 0, max: n = 1, step: r = 0.01 } = {}) {
    super(), this.value = e, this.element = document.createElement("label"), this.inputElement = document.createElement("input"), this.numericInputElement = document.createElement("input");
    let s = this.element, a = this.inputElement, l = this.numericInputElement;
    s.className = "range-slider";
    const d = (h) => {
      h.min = "" + t, h.max = "" + n, h.step = "" + r, h.valueAsNumber = this.value.value, this.registerEventListener(h, "change", () => this.inputValueChanged(h)), this.registerEventListener(h, "input", () => this.inputValueChanged(h)), this.registerEventListener(h, "wheel", (g) => {
        this.adjustViaWheel(h, g);
      });
    };
    a.type = "range", d(a), l.type = "number";
    const u = Math.max(t.toString().length, n.toString().length, Math.min(n, t + r).toString().length, Math.max(t, n - r).toString().length);
    l.style.width = u + 2 + "ch", d(l), s.appendChild(a), s.appendChild(l), e.changed.add(() => {
      this.inputElement.valueAsNumber = this.value.value, this.numericInputElement.valueAsNumber = this.value.value;
    });
  }
  inputValueChanged(e) {
    this.value.value = e.valueAsNumber;
  }
  adjustViaWheel(e, t) {
    const n = this.inputElement;
    let r = t.deltaY;
    r > 0 ? (n.stepUp(), this.inputValueChanged(e)) : r < 0 && (n.stepDown(), this.inputValueChanged(e));
  }
  disposed() {
    Ut(this.element), super.disposed();
  }
};
var m6 = St.fromObject({
  "at:shift+wheel": { action: "adjust-via-wheel" }
});
function fs(i) {
  return {
    makeControl: (e, t) => {
      var n = i(e);
      const r = n.value, s = n.options, a = t.registerDisposer(new g6(r, s));
      return { control: a, controlElement: a.element };
    },
    activateTool: (e, t) => {
      e.bindInputEventMap(m6), e.bindAction("adjust-via-wheel", (n) => {
        n.stopPropagation(), n.preventDefault(), t.adjustViaWheel(t.inputElement, n.detail);
      });
    }
  };
}
function gk(i, e) {
  const t = i.shaderControlState, n = t.state.get(e);
  if (n === void 0) return;
  const r = n.control;
  switch (r.type) {
    case "slider":
      return fs(() => ({
        value: n.trackable,
        options: { min: r.min, max: r.max, step: r.step }
      }));
    case "color":
      return w2(() => n.trackable);
    case "checkbox":
      return Xl(() => n.trackable);
    case "invlerp": {
      let a = 0;
      for (const l of t.state) {
        var s = de(l, 2);
        const d = s[0], u = s[1].control.type;
        if (d === e) break;
        u === "invlerp" && ++a;
      }
      return f6(() => ({
        dataType: r.dataType,
        defaultChannel: r.default.channel,
        watchableValue: n.trackable,
        channelCoordinateSpaceCombiner: t.channelCoordinateSpaceCombiner,
        histogramSpecifications: t.histogramSpecifications,
        histogramIndex: a,
        legendShaderOptions: i.legendShaderOptions
      }));
    }
  }
}
function C2(i, e, t) {
  return {
    label: t,
    toolJson: v6(t, e),
    makeControl: (n, r, s) => {
      const a = i(n);
      return gk(a, t).makeControl(n, r, s);
    },
    activateTool: (n, r) => {
      const s = i(n.tool.layer);
      return gk(s, t).activateTool(n, r);
    }
  };
}
var qS = class extends qr {
  constructor(e, t, n, r = {}) {
    super(r.visibility), this.state = e, this.display = t, this.layer = n, this.options = r, this.controlDisposer = void 0;
    var s = r.toolId;
    const a = s === void 0 ? x22 : s;
    this.toolId = a;
    const l = this.element;
    l.style.display = "contents";
    const d = e.controls;
    this.registerDisposer(d.changed.add(this.registerCancellable(dt(() => this.updateControls(), 0)))), this.updateControls();
  }
  updateControls() {
    const e = this.element;
    this.controlDisposer !== void 0 && (this.controlDisposer.dispose(), st(e));
    const t = this.controlDisposer = new X(), n = () => ({
      shaderControlState: this.state,
      legendShaderOptions: this.options.legendShaderOptions
    });
    for (const r of this.state.state.keys())
      e.appendChild(GS(t, this.layer, this.visibility, C2(n, this.toolId, r)));
  }
  disposed() {
    var e;
    (e = this.controlDisposer) === null || e === void 0 || e.dispose(), super.disposed();
  }
};
var x22 = "shaderControl";
var E2 = "control";
function v6(i, e) {
  return { type: e, [E2]: i };
}
var y6 = class extends S2 {
  constructor(e, t, n, r) {
    super(e, C2(() => t, n, r)), this.layerShaderControls = t, this.control = r, this.registerDisposer(t.shaderControlState.controls.changed.add(this.registerCancellable(dt(() => {
      t.shaderControlState.state.get(r) === void 0 && this.unbind();
    }))));
  }
  activate(e) {
    this.layerShaderControls.shaderControlState.state.get(this.control) !== void 0 && super.activate(e);
  }
};
function jS(i, e, t = x22) {
  gc(i, t, (n, r) => {
    const s = Y(r, E2, Ae);
    return new y6(n, e(n), t, s);
  });
}
function k2(i) {
  return new HS({
    fragmentMain: i.displayState.skeletonRenderingOptions.shader,
    shaderError: i.displayState.shaderError,
    shaderControlState: i.displayState.skeletonRenderingOptions.shaderControlState
  });
}
var S6 = class extends qr {
  constructor(e) {
    super(), this.layer = e;
    const t = this.element;
    t.classList.add("neuroglancer-segmentation-rendering-tab");
    {
      const r = this.registerDisposer(new uk(e.displayState.linkedSegmentationGroup));
      r.label.textContent = "Linked to: ", t.appendChild(r.element);
    }
    {
      const r = this.registerDisposer(new uk(e.displayState.linkedSegmentationColorGroup));
      r.label.textContent = "Colors linked to: ", t.appendChild(r.element);
    }
    for (const r of KS)
      t.appendChild(GS(this, e, this.visibility, r));
    const n = this.registerDisposer(new lr(e.hasSkeletonsLayer, (r, s, a) => {
      if (!r) return;
      let l = document.createElement("div");
      l.className = "neuroglancer-segmentation-dropdown-skeleton-shader-header";
      let d = document.createElement("div");
      d.style.flex = "1", d.textContent = "Skeleton shader:", l.appendChild(d), l.appendChild(WS({
        title: "Show larger editor view",
        onClick: () => {
          new b6(this.layer);
        }
      })), l.appendChild($S({
        title: "Documentation on skeleton rendering",
        href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md"
      })), s.appendChild(l);
      const u = a.registerDisposer(k2(this.layer));
      s.appendChild(u.element), s.appendChild(a.registerDisposer(new qS(e.displayState.skeletonRenderingOptions.shaderControlState, this.layer.manager.root.display, this.layer, {
        visibility: this.visibility,
        toolId: JS
      })).element), u.textEditor.refresh();
    }, this.visibility));
    t.appendChild(n.element);
  }
};
var b6 = class extends Gh {
  constructor(e) {
    super(), this.layer = e, this.codeWidget = this.registerDisposer(k2(this.layer)), this.content.classList.add("neuroglancer-segmentation-layer-skeleton-shader-overlay"), this.content.appendChild(this.codeWidget.element), this.codeWidget.textEditor.refresh();
  }
};
var w6 = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
var Pv;
var Rv = Pv = class extends ph {
  constructor() {
    super(...arguments), this.hashTable = new Qy(), this.changed = new ct();
  }
  get value() {
    return this;
  }
  static makeWithCounterpart(e) {
    let t = new Pv();
    return t.initializeCounterpart(e), t;
  }
  set_(e, t) {
    return this.hashTable.set(e, t);
  }
  set(e, t) {
    if (this.set_(e, t)) {
      let n = this.rpc;
      n && n.invoke("Uint64Map.set", { id: this.rpcId, key: e, value: t }), this.changed.dispatch(e, true);
    }
  }
  has(e) {
    return this.hashTable.has(e);
  }
  get(e, t) {
    return this.hashTable.get(e, t);
  }
  [qn]() {
    return this.hashTable.entries();
  }
  unsafeEntries() {
    return this.hashTable.unsafeEntries();
  }
  delete_(e) {
    return this.hashTable.delete(e);
  }
  delete(e) {
    if (this.delete_(e)) {
      let t = this.rpc;
      t && t.invoke("Uint64Map.delete", { id: this.rpcId, key: e }), this.changed.dispatch(e, false);
    }
  }
  get size() {
    return this.hashTable.size;
  }
  assignFrom(e) {
    this.clear();
    for (const n of e.unsafeEntries()) {
      var t = de(n, 2);
      const r = t[0], s = t[1];
      this.set(r, s);
    }
  }
  clear() {
    if (this.hashTable.clear()) {
      let e = this.rpc;
      e && e.invoke("Uint64Map.clear", { id: this.rpcId }), this.changed.dispatch(null, false);
    }
  }
  toJSON() {
    let e = {};
    for (let n of this.hashTable.unsafeEntries()) {
      var t = de(n, 2);
      let r = t[0], s = t[1];
      e[r.toString()] = s.toString();
    }
    return e;
  }
};
Rv = Pv = w6([gh("Uint64Map")], Rv);
zt("Uint64Map.set", function(i) {
  let e = this.get(i.id);
  e.set_(i.key, i.value) && e.changed.dispatch();
});
zt("Uint64Map.delete", function(i) {
  let e = this.get(i.id);
  e.delete_(i.key) && e.changed.dispatch();
});
zt("Uint64Map.clear", function(i) {
  let e = this.get(i.id);
  e.hashTable.clear() && e.changed.dispatch();
});
var C6 = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
var Av;
var zu = Av = class extends ph {
  constructor() {
    super(...arguments), this.hashTable = new JD(), this.changed = new ct();
  }
  get value() {
    return this;
  }
  static makeWithCounterpart(e) {
    let t = new Av();
    return t.initializeCounterpart(e), t;
  }
  set(e, t) {
    t ? this.add(e) : this.delete(e);
  }
  reserve_(e) {
    return this.hashTable.reserve(e);
  }
  reserve(e) {
    if (this.reserve_(e)) {
      let t = this.rpc;
      t && t.invoke("Uint64Set.reserve", { id: this.rpcId, value: e });
    }
  }
  add_(e) {
    let t = false;
    for (const n of e)
      t = this.hashTable.add(n) || t;
    return t;
  }
  add(e) {
    const t = Array().concat(e);
    if (this.add_(t)) {
      let n = this.rpc;
      n && n.invoke("Uint64Set.add", { id: this.rpcId, value: t }), this.changed.dispatch(e, true);
    }
  }
  has(e) {
    return this.hashTable.has(e);
  }
  [qn]() {
    return this.hashTable.keys();
  }
  unsafeKeys() {
    return this.hashTable.unsafeKeys();
  }
  delete_(e) {
    let t = false;
    for (const n of e)
      t = this.hashTable.delete(n) || t;
    return t;
  }
  delete(e) {
    const t = Array().concat(e);
    if (this.delete_(Array().concat(e))) {
      let n = this.rpc;
      n && n.invoke("Uint64Set.delete", { id: this.rpcId, value: t }), this.changed.dispatch(e, false);
    }
  }
  get size() {
    return this.hashTable.size;
  }
  clear() {
    if (this.hashTable.clear()) {
      let e = this.rpc;
      e && e.invoke("Uint64Set.clear", { id: this.rpcId }), this.changed.dispatch(null, false);
    }
  }
  toJSON() {
    let e = new Array();
    for (let t of this.unsafeKeys())
      e.push(t.toString());
    return e.sort(), e;
  }
  assignFrom(e) {
    this.clear();
    for (const t of e.unsafeKeys())
      this.add(t);
  }
};
zu = Av = C6([gh("Uint64Set")], zu);
zt("Uint64Set.reserve", function(i) {
  let e = this.get(i.id);
  e.reserve_(i.value) && e.changed.dispatch();
});
zt("Uint64Set.add", function(i) {
  let e = this.get(i.id);
  e.add_(i.value) && e.changed.dispatch();
});
zt("Uint64Set.delete", function(i) {
  let e = this.get(i.id);
  e.delete_(i.value) && e.changed.dispatch();
});
zt("Uint64Set.clear", function(i) {
  let e = this.get(i.id);
  e.hashTable.clear() && e.changed.dispatch();
});
var x6 = St.fromObject({
  "at:shift+wheel": { action: "adjust-via-wheel" }
});
function T2(i) {
  return {
    makeControl: (e, t) => {
      const n = i(e), r = t.registerDisposer(new sP(n));
      return { control: r, controlElement: r.element };
    },
    activateTool: (e, t) => {
      e.bindInputEventMap(x6), e.bindAction("adjust-via-wheel", (n) => {
        n.stopPropagation(), n.preventDefault(), t.adjustViaWheel(n.detail);
      });
    }
  };
}
var E6 = 200;
var mk = St.fromObject({
  mousedown0: { action: "set" },
  wheel: { action: "adjust-via-wheel" },
  dblclick0: { action: "reset" }
});
function k6(i) {
  if (i < 1 || i > 1024) {
    const e = Zn(i) | 0, t = i / 2 ** e;
    return `${GI(t, 1)}p${e}`;
  }
  return Math.round(i) + "";
}
var _v = class extends X {
  constructor(e, t) {
    super(), this.histogram = e, this.target = t, this.label = document.createElement("div"), this.element = document.createElement("div"), this.canvas = document.createElement("canvas"), this.legend = document.createElement("div"), this.legendRenderScale = document.createElement("div"), this.legendSpatialScale = document.createElement("div"), this.legendChunks = document.createElement("div"), this.ctx = this.canvas.getContext("2d"), this.hoverTarget = new vt(void 0), this.throttledUpdateView = this.registerCancellable(wh(() => this.debouncedUpdateView(), E6, { leading: true, trailing: true })), this.debouncedUpdateView = this.registerCancellable(dt(() => this.updateView(), 0));
    const n = this.canvas, r = this.label, s = this.element, a = this.legend, l = this.legendRenderScale, d = this.legendSpatialScale, u = this.legendChunks;
    r.className = "neuroglancer-render-scale-widget-prompt", s.className = "neuroglancer-render-scale-widget", s.title = mk.describe(), a.className = "neuroglancer-render-scale-widget-legend", s.appendChild(r), s.appendChild(n), s.appendChild(a), l.title = "Target resolution of data in screen pixels", u.title = "Number of chunks rendered", a.appendChild(l), a.appendChild(u), a.appendChild(d), this.registerDisposer(e.changed.add(this.throttledUpdateView)), this.registerDisposer(e.visibility.changed.add(this.debouncedUpdateView)), this.registerDisposer(t.changed.add(this.debouncedUpdateView)), this.registerDisposer(new Hr(n, mk)), this.registerDisposer(t.changed.add(this.debouncedUpdateView)), this.registerDisposer(this.hoverTarget.changed.add(this.debouncedUpdateView));
    const h = (v) => {
      const y = v.offsetX / n.width * dn;
      return jF(y);
    };
    this.registerEventListener(n, "pointermove", (v) => {
      this.hoverTarget.value = [h(v), v.offsetY];
    }), this.registerEventListener(n, "pointerleave", () => {
      this.hoverTarget.value = void 0;
    }), this.registerDisposer(Ce(n, "set", (v) => {
      this.target.value = h(v.detail);
    })), this.registerDisposer(Ce(n, "adjust-via-wheel", (v) => {
      this.adjustViaWheel(v.detail);
    })), this.registerDisposer(Ce(n, "reset", (v) => {
      this.reset(), v.preventDefault();
    }));
    const g = new ResizeObserver(() => this.debouncedUpdateView());
    g.observe(n), this.registerDisposer(() => g.disconnect()), this.updateView();
  }
  adjustViaWheel(e) {
    const t = e.deltaY;
    t !== 0 && (this.hoverTarget.value = void 0, this.target.value *= 2 ** dc(t), e.preventDefault());
  }
  reset() {
    this.hoverTarget.value = void 0, this.target.reset();
  }
  updateView() {
    const e = this.ctx, t = this.canvas, n = t.width = t.offsetWidth, r = t.height = t.offsetHeight, s = this.target.value, a = this.hoverTarget.value;
    {
      const L = this.legendRenderScale, A = a === void 0 ? s : a[0], M = k6(A);
      L.textContent = M + " px";
    }
    function l(L) {
      return L * n / dn;
    }
    e.clearRect(0, 0, n, r);
    const d = this.histogram, u = d.value, h = d.spatialScales;
    d.visibility.visible || u.fill(0);
    const g = _e(h.keys());
    g.sort();
    const v = ze();
    let y = 1;
    const C = h.size;
    let w = 0, b = 0;
    for (let L = 0; L < dn; ++L) {
      let A = 0;
      for (let M = 0; M < C; ++M) {
        const O = M * dn * 2 + L, F = u[O], q = u[O + dn];
        w += F, b += q, A += F + q;
      }
      y = Math.max(A, y);
    }
    const T = r / Math.log(1 + y);
    function I(L) {
      return r - Math.log(1 + L) * T;
    }
    let R;
    if (a !== void 0) {
      const L = Math.floor(Yd(a[0]));
      if (L >= 0 && L < dn) {
        let A = 0;
        const M = a[1];
        for (let O = C - 1; O >= 0; --O) {
          const F = g[O], U = 2 * h.get(F) * dn + L, V = u[U] + u[U + dn];
          if (V === 0) continue;
          const $ = Math.round(I(A));
          if (A += V, Math.round(I(A)) <= M && M <= $) {
            R = F;
            break;
          }
        }
      }
    }
    if (R !== void 0) {
      w = 0, b = 0;
      const A = 2 * h.get(R) * dn;
      for (let M = 0; M < dn; ++M) {
        const O = A + M;
        w += u[O], b += u[O + dn];
      }
      Lt(R) ? this.legendSpatialScale.textContent = ia(R, "m", { precision: 2, elide1: false }) : this.legendSpatialScale.textContent = "unknown";
    } else
      this.legendSpatialScale.textContent = "";
    this.legendChunks.textContent = `${w}/${w + b}`;
    const P = g.map((L) => {
      const A = L === R ? 0.5 : 1;
      let M;
      Lt(L) ? M = (Zn(L) * 0.1 % 1 + 1) % 1 : M = 0, ku(v, M, A, 1);
      const O = Hn(v);
      ku(v, M, A, 0.5);
      const F = Hn(v);
      return [O, F];
    });
    for (let L = 0; L < dn; ++L) {
      let A = 0;
      for (let M = C - 1; M >= 0; --M) {
        const O = g[M], q = h.get(O) * dn * 2 + L, U = u[q], V = u[q + dn], $ = U + V;
        if ($ === 0) continue;
        const B = Math.round(l(L)), ue = Math.round(l(L + 1)), se = Math.round(I(A));
        A += $;
        const Pe = Math.round(I(A)), ae = (U * Pe + V * se) / $;
        e.fillStyle = P[M][1], e.fillRect(B, Pe, ue - B, ae - Pe), e.fillStyle = P[M][0], e.fillRect(B, ae, ue - B, se - ae);
      }
    }
    {
      const L = s;
      e.fillStyle = "#fff";
      const A = l(Yd(L));
      e.fillRect(Math.floor(A), 0, 1, r);
    }
    if (a !== void 0) {
      const L = a[0];
      e.fillStyle = "#888";
      const A = l(Yd(L));
      e.fillRect(Math.floor(A), 0, 1, r);
    }
  }
};
var T6 = St.fromObject({
  "at:shift+wheel": { action: "adjust-via-wheel" },
  "at:shift+dblclick0": { action: "reset" }
});
function $u(i) {
  return {
    makeControl: (e, t) => {
      var n = i(e);
      const r = n.histogram, s = n.target, a = t.registerDisposer(new _v(r, s));
      return { control: a, controlElement: a.element };
    },
    activateTool: (e, t) => {
      e.bindInputEventMap(T6), e.bindAction("adjust-via-wheel", (n) => {
        n.stopPropagation(), n.preventDefault(), t.adjustViaWheel(n.detail);
      }), e.bindAction("reset", (n) => {
        n.stopPropagation(), n.preventDefault(), t.reset();
      });
    }
  };
}
var L6 = "data:image/svg+xml,%3csvg%20role='img'%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20aria-labelledby='rotateIconTitle'%3e%3ctitle%20id='rotateIconTitle'%3eRotate%3c/title%3e%3cpath%20d='M22%2012l-3%203-3-3'/%3e%3cpath%20d='M2%2012l3-3%203%203'/%3e%3cpath%20d='M19.016%2014v-1.95A7.05%207.05%200%200%200%208%206.22'/%3e%3cpath%20d='M16.016%2017.845A7.05%207.05%200%200%201%205%2012.015V10'/%3e%3cpath%20stroke-linecap='round'%20d='M5%2010V9'/%3e%3cpath%20stroke-linecap='round'%20d='M19%2015v-1'/%3e%3c/svg%3e";
function Gu(i, e) {
  e ? i.displayState.segmentDefaultColor.value = wt(1, 0, 0) : i.displayState.segmentDefaultColor.value = void 0;
}
function D6() {
  const i = (e) => {
    e.displayState.segmentationColorGroupState.value.segmentColorHash.randomize();
  };
  return {
    makeControl: (e, t, { labelTextContainer: n }) => {
      const r = document.createElement("input");
      r.type = "radio", r.addEventListener("change", () => {
        Gu(e, !r.checked);
      }), n.prepend(r);
      const s = document.createElement("div");
      s.classList.add("neuroglancer-segmentation-color-seed-control");
      const a = t.registerDisposer(new dP(e.displayState.segmentColorHash));
      s.appendChild(a.element);
      const l = Tt({
        svg: L6,
        title: "Randomize",
        onClick: () => i(e)
      });
      return s.appendChild(l), t.registerDisposer(_r((d) => {
        const u = d === void 0;
        s.style.visibility = u ? "" : "hidden", r.checked = u;
      }, e.displayState.segmentDefaultColor)), { controlElement: s, control: a };
    },
    activateTool: (e) => {
      const t = e.tool.layer;
      Gu(t, false), i(t);
    }
  };
}
function I6() {
  const i = w2((e) => e.displayState.segmentDefaultColor);
  return H(H({}, i), { makeControl: (e, t, n) => {
    const r = i.makeControl(e, t, n), s = r.controlElement, a = document.createElement("input");
    return a.type = "radio", a.addEventListener("change", () => {
      Gu(e, a.checked), a.checked && s.click();
    }), n.labelTextContainer.prepend(a), t.registerDisposer(_r((l) => {
      const d = l !== void 0;
      s.style.visibility = d ? "" : "hidden", a.checked = d;
    }, e.displayState.segmentDefaultColor)), r;
  }, activateTool: (e, t) => {
    Gu(e.tool.layer, true), i.activateTool(e, t);
  } });
}
var Mv = "selectedAlpha";
var Nv = "notSelectedAlpha";
var Ov = "objectAlpha";
var Vv = "saturation";
var Bv = "hideSegmentZero";
var Fv = "baseSegmentColoring";
var Uv = "ignoreNullVisibleSet";
var P6 = "mesh";
var R6 = "skeletons";
var vk = "segments";
var Wu = "equivalences";
var zv = "colorSeed";
var yk = "segmentColors";
var $v = "meshRenderScale";
var Gv = "crossSectionRenderScale";
var Hu = "skeletonRendering";
var A6 = "skeletonShader";
var Sk = "segmentQuery";
var Wv = "meshSilhouetteRendering";
var bk = "linkedSegmentationGroup";
var wk = "linkedSegmentationColorGroup";
var Hv = "segmentDefaultColor";
var Ck = "anchorSegment";
var JS = "skeletonShaderControl";
var L2 = class extends X {
  constructor(e) {
    super(), this.layer = e, this.specificationChanged = new ct(), this.localGraph = new OW(), this.visibleSegments = this.registerDisposer(zu.makeWithCounterpart(this.layer.manager.rpc)), this.segmentPropertyMap = new vt(void 0), this.graph = new vt(void 0), this.segmentEquivalences = this.registerDisposer(mc.makeWithCounterpart(this.layer.manager.rpc, this.layer.registerDisposer(wi((n) => n && n.visibleSegmentEquivalencePolicy || Bi.MIN_REPRESENTATIVE, [this.graph])))), this.localSegmentEquivalences = false, this.maxIdLength = new vt(1), this.hideSegmentZero = new nn(true, true), this.segmentQuery = new fn("", Ae), this.temporaryVisibleSegments = this.layer.registerDisposer(zu.makeWithCounterpart(this.layer.manager.rpc)), this.temporarySegmentEquivalences = this.layer.registerDisposer(mc.makeWithCounterpart(this.layer.manager.rpc, this.segmentEquivalences.disjointSets.visibleSegmentEquivalencePolicy)), this.useTemporaryVisibleSegments = this.layer.registerDisposer(An.make(this.layer.manager.rpc, false)), this.useTemporarySegmentEquivalences = this.layer.registerDisposer(An.make(this.layer.manager.rpc, false));
    const t = this.specificationChanged;
    this.visibleSegments.changed.add(t.dispatch), this.hideSegmentZero.changed.add(t.dispatch), this.segmentQuery.changed.add(t.dispatch);
  }
  restoreState(e) {
    xe(e, Bv, (t) => this.hideSegmentZero.restoreState(t)), xe(e, Wu, (t) => {
      this.localGraph.restoreState(t);
    }), xe(e, vk, (t) => {
      const n = this.segmentEquivalences, r = this.visibleSegments;
      Xe(t, (s) => {
        let a = re.parseString(String(s), 10);
        r.add(n.get(a));
      });
    }), xe(e, Sk, (t) => this.segmentQuery.restoreState(t));
  }
  toJSON() {
    const e = {};
    e[Bv] = this.hideSegmentZero.toJSON();
    let t = this.visibleSegments;
    t.size > 0 && (e[vk] = t.toJSON());
    let n = this.segmentEquivalences;
    return this.localSegmentEquivalences && n.size > 0 && (e[Wu] = n.toJSON()), e[Sk] = this.segmentQuery.toJSON(), e;
  }
  assignFrom(e) {
    this.maxIdLength.value = e.maxIdLength.value, this.hideSegmentZero.value = e.hideSegmentZero.value, this.visibleSegments.assignFrom(e.visibleSegments), this.segmentEquivalences.assignFrom(e.segmentEquivalences);
  }
};
var D2 = class extends X {
  constructor(e) {
    super(), this.layer = e, this.specificationChanged = new ct(), this.segmentColorHash = iS.getDefault(), this.segmentStatedColors = this.registerDisposer(new Rv()), this.segmentDefaultColor = new OT();
    const t = this.specificationChanged;
    this.segmentColorHash.changed.add(t.dispatch), this.segmentStatedColors.changed.add(t.dispatch), this.segmentDefaultColor.changed.add(t.dispatch);
  }
  restoreState(e) {
    xe(e, zv, (t) => this.segmentColorHash.restoreState(t)), xe(e, Hv, (t) => this.segmentDefaultColor.restoreState(t)), xe(e, yk, (t) => {
      let n = uh(t, (s) => ua(String(s)));
      for (let s of n) {
        var r = de(s, 2);
        let a = r[0], l = r[1];
        const d = re.parseString(String(a)), u = new re(lu(l));
        this.segmentStatedColors.set(d, u);
      }
    });
  }
  toJSON() {
    const e = {};
    e[zv] = this.segmentColorHash.toJSON(), e[Hv] = this.segmentDefaultColor.toJSON();
    const t = this.segmentStatedColors;
    if (t.size > 0) {
      const r = e[yk] = {};
      for (const s of t.unsafeEntries()) {
        var n = de(s, 2);
        const a = n[0], l = n[1];
        r[a.toString()] = Hn(Xs(l.low));
      }
    }
    return e;
  }
  assignFrom(e) {
    this.segmentColorHash.value = e.segmentColorHash.value, this.segmentStatedColors.assignFrom(e.segmentStatedColors), this.segmentDefaultColor.value = e.segmentDefaultColor.value;
  }
};
var xk = class extends X {
  constructor(e, t) {
    super(), this.linkedGroup = e, this.propertyName = t, this.value;
  }
  get changed() {
    return this.linkedGroup.root.changed;
  }
  get value() {
    const e = this.linkedGroup.root.value;
    if (e !== this.curRoot) {
      this.curRoot = e;
      const t = e.displayState[this.propertyName];
      if (e === this.linkedGroup.layer) {
        const n = this.curGroupState;
        n !== void 0 && (t.assignFrom(n), n.dispose());
      }
      this.curGroupState = t.addRef();
    }
    return this.curGroupState;
  }
  disposed() {
    var e;
    (e = this.curGroupState) === null || e === void 0 || e.dispose();
  }
};
var _6 = class {
  constructor(e) {
    this.layer = e, this.segmentSelectionState = new cI(), this.selectedAlpha = Wl(0.5), this.saturation = Wl(1), this.notSelectedAlpha = Wl(0), this.silhouetteRendering = new fn(0, fy, 0), this.objectAlpha = Wl(1), this.ignoreNullVisibleSet = new nn(true, true), this.skeletonRenderingOptions = new fz(), this.shaderError = vh(), this.renderScaleHistogram = new Co(), this.renderScaleTarget = sa(1), this.selectSegment = this.layer.selectSegment, this.transparentPickEnabled = this.layer.pick, this.baseSegmentColoring = new nn(false, false), this.filterBySegmentLabel = this.layer.filterBySegmentLabel, this.moveToSegment = (t) => {
      this.layer.moveToSegment(t);
    }, this.linkedSegmentationGroup = this.layer.registerDisposer(new $E(this.layer.manager.rootLayers, this.layer, (t) => t instanceof Mn, (t) => t.displayState.linkedSegmentationGroup)), this.linkedSegmentationColorGroup = this.layer.registerDisposer(new $E(this.layer.manager.rootLayers, this.layer, (t) => t instanceof Mn, (t) => t.displayState.linkedSegmentationColorGroup)), this.originalSegmentationGroupState = this.layer.registerDisposer(new L2(this.layer)), this.originalSegmentationColorGroupState = this.layer.registerDisposer(new D2(this.layer)), e.displayState = this, this.segmentationGroupState = this.layer.registerDisposer(new xk(this.linkedSegmentationGroup, "originalSegmentationGroupState")), this.segmentationColorGroupState = this.layer.registerDisposer(new xk(this.linkedSegmentationColorGroup, "originalSegmentationColorGroupState")), this.hideSegmentZero = this.layer.registerDisposer(new Wd(this.segmentationGroupState, (t) => t.hideSegmentZero)), this.segmentColorHash = this.layer.registerDisposer(new Bp(this.segmentationColorGroupState, (t) => t.segmentColorHash)), this.segmentStatedColors = this.layer.registerDisposer(new Bp(this.segmentationColorGroupState, (t) => t.segmentStatedColors)), this.segmentDefaultColor = this.layer.registerDisposer(new Bp(this.segmentationColorGroupState, (t) => t.segmentDefaultColor)), this.segmentQuery = this.layer.registerDisposer(new Wd(this.segmentationGroupState, (t) => t.segmentQuery)), this.segmentPropertyMap = this.layer.registerDisposer(new Wd(this.segmentationGroupState, (t) => t.segmentPropertyMap));
  }
};
var M6 = BS(Xo);
var Mn = class extends M6 {
  constructor(e) {
    super(e), this.sliceViewRenderScaleHistogram = new Co(), this.sliceViewRenderScaleTarget = sa(1), this.segmentQueryFocusTime = new vt(Number.NEGATIVE_INFINITY), this.selectSegment = (t, n) => {
      this.manager.root.selectionState.captureSingleLayerState(this, (r) => (r.value = t.clone(), true), n);
    }, this.filterBySegmentLabel = (t) => {
      const r = aa(this.displayState, t).label;
      r && this.filterSegments(r);
    }, this.filterSegments = (t) => {
      this.displayState.segmentationGroupState.value.segmentQuery.value = t, this.segmentQueryFocusTime.value = Date.now(), this.tabs.value = "segments", this.manager.root.selectedLayer.layer = this.managedLayer;
    }, this.displayState = new _6(this), this.anchorSegment = new fn(void 0, (t) => t === void 0 ? void 0 : re.parseString(t)), this.has2dLayer = this.registerDisposer(nr((t) => t.some((n) => n instanceof lm), { changed: this.layersChanged, value: this.renderLayers })), this.has3dLayer = this.registerDisposer(nr((t) => t.some((n) => n instanceof V1 || n instanceof Wg || n instanceof jg || n instanceof H1), { changed: this.layersChanged, value: this.renderLayers })), this.hasSkeletonsLayer = this.registerDisposer(nr((t) => t.some((n) => n instanceof jg), { changed: this.layersChanged, value: this.renderLayers })), this.registerDisposer(fo((t, n) => {
      t.registerDisposer(n.specificationChanged.add(this.specificationChanged.dispatch)), this.specificationChanged.dispatch();
    }, this.displayState.segmentationGroupState)), this.registerDisposer(fo((t, n) => {
      t.registerDisposer(n.specificationChanged.add(this.specificationChanged.dispatch)), this.specificationChanged.dispatch();
    }, this.displayState.segmentationColorGroupState)), this.displayState.segmentSelectionState.bindTo(this.manager.layerSelectedValues, this), this.displayState.selectedAlpha.changed.add(this.specificationChanged.dispatch), this.displayState.saturation.changed.add(this.specificationChanged.dispatch), this.displayState.notSelectedAlpha.changed.add(this.specificationChanged.dispatch), this.displayState.objectAlpha.changed.add(this.specificationChanged.dispatch), this.displayState.baseSegmentColoring.changed.add(this.specificationChanged.dispatch), this.displayState.ignoreNullVisibleSet.changed.add(this.specificationChanged.dispatch), this.displayState.skeletonRenderingOptions.changed.add(this.specificationChanged.dispatch), this.displayState.renderScaleTarget.changed.add(this.specificationChanged.dispatch), this.displayState.silhouetteRendering.changed.add(this.specificationChanged.dispatch), this.anchorSegment.changed.add(this.specificationChanged.dispatch), this.sliceViewRenderScaleTarget.changed.add(this.specificationChanged.dispatch), this.displayState.originalSegmentationGroupState.localGraph.changed.add(this.specificationChanged.dispatch), this.displayState.linkedSegmentationGroup.changed.add(() => this.updateDataSubsourceActivations()), this.tabs.add("rendering", { label: "Render", order: -100, getter: () => new S6(this) }), this.tabs.add("segments", { label: "Seg.", order: -50, getter: () => new s6(this) }), this.tabs.default = "rendering";
  }
  bindSegmentListWidth(e) {
    return Do(this.displayState, e);
  }
  get volumeOptions() {
    return { volumeType: Pn.SEGMENTATION };
  }
  activateDataSubsources(e) {
    const t = [], n = this.displayState.linkedSegmentationGroup.root.value === this;
    let r;
    for (const a of e) {
      if (this.addStaticAnnotations(a)) continue;
      var s = a.subsourceEntry.subsource;
      const l = s.volume, d = s.mesh, u = s.segmentPropertyMap, h = s.segmentationGraph, g = s.local;
      if (l instanceof Ps) {
        switch (l.dataType) {
          case j.FLOAT32:
            a.deactivate("Data type not compatible with segmentation layer");
            continue;
        }
        a.activate(() => a.addRenderLayer(new lm(l, H(H({}, this.displayState), { transform: a.getRenderLayerTransform(), renderScaleTarget: this.sliceViewRenderScaleTarget, renderScaleHistogram: this.sliceViewRenderScaleHistogram, localPosition: this.localPosition }))), this.displayState.segmentationGroupState.value);
      } else d !== void 0 ? a.activate(() => {
        const v = H(H({}, this.displayState), { transform: a.getRenderLayerTransform() });
        if (d instanceof Vc)
          a.addRenderLayer(new V1(this.manager.chunkManager, d, v));
        else if (d instanceof Ah)
          a.addRenderLayer(new Wg(this.manager.chunkManager, d, v));
        else {
          const y = new pz(this.manager.chunkManager, d, v);
          a.addRenderLayer(new jg(y.addRef())), a.addRenderLayer(new H1(
            /* transfer ownership */
            y
          ));
        }
      }, this.displayState.segmentationGroupState.value) : u !== void 0 ? n ? (a.activate(() => {
      }), t.push(u)) : a.deactivate("Not supported on non-root linked segmentation layers") : h !== void 0 ? n ? r !== void 0 ? a.deactivate("Only one segmentation graph is supported") : (r = h, a.activate((v) => {
        this.graphConnection = v.registerDisposer(h.connect(this.displayState.segmentationGroupState.value));
        const y = H(H({}, this.displayState), { transform: a.getRenderLayerTransform() }), C = this.graphConnection.createRenderLayers(this.manager.chunkManager, y, this.localPosition);
        for (const w of C)
          a.addRenderLayer(w);
      })) : a.deactivate("Not supported on non-root linked segmentation layers") : g === Br.equivalences ? n ? r !== void 0 ? a.deactivate("Only one segmentation graph is supported") : (r = this.displayState.originalSegmentationGroupState.localGraph, a.activate((v) => {
        this.graphConnection = v.registerDisposer(r.connect(this.displayState.segmentationGroupState.value)), v.registerDisposer(() => {
          this.graphConnection = void 0;
        });
      })) : a.deactivate("Not supported on non-root linked segmentation layers") : a.deactivate("Not compatible with segmentation layer");
    }
    this.displayState.originalSegmentationGroupState.segmentPropertyMap.value = CW(this.manager.chunkManager, t), this.displayState.originalSegmentationGroupState.graph.value = r;
  }
  getLegacyDataSourceSpecifications(e, t, n, r) {
    const s = super.getLegacyDataSourceSpecifications(e, t, n, r), a = xe(t, P6, (d) => d === null ? null : Ae(d)), l = xe(t, R6, (d) => d === null ? null : Ae(d));
    if (a !== void 0 || l !== void 0)
      for (const d of s)
        d.enableDefaultSubsources = false, d.subsources = new he([["default", { enabled: true }], ["bounds", { enabled: true }]]);
    return a != null && s.push(Jl(this.manager.dataSourceProviderRegistry.convertLegacyUrl({ url: a, type: "mesh" }))), l != null && s.push(Jl(this.manager.dataSourceProviderRegistry.convertLegacyUrl({ url: l, type: "skeletons" }))), t[Wu] !== void 0 && r.find((d) => d.url === Jm) === void 0 && s.push({
      url: Jm,
      enableDefaultSubsources: true,
      transform: {
        outputSpace: mo,
        sourceRank: 0,
        transform: void 0,
        inputSpace: mo
      },
      subsources: new he()
    }), s;
  }
  restoreState(e) {
    super.restoreState(e), this.displayState.selectedAlpha.restoreState(e[Mv]), this.displayState.saturation.restoreState(e[Vv]), this.displayState.notSelectedAlpha.restoreState(e[Nv]), this.displayState.objectAlpha.restoreState(e[Ov]), this.displayState.baseSegmentColoring.restoreState(e[Fv]), this.displayState.silhouetteRendering.restoreState(e[Wv]), this.displayState.ignoreNullVisibleSet.restoreState(e[Uv]);
    const t = this.displayState.skeletonRenderingOptions;
    t.restoreState(e[Hu]);
    const n = e[A6];
    n !== void 0 && t.shader.restoreState(n), this.displayState.renderScaleTarget.restoreState(e[$v]), this.anchorSegment.restoreState(e[Ck]), this.sliceViewRenderScaleTarget.restoreState(e[Gv]);
    const r = xe(e, bk, Ae);
    r !== void 0 && this.displayState.linkedSegmentationGroup.linkByName(r);
    const s = xe(e, wk, (a) => a === false ? void 0 : Ae(a), r);
    s !== void 0 && this.displayState.linkedSegmentationColorGroup.linkByName(s), this.displayState.segmentationGroupState.value.restoreState(e), this.displayState.segmentationColorGroupState.value.restoreState(e);
  }
  toJSON() {
    var e;
    const t = super.toJSON();
    t[Mv] = this.displayState.selectedAlpha.toJSON(), t[Nv] = this.displayState.notSelectedAlpha.toJSON(), t[Vv] = this.displayState.saturation.toJSON(), t[Ov] = this.displayState.objectAlpha.toJSON(), t[Fv] = this.displayState.baseSegmentColoring.toJSON(), t[Uv] = this.displayState.ignoreNullVisibleSet.toJSON(), t[Wv] = this.displayState.silhouetteRendering.toJSON(), t[Ck] = this.anchorSegment.toJSON(), t[Hu] = this.displayState.skeletonRenderingOptions.toJSON(), t[$v] = this.displayState.renderScaleTarget.toJSON(), t[Gv] = this.sliceViewRenderScaleTarget.toJSON();
    var n = this.displayState;
    const r = n.linkedSegmentationGroup, s = n.linkedSegmentationColorGroup;
    return t[bk] = r.toJSON(), s.root.value !== r.root.value && (t[wk] = (e = s.toJSON()) !== null && e !== void 0 ? e : false), t[Wu] = this.displayState.originalSegmentationGroupState.localGraph.toJSON(), r.root.value === this && H(t, this.displayState.segmentationGroupState.value.toJSON()), s.root.value === this && H(t, this.displayState.segmentationColorGroupState.value.toJSON()), t;
  }
  transformPickedValue(e) {
    return e == null ? e : oS(
      this.displayState,
      e,
      /*mustCopy=*/
      true
    );
  }
  handleAction(e, t) {
    switch (e) {
      case "recolor": {
        this.displayState.segmentationColorGroupState.value.segmentColorHash.randomize();
        break;
      }
      case "clear-segments": {
        if (!this.pick.value) break;
        this.displayState.segmentationGroupState.value.visibleSegments.clear();
        break;
      }
      case "select": {
        if (!this.pick.value) break;
        const n = this.displayState.segmentSelectionState;
        if (n.hasSelectedSegment) {
          const r = n.selectedSegment, s = this.displayState.segmentationGroupState.value.visibleSegments, a = !s.has(r);
          (a || t.segmentationToggleSegmentState === void 0) && (t.segmentationToggleSegmentState = a), t.defer(() => {
            t.segmentationToggleSegmentState === a && s.set(r, a);
          });
        }
        break;
      }
      case "copy-segment-id": {
        if (!this.pick.value) break;
        const n = this.displayState.segmentSelectionState;
        if (n.hasSelectedSegment) {
          const r = n.selectedSegment;
          this.copiedSegments = [r.clone()];
          const s = r.toString();
          oi(s) && rt.showTemporaryMessage(s + " copied to clipboard");
        }
        break;
      }
      case "add-copy-segment-id": {
        if (!this.pick.value) break;
        const n = this.displayState.segmentSelectionState;
        if (n.hasSelectedSegment) {
          const r = n.selectedSegment;
          this.copiedSegments.push(r.clone());
          const s = this.copiedSegments.map((a) => a.toString()).join(",");
          oi(s) && rt.showTemporaryMessage(s + " copied to clipboard");
        }
        break;
      }
    }
  }
  selectionStateFromJson(e, t) {
    super.selectionStateFromJson(e, t);
    const n = new re();
    let r = e.value;
    typeof r == "number" && (r = r.toString()), typeof r != "string" || !n.tryParseString(r) ? e.value = void 0 : e.value = n;
  }
  selectionStateToJson(e, t) {
    const n = super.selectionStateToJson(e, t);
    let r = e.value;
    return r instanceof Fr ? t ? n.value = {
      key: r.key.toString(),
      value: r.value ? r.value.toString() : void 0,
      label: r.label
    } : n.value = (r.value || r.key).toString() : r instanceof re && (n.value = r.toString()), n;
  }
  displaySegmentationSelection(e, t, n) {
    const r = e.value;
    let s;
    if ((typeof r == "number" || typeof r == "string") && (s = new re(), !s.tryParseString(r.toString())))
      return false;
    if (r instanceof re)
      s = r.clone();
    else if (r instanceof Fr)
      s = r.key.clone();
    else
      return false;
    const a = this.displayState, l = aa(a, s);
    var d = this.displayState.segmentationGroupState.value;
    const u = d.segmentEquivalences, h = d.segmentPropertyMap.value, g = u.get(s), v = Dh(this.displayState, l);
    if (jo(a, n, n.redraw), n.registerDisposer(Do(a, v)), v.classList.add("neuroglancer-selection-details-segment"), t.appendChild(v), h !== void 0) {
      const y = h.segmentPropertyMap.inlineProperties;
      if (y !== void 0) {
        const C = h.getSegmentInlineIndex(g);
        if (C !== -1) {
          for (const w of y.properties)
            if (w.type !== "label") {
              if (w.type === "description") {
                const b = w.values[C];
                if (!b) continue;
                const E = document.createElement("div");
                E.classList.add("neuroglancer-selection-details-segment-description"), E.textContent = b, t.appendChild(E);
              } else if (w.type === "number" || w.type === "string") {
                const b = w.values[C];
                if (w.type === "number" ? isNaN(b) : !b) continue;
                const E = document.createElement("div");
                E.classList.add("neuroglancer-selection-details-segment-property");
                const T = document.createElement("div");
                T.classList.add("neuroglancer-selection-details-segment-property-name"), T.textContent = w.id, w.description && (T.title = w.description);
                const I = document.createElement("div");
                I.classList.add("neuroglancer-selection-details-segment-property-value"), I.textContent = b.toString(), E.appendChild(T), E.appendChild(I), t.appendChild(E);
              }
            }
        }
      }
    }
    return true;
  }
  displaySelectionState(e, t, n) {
    let r = this.displaySegmentationSelection(e, t, n);
    return super.displaySelectionState(e, t, n) && (r = true), r;
  }
  moveToSegment(e) {
    for (const n of this.renderLayers) {
      if (!(n instanceof Wg)) continue;
      const r = n.getObjectPosition(e);
      if (r !== void 0) {
        this.setLayerPosition(n.displayState.transform.value, r);
        return;
      }
    }
    let t = false;
    for (const n of this.renderLayers)
      if (n instanceof lm) {
        const r = n.multiscaleSource;
        r.getSegmentPosition && (t = true, r.getSegmentPosition(e).then((s) => {
          this.setLayerPosition(null, s);
        }).catch((s) => {
          rt.showTemporaryMessage(`Failed to retrieve position for segment ${e}: ${s}`);
        }));
      }
    t || rt.showTemporaryMessage(`No position information loaded for segment ${e}`);
  }
};
Mn.type = "segmentation";
Mn.typeAbbreviation = "seg";
Mn.supportsPickOption = true;
var N6 = 10;
function Ek(i) {
  return [H({ label: `Skeleton mode (${i})`, toolJson: `${Hu}.mode${i}`, isValid: (e) => e.hasSkeletonsLayer }, T2((e) => e.displayState.skeletonRenderingOptions[`params${i}`].mode)), H({ label: `Line width (${i})`, toolJson: `${Hu}.lineWidth${i}`, isValid: (e) => e.hasSkeletonsLayer, toolDescription: `Skeleton line width (${i})`, title: `Skeleton line width (${i})` }, fs((e) => ({
    value: e.displayState.skeletonRenderingOptions[`params${i}`].lineWidth,
    options: { min: 1, max: 40, step: 1 }
  })))];
}
var KS = [H({ label: "Color seed", title: "Color segments based on a hash of their id", toolJson: zv }, D6()), H({ label: "Fixed color", title: "Use a fixed color for all segments without an explicitly-specified color", toolJson: Hv }, I6()), H({ label: "Saturation", toolJson: Vv, title: "Saturation of segment colors" }, fs((i) => ({ value: i.displayState.saturation }))), H({ label: "Opacity (on)", toolJson: Mv, isValid: (i) => i.has2dLayer, title: "Opacity in cross-section views of segments that are selected" }, fs((i) => ({ value: i.displayState.selectedAlpha }))), H({ label: "Opacity (off)", toolJson: Nv, isValid: (i) => i.has2dLayer, title: "Opacity in cross-section views of segments that are not selected" }, fs((i) => ({ value: i.displayState.notSelectedAlpha }))), H({ label: "Resolution (slice)", toolJson: Gv, isValid: (i) => i.has2dLayer }, $u((i) => ({
  histogram: i.sliceViewRenderScaleHistogram,
  target: i.sliceViewRenderScaleTarget
}))), H({ label: "Resolution (mesh)", toolJson: $v, isValid: (i) => i.has3dLayer }, $u((i) => ({
  histogram: i.displayState.renderScaleHistogram,
  target: i.displayState.renderScaleTarget
}))), H({ label: "Opacity (3d)", toolJson: Ov, isValid: (i) => i.has3dLayer, title: "Opacity of meshes and skeletons" }, fs((i) => ({ value: i.displayState.objectAlpha }))), H({ label: "Silhouette (3d)", toolJson: Wv, isValid: (i) => i.has3dLayer, title: "Set to a non-zero value to increase transparency of object faces perpendicular to view direction" }, fs((i) => ({
  value: i.displayState.silhouetteRendering,
  options: { min: 0, max: N6, step: 0.1 }
}))), H({ label: "Hide segment ID 0", toolJson: Bv, title: "Disallow selection and display of segment id 0" }, Xl((i) => i.displayState.hideSegmentZero)), H({ label: "Base segment coloring", toolJson: Fv, title: "Color base segments individually" }, Xl((i) => i.displayState.baseSegmentColoring)), H({ label: "Show all by default", title: "Show all segments if none are selected", toolJson: Uv }, Xl((i) => i.displayState.ignoreNullVisibleSet)), ...Ek("2d"), ...Ek("3d")];
for (const i of KS)
  b2(Mn, i);
Zo(Mn);
xP(Pn.SEGMENTATION, Mn);
LS((i) => {
  if (i.mesh !== void 0)
    return { layerConstructor: Mn, priority: 1 };
});
jS(Mn, (i) => ({
  shaderControlState: i.displayState.skeletonRenderingOptions.shaderControlState
}), JS);
JH();
XH();
var O6 = Object.freeze(Object.defineProperty({
  __proto__: null,
  LAYER_CONTROLS: KS,
  SKELETON_RENDERING_SHADER_CONTROL_TOOL_ID: JS,
  SegmentationUserLayer: Mn,
  SegmentationUserLayerColorGroupState: D2,
  SegmentationUserLayerGroupState: L2
}, Symbol.toStringTag, { value: "Module" }));
var V6 = class extends X {
  constructor(e) {
    super(), this.ref = e, this.element = document.createElement("label"), this.selectElement = document.createElement("select"), this.registerDisposer(e);
    const t = this.element, n = this.selectElement;
    t.appendChild(n), this.updateView(), this.registerEventListener(n, "change", () => this.updateModel()), this.registerDisposer(this.ref.changed.add(dt(() => this.updateView(), 0)));
  }
  updateModel() {
    this.ref.layerName = this.selectElement.value || void 0;
  }
  updateView() {
    const e = this.selectElement, t = this.ref, n = t.filter;
    st(e);
    const r = document.createElement("option");
    e.appendChild(r);
    for (const s of this.ref.layerManager.managedLayers)
      if (n(s)) {
        const a = document.createElement("option"), l = s.name;
        a.textContent = l, a.value = l, e.appendChild(a);
      }
    e.value = t.layerName || "";
  }
};
var B6 = "points";
var um = "annotations";
var kk = "annotationProperties";
var Tk = "annotationRelationships";
var Lk = "crossSectionAnnotationSpacing";
var Dk = "projectionAnnotationSpacing";
var Ik = "shader";
var Pk = "shaderControls";
function F6(i, e) {
  e !== void 0 && Xe(e, (t, n) => {
    i.add({
      type: Fe.POINT,
      id: "" + n,
      point: KT(t),
      properties: []
    });
  });
}
function U6(i) {
  const e = i.layer;
  return e === null || e instanceof Mn;
}
function z6(i) {
  if (i === void 0)
    return null;
  const e = i.layer;
  return e === null || !(e instanceof Mn) ? null : e.displayState;
}
var Rk = "linkedSegmentationLayer";
var Ak = "filterBySegmentation";
var _k = "ignoreNullSegmentFilter";
var $6 = class extends X {
  constructor(e, t, n) {
    super(), this.layerManager = e, this.annotationStates = t, this.annotationDisplayState = n, this.changed = new Le(), this.curGeneration = -1, this.wasLoading = void 0, this.map = new he(), this.registerDisposer(t.changed.add(() => this.update())), this.registerDisposer(t.isLoadingChanged.add(() => this.update())), this.update();
  }
  update() {
    const e = this.annotationStates.changed.count, t = this.annotationStates.isLoading;
    if (this.curGeneration === e && t === this.wasLoading) return;
    this.wasLoading = t, this.curGeneration = e;
    const n = this.map;
    let r = false;
    for (const a of this.annotationStates.relationships) {
      let l = n.get(a);
      l === void 0 && (l = this.addRelationship(a), r = true), l.seenGeneration = e;
    }
    if (!t)
      for (const a of n) {
        var s = de(a, 2);
        const l = s[0];
        s[1].seenGeneration !== e && (n.delete(l), r = true);
      }
    r && this.changed.dispatch();
  }
  addRelationship(e) {
    const t = this.annotationDisplayState.relationshipStates.get(e), n = new sW(this.layerManager.addRef(), U6);
    n.registerDisposer(n.changed.add(() => {
      t.segmentationState.value = n.layerName === void 0 ? void 0 : z6(n.layer);
    }));
    const r = t.showMatches, s = {
      layerRef: n,
      showMatches: r,
      seenGeneration: -1
    };
    return n.changed.add(this.changed.dispatch), r.changed.add(this.changed.dispatch), this.map.set(e, s), s;
  }
  get(e) {
    return this.update(), this.map.get(e);
  }
  unbind(e) {
    e.layerRef.changed.remove(this.changed.dispatch), e.showMatches.changed.remove(this.changed.dispatch);
  }
  reset() {
    for (const e of this.map.values())
      e.showMatches.reset();
  }
  toJSON() {
    const e = this.map;
    if (e.size === 0) return {};
    let t;
    const n = [];
    for (const s of e) {
      var r = de(s, 2);
      const a = r[0], l = r[1];
      l.showMatches.value && n.push(a);
      const d = l.layerRef.layerName;
      d !== void 0 && ((t = t || {})[a] = d);
    }
    return n.sort(), {
      [Rk]: t,
      [Ak]: n.length === 0 ? void 0 : n
    };
  }
  restoreState(e) {
    const t = this.annotationStates.isLoading;
    xe(e, Rk, (n) => {
      typeof n == "string" && (n = { segments: n }), me(n);
      for (const s of hn(n)) {
        const a = Ae(n[s]);
        let l = this.map.get(s);
        if (l === void 0) {
          if (!t) continue;
          l = this.addRelationship(s);
        }
        l.layerRef.layerName = a;
      }
      for (const s of this.map) {
        var r = de(s, 2);
        const a = r[0], l = r[1];
        Object.prototype.hasOwnProperty.call(n, a) || (l.layerRef.layerName = void 0);
      }
    }), xe(e, Ak, (n) => {
      typeof n == "boolean" && (n = n === true ? ["segments"] : []);
      for (const r of bi(n)) {
        let s = this.map.get(r);
        if (s === void 0) {
          if (!t) continue;
          s = this.addRelationship(r);
        }
        s.showMatches.value = true;
      }
    });
  }
  disposed() {
    const e = this.map;
    for (const t of e.values())
      this.unbind(t);
    e.clear(), super.disposed();
  }
};
var G6 = class extends X {
  constructor(e, t) {
    super(), this.relationship = e, this.state = t, this.element = document.createElement("label"), this.seenGeneration = -1;
    const n = this.element, r = this.registerDisposer(new Ls(t.showMatches)), s = new V6(t.layerRef);
    n.appendChild(r.element), n.appendChild(document.createTextNode(e)), n.appendChild(s.element);
  }
};
var W6 = class extends X {
  constructor(e) {
    super(), this.linkedSegmentationLayers = e, this.widgets = new he(), this.element = document.createElement("div"), this.element.style.display = "contents";
    const t = this.registerCancellable(Ct(() => this.updateView()));
    this.registerDisposer(this.linkedSegmentationLayers.annotationStates.changed.add(t)), this.updateView();
  }
  updateView() {
    const e = this.linkedSegmentationLayers, t = e.annotationStates, n = t.changed.count, r = this.widgets;
    function* s() {
      for (const l of t.relationships) {
        let d = r.get(l);
        d === void 0 && (d = new G6(l, e.get(l))), d.seenGeneration = n, yield d.element;
      }
    }
    for (const l of r) {
      var a = de(l, 2);
      const d = a[0], u = a[1];
      u.seenGeneration !== n && (u.dispose(), r.delete(d));
    }
    rr(this.element, s.call(this));
  }
  disposed() {
    super.disposed();
    for (const e of this.widgets.values())
      e.dispose();
  }
};
var H6 = BS(Xo);
var Cs = class extends H6 {
  constructor(e) {
    super(e), this.annotationProperties = new vt(void 0), this.localAnnotationsJson = void 0, this.pointAnnotationsJson = void 0, this.linkedSegmentationLayers = this.registerDisposer(new $6(this.manager.rootLayers, this.annotationStates, this.annotationDisplayState)), this.linkedSegmentationLayers.changed.add(this.specificationChanged.dispatch), this.annotationDisplayState.ignoreNullSegmentFilter.changed.add(this.specificationChanged.dispatch), this.annotationCrossSectionRenderScaleTarget.changed.add(this.specificationChanged.dispatch), this.tabs.add("rendering", { label: "Rendering", order: -100, getter: () => new j6(this) }), this.tabs.default = "annotations", this.allowingRefresh = true;
  }
  disposed() {
    const e = this.localAnnotations;
    e !== void 0 && e.dispose(), super.disposed();
  }
  restoreState(e) {
    super.restoreState(e), this.linkedSegmentationLayers.restoreState(e), this.localAnnotationsJson = e[um], this.localAnnotationProperties = xe(e, kk, tL), this.localAnnotationRelationships = xe(e, Tk, bi, ["segments"]), this.pointAnnotationsJson = e[B6], this.annotationCrossSectionRenderScaleTarget.restoreState(e[Lk]), this.annotationProjectionRenderScaleTarget.restoreState(e[Dk]), this.annotationDisplayState.ignoreNullSegmentFilter.restoreState(e[_k]), this.annotationDisplayState.shader.restoreState(e[Ik]), this.annotationDisplayState.shaderControls.restoreState(e[Pk]);
  }
  getLegacyDataSourceSpecifications(e, t, n, r) {
    if (Object.prototype.hasOwnProperty.call(t, "source"))
      return super.getLegacyDataSourceSpecifications(e, t, n, r);
    const s = xe(t, "voxelSize", (l) => lt(new Float64Array(3), l, (d) => yn(d) / 1e9)), a = ["m", "m", "m"];
    if (s !== void 0) {
      const l = yt({ rank: 3, units: a, scales: s, names: ["x", "y", "z"] });
      n === void 0 ? n = {
        outputSpace: l,
        sourceRank: 3,
        transform: void 0,
        inputSpace: l
      } : n = H(H({}, n), { inputSpace: l });
    }
    return [{
      url: MD,
      transform: n,
      enableDefaultSubsources: true,
      subsources: new he()
    }];
  }
  activateDataSubsources(e) {
    var t;
    let n = false, r;
    for (const a of e) {
      const l = a.subsourceEntry, d = l.subsource.local, u = (g) => r !== void 0 && si(g) !== si(r) ? (a.deactivate("Annotation properties are not compatible"), false) : (r = g, true);
      if (d === Br.annotations) {
        if (n) {
          a.deactivate("Only one local annotations source per layer is supported");
          continue;
        }
        if (n = true, !u((t = this.localAnnotationProperties) !== null && t !== void 0 ? t : [])) continue;
        a.activate((g) => {
          var v;
          const y = this.localAnnotations = new RO(a.loadedDataSource.transform, (v = this.localAnnotationProperties) !== null && v !== void 0 ? v : [], this.localAnnotationRelationships);
          try {
            y.restoreState(this.localAnnotationsJson);
          } catch {
          }
          g.registerDisposer(() => {
            y.dispose(), this.localAnnotations = void 0;
          }), g.registerDisposer(this.localAnnotations.changed.add(this.specificationChanged.dispatch));
          try {
            F6(this.localAnnotations, this.pointAnnotationsJson);
          } catch {
          }
          this.pointAnnotationsJson = void 0, this.localAnnotationsJson = void 0;
          const C = new $m({
            localPosition: this.localPosition,
            transform: g.registerDisposer(bL(this.manager.root.coordinateSpace, this.localPosition.coordinateSpace, a.loadedDataSource.transform, void 0)),
            source: y.addRef(),
            displayState: this.annotationDisplayState,
            dataSource: a.loadedDataSource.layerDataSource,
            subsourceIndex: a.subsourceIndex,
            subsourceId: l.id,
            role: Ei.ANNOTATION
          });
          this.addAnnotationLayerState(C, a);
        });
        continue;
      }
      const h = l.subsource.annotation;
      if (h !== void 0) {
        if (!u(h.properties)) continue;
        a.activate(() => {
          const g = new $m({
            localPosition: this.localPosition,
            transform: a.getRenderLayerTransform(),
            source: h,
            displayState: this.annotationDisplayState,
            dataSource: a.loadedDataSource.layerDataSource,
            subsourceIndex: a.subsourceIndex,
            subsourceId: l.id,
            role: Ei.ANNOTATION
          });
          this.addAnnotationLayerState(g, a);
        });
        continue;
      }
      a.deactivate("Not compatible with annotation layer");
    }
    const s = this.annotationProperties.value;
    si(s) !== si(r) && (this.annotationProperties.value = r);
  }
  initializeAnnotationLayerViewTab(e) {
    const t = e.registerDisposer(nr((r) => r.some((s) => s.source instanceof Fi), this.annotationStates)), n = e.registerDisposer(new lr(t, (r, s, a) => {
      if (r) {
        {
          const l = a.registerDisposer(new _v(this.annotationCrossSectionRenderScaleHistogram, this.annotationCrossSectionRenderScaleTarget));
          l.label.textContent = "Spacing (cross section)", s.appendChild(l.element);
        }
        {
          const l = a.registerDisposer(new _v(this.annotationProjectionRenderScaleHistogram, this.annotationProjectionRenderScaleTarget));
          l.label.textContent = "Spacing (projection)", s.appendChild(l.element);
        }
      }
    }));
    e.element.insertBefore(n.element, e.element.firstChild);
    {
      const r = e.registerDisposer(new Ls(this.annotationDisplayState.ignoreNullSegmentFilter)), s = document.createElement("label");
      s.appendChild(document.createTextNode("Ignore null related segment filter")), s.title = "Display all annotations if filtering by related segments is enabled but no segments are selected", s.appendChild(r.element), e.element.appendChild(s);
    }
    e.element.appendChild(e.registerDisposer(new W6(this.linkedSegmentationLayers)).element);
  }
  toJSON() {
    const e = super.toJSON();
    e[Lk] = this.annotationCrossSectionRenderScaleTarget.toJSON(), e[Dk] = this.annotationProjectionRenderScaleTarget.toJSON(), this.localAnnotations !== void 0 ? e[um] = this.localAnnotations.toJSON() : this.localAnnotationsJson !== void 0 && (e[um] = this.localAnnotationsJson), e[kk] = IO(this.localAnnotationProperties);
    const t = this.localAnnotationRelationships;
    return e[Tk] = t && t.length === 1 && t[0] === "segments" ? void 0 : t, e[_k] = this.annotationDisplayState.ignoreNullSegmentFilter.toJSON(), e[Ik] = this.annotationDisplayState.shader.toJSON(), e[Pk] = this.annotationDisplayState.shaderControls.toJSON(), H(e, this.linkedSegmentationLayers.toJSON()), e;
  }
};
Cs.type = "annotation";
Cs.typeAbbreviation = "ann";
function I2(i) {
  return new HS({
    shaderError: i.annotationDisplayState.shaderError,
    fragmentMain: i.annotationDisplayState.shader,
    shaderControlState: i.annotationDisplayState.shaderControls
  });
}
var q6 = class extends Gh {
  constructor(e) {
    super(), this.layer = e, this.codeWidget = this.registerDisposer(I2(this.layer)), this.content.appendChild(this.codeWidget.element), this.codeWidget.textEditor.refresh();
  }
};
var j6 = class extends qr {
  constructor(e) {
    super(), this.layer = e, this.codeWidget = this.registerDisposer(I2(this.layer));
    const t = this.element;
    t.classList.add("neuroglancer-annotation-rendering-tab"), t.appendChild(this.registerDisposer(new lr(e.annotationProperties, (s, a) => {
      if (s === void 0 || s.length === 0) return;
      const l = document.createElement("div");
      a.appendChild(l), l.classList.add("neuroglancer-annotation-shader-property-list");
      for (const d of s) {
        const u = document.createElement("div");
        u.classList.add("neuroglancer-annotation-shader-property");
        const h = document.createElement("span");
        h.classList.add("neuroglancer-annotation-shader-property-type"), h.textContent = d.type;
        const g = document.createElement("span");
        g.classList.add("neuroglancer-annotation-shader-property-identifier"), g.textContent = `prop_${d.identifier}`, u.appendChild(h), u.appendChild(g);
        const v = d.description;
        v !== void 0 && (u.title = v), l.appendChild(u);
      }
    })).element);
    let n = document.createElement("div");
    n.className = "neuroglancer-segmentation-dropdown-skeleton-shader-header";
    let r = document.createElement("div");
    r.style.flex = "1", r.textContent = "Annotation shader:", n.appendChild(r), n.appendChild(WS({
      title: "Show larger editor view",
      onClick: () => {
        new q6(this.layer);
      }
    })), n.appendChild($S({
      title: "Documentation on annotation rendering",
      href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/annotation/rendering.md"
    })), t.appendChild(n), t.appendChild(this.codeWidget.element), t.appendChild(this.registerDisposer(new qS(e.annotationDisplayState.shaderControls, this.layer.manager.root.display, this.layer, { visibility: this.visibility })).element);
  }
};
Zo(Cs);
Zo(Cs, "pointAnnotation");
LS((i) => {
  if (i.local === Br.annotations)
    return { layerConstructor: Cs, priority: 100 };
  if (i.annotation !== void 0)
    return { layerConstructor: Cs, priority: 1 };
});
jS(Cs, (i) => ({
  shaderControlState: i.annotationDisplayState.shaderControls
}));
var J6 = Object.freeze(Object.defineProperty({
  __proto__: null,
  AnnotationUserLayer: Cs
}, Symbol.toStringTag, { value: "Module" }));
var K6 = rI(J6);
var Y6 = rI(KU);
var X6 = rI(O6);
var Z6 = rI(_N);
function Q6(i) {
  i.registerEventListener(document, "copy", (e) => {
    if (sS(e.target))
      return;
    const t = document.getSelection();
    if (t !== null && t.type === "Range") return;
    const n = xh(i.state).value, r = e.clipboardData;
    r !== null && r.setData("text/plain", oe(n, void 0, "  ")), e.preventDefault();
  });
}
function eq(i, e) {
  let t = $l`^[\[\]{}()\s,]*`;
  for (let s = 0; s < e; ++s)
    s !== 0 && (t += $l`[,\s]+`), t += $l`(\d+(?:\.\d+)?)`;
  t += $l`[\[\]{}()\s,]*$`;
  const n = i.match(t);
  if (n === null) return;
  const r = new Float32Array(e);
  for (let s = 0; s < e; ++s) {
    const a = Number(n[s + 1]);
    if (!Lt(a)) return;
    r[s] = a;
  }
  return r;
}
function tq(i) {
  i.registerEventListener(document, "paste", (e) => {
    if (sS(e.target))
      return;
    const t = e.clipboardData;
    if (t !== null) {
      const n = t.getData("text/plain"), r = eq(n, i.coordinateSpace.value.rank);
      r !== void 0 && (i.navigationState.position.value = r);
    }
    e.preventDefault();
  });
}
var Mk = li("SingleTextureVolumeChunk.textureUnit");
var zd = li("SingleTextureVolumeChunk.textureLayout");
var P2 = class extends X {
  constructor(e, t) {
    super(), this.shaderKey = e, this.dataType = t;
  }
  defineShader(e, t) {
    e.addTextureSampler(this.shaderSamplerType, "uVolumeChunkSampler", Mk);
  }
  beginDrawing(e, t) {
    let n = t.textureUnit(Mk);
    e.activeTexture(WebGL2RenderingContext.TEXTURE0 + n), t[zd] = null;
  }
  endDrawing(e, t) {
    e.bindTexture(zm[this.shaderSamplerType], null), t[zd] = null;
  }
  bindChunk(e, t, n, r, s, a, l) {
    let d = n.textureLayout;
    (t[zd] !== d || l) && (t[zd] = d, this.setupTextureLayout(e, t, d, r, s, a)), e.bindTexture(zm[this.shaderSamplerType], n.texture);
  }
  /**
   * Does nothing, but may be overridden by subclass.
   */
  beginSource(e, t) {
  }
};
var R2 = class extends wz {
  constructor(e, t) {
    super(e, t), this.texture = null, this.data = t.data;
  }
  copyToGPU(e) {
    super.copyToGPU(e);
    let t = this.texture = e.createTexture();
    const n = zm[this.chunkFormat.shaderSamplerType];
    e.bindTexture(n, t), this.setTextureData(e), e.bindTexture(n, null);
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e), e.deleteTexture(this.texture), this.texture = null, this.textureLayout.dispose(), this.textureLayout = null;
  }
};
var nq = class A2 extends X {
  constructor(e, t, n) {
    super(), this.chunkDataSize = t, this.textureDims = n, this.textureShape = new Uint32Array(this.textureDims);
    const r = t.length;
    let s = 0;
    for (const g of t)
      g !== 1 && ++s;
    const a = this.strides = new Uint32Array(r * n), l = n === 3 ? e.max3dTextureSize : e.maxTextureSize;
    let d = 0, u = 1;
    const h = this.textureShape;
    h.fill(1);
    for (let g = 0; g < r; ++g) {
      const v = t[g];
      if (v === 1) continue;
      const y = v * u;
      let C;
      y > l || u !== 1 && d + s < n ? (++d, u = v, C = 1) : (C = u, u = y), a[n * g + d] = C, h[d] = u;
    }
  }
  static get(e, t, n) {
    return e.memoize.get(`sliceview.UncompressedTextureLayout:${t.join()}:${n}`, () => new A2(e, t, n));
  }
};
var hm = new Uint32Array(3 * 5);
var iq = class _2 extends P2 {
  constructor(e, t, n, r) {
    super(n, t), this.textureDims = r, Oc(this, t), this.shaderSamplerType = `${this.samplerPrefix}sampler${r}D`, this.textureAccessHelper = new vU("chunkData", r);
  }
  static get(e, t, n) {
    const r = `sliceview.UncompressedChunkFormat:${t}:${n}`;
    return e.memoize.get(r, () => new _2(e, t, r, n));
  }
  defineShader(e, t) {
    super.defineShader(e, t);
    const n = this.textureDims, r = `ivec${this.textureDims}`;
    let s = this.textureAccessHelper;
    const a = (4 + t) * n;
    hm.length < a && (hm = new Uint32Array(a)), e.addUniform(`highp ${r}`, "uVolumeChunkStrides", 4 + t), e.addFragmentCode(s.getAccessor("readVolumeData", "uVolumeChunkSampler", this.dataType));
    let d = `
${xn(this.dataType)} getDataValueAt(highp ivec3 p`;
    for (let u = 0; u < t; ++u)
      d += `, highp int channelIndex${u}`;
    d += `) {
  highp ${r} offset = uVolumeChunkStrides[0]
                     + p.x * uVolumeChunkStrides[1]
                     + p.y * uVolumeChunkStrides[2]
                     + p.z * uVolumeChunkStrides[3];
`;
    for (let u = 0; u < t; ++u)
      d += `
  offset += channelIndex${u} * uVolumeChunkStrides[${4 + u}];
`;
    d += `
  return readVolumeData(offset);
}
`, e.addFragmentCode(d);
  }
  /**
   * Called each time textureLayout changes while drawing chunks.
   */
  setupTextureLayout(e, t, n, r, s, a) {
    const l = hm, d = a.length, u = n.strides, h = r.length, g = this.textureDims;
    for (let y = 0; y < g; ++y) {
      let C = 0;
      for (let w = 0; w < h; ++w)
        C += r[w] * u[w * g + y];
      l[y] = C;
    }
    for (let y = 0; y < 3; ++y) {
      const C = s[y];
      if (!(C >= h))
        for (let w = 0; w < g; ++w)
          l[(y + 1) * g + w] = u[C * g + w];
    }
    for (let y = 0; y < d; ++y) {
      const C = a[y];
      if (C === -1)
        l.fill(0, (4 + y) * g, (4 + y + 1) * g);
      else
        for (let w = 0; w < g; ++w)
          l[(4 + y) * g + w] = u[C * g + w];
    }
    const v = (4 + d) * g;
    g === 3 ? e.uniform3iv(t.uniform("uVolumeChunkStrides"), l, 0, v) : e.uniform2iv(t.uniform("uVolumeChunkStrides"), l, 0, v);
  }
  getTextureLayout(e, t) {
    return nq.get(e, t, this.textureDims);
  }
  setTextureData(e, t, n) {
    const r = t.textureShape;
    (this.textureDims === 3 ? gU : pU)(e, this, n, r[0], r[1], r[2]);
  }
};
var rq = class extends R2 {
  setTextureData(e) {
    let t = this.source, n = t.chunkFormatHandler, r = n.chunkFormat, s;
    this.chunkDataSize === t.spec.chunkDataSize ? this.textureLayout = s = n.textureLayout.addRef() : this.textureLayout = s = r.getTextureLayout(e, this.chunkDataSize), this.chunkFormat.setTextureData(e, s, this.data);
  }
  getValueAt(e) {
    let t = this.chunkFormat;
    const n = this.chunkDataSize;
    let r = 0, s = 1;
    const a = e.length;
    for (let u = 0; u < a; ++u)
      r += s * e[u], s *= n[u];
    let l = t.dataType, d = this.data;
    switch (l) {
      case j.UINT8:
      case j.INT8:
      case j.FLOAT32:
      case j.UINT16:
      case j.INT16:
      case j.UINT32:
      case j.INT32:
        return d[r];
      case j.UINT64: {
        let u = r * 2;
        return new re(d[u], d[u + 1]);
      }
    }
  }
};
var sq = class extends X {
  constructor(e, t) {
    super();
    let n = 0;
    for (const r of t.chunkDataSize)
      r > 1 && ++n;
    this.chunkFormat = this.registerDisposer(iq.get(e, t.dataType, n >= 3 ? 3 : 2)), this.textureLayout = this.registerDisposer(this.chunkFormat.getTextureLayout(e, t.chunkDataSize));
  }
  getChunk(e, t) {
    return new rq(e, t);
  }
};
EI((i, e) => e.compressedSegmentationBlockSize == null ? new sq(i, e) : null);
function M2(i, e, t, n, r, s) {
  let a = 0, l = 0, d = 1, u = 1;
  for (let w = 0; w < 3; ++w) {
    let b = r[w], E = n[w], T = Math.floor(b / E), I = b % E;
    a += T * d, d *= Math.ceil(t[w] / E), l += I * u, u *= E;
  }
  let h = e + a * 2, g = i[h], v = i[h + 1], y = g & 16777215, C = g >> 24 & 255;
  if (C > 0) {
    let b = (e + v & 16777215) + Math.floor(l * C / 32), E = i[b], T = l * C % 32, I = E >> T & (1 << C) - 1;
    y += s * I;
  }
  return y;
}
function aq(i, e, t, n, r) {
  let s = M2(i, e, t, n, r, 1) + e;
  return i[s];
}
function oq(i, e, t, n, r, s) {
  let a = M2(e, t, n, r, s, 2) + t;
  return i.low = e[a], i.high = e[a + 1], i;
}
var YS = class _YS extends X {
  constructor(e, t) {
    super(), this.chunkDataSize = e, this.subchunkSize = t;
    const n = this.subchunkGridSize = ze();
    for (let r = 0; r < 3; ++r)
      n[r] = Math.ceil(e[r] / t[r]);
  }
  static get(e, t, n) {
    return e.memoize.get(`sliceview.CompressedSegmentationTextureLayout:${Lm(t)},${Lm(n)}`, () => new _YS(t, n));
  }
};
var lq = Oc(new kh(), j.UINT32);
var fm = new Uint32Array(4 * 4);
var XS = class _XS extends P2 {
  constructor(e, t, n, r) {
    super(r, e), this.subchunkSize = t, this.numChannels = n, this.textureAccessHelper = new nS("chunkData");
  }
  // numChannels is the number of channels in the compressed segmentation format, which is
  // independent of the channel dimensions presented to the user.
  static get(e, t, n, r) {
    let s = `sliceview.CompressedSegmentationChunkFormat:${t}:${r}`, a = `${s}:${Lm(n)}`;
    return e.memoize.get(a, () => new _XS(t, n, r, s));
  }
  get shaderSamplerType() {
    return "usampler2D";
  }
  defineShader(e, t) {
    super.defineShader(e, t);
    const n = 4 * (4 + t);
    fm.length < n && (fm = new Uint32Array(n));
    let r = this.textureAccessHelper;
    r.defineShader(e);
    let s = (u) => "compressedSegmentationChunkFormat_" + u;
    e.addUniform("highp ivec3", "uSubchunkGridSize"), e.addUniform("highp ivec3", "uSubchunkSize"), e.addUniform("highp ivec4", "uVolumeChunkStrides", 4 + t), e.addFragmentCode(NB);
    const a = this.dataType, l = xn(a);
    a === j.UINT64 ? e.addFragmentCode(jt) : e.addFragmentCode(Oy), e.addFragmentCode(r.getAccessor(s("readTextureValue"), "uVolumeChunkSampler", j.UINT32, 1));
    let d = `
uint ${s("getChannelOffset")}(int channelIndex) {
  if (channelIndex == 0) {
    return ${this.numChannels}u;
  }
  return ${s("readTextureValue")}(uint(channelIndex)).value;
}
${l} getDataValueAt(highp ivec3 p`;
    for (let u = 0; u < t; ++u)
      d += `, highp int channelIndex${u}`;
    d += `) {
  highp ivec4 chunkPositionFull = uVolumeChunkStrides[0] +
                     + p.x * uVolumeChunkStrides[1]
                     + p.y * uVolumeChunkStrides[2]
                     + p.z * uVolumeChunkStrides[3];
`;
    for (let u = 0; u < t; ++u)
      d += `
  chunkPositionFull += channelIndex${u} * uVolumeChunkStrides[${4 + u}];
`;
    d += `
  highp ivec3 chunkPosition = chunkPositionFull.xyz;

  // TODO: maybe premultiply this and store as uniform.
  ivec3 subchunkGridPosition = chunkPosition / uSubchunkSize;
  int subchunkGridOffset = getFortranOrderIndex(subchunkGridPosition, uSubchunkGridSize);

  int channelOffset = int(${s("getChannelOffset")}(chunkPositionFull[3]));

  // TODO: Maybe just combine this offset into subchunkGridStrides.
  int subchunkHeaderOffset = subchunkGridOffset * 2 + channelOffset;

  highp uint subchunkHeader0 = ${s("readTextureValue")}(uint(subchunkHeaderOffset)).value;
  highp uint subchunkHeader1 = ${s("readTextureValue")}(uint(subchunkHeaderOffset + 1)).value;
  highp uint outputValueOffset = (subchunkHeader0 & 0xFFFFFFu) + uint(channelOffset);
  highp uint encodingBits = subchunkHeader0 >> 24u;
  if (encodingBits > 0u) {
    ivec3 subchunkPosition = chunkPosition - subchunkGridPosition * uSubchunkSize;
    int subchunkOffset = getFortranOrderIndex(subchunkPosition, uSubchunkSize);
    uint encodedValueBaseOffset = subchunkHeader1 + uint(channelOffset);
    uint encodedValueOffset = encodedValueBaseOffset + uint(subchunkOffset) * encodingBits / 32u;
    uint encodedValue = ${s("readTextureValue")}(encodedValueOffset).value;
    uint wordOffset = uint(subchunkOffset) * encodingBits % 32u;
    uint encodedValueShifted = encodedValue >> wordOffset;
    uint decodedValue = encodedValueShifted - (encodedValueShifted >> encodingBits << encodingBits);
    outputValueOffset += decodedValue * ${this.dataType === j.UINT64 ? "2u" : "1u"};
  }
  ${l} result;
`, a === j.UINT64 ? d += `
  result.value[0] = ${s("readTextureValue")}(outputValueOffset).value;
  result.value[1] = ${s("readTextureValue")}(outputValueOffset+1u).value;
` : d += `
  result.value = ${s("readTextureValue")}(outputValueOffset).value;
`, d += `
  return result;
}
`, e.addFragmentCode(d);
  }
  /**
   * Called each time textureLayout changes while drawing chunks.
   *
   * @param channelDimensions The user-specified channel dimensions, independent of the compressed
   * segmentation channels.
   */
  setupTextureLayout(e, t, n, r, s, a) {
    const l = n.subchunkGridSize;
    e.uniform3i(t.uniform("uSubchunkGridSize"), l[0], l[1], l[2]);
    const d = fm, u = a.length;
    d.fill(0);
    for (let h = 0; h < 3; ++h) {
      d[h] = r[h];
      const g = s[h];
      g !== -1 && (d[4 * (h + 1) + g] = 1);
    }
    for (let h = 0; h < u; ++h) {
      const g = a[h];
      g !== -1 && (d[4 * (4 + h) + g] = 1);
    }
    e.uniform4iv(t.uniform("uVolumeChunkStrides"), d, 0, (u + 4) * 4);
  }
  setTextureData(e, t, n) {
    tS(e, lq, n);
  }
  getTextureLayout(e, t) {
    return YS.get(e, t, this.subchunkSize);
  }
  beginSource(e, t) {
    super.beginSource(e, t);
    const n = this.subchunkSize;
    e.uniform3i(t.uniform("uSubchunkSize"), n[0], n[1], n[2]);
  }
};
var cq = class extends R2 {
  setTextureData(e) {
    let t = this.data, n = this.chunkFormat, r = this.textureLayout = n.getTextureLayout(e, this.chunkDataSize);
    n.setTextureData(e, r, t);
  }
  getValueAt(e) {
    let t = this.chunkDataSize, n = this.chunkFormat, r = this.data, s = r[e[3] || 0];
    if (n.dataType === j.UINT64) {
      let a = new re();
      return oq(
        a,
        r,
        /*baseOffset=*/
        s,
        t,
        n.subchunkSize,
        e
      ), a;
    } else
      return aq(
        r,
        /*baseOffset=*/
        s,
        t,
        n.subchunkSize,
        e
      );
  }
};
var dq = class extends X {
  constructor(e, t) {
    super();
    let n = t.dataType;
    if (n !== j.UINT64 && n !== j.UINT32)
      throw new Error(`Unsupported compressed segmentation data type: ${j[n]}`);
    this.chunkFormat = this.registerDisposer(XS.get(e, t.dataType, t.compressedSegmentationBlockSize, t.chunkDataSize[3] || 1));
  }
  getChunk(e, t) {
    return new cq(e, t);
  }
};
EI((i, e) => e.compressedSegmentationBlockSize != null ? new dq(i, e) : null);
function uq(i, e = document.getElementById("neuroglancer-container")) {
  try {
    let t = new NV(e);
    return new j4(t, i);
  } catch (t) {
    throw rt.showMessage(`Error: ${t.message}`), t;
  }
}
function hq(i = document) {
  return Oi(i, "contextmenu", (e) => {
    e.preventDefault();
  });
}
var ZS = "DVID";
function fq(i) {
  return i.text();
}
function pq(i, e = Qt) {
  const t = `${i.url}`, n = { method: i.method, body: i.payload };
  return ws(t, n, Wi, e);
}
function gq(i, e, t = Qt) {
  return mq(i, e.url, { method: e.method, body: e.payload }, Wi, t);
}
function mq(i, e, t, n, r = Qt) {
  return bS(i, e, t, n, (s, a) => {
    const l = H({}, a);
    return s.token && (l.headers = H(H({}, l.headers), { Authorization: `Bearer ${s}` })), l;
  }, (s) => {
    if (s.status === 504)
      return "retry";
    throw s;
  }, r);
}
async function vq(i, e = Qt) {
  return { token: await ws(i, { method: "GET", credentials: "include" }, fq, e) };
}
var yq = class extends Gc {
  constructor(e) {
    super(), this.authServer = e, this.get = Nh((t) => {
      if (!this.authServer) return Ft.resolve({ token: "" });
      const n = new rt(
        /*delay=*/
        true
      );
      let r;
      return new Ft((s, a) => {
        const l = () => {
          r = void 0, n.dispose();
        };
        t.add(() => {
          r !== void 0 && (r.cancel(), r = void 0, n.dispose(), a(bs));
        });
        function d(h, g = "DVID authorization required.", v = "Request authorization.") {
          n.setText(g + " ");
          let y = document.createElement("button");
          y.textContent = v, n.element.appendChild(y), y.addEventListener("click", () => {
            let C = h.match(/^[^\/]+\/\/[^\/\.]+\.([^\/]+)/);
            if (C) {
              const w = `https://flyemlogin.${C[1]}/login`;
              window.alert(`Please log into ${w} and then refresh the neurogalncer page to try again.
If you are unable to log into ${w}, please check your authorization server ${h} to make sure it is correct.`);
            } else
              window.alert(`Please check your authorization server ${h} to make sure it is correct.`);
          }), n.setVisible(true);
        }
        function u(h) {
          r !== void 0 && r.cancel(), r = new Ts(), d(h, "Waiting for DVID authorization...", "Retry"), vq(h, r).then((g) => {
            r !== void 0 && (l(), s(g));
          }, (g) => {
            r !== void 0 && (r = void 0, d(h, `DVID authorization failed: ${g}.`, "Retry"));
          });
        }
        u(this.authServer);
      });
    });
  }
};
var Sq = class extends u$ {
  constructor(e, t) {
    super(new yq(t), {});
  }
};
Jo.register(ZS, (i) => new Sq(i.dvidServer, i.authServer));
var bq = "CredentialsProvider";
var wq = "CredentialsProvider.get";
var Cq = function(i, e, t, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = $i(e, t) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(i, e, t, n);
  else for (var l = i.length - 1; l >= 0; l--) (a = i[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && zi(e, t, s), s;
};
var qv = class extends cr {
  constructor(e, t) {
    super(), this.provider = e, this.registerDisposer(e), this.initializeCounterpart(t);
  }
  get(e, t) {
    return this.provider.get(e, t);
  }
};
qv = Cq([ki(bq)], qv);
zL(wq, function(i, e) {
  return this.get(i.providerId).get(i.invalidCredentials, e).then((n) => ({
    value: n
  }));
});
function xq(i, e) {
  if (e === void 0) return;
  const t = i.memoize.get({ type: "getSharedCredentialsProvider", credentialsProvider: En(e) }, () => new qv(e.addRef(), i.rpc)), n = t.addCounterpartRef();
  return t.dispose(), n;
}
function Kt() {
  return function(i) {
    class e extends i {
      constructor(...n) {
        var r;
        super(...n);
        const s = n[1];
        this.credentialsProvider = (r = s.credentialsProvider) === null || r === void 0 ? void 0 : r.addRef();
      }
      initializeCounterpart(n, r) {
        const s = this.credentialsProvider;
        r.credentialsProvider = xq(this.chunkManager, s), super.initializeCounterpart(n, r);
      }
      static encodeOptions(n) {
        const r = super.encodeOptions(n), s = n.credentialsProvider;
        return r.credentialsProvider = s === void 0 ? void 0 : En(s), r;
      }
    }
    return e;
  };
}
var Eq = wt(128, 128, 128);
var vi;
(function(i) {
  i[i.JPEG = 0] = "JPEG", i[i.RAW = 1] = "RAW", i[i.COMPRESSED_SEGMENTATION = 2] = "COMPRESSED_SEGMENTATION", i[i.COMPRESSED_SEGMENTATIONARRAY = 3] = "COMPRESSED_SEGMENTATIONARRAY";
})(vi || (vi = {}));
var Wh = class {
};
var N22 = class extends Wh {
};
N22.RPC_ID = "dvid/VolumeChunkSource";
var O2 = class extends Wh {
};
O2.RPC_ID = "dvid/SkeletonSource";
var V2 = class extends Wh {
};
V2.RPC_ID = "dvid/MeshSource";
var B2 = class extends Wh {
  constructor() {
    super(...arguments), this.chunkDataSize = Eq;
  }
};
var QS = class extends B2 {
};
QS.RPC_ID = "dvid/AnnotationSource";
var F2 = class extends B2 {
};
F2.RPC_ID = "dvid/AnnotationChunkSource";
var U2 = class {
  constructor(e, t) {
    this.numLevels = 1;
    try {
      if (me(e), t === "dvid") {
        let n = Y(e, "Extended", me);
        if (n.MaxDownresLevel) {
          let r = Y(n, "MaxDownresLevel", un);
          this.numLevels = r + 1;
        }
        this.voxelSize = Y(n, "VoxelSize", (r) => js(ze(), r)), this.upperVoxelBound = Y(n, "MaxPoint", (r) => js(ze(), r.map((s) => ++s))), this.lowerVoxelBound = Y(n, "MinPoint", (r) => js(ze(), r)), this.blockSize = Y(n, "BlockSize", (r) => js(ze(), r));
      } else if (t === "gs") {
        me(e);
        const n = Y(e, "scales", (a) => a);
        if (n.length === 0) throw new Error("Expected at least one scale");
        const r = n[0];
        this.voxelSize = Y(r, "resolution", (a) => ao(ze(), a)), this.lowerVoxelBound = xe(r, "offset", (a) => js(ze(), a)) || wt(0, 0, 0);
        const s = Y(r, "size", (a) => js(ze(), a));
        this.upperVoxelBound = wT(ze(), s, this.lowerVoxelBound), this.blockSize = wt(64, 64, 64);
      } else
        throw new Error("unrecognized volume info");
    } catch (n) {
      throw new Error(`Failed to parse volume geometry: ${n.message}`);
    }
  }
};
var kq = class {
  constructor(e) {
    try {
      this.scales = [], this.scales.push(e);
      let t = e.voxelSize, n = e.lowerVoxelBound, r = e.upperVoxelBound;
      for (let s = 1; s < e.numLevels; ++s) {
        let a = H({}, e);
        a.voxelSize = xT(ze(), t, wt(2, 2, 2)), t = a.voxelSize, a.upperVoxelBound = uC(ze(), Cm(ze(), r, wt(2, 2, 2))), r = a.upperVoxelBound, a.lowerVoxelBound = uC(ze(), Cm(ze(), n, wt(2, 2, 2))), n = a.lowerVoxelBound, this.scales.push(a);
      }
    } catch (t) {
      throw new Error(`Failed to parse multiscale volume specification: ${t.message}`);
    }
  }
  get numChannels() {
    return this.scales.length === 0 ? 0 : this.scales[0].numChannels;
  }
};
var Hh = new he();
Hh.set("uint8", j.UINT8);
Hh.set("uint32", j.UINT32);
Hh.set("uint64", j.UINT64);
var z2 = class {
  constructor(e) {
    this.obj = e, me(e), Y(e, "TypeName", Ae);
  }
  get typeName() {
    return this.obj.TypeName;
  }
  get compressionName() {
    return this.obj.Compression;
  }
  get tags() {
    return this.obj.Tags;
  }
};
var $2 = class {
  constructor(e, t, n) {
    this.name = t, this.base = n, this.volumeInfo = new U2(Iq(n.tags, e), "dvid");
  }
  get lowerVoxelBound() {
    return this.volumeInfo.lowerVoxelBound;
  }
  get upperVoxelBound() {
    return this.volumeInfo.upperVoxelBound;
  }
  get blockSize() {
    return this.volumeInfo.blockSize;
  }
  get voxelSize() {
    return this.volumeInfo.voxelSize;
  }
  get numLevels() {
    return this.volumeInfo.numLevels;
  }
};
var Tq = class extends Jt(Kt()(zc), N22) {
};
var Lq = class extends Jt(Kt()(_h), O2) {
};
var Dq = class extends Jt(Kt()(Vc), V2) {
};
var iu = class extends $2 {
  constructor(e, t, n, r, s) {
    super(e, t, n), this.encoding = r;
    let a = Y(e, "Extended", me), l = Y(a, "Values", (u) => Xe(u, me));
    if (l.length < 1)
      throw new Error("Expected Extended.Values property to have length >= 1, but received: ${JSON.stringify(extendedValues)}.");
    let d = new Ye(s);
    if (r !== vi.COMPRESSED_SEGMENTATIONARRAY)
      for (; d.has(t + "_" + this.volumeInfo.numLevels.toString()); )
        this.volumeInfo.numLevels += 1;
    d.has(t + "_meshes") ? this.meshSrc = t + "_meshes" : this.meshSrc = "", d.has(t + "_skeletons") ? this.skeletonSrc = t + "_skeletons" : this.skeletonSrc = "", this.dataType = Y(l[0], "DataType", (u) => py(u, Hh));
  }
  get volumeType() {
    return this.encoding === vi.COMPRESSED_SEGMENTATION || this.encoding === vi.COMPRESSED_SEGMENTATIONARRAY ? Pn.SEGMENTATION : Pn.IMAGE;
  }
  getSources(e, t, n, r) {
    const s = this.encoding, a = [], l = 64;
    for (let d = 0; d < this.numLevels; ++d) {
      const u = Math.pow(2, d), h = Math.pow(2, -d), g = ze(), v = ze();
      for (let E = 0; E < 3; ++E) {
        const T = Math.floor(this.lowerVoxelBound[E] * h);
        g[E] = T - T % l;
        const I = Math.ceil(this.upperVoxelBound[E] * h);
        v[E] = I, I % l !== 0 && (v[E] += l - I % l);
      }
      let y = t.dataInstanceKey;
      s !== vi.COMPRESSED_SEGMENTATIONARRAY && d > 0 && (y += "_" + d.toString());
      const C = H(H({}, t), { dataInstanceKey: y, dataScale: d.toString(), encoding: s }), w = nt();
      for (let E = 0; E < 3; ++E)
        w[5 * E] = u, w[12 + E] = g[E] * u;
      const b = Wc({
        rank: 3,
        chunkToMultiscaleTransform: w,
        dataType: this.dataType,
        baseVoxelOffset: g,
        upperVoxelBound: CT(ze(), v, g),
        volumeType: this.volumeType,
        volumeSourceOptions: n,
        compressedSegmentationBlockSize: s === vi.COMPRESSED_SEGMENTATION || s === vi.COMPRESSED_SEGMENTATIONARRAY ? wt(8, 8, 8) : void 0
      }).map((E) => ({
        chunkSource: e.getChunkSource(Tq, { spec: E, parameters: C, credentialsProvider: r }),
        chunkToMultiscaleTransform: w
      }));
      a.push(b);
    }
    return yc(a);
  }
};
function G2(i) {
  let e = Y(i, "Base", me), t = Y(e, "Syncs", bi);
  return t.length === 1 ? t[0] : "";
}
function Iq(i, e) {
  if (!i)
    return e;
  const t = e && e.Extended || {};
  let n = t.MaxDownresLevel, r = t.MaxPoint, s = t.MinPoint, a = t.VoxelSize, l = t.BlockSize;
  try {
    i.MaxDownresLevel && typeof i.MaxDownresLevel == "string" ? (n = parseInt(Y(i, "MaxDownresLevel", Ae)), n < 0 && (n = t.MaxDownresLevel)) : typeof i.MaxDownresLevel == "number" && (n = Y(i, "MaxDownresLevel", jT));
  } catch {
  }
  try {
    i.MaxPoint && typeof i.MaxPoint == "string" ? r = JSON.parse(Y(i, "MaxPoint", Ae)) : Array.isArray(i.MaxPoint) && i.MaxPoint.length === 3 && (r = i.MaxPoint);
  } catch {
  }
  try {
    i.MinPoint && typeof i.MinPoint == "string" ? s = JSON.parse(Y(i, "MinPoint", Ae)) : Array.isArray(i.MinPoint) && i.MinPoint.length === 3 && (s = i.MinPoint);
  } catch {
  }
  try {
    i.VoxelSize && typeof i.VoxelSize == "string" ? a = JSON.parse(Y(i, "VoxelSize", Ae)) : Array.isArray(i.VoxelSize) && i.VoxelSize.length === 3 && (a = i.VoxelSize);
  } catch {
  }
  try {
    i.BlockSize && typeof i.BlockSize == "string" ? l = JSON.parse(Y(i, "BlockSize", Ae)) : Array.isArray(i.BlockSize) && i.BlockSize.length === 3 && (l = i.BlockSize);
  } catch {
  }
  return {
    Base: e && e.Base || {},
    Extended: H(H({}, t), {
      VoxelSize: a,
      MinPoint: s,
      MaxPoint: r,
      MaxDownresLevel: n,
      BlockSize: l
    })
  };
}
var W2 = class extends $2 {
  get tags() {
    return Y(this.base.obj, "Tags", me);
  }
  constructor(e, t, n) {
    super(e, t, n);
  }
};
function Pq(i, e, t) {
  me(i);
  let n = i[e], r = Y(n, "Base", (s) => new z2(s));
  if (r.typeName === "annotation") {
    let s = G2(n);
    return s && (n = i[s]), new W2(n, e, r);
  }
  return Rq(n, e, t);
}
function Rq(i, e, t) {
  me(i);
  let n = Y(i, "Base", (r) => new z2(r));
  switch (n.typeName) {
    case "uint8blk":
    case "grayscale8":
      let r = n.compressionName.indexOf("jpeg") !== -1;
      return new iu(i, e, n, r ? vi.JPEG : vi.RAW, t);
    case "labels64":
    case "labelblk":
      return new iu(i, e, n, vi.COMPRESSED_SEGMENTATION, t);
    case "labelarray":
    case "labelmap":
      return new iu(i, e, n, vi.COMPRESSED_SEGMENTATIONARRAY, t);
    default:
      throw new Error(`DVID data type ${oe(n.typeName)} is not supported.`);
  }
}
var qu = class _qu {
  constructor(e) {
    if (this.errors = [], this.dataInstances = new he(), this.vnodes = new Ye(), e instanceof _qu) {
      this.alias = e.alias, this.description = e.description, this.errors = e.errors, this.dataInstances = e.dataInstances;
      return;
    }
    me(e), this.alias = Y(e, "Alias", Ae), this.description = Y(e, "Description", Ae);
    let t = Y(e, "DataInstances", me), n = hn(t);
    for (let a of n)
      try {
        this.dataInstances.set(a, Pq(t, a, n));
      } catch (l) {
        let d = `Failed to parse data instance ${oe(a)}: ${l.message}`;
        console.log(d), this.errors.push(d);
      }
    let r = Y(e, "DAG", me), s = Y(r, "Nodes", me);
    for (let a of hn(s))
      this.vnodes.add(a);
  }
};
function Aq(i) {
  try {
    let n = uh(i, (s) => new qu(s)), r = new he();
    for (let s of n) {
      var e = de(s, 2);
      let a = e[0], l = e[1];
      r.set(a, l);
      for (let d of l.vnodes)
        if (d !== a) {
          let u = new qu(l);
          r.set(d, u);
        }
    }
    for (let s of r) {
      var t = de(s, 2);
      let a = t[0], l = t[1];
      l.uuid = a;
    }
    return r;
  } catch (n) {
    throw new Error(`Failed to parse DVID repositories info: ${n.message}`);
  }
}
var _q = class {
  constructor(e) {
    this.repositories = Aq(e);
  }
  getNode(e) {
    let t = [];
    for (let n of this.repositories.keys())
      n.startsWith(e) && t.push(n);
    if (t.length !== 1)
      throw new Error(`Node key ${oe(e)} matches ${oe(t)} nodes.`);
    return this.repositories.get(t[0]);
  }
};
function H2(i, e, t) {
  return i.memoize.getUncounted({ type: "dvid:getServerInfo", baseUrl: e }, () => {
    const n = gq(t, { url: `${e}/api/repos/info`, method: "GET" }).then((s) => new _q(s)), r = `repository info for DVID server ${e}`;
    return rt.forPromise(n, {
      initialMessage: `Retrieving ${r}.`,
      delay: true,
      errorPrefix: `Error retrieving ${r}: `
    }), n;
  });
}
var Mq = class extends Ps {
  constructor(e, t, n, r) {
    super(e), this.sourceParameters = t, this.info = n, this.credentialsProvider = r;
  }
  get dataType() {
    return this.info.dataType;
  }
  get volumeType() {
    return this.info.volumeType;
  }
  get rank() {
    return 3;
  }
  get baseUrl() {
    return this.sourceParameters.baseUrl;
  }
  get nodeKey() {
    return this.sourceParameters.nodeKey;
  }
  get dataInstanceKey() {
    return this.sourceParameters.dataInstanceKey;
  }
  get supervoxels() {
    return this.sourceParameters.supervoxels || false;
  }
  getSegmentPosition(e) {
    const t = this.sourceParameters.dvidService;
    return t ? fetch(`${t}/locate-body?dvid=${this.baseUrl}&uuid=${this.nodeKey}&segmentation=${this.dataInstanceKey}&body=${e.toString()}${this.supervoxels ? "&supervoxels=true" : ""}`, {
      method: "GET"
    }).then((n) => n.json()).then((n) => new Float32Array(n)) : Ft.reject("No locate service is available");
  }
  getSources(e) {
    return this.info.getSources(this.chunkManager, this.sourceParameters, e, this.credentialsProvider);
  }
};
var Nq = /^((?:http|https):\/\/[^\/]+)\/([^\/]+)\/([^\/\?#]+)(?:(?:\?|#)(.*))?$/;
function q2(i) {
  if (i.startsWith("https"))
    return i + "/api/server/token";
}
function Oq(i) {
  let e = i.match(Nq);
  if (e === null)
    throw new Error(`Invalid DVID URL: ${oe(i)}.`);
  let t = {
    baseUrl: e[1],
    nodeKey: e[2],
    dataInstanceKey: e[3]
  };
  const n = e[4];
  if (n) {
    const r = Fo(n);
    r.usertag === "true" && (t.usertag = true), r.user && (t.user = r.user);
    const s = r.dvidService || r.dvidservice || r["dvid-service"];
    s && (t.dvidService = s), (r.forceDvidService || r.forcedividservice || r["force-dvid-service"]) && (t.forceDvidService = true), t.supervoxels = r.supervoxels === "true";
  }
  return t.authServer = q2(t.baseUrl), t;
}
function Vq(i, e, t) {
  return i.usertag ? gN(ze(), t, e) : i.chunkDataSize;
}
function Bq(i, e) {
  let n = (r) => {
    const s = r.lowerVoxelBound, a = r.upperVoxelBound, l = Vq(e, s, a);
    return { spec: Dc({
      rank: 3,
      chunkDataSize: Uint32Array.from(l),
      lowerVoxelBound: s,
      upperVoxelBound: a
    }), chunkToMultiscaleTransform: nt() };
  };
  if (e.usertag) {
    if (e.user)
      return [[n(i.scales[0])]];
    throw "Expecting a valid user";
  } else
    return [i.scales.map((r) => n(r))];
}
var Fq = Jt(Kt()(Fi), QS);
var Uq = class extends Jt(Kt()(Eo), F2) {
};
var zq = class extends Fq {
  constructor(e, t) {
    super(e, H({ rank: 3, relationships: ["segments"], properties: t.parameters.properties }, t)), this.readonly = false, this.parameters = t.parameters, this.multiscaleVolumeInfo = t.multiscaleVolumeInfo, this.childAdded = this.childAdded || new ct(), this.childUpdated = this.childUpdated || new ct(), this.childDeleted = this.childDeleted || new ct(), this.childRefreshed = this.childRefreshed || new Le(), this.parameters.readonly !== void 0 && (this.readonly = this.parameters.readonly), this.parameters.user || (this.readonly = true);
  }
  getSources(e) {
    let t = Bq(this.multiscaleVolumeInfo, this.parameters), n = 0;
    return t[0].length > 1 && (n = 3), this.chunkSources = t.map((r) => r.map(({ spec: s, chunkToMultiscaleTransform: a }) => ({
      chunkSource: this.chunkManager.getChunkSource(Uq, {
        spec: H({ limit: n, chunkToMultiscaleTransform: a }, s),
        parent: this,
        credentialsProvider: this.credentialsProvider,
        parameters: this.parameters
      }),
      chunkToMultiscaleTransform: a
    }))), this.chunkSources;
  }
  invalidateCache() {
    this.metadataChunkSource.invalidateCache();
    for (let e of this.chunkSources)
      for (let t of e)
        t.chunkSource.invalidateCache();
    for (let e of this.segmentFilteredSources)
      e.invalidateCache();
    this.childRefreshed.dispatch();
  }
};
async function $q(i, e, t, n) {
  let r = (a, l) => i.chunkManager.getChunkSource(zq, {
    parameters: l,
    credentialsProvider: n,
    multiscaleVolumeInfo: a
  }), s = new kq(t.volumeInfo);
  return r(s, e);
}
async function Gq(i, e, t, n) {
  const r = {
    lowerBounds: new Float64Array(t.lowerVoxelBound),
    upperBounds: Float64Array.from(t.upperVoxelBound)
  }, s = yt({
    rank: 3,
    names: ["x", "y", "z"],
    units: ["m", "m", "m"],
    scales: Float64Array.from(t.voxelSize, (d) => d / 1e9),
    boundingBoxes: [fa(r)]
  }), a = await $q(i, e, t, n);
  return {
    modelTransform: ei(s),
    subsources: [{
      id: "default",
      subsource: { annotation: a },
      default: true
    }]
  };
}
function Wq(i, e, t, n) {
  const r = t, s = {
    lowerBounds: new Float64Array(r.lowerVoxelBound),
    upperBounds: Float64Array.from(r.upperVoxelBound)
  }, a = yt({
    rank: 3,
    names: ["x", "y", "z"],
    units: ["m", "m", "m"],
    scales: Float64Array.from(r.voxelSize, (u) => u / 1e9),
    boundingBoxes: [fa(s)]
  }), l = new Mq(i.chunkManager, e, r, n), d = {
    modelTransform: ei(a),
    subsources: [{
      id: "default",
      subsource: { volume: l },
      default: true
    }]
  };
  if (r.meshSrc) {
    const u = nt();
    for (let h = 0; h < 3; ++h)
      u[5 * h] = 1 / r.voxelSize[h];
    d.subsources.push({
      id: "meshes",
      default: true,
      subsource: {
        mesh: i.chunkManager.getChunkSource(Dq, {
          parameters: H(H({}, e), { segmentationName: r.name, dataInstanceKey: r.meshSrc }),
          credentialsProvider: n
        })
      },
      subsourceToModelSubspaceTransform: u
    });
  }
  return r.skeletonSrc && d.subsources.push({
    id: "skeletons",
    default: true,
    subsource: {
      mesh: i.chunkManager.getChunkSource(Lq, {
        parameters: H(H({}, e), { dataInstanceKey: r.skeletonSrc }),
        credentialsProvider: n
      })
    }
  }), d.subsources.push({
    id: "bounds",
    subsource: { staticAnnotations: Ec(s) },
    default: true
  }), d;
}
function Hq(i) {
  return i.chunkManager.memoize.getUncounted({
    type: "dvid:MultiscaleVolumeChunkSource",
    sourceUrl: i.providerUrl
  }, async () => {
    const e = Oq(i.providerUrl), t = e.baseUrl, n = e.nodeKey, r = e.dataInstanceKey, s = n.indexOf(":"), a = s !== -1 ? n.slice(0, s) : n, l = i.credentialsManager.getCredentialsProvider(ZS, { dvidServer: e.baseUrl, authServer: e.authServer }), u = (await H2(i.chunkManager, t, l)).getNode(a);
    if (u === void 0)
      throw new Error(`Invalid node: ${oe(n)}.`);
    const h = u.dataInstances.get(r);
    if (!h)
      throw new Error(`Invalid data instance ${r}.`);
    if (h.base.typeName === "annotation") {
      if (!(h instanceof W2))
        throw new Error(`Invalid data instance ${r}.`);
      let g = H(H({}, new QS()), e);
      return h.blockSize && (g.chunkDataSize = h.blockSize), g.syncedLabel = G2({ Base: h.base.obj }), g.properties = [{
        identifier: "rendering_attribute",
        description: "rendering attribute",
        type: "int32",
        default: 0,
        min: 0,
        max: 5,
        step: 1
      }, {
        identifier: "confidence",
        description: "confidence",
        type: "float32",
        default: 0,
        min: 0,
        max: 1,
        step: 0.01
      }], Gq(i, g, h, l);
    } else {
      if (!(h instanceof iu))
        throw new Error(`Invalid data instance ${r}.`);
      return Wq(i, e, h, l);
    }
  });
}
function qq(i, e) {
  return {
    offset: 0,
    completions: Wo(e, i.dataInstances.values(), (t) => t.name, (t) => `${t.base.typeName}`)
  };
}
function jq(i, e) {
  let t = e.match(/^(?:([^\/]+)(?:\/([^\/]*))?)?$/);
  if (t === null)
    throw new Error("Invalid DVID URL syntax.");
  if (t[2] === void 0)
    return {
      offset: 0,
      completions: Wo(e, i.repositories.values(), (s) => s.uuid + "/", (s) => `${s.alias}: ${s.description}`)
    };
  let n = t[1], r = i.getNode(n);
  return Go(n.length + 1, qq(r, t[2]));
}
async function Jq(i) {
  const e = /^((?:http|https):\/\/[^\/]+)\/([^\?]*).*$/;
  let n = i.providerUrl.match(e);
  if (n === null)
    throw null;
  let r = n[1], s = n[2], a = q2(r);
  const l = await H2(i.chunkManager, r, i.credentialsManager.getCredentialsProvider(ZS, { dvidServer: r, authServer: a }));
  return Go(r.length + 1, jq(l, s));
}
var Kq = class extends pa {
  constructor(e) {
    super(), this.credentialsManager = e;
  }
  get description() {
    return "DVID";
  }
  get(e) {
    return Hq(e);
  }
  completeUrl(e) {
    return Jq(e);
  }
};
va("dvid", (i) => new Kq(i.credentialsManager));
function Nk(i) {
  return i.text();
}
function Yq(i, e, t, n = Qt) {
  const r = { method: t.method, body: t.payload };
  return r.method === "POST" && (r.headers = {
    "Content-Type": "application/json"
  }), Zq(i, e, t.url, r, Wi, n);
}
function Xq(i) {
  return (e, t) => {
    let n = H({}, t);
    return e ? n.headers = H(H({}, n.headers), { Authorization: `Bearer ${e}` }) : i.startsWith("https:") && (n.credentials = "include"), n;
  };
}
function Zq(i, e, t, n, r, s = Qt) {
  return bS(i, t, n, r, Xq(t), (a) => {
    const l = a.status;
    if ((l === 403 || l === 401) && e)
      return "refresh";
    if (l === 504)
      return "retry";
    throw a;
  }, s);
}
function Qq(i) {
  return "neurohub" in i ? Ft.resolve(i.neurohub.clio.auth.getAuthResponse().id_token) : Ft.resolve("");
}
var e5 = class extends Gc {
  constructor(e, t) {
    super(), this.authServer = e, this.retry = t, this.get = Nh((n) => {
      const r = new rt(
        /*delay=*/
        true
      );
      let s;
      return new Ft((a, l) => {
        const d = () => {
          s = void 0, r.dispose();
        };
        n.add(() => {
          s !== void 0 && (s.cancel(), s = void 0, r.dispose(), l(bs));
        });
        const u = (v = "Authorization required.", y = "Request authorization.") => {
          if (r.setText(v + " "), this.retry) {
            let C = document.createElement("button");
            C.textContent = y, r.element.appendChild(C), C.addEventListener("click", this.retry);
          }
          r.setVisible(true);
        };
        let h = this.authServer;
        (() => {
          s !== void 0 && s.cancel(), s = new Ts(), u("Waiting for authorization...", "Retry"), this.getAuthToken(h, s).then((v) => {
            s !== void 0 && (d(), a(v));
          }, (v) => {
            s !== void 0 && (s = void 0, u(`Authorization failed: ${v}.`, "Retry"));
          });
        })();
      });
    });
  }
  getAuthToken(e, t = Qt) {
    if (e) {
      if (e.startsWith("token:"))
        return Ft.resolve(e.substring(6));
      if (e == "neurohub")
        return Qq(window);
      {
        const n = new Headers();
        return ws(e, { method: "GET", headers: n }, Nk, t).catch(() => ws(e, { method: "GET" }, Nk, t));
      }
    } else return Ft.resolve("");
  }
};
var j2 = "Clio";
var t5 = /^([^\/]+:\/\/[^\/]+)\/([^\/]+)\/([^\/\?]+)(\?.*)?$/;
function n5(i) {
  let e = i.match(t5);
  if (e === null)
    throw new Error(`Invalid DVID URL: ${oe(i)}.`);
  return {
    baseUrl: e[1],
    nodeKey: e[2],
    dataInstanceKey: e[3]
  };
}
function J2(i) {
  let e = _o(i);
  return e.protocol === "precomputed" && (e = _o(e.host + e.path)), e;
}
function K2(i) {
  let e = i.protocol, t = i.host, n = i.path;
  switch (e) {
    case "gs":
      return `https://storage.googleapis.com/${t}${n}/info`;
    case "dvid":
      const r = n5(t + n);
      return `${r.baseUrl}/api/node/${r.nodeKey}/${r.dataInstanceKey}/info`;
    case "https":
      return `${e}://${t}${n}/info`;
    default:
      throw Error("Unrecognized volume information");
  }
}
var i5 = class {
  constructor(e) {
    this.parameters = e;
  }
  getTopLevelUrl() {
    var e = this.parameters;
    const t = e.baseUrl, n = e.api;
    return `${t}/${n || "clio_toplevel"}`;
  }
  getDatasetsUrl() {
    return `${this.getTopLevelUrl()}/datasets`;
  }
  getGrayscaleInfoUrl() {
    let e = J2(this.parameters.grayscale);
    return K2(e);
  }
  getAnnotationEndpoint() {
    return this.parameters.kind === "Atlas" ? "atlas" : "annotations";
  }
  getAnnotationEntryUrl() {
    return `${this.getTopLevelUrl()}/${this.getAnnotationEndpoint()}/${this.parameters.dataset}`;
  }
  getAllAnnotationsUrl() {
    return this.getAnnotationEntryUrl() + (this.parameters.groups ? `?groups=${this.parameters.groups}` : "");
  }
  hasPointQueryApi() {
    return this.parameters.api === "clio_toplevel" || this.parameters.kind === "Atlas";
  }
  getPostAnnotationUrl(e) {
    return this.hasPointQueryApi() ? `${this.getAnnotationEntryUrl()}?x=${e[0]}&y=${e[1]}&z=${e[2]}` : this.getAnnotationEntryUrl();
  }
  getDeleteAnnotationUrl(e) {
    if (this.hasPointQueryApi()) {
      const t = e.match(/(-?\d+)_(-?\d+)_(-?\d+)/);
      if (t)
        return this.getAnnotationUrl(t == null ? void 0 : t.slice(1, 4));
    }
    return `${this.getAnnotationEntryUrl()}/${e}`;
  }
  getAnnotationUrl(e) {
    return `${this.getAnnotationEntryUrl()}?x=${e[0]}&y=${e[1]}&z=${e[2]}`;
  }
};
var r5 = class extends e5 {
  constructor(e) {
    super(e), this.authServer = e;
  }
};
Jo.register(j2, (i) => new r5(i));
var s5 = "annotation.add.signal";
zt(s5, function(i) {
  const e = this.get(i.id), t = yy(i.newAnnotation);
  t && (e.parent.updateReference(t), e.parent.childAdded.dispatch(t));
});
var a5 = class {
  constructor(e) {
    this.annotation = e;
  }
  get renderingAttribute() {
    if (this.kind === "Atlas")
      if (this.title) {
        if (this.checked)
          return 1;
      } else return -1;
    else {
      if (this.bookmarkType === "False Split")
        return 2;
      if (this.bookmarkType === "False Merge")
        return 3;
    }
    return 0;
  }
  get confidence() {
    return 0;
  }
  updateProperties() {
    this.annotation.properties = [this.renderingAttribute, this.confidence];
  }
  get ext() {
    return this.annotation.ext === void 0 && (this.annotation.ext = {}), this.annotation.ext;
  }
  get prop() {
    return this.annotation.prop;
  }
  set prop(e) {
    this.annotation.prop = e;
  }
  get bookmarkType() {
    if (this.prop)
      switch (this.prop.type) {
        case "Split":
          return "False Merge";
        case "Merge":
          return "False Split";
      }
    return "Other";
  }
  get type() {
    return this.annotation.type;
  }
  get kind() {
    return this.annotation.kind;
  }
  set kind(e) {
    this.annotation.kind = e, this.update();
  }
  roundPos() {
    this.annotation.type === Fe.POINT ? this.annotation.point = this.annotation.point.map((e) => Math.round(e)) : (this.annotation.type === Fe.LINE || this.annotation.type === Fe.SPHERE) && (this.annotation.pointA = this.annotation.pointA.map((e) => Math.round(e)), this.annotation.pointB = this.annotation.pointB.map((e) => Math.round(e)));
  }
  setProp(e) {
    this.prop = H(H({}, this.prop), e);
  }
  get user() {
    return this.prop && this.prop.user;
  }
  set user(e) {
    this.setProp({ user: e });
  }
  get comment() {
    return this.prop && this.prop.comment;
  }
  get description() {
    return this.comment;
  }
  updatePresentation() {
    this.title ? this.annotation.description = this.title + ": " : this.annotation.description = "", this.description && (this.annotation.description += this.description);
  }
  update() {
    this.updatePresentation(), this.updateProperties();
  }
  set comment(e) {
    this.setProp({ comment: e }), this.updatePresentation();
  }
  updateComment() {
    this.comment = this.annotation.description || "", this.annotation.description = void 0;
  }
  get title() {
    return this.prop && this.prop.title;
  }
  set title(e) {
    this.setProp({ title: e }), this.updatePresentation();
  }
  get timestamp() {
    return this.prop && this.prop.timestamp ? Number(this.prop.timestamp) : 0;
  }
  addTimeStamp() {
    this.setProp({ timestamp: String(Date.now()) });
  }
  get checked() {
    return this.ext && this.ext.verified || this.prop && this.prop.checked || false;
  }
  set checked(e) {
    this.setProp({ checked: e });
  }
  get presentation() {
    return this.updatePresentation(), this.annotation.description || "";
  }
  set presentation(e) {
    this.annotation.description = e;
  }
};
function o5(i) {
  const e = i.split(".")[1];
  if (e) {
    const t = e.replace(/-/g, "+").replace(/_/g, "/"), n = decodeURIComponent(window.atob(t).split("").map(function(r) {
      return "%" + ("00" + r.charCodeAt(0).toString(16)).slice(-2);
    }).join(""));
    return JSON.parse(n);
  }
}
function Y2(i, e) {
  let t;
  const n = o5(i);
  return n && ("user" in n ? t = n.user : "email" in n && (t = n.email)), t || (t = e), t;
}
var l5 = {
  definitions: {},
  type: "object",
  required: ["Prop"],
  properties: {
    Prop: {
      $id: "#/properties/Prop",
      type: "object",
      title: "Properties",
      required: ["comment"],
      properties: {
        comment: {
          $id: "#/properties/Prop/properties/comment",
          type: "string",
          title: "Comment",
          default: ""
        }
      }
    }
  }
};
var $d = class extends a5 {
  get title() {
    return this.annotation.ext && this.annotation.ext.title;
  }
  set title(e) {
    this.ext.title = e;
  }
  get description() {
    return this.annotation.ext && this.annotation.ext.description;
  }
  set description(e) {
    this.ext.description = e;
  }
  get user() {
    return this.annotation.ext && this.annotation.ext.user;
  }
  set user(e) {
    this.ext.user = e;
  }
  get checked() {
    return this.ext && this.ext.verified;
  }
  set checked(e) {
    this.ext.verified = e;
  }
};
function c5(i) {
  let e = i.match(/^\${(.*):JSON}$/);
  return e ? JSON.parse(e[1]) : null;
}
var d5 = {
  definitions: {},
  type: "object",
  required: ["Prop"],
  properties: {
    Prop: {
      $id: "#/properties/Prop",
      type: "object",
      title: "Properties",
      required: ["description"],
      properties: {
        description: {
          $id: "#/properties/Prop/properties/description",
          type: "string",
          title: "Description",
          default: ""
        }
      }
    }
  }
};
var u5 = {
  definitions: {},
  type: "object",
  required: ["Prop"],
  properties: {
    Prop: {
      $id: "#/properties/Prop",
      type: "object",
      title: "Properties",
      required: ["title", "description"],
      properties: {
        title: {
          $id: "#/properties/Prop/properties/title",
          type: "string",
          title: "Title",
          default: ""
        },
        description: {
          $id: "#/properties/Prop/properties/description",
          type: "string",
          title: "Description",
          default: ""
        }
      }
    }
  }
};
function X2(i) {
  return Array.isArray(i);
}
function h5(i) {
  return X2(i) || i === null ? false : typeof i == "object";
}
var Z2 = class {
  constructor(e) {
    this.name = e, this.childNodeList = new Array(), this.parentNode = null;
  }
  isRoot() {
    return this.parentNode === null;
  }
  isLeaf() {
    return this.childNodeList.length === 0;
  }
  *[qn]() {
    function* e(t) {
      yield t;
      for (let n of t.childNodeList)
        yield* e(n);
    }
    yield* e(this);
  }
  *leafNodes() {
    for (let e of this)
      e.childNodeList.length === 0 && (yield e);
  }
  get fullName() {
    let e = this.name, t = this.parentNode;
    for (; t; )
      e = t.name + "/" + e, t = t.parentNode;
    return e;
  }
  get nameArray() {
    let e = new Array();
    if (!this.isRoot()) {
      e.push(this.name);
      let t = this.parentNode;
      for (; t && !t.isRoot(); )
        e.push(t.name), t = t.parentNode;
    }
    return e;
  }
  getPropertyValue(e) {
    if (!this.isRoot() && e) {
      let t = this.nameArray, n = e;
      for (let r = t.length - 1; r >= 0; --r)
        if (h5(n)) {
          let s = t[r];
          n = n[s];
        } else
          return n;
      return n;
    }
  }
};
function Q2(i, e) {
  if (i.type == "object") {
    e.properties == null && (e.properties = {}), e.properties.title = i.title;
    let t = i.required;
    X2(t) && t.forEach((n) => {
      let r = new Z2(n);
      r.parentNode = e, e.childNodeList.push(r);
      let a = i.properties[n];
      Q2(a, r);
    });
  } else
    e.properties = i;
}
function f5(i, e) {
  let t = new Z2(e);
  return Q2(i, t), t;
}
var p5 = "annotation";
function g5(i, e, t, n = false) {
  let r = document.createElement("div"), s = i.title;
  s && r.appendChild(document.createTextNode(s));
  let a;
  switch (i.type) {
    case "number":
      a = document.createElement("input"), typeof t == "number" && (a.text = t);
      break;
    case "string":
      let l = i.enum;
      Array.isArray(l) ? (a = document.createElement("select"), r.appendChild(a), l.forEach((d) => {
        let u = document.createElement("option");
        u.text = d, u.value = d, u.disabled = n, a.appendChild(u);
      }), t !== void 0 && (a.value = t)) : (a = document.createElement("input"), a.setAttribute("autocomplete", "off"), typeof t == "string" && (a.value = t, a.setAttribute("value", t)));
      break;
    case "boolean":
      a = document.createElement("input"), a.type = "checkbox", typeof t == "boolean" ? a.checked = t : a.checked = t == 1;
      break;
  }
  return a && (a.id = e, a.readOnly = n, r.appendChild(a)), r;
}
function m5(i, e) {
  return i + "/" + e;
}
function v5(i, e, t, n = false) {
  let r = document.createElement("div"), s = f5(i, t);
  s.record = r;
  for (let a of s)
    if (!a.isRoot())
      if (a.isLeaf()) {
        let l = a.getPropertyValue(e), d = g5(a.properties, a.fullName, l, n);
        a.parentNode.record.appendChild(d);
      } else {
        let l = document.createElement("fieldset"), d = document.createElement("legend");
        d.textContent = a.properties.title, l.appendChild(d), a.record = l, a.parentNode.record.appendChild(l);
      }
  return r;
}
function y5(i, e, t = false) {
  return v5(i, e, p5, t);
}
function S5(i) {
  let e = document.getElementById(i);
  if (e)
    return e.type === "checkbox" ? e.checked : e.value;
}
function eR(i, e, t, n) {
  i.type === "object" ? i.required.forEach((r) => {
    let s = t;
    e && (typeof t[e] > "u" && (t[e] = {}), s = t[e]), eR(i.properties[r], r, s, m5(n, r));
  }) : t[e] = S5(n);
}
function b5(i, e, t, n, r, s) {
  const a = H({}, i.value);
  if (a.type !== Fe.POINT && a.type !== Fe.LINE && a.type !== Fe.SPHERE)
    return null;
  e || (e = l5);
  const l = n(a), d = r ? r(a) : l.prop;
  let u = y5(e, d ? { Prop: d } : {}, t.readonly), h = document.createElement("button");
  return h.textContent = "update", h.onclick = () => {
    let g = {};
    eR(e, "", g, "annotation");
    const v = g.Prop;
    s ? s(a, v) : l.setProp(v), l.update(), t.update(i, a), t.commit(i);
  }, u.appendChild(h), u;
}
var w5 = `
{
  "definitions": {},
  "type": "object",
  "required": [
    "Prop"
  ],
  "properties": {
    "Prop": {
      "$id": "#/properties/Prop",
      "type": "object",
      "title": "Properties",
      "required": [
        "comment",
        "type",
        "checked"
      ],
      "properties": {
        "comment": {
          "$id": "#/properties/Prop/properties/comment",
          "type": "string",
          "title": "Comment",
          "default": ""
        },
        "type": {
          "$id": "#/properties/Prop/properties/type",
          "type": "string",
          "title": "Type",
          "enum": ["Merge", "Split", "Other"]
        },
        "checked": {
          "$id": "#/properties/Prop/properties/checked",
          "type": "boolean",
          "title": "Checked"
        }
      }
    }
  }
}
`;
JSON.parse(w5);
var C5 = wt(64, 64, 64);
var x5 = class {
};
function E5(i) {
  return i.authServer ? i.authServer === "neurohub" || i.authServer.startsWith("http") : false;
}
var tR = class extends x5 {
  constructor() {
    super(...arguments), this.chunkDataSize = C5;
  }
};
var e0 = class extends tR {
};
e0.RPC_ID = "clio/Annotation";
var nR = class extends tR {
};
nR.RPC_ID = "clio/AnnotationChunkSource";
var k5 = class extends Jt(Kt()(Eo), nR) {
};
async function T5(i) {
  const e = i.grayscale;
  if (e) {
    let t = J2(e);
    return pq({
      method: "GET",
      url: K2(t)
    }).then((n) => new U2(n, t.protocol === "https" ? "gs" : t.protocol));
  } else
    return Ft.resolve({
      numChannels: 1,
      voxelSize: wt(8, 8, 8),
      lowerVoxelBound: wt(0, 0, 0),
      upperVoxelBound: wt(5e4, 5e4, 5e4),
      blockSize: wt(64, 64, 64),
      numLevels: 1
    });
}
function L5(i) {
  return [[((n) => {
    const r = n.upperVoxelBound;
    return { spec: Dc({
      rank: 3,
      chunkDataSize: Uint32Array.from(r),
      lowerVoxelBound: n.lowerVoxelBound,
      upperVoxelBound: n.upperVoxelBound
    }), chunkToMultiscaleTransform: nt() };
  })(i)]];
}
var D5 = Jt(Kt()(Fi), e0);
var I5 = class extends D5 {
  constructor(e, t) {
    super(e, H({ rank: 3, relationships: ["segments"], properties: t.parameters.properties }, t)), this.readonly = false, this.parameters = t.parameters, this.dataInfo = t.dataInfo, this.childAdded = this.childAdded || new ct(), this.childUpdated = this.childUpdated || new ct(), this.childDeleted = this.childDeleted || new ct(), this.makeEditWidget = (n) => {
      const r = (l) => new $d(l), s = (l) => H(H({}, l.prop), l.ext), a = (l, d) => {
        const u = new $d(l);
        d.title && (u.title = d.title), d.description && (u.description = d.description);
      };
      return b5(n, this.parameters.schema, this, r, s, a);
    }, this.getUser = () => this.parameters.user;
  }
  getSources(e) {
    let t = L5(this.dataInfo), n = 0;
    return t[0].length > 1 && (n = 10), t.map((r) => r.map(({ spec: s, chunkToMultiscaleTransform: a }) => ({
      chunkSource: this.chunkManager.getChunkSource(k5, {
        spec: H({ limit: n, chunkToMultiscaleTransform: a }, s),
        parent: this,
        credentialsProvider: this.credentialsProvider,
        parameters: this.parameters
      }),
      chunkToMultiscaleTransform: a
    })));
  }
  *[qn]() {
    for (let e of this.references)
      e[1].value && (yield e[1].value);
  }
  commit(e) {
    e.value && (e.value.type === Fe.LINE || e.value.type === Fe.SPHERE) && (e.value.pointA = e.value.pointA.map((t) => Math.round(t)), e.value.pointB = e.value.pointB.map((t) => Math.round(t))), super.commit(e);
  }
  add(e, t = true) {
    if (this.readonly) {
      let r = "Permission denied for changing annotations.";
      throw rt.showTemporaryMessage(r), Error(r);
    }
    const n = new $d(e);
    if (n.addTimeStamp(), this.parameters.user && (n.user = this.parameters.user), e.type === Fe.POINT && (n.kind = this.parameters.kind || "Note", e.description)) {
      let r = c5(e.description);
      r && n.setProp(r);
    }
    return n.roundPos(), n.update(), super.add(e, t);
  }
  update(e, t) {
    const n = new $d(t);
    n.roundPos(), n.update(), super.update(e, t);
  }
  invalidateCache() {
    this.references.forEach((e) => {
      e.dispose();
    }), this.references.clear(), this.childRefreshed.dispatch(), this.metadataChunkSource.invalidateCache();
    for (let e of this.getSources({
      multiscaleToViewTransform: new Float32Array(),
      displayRank: 1,
      modelChannelDimensionIndices: []
    }))
      for (let t of e)
        t.chunkSource.invalidateCache();
    for (let e of this.segmentFilteredSources)
      e.invalidateCache();
  }
};
async function P5(i, e, t, n) {
  return ((s, a) => i.chunkManager.getChunkSource(I5, {
    parameters: a,
    credentialsProvider: n,
    dataInfo: s
  }))(t, e);
}
async function R5(i, e, t) {
  const n = await T5(e), r = {
    lowerBounds: new Float64Array(n.lowerVoxelBound),
    upperBounds: Float64Array.from(n.upperVoxelBound)
  }, s = yt({
    rank: 3,
    names: ["x", "y", "z"],
    units: ["m", "m", "m"],
    scales: Float64Array.from(n.voxelSize, (d) => d / 1e9),
    boundingBoxes: [fa(r)]
  }), a = await P5(i, e, n, t);
  return {
    modelTransform: ei(s),
    subsources: [{
      id: "default",
      subsource: { annotation: a },
      default: true
    }]
  };
}
var A5 = /^([^\/]+:\/\/[^\/]+)\/(?:([^\/\?#]+)\/)?([^\/\?#]+)(?:(?:\?|#)(.*))?$/;
function _5(i) {
  let e = i.match(A5);
  if (e === null)
    throw new Error(`Invalid Clio URL: ${oe(i)}.`);
  let t = {
    baseUrl: e[1],
    api: e[2],
    dataset: e[3]
  }, n = e[4];
  if (n) {
    let r = Fo(n);
    r.token ? (t.authToken = r.token, t.authServer = "token:" + r.token) : r.auth && (t.authServer = r.auth), r.user ? t.user = r.user : t.authToken && (t.user = Y2(t.authToken)), r.kind ? r.kind === "atlas" ? t.kind = "Atlas" : t.kind = r.kind : t.kind = "Normal", r.groups && (t.groups = r.groups);
  }
  return t;
}
async function M5(i, e) {
  const t = new i5(i);
  return Yq(e(i.authServer), E5(i), {
    url: t.getDatasetsUrl(),
    method: "GET"
  }).then((n) => {
    const r = Y(n, i.dataset, me);
    if ("location" in r)
      i.grayscale = Y(r, "location", Ae);
    else if ("mainLayer" in r) {
      const s = Y(r, "mainLayer", Ae), d = Y(r, "neuroglancer", me).layers.find((u) => u.name === s);
      d.source && d.source.url ? i.grayscale = Y(d.source, "url", Ae) : i.grayscale = Y(d, "source", Ae);
    }
    return i;
  });
}
async function N5(i, e) {
  let t = _5(i.providerUrl);
  if (!t.user && t.authServer) {
    let n = e(t.authServer).get();
    t.authToken = (await n).credentials, t.user = Y2(t.authToken);
  }
  return i.chunkManager.memoize.getUncounted(H({ type: "clio:MultiscaleVolumeChunkSource" }, t), async () => {
    t = await M5(t, e);
    let n = H(H({}, new e0()), t);
    t.kind === "Atlas" ? n.schema = u5 : n.schema = d5, n.properties = [{
      identifier: "rendering_attribute",
      description: "rendering attribute",
      type: "int32",
      default: 0,
      min: 0,
      max: 5,
      step: 1
    }];
    const r = e(t.authServer);
    return R5(i, n, r);
  });
}
async function O5(i) {
  return Ft.resolve({
    offset: 0,
    completions: [{ value: "" }]
  });
}
var V5 = class extends pa {
  constructor(e) {
    super(), this.credentialsManager = e, this.description = "Clio";
  }
  getCredentialsProvider(e) {
    let t = "";
    return e && (t = e), this.credentialsManager.getCredentialsProvider(j2, t);
  }
  get(e) {
    return N5(e, this.getCredentialsProvider.bind(this));
  }
  completeUrl(e) {
    return O5(e.providerUrl);
  }
};
va("clio", (i) => new V5(i.credentialsManager));
var qh = "google-brainmaps";
function Za(i, e, t, n = Qt) {
  return Ys(e, `${i.serverUrl}${t.path}`, { method: t.method, body: t.payload }, t.responseType === "json" ? Wi : uG, n);
}
var Lr;
(function(i) {
  i[i.RAW = 0] = "RAW", i[i.JPEG = 1] = "JPEG", i[i.COMPRESSED_SEGMENTATION = 2] = "COMPRESSED_SEGMENTATION";
})(Lr || (Lr = {}));
var iR = class {
};
iR.RPC_ID = "brainmaps/VolumeChunkSource";
var rR = class {
};
rR.RPC_ID = "brainmaps/MultiscaleMeshSource";
var sR = class {
};
sR.RPC_ID = "brainmaps/MeshSource";
var aR = class {
};
aR.RPC_ID = "brainmaps/SkeletonSource";
var oR = class {
};
oR.RPC_ID = "brainmaps/Annotation";
var lR = class {
};
lR.RPC_ID = "brainmaps/AnnotationSpatialIndex";
var B5 = class extends Jt(Kt()(zc), iR) {
};
var F5 = class extends Jt(Kt()(Ah), rR) {
};
var U5 = class extends Jt(Kt()(Vc), sR) {
};
var z5 = class extends Jt(Kt()(_h), aR) {
};
var $5 = class extends Jt(Kt()(Eo), lR) {
};
var Hc = new he();
Hc.set("UINT8", j.UINT8);
Hc.set("FLOAT", j.FLOAT32);
Hc.set("UINT32", j.UINT32);
Hc.set("UINT64", j.UINT64);
function G5(i) {
  me(i);
  try {
    return {
      corner: Y(i, "corner", (e) => ec(ze(), e, Dt)),
      size: Y(i, "size", (e) => ec(ze(), e, yn)),
      metadata: Y(i, "metadata", Ci)
    };
  } catch (e) {
    throw new Error(`Failed to parse bounding box: ${e.message}`);
  }
}
var W5 = class {
  constructor(e) {
    try {
      me(e), this.numChannels = Y(e, "channelCount", un), this.dataType = Y(e, "channelType", (t) => py(t, Hc)), this.voxelSize = Y(e, "pixelSize", (t) => ec(ze(), t, yn)), this.upperVoxelBound = Y(e, "volumeSize", (t) => ec(ze(), t, un)), this.boundingBoxes = Y(e, "boundingBox", (t) => t === void 0 ? [] : Xe(t, G5));
    } catch (t) {
      throw new Error(`Failed to parse BrainMaps volume geometry: ${t.message}`);
    }
  }
};
function H5(i) {
  return me(i), {
    name: Y(i, "name", Ae),
    type: Y(i, "type", Ae)
  };
}
function q5(i) {
  try {
    return me(i), Y(i, "meshes", (e) => e === void 0 ? [] : Xe(e, H5));
  } catch (e) {
    throw new Error(`Failed to parse BrainMaps meshes specification: ${e.message}`);
  }
}
var j5 = "([0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)";
var pm = "([0-9]+)";
var cR = new RegExp(`^(.*)_${pm}x${pm}x${pm}_lod([0-9]+)_${j5}$`);
function J5(i, e) {
  const t = new he(), n = i.scales[0], r = new Ye();
  for (const a of e) {
    if (a.type !== "TRIANGLES") continue;
    const l = a.name.match(cR);
    if (l === null) continue;
    const d = l[1];
    let u = t.get(d);
    u === void 0 && (u = { key: d, chunkShape: ze(), lods: [] }, t.set(d, u));
    const h = parseInt(l[5]);
    if (u.lods[h] !== void 0) {
      r.add(d);
      continue;
    }
    const g = wt(parseInt(l[2], 10), parseInt(l[3], 10), parseInt(l[4], 10)), v = new Uint32Array(3);
    for (let y = 0; y < 3; ++y)
      v[y] = Math.ceil(n.upperVoxelBound[y] / g[y]);
    u.lods[h] = {
      info: a,
      scale: parseFloat(l[6]),
      // Temporarily use the relativeBlockShape field to store the absolute shape in voxels.
      relativeBlockShape: g,
      gridShape: v
    };
  }
  const s = [];
  e: for (const a of t.values()) {
    if (r.has(a.key)) continue e;
    const l = a.lods[0];
    if (l === void 0) continue e;
    const d = l.relativeBlockShape;
    xT(a.chunkShape, d, n.voxelSize);
    for (let u = 1; u < a.lods.length; ++u) {
      const h = a.lods[u];
      if (h === void 0) continue e;
      const g = h.relativeBlockShape;
      for (let v = 0; v < 3; ++v) {
        const y = g[v], C = d[v];
        if (y < C || y % C !== 0) continue e;
        g[v] = y / C;
      }
    }
    d.fill(1), s.push(a);
  }
  return s;
}
function K5(i, e) {
  const t = J5(i, e), n = [], r = (a) => {
    n.some((l) => l.name === a.name) || n.push(a);
  }, s = new Ye();
  for (const a of t) {
    r({ multi: a, single: void 0, name: a.key, partOfMultiscale: false });
    for (const l of a.lods)
      s.add(l.info);
  }
  for (const a of e)
    r({
      single: a,
      multi: void 0,
      name: a.name,
      partOfMultiscale: s.has(a)
    });
  return n;
}
var Y5 = class {
  constructor(e) {
    try {
      me(e);
      let t = this.scales = Y(e, "geometry", (a) => Xe(a, (l) => new W5(l)));
      if (t.length === 0)
        throw new Error("Expected at least one scale.");
      let n = t[0], r = this.numChannels = n.numChannels, s = this.dataType = n.dataType;
      for (let a = 1, l = t.length; a < l; ++a) {
        let d = t[a];
        if (d.dataType !== s)
          throw new Error(`Scale ${a} has data type ${j[d.dataType]} but scale 0 has data type ${j[s]}.`);
        if (d.numChannels !== r)
          throw new Error(`Scale ${a} has ${d.numChannels} channel(s) but scale 0 has ${r} channels.`);
      }
      this.box = {
        lowerBounds: new Float64Array(3),
        upperBounds: new Float64Array(n.upperVoxelBound)
      };
    } catch (t) {
      throw new Error(`Failed to parse BrainMaps multiscale volume specification: ${t.message}`);
    }
  }
  getModelSpace(e = false) {
    const t = this.scales[0], n = ["x", "y", "z"], r = ["m", "m", "m"], s = _e(t.voxelSize, (l) => l / 1e9), a = _e(t.upperVoxelBound);
    return e && (n.push("c^"), r.push(""), s.push(1), a.push(this.numChannels)), yt({
      names: n,
      units: r,
      scales: Float64Array.from(s),
      boundingBoxes: [fa({
        lowerBounds: new Float64Array(n.length),
        upperBounds: Float64Array.from(a)
      })]
    });
  }
};
var X5 = class extends Ps {
  constructor(e, t, n, r, s, a, l) {
    super(e), this.instance = t, this.credentialsProvider = n, this.volumeId = r, this.changeSpec = s, this.multiscaleVolumeInfo = a, this.encoding = l.encoding, this.jpegQuality = l.jpegQuality, this.chunkLayoutPreference = l.chunkLayoutPreference;
    let d = Pn.IMAGE;
    this.dataType === j.UINT64 && (d = Pn.SEGMENTATION), this.volumeType = d;
  }
  get scales() {
    return this.multiscaleVolumeInfo.scales;
  }
  get dataType() {
    return this.multiscaleVolumeInfo.dataType;
  }
  get rank() {
    return this.multiscaleVolumeInfo.numChannels !== 1 ? 4 : 3;
  }
  getSources(e) {
    let t = Lr.RAW;
    (this.dataType === j.UINT64 || this.dataType === j.UINT32) && this.volumeType === Pn.SEGMENTATION && this.encoding !== Lr.RAW ? t = Lr.COMPRESSED_SEGMENTATION : this.volumeType === Pn.IMAGE && this.dataType === j.UINT8 && this.multiscaleVolumeInfo.numChannels === 1 && this.encoding !== Lr.RAW && e.discreteValues !== true && (t = Lr.JPEG);
    const n = t === Lr.JPEG ? this.jpegQuality : void 0, r = this.scales[0], s = r.upperVoxelBound, a = ze(), l = this.rank;
    return yc(this.scales.map((d, u) => {
      Cm(a, d.voxelSize, r.voxelSize);
      let h = d.upperVoxelBound, g, v = d.numChannels;
      const y = new Float32Array((l + 1) ** 2);
      y[(l + 1) * l + l] = 1;
      const C = new Float32Array(l);
      v !== 1 && (h = Float32Array.of(...h, v), g = Uint32Array.of(1, 1, 1, v), y[(l + 1) * 3 + 3] = 1, C[3] = v);
      for (let w = 0; w < 3; ++w)
        y[(l + 1) * w + w] = a[w], C[w] = s[w] / a[w];
      return Wc({
        rank: l,
        minBlockSize: g,
        chunkToMultiscaleTransform: y,
        dataType: d.dataType,
        upperVoxelBound: h,
        volumeType: this.volumeType,
        volumeSourceOptions: e,
        chunkLayoutPreference: this.chunkLayoutPreference,
        maxCompressedSegmentationBlockSize: wt(64, 64, 64)
      }).map((w) => ({
        chunkSource: this.chunkManager.getChunkSource(B5, {
          credentialsProvider: this.credentialsProvider,
          spec: w,
          parameters: {
            volumeId: this.volumeId,
            changeSpec: this.changeSpec,
            scaleIndex: u,
            encoding: t,
            jpegQuality: n,
            instance: this.instance
          }
        }),
        chunkToMultiscaleTransform: y,
        upperClipBound: C
      }));
    }));
  }
};
function Z5(i) {
  const e = nt(), t = i.scales[0].voxelSize;
  for (let n = 0; n < 3; ++n)
    e[5 * n] = 1 / t[n];
  return e;
}
function Q5(i) {
  const e = i.match(/^([^:?\/]+:[^:?\/]+:[^:?\/]+)(?::([^:?\/]+))?(?:\/([^?]+))?(?:\?(.*))?$/);
  if (e === null)
    throw new Error(`Invalid Brain Maps volume key: ${oe(i)}.`);
  let t;
  e[2] !== void 0 && (t = { changeStackId: e[2] });
  const n = Fo(e[4] || "");
  return { volumeId: e[1], changeSpec: t, meshName: e[3], parameters: n };
}
function ej(i) {
  try {
    return me(i), {
      id: Y(i, "id", Ae),
      label: Y(i, "label", Ae),
      description: Y(i, "description", Ci)
    };
  } catch (e) {
    throw new Error(`Failed to parse project: ${e.message}`);
  }
}
function tj(i) {
  try {
    return me(i), Y(i, "project", (e) => e === void 0 ? [] : Xe(e, ej));
  } catch (e) {
    throw new Error(`Error parsing project list: ${e.message}`);
  }
}
function Ok(i, e) {
  try {
    return me(i), Y(i, e, (t) => t === void 0 ? [] : Xe(t, Ae));
  } catch (t) {
    throw new Error(`Error parsing dataset list: ${t.message}`);
  }
}
function nj(i) {
  return Y(i, "changeStackId", (e) => e === void 0 ? void 0 : Xe(e, Ae));
}
var ij = Jt(Kt()(Fi), oR);
var rj = class extends ij {
  constructor(e, t) {
    super(e, H({ rank: 3, relationships: ["segments"], properties: [] }, t)), this.credentialsProvider = this.registerDisposer(t.credentialsProvider.addRef());
  }
  hasNonSerializedProperties() {
    return true;
  }
  getSources() {
    const e = this.parameters.upperVoxelBound, t = Dc({
      rank: 3,
      chunkDataSize: e,
      upperVoxelBound: e
    }), n = nt();
    return [[{
      chunkSource: this.chunkManager.getChunkSource($5, {
        parent: this,
        spec: H({ limit: 0, chunkToMultiscaleTransform: n }, t),
        parameters: this.parameters,
        credentialsProvider: this.credentialsProvider
      }),
      chunkToMultiscaleTransform: n
    }]];
  }
};
var sj = [{
  key: { value: "encoding", description: "Volume chunk data encoding" },
  values: [{ value: "raw", description: "" }, { value: "jpeg", description: "" }, { value: "compressed_segmentation", description: "" }]
}, {
  key: { value: "chunkLayout", description: "Volume chunk layout preference" },
  values: [{ value: "isotropic", description: "" }, { value: "flat", description: "" }]
}, {
  key: { value: "jpegQuality", description: "JPEG quality (1 to 100)" },
  values: []
}];
var dR = class extends pa {
  constructor(e, t) {
    super(), this.instance = e, this.credentialsProvider = t;
  }
  get description() {
    return this.instance.description;
  }
  getMultiscaleInfo(e, t) {
    return e.memoize.getUncounted({
      type: "brainmaps:getMultiscaleInfo",
      volumeId: t,
      instance: this.instance,
      credentialsProvider: En(this.credentialsProvider)
    }, () => Za(this.instance, this.credentialsProvider, {
      method: "GET",
      path: `/v1beta2/volumes/${t}`,
      responseType: "json"
    }).then((n) => new Y5(n)));
  }
  getMeshesInfo(e, t) {
    return e.memoize.getUncounted({
      type: "brainmaps:getMeshesInfo",
      volumeId: t,
      instance: this.instance,
      credentialsProvider: En(this.credentialsProvider)
    }, () => Za(this.instance, this.credentialsProvider, {
      method: "GET",
      path: `/v1beta2/objects/${t}/meshes`,
      responseType: "json"
    }).then((n) => q5(n)));
  }
  get(e) {
    var t = Q5(e.providerUrl);
    const n = t.volumeId, r = t.changeSpec, s = t.meshName, a = t.parameters;
    me(a);
    const l = xe(a, "encoding", (g) => Rn(g, Lr)), d = xe(a, "jpegQuality", (g) => {
      const v = gn(g);
      if (v < 1 || v > 100) throw new Error(`Expected integer in range [1, 100], but received: ${g}`);
      return v;
    }, 70), u = xe(a, "chunkLayout", (g) => Rn(g, oo)), h = { encoding: l, chunkLayoutPreference: u, jpegQuality: d };
    return e.chunkManager.memoize.getUncounted({ type: "brainmaps:get", instance: this.instance, volumeId: n, changeSpec: r, brainmapsOptions: h }, async () => {
      var g = await Ft.all([this.getMultiscaleInfo(e.chunkManager, n), this.getMeshesInfo(e.chunkManager, n)]), v = de(g, 2);
      const y = v[0], C = v[1], w = new X5(e.chunkManager, this.instance, this.credentialsProvider, n, r, y, h), b = {
        modelTransform: ei(y.getModelSpace(y.numChannels !== 1)),
        subsources: [{
          id: s === void 0 ? "default" : "volume",
          subsource: { volume: w },
          default: s === void 0
        }]
      }, E = Ec(y.box);
      y.scales[0].boundingBoxes.forEach((P, L) => {
        E.add({
          type: Fe.AXIS_ALIGNED_BOUNDING_BOX,
          description: P.metadata,
          pointA: P.corner,
          pointB: wT(ze(), P.corner, P.size),
          id: `boundingBox${L}`,
          properties: []
        });
      }), b.subsources.push({
        id: "bounds",
        subsource: { staticAnnotations: E },
        default: true
      });
      const I = K5(y, C), R = (P, L) => {
        let A;
        const M = P.single;
        if (M !== void 0)
          M.type === "TRIANGLES" ? A = e.chunkManager.getChunkSource(U5, {
            credentialsProvider: this.credentialsProvider,
            parameters: {
              instance: this.instance,
              volumeId: n,
              meshName: M.name,
              changeSpec: r
            }
          }) : A = e.chunkManager.getChunkSource(z5, {
            credentialsProvider: this.credentialsProvider,
            parameters: {
              instance: this.instance,
              volumeId: n,
              meshName: P.name,
              changeSpec: r
            }
          });
        else {
          const O = P.multi;
          A = e.chunkManager.getChunkSource(F5, {
            credentialsProvider: this.credentialsProvider,
            format: {
              fragmentRelativeVertices: false,
              vertexPositionFormat: Nr.float32
            },
            parameters: {
              instance: this.instance,
              volumeId: n,
              info: O,
              changeSpec: r
            }
          });
        }
        b.subsources.push({
          id: s === void 0 ? `/${P.name}` : "default",
          subsource: { mesh: A },
          subsourceToModelSubspaceTransform: Z5(y),
          modelSubspaceDimensionIndices: [0, 1, 2],
          default: L
        });
      };
      if (s !== void 0) {
        const P = I.find((L) => L.name === s);
        if (P === void 0)
          throw new Error(`Mesh/skeleton source not found: ${oe(P)}`);
        R(P, true);
      } else {
        let P = true;
        for (const L of I)
          L.partOfMultiscale || (R(L, P), P = false);
      }
      return r !== void 0 && b.subsources.push({
        id: "spatials",
        default: true,
        modelSubspaceDimensionIndices: [0, 1, 2],
        subsource: {
          annotation: e.chunkManager.getChunkSource(rj, {
            parameters: {
              volumeId: n,
              changestack: r.changeStackId,
              instance: this.instance,
              upperVoxelBound: y.scales[0].upperVoxelBound
            },
            credentialsProvider: this.credentialsProvider
          })
        }
      }), b;
    });
  }
  getProjectList(e) {
    return e.memoize.getUncounted({ instance: this.instance, type: "brainmaps:getProjectList" }, () => {
      let t = Za(this.instance, this.credentialsProvider, {
        method: "GET",
        path: "/v1beta2/projects",
        responseType: "json"
      }).then((r) => tj(r));
      const n = `${this.instance.description} project list`;
      return rt.forPromise(t, {
        delay: true,
        initialMessage: `Retrieving ${n}.`,
        errorPrefix: `Error retrieving ${n}: `
      }), t;
    });
  }
  getDatasetList(e, t) {
    return e.memoize.getUncounted({ instance: this.instance, type: `brainmaps:${t}:getDatasetList` }, () => {
      let n = Za(this.instance, this.credentialsProvider, {
        method: "GET",
        path: `/v1beta2/datasets?project_id=${t}`,
        responseType: "json"
      }).then((s) => Ok(s, "datasetIds"));
      const r = `${this.instance.description} dataset list`;
      return rt.forPromise(n, {
        delay: true,
        initialMessage: `Retrieving ${r}`,
        errorPrefix: `Error retrieving ${r}`
      }), n;
    });
  }
  getVolumeList(e, t, n) {
    return e.memoize.getUncounted({ instance: this.instance, type: `brainmaps:${t}:${n}:getVolumeList` }, () => {
      let r = Za(this.instance, this.credentialsProvider, {
        method: "GET",
        path: `/v1beta2/volumes?project_id=${t}&dataset_id=${n}`,
        responseType: "json"
      }).then((a) => {
        const l = Ok(a, "volumeId"), d = t.length + n.length + 2, u = [];
        for (const h of l)
          u.push(h.substring(d));
        return u;
      });
      const s = `${this.instance.description} volume list`;
      return rt.forPromise(r, {
        delay: true,
        initialMessage: `Retrieving ${s}`,
        errorPrefix: `Error retrieving ${s}`
      }), r;
    });
  }
  getChangeStackList(e, t) {
    return e.memoize.getUncounted({ instance: this.instance, type: "brainmaps:getChangeStackList", volumeId: t }, () => {
      let n = Za(this.instance, this.credentialsProvider, {
        method: "GET",
        path: `/v1beta2/changes/${t}/change_stacks`,
        responseType: "json"
      }).then((s) => nj(s));
      const r = `change stacks for ${t}`;
      return rt.forPromise(n, {
        delay: true,
        initialMessage: `Retrieving ${r}.`,
        errorPrefix: `Error retrieving ${r}: `
      }), n;
    });
  }
  async completeUrl(e) {
    const t = e.providerUrl, n = t.match(/^([^:\/?]*)(?::([^:\/?]*)(?::([^:\/?]*)(?::([^:\/?]*))?(?:\/([^?]*))?(?:\?(.*))?)?)?$/);
    if (n === null) throw null;
    var r = de(n, 7);
    const s = r[1], a = r[2], l = r[3], d = r[4], u = r[5], h = r[6];
    if (h !== void 0)
      return Go(t.length - h.length, await PD(h, sj));
    if (u !== void 0) {
      const v = `${s}:${a}:${l}`, y = await this.getMeshesInfo(e.chunkManager, v), C = [], w = new Ye();
      for (const b of y)
        if (b.name.startsWith(u))
          switch (b.type) {
            case "LINE_SEGMENTS":
              C.push({ value: b.name, description: "Skeletons" });
              break;
            case "TRIANGLES": {
              C.push({ value: b.name, description: "Mesh (single-resolution)" });
              const E = b.name.match(cR);
              if (E !== null) {
                const T = E[1];
                if (w.has(T)) break;
                w.add(T), C.push({ value: T, description: "Mesh (multi-resolution)" });
              }
              break;
            }
          }
      return C.sort((b, E) => Ac(b.value, E.value)), { offset: t.length - u.length, completions: C };
    }
    if (d !== void 0) {
      const v = `${s}:${a}:${l}`, y = await this.getChangeStackList(e.chunkManager, v);
      if (y === void 0)
        throw null;
      return {
        offset: t.length - d.length,
        completions: Sg(d, y)
      };
    }
    if (l !== void 0)
      return {
        offset: t.length - l.length,
        completions: Sg(l, await this.getVolumeList(e.chunkManager, s, a))
      };
    if (a !== void 0) {
      const v = await this.getDatasetList(e.chunkManager, s);
      return {
        offset: t.length - a.length,
        completions: Sg(a, v.map((y) => `${y}:`))
      };
    }
    const g = await this.getProjectList(e.chunkManager);
    return {
      offset: 0,
      completions: Wo(s, g, (v) => `${v.id}:`, (v) => v.label)
    };
  }
};
var aj = {
  description: "Google Brain Maps",
  serverUrl: "https://brainmaps.googleapis.com"
};
va("brainmaps", (i) => new dR(aj, i.credentialsManager.getCredentialsProvider(qh)));
if (typeof NEUROGLANCER_BRAINMAPS_SERVERS < "u")
  for (const i of _c(NEUROGLANCER_BRAINMAPS_SERVERS)) {
    Vk = de(i, 2);
    const e = Vk[0], t = Vk[1];
    va(`brainmaps-${e}`, (n) => new dR(t, n.credentialsManager.getCredentialsProvider(qh)));
  }
var Vk;
var oj = "https://accounts.google.com/o/oauth2/auth";
var Bk = "https://accounts.google.com";
function lj(i, e) {
  let t = document.createElement("iframe");
  t.style.display = "none", t.id = i, t.name = i;
  const n = location.origin;
  t.src = `https://accounts.google.com/o/oauth2/postmessageRelay?parent=${encodeURIComponent(n)}#rpctoken=${e}`, document.body.appendChild(t);
}
var cj = class {
  constructor() {
    this.finished = new ct();
  }
};
var dj = class {
  constructor() {
    this.proxyName = `postmessageRelay${pu()}`, this.rpcToken = `${pu()}`, this.relayReadyService = `oauth2relayReady:${this.rpcToken}`, this.oauth2CallbackService = `oauth2callback:${this.rpcToken}`, this.pendingRequests = new he(), lj(this.proxyName, this.rpcToken), this.relayReadyPromise = new Ft((e) => {
      addEventListener("message", (t) => {
        if (t.origin === Bk)
          try {
            let n = me(JSON.parse(t.data)), r = Ae(n.s);
            if (r === this.relayReadyService && e(), r === this.oauth2CallbackService) {
              let s = Xe(n.a, (T) => T), a = Ae(s[0]), l = location.origin;
              if (!a.startsWith(l + "#") && !a.startsWith(l + "?"))
                throw new Error(`oauth2callback: URL ${oe(a)} does not match current origin ${l}.`);
              let u = a.substring(l.length + 1).split("&"), h = new he();
              for (let T of u) {
                let I = T.match("^([a-z_]+)=(.*)$");
                if (I === null)
                  throw new Error(`oauth2callback: URL part ${oe(I)} does not match expected pattern.`);
                h.set(I[1], I[2]);
              }
              let g = h.get("state");
              if (g === void 0)
                throw new Error("oauth2callback: State argument is missing.");
              let v = this.pendingRequests.get(g);
              if (v === void 0)
                return;
              let y = h.get("error");
              if (y !== void 0) {
                let T = h.get("error_subtype"), I = y;
                T !== void 0 && (I += ": " + T), v.finished.dispatch(void 0, new Error(`Error obtaining Google OAuth2 token: ${I}`));
                return;
              }
              let C = h.get("access_token"), w = h.get("token_type"), b = h.get("expires_in"), E = h.get("scope");
              if (C === void 0 || w === void 0 || b === void 0 || E === void 0)
                throw new Error("oauth2callback: URL lacks expected parameters.");
              v.finished.dispatch({
                accessToken: C,
                tokenType: w,
                expiresIn: b,
                scope: E
              });
              return;
            }
          } catch (n) {
            throw new Error(`Invalid message received from ${Bk}: ${oe(t.data)}: ${n.message}.`);
          }
      });
    });
  }
  addPendingRequest(e) {
    let t = new cj();
    return this.pendingRequests.set(e, t), t.finished.add(() => {
      this.pendingRequests.delete(e);
    }), t;
  }
  makeAuthRequestUrl(e) {
    let t = `${oj}?client_id=${encodeURIComponent(e.clientId)}`;
    t += "&redirect_uri=postmessage", t += "&response_type=token";
    var n = e.origin;
    let r = n === void 0 ? location.origin : n;
    return t += `&origin=${encodeURIComponent(r)}`, t += `&proxy=${this.proxyName}`, t += "&include_granted_scopes=true", t += `&scope=${encodeURIComponent(e.scopes.join(" "))}`, e.state && (t += `&state=${e.state}`), e.approvalPrompt && (t += `&approval_prompt=${encodeURIComponent(e.approvalPrompt)}`), e.loginHint && (t += `&login_hint=${encodeURIComponent(e.loginHint)}`), e.immediate && (t += "&immediate=true"), e.authUser !== void 0 && (t += `&authuser=${e.authUser}`), t;
  }
};
var gm;
function uj() {
  return gm === void 0 && (gm = new dj()), gm;
}
function hj(i, e = Qt) {
  const t = pu(), n = uj(), r = n.makeAuthRequestUrl({
    state: t,
    clientId: i.clientId,
    scopes: i.scopes,
    approvalPrompt: i.approvalPrompt,
    loginHint: i.loginHint,
    immediate: i.immediate,
    authUser: i.authUser
  }), s = n.addPendingRequest(t), a = new Ft((l, d) => {
    s.finished.add((u, h) => {
      u !== void 0 ? l(u) : d(h);
    });
  });
  if (s.finished.add(e.add(() => {
    s.finished.dispatch(void 0, bs);
  })), i.immediate)
    n.relayReadyPromise.then(() => {
      if (e.isCanceled)
        return;
      const l = document.createElement("iframe");
      l.src = r, l.style.display = "none", document.body.appendChild(l), s.finished.add(() => {
        Ut(l);
      });
    });
  else if (!e.isCanceled) {
    const l = open(r);
    l !== null && s.finished.add(() => {
      l.close();
    });
  }
  return a;
}
var fj = class extends Gc {
  constructor(e) {
    super(), this.options = e, this.get = Nh((t) => {
      const n = this.options, r = new rt(
        /*delay=*/
        true
      );
      let s;
      return new Ft((a, l) => {
        const d = () => {
          s = void 0, r.dispose();
        };
        t.add(() => {
          s !== void 0 && (s.cancel(), s = void 0, r.dispose(), l(bs));
        });
        function u(g = `${n.description} authorization required.`, v = "Request authorization.") {
          r.setText(g + "  ");
          let y = document.createElement("button");
          y.textContent = v, r.element.appendChild(y), y.addEventListener("click", () => {
            h(
              /*immediate=*/
              false
            );
          }), r.setVisible(true);
        }
        function h(g) {
          s !== void 0 && s.cancel(), s = new Ts(), u(`Waiting for ${n.description} authorization...`, "Retry"), hj({
            clientId: n.clientId,
            scopes: n.scopes,
            immediate: g,
            authUser: 0
          }, s).then((v) => {
            s !== void 0 && (d(), a(v));
          }, (v) => {
            s !== void 0 && (s = void 0, g ? u() : u(`${n.description} authorization failed: ${v}.`, "Retry"));
          });
        }
        h(
          /*immediate=*/
          true
        );
      });
    });
  }
};
var pj = "https://www.googleapis.com/auth/brainmaps";
var uR = class extends fj {
  constructor(e) {
    super({ clientId: e, scopes: [pj], description: "Brain Maps" });
  }
};
Jo.register(qh, () => new uR(BRAINMAPS_CLIENT_ID));
var ju;
(function(i) {
  i[i.RAW = 0] = "RAW", i[i.JPEG = 1] = "JPEG", i[i.COMPRESSED_SEGMENTATION = 2] = "COMPRESSED_SEGMENTATION", i[i.COMPRESSO = 3] = "COMPRESSO", i[i.PNG = 4] = "PNG";
})(ju || (ju = {}));
var hR = class {
};
hR.RPC_ID = "precomputed/VolumeChunkSource";
var fR = class {
};
fR.RPC_ID = "precomputed/MeshSource";
var Ju;
(function(i) {
  i[i.RAW = 0] = "RAW", i[i.GZIP = 1] = "GZIP";
})(Ju || (Ju = {}));
var jv;
(function(i) {
  i[i.IDENTITY = 0] = "IDENTITY", i[i.MURMURHASH3_X86_128 = 1] = "MURMURHASH3_X86_128";
})(jv || (jv = {}));
var pR2 = class {
};
pR2.RPC_ID = "precomputed/MultiscaleMeshSource";
var gR = class {
};
gR.RPC_ID = "precomputed/SkeletonSource";
var mR2 = class {
};
mR2.RPC_ID = "precomputed/AnnotationSpatialIndexSource";
var vR = class {
};
vR.RPC_ID = "precomputed/AnnotationSource";
var yR = class {
};
yR.RPC_ID = "precomputed/IndexedSegmentPropertySource";
async function gj(i, e, t, n, r) {
  const s = await Ys(i, `https://www.googleapis.com/storage/v1/b/${e}/o?delimiter=${encodeURIComponent(n)}&prefix=${encodeURIComponent(t)}&neuroglancerOrigin=${encodeURIComponent(location.origin)}`, {}, Wi, r);
  me(s);
  const a = xe(s, "prefixes", bi, []), l = xe(s, "items", (d) => Xe(d, (u) => (me(u), Y(u, "name", Ae))), []).filter((d) => !d.endsWith("_$folder$"));
  return [...a, ...l];
}
async function mj(i, e, t, n, r) {
  if (!n.startsWith("/")) throw null;
  const a = await gj(i, t, n.substring(1), "/", r);
  let l = n.lastIndexOf("/");
  return {
    offset: l + e.length + 1,
    completions: a.map((d) => ({ value: d.substring(l) }))
  };
}
async function vj(i, e, t) {
  var n = await ya(
    t,
    i,
    /*init=*/
    { headers: { accept: "text/html" } },
    async (u) => ({ text: await u.text(), contentType: u.headers.get("content-type") }),
    e
  );
  const r = n.text, s = n.contentType;
  if (s === null || /\btext\/html\b/i.exec(s) === null)
    return [];
  const a = new DOMParser().parseFromString(r, "text/html"), l = a.evaluate("//a/@href", a, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null), d = [];
  for (let u = 0, h = l.snapshotLength; u < h; ++u) {
    const v = l.snapshotItem(u).textContent;
    v && d.push(new URL(v, i).toString());
  }
  return d;
}
async function yj(i, e, t) {
  console.log("getHtmlPathCompletions");
  const n = i.match(/^([a-z]+:\/\/.*\/)([^\/?#]*)$/);
  if (n === null) throw null;
  const r = await vj(n[1], e, t), s = n[1].length, a = [];
  for (const l of r)
    l.startsWith(i) && a.push({ value: l.substring(s) });
  return {
    offset: s,
    completions: a
  };
}
var Sj = [{ value: "gs://", description: "Google Cloud Storage (JSON API)" }, { value: "gs+xml://", description: "Google Cloud Storage (XML API)" }, {
  value: "gs+json://",
  description: "Google Cloud Storage (storage JSON API)"
}, {
  value: "gs+ngauth+http://",
  description: "Google Cloud Storage (JSON API) authenticated via ngauth"
}, {
  value: "gs+ngauth+https://",
  description: "Google Cloud Storage (JSON API) authenticated via ngauth"
}, {
  value: "gs+xml+ngauth+http://",
  description: "Google Cloud Storage (XML API) authenticated via ngauth"
}, {
  value: "gs+xml+ngauth+https://",
  description: "Google Cloud Storage (XML API) authenticated via ngauth"
}, { value: "s3://", description: "Amazon Simple Storage Service (S3)" }, { value: "https://" }, { value: "http://" }];
async function t0(i, e, t) {
  if (!e.includes("://"))
    return {
      offset: 0,
      completions: Wo(e, Sj, (y) => y.value, (y) => y.description)
    };
  var n = Ko(e, i);
  const r = n.url, s = n.credentialsProvider, a = e.length - r.length;
  let l;
  try {
    l = _o(r);
  } catch {
    throw null;
  }
  var d = l;
  const u = d.protocol, h = d.host, g = d.path, v = await (async () => {
    if (u === "gs+xml" && g.length > 0)
      return await lv(s, `${u}://${h}`, `https://storage.googleapis.com/${h}`, g, t);
    if ((u === "gs" || u === "gs+json") && g.length > 0)
      return await mj(s, `${u}://${h}`, h, g, t);
    if (u === "s3" && g.length > 0)
      return await SG(h, g, t);
    const y = r.match(/^((?:http|https):\/\/(?:storage\.googleapis\.com\/[^\/]+|[^\/]+\.storage\.googleapis\.com|[^\/]+\.s3(?:[^./]+)?\.amazonaws.com))(\/.*)$/);
    if (y !== null)
      return await lv(s, y[1], y[1], y[2], t);
    if ((u === "http" || u === "https") && g.length > 0)
      return await yj(r, t, s);
    throw null;
  })();
  return { offset: a + v.offset, completions: v.completions };
}
var bj = class extends Jt(Kt()(zc), hR) {
};
var wj = class extends Jt(Kt()(Vc), fR) {
};
var Cj = class extends Jt(Kt()(Ah), pR2) {
};
var xj = class extends Jt(Kt()(_h), gR) {
  get skeletonVertexCoordinatesInVoxels() {
    return false;
  }
  get vertexAttributes() {
    return this.parameters.metadata.vertexAttributes;
  }
};
function Qs(i, e) {
  const t = i.split("/");
  for (const n of e.split("/")) {
    if (n === ".." && t.length !== 0) {
      t.length = t.length - 1;
      continue;
    }
    t.push(n);
  }
  return t.join("/");
}
var Ej = class {
  constructor(e, t) {
    me(e);
    const n = t === 1 ? 3 : 4, r = this.resolution = new Float64Array(n), s = this.voxelOffset = new Float32Array(n), a = this.size = new Float32Array(n);
    if (n === 4 && (r[3] = 1, a[3] = t), Y(e, "resolution", (d) => lt(r.subarray(0, 3), d, yn)), xe(e, "voxel_offset", (d) => lt(s.subarray(0, 3), d, gn)), Y(e, "size", (d) => lt(a.subarray(0, 3), d, un)), this.chunkSizes = Y(e, "chunk_sizes", (d) => Xe(d, (u) => {
      const h = new Uint32Array(n);
      return n === 4 && (h[3] = t), lt(h.subarray(0, 3), u, un), h;
    })), this.chunkSizes.length === 0)
      throw new Error("No chunk sizes specified.");
    if (this.sharding = Y(e, "sharding", jh), this.sharding !== void 0 && this.chunkSizes.length !== 1)
      throw new Error("Sharding requires a single chunk size per scale");
    (this.encoding = Y(e, "encoding", (d) => Rn(d, ju))) === ju.COMPRESSED_SEGMENTATION && (this.compressedSegmentationBlockSize = Y(e, "compressed_segmentation_block_size", (d) => lt(ze(), d, un))), this.key = Y(e, "key", Ae);
  }
};
function kj(i) {
  me(i);
  const e = Y(i, "data_type", (E) => Rn(E, j)), t = Y(i, "num_channels", un), n = Y(i, "type", (E) => Rn(E, Pn)), r = Y(i, "mesh", Ci), s = Y(i, "skeletons", Ci), a = Y(i, "segment_properties", Ci), l = Y(i, "scales", (E) => Xe(E, (T) => new Ej(T, t)));
  if (l.length === 0) throw new Error("Expected at least one scale");
  const d = l[0], u = t === 1 ? 3 : 4, h = new Float64Array(u), g = new Float64Array(u), v = new Float64Array(u), y = ["x", "y", "z"], C = ["m", "m", "m"];
  for (let E = 0; E < 3; ++E)
    h[E] = d.resolution[E] / 1e9, g[E] = d.voxelOffset[E], v[E] = g[E] + d.size[E];
  u === 4 && (h[3] = 1, v[3] = t, y[3] = "c^", C[3] = "");
  const b = yt({
    rank: u,
    names: y,
    units: C,
    scales: h,
    boundingBoxes: [fa({ lowerBounds: g, upperBounds: v })]
  });
  return {
    dataType: e,
    volumeType: n,
    mesh: r,
    skeletons: s,
    segmentPropertyMap: a,
    scales: l,
    modelSpace: b
  };
}
var Tj = class extends Ps {
  constructor(e, t, n, r) {
    super(e), this.credentialsProvider = t, this.url = n, this.info = r;
  }
  get dataType() {
    return this.info.dataType;
  }
  get volumeType() {
    return this.info.volumeType;
  }
  get rank() {
    return this.info.modelSpace.rank;
  }
  getSources(e) {
    const t = this.info.scales[0].resolution, n = this.rank;
    return yc(this.info.scales.map((r) => {
      const s = r.resolution, a = n + 1, l = new Float32Array(a * a);
      l[l.length - 1] = 1;
      var d = this.info.modelSpace.boundingBoxes[0].box;
      const u = d.lowerBounds, h = d.upperBounds, g = new Float32Array(n), v = new Float32Array(n);
      for (let y = 0; y < 3; ++y) {
        const C = s[y] / t[y];
        l[a * y + y] = C;
        const w = r.voxelOffset[y];
        l[a * n + y] = w * C, g[y] = u[y] / C - w, v[y] = h[y] / C - w;
      }
      return n === 4 && (l[a * 3 + 3] = 1, g[3] = u[3], v[3] = h[3]), Wc({
        rank: n,
        dataType: this.dataType,
        chunkToMultiscaleTransform: l,
        upperVoxelBound: r.size,
        volumeType: this.volumeType,
        chunkDataSizes: r.chunkSizes,
        baseVoxelOffset: r.voxelOffset,
        compressedSegmentationBlockSize: r.compressedSegmentationBlockSize,
        volumeSourceOptions: e
      }).map((y) => ({
        chunkSource: this.chunkManager.getChunkSource(bj, {
          credentialsProvider: this.credentialsProvider,
          spec: y,
          parameters: {
            url: Qs(this.url, r.key),
            encoding: r.encoding,
            sharding: r.sharding
          }
        }),
        chunkToMultiscaleTransform: l,
        lowerClipBound: g,
        upperClipBound: v
      }));
    }));
  }
};
var Lj = Jt(Kt()(Fi), vR);
var Dj = class extends Jt(Kt()(Eo), mR2) {
};
var Ij = class extends Lj {
  constructor(e, t) {
    const n = t.parameters;
    super(e, {
      rank: n.rank,
      relationships: n.relationships.map((r) => r.name),
      properties: n.properties,
      parameters: n
    }), this.readonly = true, this.metadata = t.metadata, this.credentialsProvider = t.credentialsProvider;
  }
  getSources() {
    return [this.metadata.spatialIndices.map((e) => {
      const t = e.spec;
      return {
        chunkSource: this.chunkManager.getChunkSource(Dj, {
          credentialsProvider: this.credentialsProvider,
          parent: this,
          spec: t,
          parameters: e.parameters
        }),
        chunkToMultiscaleTransform: t.chunkToMultiscaleTransform
      };
    })];
  }
};
function Pj(i, e, t) {
  return i.getChunkSource(wj, { parameters: t, credentialsProvider: e });
}
function SR(i) {
  return Y(i, "transform", (e) => {
    const t = nt();
    return e !== void 0 && lt(t.subarray(0, 12), e, Dt), cy(t, t), t;
  });
}
function Rj(i) {
  me(i);
  const e = Y(i, "@type", Ae);
  let t;
  if (e === "neuroglancer_legacy_mesh")
    t = void 0;
  else {
    if (e !== "neuroglancer_multilod_draco")
      throw new Error(`Unsupported mesh type: ${oe(e)}`);
    {
      const r = Y(i, "lod_scale_multiplier", yn), s = Y(i, "vertex_quantization_bits", un), a = SR(i), l = Y(i, "sharding", jh);
      t = { lodScaleMultiplier: r, transform: a, sharding: l, vertexQuantizationBits: s };
    }
  }
  const n = Y(i, "segment_properties", Ci);
  return { metadata: t, segmentPropertyMap: n };
}
async function Aj(i, e, t) {
  let n;
  try {
    n = await el(i, e, t);
  } catch (r) {
    if (Fh(r))
      return { metadata: void 0 };
    throw r;
  }
  return Rj(n);
}
function Fk(i) {
  return i === void 0 ? Ju.RAW : Rn(i, Ju);
}
function jh(i) {
  if (i === void 0) return;
  me(i);
  const e = Y(i, "@type", Ae);
  if (e !== "neuroglancer_uint64_sharded_v1")
    throw new Error(`Unsupported sharding format: ${oe(e)}`);
  const t = Y(i, "hash", (d) => Rn(d, jv)), n = Y(i, "preshift_bits", gn), r = Y(i, "shard_bits", gn), s = Y(i, "minishard_bits", gn), a = Y(i, "minishard_index_encoding", Fk), l = Y(i, "data_encoding", Fk);
  return { hash: t, preshiftBits: n, shardBits: r, minishardBits: s, minishardIndexEncoding: a, dataEncoding: l };
}
function _j(i) {
  me(i);
  const e = Y(i, "@type", Ae);
  if (e !== "neuroglancer_skeletons")
    throw new Error(`Unsupported skeleton type: ${oe(e)}`);
  const t = SR(i), n = new he();
  Y(i, "vertex_attributes", (a) => {
    a !== void 0 && Xe(a, (l) => {
      me(l);
      const d = Y(l, "id", Ae);
      if (d === "") throw new Error("vertex attribute id must not be empty");
      if (n.has(d))
        throw new Error(`duplicate vertex attribute id ${oe(d)}`);
      const u = Y(l, "data_type", (g) => Rn(g, j)), h = Y(l, "num_components", un);
      n.set(d, { dataType: u, numComponents: h });
    });
  });
  const r = Y(i, "sharding", jh), s = Y(i, "segment_properties", Ci);
  return {
    metadata: { transform: t, vertexAttributes: n, sharding: r },
    segmentPropertyMap: s
  };
}
async function Mj(i, e, t) {
  const n = await el(i, e, t);
  return _j(n);
}
function bR() {
  return yt({ names: ["x", "y", "z"], units: ["m", "m", "m"], scales: Float64Array.of(1e-9, 1e-9, 1e-9) });
}
async function wR(i, e, t) {
  var n = await Aj(i, e, t);
  const r = n.metadata, s = n.segmentPropertyMap;
  if (r === void 0)
    return {
      source: Pj(i, e, { url: t, lod: 0 }),
      transform: nt(),
      segmentPropertyMap: s
    };
  let a;
  const l = r.vertexQuantizationBits;
  if (l === 10)
    a = Nr.uint10;
  else if (l === 16)
    a = Nr.uint16;
  else
    throw new Error(`Invalid vertex quantization bits: ${l}`);
  return {
    source: i.getChunkSource(Cj, {
      credentialsProvider: e,
      parameters: { url: t, metadata: r },
      format: {
        fragmentRelativeVertices: true,
        vertexPositionFormat: a
      }
    }),
    transform: r.transform,
    segmentPropertyMap: s
  };
}
async function CR(i, e, t) {
  var n = await Mj(i, e, t);
  const r = n.metadata, s = n.segmentPropertyMap;
  return {
    source: i.getChunkSource(xj, {
      credentialsProvider: e,
      parameters: {
        url: t,
        metadata: r
      }
    }),
    transform: r.transform,
    segmentPropertyMap: s
  };
}
function el(i, e, t) {
  return i.memoize.getUncounted({ type: "precomputed:metadata", url: t, credentialsProvider: En(e) }, async () => await ya(e, `${t}/info`, {}, Wi));
}
function Uk(i) {
  const e = nt(), t = i.scales[0].resolution;
  for (let n = 0; n < 3; ++n)
    e[5 * n] = 1 / t[n];
  return e;
}
async function Nj(i, e, t, n) {
  const r = kj(n), s = new Tj(i.chunkManager, e, t, r), a = r.modelSpace, l = [{
    id: "default",
    default: true,
    subsource: { volume: s }
  }, {
    id: "bounds",
    default: true,
    subsource: {
      staticAnnotations: Ec(a.bounds)
    }
  }];
  if (r.segmentPropertyMap !== void 0) {
    const h = Qs(t, r.segmentPropertyMap), g = await el(i.chunkManager, e, h), v = Jh(i.chunkManager, e, g);
    l.push({
      id: "properties",
      default: true,
      subsource: { segmentPropertyMap: v }
    });
  }
  if (r.mesh !== void 0) {
    const h = Qs(t, r.mesh);
    var d = await wR(i.chunkManager, e, h);
    const g = d.source, v = d.transform, y = Uk(r);
    vn(y, y, v), l.push({
      id: "mesh",
      default: true,
      subsource: { mesh: g },
      subsourceToModelSubspaceTransform: y
    });
  }
  if (r.skeletons !== void 0) {
    const h = Qs(t, r.skeletons);
    var u = await CR(i.chunkManager, e, h);
    const g = u.source, v = u.transform, y = Uk(r);
    vn(y, y, v), l.push({
      id: "skeletons",
      default: true,
      subsource: { mesh: g },
      subsourceToModelSubspaceTransform: y
    });
  }
  return { modelTransform: ei(a), subsources: l };
}
async function Oj(i, e, t) {
  var n = await CR(i.chunkManager, e, t);
  const r = n.source, s = n.transform, a = n.segmentPropertyMap, l = [{
    id: "default",
    default: true,
    subsource: { mesh: r },
    subsourceToModelSubspaceTransform: s
  }];
  if (a !== void 0) {
    const d = Qs(t, a), u = await el(i.chunkManager, e, d), h = Jh(i.chunkManager, e, u);
    l.push({
      id: "properties",
      default: true,
      subsource: { segmentPropertyMap: h }
    });
  }
  return {
    modelTransform: ei(bR()),
    subsources: l
  };
}
function mm(i, e) {
  return me(e), {
    url: Qs(i, Y(e, "key", Ae)),
    sharding: Y(e, "sharding", jh)
  };
}
var Vj = class {
  constructor(e, t) {
    this.url = e, me(t);
    const n = Y(t, "dimensions", mu), r = n.rank, s = Y(t, "lower_bound", (l) => lt(new Float64Array(r), l, Dt)), a = Y(t, "upper_bound", (l) => lt(new Float64Array(r), l, Dt));
    this.coordinateSpace = yt({
      rank: r,
      names: n.names,
      units: n.units,
      scales: n.scales,
      boundingBoxes: [fa({ lowerBounds: s, upperBounds: a })]
    }), this.parameters = {
      type: Y(t, "annotation_type", (l) => Rn(l, Fe)),
      rank: r,
      relationships: Y(t, "relationships", (l) => Xe(l, (d) => {
        const u = mm(e, d), h = Y(d, "id", Ae);
        return H(H({}, u), { name: h });
      })),
      properties: Y(t, "properties", tL),
      byId: Y(t, "by_id", (l) => mm(e, l))
    }, this.spatialIndices = Y(t, "spatial", (l) => Xe(l, (d) => {
      const u = mm(e, d), h = Y(d, "grid_shape", (b) => lt(new Float32Array(r), b, un)), g = Y(d, "chunk_size", (b) => lt(new Float32Array(r), b, yn)), v = Y(d, "limit", un), y = new Float32Array(r);
      for (let b = 0; b < r; ++b)
        y[b] = h[b] * g[b];
      const C = ks(Float32Array, r + 1);
      for (let b = 0; b < r; ++b)
        C[(r + 1) * r + b] = s[b];
      const w = H({
        limit: v,
        chunkToMultiscaleTransform: C
      }, Dc({
        rank: r,
        chunkDataSize: g,
        upperVoxelBound: y
      }));
      return w.upperChunkBound = h, {
        parameters: u,
        spec: w,
        limit: v
      };
    })), this.spatialIndices.reverse();
  }
};
async function Bj(i, e, t, n) {
  const r = new Vj(t, n);
  return {
    modelTransform: ei(r.coordinateSpace),
    subsources: [{
      id: "default",
      default: true,
      subsource: {
        annotation: i.chunkManager.getChunkSource(Ij, {
          credentialsProvider: e,
          metadata: r,
          parameters: r.parameters
        })
      }
    }]
  };
}
async function zk(i, e, t) {
  var n = await wR(i.chunkManager, e, t);
  const r = n.source, s = n.transform, a = n.segmentPropertyMap, l = [{
    id: "default",
    default: true,
    subsource: { mesh: r },
    subsourceToModelSubspaceTransform: s
  }];
  if (a !== void 0) {
    const d = Qs(t, a), u = await el(i.chunkManager, e, d), h = Jh(i.chunkManager, e, u);
    l.push({
      id: "properties",
      default: true,
      subsource: { segmentPropertyMap: h }
    });
  }
  return {
    modelTransform: ei(bR()),
    subsources: l
  };
}
function Fj(i) {
  me(i);
  const e = new re(), t = Y(i, "ids", (s) => {
    s = bi(s);
    const a = s.length, l = new Uint32Array(a * 2);
    for (let d = 0; d < a; ++d) {
      if (!e.tryParseString(s[d]))
        throw new Error(`Invalid uint64 id: ${oe(s[d])}`);
      l[2 * d] = e.low, l[2 * d + 1] = e.high;
    }
    return l;
  }), n = t.length / 2, r = Y(i, "properties", (s) => Xe(s, (a) => {
    me(a);
    const l = Y(a, "id", Ae), d = xe(a, "description", Ae), u = Y(a, "type", (g) => {
      if (g !== "label" && g !== "description" && g !== "string" && g !== "tags" && g !== "number")
        throw new Error(`Invalid property type: ${oe(g)}`);
      return g;
    });
    if (u === "tags") {
      const g = Y(a, "tags", bi);
      let v = xe(a, "tag_descriptions", bi);
      if (v === void 0)
        v = new Array(g.length), v.fill("");
      else if (v.length !== g.length)
        throw new Error(`Expected tag_descriptions to have length: ${g.length}`);
      const y = Y(a, "values", (C) => {
        if (!Array.isArray(C) || C.length !== n)
          throw new Error(`Expected ${n} values, but received: ${C.length}`);
        return C.map((w) => String.fromCharCode(...w));
      });
      return { id: l, description: d, type: u, tags: g, tagDescriptions: v, values: y };
    }
    if (u === "number") {
      const g = Y(a, "data_type", (w) => Rn(w, j));
      if (g === j.UINT64)
        throw new Error("uint64 properties not supported");
      const v = Y(a, "values", (w) => {
        if (!Array.isArray(w) || w.length !== n)
          throw new Error(`Expected ${n} values, but received: ${w.length}`);
        return NN[g].from(w);
      });
      let y = 1 / 0, C = -1 / 0;
      for (let w = v.length - 1; w >= 0; --w) {
        const b = v[w];
        b < y && (y = b), b > C && (C = b);
      }
      return { id: l, description: d, type: u, dataType: g, values: v, bounds: [y, C] };
    }
    const h = Y(a, "values", (g) => {
      if (bi(g), g.length !== n)
        throw new Error(`Expected ${n} values, but received: ${g.length}`);
      return g;
    });
    return { id: l, description: d, type: u, values: h };
  }));
  return mW({ ids: t, properties: r });
}
Jt(Kt()(dW), yR);
function Jh(i, e, t, n) {
  try {
    const r = Y(t, "@type", Ae);
    if (r !== "neuroglancer_segment_properties")
      throw new Error(`Unsupported segment property map type: ${oe(r)}`);
    const s = xe(t, "inline", Fj);
    return new DP({ inlineProperties: s });
  } catch (r) {
    throw new Error(`Error parsing segment property map: ${r.message}`);
  }
}
async function Uj(i, e, t, n) {
  return {
    modelTransform: ei(mo),
    subsources: [{
      id: "default",
      default: true,
      subsource: {
        segmentPropertyMap: Jh(i.chunkManager, e, n)
      }
    }]
  };
}
var zj = /^([^#]*)(?:#(.*))?$/;
function vm(i) {
  var e = i.match(zj), t = de(e, 3);
  let n = t[1], r = t[2];
  n.endsWith("/") && (n = n.substring(0, n.length - 1));
  const s = Fo(r || "");
  return { url: n, parameters: s };
}
function $k(i, e) {
  const t = JT(e);
  return t && (i += `#${t}`), i;
}
var $j = class extends pa {
  get description() {
    return "Precomputed file-backed data source";
  }
  normalizeUrl(e) {
    var t = vm(e.providerUrl);
    const n = t.url, r = t.parameters;
    return e.providerProtocol + "://" + $k(n, r);
  }
  convertLegacyUrl(e) {
    var t = vm(e.providerUrl);
    const n = t.url, r = t.parameters;
    return e.type === "mesh" && (r.type = "mesh"), e.providerProtocol + "://" + $k(n, r);
  }
  get(e) {
    var t = vm(e.providerUrl);
    const n = t.url, r = t.parameters;
    return e.chunkManager.memoize.getUncounted({ type: "precomputed:get", providerUrl: n, parameters: r }, async () => {
      var s = Ko(n, e.credentialsManager);
      const a = s.url, l = s.credentialsProvider;
      let d;
      try {
        d = await el(e.chunkManager, l, a);
      } catch (g) {
        if (Fh(g) && r.type === "mesh")
          return await zk(e, l, a);
        throw g;
      }
      me(d);
      const u = xe(d, "redirect", Ae);
      if (u !== void 0)
        throw new RD(u);
      const h = xe(d, "@type", Ae);
      switch (h) {
        case "neuroglancer_skeletons":
          return await Oj(e, l, a);
        case "neuroglancer_multilod_draco":
        case "neuroglancer_legacy_mesh":
          return await zk(e, l, a);
        case "neuroglancer_annotations_v1":
          return await Bj(e, l, a, d);
        case "neuroglancer_segment_properties":
          return await Uj(e, l, a, d);
        case "neuroglancer_multiscale_volume":
        case void 0:
          return await Nj(e, l, a, d);
        default:
          throw new Error(`Invalid type: ${oe(h)}`);
      }
    });
  }
  completeUrl(e) {
    return t0(e.credentialsManager, e.providerUrl, e.cancellationToken);
  }
};
va("precomputed", () => new $j());
var Gd = {};
var Gk;
function Gj() {
  return Gk || (Gk = 1, Gd.__esModule = true, Gd.default = function(i) {
    if (i == null) throw new TypeError("Cannot destructure undefined");
  }), Gd;
}
var Wj = Gj();
var xR = Ws(Wj);
var Ku;
(function(i) {
  i[i.RAW = 0] = "RAW", i[i.GZIP = 1] = "GZIP", i[i.BLOSC = 2] = "BLOSC";
})(Ku || (Ku = {}));
var ER = class {
};
ER.RPC_ID = "n5/VolumeChunkSource";
var Hj = class extends Jt(Kt()(zc), ER) {
};
var qj = class extends Ps {
  constructor(e, t, n, r) {
    super(e), this.credentialsProvider = t, this.multiscaleMetadata = n, this.scales = r;
    let s, a;
    if (r.forEach((g, v) => {
      if (g !== void 0) {
        if (a === void 0 && (a = v), s !== void 0 && g.dataType !== s)
          throw new Error(`Scale s${v} has data type ${j[g.dataType]} but expected ${j[s]}.`);
        s = g.dataType;
      }
    }), s === void 0)
      throw new Error("At least one scale must be specified.");
    const l = n.scales[a], d = r[a];
    this.dataType = s, this.volumeType = Pn.IMAGE, this.baseScaleIndex = a;
    const u = n.modelSpace, h = u.rank;
    this.modelSpace = yt({
      names: u.names,
      scales: u.scales,
      units: u.units,
      boundingBoxes: [{
        transform: FC(
          Float64Array,
          l.downsamplingFactor,
          /*square=*/
          false
        ),
        box: {
          lowerBounds: new Float64Array(h),
          upperBounds: new Float64Array(d.size)
        }
      }],
      coordinateArrays: u.coordinateArrays
    });
  }
  get rank() {
    return this.modelSpace.rank;
  }
  getSources(e) {
    xR(this);
    const t = this.scales, n = this.rank, r = this.multiscaleMetadata.scales;
    return yc(t.filter((s) => s !== void 0).map((s, a) => {
      const l = r[a], d = FC(Float32Array, l.downsamplingFactor);
      return Wc({
        rank: n,
        chunkToMultiscaleTransform: d,
        dataType: s.dataType,
        upperVoxelBound: s.size,
        volumeType: this.volumeType,
        chunkDataSizes: [s.chunkSize],
        volumeSourceOptions: e
      }).map((u) => ({
        chunkSource: this.chunkManager.getChunkSource(Hj, {
          credentialsProvider: this.credentialsProvider,
          spec: u,
          parameters: { url: l.url, encoding: s.encoding }
        }),
        chunkToMultiscaleTransform: d
      }));
    }));
  }
};
var jj = class {
  constructor(e) {
    me(e), this.dataType = Y(e, "dataType", (n) => Rn(n, j)), this.size = Float32Array.from(Y(e, "dimensions", (n) => Xe(n, un))), this.chunkSize = Y(e, "blockSize", (n) => lt(new Uint32Array(this.size.length), n, un));
    let t;
    xe(e, "compression", (n) => {
      t = Y(n, "type", (r) => Rn(r, Ku));
    }), t === void 0 && (t = Y(e, "compressionType", (n) => Rn(n, Ku))), this.encoding = t;
  }
};
function Jj(i, e, t) {
  return Ft.all(t.scales.map(async (n) => {
    const r = await kR(i, e, n.url, true);
    if (r !== void 0)
      return new jj(r);
  }));
}
function Kj(i) {
  var e = _o(i);
  let t = e.protocol, n = e.host, r = e.path;
  r.endsWith("/") && (r = r.substring(0, r.length - 1));
  const s = [];
  for (; ; ) {
    s.push(`${t}://${n}${r}/attributes.json`);
    const a = r.lastIndexOf("/");
    if (a === -1) break;
    r = r.substring(0, a);
  }
  return s;
}
function Yj(i, e, t, n) {
  return i.memoize.getUncounted({ type: "n5:attributes.json", url: t, credentialsProvider: En(e) }, () => ya(e, t, {}, Wi).then((r) => {
    try {
      return me(r);
    } catch (s) {
      throw new Error(`Error reading attributes from ${t}: ${s.message}`);
    }
  }).catch((r) => {
    if (Fh(r))
      return n ? void 0 : {};
    throw r;
  }));
}
async function kR(i, e, t, n) {
  const r = Kj(t), s = await Ft.all(r.map((a, l) => Yj(i, e, a, n && l === r.length - 1)));
  if (s.indexOf(void 0) === -1)
    return s.reverse(), H({}, ...s);
}
function us(i, e) {
  if (i !== -1 && e !== i)
    throw new Error(`Rank mismatch, received ${e} but expected ${i}`);
  return e;
}
function TR(i) {
  return Float64Array.from(Xe(i, yn));
}
function LR(i) {
  const e = Vi(i);
  if (e.length === 0) throw new Error("Expected non-empty array");
  let t = -1;
  return { all: Xe(e, (r) => {
    const s = TR(r);
    return t = us(t, s.length), s;
  }), single: void 0, rank: t };
}
function Xj(i) {
  const e = Vi(i);
  if (e.length === 0) throw new Error("Expected non-empty array");
  if (Array.isArray(e[0]))
    return LR(e);
  const t = TR(i);
  return { all: void 0, single: t, rank: t.length };
}
var Zj = ["x", "y", "z", "t", "c"];
function Qj(i) {
  const e = Zj.slice(0, i);
  for (; e.length < i; )
    e.push(`d${e.length + 1}`);
  return e;
}
function e8(i, e) {
  me(e);
  let t = -1, n = xe(e, "resolution", (v) => {
    const y = Float64Array.from(Xe(v, yn));
    return t = us(t, y.length), y;
  }), r = xe(e, "axes", (v) => {
    const y = Xe(v, Ae);
    return t = us(t, y.length), y;
  }), s = xe(e, "units", (v) => {
    const y = Xe(v, WC);
    return t = us(t, y.length), y;
  }), a = { unit: "m", exponent: -9 }, l, d;
  xe(e, "downsamplingFactors", (v) => {
    var y = Xj(v);
    const C = y.single, w = y.all, b = y.rank;
    t = us(t, b), C !== void 0 && (l = C), w !== void 0 && (d = w);
  }), xe(e, "pixelResolution", (v) => {
    a = Y(v, "unit", WC), xe(v, "dimensions", (y) => {
      n = Float64Array.from(Xe(y, yn)), t = us(t, n.length);
    });
  }), xe(e, "scales", (v) => {
    var y = LR(v);
    const C = y.all, w = y.rank;
    t = us(t, w), d = C;
  });
  const u = xe(e, "dimensions", (v) => {
    const y = Xe(v, un);
    return t = us(t, y.length), y;
  });
  if (t === -1)
    throw new Error("Unable to determine rank of dataset");
  s === void 0 && (s = new Array(t), s.fill(a)), n === void 0 && (n = new Float64Array(t), n.fill(1));
  for (let v = 0; v < t; ++v)
    n[v] = Cy(n[v], s[v].exponent);
  const h = new Array(t);
  r !== void 0 && xe(e, "coordinateArrays", (v) => {
    me(v);
    for (let y = 0; y < t; ++y) {
      const C = r[y];
      if (Object.prototype.hasOwnProperty.call(v, C)) {
        const w = bi(v[C]);
        h[y] = {
          explicit: false,
          labels: w,
          coordinates: _e(w, (b, E) => E)
        }, s[y] = { unit: "", exponent: 0 }, n[y] = 1;
      }
    }
  }), r === void 0 && (r = Qj(t));
  const g = yt({
    rank: t,
    valid: true,
    names: r,
    scales: n,
    units: s.map((v) => v.unit),
    coordinateArrays: h
  });
  if (u === void 0) {
    if (d === void 0)
      throw new Error("Not valid single-resolution or multi-resolution dataset");
    return {
      modelSpace: g,
      url: i,
      attributes: e,
      scales: d.map((v, y) => ({ url: `${i}/s${y}`, downsamplingFactor: v }))
    };
  }
  return l === void 0 && (l = new Float64Array(t), l.fill(1)), {
    modelSpace: g,
    url: i,
    attributes: e,
    scales: [{ url: i, downsamplingFactor: l }]
  };
}
var t8 = class extends pa {
  get description() {
    return "N5 data source";
  }
  get(e) {
    let t = e.providerUrl;
    return t.endsWith("/") && (t = t.substring(0, t.length - 1)), e.chunkManager.memoize.getUncounted({ type: "n5:MultiscaleVolumeChunkSource", providerUrl: t }, async () => {
      var n = Ko(t, e.credentialsManager);
      const r = n.url, s = n.credentialsProvider, a = await kR(e.chunkManager, s, r, false), l = e8(r, a), d = await Jj(e.chunkManager, s, l), u = new qj(e.chunkManager, s, l, d);
      return {
        modelTransform: ei(u.modelSpace),
        subsources: [{
          id: "default",
          default: true,
          url: void 0,
          subsource: { volume: u }
        }, {
          id: "bounds",
          default: true,
          url: void 0,
          subsource: {
            staticAnnotations: Ec(u.modelSpace.bounds)
          }
        }]
      };
    });
  }
  completeUrl(e) {
    return t0(e.credentialsManager, e.providerUrl, e.cancellationToken);
  }
};
va("n5", () => new t8());
var ro;
(function(i) {
  i[i.RAW = 0] = "RAW", i[i.GZIP = 1] = "GZIP", i[i.BLOSC = 2] = "BLOSC";
})(ro || (ro = {}));
var DR = class {
};
DR.RPC_ID = "zarr/VolumeChunkSource";
var Dr = new he();
Dr.set("|u1", {
  endianness: ai.LITTLE,
  dataType: j.UINT8
});
Dr.set("|i1", {
  endianness: ai.LITTLE,
  dataType: j.INT8
});
for (let i of [["<", ai.LITTLE], [">", ai.BIG]]) {
  Wk = de(i, 2);
  let e = Wk[0], t = Wk[1];
  for (let n of ["u", "i"])
    Dr.set(`${e}${n}8`, {
      endianness: t,
      dataType: j.UINT64
    });
  Dr.set(`${e}u2`, {
    endianness: t,
    dataType: j.UINT16
  }), Dr.set(`${e}i2`, {
    endianness: t,
    dataType: j.INT16
  }), Dr.set(`${e}u4`, {
    endianness: t,
    dataType: j.UINT32
  }), Dr.set(`${e}i4`, {
    endianness: t,
    dataType: j.INT32
  }), Dr.set(`${e}f4`, {
    endianness: t,
    dataType: j.FLOAT32
  });
}
var Wk;
function n8(i) {
  const e = Dr.get(i);
  if (e === void 0)
    throw new Error(`Unsupported numpy data type: ${oe(i)}`);
  return e;
}
var i8 = class extends Jt(Kt()(zc), DR) {
};
function IR(i) {
  return xe(i, "dimension_separator", (e) => {
    if (e !== "." && e !== "/")
      throw new Error(`Expected "." or "/", but received: ${oe(e)}`);
    return e;
  });
}
function r8(i) {
  try {
    me(i), Y(i, "zarr_format", (l) => {
      if (l !== 2)
        throw new Error(`Expected 2 but received: ${oe(l)}`);
    });
    const e = Y(i, "shape", (l) => Xe(l, (d) => {
      if (typeof d != "number" || !jn(d) || d < 0)
        throw new Error(`Expected non-negative integer, but received: ${oe(d)}`);
      return d;
    })), t = Y(i, "chunks", (l) => lt(new Array(e.length), l, (d) => {
      if (typeof d != "number" || !jn(d) || d <= 0)
        throw new Error(`Expected positive integer, but received: ${oe(d)}`);
      return d;
    })), n = Y(i, "order", (l) => {
      if (l !== "C" && l !== "F")
        throw new Error(`Expected "C" or "F", but received: ${oe(l)}`);
      return l;
    }), r = IR(i), s = Y(i, "dtype", (l) => n8(Ae(l))), a = Y(i, "compressor", (l) => {
      if (l === null) return ro.RAW;
      me(l);
      const d = Y(l, "id", Ae);
      switch (d) {
        case "blosc":
          return ro.BLOSC;
        case "gzip":
          return ro.GZIP;
        case "zlib":
          return ro.GZIP;
        default:
          throw new Error(`Unsupported compressor: ${oe(d)}`);
      }
    });
    return {
      rank: e.length,
      shape: e,
      chunks: t,
      order: n,
      dataType: s.dataType,
      encoding: { compressor: a, endianness: s.endianness },
      dimensionSeparator: r
    };
  } catch (e) {
    throw new Error(`Error parsing zarr metadata: ${e.message}`);
  }
}
var s8 = class extends Ps {
  constructor(e, t, n, r, s, a) {
    super(e), this.credentialsProvider = t, this.url = n, this.separator = r, this.metadata = s, this.attrs = a, this.dataType = s.dataType, this.volumeType = Pn.IMAGE;
    let l = xe(a, "_ARRAY_DIMENSIONS", (d) => lt(new Array(s.rank), d, Ae));
    l === void 0 && (l = _e(s.shape, (d, u) => `d${u}`)), this.modelSpace = yt({
      names: l,
      scales: Float64Array.from(s.shape, () => 1),
      units: _e(s.shape, () => ""),
      boundingBoxes: [fa({
        lowerBounds: new Float64Array(s.rank),
        upperBounds: Float64Array.from(s.shape)
      })]
    });
  }
  get rank() {
    return this.metadata.rank;
  }
  getSources(e) {
    const t = this.metadata, n = t.rank, r = t.chunks, s = t.shape;
    let a, l, d;
    if (t.order === "F")
      a = Uint32Array.from(r), l = Float32Array.from(s), d = ks(Float32Array, n + 1);
    else {
      a = new Uint32Array(n), l = new Float32Array(n), d = new Float32Array((n + 1) ** 2), d[(n + 1) ** 2 - 1] = 1;
      for (let u = 0; u < n; ++u)
        a[u] = r[n - 1 - u], l[u] = s[n - 1 - u], d[u + (n - 1 - u) * (n + 1)] = 1;
    }
    return yc([Wc({
      rank: n,
      chunkToMultiscaleTransform: d,
      dataType: t.dataType,
      upperVoxelBound: l,
      volumeType: this.volumeType,
      chunkDataSizes: [a],
      volumeSourceOptions: e
    }).map((u) => ({
      chunkSource: this.chunkManager.getChunkSource(i8, {
        credentialsProvider: this.credentialsProvider,
        spec: u,
        parameters: {
          url: this.url,
          encoding: t.encoding,
          separator: this.separator
        }
      }),
      chunkToMultiscaleTransform: d
    }))]);
  }
};
function a8(i, e, t) {
  return i.memoize.getUncounted({ type: "zarr:.zattrs json", url: t, credentialsProvider: En(e) }, async () => {
    try {
      const n = await ya(e, t + "/.zattrs", {}, Wi);
      return me(n), n;
    } catch (n) {
      if (Fh(n)) return {};
      throw n;
    }
  });
}
function o8(i, e, t) {
  return i.memoize.getUncounted({ type: "zarr:.zarray json", url: t, credentialsProvider: En(e) }, async () => {
    const n = await ya(e, t + "/.zarray", {}, Wi);
    return r8(n);
  });
}
var l8 = [{
  key: { value: "dimension_separator", description: "Dimension separator in chunk keys" },
  values: [{ value: ".", description: "(default)" }, { value: "/", description: "" }]
}];
var c8 = class extends pa {
  get description() {
    return "Zarr data source";
  }
  get(e) {
    var t = e.providerUrl.match(/([^?]*)(?:\?(.*))?$/), n = de(t, 3);
    let r = n[1], s = n[2];
    const a = Fo(s || "");
    me(a);
    const l = IR(a);
    return r.endsWith("/") && (r = r.substring(0, r.length - 1)), e.chunkManager.memoize.getUncounted({ type: "zarr:MultiscaleVolumeChunkSource", providerUrl: r, dimensionSeparator: l }, async () => {
      var d = Ko(r, e.credentialsManager);
      const u = d.url, h = d.credentialsProvider;
      var g = await Ft.all([o8(e.chunkManager, h, u), a8(e.chunkManager, h, u)]), v = de(g, 2);
      const y = v[0], C = v[1];
      if (y.dimensionSeparator !== void 0 && l !== void 0 && y.dimensionSeparator !== l)
        throw new Error(`Explicitly specified dimension separator ${oe(l)} does not match value in .zarray ${oe(y.dimensionSeparator)}`);
      const w = new s8(e.chunkManager, h, u, l || y.dimensionSeparator || ".", y, C);
      return {
        modelTransform: ei(w.modelSpace),
        subsources: [{
          id: "default",
          default: true,
          url: void 0,
          subsource: { volume: w }
        }, {
          id: "bounds",
          default: true,
          url: void 0,
          subsource: {
            staticAnnotations: Ec(w.modelSpace.bounds)
          }
        }]
      };
    });
  }
  async completeUrl(e) {
    var t = e.providerUrl.match(/([^?]*)(?:\?(.*))?$/), n = de(t, 3);
    let r = n[2];
    return r !== void 0 ? Go(e.providerUrl.length - r.length, await PD(r, l8)) : await t0(e.credentialsManager, e.providerUrl, e.cancellationToken);
  }
};
va("zarr", () => new c8());
var la;
(function(i) {
  i[i.DEFAULT = 0] = "DEFAULT", i[i.ADDITIVE = 1] = "ADDITIVE";
})(la || (la = {}));
var d8 = new he([[la.DEFAULT, (i) => {
  i.blendFunc(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA);
}], [la.ADDITIVE, (i) => {
  i.blendFunc(i.SRC_ALPHA, i.ONE);
}]]);
function u8(i = la.DEFAULT) {
  return new Eh(la, i);
}
var PR = `#uicontrol invlerp normalized
void main() {
  emitGrayscale(normalized());
}
`;
function h8(i = PR) {
  return _y(i);
}
function RR(i, e) {
  i.addFragmentCode(`
#define VOLUME_RENDERING false

void emitRGBA(vec4 rgba) {
  emit(vec4(rgba.rgb, rgba.a * uOpacity));
}
void emitRGB(vec3 rgb) {
  emit(vec4(rgb, uOpacity));
}
void emitGrayscale(float value) {
  emit(vec4(value, value, value, uOpacity));
}
void emitTransparent() {
  emit(vec4(0.0, 0.0, 0.0, 0.0));
}
`), i.addFragmentCode(cc), lc(e, i), i.setFragmentMainFunction(sc(e.parseResult.code));
}
var f8 = class extends VP {
  constructor(e, t) {
    var n, r, s;
    const a = t.opacity, l = t.blendMode, d = t.shaderControlState;
    super(e, H(H({}, t), { fallbackShaderParameters: new vt(zy(Sh(PR, {
      imageData: {
        dataType: e.dataType,
        channelRank: (s = (r = (n = t.channelCoordinateSpace) === null || n === void 0 ? void 0 : n.value) === null || r === void 0 ? void 0 : r.rank) !== null && s !== void 0 ? s : 0
      }
    }))), encodeShaderParameters: (u) => u.key, shaderParameters: d.builderState, dataHistogramSpecifications: d.histogramSpecifications })), this.shaderControlState = d, this.opacity = a, this.blendMode = l, this.registerDisposer(a.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(l.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(d.changed.add(this.redrawNeeded.dispatch));
  }
  defineShader(e, t) {
    if (t.parseResult.errors.length !== 0)
      throw new Error("Invalid UI control specification");
    e.addUniform("highp float", "uOpacity"), RR(e, t);
  }
  initializeShader(e, t, n) {
    const r = this.gl;
    r.uniform1f(t.uniform("uOpacity"), this.opacity.value), wo(r, t, this.shaderControlState, n.parseResult.controls);
  }
  setGLBlendMode(e, t) {
    const n = this.blendMode.value;
    n === la.ADDITIVE || t > 0 ? (e.enable(e.BLEND), d8.get(n)(e)) : e.disable(WebGL2RenderingContext.BLEND);
  }
};
var p8 = "volume_rendering/VolumeRenderingRenderLayer";
var g8 = "volume_rendering/VolumeRenderingRenderLayer/update";
var Jv = 64;
var m8 = Sc();
function v8(i, e, t) {
  let n = 0, r = 0;
  for (let u = 0; u < 3; ++u) {
    const h = i[16 + u], g = h * e[u], v = h * t[u];
    n += Math.min(g, v), r += Math.max(g, v);
  }
  const s = -i[19], a = Math.max(s, n), l = i[23], d = Math.min(l, r);
  return { near: s, far: l, adjustedNear: a, adjustedFar: d };
}
function Hk(i, e, t, n, r, s) {
  if (n.length === 0) return;
  const a = i.viewMatrix, l = i.projectionMat, u = i.displayDimensionRenderInfo.voxelPhysicalScales, h = Tm(u), v = (AT(l) / Jv) ** 3, y = ly(lh(m8, a)), C = (P) => {
    const L = n[P];
    return Math.abs(L.chunkLayout.detTransform * y);
  };
  let w = n.length - 1, b = C(w);
  for (let P = w - 1; P >= 0; --P) {
    const L = C(P);
    if (Math.abs(L - v) < Math.abs(b - v))
      b = L, w = P;
    else
      break;
  }
  const E = Math.pow(b * h / y, 1 / 3), T = Math.pow(b, 1 / 3) * i.width / (2 * l[0]);
  let I = true;
  const R = n[w];
  gD(i, e, R, (P, L) => {
    I && (r(R, w, E, T, L), I = false), s(R, w, P);
  });
}
var y8 = nt();
var S8 = new Float32Array(24);
var b8 = class extends Ho {
  constructor(e) {
    super(), this.multiscaleSource = e.multiscaleSource, this.transform = e.transform, this.channelCoordinateSpace = e.channelCoordinateSpace, this.shaderControlState = e.shaderControlState, this.localPosition = e.localPosition, this.renderScaleTarget = e.renderScaleTarget, this.renderScaleHistogram = e.renderScaleHistogram, this.registerDisposer(this.renderScaleHistogram.visibility.add(this.visibility));
    const t = this.registerDisposer(wi((a) => a.rank, [this.channelCoordinateSpace]));
    this.shaderGetter = My(this, this.gl, {
      memoizeKey: "VolumeRenderingRenderLayer",
      parameters: e.shaderControlState.builderState,
      getContextKey: ({ emitter: a, chunkFormat: l }) => `${En(a)}:${l.shaderKey}`,
      shaderError: e.shaderError,
      extraParameters: t,
      defineShader: (a, { emitter: l, chunkFormat: d }, u, h) => {
        if (u.parseResult.errors.length !== 0)
          throw new Error("Invalid UI control specification");
        Ur(a), a.addFragmentCode(`
#define VOLUME_RENDERING true
`), l(a), a.addUniform("highp float", "uNearLimitFraction"), a.addUniform("highp float", "uFarLimitFraction"), a.addUniform("highp int", "uMaxSteps"), a.addUniform("highp vec3", "uTranslation"), a.addUniform("highp mat4", "uModelViewProjectionMatrix"), a.addUniform("highp mat4", "uInvModelViewProjectionMatrix"), a.addUniform("highp vec3", "uChunkDataSize"), a.addUniform("highp vec3", "uLowerClipBound"), a.addUniform("highp vec3", "uUpperClipBound"), a.addUniform("highp float", "uBrightnessFactor"), a.addVarying("highp vec4", "vNormalizedPosition"), a.addVertexCode(tH), a.setVertexMain(`
vec3 boxVertex = getBoxFaceVertexPosition(gl_VertexID);
vec3 position = max(uLowerClipBound, min(uUpperClipBound, uTranslation + boxVertex * uChunkDataSize));
vNormalizedPosition = gl_Position = uModelViewProjectionMatrix * vec4(position, 1.0);
gl_Position.z = 0.0;
`), a.addFragmentCode(`
vec3 curChunkPosition;
vec4 outputColor;
void userMain();
`), CI(a, d, h, "curChunkPosition"), a.addFragmentCode(`
void emitRGBA(vec4 rgba) {
  float alpha = rgba.a * uBrightnessFactor;
  outputColor += vec4(rgba.rgb * alpha, alpha);
}
void emitRGB(vec3 rgb) {
  emitRGBA(vec4(rgb, 1.0));
}
void emitGrayscale(float value) {
  emitRGB(vec3(value, value, value));
}
void emitTransparent() {
  emitRGBA(vec4(0.0, 0.0, 0.0, 0.0));
}
`), a.setFragmentMainFunction(`
void main() {
  vec2 normalizedPosition = vNormalizedPosition.xy / vNormalizedPosition.w;
  vec4 nearPointH = uInvModelViewProjectionMatrix * vec4(normalizedPosition, -1.0, 1.0);
  vec4 farPointH = uInvModelViewProjectionMatrix * vec4(normalizedPosition, 1.0, 1.0);
  vec3 nearPoint = nearPointH.xyz / nearPointH.w;
  vec3 farPoint = farPointH.xyz / farPointH.w;
  vec3 rayVector = farPoint - nearPoint;
  vec3 boxStart = max(uLowerClipBound, uTranslation);
  vec3 boxEnd = min(boxStart + uChunkDataSize, uUpperClipBound);
  float intersectStart = uNearLimitFraction;
  float intersectEnd = uFarLimitFraction;
  for (int i = 0; i < 3; ++i) {
    float startPt = nearPoint[i];
    float endPt = farPoint[i];
    float boxLower = boxStart[i];
    float boxUpper = boxEnd[i];
    float r = rayVector[i];
    float startFraction;
    float endFraction;
    if (startPt >= boxLower && startPt <= boxUpper) {
      startFraction = 0.0;
    } else {
      startFraction = min((boxLower - startPt) / r, (boxUpper - startPt) / r);
    }
    if (endPt >= boxLower && endPt <= boxUpper) {
      endFraction = 1.0;
    } else {
      endFraction = max((boxLower - startPt) / r, (boxUpper - startPt) / r);
    }
    intersectStart = max(intersectStart, startFraction);
    intersectEnd = min(intersectEnd, endFraction);
  }
  float stepSize = (uFarLimitFraction - uNearLimitFraction) / float(uMaxSteps - 1);
  int startStep = int(floor((intersectStart - uNearLimitFraction) / stepSize));
  int endStep = min(uMaxSteps, int(floor((intersectEnd - uNearLimitFraction) / stepSize)) + 1);
  outputColor = vec4(0, 0, 0, 0);
  for (int step = startStep; step < endStep; ++step) {
    vec3 position = mix(nearPoint, farPoint, uNearLimitFraction + float(step) * stepSize);
    curChunkPosition = position - uTranslation;
    userMain();
  }
  emit(outputColor, 0u);
}
`), a.addFragmentCode(cc), lc(u, a), a.addFragmentCode(`
#define main userMain
` + sc(u.parseResult.code) + `
#undef main
`);
      }
    }), this.vertexIdHelper = this.registerDisposer(fr.get(this.gl)), this.registerDisposer(this.renderScaleTarget.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.shaderControlState.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.localPosition.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.transform.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.shaderControlState.fragmentMain.changed.add(this.redrawNeeded.dispatch));
    const n = this.multiscaleSource.chunkManager, r = this.registerDisposer(new Rc(this.layerChunkProgressInfo)), s = n.rpc;
    r.RPC_TYPE_ID = p8, r.initializeCounterpart(s, {
      chunkManager: n.rpcId,
      localPosition: this.registerDisposer(An.makeFromExisting(s, this.localPosition)).rpcId,
      renderScaleTarget: this.registerDisposer(An.makeFromExisting(s, this.renderScaleTarget)).rpcId
    }), this.backend = r;
  }
  get gl() {
    return this.multiscaleSource.chunkManager.gl;
  }
  get isTransparent() {
    return true;
  }
  get isVolumeRendering() {
    return true;
  }
  get dataType() {
    return this.multiscaleSource.dataType;
  }
  attach(e) {
    super.attach(e), e.state = {
      sources: e.registerDisposer(Or((t, n, r) => {
        const s = Yy(r, n, (a) => this.multiscaleSource.getSources(a), e.messages, this);
        for (const a of s)
          for (const l of a)
            t.registerDisposer(l.source);
        return e.view.flushBackendProjectionParameters(), this.backend.rpc.invoke(g8, {
          layer: this.backend.rpcId,
          view: e.view.rpcId,
          sources: Ky(s)
        }), this.redrawNeeded.dispatch(), s;
      }, this.transform, e.view.displayDimensionRenderInfo))
    };
  }
  get chunkManager() {
    return this.multiscaleSource.chunkManager;
  }
  draw(e, t) {
    if (!e.emitColor) return;
    const n = t.state.sources.value;
    if (n.length === 0) return;
    let r = 0, s = 0, a = null, l, d;
    const u = ze(), h = this.gl;
    this.vertexIdHelper.enable();
    const g = this.renderScaleHistogram;
    g.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
    const v = () => {
      a !== null && (l !== null && l.endDrawing(h, a), (b !== 0 || E !== 0) && g.add(r, s, b, E));
    };
    let y = true;
    const C = e.projectionParameters;
    let w, b = 0, E = 0, T;
    const I = this.multiscaleSource.rank, R = ze();
    h.enable(WebGL2RenderingContext.CULL_FACE), h.cullFace(WebGL2RenderingContext.FRONT), Hk(e.projectionParameters, this.localPosition.value, this.renderScaleTarget.value, n[0], (P, L, A, M) => {
      r = A, s = M;
      const O = Hy(C, P.chunkLayout), F = P.source, q = P.fixedPositionWithinChunk, U = P.chunkDisplayDimensionIndices;
      for (const je of U)
        q[je] = 0;
      const V = F.chunkFormat;
      if (V !== l && (l = V, v(), d = this.shaderGetter({ emitter: e.emitter, chunkFormat: V }), a = d.shader, a !== null && (a.bind(), V !== null && (wo(h, a, this.shaderControlState, d.parameters.parseResult.controls), V.beginDrawing(h, a), V.beginSource(h, a)))), T = void 0, a === null) return;
      w = F.chunks, u.fill(1);
      const $ = vn(y8, C.viewProjectionMat, O.transform);
      h.uniformMatrix4fv(a.uniform("uModelViewProjectionMatrix"), false, $);
      const B = S8;
      ou(B, $), ys($, $), h.uniformMatrix4fv(a.uniform("uInvModelViewProjectionMatrix"), false, $);
      var ue = v8(B, P.lowerClipDisplayBound, P.upperClipDisplayBound);
      const se = ue.near, Pe = ue.far, ae = ue.adjustedNear, Ee = ue.adjustedFar, ge = (Ee - ae) / (Jv - 1) / (Pe - se);
      h.uniform1f(a.uniform("uBrightnessFactor"), ge);
      const Ne = (ae - se) / (Pe - se), Me = (Ee - se) / (Pe - se);
      h.uniform1f(a.uniform("uNearLimitFraction"), Ne), h.uniform1f(a.uniform("uFarLimitFraction"), Me), h.uniform1i(a.uniform("uMaxSteps"), Jv), h.uniform3fv(a.uniform("uLowerClipBound"), P.lowerClipDisplayBound), h.uniform3fv(a.uniform("uUpperClipBound"), P.upperClipDisplayBound);
    }, (P) => {
      if (a === null) return;
      const L = P.curPositionInChunks.join(), A = w.get(L);
      if (A !== void 0 && A.state === kt.GPU_MEMORY) {
        const M = P.chunkLayout.size;
        let O = A.chunkDataSize;
        const F = P.chunkDisplayDimensionIndices, q = P.fixedPositionWithinChunk, U = P.chunkTransform.channelToChunkDimensionIndices;
        if (xR(P), O !== T) {
          T = O;
          for (let $ = 0; $ < 3; ++$) {
            const B = F[$];
            u[$] = B === -1 || B >= I ? 1 : T[B];
          }
          h.uniform3fv(a.uniform("uChunkDataSize"), u);
        }
        const V = A.chunkGridPosition;
        for (let $ = 0; $ < 3; ++$) {
          const B = F[$];
          R[$] = B === -1 || B >= I ? 0 : M[$] * V[B];
        }
        l == null ? void 0 : l.bindChunk(h, a, A, q, F, U, y), y = false, h.uniform3fv(a.uniform("uTranslation"), R), nH(h, 1, 1), ++b;
      } else
        ++E;
    }), h.disable(WebGL2RenderingContext.CULL_FACE), v(), this.vertexIdHelper.disable();
  }
  isReady(e, t) {
    const n = t.state.sources.value;
    if (n.length === 0) return true;
    let r = false;
    return Hk(e.projectionParameters, this.localPosition.value, this.renderScaleTarget.value, n[0], () => {
    }, (s) => {
      const a = s.source.chunks.get(s.curPositionInChunks.join());
      (a === void 0 || a.state !== kt.GPU_MEMORY) && (r = true);
    }), r;
  }
};
var w8 = St.fromObject({
  arrowup: { action: "tab-backward" },
  arrowdown: { action: "tab-forward" },
  tab: { action: "tab-forward" },
  "shift+tab": { action: "tab-backward" },
  enter: { action: "commit" },
  escape: { action: "cancel" }
});
var C8 = class {
  constructor(e) {
    this.id = e, this.element = document.createElement("div"), this.nameContainer = document.createElement("div"), this.nameElement = document.createElement("input"), this.lowerElement = document.createElement("div"), this.upperElement = document.createElement("div");
    const t = this.element, n = this.nameContainer, r = this.nameElement, s = this.lowerElement, a = this.upperElement;
    t.classList.add("neuroglancer-channel-dimensions-widget-dim"), n.classList.add("neuroglancer-channel-dimensions-widget-name-container"), r.classList.add("neuroglancer-channel-dimensions-widget-name"), n.appendChild(r), s.classList.add("neuroglancer-channel-dimensions-widget-lower"), a.classList.add("neuroglancer-channel-dimensions-widget-upper"), t.appendChild(n), t.appendChild(s), t.appendChild(a), n.draggable = true, r.disabled = true, r.spellcheck = false, r.autocomplete = "off", r.required = true, r.placeholder = " ", n.title = "Drag to reorder, double click to rename.  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).", n.addEventListener("dblclick", () => {
      r.disabled = false, r.focus(), r.select();
    }), r.addEventListener("focus", () => {
      r.select();
    });
  }
};
var x8 = class extends X {
  constructor(e) {
    super(), this.combiner = e, this.element = document.createElement("div"), this.dimensionWidgets = [], this.curCoordinateSpace = void 0, this.dragSource = void 0, this.coordinateSpace = this.combiner.combined;
    const t = this.element;
    t.classList.add("neuroglancer-channel-dimensions-widget");
    const n = this.registerCancellable(Ct(() => this.updateView()));
    this.registerDisposer(e.combined.changed.add(n));
    const r = this.registerDisposer(new Gi(t, w8));
    r.allShortcutsAreGlobal = true, this.registerDisposer(Ce(t, "cancel", (s) => {
      this.forceUpdateView();
      const a = s.target;
      a instanceof HTMLElement && a.blur();
    })), this.updateView();
  }
  reorderDimensionTo(e, t) {
    if (e === t) return;
    const n = this.coordinateSpace;
    n.value = SL(n.value, e, t);
  }
  makeNewDimensionWidget(e) {
    const t = new C8(e);
    return t.nameContainer.addEventListener("dragstart", (n) => {
      this.dragSource = t, n.stopPropagation(), n.dataTransfer.setData("neuroglancer-dimension", "");
    }), t.nameContainer.addEventListener("dragenter", (n) => {
      const r = this.dragSource;
      if (r === void 0 || r === t) return;
      const s = this.dimensionWidgets, a = s.indexOf(r), l = s.indexOf(t);
      a === -1 || l === -1 || (n.preventDefault(), this.reorderDimensionTo(l, a));
    }), t.nameContainer.addEventListener("dragend", (n) => {
      this.dragSource === t && (this.dragSource = void 0);
    }), t.nameElement.addEventListener("blur", (n) => {
      t.nameElement.disabled = true;
      const r = n.relatedTarget;
      this.dimensionWidgets.some((s) => s.nameElement === r) || this.updateNames() || this.forceUpdateView();
    }), t.nameElement.addEventListener("input", () => {
      const n = t.nameElement;
      Xn(n), this.updateNameValidity();
    }), Ce(t.nameElement, "commit", () => {
      this.updateNames();
    }), Ce(t.nameElement, "tab-forward", (n) => this.selectAdjacentField(n, t, 1)), Ce(t.nameElement, "tab-backward", (n) => this.selectAdjacentField(n, t, -1)), t;
  }
  selectAdjacentField(e, t, n) {
    e.stopPropagation();
    const r = this.dimensionWidgets, s = r.indexOf(t);
    if (s === -1) return;
    const a = s + n;
    if (a < 0 || a >= r.length) return;
    const l = r[a];
    l.nameElement.disabled = false, l.nameElement.focus(), e.preventDefault();
  }
  updateNames() {
    const e = this.dimensionWidgets, t = this.coordinateSpace, n = t.value, r = e.map((d) => d.nameElement.value);
    if (this.combiner.getRenameValidity(r).includes(false)) return false;
    const s = n.names;
    if (He(s, r)) return false;
    const a = n.timestamps.map((d, u) => s[u] === r[u] ? d : Date.now()), l = H(H({}, n), { names: r, timestamps: a });
    return t.value = l, true;
  }
  updateNameValidity() {
    const e = this.dimensionWidgets, t = e.map((s) => s.nameElement.value), n = t.length, r = this.combiner.getRenameValidity(t);
    for (let s = 0; s < n; ++s)
      e[s].nameElement.dataset.isValid = r[s] === false ? "false" : "true";
  }
  forceUpdateView() {
    this.curCoordinateSpace = void 0, this.updateView();
  }
  updateView() {
    const e = this.coordinateSpace.value;
    if (this.curCoordinateSpace === e) return;
    this.curCoordinateSpace = e;
    const t = this.element, n = this.dimensionWidgets, r = this.dimensionWidgets = e.ids.map((a) => n.find((l) => l.id === a) || this.makeNewDimensionWidget(a));
    function* s() {
      const a = e.names, l = e.rank;
      var d = e.bounds;
      const u = d.lowerBounds, h = d.upperBounds;
      for (let g = 0; g < l; ++g) {
        const v = r[g];
        v.nameElement.value = a[g], delete v.nameElement.dataset.isValid, Xn(v.nameElement), v.lowerElement.textContent = u[g].toString(), v.upperElement.textContent = h[g].toString(), yield v.element;
      }
    }
    rr(t, s.call(this));
  }
};
var Kv = "opacity";
var Yv = "blend";
var qk = "shader";
var jk = "shaderControls";
var Xv = "crossSectionRenderScale";
var Jk = "channelDimensions";
var Zv = "volumeRendering";
var E8 = "volumeRenderScale";
var k8 = BS(Xo);
var Sa = class extends k8 {
  constructor(e) {
    super(e), this.opacity = Wl(0.5), this.blendMode = u8(), this.fragmentMain = h8(), this.shaderError = vh(), this.dataType = new vt(void 0), this.sliceViewRenderScaleHistogram = new Co(), this.sliceViewRenderScaleTarget = sa(1), this.volumeRenderingRenderScaleHistogram = new Co(), this.volumeRenderingRenderScaleTarget = sa(1), this.channelCoordinateSpace = new Ey(), this.channelCoordinateSpaceCombiner = new Dy(this.channelCoordinateSpace, aV), this.channelSpace = this.registerDisposer(nr((t) => jL(() => pV(t)), this.channelCoordinateSpace)), this.volumeRendering = new nn(false, false), this.shaderControlState = this.registerDisposer(new $y(this.fragmentMain, this.registerDisposer(wi((t, n) => t === void 0 ? null : { imageData: { dataType: t, channelRank: n.rank } }, [this.dataType, this.channelCoordinateSpace], (t, n) => oe(t) === oe(n))), this.channelCoordinateSpaceCombiner)), this.localCoordinateSpaceCombiner.includeDimensionPredicate = ql, this.blendMode.changed.add(this.specificationChanged.dispatch), this.opacity.changed.add(this.specificationChanged.dispatch), this.fragmentMain.changed.add(this.specificationChanged.dispatch), this.shaderControlState.changed.add(this.specificationChanged.dispatch), this.sliceViewRenderScaleTarget.changed.add(this.specificationChanged.dispatch), this.volumeRendering.changed.add(this.specificationChanged.dispatch), this.tabs.add("rendering", { label: "Rendering", order: -100, getter: () => new T8(this) }), this.tabs.default = "rendering";
  }
  markLoading() {
    const e = super.markLoading(), t = this.channelCoordinateSpaceCombiner.retain();
    return () => {
      e(), t();
    };
  }
  addCoordinateSpace(e) {
    const t = super.addCoordinateSpace(e), n = this.channelCoordinateSpaceCombiner.bind(e);
    return () => {
      t(), n();
    };
  }
  activateDataSubsources(e) {
    let t;
    for (const n of e) {
      if (this.addStaticAnnotations(n)) continue;
      const a = n.subsourceEntry.subsource.volume;
      if (!(a instanceof Ps)) {
        n.deactivate("Not compatible with image layer");
        continue;
      }
      if (t && a.dataType !== t) {
        n.deactivate(`Data type must be ${j[a.dataType].toLowerCase()}`);
        continue;
      }
      t = a.dataType, n.activate((l) => {
        n.addRenderLayer(new f8(a, {
          opacity: this.opacity,
          blendMode: this.blendMode,
          shaderControlState: this.shaderControlState,
          shaderError: this.shaderError,
          transform: n.getRenderLayerTransform(this.channelCoordinateSpace),
          renderScaleTarget: this.sliceViewRenderScaleTarget,
          renderScaleHistogram: this.sliceViewRenderScaleHistogram,
          localPosition: this.localPosition,
          channelCoordinateSpace: this.channelCoordinateSpace
        }));
        const d = l.registerDisposer(new b8({
          multiscaleSource: a,
          shaderControlState: this.shaderControlState,
          shaderError: this.shaderError,
          transform: n.getRenderLayerTransform(this.channelCoordinateSpace),
          renderScaleTarget: this.volumeRenderingRenderScaleTarget,
          renderScaleHistogram: this.volumeRenderingRenderScaleHistogram,
          localPosition: this.localPosition,
          channelCoordinateSpace: this.channelCoordinateSpace
        }));
        l.registerDisposer(n.messages.addChild(d.messages)), l.registerDisposer(Or((u, h) => {
          h && u.registerDisposer(this.addRenderLayer(d.addRef()));
        }, this.volumeRendering)), this.shaderError.changed.dispatch();
      });
    }
    this.dataType.value = t;
  }
  restoreState(e) {
    super.restoreState(e), this.opacity.restoreState(e[Kv]), xe(e, Yv, (t) => this.blendMode.restoreState(t)), this.fragmentMain.restoreState(e[qk]), this.shaderControlState.restoreState(e[jk]), this.sliceViewRenderScaleTarget.restoreState(e[Xv]), this.channelCoordinateSpace.restoreState(e[Jk]), this.volumeRendering.restoreState(e[Zv]);
  }
  toJSON() {
    const e = super.toJSON();
    return e[Kv] = this.opacity.toJSON(), e[Yv] = this.blendMode.toJSON(), e[qk] = this.fragmentMain.toJSON(), e[jk] = this.shaderControlState.toJSON(), e[Xv] = this.sliceViewRenderScaleTarget.toJSON(), e[Jk] = this.channelCoordinateSpace.toJSON(), e[Zv] = this.volumeRendering.toJSON(), e;
  }
  displayImageSelectionState(e, t) {
    const n = e.value;
    if (n == null) return false;
    const r = this.channelSpace.value;
    if (r.error !== void 0) return false;
    const s = r.numChannels, a = r.coordinates;
    var l = r.channelCoordinateSpace;
    const d = l.names, u = l.rank, h = document.createElement("div");
    h.classList.add("neuroglancer-selection-details-value-grid");
    let g = "[copy] 0fr ";
    u !== 0 && (g += `repeat(${u}, [dim] 0fr [coord] 0fr) `), g += "[value] 1fr", h.style.gridTemplateColumns = g;
    for (let v = 0; v < s; ++v) {
      const y = u === 0 ? n : n[v], C = y == null ? "" : y.toString(), w = or({
        title: "Copy value",
        onClick: () => {
          oi(C);
        }
      });
      h.appendChild(w);
      for (let E = 0; E < u; ++E) {
        const T = document.createElement("div");
        T.classList.add("neuroglancer-selection-details-value-grid-dim"), T.textContent = d[E], h.appendChild(T);
        const I = document.createElement("div");
        I.classList.add("neuroglancer-selection-details-value-grid-coord"), I.textContent = a[v * u + E].toString(), h.appendChild(I);
      }
      const b = document.createElement("div");
      b.classList.add("neuroglancer-selection-details-value-grid-value"), b.textContent = C, h.appendChild(b);
    }
    return t.appendChild(h), true;
  }
  displaySelectionState(e, t, n) {
    let r = this.displayImageSelectionState(e, t);
    return super.displaySelectionState(e, t, n) && (r = true), r;
  }
  getLegendShaderOptions() {
    return {
      memoizeKey: "ImageUserLayer",
      parameters: this.shaderControlState.builderState,
      // fixme: support fallback
      encodeParameters: (e) => e.key,
      defineShader: (e, t) => {
        e.addFragmentCode(`
#define uOpacity 1.0
`), RR(e, t);
      },
      initializeShader: (e) => {
        const t = e.shader;
        wo(this.manager.root.display.gl, t, this.shaderControlState, e.parameters.parseResult.controls);
      }
    };
  }
};
Sa.type = "image";
Sa.typeAbbreviation = "img";
function AR(i) {
  return new HS({
    shaderError: i.shaderError,
    fragmentMain: i.fragmentMain,
    shaderControlState: i.shaderControlState
  });
}
var _R = [H({ label: "Resolution (slice)", toolJson: Xv }, $u((i) => ({
  histogram: i.sliceViewRenderScaleHistogram,
  target: i.sliceViewRenderScaleTarget
}))), H({ label: "Blending", toolJson: Yv }, T2((i) => i.blendMode)), H({ label: "Volume rendering (experimental)", toolJson: Zv }, Xl((i) => i.volumeRendering)), H({ label: "Resolution (3d)", toolJson: E8, isValid: (i) => i.volumeRendering }, $u((i) => ({
  histogram: i.volumeRenderingRenderScaleHistogram,
  target: i.volumeRenderingRenderScaleTarget
}))), H({ label: "Opacity", toolJson: Kv }, fs((i) => ({ value: i.opacity })))];
for (const i of _R)
  b2(Sa, i);
var T8 = class extends qr {
  constructor(e) {
    super(), this.layer = e, this.codeWidget = this.registerDisposer(AR(this.layer));
    const t = this.element;
    t.classList.add("neuroglancer-image-dropdown");
    for (const s of _R)
      t.appendChild(GS(this, e, this.visibility, s));
    let n = document.createElement("div");
    n.style.flex = "1";
    let r = document.createElement("div");
    r.className = "neuroglancer-image-dropdown-top-row", r.appendChild(document.createTextNode("Shader")), r.appendChild(n), r.appendChild(WS({
      title: "Show larger editor view",
      onClick: () => {
        new L8(this.layer);
      }
    })), r.appendChild($S({
      title: "Documentation on image layer rendering",
      href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md"
    })), t.appendChild(r), t.appendChild(this.registerDisposer(new x8(e.channelCoordinateSpaceCombiner)).element), t.appendChild(this.codeWidget.element), t.appendChild(this.registerDisposer(new qS(e.shaderControlState, this.layer.manager.root.display, this.layer, {
      visibility: this.visibility,
      legendShaderOptions: this.layer.getLegendShaderOptions()
    })).element);
  }
};
var L8 = class extends Gh {
  constructor(e) {
    super(), this.layer = e, this.codeWidget = this.registerDisposer(AR(this.layer)), this.content.classList.add("neuroglancer-image-layer-shader-overlay"), this.content.appendChild(this.codeWidget.element), this.codeWidget.textEditor.refresh();
  }
};
Zo(Sa);
xP(Pn.IMAGE, Sa);
LS((i) => {
  const e = i.volume;
  if (e !== void 0 && e.volumeType === Pn.UNKNOWN)
    return { layerConstructor: Sa, priority: -100 };
});
jS(Sa, (i) => ({
  shaderControlState: i.shaderControlState,
  legendShaderOptions: i.getLegendShaderOptions()
}));
function D8(i) {
  if (i.brainMapsClientId) {
    const t = i.brainMapsClientId;
    Jo.register(qh, () => new uR(t));
  }
  let e = uq({ bundleRoot: i.bundleRoot }, i.target);
  return PU(e.inputEventBindings), Q6(e), tq(e), hq(i.target), e;
}
var I8 = class {
  version() {
    return "0.0.1";
  }
};
var P8 = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: I8,
  setupDefaultViewer: D8
}, Symbol.toStringTag, { value: "Module" }));
var R8 = rI(P8);
var A8 = rI(mO);
var _8 = rI(sO);
var M8 = rI(z4);
var Kk;
function N8() {
  return Kk || (Kk = 1, function(i) {
    function e(Z) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? e = function(te) {
        return typeof te;
      } : e = function(te) {
        return te && typeof Symbol == "function" && te.constructor === Symbol && te !== Symbol.prototype ? "symbol" : typeof te;
      }, e(Z);
    }
    Object.defineProperty(i, "__esModule", {
      value: true
    }), i.parseUrlHash = B, i.getNeuroglancerViewerState = ue, i.getNeuroglancerColor = se, i.closeSelectionTab = Pe, i.getLayerManager = ae, i.getManagedLayer = Ee, i.getAnnotationLayer = ce, i.getAnnotationSource = ge, i.addLayerSignalRemover = Ne, i.unsubscribeLayersChangedSignals = Me, i.configureLayersChangedSignals = je, i.configureAnnotationLayer = We, i.configureAnnotationLayerChanged = De, i.getAnnotationSelectionHost = et, i.getSelectedAnnotationId = $t, i.default = void 0;
    var t = v(import_react.default), n = v(vS()), r = K6, s = Y6, a = X6, l = Z6, d = R8, u = A8, h = _8, g = M8;
    function v(Z) {
      return Z && Z.__esModule ? Z : { default: Z };
    }
    function y(Z, ne) {
      var te = Object.keys(Z);
      if (Object.getOwnPropertySymbols) {
        var ve = Object.getOwnPropertySymbols(Z);
        ne && (ve = ve.filter(function(ke) {
          return Object.getOwnPropertyDescriptor(Z, ke).enumerable;
        })), te.push.apply(te, ve);
      }
      return te;
    }
    function C(Z) {
      for (var ne = 1; ne < arguments.length; ne++) {
        var te = arguments[ne] != null ? arguments[ne] : {};
        ne % 2 ? y(Object(te), true).forEach(function(ve) {
          O(Z, ve, te[ve]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Z, Object.getOwnPropertyDescriptors(te)) : y(Object(te)).forEach(function(ve) {
          Object.defineProperty(Z, ve, Object.getOwnPropertyDescriptor(te, ve));
        });
      }
      return Z;
    }
    function w(Z, ne) {
      if (!(Z instanceof ne))
        throw new TypeError("Cannot call a class as a function");
    }
    function b(Z, ne) {
      for (var te = 0; te < ne.length; te++) {
        var ve = ne[te];
        ve.enumerable = ve.enumerable || false, ve.configurable = true, "value" in ve && (ve.writable = true), Object.defineProperty(Z, ve.key, ve);
      }
    }
    function E(Z, ne, te) {
      return ne && b(Z.prototype, ne), Z;
    }
    function T(Z, ne) {
      if (typeof ne != "function" && ne !== null)
        throw new TypeError("Super expression must either be null or a function");
      Z.prototype = Object.create(ne && ne.prototype, { constructor: { value: Z, writable: true, configurable: true } }), ne && I(Z, ne);
    }
    function I(Z, ne) {
      return I = Object.setPrototypeOf || function(ve, ke) {
        return ve.__proto__ = ke, ve;
      }, I(Z, ne);
    }
    function R(Z) {
      var ne = A();
      return function() {
        var ve = M(Z), ke;
        if (ne) {
          var ye = M(this).constructor;
          ke = Reflect.construct(ve, arguments, ye);
        } else
          ke = ve.apply(this, arguments);
        return P(this, ke);
      };
    }
    function P(Z, ne) {
      return ne && (e(ne) === "object" || typeof ne == "function") ? ne : L(Z);
    }
    function L(Z) {
      if (Z === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return Z;
    }
    function A() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return false;
      if (typeof Proxy == "function") return true;
      try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        })), true;
      } catch {
        return false;
      }
    }
    function M(Z) {
      return M = Object.setPrototypeOf ? Object.getPrototypeOf : function(te) {
        return te.__proto__ || Object.getPrototypeOf(te);
      }, M(Z);
    }
    function O(Z, ne, te) {
      return ne in Z ? Object.defineProperty(Z, ne, { value: te, enumerable: true, configurable: true, writable: true }) : Z[ne] = te, Z;
    }
    function F(Z, ne) {
      var te;
      if (typeof Symbol > "u" || Z[Symbol.iterator] == null) {
        if (Array.isArray(Z) || (te = q(Z)) || ne) {
          te && (Z = te);
          var ve = 0, ke = function() {
          };
          return { s: ke, n: function() {
            return ve >= Z.length ? { done: true } : { done: false, value: Z[ve++] };
          }, e: function(gt) {
            throw gt;
          }, f: ke };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var ye = true, Je = false, it;
      return { s: function() {
        te = Z[Symbol.iterator]();
      }, n: function() {
        var gt = te.next();
        return ye = gt.done, gt;
      }, e: function(gt) {
        Je = true, it = gt;
      }, f: function() {
        try {
          !ye && te.return != null && te.return();
        } finally {
          if (Je) throw it;
        }
      } };
    }
    function q(Z, ne) {
      if (Z) {
        if (typeof Z == "string") return U(Z, ne);
        var te = Object.prototype.toString.call(Z).slice(8, -1);
        if (te === "Object" && Z.constructor && (te = Z.constructor.name), te === "Map" || te === "Set") return Array.from(Z);
        if (te === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(te)) return U(Z, ne);
      }
    }
    function U(Z, ne) {
      (ne == null || ne > Z.length) && (ne = Z.length);
      for (var te = 0, ve = new Array(ne); te < ne; te++)
        ve[te] = Z[te];
      return ve;
    }
    var V = {}, $;
    function B(Z) {
      var ne = null, te = Z.replace(/^[^#]+/, "");
      if ((te === "" || te === "#" || te === "#!") && (te = "#!{}"), te.startsWith("#!+"))
        te = te.slice(3), te = decodeURIComponent(te), ne = (0, h.urlSafeParse)(te);
      else if (te.startsWith("#!"))
        te = te.slice(2), te = decodeURIComponent(te), ne = (0, h.urlSafeParse)(te);
      else
        throw new Error('URL hash is expected to be of the form "#!{...}" or "#!+{...}".');
      return ne;
    }
    function ue(Z) {
      var ne = Z ? V[Z] : $;
      return ne ? ne.state.toJSON() : {};
    }
    function se(Z, ne) {
      try {
        var te = u.Uint64.parseString(Z), ve = ne ? V[ne] : $;
        if (ve) {
          var ke = F(ve.layerManager.managedLayers), ye;
          try {
            for (ke.s(); !(ye = ke.n()).done; ) {
              var Je = ye.value;
              if (Je.layer instanceof a.SegmentationUserLayer) {
                var it = Je.layer.displayState, pt = (0, s.getObjectColor)(it, te);
                if (it.segmentSelectionState.isSelected(te))
                  for (var gt = 0; gt < 3; gt += 1)
                    pt[gt] = (pt[gt] - 0.5) / 0.5;
                var ot = (0, l.serializeColor)(pt);
                return ot;
              }
            }
          } catch (Gt) {
            ke.e(Gt);
          } finally {
            ke.f();
          }
        }
      } catch {
      }
      return "";
    }
    function Pe(Z) {
      var ne = Z ? V[Z] : $;
      ne && ne.closeSelectionTab && ne.closeSelectionTab();
    }
    function ae(Z) {
      var ne = Z ? V[Z] : $;
      if (ne)
        return ne.layerManager;
    }
    function Ee(Z, ne) {
      var te = ae(Z);
      if (te)
        return te.managedLayers.filter(function(ve) {
          return ve.name === ne;
        })[0];
    }
    function ce(Z, ne) {
      var te = Ee(Z, ne);
      if (te && te.layer instanceof r.AnnotationUserLayer)
        return te.layer;
    }
    function ge(Z, ne) {
      var te = ce(Z, ne);
      if (te && te.dataSources && te.dataSources[0].loadState_) {
        var ve = te.dataSources[0].loadState_.dataSource;
        if (ve)
          return ve.subsources[0].subsource.annotation;
      }
    }
    function Ne(Z, ne, te) {
      var ve = ae(Z);
      ve && ne && te && (ve.customSignalHandlerRemovers || (ve.customSignalHandlerRemovers = {}), ve.customSignalHandlerRemovers[ne] || (ve.customSignalHandlerRemovers[ne] = []), ve.customSignalHandlerRemovers[ne].push(te));
    }
    function Me(Z, ne) {
      Z && Z.customSignalHandlerRemovers && Z.customSignalHandlerRemovers[ne] && (Z.customSignalHandlerRemovers[ne].forEach(function(te) {
        te();
      }), delete Z.customSignalHandlerRemovers[ne]);
    }
    function je(Z, ne) {
      var te = ae(Z);
      if (te) {
        var ve = ne.layerName;
        if (Me(te, ve), ne.process) {
          var ke = function(it) {
            return Ne(void 0, ve, it);
          };
          ke(te.layersChanged.add(function() {
            var Je = Ee(void 0, ve);
            Je && ne.process(Je);
          }));
          var ye = Ee(void 0, ve);
          return ye && ne.process(ye), function() {
            ne.cancel && ne.cancel(), Me(te, ve);
          };
        }
      }
      return ne.cancel;
    }
    function Oe(Z, ne, te) {
      Z && !Z.signalReady && (ne.onAnnotationAdded && te(Z.childAdded.add(function(ve) {
        ne.onAnnotationAdded(ve);
      })), ne.onAnnotationDeleted && te(Z.childDeleted.add(function(ve) {
        ne.onAnnotationDeleted(ve);
      })), ne.onAnnotationUpdated && te(Z.childUpdated.add(function(ve) {
        ne.onAnnotationUpdated(ve);
      })), ne.onAnnotationChanged && Z.referencesChanged && te(Z.referencesChanged.add(ne.onAnnotationChanged)), Z.signalReady = true, te(function() {
        Z.signalReady = false;
      }));
    }
    function Re(Z) {
      if (Z.dataSources && Z.dataSources.length > 0 && Z.dataSources[0].loadState_ && Z.dataSources[0].loadState_.dataSource)
        return Z.dataSources[0].loadState_.dataSource;
    }
    function Ve(Z) {
      var ne = Re(Z);
      if (ne)
        return ne.subsources[0].subsource.annotation;
    }
    function qe(Z, ne, te) {
      var ve = function() {
        var Je = Ve(Z);
        Je && Oe(Je, ne, te);
      }, ke = Z.dataSourcesChanged;
      ke && !ke.signalReady && (te(ke.add(ve)), ke.signalReady = true, te(function() {
        ke.signalReady = false;
      }), ve());
    }
    function We(Z, ne, te) {
      Z && (Z.expectingExternalTable = true, Z.selectedAnnotation && !Z.selectedAnnotation.changed.signalReady && ne.onAnnotationSelectionChanged && (te(Z.selectedAnnotation.changed.add(function() {
        ne.onAnnotationSelectionChanged(Z.selectedAnnotation.value);
      })), te(function() {
        Z.selectedAnnotation.changed.signalReady = false;
      }), Z.selectedAnnotation.changed.signalReady = true), qe(Z, ne, te));
    }
    function De(Z, ne, te) {
      if (!Z.layerChanged.signalReady) {
        var ve = Z.layerChanged.add(function() {
          We(Z.layer, ne, te);
        });
        Z.layerChanged.signalReady = true, te(ve), te(function() {
          Z.layerChanged.signalReady = false;
        }), We(Z.layer, ne, te);
      }
    }
    function et(Z) {
      var ne = Z ? V[Z] : $;
      return ne ? ne.selectionDetailsState ? "viewer" : "layer" : null;
    }
    function $t(Z, ne) {
      var te = Z ? V[Z] : $;
      if (te)
        if (te.selectionDetailsState) {
          if (te.selectionDetailsState.value) {
            var ve = te.selectionDetailsState.value.layers;
            if (ve) {
              var ke = ve.find(function(Je) {
                return Je.layer.managedLayer.name === ne;
              });
              if (ke && ke.state)
                return ke.state.annotationId;
            }
          }
        } else {
          var ye = ce(void 0, ne);
          if (ye && ye.selectedAnnotation && ye.selectedAnnotation.value)
            return ye.selectedAnnotation.value.id;
        }
      return null;
    }
    var At = function(Z) {
      T(te, Z);
      var ne = R(te);
      function te(ve) {
        var ke;
        return w(this, te), ke = ne.call(this, ve), O(L(ke), "updateEventBindings", function(ye) {
          var Je = ke.viewer.inputEventBindings, it = function pt(gt) {
            var ot = function(It, Wt, Ze) {
              var _t = It.get(Wt);
              _t && (It.delete(Wt), Ze && It.set(Ze, _t));
            }, Gt = gt.bindings;
            ye.forEach(function(mt) {
              var It = Array.isArray(mt) ? mt[0] : mt, Wt = "at:".concat(It), Ze = mt[1] ? "at:".concat(mt[1]) : void 0;
              ot(Gt, Wt, Ze);
              var _t = "bubble:".concat(It), Pt = mt[1] ? "bubble:".concat(mt[1]) : void 0;
              ot(Gt, _t, Pt);
            }), gt.parents.forEach(function(mt) {
              pt(mt);
            });
          };
          it(Je.global), it(Je.perspectiveView), it(Je.sliceView);
        }), O(L(ke), "selectionDetailsStateChanged", function() {
          if (ke.viewer) {
            var ye = ke.props.onSelectionDetailsStateChanged;
            ye && ye();
          }
        }), O(L(ke), "layersChanged", function() {
          if (ke.handlerRemovers && ke.handlerRemovers.forEach(function(Pt) {
            return Pt();
          }), ke.viewer) {
            var ye = ke.props, Je = ye.onSelectedChanged, it = ye.onVisibleChanged;
            if (Je || it) {
              ke.handlerRemovers = [];
              var pt = F(ke.viewer.layerManager.managedLayers), gt;
              try {
                for (pt.s(); !(gt = pt.n()).done; ) {
                  var ot = gt.value;
                  if (ot.layer instanceof a.SegmentationUserLayer) {
                    var Gt = ot.layer.displayState.segmentSelectionState, mt = ot.layer.displayState.segmentationGroupState.value.visibleSegments;
                    if (Gt && Je) {
                      var It = ke.selectedChanged.bind(void 0, ot), Wt = Gt.changed.add(It);
                      ke.handlerRemovers.push(Wt), ot.registerDisposer(Wt);
                    }
                    if (mt && it) {
                      var Ze = ke.visibleChanged.bind(void 0, ot), _t = mt.changed.add(Ze);
                      ke.handlerRemovers.push(_t), ot.registerDisposer(_t);
                    }
                  }
                }
              } catch (Pt) {
                pt.e(Pt);
              } finally {
                pt.f();
              }
            }
          }
        }), O(L(ke), "selectedChanged", function(ye) {
          if (ke.viewer) {
            var Je = ke.props.onSelectedChanged;
            if (Je) {
              var it = ye.layer.displayState.segmentSelectionState;
              if (it) {
                var pt = it.hasSelectedSegment ? it.selectedSegment : null;
                Je(pt, ye);
              }
            }
          }
        }), O(L(ke), "visibleChanged", function(ye) {
          if (ke.viewer) {
            var Je = ke.props.onVisibleChanged;
            if (Je) {
              var it = ye.layer.displayState.segmentationGroupState.value.visibleSegments;
              it && Je(it, ye);
            }
          }
        }), ke.ngContainer = t.default.createRef(), ke.viewer = null, ke;
      }
      return E(te, [{
        key: "componentDidMount",
        value: function() {
          var ke = this, ye = this.props, Je = ye.perspectiveZoom, it = ye.viewerState, pt = ye.brainMapsClientId, gt = ye.eventBindingsToUpdate, ot = ye.onViewerStateChanged, Gt = ye.callbacks, mt = ye.ngServer, It = ye.key, Wt = ye.bundleRoot;
          if (this.viewer = (0, d.setupDefaultViewer)({
            brainMapsClientId: pt,
            target: this.ngContainer.current,
            bundleRoot: Wt || "/"
          }), this.setCallbacks(Gt), gt && this.updateEventBindings(gt), this.viewer.expectingExternalUI = true, mt && (this.viewer.makeUrlFromState = function(_t) {
            var Pt = C({}, _t);
            return _t.layers && (Pt.layers = _t.layers.filter(function(ci) {
              if (ci.source) {
                var Hi = ci.source.url || ci.source;
                if (typeof Hi == "string")
                  return !Hi.startsWith("clio://");
              }
              return true;
            })), "".concat(mt, "/#!").concat((0, g.encodeFragment)(JSON.stringify(Pt)));
          }), this.viewer.selectionDetailsState && this.viewer.selectionDetailsState.changed.add(this.selectionDetailsStateChanged), this.viewer.layerManager.layersChanged.add(this.layersChanged), it) {
            var Ze = it;
            Ze.projectionScale === null && delete Ze.projectionScale, Ze.crossSectionScale === null && delete Ze.crossSectionScale, Ze.projectionOrientation === null && delete Ze.projectionOrientation, Ze.crossSectionOrientation === null && delete Ze.crossSectionOrientation, this.viewer.state.restoreState(Ze);
          } else
            this.viewer.state.restoreState({
              layers: {
                grayscale: {
                  type: "image",
                  source: "dvid://https://flyem.dvid.io/ab6e610d4fe140aba0e030645a1d7229/grayscalejpeg"
                },
                segmentation: {
                  type: "segmentation",
                  source: "dvid://https://flyem.dvid.io/d925633ed0974da78e2bb5cf38d01f4d/segmentation"
                }
              },
              perspectiveZoom: Je,
              navigation: {
                zoomFactor: 8
              }
            });
          this.viewer.state.changed.add(function() {
            if (ot)
              try {
                ke.viewer.state.viewer.position && ot(ke.viewer.state.toJSON());
              } catch (_t) {
                console.debug(_t);
              }
          }), It ? V[It] = this.viewer : $ = this.viewer, window.viewer = this.viewer;
        }
      }, {
        key: "componentDidUpdate",
        value: function() {
          var ke = this, ye = {}, Je = F(this.viewer.layerManager.managedLayers), it;
          try {
            for (Je.s(); !(it = Je.n()).done; ) {
              var pt = it.value;
              if (pt.layer instanceof a.SegmentationUserLayer) {
                var gt = pt.layer.displayState.segmentSelectionState;
                ye[pt.name] = gt.selectedSegment;
              }
            }
          } catch (Pt) {
            Je.e(Pt);
          } finally {
            Je.f();
          }
          var ot = this.props.viewerState;
          if (ot) {
            var Gt = C({}, ot), mt = [function() {
              ke.viewer.state.restoreState(Gt);
            }];
            ot.projectionScale === null && (delete Gt.projectionScale, mt.push(function() {
              ke.viewer.projectionScale.reset();
            })), ot.crossSectionScale === null && delete Gt.crossSectionScale, mt.forEach(function(Pt) {
              return Pt();
            });
          }
          var It = F(this.viewer.layerManager.managedLayers), Wt;
          try {
            for (It.s(); !(Wt = It.n()).done; ) {
              var Ze = Wt.value;
              if (Ze.layer instanceof a.SegmentationUserLayer) {
                var _t = Ze.layer.displayState.segmentSelectionState;
                _t.set(ye[Ze.name]);
              }
            }
          } catch (Pt) {
            It.e(Pt);
          } finally {
            It.f();
          }
          "position" in ot && Array.isArray(ot.position) && ot.position.length === 0 && this.viewer.position.reset();
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          var ke = this.props.key;
          ke ? delete V[ke] : $ = void 0;
        }
        /* setCallbacks allows us to set a callback on a neuroglancer event
         * each callback created should be in the format:
         * [
         *   {
         *     name: 'unique-name',
         *     event: 'the neuroglancer event to target, eg: click0, keyt',
         *     function: (slice) => { slice.whatever }
         *   },
         *   {...}
         * ]
         *
         */
      }, {
        key: "setCallbacks",
        value: function(ke) {
          var ye = this;
          ke.forEach(function(Je) {
            ye.viewer.bindCallback(Je.name, Je.function), ye.viewer.inputEventBindings.sliceView.set(Je.event, Je.name);
          });
        }
      }, {
        key: "render",
        value: function() {
          var ke = this.props.perspectiveZoom;
          return t.default.createElement("div", {
            className: "neuroglancer-container",
            ref: this.ngContainer
          }, t.default.createElement("p", null, "Neuroglancer here with zoom ", ke));
        }
      }]), te;
    }(t.default.Component);
    i.default = At, At.propTypes = {
      perspectiveZoom: n.default.number,
      viewerState: n.default.object,
      brainMapsClientId: n.default.string,
      key: n.default.string,
      /**
       * An array of event bindings to change in Neuroglancer.  The array format is as follows:
       * [[old-event1, new-event1], [old-event2], old-event3]
       * Here, `old-event1`'s will be unbound and its action will be re-bound to `new-event1`.
       * The bindings for `old-event2` and `old-event3` will be removed.
       * Neuroglancer has its own syntax for event descriptors, and here are some examples:
       * 'keya', 'shift+keyb' 'control+keyc', 'digit4', 'space', 'arrowleft', 'comma', 'period',
       * 'minus', 'equal', 'bracketleft'.
       */
      eventBindingsToUpdate: n.default.array,
      /**
       * A function of the form `(segment, layer) => {}`, called each time there is a change to
       * the segment the user has "selected" (i.e., hovered over) in Neuroglancer.
       * The `segment` argument will be a Neuroglancer `Uint64` with the ID of the now-selected
       * segment, or `null` if no segment is now selected.
       * The `layer` argument will be a Neuroglaner `ManagedUserLayer`, whose `layer` property
       * will be a Neuroglancer `SegmentationUserLayer`.
       */
      onSelectedChanged: n.default.func,
      /**
       * A function of the form `(segments, layer) => {}`, called each time there is a change to
       * the segments the user has designated as "visible" (i.e., double-clicked on) in Neuroglancer.
       * The `segments` argument will be a Neuroglancer `Uint64Set` whose elements are `Uint64`
       * instances for the IDs of the now-visible segments.
       * The `layer` argument will be a Neuroglaner `ManagedUserLayer`, whose `layer` property
       * will be a Neuroglancer `SegmentationUserLayer`.
       */
      onVisibleChanged: n.default.func,
      /**
       * A function of the form `() => {}` to respond to selection changes in the viewer.
       */
      onSelectionDetailsStateChanged: n.default.func,
      onViewerStateChanged: n.default.func,
      callbacks: n.default.arrayOf(n.default.object),
      ngServer: n.default.string
    }, At.defaultProps = {
      perspectiveZoom: 20,
      eventBindingsToUpdate: null,
      brainMapsClientId: "NOT_A_VALID_ID",
      viewerState: null,
      onSelectedChanged: null,
      onVisibleChanged: null,
      onSelectionDetailsStateChanged: null,
      onViewerStateChanged: null,
      key: null,
      callbacks: [],
      ngServer: "https://neuroglancer-demo.appspot.com/"
    };
  }(qf)), qf;
}
var MR = N8();
var O8 = Ws(MR);
var RJ = iM({
  __proto__: null,
  default: O8
}, [MR]);
export {
  RJ as i
};
/*! Bundled license information:

vitessce/dist/index-CGb9JHk9.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2018 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2017 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * /**
   * @license
   * This work is a derivative of the Google Neuroglancer project,
   * Copyright 2016 Google Inc.
   * The Derivative Work is covered by
   * Copyright 2021 Howard Hughes Medical Institute
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * This work is a derivative of the Google Neuroglancer project,
   * Copyright 2016 Google Inc.
   * The Derivative Work is covered by
   * Copyright 2019 Howard Hughes Medical Institute
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=index-CGb9JHk9-ZEDZCRUD.js.map
