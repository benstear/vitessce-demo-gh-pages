import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from 'react';
import { useId } from 'react-aria';
import { TableCell, TableRow, TextField, Slider } from '@vitessce/styles';
import { usePlotOptionsStyles, OptionsContainer, OptionSelect } from '@vitessce/vit-s';
import { GLSL_COLORMAPS } from '@vitessce/gl';
import { capitalize } from '@vitessce/utils';
const FEATURE_AGGREGATION_STRATEGIES = ['first', 'last', 'sum', 'mean'];
export default function CellSetExpressionPlotOptions(props) {
    const { featureValueTransform, setFeatureValueTransform, featureValueTransformCoefficient, setFeatureValueTransformCoefficient, transformOptions, featureValuePositivityThreshold, setFeatureValuePositivityThreshold, featureValueColormap, setFeatureValueColormap, featureAggregationStrategy, setFeatureAggregationStrategy, } = props;
    const cellSetExpressionPlotOptionsId = useId();
    const { classes } = usePlotOptionsStyles();
    function handleFeatureValueColormapChange(event) {
        setFeatureValueColormap(event.target.value);
    }
    function handleTransformChange(event) {
        setFeatureValueTransform(event.target.value === '' ? null : event.target.value);
    }
    function handleFeatureAggregationStrategyChange(event) {
        setFeatureAggregationStrategy(event.target.value);
    }
    function handlePositivityThresholdChange(event, value) {
        setFeatureValuePositivityThreshold(value);
    }
    // Feels a little hacky, but I think this is the best way to handle
    // the limitations of the v4 material-ui number input.
    const handleTransformCoefficientChange = (event) => {
        const { value } = event.target;
        if (!value) {
            setFeatureValueTransformCoefficient(value);
        }
        else {
            const newCoefficient = Number(value);
            if (!Number.isNaN(newCoefficient) && newCoefficient >= 0) {
                setFeatureValueTransformCoefficient(value);
            }
        }
    };
    return (_jsxs(OptionsContainer, { children: [setFeatureValueColormap ? (_jsxs(TableRow, { children: [_jsx(TableCell, { className: classes.labelCell, variant: "head", scope: "row", children: _jsx("label", { htmlFor: `cellset-expression-feature-value-colormap-${cellSetExpressionPlotOptionsId}`, children: "Feature Value Colormap" }) }), _jsx(TableCell, { className: classes.inputCell, variant: "body", children: _jsx(OptionSelect, { className: classes.select, value: featureValueColormap, onChange: handleFeatureValueColormapChange, inputProps: {
                                'aria-label': 'Select feature value colormap',
                                id: `cellset-expression-feature-value-colormap-${cellSetExpressionPlotOptionsId}`,
                            }, children: GLSL_COLORMAPS.map(cmap => (_jsx("option", { value: cmap, children: cmap }, cmap))) }) })] })) : null, _jsxs(TableRow, { children: [_jsx(TableCell, { className: classes.labelCell, variant: "head", scope: "row", children: _jsx("label", { htmlFor: `cellset-expression-transform-select-${cellSetExpressionPlotOptionsId}`, children: "Transform" }) }), _jsx(TableCell, { className: classes.inputCell, variant: "body", children: _jsx(OptionSelect, { className: classes.select, value: featureValueTransform === null ? '' : featureValueTransform, onChange: handleTransformChange, inputProps: {
                                id: `cellset-expression-transform-select-${cellSetExpressionPlotOptionsId}`,
                            }, children: transformOptions.map(opt => (_jsx("option", { value: opt.value === null ? '' : opt.value, children: opt.name }, opt.name))) }) })] }), _jsxs(TableRow, { children: [_jsx(TableCell, { className: classes.labelCell, variant: "head", scope: "row", children: _jsx("label", { htmlFor: `cellset-expression-transform-coeff-${cellSetExpressionPlotOptionsId}`, children: "Transform Coefficient" }) }), _jsx(TableCell, { className: classes.inputCell, variant: "body", children: _jsx(TextField, { label: "Transform Coefficient", type: "number", onChange: handleTransformCoefficientChange, value: featureValueTransformCoefficient, slotProps: { input: { shrink: true } }, id: `cellset-expression-transform-coeff-${cellSetExpressionPlotOptionsId}` }) })] }), setFeatureAggregationStrategy ? (_jsxs(TableRow, { children: [_jsx(TableCell, { className: classes.labelCell, variant: "head", scope: "row", children: _jsx("label", { htmlFor: `feature-aggregation-strategy-${cellSetExpressionPlotOptionsId}`, children: "Feature Aggregation Strategy" }) }), _jsx(TableCell, { className: classes.inputCell, variant: "body", children: _jsx(OptionSelect, { className: classes.select, value: featureAggregationStrategy ?? 'first', onChange: handleFeatureAggregationStrategyChange, inputProps: {
                                id: `feature-aggregation-strategy-${cellSetExpressionPlotOptionsId}`,
                            }, children: FEATURE_AGGREGATION_STRATEGIES.map(opt => (_jsx("option", { value: opt, children: capitalize(opt) }, opt))) }) })] })) : null, setFeatureValuePositivityThreshold ? (_jsxs(TableRow, { children: [_jsx(TableCell, { className: classes.labelCell, children: "Positivity Threshold" }), _jsx(TableCell, { className: classes.inputCell, children: _jsx(Slider, { slotProps: {
                                root: { className: classes.slider },
                                valueLabel: { className: classes.sliderValueLabel },
                            }, value: featureValuePositivityThreshold, onChange: handlePositivityThresholdChange, "aria-labelledby": "pos-threshold-slider", valueLabelDisplay: "auto", step: 1.0, min: 0.0, max: 100.0 }) })] }, "transform-coefficient-option-row")) : null] }));
}
