import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React, { useRef, useEffect } from 'react';
import { Grid, Button, TextField, Typography, Add as AddIcon, Info as InfoIcon, Autocomplete } from '@vitessce/styles';
import { VariableSizeList } from 'react-window';
import { useStyles } from './styles.js';
const LIST_ROW_HEIGHT = 48;
// We use a context to pass the extra props from ListboxComponent to the outer div element.
const OuterElementContext = React.createContext({});
const OuterElementType = React.forwardRef((props, ref) => {
    const outerProps = React.useContext(OuterElementContext);
    return _jsx("div", { ref: ref, ...props, ...outerProps });
});
function ListRow(props) {
    const { data, index, style } = props;
    const dataSet = data[index];
    const inlineStyle = {
        ...style,
        top: style.top + 8,
    };
    // This array is created by the renderOption function in the Autocomplete component.
    const [props0, option] = dataSet;
    const { key, ...optionProps } = props0;
    return (_jsxs(Typography, { component: "li", ...optionProps, noWrap: true, style: inlineStyle, children: [option.label, " (", option.nodeType, ")"] }, key));
}
function useResetCache(itemCount) {
    const ref = useRef(null);
    useEffect(() => {
        if (ref.current != null) {
            ref.current.resetAfterIndex(0, true);
        }
    }, [itemCount]);
    return ref;
}
// Reference: https://mui.com/material-ui/react-autocomplete/#virtualization
const ListboxComponent = React.forwardRef((props, ref) => {
    const { children, ...other } = props;
    const itemCount = children.length;
    const gridRef = useResetCache(itemCount);
    return (_jsx("div", { ref: ref, children: _jsx(OuterElementContext.Provider, { value: other, children: _jsx(VariableSizeList, { height: Math.min(8, itemCount) * LIST_ROW_HEIGHT, itemSize: () => LIST_ROW_HEIGHT, width: "100%", innerElementType: "ul", outerElementType: OuterElementType, overscanCount: 5, ref: gridRef, itemCount: itemCount, itemData: children, children: ListRow }) }) }));
});
export function SelectAgnostic(props) {
    const { autocompleteNode, currentModalityAgnosticSelection, setCurrentModalityAgnosticSelection, } = props;
    const { classes } = useStyles();
    const [selectedItem, setSelectedItem] = React.useState(null);
    const [potentialItems, setPotentialItems] = React.useState([]);
    const handleChange = async (event) => {
        const { value } = event.target;
        if (!value) {
            return;
        }
        const autocompleteResult = await autocompleteNode(value);
        setPotentialItems(autocompleteResult);
    };
    function confirmSelectedItem() {
        // eslint-disable-next-line max-len
        if (selectedItem && !currentModalityAgnosticSelection?.find(item => item.kgId === selectedItem?.kgId)) {
            setCurrentModalityAgnosticSelection([
                ...(currentModalityAgnosticSelection || []),
                selectedItem,
            ]);
        }
    }
    return (_jsxs(_Fragment, { children: [_jsx(Grid, { container: true, size: 12, children: _jsx(Typography, { variant: "h6", children: "Search by gene, protein, pathway (by term name), or cell type:" }) }), _jsxs(Grid, { container: true, size: 12, children: [_jsx(Grid, { size: 4, children: _jsx(Autocomplete, { options: potentialItems, autoComplete: true, includeInputInList: true, onInputChange: handleChange, onChange: (event, item) => setSelectedItem(item), classes: { input: classes.searchInput }, renderInput: params => (_jsx(TextField, { label: "Search", variant: "outlined", onChange: handleChange, ...params })), getOptionLabel: option => option.label, renderOption: (props0, option, state) => ([props0, option, state.index]), slotProps: {
                                listbox: {
                                    component: ListboxComponent,
                                },
                            } }) }), _jsx(Grid, { size: 8, style: {
                            border: selectedItem ? '1px solid gray' : '1px solid transparent',
                            borderRadius: '4px',
                        }, children: selectedItem ? (_jsxs(_Fragment, { children: [_jsxs(Grid, { container: true, size: 12, children: [_jsx(Grid, { size: 9, children: _jsx(Typography, { variant: "h4", title: selectedItem.term, children: selectedItem.label }) }), _jsx(Grid, { size: 3, sx: { position: 'relative' }, children: _jsx(Button, { className: classes.selectButton, variant: "contained", startIcon: _jsx(AddIcon, {}), onClick: confirmSelectedItem, children: "Select" }) })] }), _jsxs(Grid, { container: true, size: 12, children: [_jsx(InfoIcon, {}), _jsxs(Typography, { variant: "h6", children: ["About this ", selectedItem.nodeType] })] }), _jsx(Grid, { container: true, size: 12, children: _jsx("iframe", { title: `Embedded metadata page for ontology term ${selectedItem.term}`, src: `https://identifiers.org/${selectedItem.term}`, width: "100%", height: "500", style: { border: 0 } }) }, selectedItem.term)] })) : null })] })] }));
}
