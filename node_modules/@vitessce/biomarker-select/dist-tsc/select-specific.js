import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React, { useMemo } from 'react';
import { useQueries } from '@tanstack/react-query';
import { Grid, FormHelperText, Typography, NativeSelect, FormControl, DataGrid } from '@vitessce/styles';
import { useStyles } from './styles.js';
const columns = [
    {
        field: 'targetLabel',
        headerName: 'Gene symbol',
        width: 200,
        editable: false,
    },
    {
        field: 'sourceRelationship',
        headerName: 'Relationship to modality-agnostic selections',
        width: 400,
        editable: false,
    },
];
const initialState = {
    pagination: {
        paginationModel: {
            pageSize: 10,
        },
    },
};
const pageSizeOptions = [10];
export function SelectSpecific(props) {
    const { currentModalityAgnosticSelection, currentModalitySpecificSelection, setCurrentModalitySpecificSelection, getEdges, } = props;
    const { classes } = useStyles();
    const queries = useQueries({
        queries: currentModalityAgnosticSelection?.map(item => ({
            queryKey: [item.nodeType, item.kgId],
            queryFn: async () => {
                const matchingGenes = await getEdges(item, 'gene');
                return matchingGenes.map(d => ({ target: d, source: item }));
            },
        })) || [],
    });
    const anyLoading = queries.some(q => q.isFetching);
    const anyError = queries.some(q => q.isError);
    // eslint-disable-next-line no-nested-ternary
    const dataStatus = anyLoading ? 'loading' : (anyError ? 'error' : 'success');
    const data = queries
        .flatMap(q => q.data)
        .filter(Boolean);
    const rows = useMemo(() => data.map(d => ({
        id: d.target.kgId,
        targetLabel: d.target.label,
        sourceRelationship: (d.source.nodeType === 'gene'
            ? 'Directly-selected gene'
            : `Member of ${d.source.label} ${d.source.nodeType}`),
        // eslint-disable-next-line react-hooks/exhaustive-deps
    })), [currentModalityAgnosticSelection, dataStatus]);
    // Derive the set of selected row ids from the
    // currentModalitySpecificSelection.
    const rowSelectionModel = useMemo(() => ({
        ids: new Set(currentModalitySpecificSelection?.map(d => d.kgId) || []),
        type: 'include',
    }), [rows, currentModalitySpecificSelection]);
    function handleSelection(newRowSelectionModel) {
        const newSelection = Array.from(newRowSelectionModel.ids)
            .map(kgId => data.find(d => d.target.kgId === kgId)?.target)
            .filter(Boolean);
        setCurrentModalitySpecificSelection(newSelection);
    }
    return (_jsxs(_Fragment, { children: [_jsx(Grid, { size: 6, children: _jsx(Typography, { variant: "h6", children: "Select a feature type:" }) }), _jsx(Grid, { container: true, size: 6, children: _jsx(Grid, { children: _jsxs(FormControl, { fullWidth: true, children: [_jsx(NativeSelect, { defaultValue: "gene", classes: { select: classes.selectInput }, inputProps: {
                                    name: 'age',
                                    id: 'uncontrolled-native',
                                }, children: _jsx("option", { value: "gene", children: "Gene (RNA-seq)" }) }), _jsx(FormHelperText, { children: "Feature type (experimental modality)" })] }) }) }), _jsx(Grid, { container: true, size: 12, sx: { height: '450px' }, children: _jsx(DataGrid, { rows: rows, columns: columns, initialState: initialState, pageSizeOptions: pageSizeOptions, checkboxSelection: true, onRowSelectionModelChange: handleSelection, rowSelectionModel: rowSelectionModel }) })] }));
}
