import { g as getDefaultExportFromCjs, aV as requireAssign, aW as require_export, aX as require_core, aY as require_fails, aZ as require_toObject, a_ as require_objectKeys, a$ as require_cof, b0 as require_wks, b1 as require_iterators, b2 as requireWeb_dom_iterable, b3 as requireEs6_string_iterator, b4 as require_anObject, b5 as require_hide, b6 as require_ctx, b7 as require_toLength, b8 as require_global, b9 as require_objectDp, ba as require_descriptors, bb as require_isObject, bc as require_objectCreate, bd as require_iterDefine, be as require_iterStep, bf as require_meta, bg as require_isArray, bh as require_iobject, bi as require_setToStringTag, bj as require_aFunction, bk as requireIterator, bl as require_propertyDesc, aS as commonjsGlobal, bm as requireEs6_symbol, bn as requireDefineProperty, bo as require_toIobject, bp as require_objectGopd, bq as require_html, br as require_domCreate, bs as require_library, bt as requireSymbol, bu as require_objectPie, bv as require_has, bw as require_redefine, bx as require_objectAssign, by as getAugmentedNamespace, bz as requirePropTypes } from "./index-CCplcSNt.js";
import React__default from "react";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var lib = {};
var assignExports = requireAssign();
const _Object$assign = /* @__PURE__ */ getDefaultExportFromCjs(assignExports);
var es6_object_keys = {};
var _objectSap;
var hasRequired_objectSap;
function require_objectSap() {
  if (hasRequired_objectSap) return _objectSap;
  hasRequired_objectSap = 1;
  var $export = require_export();
  var core = require_core();
  var fails = require_fails();
  _objectSap = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), "Object", exp);
  };
  return _objectSap;
}
var hasRequiredEs6_object_keys;
function requireEs6_object_keys() {
  if (hasRequiredEs6_object_keys) return es6_object_keys;
  hasRequiredEs6_object_keys = 1;
  var toObject = require_toObject();
  var $keys = require_objectKeys();
  require_objectSap()("keys", function() {
    return function keys2(it) {
      return $keys(toObject(it));
    };
  });
  return es6_object_keys;
}
var keys$1;
var hasRequiredKeys$1;
function requireKeys$1() {
  if (hasRequiredKeys$1) return keys$1;
  hasRequiredKeys$1 = 1;
  requireEs6_object_keys();
  keys$1 = require_core().Object.keys;
  return keys$1;
}
var keys;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys;
  hasRequiredKeys = 1;
  keys = { "default": requireKeys$1(), __esModule: true };
  return keys;
}
var keysExports = requireKeys();
const _Object$keys = /* @__PURE__ */ getDefaultExportFromCjs(keysExports);
var slicedToArray = {};
var _classof;
var hasRequired_classof;
function require_classof() {
  if (hasRequired_classof) return _classof;
  hasRequired_classof = 1;
  var cof = require_cof();
  var TAG = require_wks()("toStringTag");
  var ARG = cof(/* @__PURE__ */ function() {
    return arguments;
  }()) == "Arguments";
  var tryGet = function(it, key) {
    try {
      return it[key];
    } catch (e) {
    }
  };
  _classof = function(it) {
    var O, T, B;
    return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
  };
  return _classof;
}
var core_isIterable;
var hasRequiredCore_isIterable;
function requireCore_isIterable() {
  if (hasRequiredCore_isIterable) return core_isIterable;
  hasRequiredCore_isIterable = 1;
  var classof = require_classof();
  var ITERATOR = require_wks()("iterator");
  var Iterators = require_iterators();
  core_isIterable = require_core().isIterable = function(it) {
    var O = Object(it);
    return O[ITERATOR] !== void 0 || "@@iterator" in O || Iterators.hasOwnProperty(classof(O));
  };
  return core_isIterable;
}
var isIterable$1;
var hasRequiredIsIterable$1;
function requireIsIterable$1() {
  if (hasRequiredIsIterable$1) return isIterable$1;
  hasRequiredIsIterable$1 = 1;
  requireWeb_dom_iterable();
  requireEs6_string_iterator();
  isIterable$1 = requireCore_isIterable();
  return isIterable$1;
}
var isIterable;
var hasRequiredIsIterable;
function requireIsIterable() {
  if (hasRequiredIsIterable) return isIterable;
  hasRequiredIsIterable = 1;
  isIterable = { "default": requireIsIterable$1(), __esModule: true };
  return isIterable;
}
var core_getIteratorMethod;
var hasRequiredCore_getIteratorMethod;
function requireCore_getIteratorMethod() {
  if (hasRequiredCore_getIteratorMethod) return core_getIteratorMethod;
  hasRequiredCore_getIteratorMethod = 1;
  var classof = require_classof();
  var ITERATOR = require_wks()("iterator");
  var Iterators = require_iterators();
  core_getIteratorMethod = require_core().getIteratorMethod = function(it) {
    if (it != void 0) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
  };
  return core_getIteratorMethod;
}
var core_getIterator;
var hasRequiredCore_getIterator;
function requireCore_getIterator() {
  if (hasRequiredCore_getIterator) return core_getIterator;
  hasRequiredCore_getIterator = 1;
  var anObject = require_anObject();
  var get = requireCore_getIteratorMethod();
  core_getIterator = require_core().getIterator = function(it) {
    var iterFn = get(it);
    if (typeof iterFn != "function") throw TypeError(it + " is not iterable!");
    return anObject(iterFn.call(it));
  };
  return core_getIterator;
}
var getIterator$1;
var hasRequiredGetIterator$1;
function requireGetIterator$1() {
  if (hasRequiredGetIterator$1) return getIterator$1;
  hasRequiredGetIterator$1 = 1;
  requireWeb_dom_iterable();
  requireEs6_string_iterator();
  getIterator$1 = requireCore_getIterator();
  return getIterator$1;
}
var getIterator;
var hasRequiredGetIterator;
function requireGetIterator() {
  if (hasRequiredGetIterator) return getIterator;
  hasRequiredGetIterator = 1;
  getIterator = { "default": requireGetIterator$1(), __esModule: true };
  return getIterator;
}
var hasRequiredSlicedToArray;
function requireSlicedToArray() {
  if (hasRequiredSlicedToArray) return slicedToArray;
  hasRequiredSlicedToArray = 1;
  slicedToArray.__esModule = true;
  var _isIterable2 = requireIsIterable();
  var _isIterable3 = _interopRequireDefault(_isIterable2);
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  slicedToArray.default = /* @__PURE__ */ function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if ((0, _isIterable3.default)(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  return slicedToArray;
}
var slicedToArrayExports = requireSlicedToArray();
const _slicedToArray = /* @__PURE__ */ getDefaultExportFromCjs(slicedToArrayExports);
var _redefineAll;
var hasRequired_redefineAll;
function require_redefineAll() {
  if (hasRequired_redefineAll) return _redefineAll;
  hasRequired_redefineAll = 1;
  var hide = require_hide();
  _redefineAll = function(target, src, safe) {
    for (var key in src) {
      if (safe && target[key]) target[key] = src[key];
      else hide(target, key, src[key]);
    }
    return target;
  };
  return _redefineAll;
}
var _anInstance;
var hasRequired_anInstance;
function require_anInstance() {
  if (hasRequired_anInstance) return _anInstance;
  hasRequired_anInstance = 1;
  _anInstance = function(it, Constructor, name2, forbiddenField) {
    if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) {
      throw TypeError(name2 + ": incorrect invocation!");
    }
    return it;
  };
  return _anInstance;
}
var _forOf = { exports: {} };
var _iterCall;
var hasRequired_iterCall;
function require_iterCall() {
  if (hasRequired_iterCall) return _iterCall;
  hasRequired_iterCall = 1;
  var anObject = require_anObject();
  _iterCall = function(iterator, fn, value, entries2) {
    try {
      return entries2 ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator["return"];
      if (ret !== void 0) anObject(ret.call(iterator));
      throw e;
    }
  };
  return _iterCall;
}
var _isArrayIter;
var hasRequired_isArrayIter;
function require_isArrayIter() {
  if (hasRequired_isArrayIter) return _isArrayIter;
  hasRequired_isArrayIter = 1;
  var Iterators = require_iterators();
  var ITERATOR = require_wks()("iterator");
  var ArrayProto = Array.prototype;
  _isArrayIter = function(it) {
    return it !== void 0 && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  return _isArrayIter;
}
var hasRequired_forOf;
function require_forOf() {
  if (hasRequired_forOf) return _forOf.exports;
  hasRequired_forOf = 1;
  var ctx = require_ctx();
  var call = require_iterCall();
  var isArrayIter = require_isArrayIter();
  var anObject = require_anObject();
  var toLength = require_toLength();
  var getIterFn = requireCore_getIteratorMethod();
  var BREAK = {};
  var RETURN = {};
  var exports = _forOf.exports = function(iterable, entries2, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function() {
      return iterable;
    } : getIterFn(iterable);
    var f = ctx(fn, that, entries2 ? 2 : 1);
    var index2 = 0;
    var length2, step, iterator, result;
    if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
    if (isArrayIter(iterFn)) for (length2 = toLength(iterable.length); length2 > index2; index2++) {
      result = entries2 ? f(anObject(step = iterable[index2])[0], step[1]) : f(iterable[index2]);
      if (result === BREAK || result === RETURN) return result;
    }
    else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
      result = call(iterator, f, step.value, entries2);
      if (result === BREAK || result === RETURN) return result;
    }
  };
  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
  return _forOf.exports;
}
var _setSpecies;
var hasRequired_setSpecies;
function require_setSpecies() {
  if (hasRequired_setSpecies) return _setSpecies;
  hasRequired_setSpecies = 1;
  var global = require_global();
  var core = require_core();
  var dP = require_objectDp();
  var DESCRIPTORS = require_descriptors();
  var SPECIES = require_wks()("species");
  _setSpecies = function(KEY) {
    var C = typeof core[KEY] == "function" ? core[KEY] : global[KEY];
    if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  };
  return _setSpecies;
}
var _validateCollection;
var hasRequired_validateCollection;
function require_validateCollection() {
  if (hasRequired_validateCollection) return _validateCollection;
  hasRequired_validateCollection = 1;
  var isObject = require_isObject();
  _validateCollection = function(it, TYPE) {
    if (!isObject(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
    return it;
  };
  return _validateCollection;
}
var _collectionStrong;
var hasRequired_collectionStrong;
function require_collectionStrong() {
  if (hasRequired_collectionStrong) return _collectionStrong;
  hasRequired_collectionStrong = 1;
  var dP = require_objectDp().f;
  var create2 = require_objectCreate();
  var redefineAll = require_redefineAll();
  var ctx = require_ctx();
  var anInstance = require_anInstance();
  var forOf = require_forOf();
  var $iterDefine = require_iterDefine();
  var step = require_iterStep();
  var setSpecies = require_setSpecies();
  var DESCRIPTORS = require_descriptors();
  var fastKey = require_meta().fastKey;
  var validate = require_validateCollection();
  var SIZE = DESCRIPTORS ? "_s" : "size";
  var getEntry = function(that, key) {
    var index2 = fastKey(key);
    var entry;
    if (index2 !== "F") return that._i[index2];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };
  _collectionStrong = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        anInstance(that, C, NAME, "_i");
        that._t = NAME;
        that._i = create2(null);
        that._f = void 0;
        that._l = void 0;
        that[SIZE] = 0;
        if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        // 23.1.3.1 Map.prototype.clear()
        // 23.2.3.2 Set.prototype.clear()
        clear: function clear() {
          for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = void 0;
            delete data[entry.i];
          }
          that._f = that._l = void 0;
          that[SIZE] = 0;
        },
        // 23.1.3.3 Map.prototype.delete(key)
        // 23.2.3.4 Set.prototype.delete(value)
        "delete": function(key) {
          var that = validate(this, NAME);
          var entry = getEntry(that, key);
          if (entry) {
            var next = entry.n;
            var prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
        // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
        forEach: function forEach(callbackfn) {
          validate(this, NAME);
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3);
          var entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r) entry = entry.p;
          }
        },
        // 23.1.3.7 Map.prototype.has(key)
        // 23.2.3.7 Set.prototype.has(value)
        has: function has(key) {
          return !!getEntry(validate(this, NAME), key);
        }
      });
      if (DESCRIPTORS) dP(C.prototype, "size", {
        get: function() {
          return validate(this, NAME)[SIZE];
        }
      });
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key);
      var prev, index2;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index2 = fastKey(key, true),
          // <- index
          k: key,
          // <- key
          v: value,
          // <- value
          p: prev = that._l,
          // <- previous entry
          n: void 0,
          // <- next entry
          r: false
          // <- removed
        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++;
        if (index2 !== "F") that._i[index2] = entry;
      }
      return that;
    },
    getEntry,
    setStrong: function(C, NAME, IS_MAP) {
      $iterDefine(C, NAME, function(iterated, kind) {
        this._t = validate(iterated, NAME);
        this._k = kind;
        this._l = void 0;
      }, function() {
        var that = this;
        var kind = that._k;
        var entry = that._l;
        while (entry && entry.r) entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = void 0;
          return step(1);
        }
        if (kind == "keys") return step(0, entry.k);
        if (kind == "values") return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? "entries" : "values", !IS_MAP, true);
      setSpecies(NAME);
    }
  };
  return _collectionStrong;
}
var _arraySpeciesConstructor;
var hasRequired_arraySpeciesConstructor;
function require_arraySpeciesConstructor() {
  if (hasRequired_arraySpeciesConstructor) return _arraySpeciesConstructor;
  hasRequired_arraySpeciesConstructor = 1;
  var isObject = require_isObject();
  var isArray = require_isArray();
  var SPECIES = require_wks()("species");
  _arraySpeciesConstructor = function(original) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      if (typeof C == "function" && (C === Array || isArray(C.prototype))) C = void 0;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = void 0;
      }
    }
    return C === void 0 ? Array : C;
  };
  return _arraySpeciesConstructor;
}
var _arraySpeciesCreate;
var hasRequired_arraySpeciesCreate;
function require_arraySpeciesCreate() {
  if (hasRequired_arraySpeciesCreate) return _arraySpeciesCreate;
  hasRequired_arraySpeciesCreate = 1;
  var speciesConstructor = require_arraySpeciesConstructor();
  _arraySpeciesCreate = function(original, length2) {
    return new (speciesConstructor(original))(length2);
  };
  return _arraySpeciesCreate;
}
var _arrayMethods;
var hasRequired_arrayMethods;
function require_arrayMethods() {
  if (hasRequired_arrayMethods) return _arrayMethods;
  hasRequired_arrayMethods = 1;
  var ctx = require_ctx();
  var IObject = require_iobject();
  var toObject = require_toObject();
  var toLength = require_toLength();
  var asc = require_arraySpeciesCreate();
  _arrayMethods = function(TYPE, $create) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    var create2 = $create || asc;
    return function($this, callbackfn, that) {
      var O = toObject($this);
      var self2 = IObject(O);
      var f = ctx(callbackfn, that, 3);
      var length2 = toLength(self2.length);
      var index2 = 0;
      var result = IS_MAP ? create2($this, length2) : IS_FILTER ? create2($this, 0) : void 0;
      var val, res;
      for (; length2 > index2; index2++) if (NO_HOLES || index2 in self2) {
        val = self2[index2];
        res = f(val, index2, O);
        if (TYPE) {
          if (IS_MAP) result[index2] = res;
          else if (res) switch (TYPE) {
            case 3:
              return true;
            // some
            case 5:
              return val;
            // find
            case 6:
              return index2;
            // findIndex
            case 2:
              result.push(val);
          }
          else if (IS_EVERY) return false;
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  return _arrayMethods;
}
var _collection;
var hasRequired_collection;
function require_collection() {
  if (hasRequired_collection) return _collection;
  hasRequired_collection = 1;
  var global = require_global();
  var $export = require_export();
  var meta = require_meta();
  var fails = require_fails();
  var hide = require_hide();
  var redefineAll = require_redefineAll();
  var forOf = require_forOf();
  var anInstance = require_anInstance();
  var isObject = require_isObject();
  var setToStringTag = require_setToStringTag();
  var dP = require_objectDp().f;
  var each = require_arrayMethods()(0);
  var DESCRIPTORS = require_descriptors();
  _collection = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base2 = global[NAME];
    var C = Base2;
    var ADDER = IS_MAP ? "set" : "add";
    var proto = C && C.prototype;
    var O = {};
    if (!DESCRIPTORS || typeof C != "function" || !(IS_WEAK || proto.forEach && !fails(function() {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
      meta.NEED = true;
    } else {
      C = wrapper(function(target, iterable) {
        anInstance(target, C, NAME, "_c");
        target._c = new Base2();
        if (iterable != void 0) forOf(iterable, IS_MAP, target[ADDER], target);
      });
      each("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(KEY) {
        var IS_ADDER = KEY == "add" || KEY == "set";
        if (KEY in proto && !(IS_WEAK && KEY == "clear")) hide(C.prototype, KEY, function(a, b) {
          anInstance(this, C, KEY);
          if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == "get" ? void 0 : false;
          var result = this._c[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      });
      IS_WEAK || dP(C.prototype, "size", {
        get: function() {
          return this._c.size;
        }
      });
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  return _collection;
}
var es6_map;
var hasRequiredEs6_map;
function requireEs6_map() {
  if (hasRequiredEs6_map) return es6_map;
  hasRequiredEs6_map = 1;
  var strong = require_collectionStrong();
  var validate = require_validateCollection();
  var MAP = "Map";
  es6_map = require_collection()(MAP, function(get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : void 0);
    };
  }, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function get(key) {
      var entry = strong.getEntry(validate(this, MAP), key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function set2(key, value) {
      return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
    }
  }, strong, true);
  return es6_map;
}
var es7_map_toJson = {};
var _arrayFromIterable;
var hasRequired_arrayFromIterable;
function require_arrayFromIterable() {
  if (hasRequired_arrayFromIterable) return _arrayFromIterable;
  hasRequired_arrayFromIterable = 1;
  var forOf = require_forOf();
  _arrayFromIterable = function(iter, ITERATOR) {
    var result = [];
    forOf(iter, false, result.push, result, ITERATOR);
    return result;
  };
  return _arrayFromIterable;
}
var _collectionToJson;
var hasRequired_collectionToJson;
function require_collectionToJson() {
  if (hasRequired_collectionToJson) return _collectionToJson;
  hasRequired_collectionToJson = 1;
  var classof = require_classof();
  var from2 = require_arrayFromIterable();
  _collectionToJson = function(NAME) {
    return function toJSON() {
      if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
      return from2(this);
    };
  };
  return _collectionToJson;
}
var hasRequiredEs7_map_toJson;
function requireEs7_map_toJson() {
  if (hasRequiredEs7_map_toJson) return es7_map_toJson;
  hasRequiredEs7_map_toJson = 1;
  var $export = require_export();
  $export($export.P + $export.R, "Map", { toJSON: require_collectionToJson()("Map") });
  return es7_map_toJson;
}
var es7_map_of = {};
var _setCollectionOf;
var hasRequired_setCollectionOf;
function require_setCollectionOf() {
  if (hasRequired_setCollectionOf) return _setCollectionOf;
  hasRequired_setCollectionOf = 1;
  var $export = require_export();
  _setCollectionOf = function(COLLECTION) {
    $export($export.S, COLLECTION, { of: function of() {
      var length2 = arguments.length;
      var A = new Array(length2);
      while (length2--) A[length2] = arguments[length2];
      return new this(A);
    } });
  };
  return _setCollectionOf;
}
var hasRequiredEs7_map_of;
function requireEs7_map_of() {
  if (hasRequiredEs7_map_of) return es7_map_of;
  hasRequiredEs7_map_of = 1;
  require_setCollectionOf()("Map");
  return es7_map_of;
}
var es7_map_from = {};
var _setCollectionFrom;
var hasRequired_setCollectionFrom;
function require_setCollectionFrom() {
  if (hasRequired_setCollectionFrom) return _setCollectionFrom;
  hasRequired_setCollectionFrom = 1;
  var $export = require_export();
  var aFunction = require_aFunction();
  var ctx = require_ctx();
  var forOf = require_forOf();
  _setCollectionFrom = function(COLLECTION) {
    $export($export.S, COLLECTION, { from: function from2(source) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      aFunction(this);
      mapping = mapFn !== void 0;
      if (mapping) aFunction(mapFn);
      if (source == void 0) return new this();
      A = [];
      if (mapping) {
        n = 0;
        cb = ctx(mapFn, arguments[2], 2);
        forOf(source, false, function(nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        forOf(source, false, A.push, A);
      }
      return new this(A);
    } });
  };
  return _setCollectionFrom;
}
var hasRequiredEs7_map_from;
function requireEs7_map_from() {
  if (hasRequiredEs7_map_from) return es7_map_from;
  hasRequiredEs7_map_from = 1;
  require_setCollectionFrom()("Map");
  return es7_map_from;
}
var map$1;
var hasRequiredMap$1;
function requireMap$1() {
  if (hasRequiredMap$1) return map$1;
  hasRequiredMap$1 = 1;
  requireEs6_string_iterator();
  requireWeb_dom_iterable();
  requireEs6_map();
  requireEs7_map_toJson();
  requireEs7_map_of();
  requireEs7_map_from();
  map$1 = require_core().Map;
  return map$1;
}
var map;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map;
  hasRequiredMap = 1;
  map = { "default": requireMap$1(), __esModule: true };
  return map;
}
var mapExports = requireMap();
const _Map = /* @__PURE__ */ getDefaultExportFromCjs(mapExports);
var iteratorExports = requireIterator();
const _Symbol$iterator = /* @__PURE__ */ getDefaultExportFromCjs(iteratorExports);
var es6_array_from = {};
var _createProperty;
var hasRequired_createProperty;
function require_createProperty() {
  if (hasRequired_createProperty) return _createProperty;
  hasRequired_createProperty = 1;
  var $defineProperty = require_objectDp();
  var createDesc = require_propertyDesc();
  _createProperty = function(object, index2, value) {
    if (index2 in object) $defineProperty.f(object, index2, createDesc(0, value));
    else object[index2] = value;
  };
  return _createProperty;
}
var _iterDetect;
var hasRequired_iterDetect;
function require_iterDetect() {
  if (hasRequired_iterDetect) return _iterDetect;
  hasRequired_iterDetect = 1;
  var ITERATOR = require_wks()("iterator");
  var SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter["return"] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {
  }
  _iterDetect = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR]();
      iter.next = function() {
        return { done: safe = true };
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {
    }
    return safe;
  };
  return _iterDetect;
}
var hasRequiredEs6_array_from;
function requireEs6_array_from() {
  if (hasRequiredEs6_array_from) return es6_array_from;
  hasRequiredEs6_array_from = 1;
  var ctx = require_ctx();
  var $export = require_export();
  var toObject = require_toObject();
  var call = require_iterCall();
  var isArrayIter = require_isArrayIter();
  var toLength = require_toLength();
  var createProperty = require_createProperty();
  var getIterFn = requireCore_getIteratorMethod();
  $export($export.S + $export.F * !require_iterDetect()(function(iter) {
    Array.from(iter);
  }), "Array", {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from2(arrayLike) {
      var O = toObject(arrayLike);
      var C = typeof this == "function" ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : void 0;
      var mapping = mapfn !== void 0;
      var index2 = 0;
      var iterFn = getIterFn(O);
      var length2, result, step, iterator;
      if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : void 0, 2);
      if (iterFn != void 0 && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index2++) {
          createProperty(result, index2, mapping ? call(iterator, mapfn, [step.value, index2], true) : step.value);
        }
      } else {
        length2 = toLength(O.length);
        for (result = new C(length2); length2 > index2; index2++) {
          createProperty(result, index2, mapping ? mapfn(O[index2], index2) : O[index2]);
        }
      }
      result.length = index2;
      return result;
    }
  });
  return es6_array_from;
}
var from$1;
var hasRequiredFrom$1;
function requireFrom$1() {
  if (hasRequiredFrom$1) return from$1;
  hasRequiredFrom$1 = 1;
  requireEs6_string_iterator();
  requireEs6_array_from();
  from$1 = require_core().Array.from;
  return from$1;
}
var from;
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom) return from;
  hasRequiredFrom = 1;
  from = { "default": requireFrom$1(), __esModule: true };
  return from;
}
var fromExports = requireFrom();
const _Array$from = /* @__PURE__ */ getDefaultExportFromCjs(fromExports);
var es6_set;
var hasRequiredEs6_set;
function requireEs6_set() {
  if (hasRequiredEs6_set) return es6_set;
  hasRequiredEs6_set = 1;
  var strong = require_collectionStrong();
  var validate = require_validateCollection();
  var SET = "Set";
  es6_set = require_collection()(SET, function(get) {
    return function Set() {
      return get(this, arguments.length > 0 ? arguments[0] : void 0);
    };
  }, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function add2(value) {
      return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
    }
  }, strong);
  return es6_set;
}
var es7_set_toJson = {};
var hasRequiredEs7_set_toJson;
function requireEs7_set_toJson() {
  if (hasRequiredEs7_set_toJson) return es7_set_toJson;
  hasRequiredEs7_set_toJson = 1;
  var $export = require_export();
  $export($export.P + $export.R, "Set", { toJSON: require_collectionToJson()("Set") });
  return es7_set_toJson;
}
var es7_set_of = {};
var hasRequiredEs7_set_of;
function requireEs7_set_of() {
  if (hasRequiredEs7_set_of) return es7_set_of;
  hasRequiredEs7_set_of = 1;
  require_setCollectionOf()("Set");
  return es7_set_of;
}
var es7_set_from = {};
var hasRequiredEs7_set_from;
function requireEs7_set_from() {
  if (hasRequiredEs7_set_from) return es7_set_from;
  hasRequiredEs7_set_from = 1;
  require_setCollectionFrom()("Set");
  return es7_set_from;
}
var set$3;
var hasRequiredSet$1;
function requireSet$1() {
  if (hasRequiredSet$1) return set$3;
  hasRequiredSet$1 = 1;
  requireEs6_string_iterator();
  requireWeb_dom_iterable();
  requireEs6_set();
  requireEs7_set_toJson();
  requireEs7_set_of();
  requireEs7_set_from();
  set$3 = require_core().Set;
  return set$3;
}
var set$2;
var hasRequiredSet;
function requireSet() {
  if (hasRequiredSet) return set$2;
  hasRequiredSet = 1;
  set$2 = { "default": requireSet$1(), __esModule: true };
  return set$2;
}
var setExports = requireSet();
const _Set = /* @__PURE__ */ getDefaultExportFromCjs(setExports);
var stringify$1;
var hasRequiredStringify$1;
function requireStringify$1() {
  if (hasRequiredStringify$1) return stringify$1;
  hasRequiredStringify$1 = 1;
  var core = require_core();
  var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
  stringify$1 = function stringify2(it) {
    return $JSON.stringify.apply($JSON, arguments);
  };
  return stringify$1;
}
var stringify;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  stringify = { "default": requireStringify$1(), __esModule: true };
  return stringify;
}
var stringifyExports = requireStringify();
const _JSON$stringify = /* @__PURE__ */ getDefaultExportFromCjs(stringifyExports);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function filterArrayInplace(array, predicate) {
  let length2 = array.length;
  let outIndex = 0;
  for (let i = 0; i < length2; ++i) {
    if (predicate(array[i], i, array)) {
      array[outIndex] = array[i];
      ++outIndex;
    }
  }
  array.length = outIndex;
}
function maybePadArray(array, newSize) {
  if (array.length === newSize) {
    return array;
  }
  let newArray = new array.constructor(newSize);
  newArray.set(array);
  return newArray;
}
function tile2dArray(array, majorDimension, minorTiles, majorTiles) {
  const minorDimension = array.length / majorDimension;
  const length2 = array.length * minorTiles * majorTiles;
  const result = new array.constructor(length2);
  const minorTileStride = array.length * majorTiles;
  const majorTileStride = majorDimension;
  const minorStride = majorDimension * majorTiles;
  for (let minor = 0; minor < minorDimension; ++minor) {
    for (let major = 0; major < majorDimension; ++major) {
      const inputValue = array[minor * majorDimension + major];
      const baseOffset = minor * minorStride + major;
      for (let minorTile = 0; minorTile < minorTiles; ++minorTile) {
        for (let majorTile = 0; majorTile < majorTiles; ++majorTile) {
          result[minorTile * minorTileStride + majorTile * majorTileStride + baseOffset] = inputValue;
        }
      }
    }
  }
  return result;
}
function binarySearch(haystack, needle, compare, low = 0, high = haystack.length) {
  while (low < high) {
    const mid = low + high - 1 >> 1;
    const compareResult = compare(needle, haystack[mid]);
    if (compareResult > 0) {
      low = mid + 1;
    } else if (compareResult < 0) {
      high = mid;
    } else {
      return mid;
    }
  }
  return ~low;
}
function binarySearchLowerBound(begin, end, predicate) {
  let count = end - begin;
  while (count > 0) {
    let step = Math.floor(count / 2);
    let i = begin + step;
    if (predicate(i)) {
      count = step;
    } else {
      begin = i + 1;
      count -= step + 1;
    }
  }
  return begin;
}
function findMatchingIndices(input, value) {
  const out = [];
  for (let i = 0, length2 = input.length; i < length2; ++i) {
    if (input[i] === value) {
      out.push(i);
    }
  }
  return out;
}
function arraysEqual(a, b) {
  const length2 = a.length;
  if (b.length !== length2) return false;
  for (let i = 0; i < length2; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function arraysEqualWithPredicate(a, b, elementsEqual = (a2, b2) => a2 === b2) {
  const length2 = a.length;
  if (b.length !== length2) return false;
  for (let i = 0; i < length2; ++i) {
    if (!elementsEqual(a[i], b[i])) return false;
  }
  return true;
}
function getInsertPermutation(n, sourceIndex, targetIndex) {
  const newToOld = [];
  if (targetIndex === sourceIndex) {
    for (let i = 0; i < n; ++i) {
      newToOld[i] = i;
    }
    return newToOld;
  }
  newToOld[targetIndex] = sourceIndex;
  for (let oldDim = 0, newDim = 0; oldDim < n; ) {
    if (oldDim === sourceIndex) {
      ++oldDim;
      continue;
    }
    if (newDim === targetIndex) {
      ++newDim;
    }
    newToOld[newDim++] = oldDim++;
  }
  return newToOld;
}
function gatherUpdate(dest, source, indices) {
  for (let destIndex = 0, length2 = indices.length; destIndex < length2; ++destIndex) {
    const sourceIndex = indices[destIndex];
    if (sourceIndex === -1) continue;
    dest[destIndex] = source[sourceIndex];
  }
  return dest;
}
function transposeNestedArrays(x) {
  const result = [];
  for (let outerIndex = 0, outerLength = x.length; outerIndex < outerLength; ++outerIndex) {
    const inner = x[outerIndex];
    for (let innerIndex = 0, innerLength = inner.length; innerIndex < innerLength; ++innerIndex) {
      let resultInner = result[innerIndex];
      if (resultInner === void 0) {
        resultInner = result[innerIndex] = [];
      }
      resultInner.push(inner[innerIndex]);
    }
  }
  return result;
}
function spliceArray(array, splices) {
  const parts = [];
  let origOffset = 0;
  for (let i = 0, numSplices = splices.length; i < numSplices; ++i) {
    var _splices$i = splices[i];
    const retainCount = _splices$i.retainCount, deleteCount = _splices$i.deleteCount, insertCount = _splices$i.insertCount;
    if (retainCount !== 0) {
      parts.push(array.slice(origOffset, origOffset + retainCount));
      origOffset += retainCount;
    }
    origOffset += deleteCount;
    if (insertCount !== 0) {
      parts.push(new Array(insertCount));
    }
  }
  const origLength = array.length;
  if (origOffset !== origLength) {
    parts.push(array.slice(origOffset));
  }
  return new Array(0).concat(...parts);
}
function getMergeSplices(oldArray, newArray, compare) {
  const splices = [];
  let oldIndex = 0, newIndex = 0, oldCount = oldArray.length, newCount = newArray.length;
  while (oldIndex < oldCount && newIndex < newCount) {
    let c;
    let oldValue = oldArray[oldIndex];
    let newValue = newArray[newIndex];
    c = compare(oldValue, newValue);
    if (c === 0) {
      let retainCount = 1;
      ++oldIndex;
      ++newIndex;
      while (oldIndex < oldCount && newIndex < newCount && (c = compare(oldArray[oldIndex], newArray[newIndex])) === 0) {
        ++retainCount;
        ++oldIndex;
        ++newIndex;
      }
      splices.push({ retainCount, deleteCount: 0, insertCount: 0 });
      continue;
    }
    if (c < 0) {
      let deleteCount = 1;
      while (++oldIndex < oldCount && (c = compare(oldArray[oldIndex], newValue)) < 0) {
        ++deleteCount;
      }
      splices.push({ retainCount: 0, deleteCount, insertCount: 0 });
      continue;
    }
    if (c > 0) {
      let insertCount = 1;
      while (++newIndex < newCount && (c = compare(oldValue, newArray[newIndex])) > 0) {
        ++insertCount;
      }
      splices.push({ retainCount: 0, deleteCount: 0, insertCount });
      continue;
    }
  }
  if (oldIndex < oldCount || newIndex < newCount) {
    splices.push({ retainCount: 0, deleteCount: oldCount - oldIndex, insertCount: newCount - newIndex });
  }
  return splices;
}
function mergeSequences(aCount, bCount, compare, aCallback, bCallback, abCallback) {
  let a = 0;
  let b = 0;
  if (aCount !== 0 && bCount !== 0) {
    while (true) {
      const x = compare(a, b);
      if (x < 0) {
        aCallback(a);
        if (++a === aCount) break;
      } else if (x > 0) {
        bCallback(b);
        if (++b === bCount) break;
      } else {
        abCallback(a, b);
        ++a;
        ++b;
        if (a === aCount || b === bCount) break;
      }
    }
  }
  while (a < aCount) {
    aCallback(a);
    ++a;
  }
  while (b < bCount) {
    bCallback(b);
    ++b;
  }
}
var getIteratorExports = requireGetIterator();
const _getIterator = /* @__PURE__ */ getDefaultExportFromCjs(getIteratorExports);
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  isObject_1 = isObject;
  return isObject_1;
}
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  _root = root;
  return _root;
}
var now_1;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow) return now_1;
  hasRequiredNow = 1;
  var root = require_root();
  var now = function() {
    return root.Date.now();
  };
  now_1 = now;
  return now_1;
}
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index2 = string.length;
    while (index2-- && reWhitespace.test(string.charAt(index2))) {
    }
    return index2;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim) return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var _Symbol$1;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol$1;
  hasRequired_Symbol = 1;
  var root = require_root();
  var Symbol2 = root.Symbol;
  _Symbol$1 = Symbol2;
  return _Symbol$1;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol2 = require_Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(), isObject = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var debounce_1;
var hasRequiredDebounce;
function requireDebounce() {
  if (hasRequiredDebounce) return debounce_1;
  hasRequiredDebounce = 1;
  var isObject = requireIsObject(), now = requireNow(), toNumber = requireToNumber();
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax = Math.max, nativeMin = Math.min;
  function debounce2(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  debounce_1 = debounce2;
  return debounce_1;
}
var debounceExports = requireDebounce();
const debounce = /* @__PURE__ */ getDefaultExportFromCjs(debounceExports);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function invokeDisposer(disposer) {
  if (typeof disposer === "object") {
    disposer.dispose();
  } else {
    disposer();
  }
}
function invokeDisposers(disposers) {
  for (let i = disposers.length; i > 0; --i) {
    invokeDisposer(disposers[i - 1]);
  }
}
function registerEventListener(target, type, listener, options) {
  target.addEventListener(type, listener, options);
  return () => target.removeEventListener(type, listener, options);
}
class RefCounted {
  constructor() {
    this.refCount = 1;
  }
  addRef() {
    ++this.refCount;
    return this;
  }
  dispose() {
    if (--this.refCount !== 0) {
      return;
    }
    this.refCountReachedZero();
  }
  refCountReachedZero() {
    this.disposed();
    let disposers = this.disposers;
    if (disposers !== void 0) {
      invokeDisposers(disposers);
      this.disposers = void 0;
    }
    this.wasDisposed = true;
  }
  disposed() {
  }
  registerDisposer(f) {
    let disposers = this.disposers;
    if (disposers == null) {
      this.disposers = [f];
    } else {
      disposers.push(f);
    }
    return f;
  }
  unregisterDisposer(f) {
    let disposers = this.disposers;
    if (disposers != null) {
      let index2 = disposers.indexOf(f);
      if (index2 !== -1) {
        disposers.splice(index2, 1);
      }
    }
    return f;
  }
  registerEventListener(target, type, listener, options) {
    this.registerDisposer(registerEventListener(target, type, listener, options));
  }
  registerCancellable(cancellable) {
    this.registerDisposer(() => {
      cancellable.cancel();
    });
    return cancellable;
  }
}
class RefCountedValue extends RefCounted {
  constructor(value) {
    super();
    this.value = value;
  }
}
function disposableOnce(value) {
  return () => {
    if (value !== void 0) {
      let x = value;
      value = void 0;
      invokeDisposer(x);
    }
  };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Signal {
  constructor() {
    this.handlers = new _Set();
    this.count = 0;
    const obj = this;
    this.dispatch = function() {
      ++obj.count;
      obj.handlers.forEach((handler) => {
        handler.apply(this, arguments);
      });
    };
  }
  /**
   * Add a handler function.  If `dispatch` is currently be called, then the new handler will be
   * called before `dispatch` returns.
   *
   * @param handler The handler function to add.
   *
   * @return A function that unregisters the handler.
   */
  add(handler) {
    this.handlers.add(handler);
    return () => {
      return this.remove(handler);
    };
  }
  /**
   * Remove a handler function.  If `dispatch` is currently be called and the new handler has not
   * yet been called, then it will not be called.
   *
   * @param handler Handler to remove.
   * @return `true` if the handler was present, `false` otherwise.
   */
  remove(handler) {
    return this.handlers.delete(handler);
  }
  /**
   * Disposes of resources.  No methods, including `dispatch`, may be invoked afterwards.
   */
  dispose() {
    this.handlers = void 0;
  }
}
class NullarySignal extends Signal {
}
const neverSignal = {
  count: 0,
  add(_handler) {
    return () => {
    };
  },
  remove(_handler) {
    return false;
  }
};
class WatchableValue {
  constructor(value_) {
    this.value_ = value_;
    this.changed = new NullarySignal();
  }
  get value() {
    return this.value_;
  }
  set value(newValue) {
    if (newValue !== this.value_) {
      this.value_ = newValue;
      this.changed.dispatch();
    }
  }
}
class TrackableValue extends WatchableValue {
  constructor(value, validator, defaultValue = value) {
    super(value);
    this.validator = validator;
    this.defaultValue = defaultValue;
  }
  toJSON() {
    let value_ = this.value_;
    if (value_ === this.defaultValue) {
      return void 0;
    }
    return this.value_;
  }
  reset() {
    this.value = this.defaultValue;
  }
  restoreState(x) {
    if (x !== void 0) {
      let validator = this.validator;
      try {
        this.value = validator(x);
        return;
      } catch (ignoredError) {
      }
    }
    this.value = this.defaultValue;
  }
}
class DerivedWatchableValue extends RefCounted {
  constructor(f, ws) {
    super();
    this.changed = new NullarySignal();
    this.f = f;
    this.ws = ws;
    for (const w of ws) {
      this.registerDisposer(w.changed.add(this.changed.dispatch));
    }
  }
  get value() {
    return this.f(...this.ws.map((w) => w.value));
  }
}
function makeDerivedWatchableValue(f, ...ws) {
  return new DerivedWatchableValue(f, ws);
}
class CachedLazyDerivedWatchableValue extends RefCounted {
  constructor(f, ws) {
    super();
    this.changed = new NullarySignal();
    this.valueGeneration = -1;
    this.f = f;
    this.ws = ws;
    for (const w of ws) {
      this.registerDisposer(w.changed.add(this.changed.dispatch));
    }
  }
  get value() {
    const generation = this.changed.count;
    if (generation !== this.valueGeneration) {
      this.value_ = this.f(...this.ws.map((w) => w.value));
      this.valueGeneration = generation;
    }
    return this.value_;
  }
}
function makeCachedLazyDerivedWatchableValue(f, ...ws) {
  return new CachedLazyDerivedWatchableValue(f, ws);
}
class CachedWatchableValue extends RefCounted {
  constructor(base, isEqual = (a, b) => a === b) {
    super();
    this.changed = new Signal();
    this.value = base.value;
    this.registerDisposer(base.changed.add(() => {
      const newValue = base.value;
      if (!isEqual(this.value, newValue)) {
        this.value = newValue;
        this.changed.dispatch();
      }
    }));
  }
}
function makeCachedDerivedWatchableValue(f, ws, isEqual) {
  const derived = new DerivedWatchableValue(f, ws);
  const cached = new CachedWatchableValue(derived, isEqual);
  cached.registerDisposer(derived);
  return cached;
}
class AggregateWatchableValue extends RefCounted {
  constructor(getWatchables) {
    super();
    this.changed = new NullarySignal();
    const watchables = getWatchables(this);
    const keys2 = _Object$keys(watchables);
    const updateValue = () => {
      const obj = Array.isArray(watchables) ? [] : {};
      for (const k of keys2) {
        obj[k] = watchables[k].value;
      }
      this.value = obj;
      this.changed.dispatch();
    };
    updateValue();
    for (const k of keys2) {
      const watchable = watchables[k];
      this.registerDisposer(watchable.changed.add(() => updateValue()));
    }
  }
}
class WatchableSet {
  constructor(values2) {
    this.changed = new NullarySignal();
    if (values2 === void 0) {
      this.values = new _Set();
    } else {
      this.values = new _Set(values2);
    }
  }
  add(x) {
    const values2 = this.values;
    if (!values2.has(x)) {
      values2.add(x);
      this.changed.dispatch();
    }
    return this;
  }
  delete(x) {
    const values2 = this.values;
    if (values2.delete(x)) {
      this.changed.dispatch();
      return true;
    }
    return false;
  }
  has(x) {
    return this.values.has(x);
  }
  get size() {
    return this.values.size;
  }
  [_Symbol$iterator]() {
    return _getIterator(this.values);
  }
  clear() {
    const values2 = this.values;
    if (values2.size > 0) {
      values2.clear();
      this.changed.dispatch();
    }
  }
}
function registerNested(f, ...watchables) {
  let values2 = watchables.map((w) => w.value);
  const count = watchables.length;
  let context = new RefCounted();
  let result = f(context, ...values2);
  const handleChange = debounce(() => {
    let changed = false;
    for (let i = 0; i < count; ++i) {
      const watchable = watchables[i];
      const value = watchable.value;
      if (values2[i] !== value) {
        values2[i] = value;
        changed = true;
      }
    }
    if (!changed) return;
    context.dispose();
    context = new RefCounted();
    result = f(context, ...values2);
  }, 0);
  const signalDisposers = watchables.map((w) => w.changed.add(handleChange));
  return {
    flush() {
      handleChange.flush();
    },
    dispose() {
      handleChange.cancel();
      invokeDisposers(signalDisposers);
      context.dispose();
    },
    get value() {
      handleChange.flush();
      return result;
    }
  };
}
function registerNestedSync(f, ...watchables) {
  let values2 = watchables.map((w) => w.value);
  const count = watchables.length;
  let context = new RefCounted();
  let result = f(context, ...values2);
  const handleChange = () => {
    let changed = false;
    for (let i = 0; i < count; ++i) {
      const watchable = watchables[i];
      const value = watchable.value;
      if (values2[i] !== value) {
        values2[i] = value;
        changed = true;
      }
    }
    if (!changed) return;
    context.dispose();
    context = new RefCounted();
    result = f(context, ...values2);
  };
  const signalDisposers = watchables.map((w) => w.changed.add(handleChange));
  return {
    dispose() {
      invokeDisposers(signalDisposers);
      context.dispose();
    },
    get value() {
      return result;
    }
  };
}
function constantWatchableValue(value) {
  return { changed: neverSignal, value };
}
function observeWatchable(callback, watchable) {
  callback(watchable.value);
  return watchable.changed.add(() => callback(watchable.value));
}
class IndirectWatchableValue {
  constructor(outer, getInner) {
    this.outer = outer;
    this.getInner = getInner;
    this.changed = new NullarySignal();
    this.update = () => {
      const disposer = this.disposer, outer2 = this.outer;
      if (disposer !== void 0) {
        disposer();
      }
      const inner = this.inner = this.getInner(outer2.value);
      this.disposer = inner.changed.add(this.changed.dispatch);
      this.changed.dispatch();
    };
    outer.changed.add(this.update);
    this.update();
  }
  dispose() {
    this.outer.changed.remove(this.update);
    this.disposer();
  }
  get value() {
    return this.inner.value;
  }
  set value(value) {
    this.inner.value = value;
  }
}
class IndirectTrackableValue extends IndirectWatchableValue {
  reset() {
    this.inner.reset();
  }
  restoreState(obj) {
    this.inner.restoreState(obj);
  }
  toJSON() {
    return this.inner.toJSON();
  }
}
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tempArray = new Float32Array(1);
function float32ToString(x) {
  tempArray[0] = x;
  x = tempArray[0];
  for (let digits = 1; digits < 21; ++digits) {
    let result = x.toPrecision(digits);
    tempArray[0] = parseFloat(result);
    if (tempArray[0] === x) {
      return result;
    }
  }
  return x.toString();
}
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function() {
  var y = 0, i = arguments.length;
  while (i--) {
    y += arguments[i] * arguments[i];
  }
  return Math.sqrt(y);
};
function create$5() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function transpose$1(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert$2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function fromQuat$1(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function create$4() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone$1(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy$4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function identity$2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert$1(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function multiply$3(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale$2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function perspective(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
function create$3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues$1(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy$3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set$1(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add$2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract$1(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply$2(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function scale$1(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function normalize$2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len2 = x * x + y * y + z * z;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a[0] * len2;
  out[1] = a[1] * len2;
  out[2] = a[2] * len2;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub = subtract$1;
var len = length;
(function() {
  var vec = create$3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
})();
function create$2() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function fromValues(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy$2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function normalize$1(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len2 = x * x + y * y + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x * len2;
  out[1] = y * len2;
  out[2] = z * len2;
  out[3] = w * len2;
  return out;
}
(function() {
  var vec = create$2();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
})();
function create$1() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity$1(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function multiply$1(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function invert(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot2 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot2 ? 1 / dot2 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var copy$1 = copy$2;
var normalize = normalize$1;
(function() {
  var tmpvec3 = create$3();
  var xUnitVec3 = fromValues$1(1, 0, 0);
  var yUnitVec3 = fromValues$1(0, 1, 0);
  return function(out, a, b) {
    var dot$1 = dot(a, b);
    if (dot$1 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a);
      normalize$2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot$1 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot$1;
      return normalize(out, out);
    }
  };
})();
(function() {
  var temp1 = create$1();
  var temp2 = create$1();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
(function() {
  var matr = create$5();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
})();
function create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add$1(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
(function() {
  var vec = create();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
})();
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const identityMat4 = create$4();
const AXES_NAMES = ["x", "y", "z"];
const kAxes = [fromValues$1(1, 0, 0), fromValues$1(0, 1, 0), fromValues$1(0, 0, 1)];
fromValues$1(0, 0, 0);
const kZeroVec4 = fromValues(0, 0, 0, 0);
const kOneVec = fromValues$1(1, 1, 1);
fromValues$1(Infinity, Infinity, Infinity);
create$1();
function prod3(x) {
  return x[0] * x[1] * x[2];
}
function vec3Key(x) {
  return `${x[0]},${x[1]},${x[2]}`;
}
function transformVectorByMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  out[0] = m[0] * x + m[4] * y + m[8] * z;
  out[1] = m[1] * x + m[5] * y + m[9] * z;
  out[2] = m[2] * x + m[6] * y + m[10] * z;
  return out;
}
function transformVectorByMat4Transpose(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  out[0] = m[0] * x + m[1] * y + m[2] * z;
  out[1] = m[4] * x + m[5] * y + m[6] * z;
  out[2] = m[8] * x + m[9] * y + m[10] * z;
  return out;
}
function findClosestParameterizedLinePosition(a, b, p) {
  const rank = p.length;
  let denominator = 0;
  for (let i = 0; i < rank; ++i) {
    denominator += (a[i] - b[i]) ** 2;
  }
  let numerator = 0;
  for (let i = 0; i < rank; ++i) {
    const aValue = a[i];
    numerator -= (aValue - p[i]) * (b[i] - aValue);
  }
  return numerator / Math.max(denominator, 1e-6);
}
function projectPointToLineSegment(out, a, b, p) {
  const rank = out.length;
  let t = findClosestParameterizedLinePosition(a, b, p);
  t = Math.max(0, Math.min(1, t));
  for (let i = 0; i < rank; ++i) {
    const aValue = a[i];
    out[i] = aValue + t * (b[i] - aValue);
  }
  return out;
}
function mat3FromMat4(out, m) {
  const m00 = m[0], m01 = m[1], m02 = m[2], m10 = m[4], m11 = m[5], m12 = m[6], m20 = m[8], m21 = m[9], m22 = m[10];
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function getFrustrumPlanes(out, m) {
  const m00 = m[0], m10 = m[1], m20 = m[2], m30 = m[3], m01 = m[4], m11 = m[5], m21 = m[6], m31 = m[7], m02 = m[8], m12 = m[9], m22 = m[10], m32 = m[11], m03 = m[12], m13 = m[13], m23 = m[14], m33 = m[15];
  out[0] = m30 + m00;
  out[1] = m31 + m01;
  out[2] = m32 + m02;
  out[3] = m33 + m03;
  out[4] = m30 - m00;
  out[5] = m31 - m01;
  out[6] = m32 - m02;
  out[7] = m33 - m03;
  out[8] = m30 + m10;
  out[9] = m31 + m11;
  out[10] = m32 + m12;
  out[11] = m33 + m13;
  out[12] = m30 - m10;
  out[13] = m31 - m11;
  out[14] = m32 - m12;
  out[15] = m33 - m13;
  const nearA = m30 + m20;
  const nearB = m31 + m21;
  const nearC = m32 + m22;
  const nearD = m33 + m23;
  const farA = m30 - m20;
  const farB = m31 - m21;
  const farC = m32 - m22;
  const farD = m33 - m23;
  const nearNorm = Math.sqrt(nearA ** 2 + nearB ** 2 + nearC ** 2);
  out[16] = nearA / nearNorm;
  out[17] = nearB / nearNorm;
  out[18] = nearC / nearNorm;
  out[19] = nearD / nearNorm;
  const farNorm = Math.sqrt(farA ** 2 + farB ** 2 + farC ** 2);
  out[20] = farA / farNorm;
  out[21] = farB / farNorm;
  out[22] = farC / farNorm;
  out[23] = farD / farNorm;
  return out;
}
function isAABBVisible(xLower, yLower, zLower, xUpper, yUpper, zUpper, clippingPlanes) {
  for (let i = 0; i < 6; ++i) {
    const a = clippingPlanes[i * 4], b = clippingPlanes[i * 4 + 1], c = clippingPlanes[i * 4 + 2], d = clippingPlanes[i * 4 + 3];
    const sum = Math.max(a * xLower, a * xUpper) + Math.max(b * yLower, b * yUpper) + Math.max(c * zLower, c * zUpper) + d;
    if (sum < 0) {
      return false;
    }
  }
  return true;
}
function isAABBIntersectingPlane(xLower, yLower, zLower, xUpper, yUpper, zUpper, clippingPlanes) {
  for (let i = 0; i < 4; ++i) {
    const a = clippingPlanes[i * 4], b = clippingPlanes[i * 4 + 1], c = clippingPlanes[i * 4 + 2], d = clippingPlanes[i * 4 + 3];
    const sum = Math.max(a * xLower, a * xUpper) + Math.max(b * yLower, b * yUpper) + Math.max(c * zLower, c * zUpper) + d;
    if (sum < 0) {
      return false;
    }
  }
  {
    const i = 5;
    const a = clippingPlanes[i * 4], b = clippingPlanes[i * 4 + 1], c = clippingPlanes[i * 4 + 2], d = clippingPlanes[i * 4 + 3];
    const maxSum = Math.max(a * xLower, a * xUpper) + Math.max(b * yLower, b * yUpper) + Math.max(c * zLower, c * zUpper);
    const minSum = Math.min(a * xLower, a * xUpper) + Math.min(b * yLower, b * yUpper) + Math.min(c * zLower, c * zUpper);
    const epsilon = Math.abs(d) * 1e-6;
    if (minSum > -d + epsilon || maxSum < -d - epsilon) return false;
  }
  return true;
}
function getDependentTransformInputDimensions(transform, rank, outputDimensions, transpose2 = false) {
  const numOutputDimensions = outputDimensions.length;
  const isDependentInputDimension = [];
  const inputStride = transpose2 ? 1 : rank + 1;
  const outputStride = transpose2 ? rank + 1 : 1;
  for (let i = 0; i < numOutputDimensions; ++i) {
    const outputDim = outputDimensions[i];
    for (let inputDim = 0; inputDim < rank; ++inputDim) {
      if (transform[inputDim * inputStride + outputDim * outputStride] !== 0) {
        isDependentInputDimension[inputDim] = true;
      }
    }
  }
  return findMatchingIndices(isDependentInputDimension, true);
}
function scaleMat3Output(out, input, scales) {
  for (let i = 0; i < 3; ++i) {
    const s = scales[i];
    for (let j = 0; j < 3; ++j) {
      out[i + j * 3] = s * input[i + j * 3];
    }
  }
  return out;
}
function getViewFrustrumVolume(projectionMat) {
  if (projectionMat[15] === 1) {
    const depth = 2 / Math.abs(projectionMat[10]);
    const width = 2 / Math.abs(projectionMat[0]);
    const height = 2 / Math.abs(projectionMat[5]);
    return width * height * depth;
  }
  const a = projectionMat[10];
  const b = projectionMat[14];
  const near = 2 * b / (2 * a - 2);
  const far = (a - 1) * near / (a + 1);
  const baseArea = 4 / (projectionMat[0] * projectionMat[5]);
  return baseArea / 3 * (Math.abs(far) ** 3 - Math.abs(near) ** 3);
}
function getViewFrustrumDepthRange(projectionMat) {
  if (projectionMat[15] === 1) {
    const depth2 = 2 / Math.abs(projectionMat[10]);
    return depth2;
  }
  const a = projectionMat[10];
  const b = projectionMat[14];
  const near = 2 * b / (2 * a - 2);
  const far = (a - 1) * near / (a + 1);
  const depth = Math.abs(far - near);
  return depth;
}
function disableZProjection(mat) {
  mat[2] = 0;
  mat[6] = 0;
  mat[10] = 0;
  mat[14] = 0;
  return mat;
}
const tempVec3$6 = create$3();
function getViewFrustrumWorldBounds(invViewProjectionMat, bounds) {
  bounds[0] = bounds[1] = bounds[2] = Number.POSITIVE_INFINITY;
  bounds[3] = bounds[4] = bounds[5] = Number.NEGATIVE_INFINITY;
  for (let i = 0; i < 8; ++i) {
    tempVec3$6[0] = 2 * (i & 1) - 1;
    tempVec3$6[1] = 2 * (i >>> 1 & 1) - 1;
    tempVec3$6[2] = 2 * (i >>> 2 & 1) - 1;
    transformMat4(tempVec3$6, tempVec3$6, invViewProjectionMat);
    for (let j = 0; j < 3; ++j) {
      const x = tempVec3$6[j];
      bounds[j] = Math.min(bounds[j], x);
      bounds[j + 3] = Math.max(bounds[j + 3], x);
    }
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hexEncodeByte(x) {
  return ("0" + x.toString(16)).slice(-2);
}
function hexEncode(arr) {
  return Array.prototype.map.call(arr, hexEncodeByte).join("");
}
function hexDecode(x) {
  if (!/^(?:[0-9a-fA-F]{2})*$/.test(x)) {
    throw new Error("Invalid hex-encoded string");
  }
  const length2 = x.length / 2;
  const result = new Uint8Array(length2);
  for (let i = 0; i < length2; ++i) {
    result[i] = parseInt(x.substr(i * 2, 2), 16);
  }
  return result;
}
function parseColorSerialization(x) {
  const rgbaPattern = /^rgba\(([0-9]+), ([0-9]+), ([0-9]+), (0(?:\.[0-9]+)?)\)$/;
  {
    const m = x.match(rgbaPattern);
    if (m !== null) {
      return [parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), parseFloat(m[4])];
    }
  }
  const hexPattern = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/;
  {
    const m = x.match(hexPattern);
    if (m !== null) {
      return [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 1];
    }
  }
  throw new Error(`Invalid serialized color: ${_JSON$stringify(x)}.`);
}
function parseRGBAColorSpecification(x) {
  try {
    if (typeof x !== "string") {
      throw new Error(`Expected string, but received ${_JSON$stringify(x)}.`);
    }
    const context = document.createElement("canvas").getContext("2d");
    context.fillStyle = x;
    const result = parseColorSerialization(context.fillStyle);
    return fromValues(result[0] / 255, result[1] / 255, result[2] / 255, result[3]);
  } catch (parseError) {
    throw new Error(`Failed to parse color specification: ${parseError.message}`);
  }
}
function parseRGBColorSpecification(x) {
  const result = parseRGBAColorSpecification(x);
  return result.subarray(0, 3);
}
function packColor(x) {
  const size = x[3] === void 0 ? 3 : 4;
  let result = 0;
  for (let i = 0; i < size; i++) {
    result = (result << 8 >>> 0) + Math.min(255, Math.max(0, Math.round(x[size - 1 - i] * 255)));
  }
  return result;
}
function unpackRGB(value) {
  return fromValues$1((value >>> 0 & 255) / 255, (value >>> 8 & 255) / 255, (value >>> 16 & 255) / 255);
}
function unpackRGBA(value) {
  return fromValues((value >>> 0 & 255) / 255, (value >>> 8 & 255) / 255, (value >>> 16 & 255) / 255, (value >>> 24 & 255) / 255);
}
function serializeColor(x) {
  if (x[3] === void 0 || x[3] === 1) {
    let result = "#";
    for (let i = 0; i < 3; ++i) {
      result += hexEncodeByte(Math.min(255, Math.max(0, Math.round(x[i] * 255))));
    }
    return result;
  } else {
    let result = "rgba(";
    for (let i = 0; i < 3; ++i) {
      if (i !== 0) {
        result += ", ";
      }
      result += Math.min(255, Math.max(0, Math.round(x[i] * 255)));
    }
    result += `, ${float32ToString(x[3])})`;
    return result;
  }
}
function srgbGammaExpand(value) {
  return value <= 0.03928 ? value / 12.92 : ((value + 0.055) / 1.055) ** 2.4;
}
function getRelativeLuminance(color2) {
  var _color = _slicedToArray(color2, 3);
  const r = _color[0], g = _color[1], b = _color[2];
  return 0.2126 * srgbGammaExpand(r) + 0.7152 * srgbGammaExpand(g) + 0.0722 * srgbGammaExpand(b);
}
function useWhiteBackground(foregroundColor) {
  return getRelativeLuminance(foregroundColor) <= 0.179;
}
class TrackableRGB extends WatchableValue {
  constructor(defaultValue) {
    super(clone(defaultValue));
    this.defaultValue = defaultValue;
  }
  toString() {
    return serializeColor(this.value);
  }
  toJSON() {
    if (equals(this.value, this.defaultValue)) {
      return void 0;
    } else {
      return serializeColor(this.value);
    }
  }
  reset() {
    this.value = clone(this.defaultValue);
  }
  restoreState(x) {
    if (x === void 0) {
      this.reset();
      return;
    }
    const value = this.value;
    const newValue = parseRGBColorSpecification(x);
    if (!equals(value, newValue)) {
      this.value = newValue;
    }
  }
}
class TrackableOptionalRGB extends WatchableValue {
  constructor() {
    super(void 0);
  }
  toJSON() {
    const value = this.value;
    if (value === void 0) return void 0;
    return serializeColor(value);
  }
  reset() {
    this.value = void 0;
  }
  restoreState(x) {
    if (x === void 0) {
      this.reset();
      return;
    }
    const value = this.value;
    const newValue = parseRGBColorSpecification(x);
    if (value === void 0 || !equals(value, newValue)) {
      this.value = newValue;
    }
  }
}
const color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TrackableOptionalRGB,
  TrackableRGB,
  getRelativeLuminance,
  packColor,
  parseColorSerialization,
  parseRGBAColorSpecification,
  parseRGBColorSpecification,
  serializeColor,
  srgbGammaExpand,
  unpackRGB,
  unpackRGBA,
  useWhiteBackground
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DataType;
(function(DataType2) {
  DataType2[DataType2["UINT8"] = 0] = "UINT8";
  DataType2[DataType2["INT8"] = 1] = "INT8";
  DataType2[DataType2["UINT16"] = 2] = "UINT16";
  DataType2[DataType2["INT16"] = 3] = "INT16";
  DataType2[DataType2["UINT32"] = 4] = "UINT32";
  DataType2[DataType2["INT32"] = 5] = "INT32";
  DataType2[DataType2["UINT64"] = 6] = "UINT64";
  DataType2[DataType2["FLOAT32"] = 7] = "FLOAT32";
})(DataType || (DataType = {}));
const DATA_TYPE_SIGNED = {
  [DataType.UINT8]: false,
  [DataType.INT8]: true,
  [DataType.UINT16]: false,
  [DataType.INT16]: true,
  [DataType.UINT32]: false,
  [DataType.INT32]: true,
  [DataType.UINT64]: false,
  [DataType.FLOAT32]: void 0
};
const DATA_TYPE_BYTES = {
  [DataType.UINT8]: 1,
  [DataType.INT8]: 1,
  [DataType.UINT16]: 2,
  [DataType.INT16]: 2,
  [DataType.UINT32]: 4,
  [DataType.INT32]: 4,
  [DataType.UINT64]: 8,
  [DataType.FLOAT32]: 4
};
const DATA_TYPE_ARRAY_CONSTRUCTOR = {
  [DataType.UINT8]: Uint8Array,
  [DataType.INT8]: Int8Array,
  [DataType.UINT16]: Uint16Array,
  [DataType.INT16]: Int16Array,
  [DataType.UINT32]: Uint32Array,
  [DataType.INT32]: Int32Array,
  [DataType.UINT64]: Uint32Array,
  [DataType.FLOAT32]: Float32Array
};
({
  [DataType.UINT8]: 1,
  [DataType.INT8]: 1,
  [DataType.UINT16]: 1,
  [DataType.INT16]: 1,
  [DataType.UINT32]: 1,
  [DataType.INT32]: 1,
  [DataType.UINT64]: 2,
  [DataType.FLOAT32]: 1
});
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Endianness;
(function(Endianness2) {
  Endianness2[Endianness2["LITTLE"] = 0] = "LITTLE";
  Endianness2[Endianness2["BIG"] = 1] = "BIG";
})(Endianness || (Endianness = {}));
function determineEndianness() {
  const a = Uint16Array.of(4386);
  const b = new Uint8Array(a.buffer);
  return b[0] === 17 ? Endianness.BIG : Endianness.LITTLE;
}
const ENDIANNESS = determineEndianness();
var es6_number_isInteger = {};
var _isInteger;
var hasRequired_isInteger;
function require_isInteger() {
  if (hasRequired_isInteger) return _isInteger;
  hasRequired_isInteger = 1;
  var isObject = require_isObject();
  var floor = Math.floor;
  _isInteger = function isInteger2(it) {
    return !isObject(it) && isFinite(it) && floor(it) === it;
  };
  return _isInteger;
}
var hasRequiredEs6_number_isInteger;
function requireEs6_number_isInteger() {
  if (hasRequiredEs6_number_isInteger) return es6_number_isInteger;
  hasRequiredEs6_number_isInteger = 1;
  var $export = require_export();
  $export($export.S, "Number", { isInteger: require_isInteger() });
  return es6_number_isInteger;
}
var isInteger$1;
var hasRequiredIsInteger$1;
function requireIsInteger$1() {
  if (hasRequiredIsInteger$1) return isInteger$1;
  hasRequiredIsInteger$1 = 1;
  requireEs6_number_isInteger();
  isInteger$1 = require_core().Number.isInteger;
  return isInteger$1;
}
var isInteger;
var hasRequiredIsInteger;
function requireIsInteger() {
  if (hasRequiredIsInteger) return isInteger;
  hasRequiredIsInteger = 1;
  isInteger = { "default": requireIsInteger$1(), __esModule: true };
  return isInteger;
}
var isIntegerExports = requireIsInteger();
const _Number$isInteger = /* @__PURE__ */ getDefaultExportFromCjs(isIntegerExports);
var es6_number_isFinite = {};
var hasRequiredEs6_number_isFinite;
function requireEs6_number_isFinite() {
  if (hasRequiredEs6_number_isFinite) return es6_number_isFinite;
  hasRequiredEs6_number_isFinite = 1;
  var $export = require_export();
  var _isFinite2 = require_global().isFinite;
  $export($export.S, "Number", {
    isFinite: function isFinite2(it) {
      return typeof it == "number" && _isFinite2(it);
    }
  });
  return es6_number_isFinite;
}
var _isFinite$1;
var hasRequired_isFinite$1;
function require_isFinite$1() {
  if (hasRequired_isFinite$1) return _isFinite$1;
  hasRequired_isFinite$1 = 1;
  requireEs6_number_isFinite();
  _isFinite$1 = require_core().Number.isFinite;
  return _isFinite$1;
}
var _isFinite;
var hasRequired_isFinite;
function require_isFinite() {
  if (hasRequired_isFinite) return _isFinite;
  hasRequired_isFinite = 1;
  _isFinite = { "default": require_isFinite$1(), __esModule: true };
  return _isFinite;
}
var _isFiniteExports = require_isFinite();
const _Number$isFinite = /* @__PURE__ */ getDefaultExportFromCjs(_isFiniteExports);
var es6_number_isNan = {};
var hasRequiredEs6_number_isNan;
function requireEs6_number_isNan() {
  if (hasRequiredEs6_number_isNan) return es6_number_isNan;
  hasRequiredEs6_number_isNan = 1;
  var $export = require_export();
  $export($export.S, "Number", {
    isNaN: function isNaN2(number) {
      return number != number;
    }
  });
  return es6_number_isNan;
}
var isNan$1;
var hasRequiredIsNan$1;
function requireIsNan$1() {
  if (hasRequiredIsNan$1) return isNan$1;
  hasRequiredIsNan$1 = 1;
  requireEs6_number_isNan();
  isNan$1 = require_core().Number.isNaN;
  return isNan$1;
}
var isNan;
var hasRequiredIsNan;
function requireIsNan() {
  if (hasRequiredIsNan) return isNan;
  hasRequiredIsNan = 1;
  isNan = { "default": requireIsNan$1(), __esModule: true };
  return isNan;
}
var isNanExports = requireIsNan();
const _Number$isNaN = /* @__PURE__ */ getDefaultExportFromCjs(isNanExports);
function verifyFloat(obj) {
  let t = typeof obj;
  if (t === "number" || t === "string") {
    let x = parseFloat("" + obj);
    if (!_Number$isNaN(x)) {
      return x;
    }
  }
  throw new Error(`Expected floating-point number, but received: ${_JSON$stringify(obj)}.`);
}
function verifyFiniteFloat(obj) {
  let x = verifyFloat(obj);
  if (_Number$isFinite(x)) {
    return x;
  }
  throw new Error(`Expected finite floating-point number, but received: ${x}.`);
}
function verifyFiniteNonNegativeFloat(obj) {
  let x = verifyFloat(obj);
  if (_Number$isFinite(x) && x >= 0) {
    return x;
  }
  throw new Error(`Expected finite non-negative floating-point number, but received: ${x}.`);
}
function verifyFinitePositiveFloat(obj) {
  let x = verifyFiniteFloat(obj);
  if (x > 0) {
    return x;
  }
  throw new Error(`Expected positive finite floating-point number, but received: ${x}.`);
}
function parseXYZ(out, obj, validator = verifyFloat) {
  verifyObject(obj);
  out[0] = out[1] = out[2] = 0;
  for (const key of _Object$keys(obj)) {
    switch (key) {
      case "x":
        out[0] = validator(obj[key]);
        break;
      case "y":
        out[1] = validator(obj[key]);
        break;
      case "z":
        out[2] = validator(obj[key]);
        break;
      default:
        throw new Error(`Expected object to have keys ['x', 'y', 'z'], but received: ${_JSON$stringify(obj)}.`);
    }
  }
  return out;
}
function parseFiniteVec(out, obj) {
  let length2 = out.length;
  if (!Array.isArray(obj) || obj.length !== length2) {
    throw new Error("Incompatible sizes");
  }
  for (let i = 0; i < length2; ++i) {
    if (!_Number$isFinite(parseFloat(obj[i]))) {
      throw new Error("Non-finite value.");
    }
  }
  for (let i = 0; i < length2; ++i) {
    out[i] = parseFloat(obj[i]);
  }
  return out;
}
function parseIntVec(out, obj) {
  let length2 = out.length;
  if (!Array.isArray(obj) || obj.length !== length2) {
    throw new Error("Incompatible sizes.");
  }
  for (let i = 0; i < length2; ++i) {
    let val = parseInt(obj[i], void 0);
    if (!_Number$isInteger(val)) {
      throw new Error("Non-integer value.");
    }
  }
  for (let i = 0; i < length2; ++i) {
    out[i] = parseInt(obj[i], void 0);
  }
  return out;
}
function stableStringify(x) {
  if (typeof x === "object") {
    if (x === null) {
      return "null";
    }
    if (Array.isArray(x)) {
      let s2 = "[";
      let size2 = x.length;
      let i2 = 0;
      if (i2 < size2) {
        s2 += stableStringify(x[i2]);
        while (++i2 < size2) {
          s2 += ",";
          s2 += stableStringify(x[i2]);
        }
      }
      s2 += "]";
      return s2;
    }
    let s = "{";
    let keys2 = _Object$keys(x).sort();
    let i = 0;
    let size = keys2.length;
    if (i < size) {
      let key = keys2[i];
      s += _JSON$stringify(key);
      s += ":";
      s += stableStringify(x[key]);
      while (++i < size) {
        s += ",";
        key = keys2[i];
        s += _JSON$stringify(key);
        s += ":";
        s += stableStringify(x[key]);
      }
    }
    s += "}";
    return s;
  }
  return _JSON$stringify(x);
}
function swapQuotes(x) {
  return x.replace(/['"]/g, (s) => {
    return s === '"' ? "'" : '"';
  });
}
function urlSafeStringifyString(x) {
  return swapQuotes(_JSON$stringify(swapQuotes(x)));
}
const URL_SAFE_COMMA = "_";
function urlSafeStringify(x) {
  if (typeof x === "object") {
    if (x === null) {
      return "null";
    }
    let toJSON = x["toJSON"];
    if (typeof toJSON === "function") {
      return urlSafeStringify(toJSON.call(x));
    }
    if (Array.isArray(x)) {
      let s2 = "[";
      let size = x.length;
      let i = 0;
      if (i < size) {
        s2 += urlSafeStringify(x[i]);
        while (++i < size) {
          s2 += URL_SAFE_COMMA;
          s2 += urlSafeStringify(x[i]);
        }
      }
      s2 += "]";
      return s2;
    }
    let s = "{";
    let keys2 = _Object$keys(x);
    let first = true;
    for (let key of keys2) {
      let value = x[key];
      if (value === void 0) {
        continue;
      }
      let valueString = urlSafeStringify(value);
      if (!valueString) {
        continue;
      }
      if (!first) {
        s += URL_SAFE_COMMA;
      } else {
        first = false;
      }
      s += urlSafeStringifyString(key);
      s += ":";
      s += valueString;
    }
    s += "}";
    return s;
  }
  if (typeof x === "string") {
    return urlSafeStringifyString(x);
  }
  return _JSON$stringify(x);
}
const SINGLE_QUOTE_STRING_PATTERN = /('(?:[^'\\]|(?:\\.))*')/;
const DOUBLE_QUOTE_STRING_PATTERN = /("(?:[^"\\]|(?:\\.))*")/;
const SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN = new RegExp(`${SINGLE_QUOTE_STRING_PATTERN.source}|${DOUBLE_QUOTE_STRING_PATTERN.source}`);
const DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN = new RegExp(`${DOUBLE_QUOTE_STRING_PATTERN.source}|${SINGLE_QUOTE_STRING_PATTERN.source}`);
const DOUBLE_QUOTE_PATTERN = /^((?:[^"'\\]|(?:\\[^']))*)("|\\')/;
const SINGLE_QUOTE_PATTERN = /^((?:[^"'\\]|(?:\\.))*)'/;
function convertStringLiteral(x, quoteInitial, quoteReplace, quoteSearch) {
  if (x.length >= 2 && x.charAt(0) === quoteInitial && x.charAt(x.length - 1) === quoteInitial) {
    let inner = x.substr(1, x.length - 2);
    let s = quoteReplace;
    while (inner.length > 0) {
      let m = inner.match(quoteSearch);
      if (m === null) {
        s += inner;
        break;
      }
      s += m[1];
      if (m[2] === quoteReplace) {
        s += "\\";
        s += quoteReplace;
      } else {
        s += quoteInitial;
      }
      inner = inner.substr(m.index + m[0].length);
    }
    s += quoteReplace;
    return s;
  }
  return x;
}
function normalizeStringLiteral(x) {
  return convertStringLiteral(x, "'", '"', DOUBLE_QUOTE_PATTERN);
}
function convertJsonHelper(x, desiredCommaChar, desiredQuoteChar) {
  const commaSearch = /[&_,]/g;
  let quoteInitial;
  let quoteSearch;
  let stringLiteralPattern;
  if (desiredQuoteChar === '"') {
    quoteInitial = "'";
    quoteSearch = DOUBLE_QUOTE_PATTERN;
    stringLiteralPattern = SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN;
  } else {
    quoteInitial = '"';
    quoteSearch = SINGLE_QUOTE_PATTERN;
    stringLiteralPattern = DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN;
  }
  let s = "";
  while (x.length > 0) {
    let m = x.match(stringLiteralPattern);
    let before;
    let replacement;
    if (m === null) {
      before = x;
      x = "";
      replacement = "";
    } else {
      before = x.substr(0, m.index);
      x = x.substr(m.index + m[0].length);
      let originalString = m[1];
      if (originalString !== void 0) {
        replacement = convertStringLiteral(originalString, quoteInitial, desiredQuoteChar, quoteSearch);
      } else {
        replacement = m[2];
      }
    }
    s += before.replace(commaSearch, desiredCommaChar);
    s += replacement;
  }
  return s;
}
function urlSafeToJSON(x) {
  return convertJsonHelper(x, ",", '"');
}
function jsonToUrlSafe(x) {
  return convertJsonHelper(x, "_", "'");
}
function urlSafeParse(x) {
  return JSON.parse(urlSafeToJSON(x));
}
function pythonLiteralToJSON(x) {
  let s = "";
  while (x.length > 0) {
    let m = x.match(SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN);
    let before;
    let replacement;
    if (m === null) {
      before = x;
      x = "";
      replacement = "";
    } else {
      before = x.substr(0, m.index);
      x = x.substr(m.index + m[0].length);
      let singleQuoteString = m[1];
      if (singleQuoteString !== void 0) {
        replacement = normalizeStringLiteral(singleQuoteString);
      } else {
        replacement = m[2];
      }
    }
    s += before.replace(/\(/g, "[").replace(/\)/g, "]").replace("True", "true").replace("False", "false").replace(/,\s*([\}\]])/g, "$1");
    s += replacement;
  }
  return s;
}
function pythonLiteralParse(x) {
  return JSON.parse(pythonLiteralToJSON(x));
}
function expectArray(x, length2) {
  if (!Array.isArray(x)) {
    throw new Error(`Expected array, but received: ${_JSON$stringify(x)}.`);
  }
  if (length2 !== void 0 && x.length !== length2) {
    throw new Error(`Expected array of length ${length2}, but received: ${_JSON$stringify(x)}.`);
  }
  return x;
}
function parseArray(x, parseElement) {
  if (!Array.isArray(x)) {
    throw new Error(`Expected array, but received: ${_JSON$stringify(x)}.`);
  }
  return x.map(parseElement);
}
function parseFixedLengthArray(out, obj, parseElement) {
  const length2 = out.length;
  if (!Array.isArray(obj) || obj.length !== length2) {
    throw new Error(`Expected length ${length2} array, but received: ${_JSON$stringify(obj)}.`);
  }
  for (let i = 0; i < length2; ++i) {
    out[i] = parseElement(obj[i], i);
  }
  return out;
}
function verifyObject(obj) {
  if (typeof obj !== "object" || obj == null || Array.isArray(obj)) {
    throw new Error(`Expected JSON object, but received: ${_JSON$stringify(obj)}.`);
  }
  return obj;
}
function verifyInt(obj) {
  let result = parseInt(obj, 10);
  if (!_Number$isInteger(result)) {
    throw new Error(`Expected integer, but received: ${_JSON$stringify(obj)}.`);
  }
  return result;
}
function verifyPositiveInt(obj) {
  let result = verifyInt(obj);
  if (result <= 0) {
    throw new Error(`Expected positive integer, but received: ${result}.`);
  }
  return result;
}
function verifyNonnegativeInt(obj) {
  const result = verifyInt(obj);
  if (result < 0) {
    throw new Error(`Expected non-negative integer, but received: ${result}.`);
  }
  return result;
}
function verifyMapKey(obj, map2) {
  let result = map2.get(obj);
  if (result === void 0) {
    throw new Error(`Expected one of ${_JSON$stringify(_Array$from(map2.keys()))}, but received: ${_JSON$stringify(obj)}.`);
  }
  return result;
}
function verifyString(obj) {
  if (typeof obj !== "string") {
    throw new Error(`Expected string, but received: ${_JSON$stringify(obj)}.`);
  }
  return obj;
}
function verifyOptionalString(obj) {
  if (obj === void 0) {
    return void 0;
  }
  return verifyString(obj);
}
function verifyOptionalInt(obj) {
  if (obj === void 0) {
    return void 0;
  }
  return verifyInt(obj);
}
function verifyOptionalBoolean(obj) {
  if (obj === void 0) {
    return void 0;
  }
  if (typeof obj === "boolean") {
    return obj;
  } else if (obj === "true") {
    return true;
  } else if (obj === "false") {
    return false;
  } else {
    throw new Error(`Expected string or boolean but received: ${_JSON$stringify(obj)}`);
  }
}
function valueOr(value, defaultValue) {
  return value === void 0 ? defaultValue : value;
}
function verifyObjectProperty(obj, propertyName, validator) {
  let value = Object.prototype.hasOwnProperty.call(obj, propertyName) ? obj[propertyName] : void 0;
  try {
    return validator(value);
  } catch (parseError) {
    throw new Error(`Error parsing ${_JSON$stringify(propertyName)} property: ${parseError.message}`);
  }
}
function verifyOptionalObjectProperty(obj, propertyName, validator, defaultValue) {
  return verifyObjectProperty(obj, propertyName, (x) => x === void 0 ? defaultValue : validator(x));
}
function verifyObjectAsMap(obj, validator) {
  verifyObject(obj);
  let map2 = new _Map();
  for (let key of _Object$keys(obj)) {
    try {
      map2.set(key, validator(obj[key]));
    } catch (parseError) {
      throw new Error(`Error parsing value associated with key ${_JSON$stringify(key)}: ${parseError.message}`);
    }
  }
  return map2;
}
function verifyFloat01(obj) {
  if (typeof obj !== "number" || !_Number$isFinite(obj) || obj < 0 || obj > 1) {
    throw new Error(`Expected floating point number in [0,1], but received: ${_JSON$stringify(obj)}.`);
  }
  return obj;
}
function parseQueryStringParameters(queryString) {
  if (queryString === "") {
    return {};
  }
  if (queryString.startsWith("{")) {
    return urlSafeParse(queryString);
  } else {
    let result = {};
    let parts = queryString.split(/[&;]/);
    for (let part of parts) {
      let m = part.match(/^([^=&;]+)=([^&;]*)$/);
      if (m === null) {
        throw new Error(`Invalid query string part: ${_JSON$stringify(part)}.`);
      }
      result[m[1]] = decodeURIComponent(m[2]);
    }
    return result;
  }
}
function unparseQueryStringParameters(parameters) {
  if (parameters === void 0) return "";
  const keys2 = _Object$keys(parameters);
  if (keys2.length === 0) return "";
  if (keys2.some((key) => typeof parameters[key] !== "string")) {
    return _JSON$stringify(parameters);
  }
  return keys2.map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(parameters[key])}`).join("&");
}
function verifyEnumString(obj, enumType) {
  if (typeof obj === "string" && obj.match(/^[a-zA-Z]/) !== null) {
    obj = obj.toUpperCase();
    if (enumType.hasOwnProperty(obj)) {
      return enumType[obj];
    }
  }
  throw new Error(`Invalid enum value: ${_JSON$stringify(obj)}.`);
}
function verify3dVec(obj) {
  return parseFixedLengthArray(create$3(), obj, verifyFiniteFloat);
}
function verify3dScale(obj) {
  return parseFixedLengthArray(create$3(), obj, verifyFinitePositiveFloat);
}
function verify3dDimensions(obj) {
  return parseFixedLengthArray(create$3(), obj, verifyPositiveInt);
}
function verifyStringArray(a) {
  if (!Array.isArray(a)) {
    throw new Error(`Expected array, received: ${_JSON$stringify(a)}.`);
  }
  for (let x of a) {
    if (typeof x !== "string") {
      throw new Error(`Expected string, received: ${_JSON$stringify(x)}.`);
    }
  }
  return a;
}
function verifyIntegerArray(a) {
  if (!Array.isArray(a)) {
    throw new Error(`Expected array, received: ${_JSON$stringify(a)}.`);
  }
  for (let x of a) {
    if (!_Number$isInteger(x)) {
      throw new Error(`Expected integer, received: ${_JSON$stringify(x)}.`);
    }
  }
  return a;
}
function verifyBoolean(x) {
  if (typeof x !== "boolean") {
    throw new Error(`Expected boolean, received: ${_JSON$stringify(x)}`);
  }
  return x;
}
function emptyToUndefined(x) {
  for (const _ in x) {
    return x;
  }
  return void 0;
}
const json = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  emptyToUndefined,
  expectArray,
  jsonToUrlSafe,
  normalizeStringLiteral,
  parseArray,
  parseFiniteVec,
  parseFixedLengthArray,
  parseIntVec,
  parseQueryStringParameters,
  parseXYZ,
  pythonLiteralParse,
  pythonLiteralToJSON,
  stableStringify,
  unparseQueryStringParameters,
  urlSafeParse,
  urlSafeStringify,
  urlSafeStringifyString,
  urlSafeToJSON,
  valueOr,
  verify3dDimensions,
  verify3dScale,
  verify3dVec,
  verifyBoolean,
  verifyEnumString,
  verifyFiniteFloat,
  verifyFiniteNonNegativeFloat,
  verifyFinitePositiveFloat,
  verifyFloat,
  verifyFloat01,
  verifyInt,
  verifyIntegerArray,
  verifyMapKey,
  verifyNonnegativeInt,
  verifyObject,
  verifyObjectAsMap,
  verifyObjectProperty,
  verifyOptionalBoolean,
  verifyOptionalInt,
  verifyOptionalObjectProperty,
  verifyOptionalString,
  verifyPositiveInt,
  verifyString,
  verifyStringArray
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2021 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const denormMin = 2 ** -1074;
const float64Buf = new Float64Array(1);
const uint32Buf = new Uint32Array(float64Buf.buffer);
function nextAfterFloat64(x, y) {
  if (isNaN(x) || isNaN(y)) return NaN;
  if (x === y) return y;
  if (x === 0) {
    return y < 0 ? -5e-324 : denormMin;
  }
  float64Buf[0] = x;
  const lowIndex = ENDIANNESS === Endianness.LITTLE ? 0 : 1;
  const highIndex = 1 - lowIndex;
  if (y > x === x > 0) {
    if (uint32Buf[lowIndex] === 4294967295) {
      uint32Buf[lowIndex] = 0;
      uint32Buf[highIndex] += 1;
    } else {
      uint32Buf[lowIndex] += 1;
    }
  } else {
    if (uint32Buf[lowIndex] === 0) {
      uint32Buf[lowIndex] = 4294967295;
      uint32Buf[highIndex] -= 1;
    } else {
      uint32Buf[lowIndex] -= 1;
    }
  }
  return float64Buf[0];
}
var es6_math_imul = {};
var hasRequiredEs6_math_imul;
function requireEs6_math_imul() {
  if (hasRequiredEs6_math_imul) return es6_math_imul;
  hasRequiredEs6_math_imul = 1;
  var $export = require_export();
  var $imul = Math.imul;
  $export($export.S + $export.F * require_fails()(function() {
    return $imul(4294967295, 5) != -5 || $imul.length != 2;
  }), "Math", {
    imul: function imul2(x, y) {
      var UINT16 = 65535;
      var xn = +x;
      var yn = +y;
      var xl = UINT16 & xn;
      var yl = UINT16 & yn;
      return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }
  });
  return es6_math_imul;
}
var imul$1;
var hasRequiredImul$1;
function requireImul$1() {
  if (hasRequiredImul$1) return imul$1;
  hasRequiredImul$1 = 1;
  requireEs6_math_imul();
  imul$1 = require_core().Math.imul;
  return imul$1;
}
var imul;
var hasRequiredImul;
function requireImul() {
  if (hasRequiredImul) return imul;
  hasRequiredImul = 1;
  imul = { "default": requireImul$1(), __esModule: true };
  return imul;
}
var imulExports = requireImul();
const _Math$imul = /* @__PURE__ */ getDefaultExportFromCjs(imulExports);
var es6_math_log2 = {};
var hasRequiredEs6_math_log2;
function requireEs6_math_log2() {
  if (hasRequiredEs6_math_log2) return es6_math_log2;
  hasRequiredEs6_math_log2 = 1;
  var $export = require_export();
  $export($export.S, "Math", {
    log2: function log22(x) {
      return Math.log(x) / Math.LN2;
    }
  });
  return es6_math_log2;
}
var log2$1;
var hasRequiredLog2$1;
function requireLog2$1() {
  if (hasRequiredLog2$1) return log2$1;
  hasRequiredLog2$1 = 1;
  requireEs6_math_log2();
  log2$1 = require_core().Math.log2;
  return log2$1;
}
var log2;
var hasRequiredLog2;
function requireLog2() {
  if (hasRequiredLog2) return log2;
  hasRequiredLog2 = 1;
  log2 = { "default": requireLog2$1(), __esModule: true };
  return log2;
}
var log2Exports = requireLog2();
const _Math$log$1 = /* @__PURE__ */ getDefaultExportFromCjs(log2Exports);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const randomTempBuffer = new Uint32Array(2);
const trueBase = 4294967296;
let stringConversionData = [];
for (let base = 2; base <= 36; ++base) {
  let lowDigits = Math.floor(32 / _Math$log$1(base));
  let lowBase = Math.pow(base, lowDigits);
  let patternString = `^[0-${String.fromCharCode("0".charCodeAt(0) + Math.min(9, base - 1))}`;
  if (base > 10) {
    patternString += `a-${String.fromCharCode("a".charCodeAt(0) + base - 11)}`;
    patternString += `A-${String.fromCharCode("A".charCodeAt(0) + base - 11)}`;
  }
  let maxDigits = Math.ceil(64 / _Math$log$1(base));
  patternString += `]{1,${maxDigits}}$`;
  let pattern = new RegExp(patternString);
  stringConversionData[base] = { lowDigits, lowBase, pattern };
}
function uint32MultiplyHigh(a, b) {
  a >>>= 0;
  b >>>= 0;
  const a00 = a & 65535, a16 = a >>> 16;
  const b00 = b & 65535, b16 = b >>> 16;
  let c00 = a00 * b00;
  let c16 = (c00 >>> 16) + a16 * b00;
  let c32 = c16 >>> 16;
  c16 = (c16 & 65535) + a00 * b16;
  c32 += c16 >>> 16;
  let c48 = c32 >>> 16;
  c32 = (c32 & 65535) + a16 * b16;
  c48 += c32 >>> 16;
  return ((c48 & 65535) << 16 | c32 & 65535) >>> 0;
}
class Uint64 {
  constructor(low = 0, high = 0) {
    this.low = low;
    this.high = high;
  }
  clone() {
    return new Uint64(this.low, this.high);
  }
  assign(x) {
    this.low = x.low;
    this.high = x.high;
  }
  toString(base = 10) {
    let vLow = this.low, vHigh = this.high;
    if (vHigh === 0) {
      return vLow.toString(base);
    }
    vHigh *= trueBase;
    var _stringConversionData = stringConversionData[base];
    let lowBase = _stringConversionData.lowBase, lowDigits = _stringConversionData.lowDigits;
    let vHighExtra = vHigh % lowBase;
    vHigh = Math.floor(vHigh / lowBase);
    vLow += vHighExtra;
    vHigh += Math.floor(vLow / lowBase);
    vLow = vLow % lowBase;
    let vLowStr = vLow.toString(base);
    return vHigh.toString(base) + "0".repeat(lowDigits - vLowStr.length) + vLowStr;
  }
  /**
   * Returns true if a is strictly less than b.
   */
  static less(a, b) {
    return a.high < b.high || a.high === b.high && a.low < b.low;
  }
  /**
   * Returns a negative number if a is strictly less than b, 0 if a is equal to b, or a positive
   * number if a is strictly greater than b.
   */
  static compare(a, b) {
    return a.high - b.high || a.low - b.low;
  }
  static equal(a, b) {
    return a.low === b.low && a.high === b.high;
  }
  static min(a, b) {
    return Uint64.less(a, b) ? a : b;
  }
  static max(a, b) {
    return Uint64.less(a, b) ? b : a;
  }
  static random() {
    crypto.getRandomValues(randomTempBuffer);
    return new Uint64(randomTempBuffer[0], randomTempBuffer[1]);
  }
  tryParseString(s, base = 10) {
    var _stringConversionData2 = stringConversionData[base];
    const lowDigits = _stringConversionData2.lowDigits, lowBase = _stringConversionData2.lowBase, pattern = _stringConversionData2.pattern;
    if (!pattern.test(s)) {
      return false;
    }
    if (s.length <= lowDigits) {
      this.low = parseInt(s, base);
      this.high = 0;
      return true;
    }
    const splitPoint = s.length - lowDigits;
    const lowPrime = parseInt(s.substr(splitPoint), base);
    const highPrime = parseInt(s.substr(0, splitPoint), base);
    let high, low;
    if (lowBase === trueBase) {
      high = highPrime;
      low = lowPrime;
    } else {
      const highRemainder = _Math$imul(highPrime, lowBase) >>> 0;
      high = uint32MultiplyHigh(highPrime, lowBase) + (_Math$imul(Math.floor(highPrime / trueBase), lowBase) >>> 0);
      low = lowPrime + highRemainder;
      if (low >= trueBase) {
        ++high;
        low -= trueBase;
      }
    }
    if (low >>> 0 !== low || high >>> 0 !== high) {
      return false;
    }
    this.low = low;
    this.high = high;
    return true;
  }
  parseString(s, base = 10) {
    if (!this.tryParseString(s, base)) {
      throw new Error(`Failed to parse string as uint64 value: ${_JSON$stringify(s)}.`);
    }
    return this;
  }
  static parseString(s, base = 10) {
    let x = new Uint64();
    return x.parseString(s, base);
  }
  valid() {
    let low = this.low, high = this.high;
    return low >>> 0 === low && high >>> 0 === high;
  }
  toJSON() {
    return this.toString();
  }
  static lshift(out, input, bits) {
    const low = input.low, high = input.high;
    if (bits === 0) {
      out.low = low;
      out.high = high;
    } else if (bits < 32) {
      out.low = low << bits;
      out.high = high << bits | low >>> 32 - bits;
    } else {
      out.low = 0;
      out.high = low << bits - 32;
    }
    return out;
  }
  static rshift(out, input, bits) {
    const low = input.low, high = input.high;
    if (bits === 0) {
      out.low = low;
      out.high = high;
    } else if (bits < 32) {
      out.low = low >>> bits | high << 32 - bits;
      out.high = high >>> bits;
    } else {
      out.low = high >>> bits - 32;
      out.high = 0;
    }
    return out;
  }
  static or(out, a, b) {
    out.low = a.low | b.low;
    out.high = a.high | b.high;
    return out;
  }
  static xor(out, a, b) {
    out.low = a.low ^ b.low;
    out.high = a.high ^ b.high;
    return out;
  }
  static and(out, a, b) {
    out.low = a.low & b.low;
    out.high = a.high & b.high;
    return out;
  }
  static add(out, a, b) {
    let lowSum = a.low + b.low;
    let highSum = a.high + b.high;
    const low = lowSum >>> 0;
    if (low !== lowSum) highSum += 1;
    out.low = low;
    out.high = highSum >>> 0;
    return out;
  }
  static addUint32(out, a, b) {
    let lowSum = a.low + b;
    let highSum = a.high;
    const low = lowSum >>> 0;
    if (low !== lowSum) highSum += 1;
    out.low = low;
    out.high = highSum >>> 0;
    return out;
  }
  static decrement(out, input) {
    let low = input.low, high = input.high;
    if (low === 0) {
      high -= 1;
    }
    out.low = low - 1 >>> 0;
    out.high = high >>> 0;
    return out;
  }
  static increment(out, input) {
    let low = input.low, high = input.high;
    if (low === 4294967295) high += 1;
    out.low = low + 1 >>> 0;
    out.high = high >>> 0;
    return out;
  }
  static subtract(out, a, b) {
    let lowSum = a.low - b.low;
    let highSum = a.high - b.high;
    const low = lowSum >>> 0;
    if (low !== lowSum) highSum -= 1;
    out.low = low;
    out.high = highSum >>> 0;
    return out;
  }
  static absDifference(out, a, b) {
    return Uint64.less(a, b) ? Uint64.subtract(out, b, a) : Uint64.subtract(out, a, b);
  }
  static multiplyUint32(out, a, b) {
    const low = a.low, high = a.high;
    out.low = _Math$imul(low, b) >>> 0;
    out.high = _Math$imul(high, b) + uint32MultiplyHigh(low, b) >>> 0;
    return out;
  }
  static lowMask(out, bits) {
    if (bits === 0) {
      out.high = out.low = 0;
    } else if (bits <= 32) {
      out.high = 0;
      out.low = 4294967295 >>> 32 - bits;
    } else {
      out.high = 4294967295 >>> bits - 32;
      out.low = 4294967295;
    }
    return out;
  }
  toNumber() {
    return this.low + this.high * 4294967296;
  }
  setFromNumber(value) {
    value = Math.round(value);
    if (value < 0) {
      this.low = this.high = 0;
    } else if (value >= 18446744073709552e3) {
      this.low = this.high = 4294967295;
    } else {
      this.low = value % 4294967296;
      this.high = Math.floor(value / 4294967296);
    }
  }
}
Uint64.ZERO = new Uint64(0, 0);
Uint64.ONE = new Uint64(1, 0);
const uint64 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Uint64
}, Symbol.toStringTag, { value: "Module" }));
const defaultDataTypeRange = {
  [DataType.UINT8]: [0, 255],
  [DataType.INT8]: [-128, 127],
  [DataType.UINT16]: [0, 65535],
  [DataType.INT16]: [-32768, 32767],
  [DataType.UINT32]: [0, 4294967295],
  [DataType.INT32]: [-2147483648, 2147483647],
  [DataType.UINT64]: [Uint64.ZERO, new Uint64(4294967295, 4294967295)],
  [DataType.FLOAT32]: [0, 1]
};
function computeInvlerp(range, value) {
  if (typeof value === "number") {
    const minValue = range[0];
    const maxValue = range[1];
    return (value - minValue) / (maxValue - minValue);
  } else {
    const minValue = range[0];
    const maxValue = range[1];
    let numerator;
    if (Uint64.compare(value, minValue) < 0) {
      numerator = -Uint64.subtract(tempUint64$3, minValue, value).toNumber();
    } else {
      numerator = Uint64.subtract(tempUint64$3, value, minValue).toNumber();
    }
    let denominator = Uint64.absDifference(tempUint64$3, maxValue, minValue).toNumber();
    if (Uint64.compare(minValue, maxValue) > 0) denominator *= -1;
    return numerator / denominator;
  }
}
function computeLerp(range, dataType, value) {
  if (typeof range[0] === "number") {
    const minValue = range[0];
    const maxValue = range[1];
    let result = minValue * (1 - value) + maxValue * value;
    if (dataType !== DataType.FLOAT32) {
      const dataTypeRange = defaultDataTypeRange[dataType];
      result = Math.round(result);
      result = Math.max(dataTypeRange[0], result);
      result = Math.min(dataTypeRange[1], result);
    }
    return result;
  } else {
    let minValue = range[0];
    let maxValue = range[1];
    if (Uint64.compare(minValue, maxValue) > 0) {
      var _ref = [maxValue, minValue];
      minValue = _ref[0];
      maxValue = _ref[1];
      value = 1 - value;
    }
    const scalar = Uint64.subtract(tempUint64$3, maxValue, minValue).toNumber();
    const result = new Uint64();
    if (value <= 0) {
      tempUint64$3.setFromNumber(scalar * -value);
      Uint64.subtract(result, minValue, Uint64.min(tempUint64$3, minValue));
    } else if (value >= 1) {
      tempUint64$3.setFromNumber(scalar * (value - 1));
      Uint64.add(result, maxValue, tempUint64$3);
      if (Uint64.less(result, maxValue)) {
        result.low = result.high = 4294967295;
      }
    } else {
      tempUint64$3.setFromNumber(scalar * value);
      Uint64.add(result, minValue, tempUint64$3);
      if (Uint64.less(result, minValue)) {
        result.low = result.high = 4294967295;
      }
    }
    return result;
  }
}
function clampToInterval(range, value) {
  if (typeof value === "number") {
    return Math.min(Math.max(range[0], value), range[1]);
  } else {
    return Uint64.min(Uint64.max(range[0], value), range[1]);
  }
}
function getClampedInterval(bounds, range) {
  return [clampToInterval(bounds, range[0]), clampToInterval(bounds, range[1])];
}
function validateDataTypeInterval(interval) {
  if (dataTypeCompare(interval[0], interval[1]) <= 0) return interval;
  throw new Error(`Invalid interval: [${interval[0]}, ${interval[1]}]`);
}
function normalizeDataTypeInterval(interval) {
  if (dataTypeCompare(interval[0], interval[1]) <= 0) return interval;
  return [interval[1], interval[0]];
}
function dataTypeCompare(a, b) {
  if (typeof a === "number") {
    return a - b;
  } else {
    return Uint64.compare(a, b);
  }
}
const tempUint64$3 = new Uint64();
const temp2Uint64 = new Uint64();
function getClosestEndpoint(range, value) {
  if (typeof value === "number") {
    return Math.abs(value - range[0]) < Math.abs(value - range[1]) ? 0 : 1;
  } else {
    return Uint64.less(Uint64.absDifference(tempUint64$3, range[0], value), Uint64.absDifference(temp2Uint64, range[1], value)) ? 0 : 1;
  }
}
function parseDataTypeValue(dataType, x) {
  let s;
  if (typeof x !== "string") {
    s = "" + x;
  } else {
    s = x;
  }
  switch (dataType) {
    case DataType.UINT64:
      return Uint64.parseString(s);
    case DataType.FLOAT32: {
      const value = parseFloat(s);
      if (!_Number$isFinite(value)) {
        throw new Error(`Invalid float32 value: ${_JSON$stringify(s)}`);
      }
      return value;
    }
    default: {
      const value = parseInt(s);
      const dataTypeRange = defaultDataTypeRange[dataType];
      if (!_Number$isInteger(value) || value < dataTypeRange[0] || value > dataTypeRange[1]) {
        throw new Error(`Invalid ${DataType[dataType].toLowerCase()} value: ${_JSON$stringify(s)}`);
      }
      return value;
    }
  }
}
function parseDataTypeInterval(obj, dataType) {
  return parseFixedLengthArray(new Array(2), obj, (x) => parseDataTypeValue(dataType, x));
}
function dataTypeIntervalEqual(dataType, a, b) {
  if (dataType === DataType.UINT64) {
    return Uint64.equal(a[0], b[0]) && Uint64.equal(a[1], b[1]);
  } else {
    return a[0] === b[0] && a[1] === b[1];
  }
}
function dataTypeIntervalToJson(range, dataType, defaultRange = defaultDataTypeRange[dataType]) {
  if (dataTypeIntervalEqual(dataType, range, defaultRange)) return void 0;
  if (dataType === DataType.UINT64) {
    return [range[0].toString(), range[1].toString()];
  } else {
    return range;
  }
}
function dataTypeValueNextAfter(dataType, value, sign2) {
  switch (dataType) {
    case DataType.FLOAT32:
      return nextAfterFloat64(value, sign2 * Infinity);
    case DataType.UINT64:
      const v = value;
      if (sign2 === -1) {
        if (v.low === 0 && v.high === 0) return v;
        return Uint64.decrement(new Uint64(), v);
      } else {
        if (v.low === 4294967295 && v.high === 4294967295) return v;
        return Uint64.increment(new Uint64(), v);
      }
    default: {
      const range = defaultDataTypeRange[dataType];
      return Math.max(range[0], Math.min(range[1], value + sign2));
    }
  }
}
function getIntervalBoundsEffectiveOffset(dataType, interval) {
  switch (dataType) {
    case DataType.FLOAT32:
      return 0;
    case DataType.UINT64:
      return 0.5 / Uint64.absDifference(tempUint64$3, interval[0], interval[1]).toNumber();
    default:
      return 0.5 / Math.abs(interval[0] - interval[1]);
  }
}
function getIntervalBoundsEffectiveFraction(dataType, interval) {
  switch (dataType) {
    case DataType.FLOAT32:
      return 1;
    case DataType.UINT64: {
      const diff = Uint64.absDifference(tempUint64$3, interval[0], interval[1]).toNumber();
      return diff / (diff + 1);
    }
    default: {
      const diff = Math.abs(interval[0] - interval[1]);
      return diff / (diff + 1);
    }
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getRandomHexString(numBits = 128) {
  const numValues = Math.ceil(numBits / 32);
  const data = new Uint32Array(numValues);
  crypto.getRandomValues(data);
  let s = "";
  for (let i = 0; i < numValues; ++i) {
    s += ("00000000" + data[i].toString(16)).slice(-8);
  }
  return s;
}
function getRandomValues(array) {
  let byteArray = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
  const blockSize = 65536;
  for (let i = 0, length2 = byteArray.length; i < length2; i += blockSize) {
    crypto.getRandomValues(byteArray.subarray(i, Math.min(length2, i + blockSize)));
  }
  return array;
}
function getRandomUint32() {
  const data = new Uint32Array(1);
  crypto.getRandomValues(data);
  return data[0];
}
class AnnotationReference extends RefCounted {
  constructor(id) {
    super();
    this.id = id;
    this.changed = new NullarySignal();
  }
  addRef() {
    return super.addRef();
  }
  dispose() {
    super.dispose();
  }
}
var AnnotationType;
(function(AnnotationType2) {
  AnnotationType2[AnnotationType2["POINT"] = 0] = "POINT";
  AnnotationType2[AnnotationType2["LINE"] = 1] = "LINE";
  AnnotationType2[AnnotationType2["AXIS_ALIGNED_BOUNDING_BOX"] = 2] = "AXIS_ALIGNED_BOUNDING_BOX";
  AnnotationType2[AnnotationType2["ELLIPSOID"] = 3] = "ELLIPSOID";
  AnnotationType2[AnnotationType2["SPHERE"] = 4] = "SPHERE";
})(AnnotationType || (AnnotationType = {}));
const annotationTypes = [AnnotationType.POINT, AnnotationType.LINE, AnnotationType.AXIS_ALIGNED_BOUNDING_BOX, AnnotationType.ELLIPSOID, AnnotationType.SPHERE];
const annotationPropertyTypeHandlers = {
  "rgb": {
    serializedBytes() {
      return 3;
    },
    alignment() {
      return 1;
    },
    serializeCode(property, offset) {
      return `dv.setUint16(${offset}, ${property}, true);dv.setUint8(${offset} + 2, ${property} >>> 16);`;
    },
    deserializeCode(property, offset) {
      return `${property} = dv.getUint16(${offset}, true) | (dv.getUint8(${offset} + 2) << 16);`;
    },
    deserializeJson(obj) {
      return packColor(parseRGBColorSpecification(obj));
    },
    serializeJson(value) {
      return serializeColor(unpackRGB(value));
    }
  },
  "rgba": {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 1;
    },
    serializeCode(property, offset) {
      return `dv.setUint32(${offset}, ${property}, true);`;
    },
    deserializeCode(property, offset) {
      return `${property} = dv.getUint32(${offset}, true);`;
    },
    deserializeJson(obj) {
      return packColor(parseRGBAColorSpecification(obj));
    },
    serializeJson(value) {
      return serializeColor(unpackRGBA(value));
    }
  },
  "float32": {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 4;
    },
    serializeCode(property, offset) {
      return `dv.setFloat32(${offset}, ${property}, isLittleEndian);`;
    },
    deserializeCode(property, offset) {
      return `${property} = dv.getFloat32(${offset}, isLittleEndian);`;
    },
    deserializeJson(obj) {
      return verifyFloat(obj);
    },
    serializeJson(value) {
      return value;
    }
  },
  "uint32": {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 4;
    },
    serializeCode(property, offset) {
      return `dv.setUint32(${offset}, ${property}, isLittleEndian);`;
    },
    deserializeCode(property, offset) {
      return `${property} = dv.getUint32(${offset}, isLittleEndian);`;
    },
    deserializeJson(obj) {
      return verifyInt(obj);
    },
    serializeJson(value) {
      return value;
    }
  },
  "int32": {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 4;
    },
    serializeCode(property, offset) {
      return `dv.setInt32(${offset}, ${property}, isLittleEndian);`;
    },
    deserializeCode(property, offset) {
      return `${property} = dv.getInt32(${offset}, isLittleEndian);`;
    },
    deserializeJson(obj) {
      return verifyInt(obj);
    },
    serializeJson(value) {
      return value;
    }
  },
  "uint16": {
    serializedBytes() {
      return 2;
    },
    alignment() {
      return 2;
    },
    serializeCode(property, offset) {
      return `dv.setUint16(${offset}, ${property}, isLittleEndian);`;
    },
    deserializeCode(property, offset) {
      return `${property} = dv.getUint16(${offset}, isLittleEndian);`;
    },
    deserializeJson(obj) {
      return verifyInt(obj);
    },
    serializeJson(value) {
      return value;
    }
  },
  "int16": {
    serializedBytes() {
      return 2;
    },
    alignment() {
      return 2;
    },
    serializeCode(property, offset) {
      return `dv.setInt16(${offset}, ${property}, isLittleEndian);`;
    },
    deserializeCode(property, offset) {
      return `${property} = dv.getInt16(${offset}, isLittleEndian);`;
    },
    deserializeJson(obj) {
      return verifyInt(obj);
    },
    serializeJson(value) {
      return value;
    }
  },
  "uint8": {
    serializedBytes() {
      return 1;
    },
    alignment() {
      return 1;
    },
    serializeCode(property, offset) {
      return `dv.setUint8(${offset}, ${property});`;
    },
    deserializeCode(property, offset) {
      return `${property} = dv.getUint8(${offset});`;
    },
    deserializeJson(obj) {
      return verifyInt(obj);
    },
    serializeJson(value) {
      return value;
    }
  },
  "int8": {
    serializedBytes() {
      return 2;
    },
    alignment() {
      return 1;
    },
    serializeCode(property, offset) {
      return `dv.setInt8(${offset}, ${property});`;
    },
    deserializeCode(property, offset) {
      return `${property} = dv.getInt8(${offset});`;
    },
    deserializeJson(obj) {
      return verifyInt(obj);
    },
    serializeJson(value) {
      return value;
    }
  }
};
const MAX_BUFFER_STRIDE = 255;
function getPropertyOffsets(rank, firstGroupInitialOffset, propertySpecs) {
  let serializedBytes = 0;
  const numProperties = propertySpecs.length;
  const permutation = new Array(numProperties);
  const propertyGroupBytes = [];
  for (let i = 0; i < numProperties; ++i) {
    permutation[i] = i;
  }
  const getAlignment = (i) => annotationPropertyTypeHandlers[propertySpecs[i].type].alignment(rank);
  permutation.sort((i, j) => getAlignment(j) - getAlignment(i));
  let propertyGroupIndex = 0;
  const offsets = new Array(numProperties);
  let propertyGroupOffset = firstGroupInitialOffset;
  const nextPropertyGroup = () => {
    propertyGroupOffset += (4 - propertyGroupOffset % 4) % 4;
    serializedBytes += propertyGroupOffset;
    propertyGroupBytes[propertyGroupIndex] = propertyGroupOffset;
    propertyGroupOffset = 0;
    ++propertyGroupIndex;
  };
  for (let outputIndex = 0; outputIndex < numProperties; ++outputIndex) {
    const propertyIndex = permutation[outputIndex];
    const spec = propertySpecs[propertyIndex];
    const handler = annotationPropertyTypeHandlers[spec.type];
    const numBytes = handler.serializedBytes(rank);
    const alignment = handler.alignment(rank);
    const alignmentOffset = (alignment - propertyGroupOffset % alignment) % alignment;
    const newStartOffset = propertyGroupOffset + alignmentOffset;
    const newEndOffset = newStartOffset + numBytes;
    const newAlignedEndOffset = newEndOffset + (4 - newEndOffset % 4) % 4;
    if (newAlignedEndOffset <= MAX_BUFFER_STRIDE) {
      propertyGroupOffset += alignmentOffset;
    } else {
      nextPropertyGroup();
    }
    offsets[propertyIndex] = { offset: propertyGroupOffset, group: propertyGroupIndex };
    propertyGroupOffset += numBytes;
  }
  nextPropertyGroup();
  return { serializedBytes, offsets, propertyGroupBytes };
}
class AnnotationPropertySerializer {
  constructor(rank, firstGroupInitialOffset, propertySpecs) {
    this.rank = rank;
    this.firstGroupInitialOffset = firstGroupInitialOffset;
    this.propertySpecs = propertySpecs;
    if (propertySpecs.length === 0) {
      this.serializedBytes = firstGroupInitialOffset;
      this.serialize = this.deserialize = () => {
      };
      this.propertyGroupBytes = [firstGroupInitialOffset];
      return;
    }
    var _getPropertyOffsets = getPropertyOffsets(rank, firstGroupInitialOffset, propertySpecs);
    const serializedBytes = _getPropertyOffsets.serializedBytes, offsets = _getPropertyOffsets.offsets, propertyGroupBytes = _getPropertyOffsets.propertyGroupBytes;
    this.propertyGroupBytes = propertyGroupBytes;
    let groupOffsetCode = "let groupOffset0 = offset;";
    for (let groupIndex = 1; groupIndex < propertyGroupBytes.length; ++groupIndex) {
      groupOffsetCode += `let groupOffset${groupIndex} = groupOffset${groupIndex - 1} + ${propertyGroupBytes[groupIndex - 1]}*annotationCount;`;
    }
    for (let groupIndex = 0; groupIndex < propertyGroupBytes.length; ++groupIndex) {
      groupOffsetCode += `groupOffset${groupIndex} += ${propertyGroupBytes[groupIndex]}*annotationIndex;`;
    }
    let serializeCode = groupOffsetCode;
    let deserializeCode = groupOffsetCode;
    const numProperties = propertySpecs.length;
    for (let propertyIndex = 0; propertyIndex < numProperties; ++propertyIndex) {
      var _offsets$propertyInde = offsets[propertyIndex];
      const group = _offsets$propertyInde.group, offset = _offsets$propertyInde.offset;
      const spec = propertySpecs[propertyIndex];
      const handler = annotationPropertyTypeHandlers[spec.type];
      const propId = `properties[${propertyIndex}]`;
      const offsetExpr = `groupOffset${group} + ${offset}`;
      serializeCode += handler.serializeCode(propId, offsetExpr, rank);
      deserializeCode += handler.deserializeCode(propId, offsetExpr, rank);
    }
    this.serializedBytes = serializedBytes;
    this.serialize = new Function("dv", "offset", "annotationIndex", "annotationCount", "isLittleEndian", "properties", serializeCode);
    this.deserialize = new Function("dv", "offset", "annotationIndex", "annotationCount", "isLittleEndian", "properties", deserializeCode);
  }
}
function makeAnnotationPropertySerializers(rank, propertySpecs) {
  const serializers = [];
  for (const annotationType of annotationTypes) {
    const handler = annotationTypeHandlers[annotationType];
    serializers[annotationType] = new AnnotationPropertySerializer(rank, handler.serializedBytes(rank), propertySpecs);
  }
  return serializers;
}
function formatNumericProperty(property, value) {
  const formattedValue = property.type === "float32" ? value.toPrecision(6) : value.toString();
  const enumValues = property.enumValues, enumLabels = property.enumLabels;
  if (enumValues !== void 0) {
    const enumIndex = enumValues.indexOf(value);
    if (enumIndex !== -1) {
      return `${enumLabels[enumIndex]} (${formattedValue})`;
    }
  }
  return formattedValue;
}
function formatAnnotationPropertyValue(property, value) {
  switch (property.type) {
    case "rgb":
      return serializeColor(unpackRGB(value));
    case "rgba":
      return serializeColor(unpackRGBA(value));
    default:
      return formatNumericProperty(property, value);
  }
}
function parseAnnotationPropertyId(obj) {
  const s = verifyString(obj);
  if (s.match(/^[a-z][a-zA-Z0-9_]*$/) === null) {
    throw new Error(`Invalid property identifier: ${_JSON$stringify(obj)}`);
  }
  return s;
}
function parseAnnotationPropertyType(obj) {
  verifyString(obj);
  if (!Object.prototype.hasOwnProperty.call(annotationPropertyTypeHandlers, obj)) {
    throw new Error(`Unsupported property type: $JSON.stringify(obj)}`);
  }
  return obj;
}
function ensureUniqueAnnotationPropertyIds(properties) {
  const ids = new _Set();
  for (const p of properties) {
    if (ids.has(p.identifier)) {
      throw new Error(`Duplicate property identifier: ${p.identifier}`);
    }
    ids.add(p.identifier);
  }
}
function parseAnnotationPropertySpec(obj) {
  verifyObject(obj);
  const identifier = verifyObjectProperty(obj, "id", parseAnnotationPropertyId);
  const type = verifyObjectProperty(obj, "type", parseAnnotationPropertyType);
  const description = verifyOptionalObjectProperty(obj, "description", verifyString);
  let defaultValue = verifyOptionalObjectProperty(obj, "default", (x) => annotationPropertyTypeHandlers[type].deserializeJson(x), 0);
  let enumValues;
  let enumLabels;
  switch (type) {
    case "rgb":
    case "rgba":
      break;
    default: {
      const dataType = DataType[type.toUpperCase()];
      enumValues = verifyOptionalObjectProperty(obj, "enum_values", (valuesObj) => parseArray(valuesObj, (x) => parseDataTypeValue(dataType, x)));
      if (enumValues !== void 0) {
        enumLabels = verifyObjectProperty(obj, "enum_labels", (labelsObj) => parseFixedLengthArray(new Array(enumValues.length), labelsObj, verifyString));
      }
    }
  }
  return { type, identifier, description, default: defaultValue, enumValues, enumLabels };
}
function annotationPropertySpecToJson(spec) {
  const defaultValue = spec.default;
  return {
    id: spec.identifier,
    description: spec.description,
    type: spec.type,
    default: defaultValue === 0 ? void 0 : annotationPropertyTypeHandlers[spec.type].serializeJson(defaultValue)
  };
}
function annotationPropertySpecsToJson(specs) {
  if (specs === void 0 || specs.length === 0) return void 0;
  return specs.map(annotationPropertySpecToJson);
}
function parseAnnotationPropertySpecs(obj) {
  if (obj === void 0) return [];
  const properties = parseArray(obj, parseAnnotationPropertySpec);
  ensureUniqueAnnotationPropertyIds(properties);
  return properties;
}
function serializeFloatVector(buffer, offset, isLittleEndian, rank, vec) {
  for (let i = 0; i < rank; ++i) {
    buffer.setFloat32(offset, vec[i], isLittleEndian);
    offset += 4;
  }
  return offset;
}
function serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, vecA, vecB) {
  offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, vecA);
  offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, vecB);
  return offset;
}
function deserializeFloatVector(buffer, offset, isLittleEndian, rank, vec) {
  for (let i = 0; i < rank; ++i) {
    vec[i] = buffer.getFloat32(offset, isLittleEndian);
    offset += 4;
  }
  return offset;
}
function deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, vecA, vecB) {
  offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, vecA);
  offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, vecB);
  return offset;
}
const annotationTypeHandlers = {
  [AnnotationType.LINE]: {
    icon: "ꕹ",
    description: "Line",
    toJSON(annotation) {
      return {
        pointA: _Array$from(annotation.pointA),
        pointB: _Array$from(annotation.pointB)
      };
    },
    restoreState(annotation, obj, rank) {
      annotation.pointA = verifyObjectProperty(obj, "pointA", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
      annotation.pointB = verifyObjectProperty(obj, "pointB", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
    },
    serializedBytes(rank) {
      return 2 * 4 * rank;
    },
    serialize(buffer, offset, isLittleEndian, rank, annotation) {
      serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.pointA, annotation.pointB);
    },
    deserialize: (buffer, offset, isLittleEndian, rank, id) => {
      const pointA = new Float32Array(rank);
      const pointB = new Float32Array(rank);
      deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, pointA, pointB);
      return { type: AnnotationType.LINE, pointA, pointB, id, properties: [] };
    },
    visitGeometry(annotation, callback) {
      callback(annotation.pointA, false);
      callback(annotation.pointB, false);
    }
  },
  [AnnotationType.SPHERE]: {
    icon: "⊖",
    description: "Sphere",
    toJSON(annotation) {
      return {
        pointA: _Array$from(annotation.pointA),
        pointB: _Array$from(annotation.pointB)
      };
    },
    restoreState(annotation, obj, rank) {
      annotation.pointA = verifyObjectProperty(obj, "pointA", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
      annotation.pointB = verifyObjectProperty(obj, "pointB", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
    },
    serializedBytes(rank) {
      return 2 * 4 * rank;
    },
    serialize(buffer, offset, isLittleEndian, rank, annotation) {
      serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.pointA, annotation.pointB);
    },
    deserialize: (buffer, offset, isLittleEndian, rank, id) => {
      const pointA = new Float32Array(rank);
      const pointB = new Float32Array(rank);
      deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, pointA, pointB);
      return { type: AnnotationType.SPHERE, pointA, pointB, id, properties: [] };
    },
    visitGeometry(annotation, callback) {
      callback(annotation.pointA, false);
      callback(annotation.pointB, false);
    }
  },
  [AnnotationType.POINT]: {
    icon: "⚬",
    description: "Point",
    toJSON: (annotation) => {
      return {
        point: _Array$from(annotation.point)
      };
    },
    restoreState: (annotation, obj, rank) => {
      annotation.point = verifyObjectProperty(obj, "point", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
    },
    serializedBytes: (rank) => rank * 4,
    serialize: (buffer, offset, isLittleEndian, rank, annotation) => {
      serializeFloatVector(buffer, offset, isLittleEndian, rank, annotation.point);
    },
    deserialize: (buffer, offset, isLittleEndian, rank, id) => {
      const point = new Float32Array(rank);
      deserializeFloatVector(buffer, offset, isLittleEndian, rank, point);
      return { type: AnnotationType.POINT, point, id, properties: [] };
    },
    visitGeometry(annotation, callback) {
      callback(annotation.point, false);
    }
  },
  [AnnotationType.AXIS_ALIGNED_BOUNDING_BOX]: {
    icon: "❑",
    description: "Bounding Box",
    toJSON: (annotation) => {
      return {
        pointA: _Array$from(annotation.pointA),
        pointB: _Array$from(annotation.pointB)
      };
    },
    restoreState: (annotation, obj, rank) => {
      annotation.pointA = verifyObjectProperty(obj, "pointA", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
      annotation.pointB = verifyObjectProperty(obj, "pointB", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
    },
    serializedBytes: (rank) => 2 * 4 * rank,
    serialize(buffer, offset, isLittleEndian, rank, annotation) {
      serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.pointA, annotation.pointB);
    },
    deserialize: (buffer, offset, isLittleEndian, rank, id) => {
      const pointA = new Float32Array(rank);
      const pointB = new Float32Array(rank);
      deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, pointA, pointB);
      return { type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX, pointA, pointB, id, properties: [] };
    },
    visitGeometry(annotation, callback) {
      callback(annotation.pointA, false);
      callback(annotation.pointB, false);
    }
  },
  [AnnotationType.ELLIPSOID]: {
    icon: "◎",
    description: "Ellipsoid",
    toJSON: (annotation) => {
      return {
        center: _Array$from(annotation.center),
        radii: _Array$from(annotation.radii)
      };
    },
    restoreState: (annotation, obj, rank) => {
      annotation.center = verifyObjectProperty(obj, "center", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
      annotation.radii = verifyObjectProperty(obj, "radii", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteNonNegativeFloat));
    },
    serializedBytes: (rank) => 2 * 4 * rank,
    serialize(buffer, offset, isLittleEndian, rank, annotation) {
      serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.center, annotation.radii);
    },
    deserialize: (buffer, offset, isLittleEndian, rank, id) => {
      const center = new Float32Array(rank);
      const radii = new Float32Array(rank);
      deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, center, radii);
      return { type: AnnotationType.ELLIPSOID, center, radii, id, properties: [] };
    },
    visitGeometry(annotation, callback) {
      callback(annotation.center, false);
      callback(annotation.radii, true);
    }
  }
};
function annotationToJson(annotation, schema) {
  const result = annotationTypeHandlers[annotation.type].toJSON(annotation, schema.rank);
  result.type = AnnotationType[annotation.type].toLowerCase();
  result.id = annotation.id;
  result.description = annotation.description || void 0;
  const relatedSegments = annotation.relatedSegments;
  if (relatedSegments !== void 0 && relatedSegments.some((x) => x.length !== 0)) {
    result.segments = relatedSegments.map((segments) => segments.map((x) => x.toString()));
  }
  if (schema.properties.length !== 0) {
    const propertySpecs = schema.properties;
    result.props = annotation.properties.map((prop, i) => annotationPropertyTypeHandlers[propertySpecs[i].type].serializeJson(prop));
  }
  return result;
}
function restoreAnnotation(obj, schema, allowMissingId = false) {
  verifyObject(obj);
  const type = verifyObjectProperty(obj, "type", (x) => verifyEnumString(x, AnnotationType));
  const id = verifyObjectProperty(obj, "id", allowMissingId ? verifyOptionalString : verifyString) || makeAnnotationId();
  const relatedSegments = verifyObjectProperty(obj, "segments", (relObj) => {
    if (relObj === void 0) {
      return schema.relationships.map(() => []);
    }
    const a = expectArray(relObj);
    if (a.length === 0) {
      return schema.relationships.map(() => []);
    }
    if (schema.relationships.length === 1 && !Array.isArray(a[0])) {
      return [parseArray(a, (x) => Uint64.parseString(x))];
    }
    return parseArray(expectArray(relObj, schema.relationships.length), (segments) => parseArray(segments, (y) => Uint64.parseString(y)));
  });
  const properties = verifyObjectProperty(obj, "props", (propsObj) => {
    const propSpecs = schema.properties;
    if (propsObj === void 0) return propSpecs.map((x) => x.default);
    return parseArray(expectArray(propsObj, schema.properties.length), (x, i) => annotationPropertyTypeHandlers[propSpecs[i].type].deserializeJson(x));
  });
  const result = {
    id,
    description: verifyObjectProperty(obj, "description", verifyOptionalString),
    relatedSegments,
    properties,
    type
  };
  annotationTypeHandlers[type].restoreState(result, obj, schema.rank);
  return result;
}
class AnnotationSource extends RefCounted {
  constructor(rank, relationships = [], properties = []) {
    super();
    this.relationships = relationships;
    this.properties = properties;
    this.annotationMap = new _Map();
    this.changed = new NullarySignal();
    this.readonly = false;
    this.childAdded = new Signal();
    this.childUpdated = new Signal();
    this.childDeleted = new Signal();
    this.childRefreshed = new NullarySignal();
    this.pending = new _Set();
    this.references = new _Map();
    this.rank_ = rank;
    this.annotationPropertySerializers = makeAnnotationPropertySerializers(rank, properties);
  }
  get rank() {
    return this.rank_;
  }
  hasNonSerializedProperties() {
    return true;
  }
  add(annotation, commit = true) {
    this.ensureUpdated();
    if (!annotation.id) {
      annotation.id = makeAnnotationId();
    } else if (this.annotationMap.has(annotation.id)) {
      throw new Error(`Annotation id already exists: ${_JSON$stringify(annotation.id)}.`);
    }
    this.annotationMap.set(annotation.id, annotation);
    this.changed.dispatch();
    this.childAdded.dispatch(annotation);
    if (!commit) {
      this.pending.add(annotation.id);
    }
    return this.getReference(annotation.id);
  }
  commit(reference) {
    this.ensureUpdated();
    const id = reference.id;
    this.pending.delete(id);
    this.changed.dispatch();
  }
  update(reference, annotation) {
    this.ensureUpdated();
    if (reference.value === null) {
      throw new Error(`Annotation already deleted.`);
    }
    reference.value = annotation;
    this.annotationMap.set(annotation.id, annotation);
    reference.changed.dispatch();
    this.changed.dispatch();
    this.childUpdated.dispatch(annotation);
  }
  [_Symbol$iterator]() {
    this.ensureUpdated();
    return this.annotationMap.values();
  }
  get(id) {
    this.ensureUpdated();
    return this.annotationMap.get(id);
  }
  delete(reference) {
    if (reference.value === null) {
      return;
    }
    reference.value = null;
    this.annotationMap.delete(reference.id);
    this.pending.delete(reference.id);
    reference.changed.dispatch();
    this.changed.dispatch();
    this.childDeleted.dispatch(reference.id);
  }
  getReference(id) {
    let existing = this.references.get(id);
    if (existing !== void 0) {
      return existing.addRef();
    }
    existing = new AnnotationReference(id);
    existing.value = this.annotationMap.get(id) || null;
    this.references.set(id, existing);
    existing.registerDisposer(() => {
      this.references.delete(id);
    });
    return existing;
  }
  ensureUpdated() {
  }
  toJSON() {
    this.ensureUpdated();
    const result = [];
    const pending = this.pending;
    for (const annotation of this) {
      if (pending.has(annotation.id)) {
        continue;
      }
      result.push(annotationToJson(annotation, this));
    }
    return result;
  }
  clear() {
    this.annotationMap.clear();
    this.pending.clear();
    this.changed.dispatch();
  }
  restoreState(obj) {
    this.ensureUpdated();
    const annotationMap = this.annotationMap;
    annotationMap.clear();
    this.pending.clear();
    if (obj !== void 0) {
      parseArray(obj, (x) => {
        const annotation = restoreAnnotation(x, this);
        annotationMap.set(annotation.id, annotation);
      });
    }
    for (const reference of this.references.values()) {
      const id = reference.id;
      const value = annotationMap.get(id);
      reference.value = value || null;
      reference.changed.dispatch();
    }
    this.changed.dispatch();
  }
  reset() {
    this.clear();
  }
}
class LocalAnnotationSource extends AnnotationSource {
  constructor(watchableTransform, properties, relationships) {
    super(watchableTransform.value.sourceRank, relationships, properties);
    this.watchableTransform = watchableTransform;
    this.curCoordinateTransform = watchableTransform.value;
    this.registerDisposer(watchableTransform.changed.add(() => this.ensureUpdated()));
  }
  get rank() {
    this.ensureUpdated();
    return this.rank_;
  }
  ensureUpdated() {
    const transform = this.watchableTransform.value;
    const curCoordinateTransform = this.curCoordinateTransform;
    if (transform === curCoordinateTransform) return;
    this.curCoordinateTransform = transform;
    const sourceRank = transform.sourceRank;
    const oldSourceRank = curCoordinateTransform.sourceRank;
    if (oldSourceRank === sourceRank && (curCoordinateTransform.inputSpace === transform.inputSpace || arraysEqual(curCoordinateTransform.inputSpace.ids.slice(0, sourceRank), transform.inputSpace.ids.slice(0, sourceRank)))) {
      return;
    }
    const newIds = transform.inputSpace.ids;
    const oldIds = curCoordinateTransform.inputSpace.ids;
    const newToOldDims = [];
    for (let newDim = 0; newDim < sourceRank; ++newDim) {
      let oldDim = oldIds.indexOf(newIds[newDim]);
      if (oldDim >= oldSourceRank) {
        oldDim = -1;
      }
      newToOldDims.push(oldDim);
    }
    const mapVector = (radii) => {
      const newRadii = new Float32Array(sourceRank);
      for (let i = 0; i < sourceRank; ++i) {
        const oldDim = newToOldDims[i];
        newRadii[i] = oldDim === -1 ? 0 : radii[i];
      }
      return newRadii;
    };
    for (const annotation of this.annotationMap.values()) {
      switch (annotation.type) {
        case AnnotationType.POINT:
          annotation.point = mapVector(annotation.point);
          break;
        case AnnotationType.LINE:
        case AnnotationType.SPHERE:
        case AnnotationType.AXIS_ALIGNED_BOUNDING_BOX:
          annotation.pointA = mapVector(annotation.pointA);
          annotation.pointB = mapVector(annotation.pointB);
          break;
        case AnnotationType.ELLIPSOID:
          annotation.center = mapVector(annotation.center);
          annotation.radii = mapVector(annotation.radii);
          break;
      }
    }
    if (this.rank_ !== sourceRank) {
      this.rank_ = sourceRank;
      this.annotationPropertySerializers = makeAnnotationPropertySerializers(this.rank_, this.properties);
    }
    this.changed.dispatch();
  }
}
const DATA_BOUNDS_DESCRIPTION = "Data Bounds";
function makeAnnotationId() {
  return getRandomHexString(160);
}
function makeDataBoundsBoundingBoxAnnotation(box2) {
  return {
    type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,
    id: "data-bounds",
    description: DATA_BOUNDS_DESCRIPTION,
    pointA: new Float32Array(box2.lowerBounds),
    pointB: new Float32Array(box2.upperBounds),
    properties: []
  };
}
function makeDataBoundsBoundingBoxAnnotationSet(box2) {
  const annotationSource = new AnnotationSource(box2.lowerBounds.length);
  annotationSource.readonly = true;
  annotationSource.add(makeDataBoundsBoundingBoxAnnotation(box2));
  return annotationSource;
}
function serializeAnnotations(allAnnotations, propertySerializers) {
  let totalBytes = 0;
  const typeToOffset = [];
  for (const annotationType of annotationTypes) {
    const propertySerializer = propertySerializers[annotationType];
    const serializedPropertiesBytes = propertySerializer.serializedBytes;
    typeToOffset[annotationType] = totalBytes;
    const annotations = allAnnotations[annotationType];
    const count = annotations.length;
    totalBytes += serializedPropertiesBytes * count;
  }
  const typeToIds = [];
  const typeToIdMaps = [];
  const data = new ArrayBuffer(totalBytes);
  const dataView = new DataView(data);
  const isLittleEndian = ENDIANNESS === Endianness.LITTLE;
  for (const annotationType of annotationTypes) {
    const propertySerializer = propertySerializers[annotationType];
    const rank = propertySerializer.rank;
    const serializeProperties = propertySerializer.serialize;
    const annotations = allAnnotations[annotationType];
    typeToIds[annotationType] = annotations.map((x) => x.id);
    typeToIdMaps[annotationType] = new _Map(annotations.map((x, i) => [x.id, i]));
    const handler = annotationTypeHandlers[annotationType];
    const serialize = handler.serialize;
    const offset = typeToOffset[annotationType];
    const geometryDataStride = propertySerializer.propertyGroupBytes[0];
    for (let i = 0, count = annotations.length; i < count; ++i) {
      const annotation = annotations[i];
      serialize(dataView, offset + i * geometryDataStride, isLittleEndian, rank, annotation);
      serializeProperties(dataView, offset, i, count, isLittleEndian, annotation.properties);
    }
  }
  return { data: new Uint8Array(data), typeToIds, typeToOffset, typeToIdMaps };
}
class AnnotationSerializer {
  constructor(propertySerializers) {
    this.propertySerializers = propertySerializers;
    this.annotations = [[], [], [], [], []];
  }
  add(annotation) {
    this.annotations[annotation.type].push(annotation);
  }
  serialize() {
    return serializeAnnotations(this.annotations, this.propertySerializers);
  }
}
function fixAnnotationAfterStructuredCloning(obj) {
  if (obj == null) {
    return obj;
  }
  const relatedSegments = obj.relatedSegments;
  if (relatedSegments !== void 0) {
    for (let i = 0, numRelationships = relatedSegments.length; i < numRelationships; ++i) {
      const segments = relatedSegments[i];
      if (segments === void 0) continue;
      relatedSegments[i] = segments.map((x) => new Uint64(x.low, x.high));
    }
  }
  return obj;
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function multiply(c, ldc, a, lda, b, ldb, m, n, k) {
  for (let mIndex = 0; mIndex < m; ++mIndex) {
    for (let kIndex = 0; kIndex < k; ++kIndex) {
      let sum = 0;
      for (let nIndex = 0; nIndex < n; ++nIndex) {
        sum += a[mIndex + lda * nIndex] * b[nIndex + ldb * kIndex];
      }
      c[mIndex + ldc * kIndex] = sum;
    }
  }
  return c;
}
function identity(a, lda, n) {
  for (let i = 0; i < n; ++i) {
    const start = lda * i;
    a.fill(0, start, start + n);
    a[start + i] = 1;
  }
  return a;
}
function createIdentity(c, rows, cols = rows) {
  return identity(new c(rows * cols), rows, Math.min(rows, cols));
}
function createHomogeneousScaleMatrix(c, scales, square = true) {
  const rank = scales.length;
  const stride = square ? rank + 1 : rank;
  const m = new c(stride * (rank + 1));
  if (square) {
    m[m.length - 1] = 1;
  }
  for (let i = 0; i < rank; ++i) {
    m[(stride + 1) * i] = scales[i];
  }
  return m;
}
function isIdentity(a, lda, n) {
  for (let i = 0; i < n; ++i) {
    for (let j = 0; j < n; ++j) {
      if (a[i * lda + j] != (i === j ? 1 : 0)) return false;
    }
  }
  return true;
}
function copy(b, ldb, a, lda, m, n) {
  for (let col = 0; col < n; ++col) {
    const aOff = col * lda;
    const bOff = col * ldb;
    for (let row = 0; row < m; ++row) {
      b[bOff + row] = a[aOff + row];
    }
  }
  return b;
}
function extendHomogeneousTransform(b, bRank, a, aRank) {
  copy(b, bRank + 1, a, aRank + 1, aRank, aRank);
  for (let i = 0; i < aRank; ++i) {
    b[(bRank + 1) * bRank + i] = a[(aRank + 1) * aRank + i];
  }
  b[b.length - 1] = 1;
  for (let i = aRank; i < bRank; ++i) {
    b[(bRank + 1) * i + i] = 1;
  }
  return b;
}
let pivots;
function inverseInplace(a, lda, n) {
  let determinant2 = 1;
  if (pivots === void 0 || pivots.length < n) {
    pivots = new Uint32Array(n);
  }
  for (let i = 0; i < n; ++i) {
    pivots[i] = i;
  }
  for (let k = 0; k < n; ++k) {
    const kColOff = lda * k;
    let pivotRow = k;
    {
      let bestPivot = Math.abs(a[kColOff + k]);
      for (let row = k + 1; row < n; ++row) {
        const mag = Math.abs(a[kColOff + row]);
        if (mag > bestPivot) {
          bestPivot = mag;
          pivotRow = row;
        }
      }
    }
    if (k !== pivotRow) {
      determinant2 *= -1;
      for (let col = 0; col < n; ++col) {
        const off = lda * col;
        const temp = a[off + k];
        a[off + k] = a[off + pivotRow];
        a[off + pivotRow] = temp;
      }
      {
        const tempPivot = pivots[k];
        pivots[k] = pivots[pivotRow];
        pivots[pivotRow] = tempPivot;
      }
    }
    const pivotValue = a[kColOff + k];
    const pivotInv = 1 / pivotValue;
    determinant2 *= pivotValue;
    for (let j = 0; j < n; ++j) {
      a[lda * j + k] *= pivotInv;
    }
    a[kColOff + k] = pivotInv;
    for (let row = 0; row < n; ++row) {
      if (row === k) continue;
      const factor = -a[lda * k + row];
      for (let j = 0; j < n; ++j) {
        const jColOff = lda * j;
        a[jColOff + row] += factor * a[jColOff + k];
      }
      a[lda * k + row] = factor * pivotInv;
    }
  }
  for (let col = 0; col < n; ++col) {
    let targetCol = pivots[col];
    while (targetCol !== col) {
      const colOff = lda * col;
      const targetColOff = lda * targetCol;
      for (let i = 0; i < n; ++i) {
        const off1 = colOff + i;
        const off2 = targetColOff + i;
        const temp2 = a[off1];
        a[off1] = a[off2];
        a[off2] = temp2;
      }
      const temp = pivots[col] = pivots[targetCol];
      pivots[targetCol] = targetCol;
      targetCol = temp;
    }
  }
  return determinant2;
}
function inverse(b, ldb, a, lda, n) {
  copy(b, ldb, a, lda, n, n);
  return inverseInplace(b, ldb, n);
}
function equal(a, lda, b, ldb, m, n) {
  for (let j = 0; j < n; ++j) {
    const offA = lda * j;
    const offB = ldb * j;
    for (let i = 0; i < m; ++i) {
      if (a[offA + i] !== b[offB + i]) return false;
    }
  }
  return true;
}
function transformPoint(out, mat, matrixStride, vec, rank) {
  for (let i = 0; i < rank; ++i) {
    let sum = mat[matrixStride * rank + i];
    for (let j = 0; j < rank; ++j) {
      sum += mat[matrixStride * j + i] * vec[j];
    }
    out[i] = sum;
  }
  return out;
}
function transformVector(out, mat, matrixStride, vec, rank) {
  for (let i = 0; i < rank; ++i) {
    let sum = 0;
    for (let j = 0; j < rank; ++j) {
      sum += mat[matrixStride * j + i] * vec[j];
    }
    out[i] = sum;
  }
  return out;
}
var es6_math_log10 = {};
var hasRequiredEs6_math_log10;
function requireEs6_math_log10() {
  if (hasRequiredEs6_math_log10) return es6_math_log10;
  hasRequiredEs6_math_log10 = 1;
  var $export = require_export();
  $export($export.S, "Math", {
    log10: function log102(x) {
      return Math.log(x) * Math.LOG10E;
    }
  });
  return es6_math_log10;
}
var log10$1;
var hasRequiredLog10$1;
function requireLog10$1() {
  if (hasRequiredLog10$1) return log10$1;
  hasRequiredLog10$1 = 1;
  requireEs6_math_log10();
  log10$1 = require_core().Math.log10;
  return log10$1;
}
var log10;
var hasRequiredLog10;
function requireLog10() {
  if (hasRequiredLog10) return log10;
  hasRequiredLog10 = 1;
  log10 = { "default": requireLog10$1(), __esModule: true };
  return log10;
}
var log10Exports = requireLog10();
const _Math$log = /* @__PURE__ */ getDefaultExportFromCjs(log10Exports);
const siPrefixes = [
  { prefix: "Y", exponent: 24 },
  { prefix: "Z", exponent: 21 },
  { prefix: "E", exponent: 18 },
  { prefix: "P", exponent: 15 },
  { prefix: "T", exponent: 12 },
  { prefix: "G", exponent: 9 },
  { prefix: "M", exponent: 6 },
  { prefix: "k", exponent: 3 },
  // {prefix: 'h', exponent: 2},
  // {prefix: 'da', exponent: 1},
  { prefix: "", exponent: 0 },
  // {prefix: 'd', exponent: -1},
  // {prefix: 'c', exponent: -2},
  { prefix: "m", exponent: -3 },
  { prefix: "µ", exponent: -6 },
  { prefix: "n", exponent: -9 },
  { prefix: "p", exponent: -12 },
  { prefix: "f", exponent: -15 },
  { prefix: "a", exponent: -18 },
  { prefix: "z", exponent: -21 },
  { prefix: "y", exponent: -24 }
];
const siPrefixesWithAlternatives = [
  // Parse 'c' for centi, but don't pick it.
  { prefix: "c", exponent: -2 },
  { prefix: "u", exponent: -6 },
  ...siPrefixes
];
const supportedUnits = new _Map();
supportedUnits.set("", { unit: "", exponent: 0 });
const exponentToPrefix = new _Map();
for (const _ref of siPrefixesWithAlternatives) {
  const prefix = _ref.prefix;
  const exponent = _ref.exponent;
  exponentToPrefix.set(exponent, prefix);
  for (const unit of ["m", "s", "Hz", "rad/s"]) {
    supportedUnits.set(`${prefix}${unit}`, { unit, exponent });
  }
}
function pickSiPrefix(x) {
  const exponent = _Math$log(x);
  const numPrefixes = siPrefixes.length;
  const i = binarySearchLowerBound(0, numPrefixes, (i2) => siPrefixes[i2].exponent <= exponent);
  return siPrefixes[Math.min(i, numPrefixes - 1)];
}
function formatScaleWithUnit(scale2, unit, options = {}) {
  var _options$precision = options.precision;
  const precision = _options$precision === void 0 ? 6 : _options$precision;
  var _options$elide = options.elide1;
  const elide1 = _options$elide === void 0 ? true : _options$elide;
  let adjustedScale = scale2;
  let prefix = "";
  if (unit !== "") {
    const result = pickSiPrefix(scale2);
    prefix = result.prefix;
    adjustedScale = scaleByExp10(scale2, -result.exponent);
  }
  if (elide1 && adjustedScale === 1) {
    return { scale: "", unit, prefix };
  }
  let scaleString;
  if (precision != 0) {
    if (adjustedScale < 1 || adjustedScale >= 1e3) {
      scaleString = adjustedScale.toPrecision(precision);
    } else {
      scaleString = adjustedScale.toFixed(precision);
    }
    const eIndex = scaleString.indexOf("e");
    let numString;
    let exponentString;
    if (eIndex !== -1) {
      numString = scaleString.substring(0, eIndex);
      exponentString = scaleString.substring(eIndex);
    } else {
      numString = scaleString;
      exponentString = "";
    }
    const m = numString.match(/.*\.(?:[0-9]*[1-9])?(0+)$/);
    if (m !== null) {
      numString = numString.substring(0, numString.length - m[1].length);
      if (numString.endsWith(".")) {
        numString = numString.substring(0, numString.length - 1);
      }
      scaleString = numString + exponentString;
    }
  } else {
    scaleString = adjustedScale.toString();
  }
  return {
    scale: scaleString,
    unit,
    prefix
  };
}
function formatScaleWithUnitAsString(scale2, unit, options) {
  var _formatScaleWithUnit = formatScaleWithUnit(scale2, unit, options);
  const formattedScale = _formatScaleWithUnit.scale, formattedUnit = _formatScaleWithUnit.unit, prefix = _formatScaleWithUnit.prefix;
  return `${formattedScale}${prefix}${formattedUnit}`;
}
function parseScale(s) {
  if (s === "") {
    return { scale: 1, unit: "" };
  }
  const match = s.match(/^((?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)?([µa-zA-Z]+)?$/);
  if (match === null) return void 0;
  const scaleString = match[1];
  let scale2 = scaleString === void 0 ? 1 : Number(scaleString);
  if (_Number$isNaN(scale2)) return void 0;
  let unit = "";
  if (match[2] !== void 0) {
    const result = supportedUnits.get(match[2]);
    if (result === void 0) {
      return void 0;
    }
    unit = result.unit;
    if (result.exponent > 0) {
      scale2 *= 10 ** result.exponent;
    } else {
      scale2 /= 10 ** -result.exponent;
    }
  }
  if (scale2 <= 0 || !_Number$isFinite(scale2)) return void 0;
  return { scale: scale2, unit };
}
function unitFromJson(x) {
  const result = supportedUnits.get(x);
  if (result === void 0) {
    throw new Error(`Invalid unit: ${_JSON$stringify(x)}`);
  }
  return result;
}
function scaleByExp10(scale2, exponent) {
  if (exponent >= 0) return scale2 * 10 ** exponent;
  return scale2 / 10 ** -exponent;
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function add(out, a, b) {
  const rank = out.length;
  for (let i = 0; i < rank; ++i) {
    out[i] = a[i] + b[i];
  }
  return out;
}
function subtract(out, a, b) {
  const rank = out.length;
  for (let i = 0; i < rank; ++i) {
    out[i] = a[i] - b[i];
  }
  return out;
}
function scaleAndAdd(out, a, b, scale2) {
  const rank = out.length;
  for (let i = 0; i < rank; ++i) {
    out[i] = a[i] + b[i] * scale2;
  }
  return out;
}
function scale(out, a, scale2) {
  const rank = out.length;
  for (let i = 0; i < rank; ++i) {
    out[i] = a[i] * scale2;
  }
  return out;
}
function prod(array) {
  let result = 1;
  for (let i = 0, length2 = array.length; i < length2; ++i) {
    result *= array[i];
  }
  return result;
}
function min(out, a, b) {
  const rank = out.length;
  for (let i = 0; i < rank; ++i) {
    out[i] = Math.min(a[i], b[i]);
  }
  return out;
}
const kEmptyFloat32Vec = new Float32Array(0);
const kEmptyFloat64Vec = new Float64Array(0);
let nextDimensionId = 0;
function newDimensionId() {
  return ++nextDimensionId;
}
function boundingBoxesEqual(a, b) {
  return arraysEqual(a.lowerBounds, b.lowerBounds) && arraysEqual(a.upperBounds, b.upperBounds);
}
function coordinateArraysEqual(a, b) {
  if (a === void 0) return b === void 0;
  if (b === void 0) return false;
  return a.explicit === b.explicit && arraysEqual(a.coordinates, b.coordinates) && arraysEqual(a.labels, b.labels);
}
function normalizeCoordinateArray(coordinates, labels) {
  const map2 = new _Map();
  for (let i = 0, length2 = coordinates.length; i < length2; ++i) {
    map2.set(coordinates[i], labels[i]);
  }
  coordinates = _Array$from(map2.keys());
  coordinates.sort((a, b) => a - b);
  labels = _Array$from(coordinates, (x) => map2.get(x));
  return { coordinates, labels };
}
function mergeCoordinateArrays(coordinateArrays) {
  if (coordinateArrays.length === 1) return coordinateArrays[0];
  const map2 = new _Map();
  let explicit = false;
  for (const x of coordinateArrays) {
    if (x.explicit) explicit = true;
    const coordinates2 = x.coordinates, labels2 = x.labels;
    for (let i = 0, length2 = coordinates2.length; i < length2; ++i) {
      map2.set(coordinates2[i], labels2[i]);
    }
  }
  const coordinates = _Array$from(map2.keys());
  coordinates.sort((a, b) => a - b);
  const labels = _Array$from(coordinates, (x) => map2.get(x));
  return { explicit, coordinates, labels };
}
function mergeOptionalCoordinateArrays(coordinateArrays) {
  coordinateArrays = coordinateArrays.filter((x) => x !== void 0);
  if (coordinateArrays.length === 0) return void 0;
  return mergeCoordinateArrays(coordinateArrays);
}
function transformedBoundingBoxesEqual(a, b) {
  return arraysEqual(a.transform, b.transform) && boundingBoxesEqual(a.box, b.box);
}
function coordinateSpacesEqual(a, b) {
  return a.valid === b.valid && a.rank === b.rank && arraysEqual(a.names, b.names) && arraysEqual(a.ids, b.ids) && arraysEqual(a.timestamps, b.timestamps) && arraysEqual(a.units, b.units) && arraysEqual(a.scales, b.scales) && arraysEqualWithPredicate(a.boundingBoxes, b.boundingBoxes, transformedBoundingBoxesEqual) && arraysEqualWithPredicate(a.coordinateArrays, b.coordinateArrays, coordinateArraysEqual);
}
function makeCoordinateSpace(space) {
  const names = space.names, units = space.units, scales = space.scales;
  var _space$valid = space.valid;
  const valid = _space$valid === void 0 ? true : _space$valid;
  var _space$rank = space.rank;
  const rank = _space$rank === void 0 ? names.length : _space$rank;
  var _space$timestamps = space.timestamps;
  const timestamps = _space$timestamps === void 0 ? names.map(() => Number.NEGATIVE_INFINITY) : _space$timestamps;
  var _space$ids = space.ids;
  const ids = _space$ids === void 0 ? names.map((_, i) => -i) : _space$ids;
  var _space$boundingBoxes = space.boundingBoxes;
  const boundingBoxes = _space$boundingBoxes === void 0 ? [] : _space$boundingBoxes;
  var _space$coordinateArra = space.coordinateArrays;
  const coordinateArrays = _space$coordinateArra === void 0 ? new Array(rank) : _space$coordinateArra;
  var _space$bounds = space.bounds;
  const bounds = _space$bounds === void 0 ? computeCombinedBounds(boundingBoxes, rank) : _space$bounds;
  return {
    valid,
    rank,
    names,
    timestamps,
    ids,
    units,
    scales,
    boundingBoxes,
    bounds,
    coordinateArrays
  };
}
const emptyInvalidCoordinateSpace = makeCoordinateSpace({
  valid: false,
  names: [],
  units: [],
  scales: kEmptyFloat64Vec,
  boundingBoxes: []
});
const emptyValidCoordinateSpace = makeCoordinateSpace({
  valid: true,
  names: [],
  units: [],
  scales: kEmptyFloat64Vec,
  boundingBoxes: []
});
function unitAndScaleFromJson(obj) {
  var _expectArray = expectArray(obj, 2), _expectArray2 = _slicedToArray(_expectArray, 2);
  const scaleObj = _expectArray2[0], unitObj = _expectArray2[1];
  const scale2 = verifyFinitePositiveFloat(scaleObj);
  const unitString = verifyString(unitObj);
  const result = supportedUnits.get(unitString);
  if (result === void 0) throw new Error(`Invalid unit: ${_JSON$stringify(unitString)}`);
  return { unit: result.unit, scale: scaleByExp10(scale2, result.exponent) };
}
function coordinateSpaceFromJson(obj, allowNumericalDimensions = false) {
  if (obj === void 0) return emptyInvalidCoordinateSpace;
  verifyObject(obj);
  const names = dimensionNamesFromJson(_Object$keys(obj), allowNumericalDimensions);
  const rank = names.length;
  const units = new Array(rank);
  const scales = new Float64Array(rank);
  const coordinateArrays = new Array(rank);
  for (let i = 0; i < rank; ++i) {
    verifyObjectProperty(obj, names[i], (mem) => {
      if (Array.isArray(mem)) {
        var _unitAndScaleFromJson = unitAndScaleFromJson(mem);
        const unit = _unitAndScaleFromJson.unit, scale2 = _unitAndScaleFromJson.scale;
        units[i] = unit;
        scales[i] = scale2;
      } else {
        verifyObject(mem);
        let coordinates = verifyObjectProperty(mem, "coordinates", verifyIntegerArray);
        let labels = verifyObjectProperty(mem, "labels", verifyStringArray);
        let length2 = coordinates.length;
        if (length2 !== labels.length) {
          throw new Error(`Length of coordinates array (${length2}) does not match length of labels array (${labels.length})`);
        }
        units[i] = "";
        scales[i] = 1;
        coordinateArrays[i] = _Object$assign({ explicit: true }, normalizeCoordinateArray(coordinates, labels));
      }
    });
  }
  return makeCoordinateSpace({ valid: false, names, units, scales, coordinateArrays });
}
function coordinateSpaceToJson(coordinateSpace) {
  const rank = coordinateSpace.rank;
  if (rank === 0) return void 0;
  const names = coordinateSpace.names, units = coordinateSpace.units, scales = coordinateSpace.scales, coordinateArrays = coordinateSpace.coordinateArrays;
  const json2 = {};
  for (let i = 0; i < rank; ++i) {
    const name2 = names[i];
    const coordinateArray = coordinateArrays[i];
    if (coordinateArray === null || coordinateArray === void 0 ? void 0 : coordinateArray.explicit) {
      json2[name2] = {
        coordinates: _Array$from(coordinateArray.coordinates),
        labels: coordinateArray.labels
      };
    } else {
      json2[name2] = [scales[i], units[i]];
    }
  }
  return json2;
}
class TrackableCoordinateSpace extends WatchableValue {
  constructor() {
    super(emptyInvalidCoordinateSpace);
  }
  toJSON() {
    return coordinateSpaceToJson(this.value);
  }
  reset() {
    this.value = emptyInvalidCoordinateSpace;
  }
  restoreState(obj) {
    this.value = coordinateSpaceFromJson(obj);
  }
}
function getCenterBound(lower, upper) {
  let x = (lower + upper) / 2;
  if (!_Number$isFinite(x)) x = Math.min(Math.max(0, lower), upper);
  return x;
}
function getBoundingBoxCenter(out, bounds) {
  const lowerBounds = bounds.lowerBounds, upperBounds = bounds.upperBounds;
  const rank = out.length;
  for (let i = 0; i < rank; ++i) {
    out[i] = getCenterBound(lowerBounds[i], upperBounds[i]);
  }
  return out;
}
function makeIdentityTransformedBoundingBox(box2) {
  const rank = box2.lowerBounds.length;
  return { box: box2, transform: createIdentity(Float64Array, rank, rank + 1) };
}
function computeCombinedLowerUpperBound(boundingBox, outputDimension, outputRank) {
  var _boundingBox$box = boundingBox.box;
  const baseLowerBounds = _boundingBox$box.lowerBounds, baseUpperBounds = _boundingBox$box.upperBounds, transform = boundingBox.transform;
  const inputRank = baseLowerBounds.length;
  const stride = outputRank;
  const offset = transform[stride * inputRank + outputDimension];
  let targetLower = offset, targetUpper = offset;
  let hasCoefficient = false;
  for (let inputDim = 0; inputDim < inputRank; ++inputDim) {
    let c = transform[stride * inputDim + outputDimension];
    if (c === 0) continue;
    const lower = c * baseLowerBounds[inputDim];
    const upper = c * baseUpperBounds[inputDim];
    targetLower += Math.min(lower, upper);
    targetUpper += Math.max(lower, upper);
    hasCoefficient = true;
  }
  if (!hasCoefficient) return void 0;
  return { lower: targetLower, upper: targetUpper };
}
function computeCombinedBounds(boundingBoxes, outputRank) {
  const lowerBounds = new Float64Array(outputRank);
  const upperBounds = new Float64Array(outputRank);
  lowerBounds.fill(Number.NEGATIVE_INFINITY);
  upperBounds.fill(Number.POSITIVE_INFINITY);
  for (const boundingBox of boundingBoxes) {
    for (let outputDim = 0; outputDim < outputRank; ++outputDim) {
      const result = computeCombinedLowerUpperBound(boundingBox, outputDim, outputRank);
      if (result === void 0) continue;
      const targetLower = result.lower, targetUpper = result.upper;
      lowerBounds[outputDim] = lowerBounds[outputDim] === Number.NEGATIVE_INFINITY ? targetLower : Math.min(lowerBounds[outputDim], targetLower);
      upperBounds[outputDim] = upperBounds[outputDim] === Number.POSITIVE_INFINITY ? targetUpper : Math.max(upperBounds[outputDim], targetUpper);
    }
  }
  return { lowerBounds, upperBounds };
}
function extendTransformedBoundingBox(boundingBox, newOutputRank, newOutputDims) {
  const oldTransform = boundingBox.transform, box2 = boundingBox.box;
  const oldOutputRank = newOutputDims.length;
  const inputRank = box2.lowerBounds.length;
  const newTransform = new Float64Array((inputRank + 1) * newOutputRank);
  for (let oldOutputDim = 0; oldOutputDim < oldOutputRank; ++oldOutputDim) {
    const newOutputDim = newOutputDims[oldOutputDim];
    if (newOutputDim === -1) continue;
    for (let inputDim = 0; inputDim <= inputRank; ++inputDim) {
      newTransform[inputDim * newOutputRank + newOutputDim] = oldTransform[inputDim * oldOutputRank + oldOutputDim];
    }
  }
  return {
    transform: newTransform,
    box: box2
  };
}
function makeSingletonDimTransformedBoundingBox(outputRank, outputDim) {
  const box2 = { lowerBounds: Float64Array.of(0), upperBounds: Float64Array.of(1) };
  const transform = new Float64Array(2 * outputRank);
  transform[outputDim] = 1;
  return { transform, box: box2 };
}
function extendTransformedBoundingBoxUpToRank(boundingBox, oldOutputRank, newOutputRank) {
  if (oldOutputRank === newOutputRank) return boundingBox;
  const box2 = boundingBox.box;
  const inputRank = box2.lowerBounds.length;
  const transform = new Float64Array((inputRank + 1) * newOutputRank);
  copy(transform, newOutputRank, boundingBox.transform, oldOutputRank, oldOutputRank, inputRank + 1);
  return { box: box2, transform };
}
function coordinateSpaceTransformsEquivalent(defaultTransform, transform) {
  const rank = defaultTransform.rank, sourceRank = defaultTransform.sourceRank;
  if (rank !== transform.rank || sourceRank !== transform.sourceRank) return false;
  const defaultInputSpace = defaultTransform.inputSpace;
  const inputSpace = transform.inputSpace;
  if (!arraysEqual(inputSpace.scales, defaultInputSpace.scales) || !arraysEqual(inputSpace.units, defaultInputSpace.units) || !arraysEqual(transform.outputSpace.names, defaultTransform.outputSpace.names)) {
    return false;
  }
  return isTransformDerivableFromDefault(defaultTransform.transform, rank, defaultTransform.outputSpace.scales, transform.transform, rank, transform.outputSpace.scales);
}
function makeIdentityTransform(inputSpace) {
  return {
    rank: inputSpace.rank,
    sourceRank: inputSpace.rank,
    inputSpace,
    outputSpace: inputSpace,
    transform: createIdentity(Float64Array, inputSpace.rank + 1)
  };
}
function transformBoundingBox(boundingBox, transform, sourceScales, targetScales) {
  let oldBoxTransform = boundingBox.transform, box2 = boundingBox.box;
  const inputRank = boundingBox.box.lowerBounds.length;
  const targetRank = targetScales.length;
  const newBoxTransform = new Float64Array((inputRank + 1) * targetRank);
  for (let targetDim = 0; targetDim < targetRank; ++targetDim) {
    const targetScale = targetScales[targetDim];
    for (let inputDim = 0; inputDim < inputRank; ++inputDim) {
      let sum2 = 0;
      for (let sourceDim = 0; sourceDim < targetRank; ++sourceDim) {
        const sourceScale = sourceScales[sourceDim];
        sum2 += transform[(targetRank + 1) * sourceDim + targetDim] * oldBoxTransform[targetRank * inputDim + sourceDim] * (sourceScale / targetScale);
      }
      newBoxTransform[targetRank * inputDim + targetDim] = sum2;
    }
    let sum = transform[(targetRank + 1) * targetRank + targetDim];
    for (let sourceDim = 0; sourceDim < targetRank; ++sourceDim) {
      const sourceScale = sourceScales[sourceDim];
      sum += transform[(targetRank + 1) * sourceDim + targetDim] * oldBoxTransform[targetRank * inputRank + sourceDim] * (sourceScale / targetScale);
    }
    newBoxTransform[inputRank * targetRank + targetDim] = sum;
  }
  return {
    transform: newBoxTransform,
    box: box2
  };
}
function getTransformedBoundingBoxes(inputSpace, transform, outputScales) {
  return inputSpace.boundingBoxes.map((boundingBox) => transformBoundingBox(boundingBox, transform, inputSpace.scales, outputScales));
}
function getOutputSpaceWithTransformedBoundingBoxes(inputSpace, transform, oldOutputSpace) {
  const newSpace = makeCoordinateSpace({
    valid: inputSpace.valid,
    rank: oldOutputSpace.rank,
    ids: oldOutputSpace.ids,
    names: oldOutputSpace.names,
    timestamps: oldOutputSpace.timestamps,
    scales: oldOutputSpace.scales,
    units: oldOutputSpace.units,
    boundingBoxes: getTransformedBoundingBoxes(inputSpace, transform, oldOutputSpace.scales),
    coordinateArrays: oldOutputSpace.coordinateArrays
  });
  if (coordinateSpacesEqual(newSpace, oldOutputSpace)) return oldOutputSpace;
  return newSpace;
}
function isValidDimensionName(name2, allowNumericalNames = false) {
  if (allowNumericalNames) {
    const n = Number(name2);
    if (_Number$isInteger(n) && n >= 0) return true;
  }
  return name2.match(/^[a-zA-Z][a-zA-Z_0-9]*['^]?$/) !== null;
}
function validateDimensionNames(names, allowNumericalNames = false) {
  const seenNames = new _Set();
  for (const name2 of names) {
    if (!isValidDimensionName(name2, allowNumericalNames)) return false;
    if (seenNames.has(name2)) return false;
    seenNames.add(name2);
  }
  return true;
}
function getDimensionNameValidity(names) {
  const rank = names.length;
  const isValid = new Array(rank);
  isValid.fill(true);
  for (let i = 0; i < rank; ++i) {
    const name2 = names[i];
    if (!isValidDimensionName(name2)) {
      isValid[i] = false;
      continue;
    }
    const otherIndex = names.indexOf(name2, i + 1);
    if (otherIndex !== -1) {
      isValid[i] = false;
      isValid[otherIndex] = false;
    }
  }
  return isValid;
}
function isLocalDimension(name2) {
  return name2.endsWith("'");
}
function isLocalOrChannelDimension(name2) {
  return name2.endsWith("'") || name2.endsWith("^");
}
function isChannelDimension(name2) {
  return name2.endsWith("^");
}
function isGlobalDimension(name2) {
  return !isLocalOrChannelDimension(name2);
}
function convertTransformOutputScales(existingTransform, existingOutputScales, newOutputScales) {
  const newTransform = new Float64Array(existingTransform);
  const rank = existingOutputScales.length;
  const baseIndex = (rank + 1) * rank;
  for (let i = 0; i < rank; ++i) {
    newTransform[baseIndex + i] *= existingOutputScales[i] / newOutputScales[i];
  }
  return newTransform;
}
function isTransformDerivableFromDefault(defaultTransform, defaultRank, defaultOutputScales, newTransform, newRank, newOutputScales) {
  if (!equal(defaultTransform, defaultRank + 1, newTransform, newRank + 1, defaultRank, defaultRank)) return false;
  for (let i = 0; i < defaultRank; ++i) {
    const aValue = defaultTransform[(defaultRank + 1) * defaultRank + i];
    const bValue = newTransform[(newRank + 1) * newRank + i];
    if (aValue * (defaultOutputScales[i] / newOutputScales[i]) !== bValue) return false;
  }
  for (let i = defaultRank; i < newRank; ++i) {
    if (newTransform[(newRank + 1) * newRank + i] !== 0) return false;
  }
  for (let i = defaultRank; i < newRank; ++i) {
    for (let j = 0; j < defaultRank; ++j) {
      if (newTransform[(newRank + 1) * j + i] !== 0) return false;
    }
    for (let j = 0; j < newRank; ++j) {
      const coeff = newTransform[(newRank + 1) * i + j];
      if (i === j) {
        if (coeff !== 1) return false;
      } else {
        if (coeff !== 0) return false;
      }
    }
  }
  return true;
}
function makeDimensionNameUnique(name2, existingNames) {
  if (!existingNames.includes(name2)) return name2;
  var _name$match = name2.match(/^([^']*)('?)$/), _name$match2 = _slicedToArray(_name$match, 3);
  const prefix = _name$match2[1], suffix = _name$match2[2];
  for (let i = 0; ; ++i) {
    const newName = `${prefix}${i}${suffix}`;
    if (!existingNames.includes(newName)) return newName;
  }
}
function remapTransformInputSpace(old, inputSpace) {
  const oldInputSpace = old.inputSpace, oldTransform = old.transform;
  const oldInputDimensionIds = oldInputSpace.ids, oldRank = oldInputSpace.rank;
  const newRank = inputSpace.rank, newInputDimensionNames = inputSpace.names, newInputUnits = inputSpace.units, newInputScales = inputSpace.scales;
  const removedOldInputIndices = new Array(oldRank);
  removedOldInputIndices.fill(true);
  const addedInputDimensionIndices = [];
  const newToOldInputDimensionIndices = inputSpace.ids.map((id, i) => {
    const oldIndex = oldInputDimensionIds.indexOf(id);
    if (oldIndex !== -1) {
      removedOldInputIndices[oldIndex] = false;
    } else {
      addedInputDimensionIndices.push(i);
    }
    return oldIndex;
  });
  const oldOutputSpace = old.outputSpace;
  const oldOutputDimensionNames = oldOutputSpace.names, oldOutputUnits = oldOutputSpace.units, oldOutputScales = oldOutputSpace.scales, oldOutputDimensionIds = oldOutputSpace.ids, oldOutputTimestamps = oldOutputSpace.timestamps, oldOutputCoordinateArrays = oldOutputSpace.coordinateArrays;
  const removedOldOutputIndices = removedOldInputIndices;
  const outputDimensionNames = [];
  const outputUnits = [];
  const outputScales = new Float64Array(newRank);
  const outputDimensionIds = [];
  const outputDimensionTimestamps = [];
  const outputCoordinateArrays = new Array(newRank);
  let newOutputDim = 0;
  const newTransform = new Float64Array((newRank + 1) ** 2);
  newTransform[newTransform.length - 1] = 1;
  for (let oldOutputDim = 0; oldOutputDim < oldRank; ++oldOutputDim) {
    if (removedOldOutputIndices[oldOutputDim]) continue;
    outputDimensionNames[newOutputDim] = oldOutputDimensionNames[oldOutputDim];
    outputDimensionIds[newOutputDim] = oldOutputDimensionIds[oldOutputDim];
    outputUnits[newOutputDim] = oldOutputUnits[oldOutputDim];
    outputScales[newOutputDim] = oldOutputScales[oldOutputDim];
    outputDimensionTimestamps[newOutputDim] = oldOutputTimestamps[oldOutputDim];
    outputCoordinateArrays[newOutputDim] = oldOutputCoordinateArrays[oldOutputDim];
    for (let newInputDim = 0; newInputDim < newRank; ++newInputDim) {
      const oldInputDim = newToOldInputDimensionIndices[newInputDim];
      if (oldInputDim === -1) continue;
      newTransform[newInputDim * (newRank + 1) + newOutputDim] = oldTransform[oldInputDim * (oldRank + 1) + oldOutputDim];
    }
    newTransform[newRank * (newRank + 1) + newOutputDim] = oldTransform[oldRank * (oldRank + 1) + oldOutputDim];
    ++newOutputDim;
  }
  for (const newInputDim of addedInputDimensionIndices) {
    outputDimensionIds[newOutputDim] = newDimensionId();
    outputDimensionNames[newOutputDim] = makeDimensionNameUnique(newInputDimensionNames[newInputDim], outputDimensionNames);
    outputScales[newOutputDim] = newInputScales[newInputDim];
    outputUnits[newOutputDim] = newInputUnits[newInputDim];
    newTransform[newInputDim * (newRank + 1) + newOutputDim] = 1;
    ++newOutputDim;
  }
  const outputSpace = makeCoordinateSpace({
    valid: inputSpace.valid,
    rank: newRank,
    names: outputDimensionNames,
    ids: outputDimensionIds,
    timestamps: outputDimensionTimestamps,
    units: outputUnits,
    scales: outputScales,
    boundingBoxes: getTransformedBoundingBoxes(inputSpace, newTransform, outputScales),
    coordinateArrays: outputCoordinateArrays
  });
  return {
    rank: newRank,
    sourceRank: old.sourceRank,
    inputSpace,
    outputSpace,
    transform: newTransform
  };
}
function normalizeCoordinateSpaceTransform(value) {
  const outputSpace = getOutputSpaceWithTransformedBoundingBoxes(value.inputSpace, value.transform, value.outputSpace);
  if (outputSpace === value.outputSpace) return value;
  return {
    rank: value.rank,
    sourceRank: value.sourceRank,
    inputSpace: value.inputSpace,
    transform: value.transform,
    outputSpace
  };
}
class WatchableCoordinateSpaceTransform {
  constructor(defaultTransform, mutableSourceRank = false) {
    this.mutableSourceRank = mutableSourceRank;
    this.value_ = void 0;
    this.changed = new NullarySignal();
    this.inputSpaceChanged = new NullarySignal();
    this.defaultTransform = normalizeCoordinateSpaceTransform(defaultTransform);
    const self2 = this;
    this.outputSpace = {
      changed: self2.changed,
      get value() {
        return self2.value.outputSpace;
      },
      set value(newOutputSpace) {
        const value = self2.value;
        if (coordinateSpacesEqual(value.outputSpace, newOutputSpace)) return;
        if (value.rank !== newOutputSpace.rank) return;
        const transform = convertTransformOutputScales(value.transform, value.outputSpace.scales, newOutputSpace.scales);
        self2.value_ = {
          sourceRank: value.sourceRank,
          rank: value.rank,
          inputSpace: value.inputSpace,
          outputSpace: getOutputSpaceWithTransformedBoundingBoxes(value.inputSpace, transform, newOutputSpace),
          transform
        };
        self2.changed.dispatch();
      }
    };
    this.inputSpace = {
      changed: self2.inputSpaceChanged,
      get value() {
        return self2.value.inputSpace;
      },
      set value(newInputSpace) {
        const value = self2.value;
        if (coordinateSpacesEqual(value.inputSpace, newInputSpace)) return;
        self2.value_ = remapTransformInputSpace(value, newInputSpace);
        self2.inputSpaceChanged.dispatch();
        self2.changed.dispatch();
      }
    };
  }
  set value(value) {
    const existingValue = this.value;
    if (value === existingValue) return;
    this.value_ = normalizeCoordinateSpaceTransform(value);
    if (value.inputSpace !== existingValue.inputSpace) {
      this.inputSpaceChanged.dispatch();
    }
    this.changed.dispatch();
  }
  get value() {
    let value = this.value_;
    if (value === void 0) {
      value = this.value_ = this.defaultTransform;
    }
    return value;
  }
  reset() {
    if (this.value_ === this.defaultTransform) return;
    this.value_ = this.defaultTransform;
    this.inputSpaceChanged.dispatch();
    this.changed.dispatch();
  }
  get defaultInputSpace() {
    return this.defaultTransform.inputSpace;
  }
  get spec() {
    const value = this.value;
    const rank = value.rank, transform = value.transform, inputSpace = value.inputSpace, outputSpace = value.outputSpace, sourceRank = value.sourceRank;
    const defaultTransform = this.defaultTransform, mutableSourceRank = this.mutableSourceRank;
    const defaultInputSpace = defaultTransform.inputSpace, defaultRank = defaultTransform.rank, defaultTransformMatrix = defaultTransform.transform, defaultOutputSpace = defaultTransform.outputSpace;
    const units = inputSpace.units, scales = inputSpace.scales;
    const inputSpaceSame = sourceRank === rank && arraysEqual(scales, mutableSourceRank ? outputSpace.scales : defaultInputSpace.scales) && arraysEqual(units, mutableSourceRank ? outputSpace.units : defaultInputSpace.units);
    const transformSame = isTransformDerivableFromDefault(defaultTransformMatrix, defaultRank, defaultOutputSpace.scales, transform, rank, outputSpace.scales);
    const outputNamesSame = arraysEqual(defaultOutputSpace.names, outputSpace.names);
    if (transformSame && outputNamesSame && inputSpaceSame) {
      return void 0;
    }
    return {
      sourceRank,
      transform: transformSame ? void 0 : transform,
      outputSpace: value.outputSpace,
      inputSpace: inputSpaceSame ? void 0 : inputSpace
    };
  }
  set transform(transform) {
    const value = this.value;
    const inputSpace = value.inputSpace;
    this.value_ = {
      rank: value.rank,
      sourceRank: value.sourceRank,
      inputSpace,
      transform,
      outputSpace: getOutputSpaceWithTransformedBoundingBoxes(inputSpace, transform, value.outputSpace)
    };
    this.changed.dispatch();
  }
  set spec(spec) {
    if (spec === void 0) {
      this.reset();
      return;
    }
    if (this.mutableSourceRank) {
      const origInputSpace = spec.inputSpace || spec.outputSpace;
      const rank = origInputSpace.rank;
      const inputSpace = makeCoordinateSpace({
        rank,
        names: origInputSpace.names.map((_, i) => `${i}`),
        units: origInputSpace.units,
        scales: origInputSpace.scales,
        coordinateArrays: origInputSpace.coordinateArrays
      });
      this.value = {
        rank,
        transform: spec.transform || createIdentity(Float64Array, rank + 1),
        sourceRank: spec.sourceRank,
        outputSpace: spec.outputSpace,
        inputSpace
      };
      return;
    }
    var _defaultTransform = this.defaultTransform;
    const defaultInputSpace = _defaultTransform.inputSpace, defaultSourceRank = _defaultTransform.sourceRank, defaultOutputSpace = _defaultTransform.outputSpace, defaultTransformMatrix = _defaultTransform.transform, defaultRank = _defaultTransform.rank;
    const specInputSpace = spec.inputSpace, specSourceRank = spec.sourceRank, specOutputSpace = spec.outputSpace, specTransformMatrix = spec.transform;
    const specRank = spec.outputSpace.rank;
    const defaultInputNames = defaultInputSpace.names;
    const specInputNames = specInputSpace !== void 0 ? specInputSpace.names : defaultInputNames;
    const newToSpecDimensionIndices = new Array(defaultSourceRank);
    for (let defaultDim = 0; defaultDim < defaultSourceRank; ++defaultDim) {
      let specDim = specInputNames.indexOf(defaultInputNames[defaultDim]);
      if (specDim >= specSourceRank) specDim = -1;
      newToSpecDimensionIndices[defaultDim] = specDim;
    }
    const newRank = specRank - specSourceRank + defaultSourceRank;
    for (let i = specSourceRank; i < specRank; ++i) {
      newToSpecDimensionIndices[defaultSourceRank + i - specSourceRank] = i;
    }
    const newInputScales = new Float64Array(newRank);
    const newInputCoordinateArrays = new Array(newRank);
    const newInputUnits = [];
    for (let newDim = 0; newDim < defaultSourceRank; ++newDim) {
      const specDim = newToSpecDimensionIndices[newDim];
      if (specDim === -1 || specInputSpace === void 0) {
        newInputScales[newDim] = defaultInputSpace.scales[newDim];
        newInputUnits[newDim] = defaultInputSpace.units[newDim];
        newInputCoordinateArrays[newDim] = defaultInputSpace.coordinateArrays[newDim];
      } else {
        newInputScales[newDim] = specInputSpace.scales[specDim];
        newInputUnits[newDim] = specInputSpace.units[specDim];
        newInputCoordinateArrays[newDim] = mergeOptionalCoordinateArrays([defaultInputSpace.coordinateArrays[newDim], specInputSpace.coordinateArrays[specDim]]);
      }
    }
    const specInputOrOutputSpace = specInputSpace || specOutputSpace;
    const newInputNames = defaultInputNames.slice(0, defaultSourceRank);
    const newOutputNames = defaultOutputSpace.names.slice(0, defaultSourceRank);
    const newOutputCoordinateArrays = defaultOutputSpace.coordinateArrays.slice(0, defaultSourceRank);
    const newOutputScales = new Float64Array(newRank);
    const newOutputUnits = [];
    for (let newDim = 0; newDim < newRank; ++newDim) {
      const specDim = newToSpecDimensionIndices[newDim];
      if (specDim === -1) {
        newOutputScales[newDim] = defaultOutputSpace.scales[newDim];
        newOutputUnits[newDim] = defaultOutputSpace.units[newDim];
        newOutputCoordinateArrays[newDim] = defaultOutputSpace.coordinateArrays[newDim];
      } else {
        newOutputNames[newDim] = specOutputSpace.names[specDim];
        newOutputUnits[newDim] = specOutputSpace.units[specDim];
        newOutputScales[newDim] = specOutputSpace.scales[specDim];
        newOutputCoordinateArrays[newDim] = specOutputSpace.coordinateArrays[specDim];
      }
    }
    if (!validateDimensionNames(newOutputNames)) {
      this.reset();
      return;
    }
    for (let newDim = defaultSourceRank; newDim < newRank; ++newDim) {
      const specDim = newDim - defaultSourceRank + specSourceRank;
      newInputScales[newDim] = specInputOrOutputSpace.scales[specDim];
      newInputUnits[newDim] = specInputOrOutputSpace.units[specDim];
      newInputNames[newDim] = `${newDim}`;
    }
    const newTransform = new Float64Array((newRank + 1) ** 2);
    newTransform[newTransform.length - 1] = 1;
    for (let newRow = 0; newRow < newRank; ++newRow) {
      const specRow = newToSpecDimensionIndices[newRow];
      let value;
      if (specRow === -1 || specTransformMatrix === void 0) {
        if (newRow >= defaultSourceRank) {
          value = 0;
        } else {
          value = defaultTransformMatrix[defaultRank * (defaultRank + 1) + newRow] * (defaultOutputSpace.scales[newRow] / newOutputScales[newRow]);
        }
      } else {
        value = specTransformMatrix[specRank * (specRank + 1) + specRow];
      }
      newTransform[newRank * (newRank + 1) + newRow] = value;
      for (let newCol = 0; newCol < newRank; ++newCol) {
        const specCol = newToSpecDimensionIndices[newCol];
        let value2;
        if (specRow === -1 != (specCol === -1)) {
          value2 = 0;
        } else if (specRow === -1 || specTransformMatrix === void 0) {
          if (specRow >= defaultSourceRank || specCol >= defaultSourceRank) {
            value2 = specRow === specCol ? 1 : 0;
          } else {
            value2 = defaultTransformMatrix[newCol * (defaultRank + 1) + newRow];
          }
        } else {
          value2 = specTransformMatrix[specCol * (specRank + 1) + specRow];
        }
        newTransform[newCol * (newRank + 1) + newRow] = value2;
      }
    }
    const boundingBoxes = defaultInputSpace.boundingBoxes.map((boundingBox) => extendTransformedBoundingBoxUpToRank(boundingBox, defaultRank, newRank));
    for (let i = defaultSourceRank; i < newRank; ++i) {
      boundingBoxes.push(makeSingletonDimTransformedBoundingBox(newRank, i));
    }
    for (let outputDim = 0; outputDim < newRank; ++outputDim) {
      const translation = newTransform[newRank * (newRank + 1) + outputDim];
      if (translation !== 0) continue;
      let singleInputDim = void 0;
      for (let inputDim = 0; inputDim < newRank; ++inputDim) {
        const factor = newTransform[inputDim * (newRank + 1) + outputDim];
        if (factor === 0) continue;
        if (factor === 1) {
          if (singleInputDim === void 0) {
            singleInputDim = inputDim;
          } else {
            singleInputDim = null;
            break;
          }
        } else {
          singleInputDim = null;
          break;
        }
      }
      if (singleInputDim == null) continue;
      let coordinateArray = newInputCoordinateArrays[singleInputDim];
      if (coordinateArray === void 0) continue;
      if (coordinateArray.explicit) {
        coordinateArray = _Object$assign(_Object$assign({}, coordinateArray), { explicit: false });
      }
      newOutputCoordinateArrays[outputDim] = mergeOptionalCoordinateArrays([coordinateArray, newOutputCoordinateArrays[outputDim]]);
    }
    this.value = {
      rank: newRank,
      transform: newTransform,
      sourceRank: defaultSourceRank,
      outputSpace: makeCoordinateSpace({
        rank: newRank,
        names: newOutputNames,
        scales: newOutputScales,
        units: newOutputUnits,
        coordinateArrays: newOutputCoordinateArrays
      }),
      inputSpace: makeCoordinateSpace({
        rank: newRank,
        names: newInputNames,
        scales: newInputScales,
        units: newInputUnits,
        coordinateArrays: newInputCoordinateArrays,
        boundingBoxes
      })
    };
  }
  toJSON() {
    return coordinateTransformSpecificationToJson(this.spec);
  }
  restoreState(obj) {
    this.spec = coordinateTransformSpecificationFromJson(obj);
  }
}
function expectDimensionName(obj, allowNumericalNames = false) {
  const name2 = verifyString(obj);
  if (!isValidDimensionName(name2, allowNumericalNames)) {
    throw new Error(`Invalid dimension name: ${_JSON$stringify(name2)}`);
  }
  return name2;
}
function dimensionNamesFromJson(obj, allowNumericalNames = false) {
  const dimensions = parseArray(obj, (x) => expectDimensionName(x, allowNumericalNames));
  if (!validateDimensionNames(dimensions, allowNumericalNames)) {
    throw new Error(`Invalid dimensions: ${_JSON$stringify(dimensions)}`);
  }
  return dimensions;
}
class CoordinateSpaceCombiner {
  constructor(combined, includeDimensionPredicate) {
    this.combined = combined;
    this.bindings = new _Set();
    this.retainCount = 0;
    this.prevCombined = this.combined.value;
    this.dimensionRefCounts = new _Map();
    this.handleCombinedChanged = () => {
      if (this.combined.value === this.prevCombined) return;
      this.update();
    };
    this.includeDimensionPredicate_ = includeDimensionPredicate;
  }
  getRenameValidity(newNames) {
    const existingNames = this.combined.value.names;
    const validity = getDimensionNameValidity(newNames);
    const rank = newNames.length;
    for (let i = 0; i < rank; ++i) {
      if (!validity[i]) continue;
      const newName = newNames[i];
      if (existingNames.includes(newName)) continue;
      let valid = true;
      for (const binding of this.bindings) {
        const otherNames = binding.space.value.names;
        if (otherNames.includes(newName)) {
          valid = false;
          break;
        }
      }
      validity[i] = valid;
    }
    return validity;
  }
  get includeDimensionPredicate() {
    return this.includeDimensionPredicate_;
  }
  set includeDimensionPredicate(value) {
    this.includeDimensionPredicate_ = value;
    this.update();
  }
  update() {
    const combined = this.combined, bindings = this.bindings;
    const retainExisting = this.retainCount > 0 ? 1 : 0;
    if (bindings.size === 0 && !retainExisting) {
      combined.value = emptyInvalidCoordinateSpace;
      return;
    }
    const include = this.includeDimensionPredicate_;
    const existing = combined.value;
    let mergedNames = _Array$from(existing.names);
    let mergedUnits = _Array$from(existing.units);
    let mergedScales = _Array$from(existing.scales);
    let mergedIds = _Array$from(existing.ids);
    let mergedTimestamps = _Array$from(existing.timestamps);
    let dimensionRefs = existing.names.map(() => retainExisting ? 1 : 0);
    const bindingCombinedIndices = [];
    let valid = false;
    for (const binding of bindings) {
      const space = binding.space.value, prevValue = binding.prevValue, mappedDimensionIds = binding.mappedDimensionIds;
      valid = valid || space.valid;
      const names = space.names, units = space.units, scales = space.scales, ids = space.ids, timestamps = space.timestamps;
      const newMappedDimensionIds = [];
      const combinedIndices = [];
      bindingCombinedIndices.push(combinedIndices);
      binding.mappedDimensionIds = newMappedDimensionIds;
      binding.prevValue = space;
      const rank = names.length;
      for (let i = 0; i < rank; ++i) {
        const name2 = names[i];
        if (!include(name2)) continue;
        if (prevValue !== void 0) {
          const id = ids[i];
          const prevIndex = prevValue.ids.indexOf(id);
          if (prevIndex !== -1) {
            const combinedId2 = mappedDimensionIds[prevIndex];
            if (combinedId2 !== void 0) {
              const combinedIndex2 = mergedIds.indexOf(combinedId2);
              if (combinedIndex2 !== -1) {
                newMappedDimensionIds[i] = combinedId2;
                ++dimensionRefs[combinedIndex2];
                combinedIndices[i] = combinedIndex2;
                const timestamp = timestamps[i];
                if (timestamp !== void 0 && !(timestamp <= mergedTimestamps[combinedIndex2])) {
                  mergedNames[combinedIndex2] = name2;
                  mergedScales[combinedIndex2] = scales[i];
                  mergedUnits[combinedIndex2] = units[i];
                  mergedTimestamps[combinedIndex2] = timestamp;
                }
                continue;
              }
            }
          }
        }
        let combinedIndex = mergedNames.indexOf(name2);
        if (combinedIndex !== -1) {
          newMappedDimensionIds[i] = mergedIds[combinedIndex];
          ++dimensionRefs[combinedIndex];
          combinedIndices[i] = combinedIndex;
          continue;
        }
        combinedIndex = mergedNames.length;
        combinedIndices[i] = combinedIndex;
        dimensionRefs[combinedIndex] = 1 + retainExisting;
        mergedNames[combinedIndex] = name2;
        mergedUnits[combinedIndex] = units[i];
        mergedScales[combinedIndex] = scales[i];
        mergedTimestamps[combinedIndex] = timestamps[i];
        const combinedId = newDimensionId();
        mergedIds[combinedIndex] = combinedId;
        newMappedDimensionIds[i] = combinedId;
      }
    }
    const dimensionRefCounts = this.dimensionRefCounts;
    dimensionRefCounts.clear();
    let bindingIndex = 0;
    let newRank = mergedNames.length;
    for (const binding of bindings) {
      const space = binding.space.value;
      const combinedIndices = bindingCombinedIndices[bindingIndex++];
      const rank = space.rank;
      const names = _Array$from(space.names);
      const timestamps = _Array$from(space.timestamps);
      const scales = Float64Array.from(space.scales);
      const units = _Array$from(space.units);
      for (let i = 0; i < rank; ++i) {
        const combinedIndex = combinedIndices[i];
        if (combinedIndex === void 0) continue;
        units[i] = mergedUnits[combinedIndex];
        scales[i] = mergedScales[combinedIndex];
        timestamps[i] = mergedTimestamps[combinedIndex];
        names[i] = mergedNames[combinedIndex];
      }
      for (const name2 of names) {
        let count = dimensionRefCounts.get(name2);
        if (count === void 0) {
          count = 1;
        } else {
          ++count;
        }
        dimensionRefCounts.set(name2, count);
      }
      if (!arraysEqual(units, space.units) || !arraysEqual(scales, space.scales) || !arraysEqual(names, space.names) || !arraysEqual(timestamps, space.timestamps)) {
        const newSpace = makeCoordinateSpace({
          valid: space.valid,
          ids: space.ids,
          scales,
          units,
          names,
          timestamps,
          boundingBoxes: space.boundingBoxes,
          coordinateArrays: space.coordinateArrays
        });
        binding.prevValue = newSpace;
        binding.space.value = newSpace;
      }
    }
    {
      for (let i = 0; i < newRank; ++i) {
        if (!include(mergedNames[i])) {
          dimensionRefs[i] = 0;
        }
      }
      const hasRefs = (_, i) => dimensionRefs[i] !== 0;
      mergedNames = mergedNames.filter(hasRefs);
      mergedUnits = mergedUnits.filter(hasRefs);
      mergedScales = mergedScales.filter(hasRefs);
      mergedIds = mergedIds.filter(hasRefs);
      mergedTimestamps = mergedTimestamps.filter(hasRefs);
      dimensionRefs = dimensionRefs.filter(hasRefs);
      newRank = mergedNames.length;
    }
    const mergedBoundingBoxes = [];
    const allCoordinateArrays = new Array(newRank);
    for (let i = 0, existingRank = existing.rank; i < existingRank; ++i) {
      const coordinateArray = existing.coordinateArrays[i];
      if (!(coordinateArray === null || coordinateArray === void 0 ? void 0 : coordinateArray.explicit)) continue;
      const newDim = mergedIds.indexOf(existing.ids[i]);
      if (newDim === -1) continue;
      allCoordinateArrays[newDim] = [coordinateArray];
    }
    for (const binding of bindings) {
      const space = binding.space.value;
      const rank = space.rank, boundingBoxes = space.boundingBoxes, coordinateArrays = space.coordinateArrays;
      const newDims = space.names.map((x) => mergedNames.indexOf(x));
      for (const oldBoundingBox of boundingBoxes) {
        mergedBoundingBoxes.push(extendTransformedBoundingBox(oldBoundingBox, newRank, newDims));
      }
      for (let i = 0; i < rank; ++i) {
        const coordinateArray = coordinateArrays[i];
        if (coordinateArray === void 0) continue;
        const newDim = newDims[i];
        const mergedList = allCoordinateArrays[newDim];
        if (mergedList === void 0) {
          allCoordinateArrays[newDim] = [coordinateArray];
        } else {
          mergedList.push(coordinateArray);
        }
      }
    }
    const mergedCoordinateArrays = new Array(newRank);
    for (let i = 0; i < newRank; ++i) {
      const mergedList = allCoordinateArrays[i];
      if (mergedList === void 0) continue;
      mergedCoordinateArrays[i] = mergeCoordinateArrays(mergedList);
    }
    const newCombined = makeCoordinateSpace({
      valid,
      ids: mergedIds,
      names: mergedNames,
      units: mergedUnits,
      scales: new Float64Array(mergedScales),
      boundingBoxes: mergedBoundingBoxes,
      coordinateArrays: mergedCoordinateArrays
    });
    if (retainExisting) {
      for (let i = 0; i < newRank; ++i) {
        --dimensionRefs[i];
      }
    }
    if (!coordinateSpacesEqual(existing, newCombined)) {
      this.prevCombined = newCombined;
      combined.value = newCombined;
    }
  }
  retain() {
    ++this.retainCount;
    return () => {
      if (--this.retainCount === 0) {
        this.update();
      }
    };
  }
  bind(space) {
    const binding = { space, mappedDimensionIds: [], prevValue: void 0 };
    const bindings = this.bindings;
    if (bindings.size === 0) {
      this.combined.changed.add(this.handleCombinedChanged);
    }
    bindings.add(binding);
    const changedDisposer = space.changed.add(() => {
      if (space.value === binding.prevValue) return;
      this.update();
    });
    const disposer = () => {
      changedDisposer();
      const bindings2 = this.bindings;
      bindings2.delete(binding);
      if (bindings2.size === 0) {
        this.combined.changed.remove(this.handleCombinedChanged);
      }
      this.update();
    };
    this.update();
    return disposer;
  }
}
function homogeneousTransformSubmatrix(constructor, oldTransform, oldRank, oldRows, oldCols) {
  const newRank = oldCols.length;
  const newTransform = new constructor((newRank + 1) ** 2);
  newTransform[newTransform.length - 1] = 1;
  for (let newRow = 0; newRow < newRank; ++newRow) {
    const oldRow = oldRows[newRow];
    newTransform[(newRank + 1) * newRank + newRow] = oldTransform[(oldRank + 1) * oldRank + oldRow];
    for (let newCol = 0; newCol < newRank; ++newCol) {
      const oldCol = oldCols[newCol];
      newTransform[(newRank + 1) * newCol + newRow] = oldTransform[(oldRank + 1) * oldCol + oldRow];
    }
  }
  return newTransform;
}
function coordinateTransformSpecificationFromLegacyJson(obj) {
  if (obj === void 0) return void 0;
  const transform = new Float64Array(16);
  if (Array.isArray(obj)) {
    if (obj.length === 16) {
      for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
          transform[i * 4 + j] = verifyFiniteFloat(obj[j * 4 + i]);
        }
      }
    } else {
      expectArray(obj, 4);
      for (let i = 0; i < 4; ++i) {
        const row = expectArray(obj[i], 4);
        for (let j = 0; j < 4; ++j) {
          transform[j * 4 + i] = verifyFiniteFloat(row[j]);
        }
      }
    }
  } else {
    verifyObject(obj);
    const rotation = create$1();
    const translation = create$3();
    const scale2 = fromValues$1(1, 1, 1);
    verifyOptionalObjectProperty(obj, "rotation", (x) => {
      parseFiniteVec(rotation, x);
      normalize(rotation, rotation);
    });
    verifyOptionalObjectProperty(obj, "translation", (x) => {
      parseFiniteVec(translation, x);
    });
    verifyOptionalObjectProperty(obj, "scale", (x) => {
      parseFiniteVec(scale2, x);
    });
    const tempMat42 = create$4();
    fromRotationTranslationScale(tempMat42, rotation, translation, scale2);
    transform.set(tempMat42);
  }
  return {
    sourceRank: 3,
    transform,
    outputSpace: makeCoordinateSpace({
      valid: true,
      names: ["x", "y", "z"],
      units: ["m", "m", "m"],
      scales: Float64Array.of(1e-9, 1e-9, 1e-9)
    }),
    inputSpace: void 0
  };
}
function coordinateTransformSpecificationFromJson(j) {
  if (j === void 0) return void 0;
  const obj = verifyObject(j);
  const outputSpace = verifyObjectProperty(obj, "outputDimensions", coordinateSpaceFromJson);
  const rank = outputSpace.rank;
  const sourceRank = verifyObjectProperty(obj, "sourceRank", (rankObj) => {
    if (rankObj === void 0) return rank;
    if (!_Number$isInteger(rankObj) || rankObj < 0 || rankObj > rank) {
      throw new Error(`Expected integer in range [0, ${rank}] but received: ${_JSON$stringify(rankObj)}`);
    }
    return rankObj;
  });
  const inputSpace = verifyOptionalObjectProperty(obj, "inputDimensions", (inputSpaceObj) => {
    const space = coordinateSpaceFromJson(inputSpaceObj, true);
    if (space.rank !== rank) {
      throw new Error(`Expected rank of ${rank}, but received rank of: ${space.rank}`);
    }
    return space;
  });
  const transform = verifyOptionalObjectProperty(obj, "matrix", (x) => {
    const transform2 = new Float64Array((rank + 1) ** 2);
    const a = expectArray(x, rank);
    transform2[transform2.length - 1] = 1;
    for (let i = 0; i < rank; ++i) {
      try {
        const row = expectArray(a[i], rank + 1);
        for (let j2 = 0; j2 <= rank; ++j2) {
          transform2[(rank + 1) * j2 + i] = verifyFiniteFloat(row[j2]);
        }
      } catch (e) {
        throw new Error(`Error in row ${i}: ${e.message}`);
      }
    }
    return transform2;
  });
  return { transform, outputSpace, inputSpace, sourceRank };
}
function coordinateTransformSpecificationToJson(spec) {
  if (spec === void 0) return void 0;
  const transform = spec.transform, outputSpace = spec.outputSpace, inputSpace = spec.inputSpace, sourceRank = spec.sourceRank;
  let m;
  const rank = outputSpace.rank;
  if (transform !== void 0) {
    m = [];
    for (let i = 0; i < rank; ++i) {
      const row = [];
      m[i] = row;
      for (let j = 0; j <= rank; ++j) {
        row[j] = transform[(rank + 1) * j + i];
      }
    }
  }
  return {
    sourceRank: sourceRank === rank ? void 0 : sourceRank,
    matrix: m,
    outputDimensions: coordinateSpaceToJson(outputSpace),
    inputDimensions: inputSpace === void 0 ? void 0 : coordinateSpaceToJson(inputSpace)
  };
}
function permuteTransformedBoundingBox(boundingBox, newToOld, oldOutputRank) {
  const box2 = boundingBox.box, transform = boundingBox.transform;
  const inputRank = boundingBox.box.lowerBounds.length;
  const outputRank = newToOld.length;
  const newTransform = new Float64Array((inputRank + 1) * outputRank);
  for (let outputDim = 0; outputDim < outputRank; ++outputDim) {
    for (let inputDim = 0; inputDim <= inputRank; ++inputDim) {
      const oldOutputDim = newToOld[outputDim];
      newTransform[outputDim + inputDim * outputRank] = transform[oldOutputDim + inputDim * oldOutputRank];
    }
  }
  if (newTransform.every((x) => x === 0)) return void 0;
  return {
    transform: newTransform,
    box: box2
  };
}
function permuteCoordinateSpace(existing, newToOld) {
  const ids = existing.ids, names = existing.names, scales = existing.scales, units = existing.units, timestamps = existing.timestamps, coordinateArrays = existing.coordinateArrays;
  return makeCoordinateSpace({
    rank: newToOld.length,
    valid: existing.valid,
    ids: newToOld.map((i) => ids[i]),
    names: newToOld.map((i) => names[i]),
    timestamps: newToOld.map((i) => timestamps[i]),
    scales: Float64Array.from(newToOld, (i) => scales[i]),
    units: newToOld.map((i) => units[i]),
    coordinateArrays: newToOld.map((i) => coordinateArrays[i]),
    boundingBoxes: existing.boundingBoxes.map((b) => permuteTransformedBoundingBox(b, newToOld, existing.rank)).filter((b) => b !== void 0)
  });
}
function insertDimensionAt(existing, targetIndex, sourceIndex) {
  if (targetIndex === sourceIndex) return existing;
  return permuteCoordinateSpace(existing, getInsertPermutation(existing.rank, sourceIndex, targetIndex));
}
function getInferredOutputScale(transform, outputDim) {
  const transformMatrix = transform.transform, rank = transform.rank;
  const inputDims = getDependentTransformInputDimensions(transformMatrix, rank, [outputDim]);
  if (inputDims.length !== 1) return void 0;
  var _inputDims = _slicedToArray(inputDims, 1);
  const inputDim = _inputDims[0];
  const coeff = Math.abs(transformMatrix[(rank + 1) * inputDim + outputDim]);
  const inputSpace = transform.inputSpace;
  return { scale: inputSpace.scales[inputDim] * coeff, unit: inputSpace.units[inputDim] };
}
function getDefaultInputScale(transform, inputDim) {
  var _transform$defaultInp = transform.defaultInputSpace;
  const defaultScales = _transform$defaultInp.scales, defaultUnits = _transform$defaultInp.units;
  return inputDim < defaultScales.length ? { scale: defaultScales[inputDim], unit: defaultUnits[inputDim] } : void 0;
}
function getChannelSpace(channelCoordinateSpace) {
  const rank = channelCoordinateSpace.rank;
  var _channelCoordinateSpa = channelCoordinateSpace.bounds;
  const lowerBounds = _channelCoordinateSpa.lowerBounds, upperBounds = _channelCoordinateSpa.upperBounds;
  if (lowerBounds.some((x) => x !== 0)) {
    throw new Error("Lower bounds of channel coordinate space must all be 0");
  }
  if (upperBounds.some((x) => !_Number$isInteger(x) || x <= 0 || x >= 2 ** 32)) {
    throw new Error("Upper bounds of channel coordinate space must all be positive integers");
  }
  const shape = new Uint32Array(upperBounds);
  const numChannels = prod(shape);
  const coordinates = new Uint32Array(numChannels * rank);
  for (let flatIndex = 0; flatIndex < numChannels; ++flatIndex) {
    let remainder = flatIndex;
    for (let dim = 0; dim < rank; ++dim) {
      const coordinate = remainder % shape[dim];
      remainder = (remainder - coordinate) / shape[dim];
      coordinates[flatIndex * rank + dim] = coordinate;
    }
  }
  return { channelCoordinateSpace, shape, numChannels, coordinates };
}
function scaleTransformSubmatrix(transform, rank, baseInputSpace, inputToBaseDimensions, baseOutputSpace, baseToOutputDimensions) {
  const baseInputScales = baseInputSpace.scales;
  const baseOutputScales = baseOutputSpace.scales, baseOutputRank = baseOutputSpace.rank;
  const stride = rank + 1;
  for (let baseOutputDim = 0; baseOutputDim < baseOutputRank; ++baseOutputDim) {
    const outputDim = baseToOutputDimensions[baseOutputDim];
    if (outputDim === -1) continue;
    const baseOutputScale = baseOutputScales[baseOutputDim];
    for (let inputDim = 0; inputDim < rank; ++inputDim) {
      const baseInputDim = inputToBaseDimensions[inputDim];
      const baseInputScale = baseInputScales[baseInputDim];
      transform[stride * inputDim + outputDim] *= baseInputScale / baseOutputScale;
    }
  }
}
function getRenderLayerTransform(globalCoordinateSpace, localCoordinateSpace, modelToLayerTransform, subsourceEntry, channelCoordinateSpace = emptyValidCoordinateSpace) {
  const modelSpace = modelToLayerTransform.inputSpace, fullRank = modelToLayerTransform.rank, sourceRank = modelToLayerTransform.sourceRank, layerSpace = modelToLayerTransform.outputSpace, oldTransform = modelToLayerTransform.transform;
  const modelDimensionNames = modelSpace.names;
  const transformOutputDimensions = layerSpace.names;
  let requiredInputDims;
  if (subsourceEntry !== void 0) {
    requiredInputDims = _Array$from(subsourceEntry.modelSubspaceDimensionIndices);
  } else {
    requiredInputDims = [];
    for (let i = 0; i < sourceRank; ++i) {
      requiredInputDims[i] = i;
    }
  }
  const unpaddedRank = requiredInputDims.length;
  for (let i = sourceRank; i < fullRank; ++i) {
    requiredInputDims.push(i);
  }
  const requiredOutputDims = getDependentTransformInputDimensions(modelToLayerTransform.transform, fullRank, requiredInputDims, true);
  const subspaceRank = requiredInputDims.length;
  const modelSubspaceDimensionNames = requiredInputDims.map((i) => modelDimensionNames[i] || `${i}`);
  const layerSubspaceDimensionNames = requiredOutputDims.map((i) => transformOutputDimensions[i]);
  if (subspaceRank !== requiredOutputDims.length) {
    return {
      error: "Rank mismatch between model subspace dimensions (" + modelSubspaceDimensionNames.join(", ") + ") and corresponding layer/global dimensions (" + layerSubspaceDimensionNames.join(", ") + ")"
    };
  }
  let newTransform = homogeneousTransformSubmatrix(Float32Array, oldTransform, fullRank, requiredOutputDims, requiredInputDims);
  const renderLayerDimensions = requiredOutputDims.map((i) => transformOutputDimensions[i]);
  const localToRenderLayerDimensions = localCoordinateSpace.names.map((x) => renderLayerDimensions.indexOf(x));
  const globalToRenderLayerDimensions = globalCoordinateSpace.names.map((x) => renderLayerDimensions.indexOf(x));
  scaleTransformSubmatrix(newTransform, subspaceRank, modelSpace, requiredInputDims, globalCoordinateSpace, globalToRenderLayerDimensions);
  scaleTransformSubmatrix(newTransform, subspaceRank, modelSpace, requiredInputDims, localCoordinateSpace, localToRenderLayerDimensions);
  const channelToRenderLayerDimensions = channelCoordinateSpace.names.map((x) => renderLayerDimensions.indexOf(x));
  scaleTransformSubmatrix(newTransform, subspaceRank, modelSpace, requiredInputDims, channelCoordinateSpace, channelToRenderLayerDimensions);
  const channelToModelSubspaceDimensions = [];
  const channelRank = channelCoordinateSpace.rank;
  if (subsourceEntry !== void 0) {
    let subsourceToModelSubspaceTransform = subsourceEntry.subsourceToModelSubspaceTransform;
    if (unpaddedRank !== subspaceRank) {
      subsourceToModelSubspaceTransform = extendHomogeneousTransform(new Float32Array((subspaceRank + 1) ** 2), subspaceRank, subsourceToModelSubspaceTransform, unpaddedRank);
    }
    newTransform = multiply(new Float32Array((subspaceRank + 1) ** 2), subspaceRank + 1, newTransform, subspaceRank + 1, subsourceToModelSubspaceTransform, subspaceRank + 1, subspaceRank + 1, subspaceRank + 1, subspaceRank + 1);
  }
  const channelSpaceShape = new Uint32Array(channelRank);
  for (let channelDim = 0; channelDim < channelRank; ++channelDim) {
    const lower = channelCoordinateSpace.bounds.lowerBounds[channelDim];
    const upper = channelCoordinateSpace.bounds.upperBounds[channelDim];
    if (lower !== 0 || !_Number$isInteger(upper) || upper <= 0 || upper >= 2 ** 32) {
      return {
        error: `Channel dimension ${channelCoordinateSpace.names[channelDim]} must have lower bound of 0 and positive integer upper bound`
      };
    }
    channelSpaceShape[channelDim] = upper;
    const layerDim = channelToRenderLayerDimensions[channelDim];
    let correspondingModelSubspaceDim = -1;
    if (layerDim !== -1) {
      for (let chunkDim = 0; chunkDim < subspaceRank; ++chunkDim) {
        const coeff = newTransform[layerDim + chunkDim * (subspaceRank + 1)];
        if (coeff === 0) continue;
        if (coeff !== 1 || correspondingModelSubspaceDim !== -1) {
          return {
            error: `Channel dimension ${layerSubspaceDimensionNames[layerDim]} must map to a single source dimension`
          };
        }
        correspondingModelSubspaceDim = chunkDim;
      }
    }
    channelToModelSubspaceDimensions[channelDim] = correspondingModelSubspaceDim;
  }
  return {
    rank: subspaceRank,
    unpaddedRank,
    modelDimensionNames: modelSubspaceDimensionNames,
    layerDimensionNames: layerSubspaceDimensionNames,
    localToRenderLayerDimensions,
    globalToRenderLayerDimensions,
    channelToRenderLayerDimensions,
    modelToRenderLayerTransform: newTransform,
    channelToModelDimensions: channelToModelSubspaceDimensions,
    channelSpaceShape
  };
}
function renderLayerTransformsEqual(a, b) {
  if (a === b) return true;
  if (a.error !== void 0 || b.error !== void 0) return false;
  return arraysEqual(a.modelDimensionNames, b.modelDimensionNames) && arraysEqual(a.layerDimensionNames, b.layerDimensionNames) && arraysEqual(a.globalToRenderLayerDimensions, b.globalToRenderLayerDimensions) && arraysEqual(a.localToRenderLayerDimensions, b.localToRenderLayerDimensions) && arraysEqual(a.channelToRenderLayerDimensions, b.channelToRenderLayerDimensions) && arraysEqual(a.modelToRenderLayerTransform, b.modelToRenderLayerTransform) && arraysEqual(a.channelSpaceShape, b.channelSpaceShape);
}
function getWatchableRenderLayerTransform(globalCoordinateSpace, localCoordinateSpace, modelToLayerTransform, subsourceEntry, channelCoordinateSpace) {
  return makeCachedDerivedWatchableValue((globalCoordinateSpace2, localCoordinateSpace2, modelToLayerTransform2, channelCoordinateSpace2) => getRenderLayerTransform(globalCoordinateSpace2, localCoordinateSpace2, modelToLayerTransform2, subsourceEntry, channelCoordinateSpace2), [globalCoordinateSpace, localCoordinateSpace, modelToLayerTransform, channelCoordinateSpace === void 0 ? constantWatchableValue(void 0) : channelCoordinateSpace], renderLayerTransformsEqual);
}
function layerToDisplayCoordinates(displayPosition, layerPosition, modelTransform, displayDimensionIndices) {
  const globalToRenderLayerDimensions = modelTransform.globalToRenderLayerDimensions;
  for (let displayDim = 0; displayDim < 3; ++displayDim) {
    let v = 0;
    const globalDim = displayDimensionIndices[displayDim];
    if (globalDim !== -1) {
      const layerDim = globalToRenderLayerDimensions[globalDim];
      if (layerDim !== -1) {
        v = layerPosition[layerDim];
      }
    }
    displayPosition[displayDim] = v;
  }
}
function displayToLayerCoordinates(layerPosition, displayPosition, modelTransform, displayDimensionIndices) {
  const globalToRenderLayerDimensions = modelTransform.globalToRenderLayerDimensions;
  for (let displayDim = 0; displayDim < 3; ++displayDim) {
    const globalDim = displayDimensionIndices[displayDim];
    if (globalDim !== -1) {
      const layerDim = globalToRenderLayerDimensions[globalDim];
      if (layerDim !== -1) {
        layerPosition[layerDim] = displayPosition[displayDim];
      }
    }
  }
}
function getChunkTransformParameters(modelTransform, chunkToModelTransform) {
  const layerRank = modelTransform.rank;
  const unpaddedRank = modelTransform.unpaddedRank;
  let chunkToLayerTransform;
  if (unpaddedRank !== layerRank && chunkToModelTransform !== void 0) {
    chunkToModelTransform = extendHomogeneousTransform(new Float32Array((layerRank + 1) ** 2), layerRank, chunkToModelTransform, unpaddedRank);
  }
  if (chunkToModelTransform !== void 0) {
    chunkToLayerTransform = new Float32Array((layerRank + 1) * (layerRank + 1));
    multiply(chunkToLayerTransform, layerRank + 1, modelTransform.modelToRenderLayerTransform, layerRank + 1, chunkToModelTransform, layerRank + 1, layerRank + 1, layerRank + 1, layerRank + 1);
  } else {
    chunkToLayerTransform = modelTransform.modelToRenderLayerTransform;
  }
  const layerToChunkTransform = new Float32Array((layerRank + 1) * (layerRank + 1));
  const det = inverse(layerToChunkTransform, layerRank + 1, chunkToLayerTransform, layerRank + 1, layerRank + 1);
  if (det === 0) {
    throw new Error(`Transform is singular`);
  }
  const globalToRenderLayerDimensions = modelTransform.globalToRenderLayerDimensions, localToRenderLayerDimensions = modelTransform.localToRenderLayerDimensions, channelToRenderLayerDimensions = modelTransform.channelToRenderLayerDimensions;
  const globalRank = globalToRenderLayerDimensions.length;
  const localRank = localToRenderLayerDimensions.length;
  const combinedGlobalLocalRank = globalRank + localRank;
  const combinedGlobalLocalToChunkTransform = new Float32Array((combinedGlobalLocalRank + 1) * layerRank);
  for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {
    for (let globalDim = 0; globalDim < globalRank; ++globalDim) {
      const layerDim = globalToRenderLayerDimensions[globalDim];
      if (layerDim === -1) continue;
      combinedGlobalLocalToChunkTransform[chunkDim + globalDim * layerRank] = layerToChunkTransform[chunkDim + layerDim * (layerRank + 1)];
    }
    for (let localDim = 0; localDim < localRank; ++localDim) {
      const layerDim = localToRenderLayerDimensions[localDim];
      if (layerDim === -1) continue;
      combinedGlobalLocalToChunkTransform[chunkDim + (globalRank + localDim) * layerRank] = layerToChunkTransform[chunkDim + layerDim * (layerRank + 1)];
    }
    combinedGlobalLocalToChunkTransform[chunkDim + combinedGlobalLocalRank * layerRank] = layerToChunkTransform[chunkDim + layerRank * (layerRank + 1)];
  }
  const channelRank = channelToRenderLayerDimensions.length;
  let channelToChunkDimensionIndices = new Array(channelRank);
  const chunkChannelDimensionIndices = [];
  for (let channelDim = 0; channelDim < channelRank; ++channelDim) {
    const layerDim = channelToRenderLayerDimensions[channelDim];
    let correspondingChunkDim = -1;
    if (layerDim !== -1) {
      for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {
        const coeff = chunkToLayerTransform[layerDim + chunkDim * (layerRank + 1)];
        if (coeff === 0) continue;
        if (coeff !== 1 || correspondingChunkDim !== -1) {
          throw new Error(`Channel dimension ${modelTransform.layerDimensionNames[layerDim]} must map with stride 1 to a single data chunk dimensions`);
        }
        correspondingChunkDim = chunkDim;
      }
      if (correspondingChunkDim !== -1) {
        if (chunkToLayerTransform[layerDim + layerRank * (layerRank + 1)] !== 0) {
          throw new Error(`Channel dimension ${modelTransform.layerDimensionNames[layerDim]} must have an offset of 0 in the chunk coordinate space`);
        }
        chunkChannelDimensionIndices.push(correspondingChunkDim);
      }
    }
    channelToChunkDimensionIndices[channelDim] = correspondingChunkDim;
  }
  const channelSpaceShape = modelTransform.channelSpaceShape;
  const numChannels = prod(channelSpaceShape);
  const chunkChannelRank = chunkChannelDimensionIndices.length;
  const chunkChannelCoordinates = new Uint32Array(numChannels * chunkChannelRank);
  for (let channelIndex = 0; channelIndex < numChannels; ++channelIndex) {
    let remainder = channelIndex;
    let chunkChannelDim = 0;
    for (let channelDim = 0; channelDim < channelRank; ++channelDim) {
      const coordinate = remainder % channelSpaceShape[channelDim];
      remainder = (remainder - coordinate) / channelSpaceShape[channelDim];
      const chunkDim = channelToChunkDimensionIndices[channelDim];
      if (chunkDim !== -1) {
        chunkChannelCoordinates[channelIndex * chunkChannelRank + chunkChannelDim] = coordinate;
        ++chunkChannelDim;
      }
    }
  }
  return {
    layerRank,
    modelTransform,
    chunkToLayerTransform,
    layerToChunkTransform,
    chunkToLayerTransformDet: det,
    combinedGlobalLocalRank,
    combinedGlobalLocalToChunkTransform,
    channelToChunkDimensionIndices,
    chunkChannelDimensionIndices,
    numChannels,
    chunkChannelCoordinates,
    channelSpaceShape
  };
}
function getLayerDisplayDimensionMapping(transform, displayDimensionIndices) {
  const globalToRenderLayerDimensions = transform.globalToRenderLayerDimensions;
  const layerDisplayDimensionIndices = [];
  const displayToLayerDimensionIndices = [];
  for (let displayDim = 0; displayDim < 3; ++displayDim) {
    const globalDim = displayDimensionIndices[displayDim];
    if (globalDim == -1) continue;
    const layerDim = globalToRenderLayerDimensions[globalDim];
    displayToLayerDimensionIndices.push(layerDim);
    if (layerDim === -1) continue;
    layerDisplayDimensionIndices.push(layerDim);
  }
  for (let i = displayToLayerDimensionIndices.length; i < 3; ++i) {
    displayToLayerDimensionIndices[i] = -1;
  }
  return { layerDisplayDimensionIndices, displayToLayerDimensionIndices };
}
function getChunkDisplayTransformParameters(chunkTransform, layerDisplayDimensionMapping) {
  const chunkToLayerTransform = chunkTransform.chunkToLayerTransform, modelTransform = chunkTransform.modelTransform;
  const rank = modelTransform.rank;
  const layerDisplayDimensionIndices = layerDisplayDimensionMapping.layerDisplayDimensionIndices, displayToLayerDimensionIndices = layerDisplayDimensionMapping.displayToLayerDimensionIndices;
  const numLayerDisplayDims = layerDisplayDimensionIndices.length;
  const chunkDisplayDimensionIndices = getDependentTransformInputDimensions(chunkToLayerTransform, rank, layerDisplayDimensionIndices);
  if (chunkDisplayDimensionIndices.length !== numLayerDisplayDims) {
    const modelDimensionNames = modelTransform.modelDimensionNames, layerDimensionNames = modelTransform.layerDimensionNames;
    throw new Error(`Rank mismatch between displayed layer dimensions (${_Array$from(layerDisplayDimensionIndices, (i) => layerDimensionNames[i]).join(", ")}) and corresponding chunk dimensions (${_Array$from(chunkDisplayDimensionIndices, (i) => modelDimensionNames[i]).join(", ")})`);
  }
  const displaySubspaceModelMatrix = create$4();
  for (let displayDim = 0; displayDim < 3; ++displayDim) {
    const layerDim = displayToLayerDimensionIndices[displayDim];
    if (layerDim === -1) continue;
    for (let chunkDisplayDimIndex = 0; chunkDisplayDimIndex < numLayerDisplayDims; ++chunkDisplayDimIndex) {
      const chunkDim = chunkDisplayDimensionIndices[chunkDisplayDimIndex];
      displaySubspaceModelMatrix[chunkDisplayDimIndex * 4 + displayDim] = chunkToLayerTransform[chunkDim * (rank + 1) + layerDim];
    }
    displaySubspaceModelMatrix[12 + displayDim] = chunkToLayerTransform[rank * (rank + 1) + layerDim];
  }
  const displaySubspaceInvModelMatrix = create$4();
  invert$1(displaySubspaceInvModelMatrix, displaySubspaceModelMatrix);
  for (let i = chunkDisplayDimensionIndices.length; i < 3; ++i) {
    chunkDisplayDimensionIndices[i] = -1;
  }
  return {
    modelTransform: chunkTransform.modelTransform,
    chunkTransform,
    displaySubspaceModelMatrix,
    displaySubspaceInvModelMatrix,
    chunkDisplayDimensionIndices,
    numChunkDisplayDims: numLayerDisplayDims
  };
}
function getChunkPositionFromCombinedGlobalLocalPositions(chunkPosition, globalPosition, localPosition, layerRank, combinedGlobalLocalToChunkTransform) {
  const globalRank = globalPosition.length;
  const localRank = localPosition.length;
  const rank = chunkPosition.length;
  let valid = true;
  for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {
    let off = chunkDim;
    let sum = 0;
    for (let globalDim = 0; globalDim < globalRank; ++globalDim) {
      sum += combinedGlobalLocalToChunkTransform[off + globalDim * layerRank] * globalPosition[globalDim];
    }
    off += globalRank * layerRank;
    for (let localDim = 0; localDim < localRank; ++localDim) {
      sum += combinedGlobalLocalToChunkTransform[off + localDim * layerRank] * localPosition[localDim];
    }
    sum += combinedGlobalLocalToChunkTransform[off + localRank * layerRank];
    if (chunkDim < rank) {
      chunkPosition[chunkDim] = sum;
    } else {
      if (sum < 0 || sum >= 1) {
        valid = false;
      }
    }
  }
  return valid;
}
function get3dModelToDisplaySpaceMatrix(out, displayDimensionRenderInfo, transform) {
  out.fill(0);
  out[15] = 1;
  let fullRank = true;
  const displayDimensionIndices = displayDimensionRenderInfo.displayDimensionIndices;
  const globalToRenderLayerDimensions = transform.globalToRenderLayerDimensions, modelToRenderLayerTransform = transform.modelToRenderLayerTransform;
  const layerRank = transform.rank;
  for (let displayDim = 0; displayDim < 3; ++displayDim) {
    const globalDim = displayDimensionIndices[displayDim];
    if (globalDim === -1) {
      fullRank = false;
      continue;
    }
    const layerDim = globalToRenderLayerDimensions[globalDim];
    if (layerDim === -1) {
      fullRank = false;
      continue;
    }
    out[displayDim + 12] = modelToRenderLayerTransform[layerDim + layerRank * (layerRank + 1)];
    for (let modelDim = 0; modelDim < 3; ++modelDim) {
      out[displayDim + 4 * modelDim] = modelToRenderLayerTransform[layerDim + (layerRank + 1) * modelDim];
    }
  }
  if (!fullRank) {
    const globalDimensionNames = displayDimensionRenderInfo.globalDimensionNames;
    const displayDimDesc = _Array$from(displayDimensionIndices.filter((i) => i !== -1), (i) => globalDimensionNames[i]).join(", ");
    throw new Error(`Transform from model dimensions (${transform.modelDimensionNames.join(", ")}) to display dimensions (${displayDimDesc}) does not have full rank`);
  }
}
var getOwnPropertySymbols$1;
var hasRequiredGetOwnPropertySymbols$1;
function requireGetOwnPropertySymbols$1() {
  if (hasRequiredGetOwnPropertySymbols$1) return getOwnPropertySymbols$1;
  hasRequiredGetOwnPropertySymbols$1 = 1;
  requireEs6_symbol();
  getOwnPropertySymbols$1 = require_core().Object.getOwnPropertySymbols;
  return getOwnPropertySymbols$1;
}
var getOwnPropertySymbols;
var hasRequiredGetOwnPropertySymbols;
function requireGetOwnPropertySymbols() {
  if (hasRequiredGetOwnPropertySymbols) return getOwnPropertySymbols;
  hasRequiredGetOwnPropertySymbols = 1;
  getOwnPropertySymbols = { "default": requireGetOwnPropertySymbols$1(), __esModule: true };
  return getOwnPropertySymbols;
}
var getOwnPropertySymbolsExports = requireGetOwnPropertySymbols();
const _Object$getOwnPropertySymbols = /* @__PURE__ */ getDefaultExportFromCjs(getOwnPropertySymbolsExports);
var definePropertyExports = requireDefineProperty();
const _Object$defineProperty = /* @__PURE__ */ getDefaultExportFromCjs(definePropertyExports);
var es6_object_getOwnPropertyDescriptor = {};
var hasRequiredEs6_object_getOwnPropertyDescriptor;
function requireEs6_object_getOwnPropertyDescriptor() {
  if (hasRequiredEs6_object_getOwnPropertyDescriptor) return es6_object_getOwnPropertyDescriptor;
  hasRequiredEs6_object_getOwnPropertyDescriptor = 1;
  var toIObject = require_toIobject();
  var $getOwnPropertyDescriptor = require_objectGopd().f;
  require_objectSap()("getOwnPropertyDescriptor", function() {
    return function getOwnPropertyDescriptor2(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  return es6_object_getOwnPropertyDescriptor;
}
var getOwnPropertyDescriptor$1;
var hasRequiredGetOwnPropertyDescriptor$1;
function requireGetOwnPropertyDescriptor$1() {
  if (hasRequiredGetOwnPropertyDescriptor$1) return getOwnPropertyDescriptor$1;
  hasRequiredGetOwnPropertyDescriptor$1 = 1;
  requireEs6_object_getOwnPropertyDescriptor();
  var $Object = require_core().Object;
  getOwnPropertyDescriptor$1 = function getOwnPropertyDescriptor2(it, key) {
    return $Object.getOwnPropertyDescriptor(it, key);
  };
  return getOwnPropertyDescriptor$1;
}
var getOwnPropertyDescriptor;
var hasRequiredGetOwnPropertyDescriptor;
function requireGetOwnPropertyDescriptor() {
  if (hasRequiredGetOwnPropertyDescriptor) return getOwnPropertyDescriptor;
  hasRequiredGetOwnPropertyDescriptor = 1;
  getOwnPropertyDescriptor = { "default": requireGetOwnPropertyDescriptor$1(), __esModule: true };
  return getOwnPropertyDescriptor;
}
var getOwnPropertyDescriptorExports = requireGetOwnPropertyDescriptor();
const _Object$getOwnPropertyDescriptor = /* @__PURE__ */ getDefaultExportFromCjs(getOwnPropertyDescriptorExports);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ChunkState;
(function(ChunkState2) {
  ChunkState2[ChunkState2["GPU_MEMORY"] = 0] = "GPU_MEMORY";
  ChunkState2[ChunkState2["SYSTEM_MEMORY"] = 1] = "SYSTEM_MEMORY";
  ChunkState2[ChunkState2["SYSTEM_MEMORY_WORKER"] = 2] = "SYSTEM_MEMORY_WORKER";
  ChunkState2[ChunkState2["DOWNLOADING"] = 3] = "DOWNLOADING";
  ChunkState2[ChunkState2["QUEUED"] = 4] = "QUEUED";
  ChunkState2[ChunkState2["NEW"] = 5] = "NEW";
  ChunkState2[ChunkState2["FAILED"] = 6] = "FAILED";
  ChunkState2[ChunkState2["EXPIRED"] = 7] = "EXPIRED";
})(ChunkState || (ChunkState = {}));
const numChunkStates = 8;
var ChunkPriorityTier;
(function(ChunkPriorityTier2) {
  ChunkPriorityTier2[ChunkPriorityTier2["FIRST_TIER"] = 0] = "FIRST_TIER";
  ChunkPriorityTier2[ChunkPriorityTier2["FIRST_ORDERED_TIER"] = 0] = "FIRST_ORDERED_TIER";
  ChunkPriorityTier2[ChunkPriorityTier2["VISIBLE"] = 0] = "VISIBLE";
  ChunkPriorityTier2[ChunkPriorityTier2["PREFETCH"] = 1] = "PREFETCH";
  ChunkPriorityTier2[ChunkPriorityTier2["LAST_ORDERED_TIER"] = 1] = "LAST_ORDERED_TIER";
  ChunkPriorityTier2[ChunkPriorityTier2["RECENT"] = 2] = "RECENT";
  ChunkPriorityTier2[ChunkPriorityTier2["LAST_TIER"] = 2] = "LAST_TIER";
})(ChunkPriorityTier || (ChunkPriorityTier = {}));
const numChunkPriorityTiers = 3;
var ChunkDownloadStatistics;
(function(ChunkDownloadStatistics2) {
  ChunkDownloadStatistics2[ChunkDownloadStatistics2["totalTime"] = 0] = "totalTime";
  ChunkDownloadStatistics2[ChunkDownloadStatistics2["totalChunks"] = 1] = "totalChunks";
})(ChunkDownloadStatistics || (ChunkDownloadStatistics = {}));
var ChunkMemoryStatistics;
(function(ChunkMemoryStatistics2) {
  ChunkMemoryStatistics2[ChunkMemoryStatistics2["numChunks"] = 0] = "numChunks";
  ChunkMemoryStatistics2[ChunkMemoryStatistics2["systemMemoryBytes"] = 1] = "systemMemoryBytes";
  ChunkMemoryStatistics2[ChunkMemoryStatistics2["gpuMemoryBytes"] = 2] = "gpuMemoryBytes";
})(ChunkMemoryStatistics || (ChunkMemoryStatistics = {}));
const numChunkMemoryStatistics = 3;
function getChunkStateStatisticIndex(state, priorityTier) {
  return state * numChunkPriorityTiers + priorityTier;
}
function getChunkDownloadStatisticIndex(statistic) {
  return numChunkStates * numChunkPriorityTiers * numChunkMemoryStatistics + statistic;
}
const CHUNK_QUEUE_MANAGER_RPC_ID = "ChunkQueueManager";
const CHUNK_MANAGER_RPC_ID = "ChunkManager";
const CHUNK_SOURCE_INVALIDATE_RPC_ID = "ChunkSource.invalidate";
const REQUEST_CHUNK_STATISTICS_RPC_ID = "ChunkQueueManager.requestChunkStatistics";
const CHUNK_LAYER_STATISTICS_RPC_ID = "ChunkManager.chunkLayerStatistics";
class LayerChunkProgressInfo {
  constructor() {
    this.numVisibleChunksNeeded = 0;
    this.numVisibleChunksAvailable = 0;
    this.numPrefetchChunksNeeded = 0;
    this.numPrefetchChunksAvailable = 0;
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function animationFrameDebounce(callback) {
  let handle = -1;
  const cancel = () => {
    if (handle !== -1) {
      cancelAnimationFrame(handle);
      handle = -1;
    }
  };
  const flush = () => {
    if (handle !== -1) {
      handle = -1;
      callback();
    }
  };
  return _Object$assign(() => {
    if (handle === -1) {
      handle = requestAnimationFrame(() => {
        handle = -1;
        callback();
      });
    }
  }, { flush, cancel });
}
class Memoize {
  constructor() {
    this.map = new _Map();
  }
  /**
   * If getter throws an exception, no value is added.
   */
  get(key, getter) {
    let map2 = this.map;
    let obj = map2.get(key);
    if (obj === void 0) {
      obj = getter();
      obj.registerDisposer(() => {
        map2.delete(key);
      });
      map2.set(key, obj);
    } else {
      obj.addRef();
    }
    return obj;
  }
}
class StringMemoize extends Memoize {
  get(x, getter) {
    if (typeof x !== "string") {
      x = stableStringify(x);
    }
    return super.get(x, getter);
  }
  getUncounted(x, getter) {
    return this.get(x, () => new RefCountedValue(getter())).value;
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function initializeWebGL(canvas) {
  let options = {
    "antialias": false,
    "stencil": true
  };
  let gl = canvas.getContext("webgl2", options);
  if (gl == null) {
    throw new Error("WebGL not supported.");
  }
  gl.memoize = new Memoize();
  gl.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  gl.max3dTextureSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
  gl.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  gl.tempTextureUnit = gl.maxTextureImageUnits - 1;
  for (const extension of ["EXT_color_buffer_float"]) {
    if (!gl.getExtension(extension)) {
      throw new Error(`${extension} extension not available`);
    }
  }
  for (const extension of [
    // Some versions of Firefox 67.0 seem to require this extension being added in addition
    // to EXT_color_buffer_float, despite the note here indicating it is unnecessary:
    // https://developer.mozilla.org/en-US/docs/Web/API/EXT_float_blend
    //
    // See https://github.com/google/neuroglancer/issues/140
    "EXT_float_blend"
  ]) {
    gl.getExtension(extension);
  }
  return gl;
}
class RenderViewport {
  constructor() {
    this.width = 0;
    this.height = 0;
    this.logicalWidth = 0;
    this.logicalHeight = 0;
    this.visibleLeftFraction = 0;
    this.visibleTopFraction = 0;
    this.visibleWidthFraction = 0;
    this.visibleHeightFraction = 0;
  }
}
function applyRenderViewportToProjectionMatrix(viewport, projectionMatrix) {
  const xScale = 1 / viewport.visibleWidthFraction;
  const yScale = 1 / viewport.visibleHeightFraction;
  const xOffset = -1 - (-1 + 2 * viewport.visibleLeftFraction) * xScale;
  let yOffset = -1 - (-1 + 2 * viewport.visibleTopFraction) * yScale;
  yOffset = -yOffset;
  projectionMatrix[0] = projectionMatrix[0] * xScale + projectionMatrix[3] * xOffset;
  projectionMatrix[4] = projectionMatrix[4] * xScale + projectionMatrix[7] * xOffset;
  projectionMatrix[8] = projectionMatrix[8] * xScale + projectionMatrix[11] * xOffset;
  projectionMatrix[12] = projectionMatrix[12] * xScale + projectionMatrix[15] * xOffset;
  projectionMatrix[1] = projectionMatrix[1] * yScale + projectionMatrix[3] * yOffset;
  projectionMatrix[5] = projectionMatrix[5] * yScale + projectionMatrix[7] * yOffset;
  projectionMatrix[9] = projectionMatrix[9] * yScale + projectionMatrix[11] * yOffset;
  projectionMatrix[13] = projectionMatrix[13] * yScale + projectionMatrix[15] * yOffset;
}
function renderViewportsEqual(a, b) {
  return a.width === b.width && a.height === b.height && a.logicalWidth === b.logicalWidth && a.logicalHeight === b.logicalHeight && a.visibleLeftFraction === b.visibleLeftFraction && a.visibleTopFraction === b.visibleTopFraction;
}
class RenderedPanel extends RefCounted {
  constructor(context, element, visibility) {
    super();
    this.context = context;
    this.element = element;
    this.visibility = visibility;
    this.boundsGeneration = -1;
    this.canvasRelativeClippedLeft = 0;
    this.canvasRelativeClippedTop = 0;
    this.canvasRelativeLogicalLeft = 0;
    this.canvasRelativeLogicalTop = 0;
    this.renderViewport = new RenderViewport();
    this.boundsObserversRegistered = false;
    this.gl = context.gl;
    context.addPanel(this);
  }
  scheduleRedraw() {
    if (this.visible) {
      this.context.scheduleRedraw();
    }
  }
  ensureBoundsUpdated() {
    const context = this.context;
    context.ensureBoundsUpdated();
    const boundsGeneration = context.boundsGeneration;
    if (boundsGeneration === this.boundsGeneration) return;
    this.boundsGeneration = boundsGeneration;
    const element = this.element;
    if (!this.boundsObserversRegistered && context.monitorPanel(element)) {
      this.boundsObserversRegistered = true;
    }
    const clientRect = element.getBoundingClientRect();
    const root = context.container;
    const canvasRect = context.canvasRect;
    const canvas = context.canvas;
    const canvasPixelWidth = canvas.width, canvasPixelHeight = canvas.height;
    const screenToCanvasPixelScaleX = canvasPixelWidth / canvasRect.width;
    const screenToCanvasPixelScaleY = canvasPixelHeight / canvasRect.height;
    const canvasLeft = canvasRect.left, canvasTop = canvasRect.top;
    let logicalLeft = this.canvasRelativeLogicalLeft = Math.round((clientRect.left - canvasLeft) * screenToCanvasPixelScaleX + element.clientLeft), logicalTop = this.canvasRelativeLogicalTop = Math.round((clientRect.top - canvasTop) * screenToCanvasPixelScaleY + element.clientTop), logicalWidth = element.clientWidth, logicalHeight = element.clientHeight, logicalRight = logicalLeft + logicalWidth, logicalBottom = logicalTop + logicalHeight;
    let clippedTop = logicalTop, clippedLeft = logicalLeft, clippedRight = logicalRight, clippedBottom = logicalBottom;
    for (let parent = element.parentElement; parent !== null && parent !== root; parent = parent.parentElement) {
      const rect = parent.getBoundingClientRect();
      if (rect.x === 0 && rect.y === 0 && rect.width === 0 && rect.height === 0) {
        continue;
      }
      clippedLeft = Math.max(clippedLeft, (rect.left - canvasLeft) * screenToCanvasPixelScaleX);
      clippedTop = Math.max(clippedTop, (rect.top - canvasTop) * screenToCanvasPixelScaleY);
      clippedRight = Math.min(clippedRight, (rect.right - canvasLeft) * screenToCanvasPixelScaleX);
      clippedBottom = Math.min(clippedBottom, (rect.bottom - canvasTop) * screenToCanvasPixelScaleY);
    }
    clippedTop = this.canvasRelativeClippedTop = Math.round(Math.max(clippedTop, 0));
    clippedLeft = this.canvasRelativeClippedLeft = Math.round(Math.max(clippedLeft, 0));
    clippedRight = Math.round(Math.min(clippedRight, canvasPixelWidth));
    clippedBottom = Math.round(Math.min(clippedBottom, canvasPixelHeight));
    const viewport = this.renderViewport;
    const clippedWidth = viewport.width = Math.max(0, clippedRight - clippedLeft);
    const clippedHeight = viewport.height = Math.max(0, clippedBottom - clippedTop);
    viewport.logicalWidth = logicalWidth;
    viewport.logicalHeight = logicalHeight;
    viewport.visibleLeftFraction = (clippedLeft - logicalLeft) / logicalWidth;
    viewport.visibleTopFraction = (clippedTop - logicalTop) / logicalHeight;
    viewport.visibleWidthFraction = clippedWidth / logicalWidth;
    viewport.visibleHeightFraction = clippedHeight / logicalHeight;
  }
  // Sets the viewport to the clipped viewport.  Any drawing must take
  // `visible{Left,Top,Width,Height}Fraction` into account.  setGLClippedViewport() {
  setGLClippedViewport() {
    const gl = this.gl, canvasRelativeClippedTop = this.canvasRelativeClippedTop, canvasRelativeClippedLeft = this.canvasRelativeClippedLeft;
    var _renderViewport = this.renderViewport;
    const width = _renderViewport.width, height = _renderViewport.height;
    const bottom = canvasRelativeClippedTop + height;
    gl.enable(WebGL2RenderingContext.SCISSOR_TEST);
    let glBottom = this.context.canvas.height - bottom;
    gl.viewport(canvasRelativeClippedLeft, glBottom, width, height);
    gl.scissor(canvasRelativeClippedLeft, glBottom, width, height);
  }
  // Sets the viewport to the logical viewport, using the scissor test to constrain drawing to the
  // clipped viewport.  Drawing does not need to take `visible{Left,Top,Width,Height}Fraction` into
  // account.
  setGLLogicalViewport() {
    const gl = this.gl;
    var _renderViewport2 = this.renderViewport;
    const width = _renderViewport2.width, height = _renderViewport2.height, logicalWidth = _renderViewport2.logicalWidth, logicalHeight = _renderViewport2.logicalHeight;
    const canvasHeight = this.context.canvas.height;
    gl.enable(WebGL2RenderingContext.SCISSOR_TEST);
    gl.viewport(this.canvasRelativeLogicalLeft, canvasHeight - (this.canvasRelativeLogicalTop + logicalHeight), logicalWidth, logicalHeight);
    gl.scissor(this.canvasRelativeClippedLeft, canvasHeight - (this.canvasRelativeClippedTop + height), width, height);
  }
  disposed() {
    if (this.boundsObserversRegistered) {
      this.context.unmonitorPanel(this.element);
    }
    this.context.removePanel(this);
    super.disposed();
  }
  get visible() {
    return this.visibility.visible;
  }
  getDepthArray() {
    return void 0;
  }
  get shouldDraw() {
    if (!this.visible) return false;
    const element = this.element;
    if (element.clientWidth === 0 || element.clientHeight === 0 || element.offsetWidth === 0 || element.offsetHeight === 0) {
      return false;
    }
    return true;
  }
  // Returns a number that determine the order in which panels are drawn. This is used by CdfPanel
  // to ensure it is drawn after other panels that update the histogram.
  //
  // A higher number -> later draw.
  get drawOrder() {
    return 0;
  }
}
class IndirectRenderedPanel extends RenderedPanel {
  constructor(context, element, visibility) {
    super(context, element, visibility);
    this.canvas = document.createElement("canvas");
    this.canvasRenderingContext = this.canvas.getContext("2d");
    const canvas = this.canvas;
    element.appendChild(canvas);
    element.style.position = "relative";
    canvas.style.position = "absolute";
    canvas.style.left = "0";
    canvas.style.right = "0";
    canvas.style.top = "0";
    canvas.style.bottom = "0";
  }
  draw() {
    this.drawIndirect();
    const renderViewport = this.renderViewport, canvas = this.canvas;
    const logicalWidth = renderViewport.logicalWidth, logicalHeight = renderViewport.logicalHeight;
    canvas.width = logicalWidth;
    canvas.height = logicalHeight;
    const canvasRenderingContext = this.canvasRenderingContext;
    canvasRenderingContext === null || canvasRenderingContext === void 0 ? void 0 : canvasRenderingContext.drawImage(this.context.canvas, this.canvasRelativeLogicalLeft, this.canvasRelativeLogicalTop, logicalWidth, logicalHeight, 0, 0, logicalWidth, logicalHeight);
  }
}
class TrackableWindowedViewport extends TrackableValue {
  constructor() {
    super(Float64Array.of(0, 0, 1, 1), (obj) => parseFixedLengthArray(new Float64Array(4), obj, verifyFloat01));
  }
  toJSON() {
    const value = this.value;
    var _value = _slicedToArray(value, 4);
    const left = _value[0], top = _value[1], width = _value[2], height = _value[3];
    if (left === 0 && top == 0 && width === 1 && height === 1) return void 0;
    return _Array$from(value);
  }
}
class DisplayContext extends RefCounted {
  constructor(container) {
    super();
    this.container = container;
    this.canvas = document.createElement("canvas");
    this.updateStarted = new NullarySignal();
    this.updateFinished = new NullarySignal();
    this.changed = this.updateFinished;
    this.panels = new _Set();
    this.resizeGeneration = 0;
    this.boundsGeneration = -1;
    this.orderedPanels = [];
    this.frameNumber = 0;
    this.panelAncestors = new _Map();
    this.resizeCallback = () => {
      ++this.resizeGeneration;
      this.scheduleRedraw();
    };
    this.resizeObserver = new ResizeObserver(this.resizeCallback);
    this.scheduleRedraw = this.registerCancellable(animationFrameDebounce(() => this.draw()));
    const canvas = this.canvas, resizeObserver = this.resizeObserver;
    container.style.position = "relative";
    canvas.style.position = "absolute";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.style.zIndex = "0";
    resizeObserver.observe(canvas);
    container.appendChild(canvas);
    this.registerEventListener(canvas, "webglcontextlost", (event) => {
      console.log(`Lost WebGL context: ${event.statusMessage}`);
      event.preventDefault();
    });
    this.registerEventListener(canvas, "webglcontextrestored", () => {
      console.log("WebGL context restored");
      window.location.reload();
    });
    this.gl = initializeWebGL(canvas);
  }
  monitorPanel(element) {
    const panelAncestors = this.panelAncestors, root = this.container;
    if (!root.contains(element)) return false;
    while (element !== root) {
      let entry = panelAncestors.get(element);
      if (entry !== void 0) {
        ++entry.count;
        break;
      }
      const parent = element.parentElement;
      entry = { parent, count: 1 };
      panelAncestors.set(element, entry);
      element.addEventListener("scroll", this.resizeCallback, { capture: true });
      this.resizeObserver.observe(element);
      element = parent;
    }
    return true;
  }
  unmonitorPanel(element) {
    const panelAncestors = this.panelAncestors, root = this.container;
    while (element !== root) {
      const entry = panelAncestors.get(element);
      if (entry.count !== 1) {
        --entry.count;
        break;
      }
      element.removeEventListener("scroll", this.resizeCallback, { capture: true });
      this.resizeObserver.unobserve(element);
      panelAncestors.delete(element);
      element = entry.parent;
    }
  }
  applyWindowedViewportToElement(element, value) {
    var _value2 = _slicedToArray(value, 4);
    const left = _value2[0], top = _value2[1], width = _value2[2], height = _value2[3];
    const totalWidth = 1 / width;
    const totalHeight = 1 / height;
    element.style.position = "absolute";
    element.style.top = `${-totalHeight * top * 100}%`;
    element.style.left = `${-totalWidth * left * 100}%`;
    element.style.width = `${totalWidth * 100}%`;
    element.style.height = `${totalHeight * 100}%`;
    ++this.resizeGeneration;
    this.scheduleRedraw();
  }
  isReady() {
    for (const panel of this.panels) {
      if (!panel.visible) {
        continue;
      }
      if (!panel.isReady()) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns a child element that overlays the canvas.
   */
  makeCanvasOverlayElement() {
    const element = document.createElement("div");
    element.style.position = "absolute";
    element.style.top = "0px";
    element.style.left = "0px";
    element.style.width = "100%";
    element.style.height = "100%";
    element.style.zIndex = "2";
    this.container.appendChild(element);
    return element;
  }
  disposed() {
    this.orderedPanels.length = 0;
    this.resizeObserver.disconnect();
  }
  addPanel(panel) {
    this.panels.add(panel);
    this.orderedPanels.length = 0;
    ++this.resizeGeneration;
    this.scheduleRedraw();
  }
  removePanel(panel) {
    this.panels.delete(panel);
    this.orderedPanels.length = 0;
    ++this.resizeGeneration;
    this.scheduleRedraw();
  }
  ensureBoundsUpdated() {
    const resizeGeneration = this.resizeGeneration;
    if (this.boundsGeneration === resizeGeneration) return;
    const canvas = this.canvas;
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    this.canvasRect = canvas.getBoundingClientRect();
    this.boundsGeneration = resizeGeneration;
  }
  draw() {
    ++this.frameNumber;
    this.updateStarted.dispatch();
    let gl = this.gl;
    this.ensureBoundsUpdated();
    this.gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    const orderedPanels = this.orderedPanels, panels = this.panels;
    if (orderedPanels.length !== panels.size) {
      orderedPanels.push(...panels);
      orderedPanels.sort((a, b) => a.drawOrder - b.drawOrder);
    }
    for (const panel of orderedPanels) {
      if (!panel.shouldDraw) continue;
      panel.ensureBoundsUpdated();
      const renderViewport = panel.renderViewport;
      if (renderViewport.width === 0 || renderViewport.height === 0) continue;
      panel.draw();
    }
    gl.disable(gl.SCISSOR_TEST);
    this.gl.clearColor(1, 1, 1, 1);
    this.gl.colorMask(false, false, false, true);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this.gl.colorMask(true, true, true, true);
    this.updateFinished.dispatch();
  }
  getDepthArray() {
    var _canvas = this.canvas;
    const width = _canvas.width, height = _canvas.height;
    const depthArray = new Float32Array(width * height);
    for (const panel of this.panels) {
      if (!panel.shouldDraw) continue;
      const panelDepthArray = panel.getDepthArray();
      if (panelDepthArray === void 0) continue;
      const canvasRelativeClippedTop = panel.canvasRelativeClippedTop, canvasRelativeClippedLeft = panel.canvasRelativeClippedLeft;
      var _panel$renderViewport = panel.renderViewport;
      const width2 = _panel$renderViewport.width, height2 = _panel$renderViewport.height;
      for (let y = 0; y < height2; ++y) {
        const panelDepthArrayOffset = (height2 - 1 - y) * width2;
        depthArray.set(panelDepthArray.subarray(panelDepthArrayOffset, panelDepthArrayOffset + width2), (canvasRelativeClippedTop + y) * width2 + canvasRelativeClippedLeft);
      }
    }
    return depthArray;
  }
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProjectionParameters extends RenderViewport {
  constructor() {
    super(...arguments);
    this.globalPosition = kEmptyFloat32Vec;
    this.projectionMat = create$4();
    this.viewMatrix = create$4();
    this.invViewMatrix = create$4();
    this.viewProjectionMat = create$4();
    this.invViewProjectionMat = create$4();
  }
}
function projectionParametersEqual(a, b) {
  return a.displayDimensionRenderInfo === b.displayDimensionRenderInfo && renderViewportsEqual(a, b) && arraysEqual(a.globalPosition, b.globalPosition) && arraysEqual(a.projectionMat, b.projectionMat) && arraysEqual(a.viewMatrix, b.viewMatrix);
}
function updateProjectionParametersFromInverseViewAndProjection(p) {
  const viewMatrix = p.viewMatrix, viewProjectionMat = p.viewProjectionMat;
  invert$1(viewMatrix, p.invViewMatrix);
  multiply$3(viewProjectionMat, p.projectionMat, viewMatrix);
  invert$1(p.invViewProjectionMat, viewProjectionMat);
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RENDERED_VIEW_ADD_LAYER_RPC_ID = "rendered_view.addLayer";
const RENDERED_VIEW_REMOVE_LAYER_RPC_ID = "rendered_view.removeLayer";
const PROJECTION_PARAMETERS_RPC_ID = "SharedProjectionParameters";
const PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID = "SharedProjectionParameters.changed";
var MessageSeverity;
(function(MessageSeverity2) {
  MessageSeverity2[MessageSeverity2["info"] = 0] = "info";
  MessageSeverity2[MessageSeverity2["warning"] = 1] = "warning";
  MessageSeverity2[MessageSeverity2["error"] = 2] = "error";
})(MessageSeverity || (MessageSeverity = {}));
class MessageList {
  constructor() {
    this.changed = new NullarySignal();
    this.messages = [];
    this.children = [];
  }
  addMessage(message) {
    this.messages.push(message);
    this.changed.dispatch();
  }
  clearMessages() {
    const messages = this.messages;
    if (messages.length === 0) return;
    messages.length = 0;
    this.changed.dispatch();
  }
  isEmpty() {
    return this.messages.length === 0 && !this.children.some((x) => !x.isEmpty());
  }
  addChild(list) {
    this.children.push(list);
    list.changed.add(this.changed.dispatch);
    if (!list.isEmpty()) {
      this.changed.dispatch();
    }
    return () => {
      const children = this.children;
      children.splice(children.indexOf(list), 1);
      list.changed.remove(this.changed.dispatch);
      if (!list.isEmpty()) {
        this.changed.dispatch();
      }
    };
  }
  *[_Symbol$iterator]() {
    yield* this.messages;
    for (const child of this.children) {
      yield* child;
    }
  }
}
var es6_promise = {};
var _speciesConstructor;
var hasRequired_speciesConstructor;
function require_speciesConstructor() {
  if (hasRequired_speciesConstructor) return _speciesConstructor;
  hasRequired_speciesConstructor = 1;
  var anObject = require_anObject();
  var aFunction = require_aFunction();
  var SPECIES = require_wks()("species");
  _speciesConstructor = function(O, D) {
    var C = anObject(O).constructor;
    var S;
    return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? D : aFunction(S);
  };
  return _speciesConstructor;
}
var _invoke;
var hasRequired_invoke;
function require_invoke() {
  if (hasRequired_invoke) return _invoke;
  hasRequired_invoke = 1;
  _invoke = function(fn, args, that) {
    var un = that === void 0;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  return _invoke;
}
var _task;
var hasRequired_task;
function require_task() {
  if (hasRequired_task) return _task;
  hasRequired_task = 1;
  var ctx = require_ctx();
  var invoke = require_invoke();
  var html = require_html();
  var cel = require_domCreate();
  var global = require_global();
  var process = global.process;
  var setTask = global.setImmediate;
  var clearTask = global.clearImmediate;
  var MessageChannel = global.MessageChannel;
  var Dispatch = global.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = "onreadystatechange";
  var defer, channel, port;
  var run = function() {
    var id = +this;
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };
  var listener = function(event) {
    run.call(event.data);
  };
  if (!setTask || !clearTask) {
    setTask = function setImmediate(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue[++counter] = function() {
        invoke(typeof fn == "function" ? fn : Function(fn), args);
      };
      defer(counter);
      return counter;
    };
    clearTask = function clearImmediate(id) {
      delete queue[id];
    };
    if (require_cof()(process) == "process") {
      defer = function(id) {
        process.nextTick(ctx(run, id, 1));
      };
    } else if (Dispatch && Dispatch.now) {
      defer = function(id) {
        Dispatch.now(ctx(run, id, 1));
      };
    } else if (MessageChannel) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = ctx(port.postMessage, port, 1);
    } else if (global.addEventListener && typeof postMessage == "function" && !global.importScripts) {
      defer = function(id) {
        global.postMessage(id + "", "*");
      };
      global.addEventListener("message", listener, false);
    } else if (ONREADYSTATECHANGE in cel("script")) {
      defer = function(id) {
        html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
          html.removeChild(this);
          run.call(id);
        };
      };
    } else {
      defer = function(id) {
        setTimeout(ctx(run, id, 1), 0);
      };
    }
  }
  _task = {
    set: setTask,
    clear: clearTask
  };
  return _task;
}
var _microtask;
var hasRequired_microtask;
function require_microtask() {
  if (hasRequired_microtask) return _microtask;
  hasRequired_microtask = 1;
  var global = require_global();
  var macrotask = require_task().set;
  var Observer = global.MutationObserver || global.WebKitMutationObserver;
  var process = global.process;
  var Promise2 = global.Promise;
  var isNode = require_cof()(process) == "process";
  _microtask = function() {
    var head, last, notify;
    var flush = function() {
      var parent, fn;
      if (isNode && (parent = process.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (e) {
          if (head) notify();
          else last = void 0;
          throw e;
        }
      }
      last = void 0;
      if (parent) parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer && !(global.navigator && global.navigator.standalone)) {
      var toggle = true;
      var node = document.createTextNode("");
      new Observer(flush).observe(node, { characterData: true });
      notify = function() {
        node.data = toggle = !toggle;
      };
    } else if (Promise2 && Promise2.resolve) {
      var promise2 = Promise2.resolve(void 0);
      notify = function() {
        promise2.then(flush);
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    return function(fn) {
      var task = { fn, next: void 0 };
      if (last) last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  };
  return _microtask;
}
var _newPromiseCapability = {};
var hasRequired_newPromiseCapability;
function require_newPromiseCapability() {
  if (hasRequired_newPromiseCapability) return _newPromiseCapability;
  hasRequired_newPromiseCapability = 1;
  var aFunction = require_aFunction();
  function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function($$resolve, $$reject) {
      if (resolve !== void 0 || reject !== void 0) throw TypeError("Bad Promise constructor");
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aFunction(resolve);
    this.reject = aFunction(reject);
  }
  _newPromiseCapability.f = function(C) {
    return new PromiseCapability(C);
  };
  return _newPromiseCapability;
}
var _perform;
var hasRequired_perform;
function require_perform() {
  if (hasRequired_perform) return _perform;
  hasRequired_perform = 1;
  _perform = function(exec) {
    try {
      return { e: false, v: exec() };
    } catch (e) {
      return { e: true, v: e };
    }
  };
  return _perform;
}
var _userAgent;
var hasRequired_userAgent;
function require_userAgent() {
  if (hasRequired_userAgent) return _userAgent;
  hasRequired_userAgent = 1;
  var global = require_global();
  var navigator2 = global.navigator;
  _userAgent = navigator2 && navigator2.userAgent || "";
  return _userAgent;
}
var _promiseResolve;
var hasRequired_promiseResolve;
function require_promiseResolve() {
  if (hasRequired_promiseResolve) return _promiseResolve;
  hasRequired_promiseResolve = 1;
  var anObject = require_anObject();
  var isObject = require_isObject();
  var newPromiseCapability = require_newPromiseCapability();
  _promiseResolve = function(C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };
  return _promiseResolve;
}
var hasRequiredEs6_promise;
function requireEs6_promise() {
  if (hasRequiredEs6_promise) return es6_promise;
  hasRequiredEs6_promise = 1;
  var LIBRARY = require_library();
  var global = require_global();
  var ctx = require_ctx();
  var classof = require_classof();
  var $export = require_export();
  var isObject = require_isObject();
  var aFunction = require_aFunction();
  var anInstance = require_anInstance();
  var forOf = require_forOf();
  var speciesConstructor = require_speciesConstructor();
  var task = require_task().set;
  var microtask = require_microtask()();
  var newPromiseCapabilityModule = require_newPromiseCapability();
  var perform = require_perform();
  var userAgent = require_userAgent();
  var promiseResolve = require_promiseResolve();
  var PROMISE = "Promise";
  var TypeError2 = global.TypeError;
  var process = global.process;
  var versions = process && process.versions;
  var v8 = versions && versions.v8 || "";
  var $Promise = global[PROMISE];
  var isNode = classof(process) == "process";
  var empty = function() {
  };
  var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
  var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
  var USE_NATIVE = !!function() {
    try {
      var promise2 = $Promise.resolve(1);
      var FakePromise = (promise2.constructor = {})[require_wks()("species")] = function(exec) {
        exec(empty, empty);
      };
      return (isNode || typeof PromiseRejectionEvent == "function") && promise2.then(empty) instanceof FakePromise && v8.indexOf("6.6") !== 0 && userAgent.indexOf("Chrome/66") === -1;
    } catch (e) {
    }
  }();
  var isThenable = function(it) {
    var then;
    return isObject(it) && typeof (then = it.then) == "function" ? then : false;
  };
  var notify = function(promise2, isReject) {
    if (promise2._n) return;
    promise2._n = true;
    var chain = promise2._c;
    microtask(function() {
      var value = promise2._v;
      var ok = promise2._s == 1;
      var i = 0;
      var run = function(reaction) {
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (promise2._h == 2) onHandleUnhandled(promise2);
              promise2._h = 1;
            }
            if (handler === true) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value);
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(TypeError2("Promise-chain cycle"));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (e) {
          if (domain && !exited) domain.exit();
          reject(e);
        }
      };
      while (chain.length > i) run(chain[i++]);
      promise2._c = [];
      promise2._n = false;
      if (isReject && !promise2._h) onUnhandled(promise2);
    });
  };
  var onUnhandled = function(promise2) {
    task.call(global, function() {
      var value = promise2._v;
      var unhandled = isUnhandled(promise2);
      var result, handler, console2;
      if (unhandled) {
        result = perform(function() {
          if (isNode) {
            process.emit("unhandledRejection", value, promise2);
          } else if (handler = global.onunhandledrejection) {
            handler({ promise: promise2, reason: value });
          } else if ((console2 = global.console) && console2.error) {
            console2.error("Unhandled promise rejection", value);
          }
        });
        promise2._h = isNode || isUnhandled(promise2) ? 2 : 1;
      }
      promise2._a = void 0;
      if (unhandled && result.e) throw result.v;
    });
  };
  var isUnhandled = function(promise2) {
    return promise2._h !== 1 && (promise2._a || promise2._c).length === 0;
  };
  var onHandleUnhandled = function(promise2) {
    task.call(global, function() {
      var handler;
      if (isNode) {
        process.emit("rejectionHandled", promise2);
      } else if (handler = global.onrejectionhandled) {
        handler({ promise: promise2, reason: promise2._v });
      }
    });
  };
  var $reject = function(value) {
    var promise2 = this;
    if (promise2._d) return;
    promise2._d = true;
    promise2 = promise2._w || promise2;
    promise2._v = value;
    promise2._s = 2;
    if (!promise2._a) promise2._a = promise2._c.slice();
    notify(promise2, true);
  };
  var $resolve = function(value) {
    var promise2 = this;
    var then;
    if (promise2._d) return;
    promise2._d = true;
    promise2 = promise2._w || promise2;
    try {
      if (promise2 === value) throw TypeError2("Promise can't be resolved itself");
      if (then = isThenable(value)) {
        microtask(function() {
          var wrapper = { _w: promise2, _d: false };
          try {
            then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
          } catch (e) {
            $reject.call(wrapper, e);
          }
        });
      } else {
        promise2._v = value;
        promise2._s = 1;
        notify(promise2, false);
      }
    } catch (e) {
      $reject.call({ _w: promise2, _d: false }, e);
    }
  };
  if (!USE_NATIVE) {
    $Promise = function Promise2(executor) {
      anInstance(this, $Promise, PROMISE, "_h");
      aFunction(executor);
      Internal.call(this);
      try {
        executor(ctx($resolve, this, 1), ctx($reject, this, 1));
      } catch (err) {
        $reject.call(this, err);
      }
    };
    Internal = function Promise2(executor) {
      this._c = [];
      this._a = void 0;
      this._s = 0;
      this._d = false;
      this._v = void 0;
      this._h = 0;
      this._n = false;
    };
    Internal.prototype = require_redefineAll()($Promise.prototype, {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function then(onFulfilled, onRejected) {
        var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
        reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
        reaction.fail = typeof onRejected == "function" && onRejected;
        reaction.domain = isNode ? process.domain : void 0;
        this._c.push(reaction);
        if (this._a) this._a.push(reaction);
        if (this._s) notify(this, false);
        return reaction.promise;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    OwnPromiseCapability = function() {
      var promise2 = new Internal();
      this.promise = promise2;
      this.resolve = ctx($resolve, promise2, 1);
      this.reject = ctx($reject, promise2, 1);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
      return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };
  }
  $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
  require_setToStringTag()($Promise, PROMISE);
  require_setSpecies()(PROMISE);
  Wrapper = require_core()[PROMISE];
  $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
    // 25.4.4.5 Promise.reject(r)
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      var $$reject = capability.reject;
      $$reject(r);
      return capability.promise;
    }
  });
  $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
    // 25.4.4.6 Promise.resolve(x)
    resolve: function resolve(x) {
      return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
    }
  });
  $export($export.S + $export.F * !(USE_NATIVE && require_iterDetect()(function(iter) {
    $Promise.all(iter)["catch"](empty);
  })), PROMISE, {
    // 25.4.4.1 Promise.all(iterable)
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function() {
        var values2 = [];
        var index2 = 0;
        var remaining = 1;
        forOf(iterable, false, function(promise2) {
          var $index = index2++;
          var alreadyCalled = false;
          values2.push(void 0);
          remaining++;
          C.resolve(promise2).then(function(value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values2[$index] = value;
            --remaining || resolve(values2);
          }, reject);
        });
        --remaining || resolve(values2);
      });
      if (result.e) reject(result.v);
      return capability.promise;
    },
    // 25.4.4.4 Promise.race(iterable)
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject = capability.reject;
      var result = perform(function() {
        forOf(iterable, false, function(promise2) {
          C.resolve(promise2).then(capability.resolve, reject);
        });
      });
      if (result.e) reject(result.v);
      return capability.promise;
    }
  });
  return es6_promise;
}
var es7_promise_finally = {};
var hasRequiredEs7_promise_finally;
function requireEs7_promise_finally() {
  if (hasRequiredEs7_promise_finally) return es7_promise_finally;
  hasRequiredEs7_promise_finally = 1;
  var $export = require_export();
  var core = require_core();
  var global = require_global();
  var speciesConstructor = require_speciesConstructor();
  var promiseResolve = require_promiseResolve();
  $export($export.P + $export.R, "Promise", { "finally": function(onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == "function";
    return this.then(
      isFunction ? function(x) {
        return promiseResolve(C, onFinally()).then(function() {
          return x;
        });
      } : onFinally,
      isFunction ? function(e) {
        return promiseResolve(C, onFinally()).then(function() {
          throw e;
        });
      } : onFinally
    );
  } });
  return es7_promise_finally;
}
var es7_promise_try = {};
var hasRequiredEs7_promise_try;
function requireEs7_promise_try() {
  if (hasRequiredEs7_promise_try) return es7_promise_try;
  hasRequiredEs7_promise_try = 1;
  var $export = require_export();
  var newPromiseCapability = require_newPromiseCapability();
  var perform = require_perform();
  $export($export.S, "Promise", { "try": function(callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  } });
  return es7_promise_try;
}
var promise$1;
var hasRequiredPromise$1;
function requirePromise$1() {
  if (hasRequiredPromise$1) return promise$1;
  hasRequiredPromise$1 = 1;
  requireEs6_string_iterator();
  requireWeb_dom_iterable();
  requireEs6_promise();
  requireEs7_promise_finally();
  requireEs7_promise_try();
  promise$1 = require_core().Promise;
  return promise$1;
}
var promise;
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise;
  hasRequiredPromise = 1;
  promise = { "default": requirePromise$1(), __esModule: true };
  return promise;
}
var promiseExports = requirePromise();
const _Promise = /* @__PURE__ */ getDefaultExportFromCjs(promiseExports);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CancellationError {
  constructor() {
    this.name = "CancellationError";
    this.message = "CANCELED";
  }
  toString() {
    return "CANCELED";
  }
}
const CANCELED = new CancellationError();
function throwIfCanceled(token) {
  if (token.isCanceled === true) {
    throw CANCELED;
  }
}
const noopFunction = () => {
};
const uncancelableToken = {
  isCanceled: false,
  add: () => noopFunction,
  remove: noopFunction
};
class CancellationTokenSource {
  /**
   * Trigger cancellation.
   *
   * If this.isCanceled === false, then each registered cancellation handler is invoked
   * synchronously.
   */
  cancel() {
    const handlers2 = this.handlers;
    if (handlers2 !== null) {
      this.handlers = null;
      if (handlers2 !== void 0) {
        for (let handler of handlers2) {
          handler();
        }
      }
    }
  }
  get isCanceled() {
    return this.handlers === null;
  }
  add(handler) {
    let handlers2 = this.handlers;
    if (handlers2 === null) {
      handler();
      return noopFunction;
    }
    if (handlers2 === void 0) {
      handlers2 = this.handlers = new _Set();
    }
    handlers2.add(handler);
    return () => {
      this.remove(handler);
    };
  }
  remove(handler) {
    const handlers2 = this.handlers;
    if (handlers2 != null) {
      handlers2.delete(handler);
    }
  }
}
class MultipleConsumerCancellationTokenSource extends CancellationTokenSource {
  constructor() {
    super(...arguments);
    this.consumers = new _Set();
  }
  addConsumer(cancellationToken = uncancelableToken) {
    const consumers = this.consumers;
    if (consumers.has(cancellationToken) || cancellationToken.isCanceled) {
      return;
    }
    consumers.add(cancellationToken);
    cancellationToken.add(() => {
      consumers.delete(cancellationToken);
      if (consumers.size === 0) {
        this.cancel();
      }
    });
  }
}
function makeCancelablePromise(cancellationToken, executor) {
  return new _Promise((resolve, reject) => {
    if (cancellationToken === uncancelableToken) {
      executor(resolve, reject, uncancelableToken);
      return;
    }
    const scopedToken = new CancellationTokenSource();
    const unregister = cancellationToken.add(() => {
      scopedToken.cancel();
    });
    executor((value) => {
      unregister();
      resolve(value);
    }, (error) => {
      unregister();
      reject(error);
    }, scopedToken);
  });
}
const IS_WORKER = !(typeof Window !== "undefined" && self instanceof Window);
const PROMISE_RESPONSE_ID = "rpc.promise.response";
const PROMISE_CANCEL_ID = "rpc.promise.cancel";
var handlers = new _Map();
function registerRPC(key, handler) {
  handlers.set(key, handler);
}
class RPCError extends Error {
  constructor(name2, message) {
    super(message);
    this.name = name2;
    this.message = message;
  }
}
function registerPromiseRPC(key, handler) {
  registerRPC(key, function(x) {
    let id = x["id"];
    const cancellationToken = new CancellationTokenSource();
    let promise2 = handler.call(this, x, cancellationToken);
    this.set(id, { promise: promise2, cancellationToken });
    promise2.then(({ value, transfers }) => {
      this.delete(id);
      this.invoke(PROMISE_RESPONSE_ID, { "id": id, "value": value }, transfers);
    }, (error) => {
      this.delete(id);
      this.invoke(PROMISE_RESPONSE_ID, { "id": id, "error": error.message, "errorName": error.name });
    });
  });
}
registerRPC(PROMISE_CANCEL_ID, function(x) {
  let id = x["id"];
  const request = this.get(id);
  if (request !== void 0) {
    let cancellationToken = request.cancellationToken;
    cancellationToken.cancel();
  }
});
registerRPC(PROMISE_RESPONSE_ID, function(x) {
  let id = x["id"];
  var _get = this.get(id);
  let resolve = _get.resolve, reject = _get.reject;
  this.delete(id);
  if (x.hasOwnProperty("value")) {
    resolve(x["value"]);
  } else {
    const errorName = x["errorName"];
    if (errorName === CANCELED.name) {
      reject(CANCELED);
    } else {
      reject(new RPCError(x["errorName"], x["error"]));
    }
  }
});
const INITIAL_RPC_ID = IS_WORKER ? -1 : 0;
class RPC {
  constructor(target) {
    this.target = target;
    this.objects = new _Map();
    this.nextId = INITIAL_RPC_ID;
    target.onmessage = (e) => {
      let data = e.data;
      handlers.get(data.functionName).call(this, data);
    };
  }
  get numObjects() {
    return this.objects.size;
  }
  set(id, value) {
    this.objects.set(id, value);
  }
  delete(id) {
    this.objects.delete(id);
  }
  get(id) {
    return this.objects.get(id);
  }
  getRef(x) {
    let rpcId = x["id"];
    let obj = this.get(rpcId);
    obj.referencedGeneration = x["gen"];
    obj.addRef();
    return obj;
  }
  getOptionalRef(x) {
    if (x === void 0) return void 0;
    let rpcId = x["id"];
    let obj = this.get(rpcId);
    obj.referencedGeneration = x["gen"];
    obj.addRef();
    return obj;
  }
  invoke(name2, x, transfers) {
    x.functionName = name2;
    this.target.postMessage(x, transfers);
  }
  promiseInvoke(name2, x, cancellationToken = uncancelableToken, transfers) {
    return makeCancelablePromise(cancellationToken, (resolve, reject, token) => {
      const id = x["id"] = this.newId();
      this.set(id, { resolve, reject });
      this.invoke(name2, x, transfers);
      token.add(() => {
        this.invoke(PROMISE_CANCEL_ID, { "id": id });
      });
    });
  }
  newId() {
    return IS_WORKER ? this.nextId-- : this.nextId++;
  }
}
class SharedObject extends RefCounted {
  constructor() {
    super(...arguments);
    this.rpc = null;
    this.rpcId = null;
  }
  initializeSharedObject(rpc, rpcId = rpc.newId()) {
    this.rpc = rpc;
    this.rpcId = rpcId;
    this.isOwner = false;
    rpc.set(rpcId, this);
  }
  initializeCounterpart(rpc, options = {}) {
    this.initializeSharedObject(rpc);
    this.unreferencedGeneration = 0;
    this.referencedGeneration = 0;
    this.isOwner = true;
    options["id"] = this.rpcId;
    options["type"] = this.RPC_TYPE_ID;
    rpc.invoke("SharedObject.new", options);
  }
  dispose() {
    super.dispose();
  }
  /**
   * Precondition: this.isOwner === true.
   */
  addCounterpartRef() {
    return { "id": this.rpcId, "gen": ++this.referencedGeneration };
  }
  refCountReachedZero() {
    if (this.isOwner === true) {
      if (this.referencedGeneration === this.unreferencedGeneration) {
        this.ownerDispose();
      }
    } else if (this.isOwner === false) {
      this.rpc.invoke("SharedObject.refCountReachedZero", { "id": this.rpcId, "gen": this.referencedGeneration });
    } else {
      super.refCountReachedZero();
    }
  }
  /**
   * Precondition: this.isOwner === true.
   */
  ownerDispose() {
    let rpc = this.rpc, rpcId = this.rpcId;
    super.refCountReachedZero();
    rpc.delete(rpcId);
    rpc.invoke("SharedObject.dispose", { "id": rpcId });
  }
  /**
   * Precondition: this.isOwner === true.
   *
   * This should be called when the counterpart's refCount is decremented and reaches zero.
   */
  counterpartRefCountReachedZero(generation) {
    this.unreferencedGeneration = generation;
    if (this.refCount === 0 && generation === this.referencedGeneration) {
      this.ownerDispose();
    }
  }
}
function initializeSharedObjectCounterpart(obj, rpc, options = {}) {
  if (rpc != null) {
    obj.initializeSharedObject(rpc, options["id"]);
  }
}
class SharedObjectCounterpart extends SharedObject {
  constructor(rpc, options = {}) {
    super();
    initializeSharedObjectCounterpart(this, rpc, options);
  }
}
registerRPC("SharedObject.dispose", function(x) {
  let obj = this.get(x["id"]);
  if (obj.refCount !== 0) {
    throw new Error(`Attempted to dispose object with non-zero reference count.`);
  }
  obj.disposed();
  this.delete(obj.rpcId);
  obj.rpcId = null;
  obj.rpc = null;
});
const WORKER_RPC_ID = "Worker";
registerRPC(WORKER_RPC_ID, function(x) {
  const port = x.port, path = x.path;
  const worker = new Worker(path);
  worker.postMessage({ port }, [port]);
});
registerRPC("SharedObject.refCountReachedZero", function(x) {
  let obj = this.get(x["id"]);
  let generation = x["gen"];
  obj.counterpartRefCountReachedZero(generation);
});
const sharedObjectConstructors = new _Map();
function registerSharedObjectOwner(identifier) {
  return (constructorFunction) => {
    constructorFunction.prototype.RPC_TYPE_ID = identifier;
  };
}
function registerSharedObject(identifier) {
  return (constructorFunction) => {
    if (identifier !== void 0) {
      constructorFunction.prototype.RPC_TYPE_ID = identifier;
    } else {
      identifier = constructorFunction.prototype.RPC_TYPE_ID;
      if (identifier === void 0) {
        throw new Error("RPC_TYPE_ID should have already been defined");
      }
    }
    sharedObjectConstructors.set(identifier, constructorFunction);
  };
}
registerRPC("SharedObject.new", function(x) {
  let rpc = this;
  let typeName = x["type"];
  let constructorFunction = sharedObjectConstructors.get(typeName);
  let obj = new constructorFunction(rpc, x);
  --obj.refCount;
});
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$a = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
var SharedWatchableValue_1;
const CHANGED_RPC_METHOD_ID = "SharedWatchableValue.changed";
let SharedWatchableValue = SharedWatchableValue_1 = class SharedWatchableValue2 extends SharedObjectCounterpart {
  constructor(rpc, options = {}) {
    super(rpc, options);
    this.updatingValue_ = false;
    if (rpc !== void 0) {
      this.base = new WatchableValue(options["value"]);
      this.setupChangedHandler();
    }
  }
  initializeCounterpart(rpc, options = {}) {
    options["value"] = this.value;
    super.initializeCounterpart(rpc, options);
  }
  setupChangedHandler() {
    this.registerDisposer(this.base.changed.add(() => {
      if (this.updatingValue_) {
        this.updatingValue_ = false;
      } else {
        const rpc = this.rpc;
        if (rpc !== null) {
          rpc.invoke(CHANGED_RPC_METHOD_ID, { "id": this.rpcId, "value": this.value });
        }
      }
    }));
  }
  static makeFromExisting(rpc, base) {
    let obj = new SharedWatchableValue_1();
    obj.base = base;
    obj.setupChangedHandler();
    obj.initializeCounterpart(rpc);
    return obj;
  }
  static make(rpc, value) {
    return SharedWatchableValue_1.makeFromExisting(rpc, new WatchableValue(value));
  }
  get value() {
    return this.base.value;
  }
  set value(value) {
    this.base.value = value;
  }
  get changed() {
    return this.base.changed;
  }
};
SharedWatchableValue = SharedWatchableValue_1 = __decorate$a([registerSharedObject("SharedWatchableValue")], SharedWatchableValue);
registerRPC(CHANGED_RPC_METHOD_ID, function(x) {
  const obj = this.get(x["id"]);
  obj.updatingValue_ = true;
  obj.base.value = x["value"];
  obj.updatingValue_ = false;
});
class WatchableVisibilityPriority extends WatchableValue {
  constructor(value = Number.NEGATIVE_INFINITY) {
    super(value);
  }
  get visible() {
    return this.value === Number.POSITIVE_INFINITY;
  }
  get ignored() {
    return this.value === Number.NEGATIVE_INFINITY;
  }
}
WatchableVisibilityPriority.VISIBLE = Number.POSITIVE_INFINITY;
WatchableVisibilityPriority.IGNORED = Number.NEGATIVE_INFINITY;
class VisibilityPriorityAggregator extends WatchableVisibilityPriority {
  constructor() {
    super(...arguments);
    this.contributors = new _Map();
  }
  /**
   * Registers `x` to be included in the set of values to be aggregated.
   *
   * @returns A disposer function that unregisters the specified value.
   */
  add(x) {
    const contributors = this.contributors;
    const changedDisposer = x.changed.add(() => {
      this.update();
    });
    const disposer = () => {
      contributors.delete(disposer);
      changedDisposer();
      this.update();
    };
    contributors.set(disposer, x);
    this.update();
    return disposer;
  }
  update() {
    let priority = Number.NEGATIVE_INFINITY;
    for (const x of this.contributors.values()) {
      priority = Math.max(priority, x.value);
    }
    this.value = priority;
  }
}
function withSharedVisibility(Base2) {
  return class extends Base2 {
    constructor() {
      super(...arguments);
      this.visibility = new VisibilityPriorityAggregator();
    }
    initializeCounterpart(rpc, options = {}) {
      options["visibility"] = this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.visibility)).rpcId;
      super.initializeCounterpart(rpc, options);
    }
  };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof _Object$getOwnPropertySymbols === "function") for (var i = 0, p = _Object$getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var RenderLayerRole;
(function(RenderLayerRole2) {
  RenderLayerRole2[RenderLayerRole2["DATA"] = 0] = "DATA";
  RenderLayerRole2[RenderLayerRole2["ANNOTATION"] = 1] = "ANNOTATION";
  RenderLayerRole2[RenderLayerRole2["DEFAULT_ANNOTATION"] = 2] = "DEFAULT_ANNOTATION";
})(RenderLayerRole || (RenderLayerRole = {}));
function allRenderLayerRoles() {
  return new WatchableSet([RenderLayerRole.DATA, RenderLayerRole.ANNOTATION, RenderLayerRole.DEFAULT_ANNOTATION]);
}
class RenderLayer extends RefCounted {
  constructor() {
    super(...arguments);
    this.role = RenderLayerRole.DATA;
    this.messages = new MessageList();
    this.layerChanged = new NullarySignal();
    this.redrawNeeded = new NullarySignal();
    this.layerChunkProgressInfo = new LayerChunkProgressInfo();
  }
  handleAction(_action) {
  }
  getValueAt(_x) {
    return void 0;
  }
  /**
   * Transform the stored pickedValue and offset associated with the retrieved pick ID into the
   * actual value.
   */
  transformPickedValue(pickState) {
    return pickState.pickedValue;
  }
  /**
   * Optionally updates the mouse state based on the retrived pick information.  This might snap the
   * 3-d position to the center of the picked point.
   */
  updateMouseState(_mouseState, _pickedValue, _pickedOffset, _data) {
  }
}
class VisibilityTrackedRenderLayer extends RenderLayer {
  constructor() {
    super(...arguments);
    this.visibility = new VisibilityPriorityAggregator();
  }
  attach(attachment) {
  }
}
function update3dRenderLayerAttachment(transform, displayDimensionRenderInfo, attachment) {
  let state = attachment.state;
  if (state === void 0 || state.transform !== transform || state.displayDimensionRenderInfo !== displayDimensionRenderInfo) {
    attachment.messages.clearMessages();
    state = attachment.state = { transform, displayDimensionRenderInfo, modelTransform: void 0 };
    if (transform.error !== void 0) {
      attachment.messages.addMessage({ severity: MessageSeverity.error, message: transform.error });
      return void 0;
    }
    try {
      const modelTransform = create$4();
      get3dModelToDisplaySpaceMatrix(modelTransform, displayDimensionRenderInfo, transform);
      state.modelTransform = modelTransform;
    } catch (e) {
      attachment.messages.addMessage({ severity: MessageSeverity.error, message: e.message });
    }
  }
  return state.modelTransform;
}
class DerivedProjectionParameters extends RefCounted {
  constructor(options) {
    super();
    this.renderViewport = new RenderViewport();
    this.changed = new Signal();
    var _options$parametersCo = options.parametersConstructor;
    const parametersConstructor = _options$parametersCo === void 0 ? ProjectionParameters : _options$parametersCo, navigationState = options.navigationState, update = options.update;
    var _options$isEqual = options.isEqual;
    const isEqual = _options$isEqual === void 0 ? projectionParametersEqual : _options$isEqual;
    this.oldValue_ = new parametersConstructor();
    this.value_ = new parametersConstructor();
    const performUpdate = () => {
      const oldValue_ = this.oldValue_, value_ = this.value_;
      oldValue_.displayDimensionRenderInfo = navigationState.displayDimensionRenderInfo.value;
      _Object$assign(oldValue_, this.renderViewport);
      let globalPosition = oldValue_.globalPosition;
      const newGlobalPosition = navigationState.position.value;
      const rank = newGlobalPosition.length;
      if (globalPosition.length !== rank) {
        oldValue_.globalPosition = globalPosition = new Float32Array(rank);
      }
      globalPosition.set(newGlobalPosition);
      update(oldValue_, navigationState);
      if (isEqual(oldValue_, value_)) return;
      this.value_ = oldValue_;
      this.oldValue_ = value_;
      this.changed.dispatch(value_, oldValue_);
    };
    const debouncedUpdate = this.update = this.registerCancellable(debounce(performUpdate, 0));
    this.registerDisposer(navigationState.changed.add(debouncedUpdate));
    performUpdate();
  }
  setViewport(viewport) {
    if (renderViewportsEqual(viewport, this.renderViewport)) return;
    _Object$assign(this.renderViewport, viewport);
    this.update();
  }
  get value() {
    this.update.flush();
    return this.value_;
  }
}
let SharedProjectionParameters = class SharedProjectionParameters2 extends SharedObject {
  constructor(rpc, base, updateInterval2 = 10) {
    super();
    this.base = base;
    this.updateInterval = updateInterval2;
    this.prevDisplayDimensionRenderInfo = void 0;
    this.update = this.registerCancellable(debounce((_oldValue, newValue) => {
      let valueUpdate;
      if (newValue.displayDimensionRenderInfo !== this.prevDisplayDimensionRenderInfo) {
        valueUpdate = newValue;
        this.prevDisplayDimensionRenderInfo = newValue.displayDimensionRenderInfo;
      } else {
        newValue.displayDimensionRenderInfo;
        const remainder = __rest(newValue, ["displayDimensionRenderInfo"]);
        valueUpdate = remainder;
      }
      this.rpc.invoke(PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID, { id: this.rpcId, value: valueUpdate });
    }, this.updateInterval));
    this.initializeCounterpart(rpc, { value: base.value });
    this.registerDisposer(base.changed.add(this.update));
  }
  flush() {
    this.update.flush();
  }
};
SharedProjectionParameters = __decorate$9([registerSharedObjectOwner(PROJECTION_PARAMETERS_RPC_ID)], SharedProjectionParameters);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TrackableBoolean {
  constructor(value_, defaultValue = value_) {
    this.value_ = value_;
    this.defaultValue = defaultValue;
    this.changed = new NullarySignal();
  }
  get value() {
    return this.value_;
  }
  set value(newValue) {
    if (newValue !== this.value_) {
      this.value_ = newValue;
      this.changed.dispatch();
    }
  }
  toggle() {
    this.value = !this.value;
  }
  toJSON() {
    let value_ = this.value_;
    if (value_ === this.defaultValue) {
      return void 0;
    }
    return this.value_;
  }
  restoreState(x) {
    if (x === true || x === false) {
      this.value = x;
      return;
    }
    this.value = this.defaultValue;
  }
  reset() {
    this.value = this.defaultValue;
  }
}
class TrackableBooleanCheckbox extends RefCounted {
  constructor(model, options = {}) {
    super();
    this.model = model;
    this.element = document.createElement("input");
    let element = this.element;
    element.type = "checkbox";
    const updateCheckbox = () => {
      var _a;
      const value = this.model.value;
      this.element.checked = value;
      if (options.enableTitle !== void 0 || options.disableTitle !== void 0) {
        this.element.title = (_a = value ? options.enableTitle : options.disableTitle) !== null && _a !== void 0 ? _a : "";
      }
    };
    this.registerDisposer(model.changed.add(updateCheckbox));
    updateCheckbox();
    this.registerEventListener(element, "change", function(_e) {
      model.value = this.checked;
    });
    element.addEventListener("mousedown", (event) => {
      event.preventDefault();
    });
  }
  disposed() {
    let element = this.element;
    let parentElement = element.parentElement;
    if (parentElement) {
      parentElement.removeChild(element);
    }
    super.disposed();
  }
}
class ElementVisibilityFromTrackableBoolean extends RefCounted {
  constructor(model, element) {
    super();
    this.model = model;
    this.element = element;
    this.initialDisplay = this.element.style.display;
    this.updateVisibility();
    this.registerDisposer(model.changed.add(this.registerCancellable(debounce(() => this.updateVisibility(), 0))));
  }
  updateVisibility() {
    this.element.style.display = this.model.value ? this.initialDisplay : "none";
  }
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function makeValueOrError(f) {
  try {
    return f();
  } catch (e) {
    return { error: e.message };
  }
}
function valueOrThrow(x) {
  if (x.error !== void 0) throw new Error(x.error);
  return x;
}
class WatchableMap extends RefCounted {
  constructor(register, values2) {
    super();
    this.register = register;
    this.changed = new NullarySignal();
    this.disposerMap = new _Map();
    if (values2 === void 0) {
      this.map = new _Map();
    } else {
      const map2 = this.map = new _Map(values2);
      const disposerMap = this.disposerMap;
      for (const _ref of map2) {
        var _ref2 = _slicedToArray(_ref, 2);
        const key = _ref2[0];
        const value = _ref2[1];
        const context = new RefCounted();
        disposerMap.set(key, context);
        register(context, value, key);
      }
    }
  }
  get value() {
    return this.map;
  }
  set(key, value) {
    const map2 = this.map, disposerMap = this.disposerMap;
    let context = disposerMap.get(key);
    if (context !== void 0) {
      context.dispose();
    }
    context = new RefCounted();
    disposerMap.set(key, context);
    map2.set(key, value);
    this.register(context, value, key);
    this.changed.dispatch();
    return this;
  }
  delete(key) {
    const map2 = this.map, disposerMap = this.disposerMap;
    const context = disposerMap.get(key);
    if (context !== void 0) {
      context.dispose();
      disposerMap.delete(key);
      map2.delete(key);
      this.changed.dispatch();
      return true;
    }
    return false;
  }
  get(key) {
    return this.map.get(key);
  }
  has(key) {
    return this.map.has(key);
  }
  get size() {
    return this.map.size;
  }
  [_Symbol$iterator]() {
    return _getIterator(this.map);
  }
  clear() {
    const map2 = this.map, disposerMap = this.disposerMap;
    if (map2.size > 0) {
      for (const disposer of disposerMap.values()) {
        disposer.dispose();
      }
      map2.clear();
      disposerMap.clear();
      this.changed.dispatch();
    }
  }
  values() {
    return this.map.values();
  }
  keys() {
    return this.map.keys();
  }
  disposed() {
    const map2 = this.map, disposerMap = this.disposerMap;
    for (const disposer of disposerMap.values()) {
      disposer.dispose();
    }
    map2.clear();
    disposerMap.clear();
    super.disposed();
  }
}
var symbolExports = requireSymbol();
const _Symbol = /* @__PURE__ */ getDefaultExportFromCjs(symbolExports);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const OBJECT_ID_SYMBOL = _Symbol("objectId");
let nextObjectId = 0;
function getObjectId(x) {
  if (x instanceof Object) {
    let id = x[OBJECT_ID_SYMBOL];
    if (id === void 0) {
      id = x[OBJECT_ID_SYMBOL] = nextObjectId++;
    }
    return `o${id}`;
  } else {
    return "" + _JSON$stringify(x);
  }
}
var ShaderType;
(function(ShaderType2) {
  ShaderType2[ShaderType2["VERTEX"] = WebGL2RenderingContext.VERTEX_SHADER] = "VERTEX";
  ShaderType2[ShaderType2["FRAGMENT"] = WebGL2RenderingContext.FRAGMENT_SHADER] = "FRAGMENT";
})(ShaderType || (ShaderType = {}));
function parseShaderErrors(log) {
  log = log.replace("\0", "");
  let result = [];
  for (let line of log.split("\n")) {
    let m = line.match(/^ERROR:\s*(\d+):(\d+)\s*(.+)$/);
    if (m !== null) {
      result.push({ message: m[3].trim(), file: parseInt(m[1], 10), line: parseInt(m[2], 10) });
    } else {
      m = line.match(/^ERROR:\s*(.+)$/);
      if (m !== null) {
        result.push({ message: m[1] });
      } else {
        line = line.trim();
        if (line) {
          result.push({ message: line });
        }
      }
    }
  }
  return result;
}
class ShaderCompilationError extends Error {
  constructor(shaderType, source, log, errorMessages) {
    const message = `Error compiling ${ShaderType[shaderType].toLowerCase()} shader: ${log}`;
    super(message);
    this.name = "ShaderCompilationError";
    this.log = log;
    this.message = message;
    this.shaderType = shaderType;
    this.source = source;
    this.errorMessages = errorMessages;
  }
}
class ShaderLinkError extends Error {
  constructor(vertexSource, fragmentSource, log) {
    const message = `Error linking shader: ${log}`;
    super(message);
    this.name = "ShaderLinkError";
    this.log = log;
    this.message = message;
    this.vertexSource = vertexSource;
    this.fragmentSource = fragmentSource;
  }
}
function getShader(gl, source, shaderType) {
  var shader = gl.createShader(shaderType);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    let log = gl.getShaderInfoLog(shader) || "";
    throw new ShaderCompilationError(shaderType, source, log, parseShaderErrors(log));
  }
  return shader;
}
class ShaderProgram extends RefCounted {
  constructor(gl, vertexSource, fragmentSource, uniformNames, attributeNames, vertexDebugOutputs) {
    super();
    this.gl = gl;
    this.vertexSource = vertexSource;
    this.fragmentSource = fragmentSource;
    this.attributes = new _Map();
    this.uniforms = new _Map();
    this.vertexShaderInputBinders = {};
    let vertexShader = this.vertexShader = getShader(gl, vertexSource, gl.VERTEX_SHADER);
    let fragmentShader = this.fragmentShader = getShader(gl, fragmentSource, gl.FRAGMENT_SHADER);
    let shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      let log = gl.getProgramInfoLog(shaderProgram) || "";
      throw new ShaderLinkError(vertexSource, fragmentSource, log);
    }
    this.program = shaderProgram;
    let uniforms = this.uniforms, attributes = this.attributes;
    if (uniformNames) {
      for (let name2 of uniformNames) {
        uniforms.set(name2, gl.getUniformLocation(shaderProgram, name2));
      }
    }
    if (attributeNames) {
      for (let name2 of attributeNames) {
        attributes.set(name2, gl.getAttribLocation(shaderProgram, name2));
      }
    }
  }
  uniform(name2) {
    return this.uniforms.get(name2);
  }
  attribute(name2) {
    return this.attributes.get(name2);
  }
  textureUnit(symbol) {
    return this.textureUnits.get(symbol);
  }
  bind() {
    this.gl.useProgram(this.program);
  }
  disposed() {
    let gl = this.gl;
    gl.deleteShader(this.vertexShader);
    this.vertexShader = void 0;
    gl.deleteShader(this.fragmentShader);
    this.fragmentShader = void 0;
    gl.deleteProgram(this.program);
    this.program = void 0;
    this.gl = void 0;
    this.attributes = void 0;
    this.uniforms = void 0;
  }
}
function drawArraysInstanced(gl, mode, first, count, instanceCount) {
  gl.drawArraysInstanced(mode, first, count, instanceCount);
  {
    return;
  }
}
class ShaderCode {
  constructor() {
    this.code = "";
    this.parts = new _Set();
  }
  add(x) {
    if (this.parts.has(x)) {
      return;
    }
    this.parts.add(x);
    switch (typeof x) {
      case "string":
        this.code += x;
        break;
      case "function":
        this.add(x());
        break;
      default:
        if (Array.isArray(x)) {
          for (let y of x) {
            this.add(y);
          }
        } else {
          console.log("Invalid code type", x);
          throw new Error("Invalid code type");
        }
    }
  }
  toString() {
    return this.code;
  }
}
const textureTargetForSamplerType = {
  "sampler2D": WebGL2RenderingContext.TEXTURE_2D,
  "isampler2D": WebGL2RenderingContext.TEXTURE_2D,
  "usampler2D": WebGL2RenderingContext.TEXTURE_2D,
  "sampler3D": WebGL2RenderingContext.TEXTURE_3D,
  "isampler3D": WebGL2RenderingContext.TEXTURE_3D,
  "usampler3D": WebGL2RenderingContext.TEXTURE_3D
};
class ShaderBuilder {
  constructor(gl) {
    this.gl = gl;
    this.nextSymbolID = 0;
    this.nextTextureUnit = 0;
    this.uniformsCode = "";
    this.attributesCode = "";
    this.varyingsCodeVS = "";
    this.varyingsCodeFS = "";
    this.fragmentExtensionsSet = new _Set();
    this.fragmentExtensions = "";
    this.vertexCode = new ShaderCode();
    this.vertexMain = "";
    this.fragmentCode = new ShaderCode();
    this.outputBufferCode = "";
    this.fragmentMain = "";
    this.required = new _Set();
    this.uniforms = new Array();
    this.attributes = new Array();
    this.initializers = [];
    this.textureUnits = new _Map();
    this.vertexDebugOutputs = [];
  }
  addVertexPositionDebugOutput() {
    this.vertexDebugOutputs.push({ typeName: "vec4", name: "gl_Position" });
  }
  addVertexDebugOutput(typeName, name2) {
    this.addVarying(typeName, name2);
    this.vertexDebugOutputs.push({ typeName, name: name2 });
  }
  allocateTextureUnit(symbol, count = 1) {
    if (this.textureUnits.has(symbol)) {
      throw new Error("Duplicate texture unit symbol: " + symbol.toString());
    }
    let old = this.nextTextureUnit;
    this.nextTextureUnit += count;
    this.textureUnits.set(symbol, old);
    return old;
  }
  addTextureSampler(samplerType, name2, symbol, extent) {
    let textureUnit = this.allocateTextureUnit(symbol, extent);
    this.addUniform(`highp ${samplerType}`, name2, extent);
    this.addInitializer((shader) => {
      if (extent) {
        let textureUnits = new Int32Array(extent);
        for (let i = 0; i < extent; ++i) {
          textureUnits[i] = i + textureUnit;
        }
        shader.gl.uniform1iv(shader.uniform(name2), textureUnits);
      } else {
        shader.gl.uniform1i(shader.uniform(name2), textureUnit);
      }
    });
    return textureUnit;
  }
  symbol(name2) {
    return name2 + this.nextSymbolID++;
  }
  addAttribute(typeName, name2, location2) {
    this.attributes.push(name2);
    if (location2 !== void 0) this.attributesCode += `layout(location = ${location2})`;
    this.attributesCode += `in ${typeName} ${name2};
`;
    return name2;
  }
  addVarying(typeName, name2, interpolationMode = "") {
    this.varyingsCodeVS += `${interpolationMode} out ${typeName} ${name2};
`;
    this.varyingsCodeFS += `${interpolationMode} in ${typeName} ${name2};
`;
  }
  addOutputBuffer(typeName, name2, location2) {
    if (location2 !== null) {
      this.outputBufferCode += `layout(location = ${location2}) `;
    }
    this.outputBufferCode += `out ${typeName} ${name2};
`;
  }
  addUniform(typeName, name2, extent) {
    this.uniforms.push(name2);
    if (extent != null) {
      this.uniformsCode += `uniform ${typeName} ${name2}[${extent}];
`;
    } else {
      this.uniformsCode += `uniform ${typeName} ${name2};
`;
    }
    return name2;
  }
  addFragmentExtension(name2) {
    if (this.fragmentExtensionsSet.has(name2)) {
      return;
    }
    this.fragmentExtensionsSet.add(name2);
    this.fragmentExtensions += `#extension ${name2} : require
`;
  }
  addVertexCode(code) {
    this.vertexCode.add(code);
  }
  addFragmentCode(code) {
    this.fragmentCode.add(code);
  }
  setVertexMain(code) {
    this.vertexMain = code;
  }
  addVertexMain(code) {
    this.vertexMain = (this.vertexMain || "") + code;
  }
  setFragmentMain(code) {
    this.fragmentMain = `void main() {
${code}
}
`;
  }
  setFragmentMainFunction(code) {
    this.fragmentMain = code;
  }
  addInitializer(f) {
    this.initializers.push(f);
  }
  require(f) {
    if (this.required.has(f)) {
      return;
    }
    this.required.add(f);
    f(this);
  }
  build() {
    let vertexSource = `#version 300 es
precision highp float;
precision highp int;
${this.uniformsCode}
${this.attributesCode}
${this.varyingsCodeVS}
${this.vertexCode}
void main() {
${this.vertexMain}
}
`;
    let fragmentSource = `#version 300 es
${this.fragmentExtensions}
precision highp float;
precision highp int;
${this.uniformsCode}
${this.varyingsCodeFS}
${this.outputBufferCode}
${this.fragmentCode}
${this.fragmentMain}
`;
    let shader = new ShaderProgram(this.gl, vertexSource, fragmentSource, this.uniforms, this.attributes, this.vertexDebugOutputs);
    shader.textureUnits = this.textureUnits;
    let initializers = this.initializers;
    if (initializers.length > 0) {
      shader.bind();
      for (let initializer of initializers) {
        initializer(shader);
      }
    }
    return shader;
  }
}
function makeWatchableShaderError() {
  return new WatchableValue(void 0);
}
function makeTrackableFragmentMain(value) {
  return new TrackableValue(value, verifyString);
}
function parameterizedContextDependentShaderGetter(refCounted, gl, options) {
  const shaders = new _Map();
  const parameters = options.parameters, fallbackParameters = options.fallbackParameters, shaderError = options.shaderError;
  var _options$encodeParame = options.encodeParameters;
  const encodeParameters = _options$encodeParame === void 0 ? (p) => p : _options$encodeParame;
  var _options$extraParamet = options.extraParameters;
  const extraParameters = _options$extraParamet === void 0 ? constantWatchableValue(void 0) : _options$extraParamet;
  var _options$encodeExtraP = options.encodeExtraParameters;
  const encodeExtraParameters = _options$encodeExtraP === void 0 ? (p) => p : _options$encodeExtraP, getContextKey = options.getContextKey, defineShader = options.defineShader;
  if (shaderError !== void 0) {
    shaderError.value = void 0;
  }
  var _options$encodeContex = options.encodeContext;
  const encodeContext = _options$encodeContex === void 0 ? getContextKey : _options$encodeContex;
  const stringMemoizeKey = stableStringify(options.memoizeKey);
  function getNewShader(context, parameters2, extraParameters2) {
    const key = _JSON$stringify({
      id: stringMemoizeKey,
      context: encodeContext(context),
      parameters: encodeParameters(parameters2),
      extraParameters: encodeExtraParameters(extraParameters2)
    });
    return gl.memoize.get(key, () => {
      const builder = new ShaderBuilder(gl);
      defineShader(builder, context, parameters2, extraParameters2);
      return builder.build();
    });
  }
  function getter(context) {
    const contextKey = getContextKey(context);
    let entry = shaders.get(contextKey);
    if (entry === void 0) {
      entry = {
        parametersGeneration: -1,
        extraParametersGeneration: -1,
        shader: null,
        fallback: false,
        parameters: parameters.value,
        extraParameters: extraParameters.value
      };
      shaders.set(contextKey, entry);
    }
    const parametersGeneration = parameters.changed.count;
    const extraParametersGeneration = extraParameters.changed.count;
    if (parametersGeneration === entry.parametersGeneration && extraParametersGeneration === entry.extraParametersGeneration) {
      return entry;
    }
    const parametersValue = entry.parameters = parameters.value;
    const extraParametersValue = entry.extraParameters = extraParameters.value;
    const oldShader = entry.shader;
    entry.parametersGeneration = parametersGeneration;
    entry.extraParametersGeneration = extraParametersGeneration;
    let newShader = null;
    try {
      newShader = getNewShader(context, parametersValue, extraParametersValue);
      entry.fallback = false;
      if (fallbackParameters !== void 0) {
        fallbackParameters.value = parametersValue;
      }
      if (shaderError !== void 0) {
        shaderError.value = null;
      }
    } catch (e) {
      if (shaderError !== void 0) {
        shaderError.value = e;
      }
      if (fallbackParameters !== void 0) {
        try {
          const fallbackParametersValue = fallbackParameters.value;
          newShader = getNewShader(context, fallbackParametersValue, extraParametersValue);
          entry.parameters = fallbackParametersValue;
          entry.fallback = true;
        } catch (_a) {
        }
      }
    }
    if (oldShader !== null) {
      oldShader.dispose();
    }
    entry.shader = newShader;
    return entry;
  }
  refCounted.registerDisposer(() => {
    for (const entry of shaders.values()) {
      const shader = entry.shader;
      if (shader !== null) {
        shader.dispose();
      }
    }
  });
  return getter;
}
function parameterizedEmitterDependentShaderGetter(refCounted, gl, options) {
  return parameterizedContextDependentShaderGetter(refCounted, gl, _Object$assign(_Object$assign({}, options), { getContextKey: (emitter) => emitter, encodeContext: (emitter) => getObjectId(emitter), defineShader: (builder, emitter, parameters, extraParameters) => {
    builder.require(emitter);
    return options.defineShader(builder, parameters, extraParameters);
  } }));
}
function shaderCodeWithLineDirective(code, sourceStringNumber = 1, line = 0) {
  return `
#line ${line} ${sourceStringNumber}
` + code;
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Buffer {
  constructor(gl, bufferType = WebGL2RenderingContext.ARRAY_BUFFER) {
    this.gl = gl;
    this.bufferType = bufferType;
    this.gl = gl;
    this.buffer = gl.createBuffer();
  }
  bind() {
    this.gl.bindBuffer(this.bufferType, this.buffer);
  }
  bindToVertexAttrib(location2, componentsPerVertexAttribute, attributeType = WebGL2RenderingContext.FLOAT, normalized = false, stride = 0, offset = 0) {
    this.bind();
    this.gl.enableVertexAttribArray(location2);
    this.gl.vertexAttribPointer(location2, componentsPerVertexAttribute, attributeType, normalized, stride, offset);
  }
  bindToVertexAttribI(location2, componentsPerVertexAttribute, attributeType = WebGL2RenderingContext.UNSIGNED_INT, stride = 0, offset = 0) {
    this.bind();
    this.gl.enableVertexAttribArray(location2);
    this.gl.vertexAttribIPointer(location2, componentsPerVertexAttribute, attributeType, stride, offset);
  }
  setData(data, usage = WebGL2RenderingContext.STATIC_DRAW) {
    let gl = this.gl;
    this.bind();
    gl.bufferData(this.bufferType, data, usage);
  }
  dispose() {
    this.gl.deleteBuffer(this.buffer);
    this.buffer = void 0;
    this.gl = void 0;
  }
  static fromData(gl, data, bufferType, usage) {
    let buffer = new Buffer(gl, bufferType);
    buffer.setData(data, usage);
    return buffer;
  }
}
function getMemoizedBuffer(gl, bufferType, getter, ...args) {
  return gl.memoize.get(stableStringify({ id: "getMemoizedBuffer", getter: getObjectId(getter), args }), () => {
    const result = new RefCountedValue(Buffer.fromData(gl, getter(...args), bufferType, WebGL2RenderingContext.STATIC_DRAW));
    result.registerDisposer(result.value);
    return result;
  });
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getSquareCornersArray(startX = -1, startY = -1, endX = 1, endY = 1, minorTiles = 1, majorTiles = 1) {
  return tile2dArray(
    new Float32Array([startX, startY, startX, endY, endX, endY, endX, startY]),
    /*majorDimension=*/
    2,
    minorTiles,
    majorTiles
  );
}
function getSquareCornersBuffer(gl, startX = -1, startY = -1, endX = 1, endY = 1, minorTiles = 1, majorTiles = 1) {
  return getMemoizedBuffer(gl, WebGL2RenderingContext.ARRAY_BUFFER, getSquareCornersArray, startX, startY, endX, endY, minorTiles, majorTiles).value;
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function setRawTextureParameters(gl) {
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
}
function setRawTexture3DParameters(gl) {
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_R, WebGL2RenderingContext.CLAMP_TO_EDGE);
}
function resizeTexture(gl, texture, width, height, internalFormat = WebGL2RenderingContext.RGBA8, format = WebGL2RenderingContext.RGBA, dataType = WebGL2RenderingContext.UNSIGNED_BYTE) {
  gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + gl.tempTextureUnit);
  gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
  setRawTextureParameters(gl);
  gl.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    0,
    /*internalformat=*/
    internalFormat,
    /*width=*/
    width,
    /*height=*/
    height,
    /*border=*/
    0,
    /*format=*/
    format,
    dataType,
    null
  );
  gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
}
function setTextureFromCanvas(gl, texture, canvas) {
  gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + gl.tempTextureUnit);
  gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
  gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
  gl.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, 1);
  gl.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 4);
  gl.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    /*level=*/
    0,
    /*internalformat=*/
    WebGL2RenderingContext.RGBA8,
    /*format=*/
    WebGL2RenderingContext.RGBA,
    WebGL2RenderingContext.UNSIGNED_BYTE,
    canvas
  );
  gl.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, 0);
  gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function defineCopyFragmentShader(builder) {
  builder.addOutputBuffer("vec4", "v4f_fragColor", null);
  builder.setFragmentMain("v4f_fragColor = getValue0();");
}
function elementWiseTextureShader(gl, shaderModule = defineCopyFragmentShader, numTextures = 1) {
  return gl.memoize.get(`elementWiseTextureShader:${numTextures}:${getObjectId(shaderModule)}`, () => {
    let builder = new ShaderBuilder(gl);
    builder.addVarying("vec2", "vTexCoord");
    builder.addUniform("sampler2D", "uSampler", numTextures);
    builder.addInitializer((shader) => {
      let textureIndices = [];
      for (let i = 0; i < numTextures; ++i) {
        textureIndices[i] = i;
      }
      gl.uniform1iv(shader.uniform("uSampler"), textureIndices);
    });
    for (let i = 0; i < numTextures; ++i) {
      builder.addFragmentCode(`
vec4 getValue${i}() {
  return texture(uSampler[${i}], vTexCoord);
}
`);
    }
    builder.addUniform("mat4", "uProjectionMatrix");
    builder.require(shaderModule);
    builder.addAttribute("vec4", "aVertexPosition");
    builder.addAttribute("vec2", "aTexCoord");
    builder.setVertexMain("vTexCoord = aTexCoord; gl_Position = uProjectionMatrix * aVertexPosition;");
    return builder.build();
  });
}
function trivialColorShader(gl) {
  return gl.memoize.get("trivialColorShader", () => {
    let builder = new ShaderBuilder(gl);
    builder.addVarying("vec4", "vColor");
    builder.addOutputBuffer("vec4", "v4f_fragColor", null);
    builder.setFragmentMain("v4f_fragColor = vColor;");
    builder.addAttribute("vec4", "aVertexPosition");
    builder.addAttribute("vec4", "aColor");
    builder.addUniform("mat4", "uProjectionMatrix");
    builder.setVertexMain("vColor = aColor; gl_Position = uProjectionMatrix * aVertexPosition;");
    return builder.build();
  });
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SizeManaged extends RefCounted {
  constructor() {
    super(...arguments);
    this.width = Number.NaN;
    this.height = Number.NaN;
  }
  hasSize(width, height) {
    return this.width === width && this.height === height;
  }
  resize(width, height) {
    if (this.hasSize(width, height)) {
      return;
    }
    this.width = width;
    this.height = height;
    this.performResize();
  }
}
class Renderbuffer extends SizeManaged {
  constructor(gl, internalformat) {
    super();
    this.gl = gl;
    this.internalformat = internalformat;
    this.renderbuffer = null;
    this.renderbuffer = gl.createRenderbuffer();
  }
  performResize() {
    let gl = this.gl;
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, this.internalformat, this.width, this.height);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  }
  disposed() {
    this.gl.deleteRenderbuffer(this.renderbuffer);
  }
  attachToFramebuffer(attachment) {
    let gl = this.gl;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, this.renderbuffer);
  }
}
class DepthRenderbuffer extends Renderbuffer {
  constructor(gl, includeStencilBuffer = false) {
    super(gl, includeStencilBuffer ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT16);
    this.gl = gl;
    this.includeStencilBuffer = includeStencilBuffer;
  }
  attachToFramebuffer() {
    let gl = this.gl;
    super.attachToFramebuffer(this.includeStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
  }
}
class DepthStencilRenderbuffer extends DepthRenderbuffer {
  constructor(gl) {
    super(
      gl,
      /*includeStencilBuffer=*/
      true
    );
  }
}
class Framebuffer extends RefCounted {
  constructor(gl) {
    super();
    this.gl = gl;
    this.framebuffer = this.gl.createFramebuffer();
  }
  disposed() {
    let gl = this.gl;
    gl.deleteFramebuffer(this.framebuffer);
  }
  bind() {
    let gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
  }
  unbind() {
    let gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
}
class TextureBuffer extends SizeManaged {
  constructor(gl, internalFormat, format, dataType) {
    super();
    this.gl = gl;
    this.internalFormat = internalFormat;
    this.format = format;
    this.dataType = dataType;
    this.texture = gl.createTexture();
  }
  performResize() {
    resizeTexture(this.gl, this.texture, this.width, this.height, this.internalFormat, this.format, this.dataType);
  }
  disposed() {
    this.gl.deleteTexture(this.texture);
  }
  attachToFramebuffer(attachment) {
    let gl = this.gl;
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      attachment,
      gl.TEXTURE_2D,
      this.texture,
      /*level=*/
      0
    );
  }
}
class DepthTextureBuffer extends TextureBuffer {
  constructor(gl, internalFormat = WebGL2RenderingContext.DEPTH_COMPONENT16, format = WebGL2RenderingContext.DEPTH_COMPONENT, dataType = WebGL2RenderingContext.UNSIGNED_SHORT) {
    super(gl, internalFormat, format, dataType);
  }
  attachToFramebuffer() {
    super.attachToFramebuffer(this.format === WebGL2RenderingContext.DEPTH_COMPONENT ? WebGL2RenderingContext.DEPTH_ATTACHMENT : WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT);
  }
}
function makeTextureBuffers(gl, count, internalFormat = WebGL2RenderingContext.RGBA8, format = WebGL2RenderingContext.RGBA, dataType = WebGL2RenderingContext.UNSIGNED_BYTE) {
  let result = new Array();
  for (let i = 0; i < count; ++i) {
    result[i] = new TextureBuffer(gl, internalFormat, format, dataType);
  }
  return result;
}
class FramebufferConfiguration extends RefCounted {
  constructor(gl, configuration) {
    super();
    this.gl = gl;
    this.width = Number.NaN;
    this.height = Number.NaN;
    this.fullAttachmentList = new Array();
    this.attachmentVerified = false;
    this.singleAttachmentList = [this.gl.COLOR_ATTACHMENT0];
    var _configuration$frameb = configuration.framebuffer;
    let framebuffer = _configuration$frameb === void 0 ? new Framebuffer(gl) : _configuration$frameb, colorBuffers = configuration.colorBuffers, depthBuffer = configuration.depthBuffer;
    this.framebuffer = this.registerDisposer(framebuffer);
    this.colorBuffers = colorBuffers;
    this.depthBuffer = depthBuffer;
    if (depthBuffer !== void 0) {
      this.registerDisposer(depthBuffer);
    }
    let fullAttachmentList = this.fullAttachmentList;
    colorBuffers.forEach((buffer, i) => {
      this.registerDisposer(buffer);
      fullAttachmentList[i] = gl.COLOR_ATTACHMENT0 + i;
    });
  }
  hasSize(width, height) {
    return this.width === width && this.height === height;
  }
  bind(width, height) {
    this.width = width;
    this.height = height;
    this.framebuffer.bind();
    let gl = this.gl, depthBuffer = this.depthBuffer;
    if (depthBuffer !== void 0) {
      depthBuffer.resize(width, height);
      depthBuffer.attachToFramebuffer();
    } else {
      gl.framebufferRenderbuffer(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT, WebGL2RenderingContext.RENDERBUFFER, null);
    }
    this.colorBuffers.forEach((buffer, i) => {
      buffer.resize(width, height);
      buffer.attachToFramebuffer(gl.COLOR_ATTACHMENT0 + i);
    });
    gl.drawBuffers(this.fullAttachmentList);
    this.verifyAttachment();
    gl.viewport(0, 0, width, height);
  }
  bindSingle(textureIndex) {
    let gl = this.gl;
    this.framebuffer.bind();
    if (textureIndex !== 0) {
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0 + textureIndex,
        gl.TEXTURE_2D,
        null,
        /*level=*/
        0
      );
    }
    gl.bindTexture(gl.TEXTURE_2D, null);
    this.colorBuffers[textureIndex].attachToFramebuffer(gl.COLOR_ATTACHMENT0);
    gl.drawBuffers(this.singleAttachmentList);
  }
  unbind() {
    this.framebuffer.unbind();
  }
  readPixelFloat32IntoBuffer(textureIndex, glWindowX, glWindowY, offset, width = 1, height = 1) {
    let gl = this.gl;
    try {
      this.bindSingle(textureIndex);
      gl.readPixels(glWindowX, glWindowY, width, height, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, offset);
    } finally {
      this.framebuffer.unbind();
    }
  }
  verifyAttachment() {
    if (this.attachmentVerified) {
      return;
    }
    let gl = this.gl;
    let framebufferStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (framebufferStatus !== gl.FRAMEBUFFER_COMPLETE) {
      throw new Error(`Framebuffer configuration not supported: ${framebufferStatus}`);
    }
    this.attachmentVerified = true;
  }
}
class OffscreenCopyHelper extends RefCounted {
  constructor(gl, shader) {
    super();
    this.gl = gl;
    this.shader = shader;
    this.copyVertexPositionsBuffer = getSquareCornersBuffer(this.gl);
    this.copyTexCoordsBuffer = getSquareCornersBuffer(this.gl, 0, 0, 1, 1);
    this.registerDisposer(shader);
  }
  draw(...textures) {
    let gl = this.gl, shader = this.shader;
    shader.bind();
    let numTextures = textures.length;
    for (let i = 0; i < numTextures; ++i) {
      gl.activeTexture(gl.TEXTURE0 + i);
      gl.bindTexture(gl.TEXTURE_2D, textures[i]);
    }
    gl.uniformMatrix4fv(shader.uniform("uProjectionMatrix"), false, identityMat4);
    let aVertexPosition = shader.attribute("aVertexPosition");
    this.copyVertexPositionsBuffer.bindToVertexAttrib(
      aVertexPosition,
      /*components=*/
      2
    );
    let aTexCoord = shader.attribute("aTexCoord");
    this.copyTexCoordsBuffer.bindToVertexAttrib(
      aTexCoord,
      /*components=*/
      2
    );
    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
    gl.disableVertexAttribArray(aVertexPosition);
    gl.disableVertexAttribArray(aTexCoord);
    for (let i = 0; i < numTextures; ++i) {
      gl.activeTexture(gl.TEXTURE0 + i);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
  }
  static get(gl, shaderModule = defineCopyFragmentShader, numTextures = 1) {
    return gl.memoize.get(`OffscreenCopyHelper:${numTextures}:${getObjectId(shaderModule)}`, () => new OffscreenCopyHelper(gl, elementWiseTextureShader(gl, shaderModule, numTextures)));
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const glsl_mixLinear = `
float mixLinear(float x, float y, float a) { return mix(x, y, a); }
`;
var glsl_hsvToRgb = `
vec3 hueToRgb(float hue) {
  float hue6 = hue * 6.0;
  float r = abs(hue6 - 3.0) - 1.0;
  float g = 2.0 - abs(hue6 - 2.0);
  float b = 2.0 - abs(hue6 - 4.0);
  return clamp(vec3(r, g, b), 0.0, 1.0);
}
vec3 hsvToRgb(vec3 c) {
  vec3 hueRgb = hueToRgb(c.x);
  return c.z * ((hueRgb - 1.0) * c.y + 1.0);
}
`;
const glsl_uint64 = `
struct uint64_t {
  highp uvec2 value;
};
struct uint64x2_t {
  highp uvec4 value;
};
uint64_t mixLinear(uint64_t x, uint64_t y, float a) {
  return x;
}
uint64_t toUint64(uint64_t x) { return x; }
`;
const glsl_unpackUint64leFromUint32 = [glsl_uint64, `
uint64_t unpackUint64leFromUint32(highp uvec2 x) {
  uint64_t result;
  result.value = x;
  return result;
}
uint64x2_t unpackUint64leFromUint32(highp uvec4 x) {
  uint64x2_t result;
  result.value = x;
  return result;
}
`];
const glsl_equalUint64 = [glsl_uint64, `
bool equals(uint64_t a, uint64_t b) {
  return a.value == b.value;
}
`];
const glsl_compareLessThanUint64 = [glsl_uint64, `
bool compareLessThan(uint64_t a, uint64_t b) {
  return (a.value[1] < b.value[1])||
         (a.value[1] == b.value[1] && a.value[0] < b.value[0]);
}
`];
const glsl_subtractUint64 = [glsl_uint64, `
uint64_t subtract(uint64_t a, uint64_t b) {
  if (a.value[0] < b.value[0]) {
    --a.value[1];
  }
  a.value -= b.value;
  return a;
}
`];
const glsl_addUint64 = [glsl_uint64, `
uint64_t add(uint64_t a, uint64_t b) {
  a.value[0] += b.value[0];
  if (a.value[0] < b.value[0]) {
    ++a.value[1];
  }
  a.value[1] += b.value[1];
  return a;
}
`];
const glsl_addSaturateUint64 = [glsl_addUint64, glsl_compareLessThanUint64, `
uint64_t addSaturate(uint64_t a, uint64_t b) {
  a = add(a, b);
  if (compareLessThan(a, b)) {
    a.value = uvec2(0xffffffffu, 0xffffffffu);
  }
  return a;
}
`];
const glsl_subtractSaturateUint64 = [glsl_subtractUint64, glsl_compareLessThanUint64, `
uint64_t subtractSaturate(uint64_t a, uint64_t b) {
  b = subtract(a, b);
  if (compareLessThan(a, b)) {
    b.value = uvec2(0u, 0u);
  }
  return b;
}
`];
const glsl_shiftRightUint64 = [glsl_uint64, `
uint64_t shiftRight(uint64_t a, int shift) {
  if (shift >= 32) {
    return uint64_t(uvec2(a.value[1] >> (shift - 32), 0u));
  } else if (shift == 0) {
    return a;
  } else {
    return uint64_t(uvec2((a.value[0] >> shift) | (a.value[1] << (32 - shift)), a.value[1] >> shift));
  }
}
`];
const glsl_shiftLeftUint64 = [glsl_uint64, `
uint64_t shiftLeft(uint64_t a, int shift) {
  if (shift >= 32) {
    return uint64_t(uvec2(0u, a.value[0] << (shift - 32)));
  } else if (shift == 0) {
    return a;
  } else {
    return uint64_t(uvec2(a.value[0] << shift, (a.value[1] << shift) | (a.value[0] >> (32 - shift))));
  }
}
`];
const glsl_uint8 = [glsl_uint64, `
struct uint8_t {
  highp uint value;
};
struct uint8x2_t {
  highp uvec2 value;
};
struct uint8x3_t {
  highp uvec3 value;
};
struct uint8x4_t {
  highp uvec4 value;
};
uint8_t mixLinear(uint8_t x, uint8_t y, highp float a) {
  return uint8_t(uint(round(mix(float(x.value), float(y.value), a))));
}
highp uint toRaw(uint8_t x) { return x.value; }
highp float toNormalized(uint8_t x) { return float(x.value) / 255.0; }
highp uvec2 toRaw(uint8x2_t x) { return x.value; }
highp vec2 toNormalized(uint8x2_t x) { return vec2(x.value) / 255.0; }
highp uvec3 toRaw(uint8x3_t x) { return x.value; }
vec3 toNormalized(uint8x3_t x) { return vec3(x.value) / 255.0; }
highp uvec4 toRaw(uint8x4_t x) { return x.value; }
vec4 toNormalized(uint8x4_t x) { return vec4(x.value) / 255.0; }
uint64_t toUint64(uint8_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
uint8_t uint8FromFloat(highp float x) {
  return uint8_t(uint(clamp(x, 0.0, 255.0)));
}
`];
const glsl_int8 = [glsl_uint64, `
struct int8_t {
  highp int value;
};
struct int8x2_t {
  highp ivec2 value;
};
struct int8x3_t {
  highp ivec3 value;
};
struct int8x4_t {
  highp ivec4 value;
};
int8_t mixLinear(int8_t x, int8_t y, highp float a) {
  return int8_t(int(round(mix(float(x.value), float(y.value), a))));
}
highp int toRaw(int8_t x) { return x.value; }
highp ivec2 toRaw(int8x2_t x) { return x.value; }
highp ivec3 toRaw(int8x3_t x) { return x.value; }
highp ivec4 toRaw(int8x4_t x) { return x.value; }
uint64_t toUint64(int8_t x) {
  uint64_t result;
  result.value[0] = uint(x.value);
  result.value[1] = uint(x.value >> 31);
  return result;
}
int8_t int8FromFloat(highp float x) {
  return int8_t(int(clamp(x, -128.0, 127.0)));
}
`];
const glsl_float = `
highp float toRaw(highp float x) { return x; }
highp float toNormalized(highp float x) { return x; }
vec2 toRaw(vec2 x) { return x; }
vec2 toNormalized(vec2 x) { return x; }
vec3 toRaw(vec3 x) { return x; }
vec3 toNormalized(vec3 x) { return x; }
vec4 toRaw(vec4 x) { return x; }
vec4 toNormalized(vec4 x) { return x; }
`;
const glsl_uint16 = [glsl_uint64, `
struct uint16_t {
  highp uint value;
};
struct uint16x2_t {
  highp uvec2 value;
};
uint16_t mixLinear(uint16_t x, uint16_t y, highp float a) {
  return uint16_t(uint(round(mix(float(x.value), float(y.value), a))));
}
highp uint toRaw(uint16_t x) { return x.value; }
highp float toNormalized(uint16_t x) { return float(toRaw(x)) / 65535.0; }
highp uvec2 toRaw(uint16x2_t x) { return x.value; }
highp vec2 toNormalized(uint16x2_t x) { return vec2(toRaw(x)) / 65535.0; }
uint64_t toUint64(uint16_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
uint16_t uint16FromFloat(highp float x) {
  return uint16_t(uint(clamp(x, 0.0, 65535.0)));
}
`];
const glsl_int16 = [glsl_uint64, `
struct int16_t {
  highp int value;
};
struct int16x2_t {
  highp ivec2 value;
};
int16_t mixLinear(int16_t x, int16_t y, highp float a) {
  return int16_t(int(round(mix(float(x.value), float(y.value), a))));
}
highp int toRaw(int16_t x) { return x.value; }
highp ivec2 toRaw(int16x2_t x) { return x.value; }
uint64_t toUint64(int16_t x) {
  uint64_t result;
  result.value[0] = uint(x.value);
  result.value[1] = uint(x.value >> 31);
  return result;
}
int16_t int16FromFloat(highp float x) {
  return int16_t(int(clamp(x, -32768.0, 32767.0)));
}
`];
const glsl_uint32 = [glsl_uint64, `
struct uint32_t {
  highp uint value;
};
uint32_t mixLinear(uint32_t x, uint32_t y, highp float a) {
  return uint32_t(uint(round(mix(float(x.value), float(y.value), a))));
}
highp float toNormalized(uint32_t x) { return float(x.value) / 4294967295.0; }
highp uint toRaw(uint32_t x) { return x.value; }
uint64_t toUint64(uint32_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
uint32_t uint32FromFloat(highp float x) {
  return uint32_t(uint(clamp(x, 0.0, 4294967295.0)));
}
`];
const glsl_int32 = [glsl_uint64, `
struct int32_t {
  highp int value;
};
int32_t mixLinear(int32_t x, int32_t y, highp float a) {
  return int32_t(int(round(mix(float(x.value), float(y.value), a))));
}
highp int toRaw(int32_t x) { return x.value; }
uint64_t toUint64(int32_t x) {
  uint64_t result;
  result.value[0] = uint(x.value);
  result.value[1] = uint(x.value >> 31);
  return result;
}
int32_t int32FromFloat(highp float x) {
  return int32_t(int(clamp(x, 2147483648.0, 2147483647.0)));
}
`];
var glsl_getFortranOrderIndex = `
highp int getFortranOrderIndex(ivec3 subscripts, ivec3 size) {
  return subscripts.x + size.x * (subscripts.y + size.y * subscripts.z);
}
`;
const glsl_log2Exact = `
highp uint log2Exact(highp uint i) {
  highp uint r;
  r = uint((i & 0xAAAAAAAAu) != 0u);
  r |= uint((i & 0xFFFF0000u) != 0u) << 4;
  r |= uint((i & 0xFF00FF00u) != 0u) << 3;
  r |= uint((i & 0xF0F0F0F0u) != 0u) << 2;
  r |= uint((i & 0xCCCCCCCCu) != 0u) << 1;
  return r;
}
`;
const glsl_clipLineToDepthRange = `
bool clipLineToDepthRange(inout highp vec4 a, inout highp vec4 b) {
  highp float tmin = 0.0, tmax = 1.0;
  highp float k1 = b.w - a.w + a.z - b.z;
  highp float k2 = a.w - b.w + a.z - b.z;
  highp float q1 = (a.z - a.w) / k1;
  highp float q2 = (a.z + a.w) / k2;
  if (k1 > 0.0) tmin = max(tmin, q1);
  else if (k1 < 0.0) tmax = min(tmax, q1);
  if (k2 > 0.0) tmax = min(tmax, q2);
  else if (k2 < 0.0) tmin = max(tmin, q2);
  if (tmin <= tmax) {
    highp vec4 tempA = a;
    highp vec4 tempB = b;
    a = mix(tempA, tempB, tmin);
    b = mix(tempA, tempB, tmax);
    return true;
  }
  return false;
}
`;
const glsl_simpleFloatHash = `
highp float simpleFloatHash(highp vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
`;
const glsl_shiftLeftSaturateUint32 = `
highp uint shiftLeftSaturate(highp uint x, int shiftAmount) {
  highp uint result = x << shiftAmount;
  if ((result >> shiftAmount) != x) return 0xffffffffu;
  return result;
}
`;
const glsl_addSaturateUint32 = `
highp uint addSaturate(highp uint x, highp uint y) {
  highp uint result = x + y;
  if (result < x) return 0xffffffffu;
  return result;
}
`;
const glsl_subtractSaturateUint32 = `
highp uint subtractSaturate(highp uint x, highp uint y) {
  highp uint result = x - y;
  if (result > x) return 0u;
  return result;
}
`;
const glsl_addSaturateInt32 = [glsl_addSaturateUint32, `
highp int addSaturate(highp int x, highp uint y) {
  if (x >= 0) {
    return int(min(addSaturate(y, uint(x)), 0x7fffffffu));
  } else if (y >= uint(-x)) {
    return int(min(y - uint(-x), 0x7fffffffu));
  } else {
    return -int(min(uint(-x) - y, 0x80000000u));
  }
}
`];
const glsl_subtractSaturateInt32 = [glsl_addSaturateUint32, `
highp int subtractSaturate(highp int x, highp uint y) {
  if (x < 0) {
    return -int(min(addSaturate(uint(-x), uint(y)), 0x80000000u));
  } else if (uint(x) >= y) {
    return x - int(y);
  } else {
    return -int(min(y - uint(x), 0x80000000u));
  }
}
`];
function getShaderType(dataType, numComponents = 1) {
  switch (dataType) {
    case DataType.FLOAT32:
      if (numComponents === 1) {
        return "float";
      }
      if (numComponents > 1 && numComponents <= 4) {
        return `vec${numComponents}`;
      }
      break;
    case DataType.UINT8:
    case DataType.INT8:
    case DataType.UINT16:
    case DataType.INT16:
    case DataType.UINT32:
    case DataType.INT32:
    case DataType.UINT64: {
      const prefix = DATA_TYPE_SIGNED[dataType] ? "" : "u";
      const bits = DATA_TYPE_BYTES[dataType] * 8;
      if (numComponents === 1) {
        return `${prefix}int${bits}_t`;
      }
      if (numComponents > 1 && numComponents * bits <= 32) {
        return `${prefix}int${bits}x${numComponents}_t`;
      }
      break;
    }
  }
  throw new Error(`No shader type for ${DataType[dataType]}[${numComponents}].`);
}
const dataTypeShaderDefinition = {
  [DataType.UINT8]: glsl_uint8,
  [DataType.INT8]: glsl_int8,
  [DataType.UINT16]: glsl_uint16,
  [DataType.INT16]: glsl_int16,
  [DataType.UINT32]: glsl_uint32,
  [DataType.INT32]: glsl_int32,
  [DataType.UINT64]: glsl_uint64,
  [DataType.FLOAT32]: glsl_float
};
function getShaderVectorType(typeName, n) {
  if (n === 1) return typeName;
  return `vec${n}`;
}
const webglTypeSizeInBytes = {
  [WebGL2RenderingContext.UNSIGNED_BYTE]: 1,
  [WebGL2RenderingContext.BYTE]: 1,
  [WebGL2RenderingContext.UNSIGNED_SHORT]: 2,
  [WebGL2RenderingContext.SHORT]: 2,
  [WebGL2RenderingContext.FLOAT]: 4,
  [WebGL2RenderingContext.INT]: 4,
  [WebGL2RenderingContext.UNSIGNED_INT]: 4
};
function defineVectorArrayVertexShaderInput(builder, typeName, attributeType, normalized, name2, vectorRank, arraySize = 1) {
  let numAttributes = 0;
  let n = vectorRank * arraySize;
  while (n > 0) {
    const components = Math.min(4, n);
    const t = getShaderVectorType(typeName, components);
    n -= components;
    builder.addAttribute("highp " + t, `a${name2}${numAttributes}`);
    ++numAttributes;
  }
  n = vectorRank * arraySize;
  let code = "";
  for (let arrayIndex = 0; arrayIndex < arraySize; ++arrayIndex) {
    code += `highp ${typeName}[${vectorRank}] get${name2}${arrayIndex}() {
  highp ${typeName}[${vectorRank}] result;
`;
    for (let vectorIndex = 0; vectorIndex < vectorRank; ++vectorIndex) {
      const i = arrayIndex * vectorRank + vectorIndex;
      const attributeIndex = Math.floor(i / 4);
      const componentIndex = i % 4;
      code += `  result[${vectorIndex}] = a${name2}${attributeIndex}`;
      if (componentIndex !== 0 || i !== n - 1) {
        code += `[${componentIndex}]`;
      }
      code += `;
`;
    }
    code += `  return result;
`;
    code += `}
`;
  }
  builder.addVertexCode(code);
  const elementSize = webglTypeSizeInBytes[attributeType];
  builder.addInitializer((shader) => {
    const locations = [];
    for (let attributeIndex = 0; attributeIndex < numAttributes; ++attributeIndex) {
      locations[attributeIndex] = shader.attribute(`a${name2}${attributeIndex}`);
    }
    shader.vertexShaderInputBinders[name2] = {
      enable(divisor) {
        const gl = shader.gl;
        for (let attributeIndex = 0; attributeIndex < numAttributes; ++attributeIndex) {
          const location2 = locations[attributeIndex];
          gl.enableVertexAttribArray(location2);
          gl.vertexAttribDivisor(location2, divisor);
        }
      },
      disable() {
        const gl = shader.gl;
        for (let attributeIndex = 0; attributeIndex < numAttributes; ++attributeIndex) {
          const location2 = locations[attributeIndex];
          gl.vertexAttribDivisor(location2, 0);
          gl.disableVertexAttribArray(location2);
        }
      },
      bind(stride, offset) {
        const gl = shader.gl;
        for (let attributeIndex = 0; attributeIndex < numAttributes; ++attributeIndex) {
          const location2 = locations[attributeIndex];
          const numComponents = Math.min(4, n - 4 * attributeIndex);
          {
            gl.vertexAttribPointer(
              location2,
              /*size=*/
              numComponents,
              attributeType,
              normalized,
              stride,
              offset
            );
          }
          offset += elementSize * numComponents;
        }
      }
    };
  });
}
class HistogramSpecifications extends RefCounted {
  constructor(channels, bounds, visibility = new VisibilityPriorityAggregator()) {
    super();
    this.channels = channels;
    this.bounds = bounds;
    this.visibility = visibility;
    this.framebuffers = [];
    this.producerVisibility = new VisibilityPriorityAggregator();
    this.frameNumber = -1;
  }
  getFramebuffers(gl) {
    const framebuffers = this.framebuffers;
    while (framebuffers.length < this.channels.value.length) {
      const framebuffer = new FramebufferConfiguration(gl, {
        colorBuffers: makeTextureBuffers(gl, 1, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT)
      });
      framebuffers.push(framebuffer);
    }
    return framebuffers;
  }
  disposed() {
    for (const framebuffer of this.framebuffers) {
      framebuffer.dispose();
    }
    this.framebuffers.length = 0;
  }
}
const histogramDataSamplerTextureUnit = _Symbol("histogramDataSamplerTextureUnit");
const histogramDepthTextureUnit = _Symbol("histogramDepthTextureUnit");
const histogramSamplesPerInstance = 4096;
const histogramSamples = 2 ** 14;
class TextureHistogramGenerator extends RefCounted {
  constructor(gl) {
    super();
    this.gl = gl;
    this.shader = this.registerDisposer((() => {
      const builder = new ShaderBuilder(this.gl);
      builder.addOutputBuffer("vec4", "outputValue", 0);
      builder.addAttribute("float", "aInput1");
      builder.addTextureSampler("sampler2D", "uDataSampler", histogramDataSamplerTextureUnit);
      builder.addTextureSampler("sampler2D", "uDepthSampler", histogramDepthTextureUnit);
      builder.addVertexCode(glsl_simpleFloatHash);
      builder.setVertexMain(`
float uRandomSeed = 0.0;
vec2 p = vec2(simpleFloatHash(vec2(aInput1 + float(gl_VertexID), uRandomSeed + float(gl_InstanceID))),
              simpleFloatHash(vec2(aInput1 + float(gl_VertexID) + 10.0, 5.0 + uRandomSeed + float(gl_InstanceID))));
float dataValue = texture(uDataSampler, p).x;
float stencilValue = texture(uDepthSampler, p).x;
if (stencilValue == 1.0) {
  gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
} else {
  gl_Position = vec4(2.0 * (dataValue * 255.0 + 0.5) / 256.0 - 1.0, 0.0, 0.0, 1.0);
}
gl_PointSize = 1.0;
`);
      builder.setFragmentMain(`
outputValue = vec4(1.0, 1.0, 1.0, 1.0);
`);
      return builder.build();
    })());
    this.inputIndexBuffer = this.registerDisposer(getMemoizedBuffer(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, () => new Uint8Array(histogramSamplesPerInstance)));
  }
  static get(gl) {
    return gl.memoize.get("textureHistogramGeneration", () => new TextureHistogramGenerator(gl));
  }
  compute(count, depthTexture, inputTextures, histogramSpecifications, frameNumber) {
    const gl = this.gl;
    const shader = this.shader;
    const outputFramebuffers = histogramSpecifications.getFramebuffers(gl);
    shader.bind();
    gl.enable(WebGL2RenderingContext.BLEND);
    gl.disable(WebGL2RenderingContext.SCISSOR_TEST);
    gl.disable(WebGL2RenderingContext.DEPTH_TEST);
    gl.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE);
    this.inputIndexBuffer.value.bindToVertexAttrib(
      shader.attribute("aInput1"),
      1,
      WebGL2RenderingContext.UNSIGNED_BYTE,
      /*normalized=*/
      true
    );
    const dataUnit = shader.textureUnit(histogramDataSamplerTextureUnit);
    const depthUnit = shader.textureUnit(histogramDepthTextureUnit);
    gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + depthUnit);
    gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, depthTexture);
    setRawTextureParameters(gl);
    gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + dataUnit);
    const oldFrameNumber = histogramSpecifications.frameNumber;
    histogramSpecifications.frameNumber = frameNumber;
    for (let i = 0; i < count; ++i) {
      gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, inputTextures[i].texture);
      setRawTextureParameters(gl);
      outputFramebuffers[i].bind(256, 1);
      if (frameNumber !== oldFrameNumber) {
        gl.clearColor(0, 0, 0, 0);
        gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
      }
      gl.drawArraysInstanced(WebGL2RenderingContext.POINTS, 0, histogramSamplesPerInstance, histogramSamples / histogramSamplesPerInstance);
    }
    gl.disable(WebGL2RenderingContext.BLEND);
  }
}
const dataTypeShaderLerpParametersType = {
  [DataType.UINT8]: "vec2",
  [DataType.INT8]: "vec2",
  [DataType.UINT16]: "vec2",
  [DataType.INT16]: "vec2",
  [DataType.FLOAT32]: "vec2",
  [DataType.UINT32]: "Uint32LerpParameters",
  [DataType.INT32]: "Int32LerpParameters",
  [DataType.UINT64]: "Uint64LerpParameters"
};
const glsl_dataTypeLerpParameters = {
  [DataType.UINT8]: "",
  [DataType.INT8]: "",
  [DataType.UINT16]: "",
  [DataType.INT16]: "",
  [DataType.FLOAT32]: "",
  [DataType.UINT32]: `
struct Uint32LerpParameters {
  uint offset;
  int shift;
  float multiplier;
};
`,
  [DataType.INT32]: `
struct Int32LerpParameters {
  int offset;
  int shift;
  float multiplier;
};
`,
  [DataType.UINT64]: [glsl_uint64, `
struct Uint64LerpParameters {
  uint64_t offset;
  int shift;
  float multiplier;
};
`]
};
function getFloatInvlerpImpl(dataType) {
  const shaderDataType = getShaderType(dataType);
  let code = `
float computeInvlerp(${shaderDataType} inputValue, vec2 p) {
  float outputValue = float(toRaw(inputValue));
  outputValue = (outputValue - p[0]) * p[1];
  return outputValue;
}
`;
  return [dataTypeShaderDefinition[dataType], code];
}
function getInt32InvlerpImpl(dataType) {
  const shaderDataType = getShaderType(dataType);
  let scalarType = dataType === DataType.INT32 ? "int" : "uint";
  let pType = dataTypeShaderLerpParametersType[dataType];
  return [dataTypeShaderDefinition[dataType], glsl_dataTypeLerpParameters[dataType], `
float computeInvlerp(${shaderDataType} inputValue, ${pType} p) {
  ${scalarType} v = toRaw(inputValue);
  uint x;
  if (v >= p.offset) {
    x = uint(v - p.offset);
  } else {
    x = uint(p.offset - v);
    p.multiplier = -p.multiplier;
  }
  x >>= p.shift;
  return float(x) * p.multiplier;
}
`];
}
const glsl_dataTypeComputeInvlerp = {
  [DataType.UINT8]: getFloatInvlerpImpl(DataType.UINT8),
  [DataType.INT8]: getFloatInvlerpImpl(DataType.INT8),
  [DataType.UINT16]: getFloatInvlerpImpl(DataType.UINT16),
  [DataType.INT16]: getFloatInvlerpImpl(DataType.INT16),
  [DataType.FLOAT32]: getFloatInvlerpImpl(DataType.FLOAT32),
  [DataType.UINT32]: getInt32InvlerpImpl(DataType.UINT32),
  [DataType.INT32]: getInt32InvlerpImpl(DataType.INT32),
  [DataType.UINT64]: [glsl_uint64, glsl_compareLessThanUint64, glsl_subtractUint64, glsl_shiftRightUint64, glsl_dataTypeLerpParameters[DataType.UINT64], `
float computeInvlerp(uint64_t inputValue, Uint64LerpParameters p) {
  if (compareLessThan(inputValue, p.offset)) {
    inputValue = subtract(p.offset, inputValue);
    p.multiplier = -p.multiplier;
  } else {
    inputValue = subtract(inputValue, p.offset);
  }
  uint shifted = shiftRight(inputValue, p.shift).value[0];
  return float(shifted) * p.multiplier;
}
`]
};
function getFloatLerpImpl(dataType) {
  const shaderDataType = getShaderType(dataType);
  let code = `
${shaderDataType} computeLerp(float inputValue, vec2 p) {
  inputValue = inputValue / p[1] + p[0];
`;
  if (dataType === DataType.FLOAT32) {
    code += `return inputValue;
`;
  } else {
    code += `return ${DataType[dataType].toLowerCase()}FromFloat(round(inputValue));
`;
  }
  code += `
}
`;
  return [dataTypeShaderDefinition[dataType], code];
}
function getInt32LerpImpl(dataType) {
  const shaderDataType = getShaderType(dataType);
  let pType = dataTypeShaderLerpParametersType[dataType];
  return [dataTypeShaderDefinition[dataType], glsl_dataTypeLerpParameters[dataType], glsl_shiftLeftSaturateUint32, dataType === DataType.UINT32 ? glsl_addSaturateUint32 : glsl_addSaturateInt32, dataType === DataType.UINT32 ? glsl_subtractSaturateUint32 : glsl_subtractSaturateInt32, `
${shaderDataType} computeLerp(float inputValue, ${pType} p) {
  inputValue = inputValue / p.multiplier;
  uint x = uint(clamp(round(abs(inputValue)), 0.0, 4294967295.0));
  uint xShifted = shiftLeftSaturate(x, p.shift);
  if (inputValue >= 0.0) {
    return ${shaderDataType}(addSaturate(p.offset, xShifted));
  } else {
    return ${shaderDataType}(subtractSaturate(p.offset, xShifted));
  }
}
`];
}
const glsl_dataTypeComputeLerp = {
  [DataType.UINT8]: getFloatLerpImpl(DataType.UINT8),
  [DataType.INT8]: getFloatLerpImpl(DataType.INT8),
  [DataType.UINT16]: getFloatLerpImpl(DataType.UINT16),
  [DataType.INT16]: getFloatLerpImpl(DataType.INT16),
  [DataType.FLOAT32]: getFloatLerpImpl(DataType.FLOAT32),
  [DataType.UINT32]: getInt32LerpImpl(DataType.UINT32),
  [DataType.INT32]: getInt32LerpImpl(DataType.INT32),
  [DataType.UINT64]: [glsl_uint64, glsl_compareLessThanUint64, glsl_equalUint64, glsl_addSaturateUint64, glsl_subtractSaturateUint64, glsl_shiftRightUint64, glsl_shiftLeftUint64, glsl_dataTypeLerpParameters[DataType.UINT64], `
uint64_t computeLerp(float inputValue, Uint64LerpParameters p) {
  inputValue = inputValue / p.multiplier;
  uint64_t x = uint64_t(uvec2(uint(clamp(round(abs(inputValue)), 0.0, 4294967295.0)), 0u));
  uint64_t shifted = shiftLeft(x, p.shift);
  if (!equals(shiftRight(shifted, p.shift), x)) {
    return uint64_t(uvec2(0xffffffffu, 0xffffffffu));
  }
  if (inputValue >= 0.0) {
    return addSaturate(p.offset, shifted);
  } else {
    return subtractSaturate(p.offset, shifted);
  }
}
`]
};
function defineLerpUniforms(builder, name2, dataType) {
  const pName = `uLerpParams_${name2}`;
  const bName = `uLerpBounds_${name2}`;
  const sName = `uLerpScalar_${name2}`;
  let code = ``;
  switch (dataType) {
    case DataType.INT8:
    case DataType.UINT8:
    case DataType.INT16:
    case DataType.UINT16:
    // {uint,int}{8,16} can be converted with float32 without any loss of precision
    case DataType.FLOAT32:
      builder.addUniform("vec2", pName);
      break;
    case DataType.INT32:
    case DataType.UINT32: {
      const pType = dataTypeShaderLerpParametersType[dataType];
      builder.addUniform(`${dataType === DataType.INT32 ? "i" : "u"}vec2`, bName);
      builder.addUniform(`float`, sName);
      code += `
#define ${pName} ${pType}(${bName}[0], int(${bName}[1]), ${sName})
`;
      break;
    }
    case DataType.UINT64: {
      builder.addUniform(`uvec3`, bName);
      builder.addUniform(`float`, sName);
      code += `
#define ${pName} Uint64LerpParameters(uint64_t(${bName}.xy), int(${bName}[2]), ${sName})
`;
      break;
    }
  }
  return [glsl_dataTypeLerpParameters[dataType], code];
}
function defineInvlerpShaderFunction(builder, name2, dataType, clamp = false) {
  return [dataTypeShaderDefinition[dataType], defineLerpUniforms(builder, name2, dataType), glsl_dataTypeComputeInvlerp[dataType], `
float ${name2}(${getShaderType(dataType)} inputValue) {
  float v = computeInvlerp(inputValue, uLerpParams_${name2});
  ${!clamp ? "" : "v = clamp(v, 0.0, 1.0);"}
  return v;
}
`];
}
function defineLerpShaderFunction(builder, name2, dataType) {
  return [dataTypeShaderDefinition[dataType], defineLerpUniforms(builder, name2, dataType), glsl_dataTypeComputeLerp[dataType], `
${getShaderType(dataType)} ${name2}(float inputValue) {
  return computeLerp(inputValue, uLerpParams_${name2});
}
`];
}
const tempUint64$2 = new Uint64();
function enableLerpShaderFunction(shader, name2, dataType, interval) {
  const gl = shader.gl;
  switch (dataType) {
    case DataType.INT8:
    case DataType.UINT8:
    case DataType.INT16:
    case DataType.UINT16:
    case DataType.FLOAT32:
      gl.uniform2f(shader.uniform(`uLerpParams_${name2}`), interval[0], 1 / (interval[1] - interval[0]));
      break;
    case DataType.INT32:
    case DataType.UINT32: {
      const lower = interval[0];
      const diff = interval[1] - lower;
      const shift = Math.max(0, Math.ceil(_Math$log$1(Math.abs(diff))) - 24);
      const scalar = Math.pow(2, shift) / diff;
      const bLocation = shader.uniform(`uLerpBounds_${name2}`);
      if (dataType === DataType.UINT32) {
        gl.uniform2ui(bLocation, lower, shift);
      } else {
        gl.uniform2i(bLocation, lower, shift);
      }
      gl.uniform1f(shader.uniform(`uLerpScalar_${name2}`), scalar);
      break;
    }
    case DataType.UINT64: {
      const lower = interval[0];
      const upper = interval[1];
      Uint64.absDifference(tempUint64$2, upper, lower);
      const numBits = tempUint64$2.high > 0 ? 32 + Math.ceil(_Math$log$1(tempUint64$2.high)) : Math.ceil(_Math$log$1(tempUint64$2.low));
      const shift = Math.max(0, numBits - 24);
      Uint64.rshift(tempUint64$2, tempUint64$2, shift);
      let scalar = 1 / tempUint64$2.low;
      if (Uint64.compare(lower, upper) > 0) {
        scalar *= -1;
      }
      const bLocation = shader.uniform(`uLerpBounds_${name2}`);
      gl.uniform3ui(bLocation, lower.low, lower.high, shift);
      gl.uniform1f(shader.uniform(`uLerpScalar_${name2}`), scalar);
    }
  }
}
function stripComments(code) {
  const commentPattern = /\/\/.*?$|\/\*(?:.|\n)*?\*\/|'(?:\\.|[^\\'])*'|"(?:\\.|[^\\"])*"/mg;
  return code.replace(commentPattern, (m) => {
    if (m.startsWith("/")) {
      return m.replace(/[^\s]/g, " ");
    }
    return m;
  });
}
function matchDirectiveParameterValue(input) {
  const valueTokenPattern = /^(?:-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?|"(?:\\.|[^\\"])*"|true|false|:|\s+|,|\[|\]|\{|\})/;
  let depth = 0;
  let initialInput = input;
  outerLoop: while (input.length) {
    const m = input.match(valueTokenPattern);
    if (m === null) break;
    const token = m[0];
    switch (token.charAt(0)) {
      case "[":
      case "{":
        ++depth;
        break;
      case "]":
      case "}":
        if (--depth < 0) return -1;
        break;
      case ",":
        if (depth === 0) break outerLoop;
        break;
      default:
        if (depth === 0) {
          input = input.substring(token.length);
          break outerLoop;
        }
        break;
    }
    input = input.substring(token.length);
  }
  if (depth !== 0) return -1;
  return initialInput.length - input.length;
}
function parseDirectiveParameters(input) {
  let errors = [];
  let parameters = new _Map();
  if (input === void 0) {
    return { errors, parameters };
  }
  const startPattern = /^([_a-z][_a-zA-Z0-9]*)[ \t]*=/;
  while (true) {
    input = input.trim();
    if (input.length == 0) break;
    const m = input.match(startPattern);
    if (m === null) {
      errors.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...");
      break;
    }
    const name2 = m[1];
    input = input.substring(m[0].length);
    let valueLength = matchDirectiveParameterValue(input);
    if (valueLength <= 0) {
      errors.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...");
      break;
    }
    let value;
    try {
      value = JSON.parse(input.substring(0, valueLength));
    } catch (_a) {
      errors.push(`Invalid #uicontrol parameter value for ${name2}: ${value}`);
      break;
    }
    if (parameters.has(name2)) {
      errors.push(`Duplicate #uicontrol parameter: ${name2}`);
    } else {
      parameters.set(name2, value);
    }
    input = input.substring(valueLength);
    input = input.trim();
    if (input.length > 0 && !input.startsWith(",")) {
      errors.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...");
    }
    input = input.substring(1);
  }
  return { parameters, errors };
}
function parseSliderDirective(valueType, parameters) {
  let min2;
  let max;
  let step;
  let defaultValue;
  let errors = [];
  if (valueType !== "float" && valueType !== "uint" && valueType !== "int") {
    errors.push("type must be float, int, or uint");
  }
  for (const _ref of parameters) {
    var _ref2 = _slicedToArray(_ref, 2);
    const key = _ref2[0];
    const value = _ref2[1];
    const getValue = () => {
      if (typeof value !== "number") {
        errors.push(`Expected ${key} argument to be a number`);
        return void 0;
      }
      if (valueType === "int" || valueType === "uint") {
        if (!_Number$isInteger(value)) {
          errors.push(`Expected ${key} argument to be an integer`);
        }
        if (valueType === "uint" && value < 0) {
          errors.push(`Expected ${key} argument to be an unsigned integer`);
        }
      }
      return value;
    };
    if (key === "min") {
      min2 = getValue();
    } else if (key === "max") {
      max = getValue();
    } else if (key === "default") {
      defaultValue = getValue();
    } else if (key === "step") {
      step = getValue();
    } else {
      errors.push(`Invalid parameter: ${key}`);
    }
  }
  if (min2 === void 0) {
    errors.push("min must be specified");
  }
  if (max === void 0) {
    errors.push("max must be specified");
  }
  if (min2 !== void 0 && max !== void 0) {
    if (min2 > max) {
      errors.push("min must be less than max");
    }
    if (step === void 0) {
      if (valueType === "float") {
        step = (max - min2) / 100;
      } else {
        step = 1;
      }
    }
    if (defaultValue !== void 0) {
      if (defaultValue < min2 || defaultValue > max) {
        errors.push("default must be within valid range");
      }
    } else {
      if (valueType === "float") {
        defaultValue = (min2 + max) / 2;
      } else {
        defaultValue = min2;
      }
    }
  }
  if (errors.length > 0) {
    return { errors };
  } else {
    return {
      control: { type: "slider", valueType, min: min2, max, step, default: defaultValue },
      errors: void 0
    };
  }
}
function parseCheckboxDirective(valueType, parameters) {
  let defaultValue = false;
  let errors = [];
  if (valueType !== "bool") {
    errors.push("type must be bool");
  }
  for (const _ref3 of parameters) {
    var _ref4 = _slicedToArray(_ref3, 2);
    const key = _ref4[0];
    const value = _ref4[1];
    if (key === "default") {
      if (typeof value !== "boolean") {
        errors.push(`Expected ${key} argument to be a boolean`);
        continue;
      }
      defaultValue = value;
    } else {
      errors.push(`Invalid parameter: ${key}`);
    }
  }
  if (errors.length > 0) {
    return { errors };
  } else {
    return {
      control: { type: "checkbox", valueType, default: defaultValue },
      errors: void 0
    };
  }
}
function parseColorDirective(valueType, parameters) {
  let defaultColor = "white";
  let errors = [];
  if (valueType !== "vec3") {
    errors.push("type must be vec3");
  }
  for (const _ref5 of parameters) {
    var _ref6 = _slicedToArray(_ref5, 2);
    const key = _ref6[0];
    const value = _ref6[1];
    if (key === "default") {
      if (typeof value !== "string") {
        errors.push(`Expected default argument to be a string`);
      } else {
        defaultColor = value;
      }
    } else {
      errors.push(`Invalid parameter: ${key}`);
    }
  }
  if (errors.length > 0) {
    return { errors };
  }
  return {
    control: {
      type: "color",
      valueType,
      defaultString: defaultColor,
      default: parseRGBColorSpecification(defaultColor)
    },
    errors: void 0
  };
}
function parseInvlerpChannel(value, rank) {
  if (typeof value === "number") {
    value = [value];
  }
  const channel = new Array(rank);
  parseFixedLengthArray(channel, value, (x) => {
    if (!_Number$isInteger(x) || x < 0) {
      throw new Error(`Expected non-negative integer, but received: ${_JSON$stringify(x)}`);
    }
    return x;
  });
  return channel;
}
function parseInvlerpDirective(valueType, parameters, dataContext) {
  let errors = [];
  const imageData = dataContext.imageData;
  if (imageData === void 0) {
    errors.push("invlerp control not supported");
    return { errors };
  }
  if (valueType !== "invlerp") {
    errors.push("type must be invlerp");
  }
  let channel = new Array(imageData.channelRank).fill(0);
  const dataType = imageData.dataType;
  let clamp = true;
  let range = defaultDataTypeRange[dataType];
  let window2;
  for (let _ref7 of parameters) {
    var _ref8 = _slicedToArray(_ref7, 2);
    let key = _ref8[0];
    let value = _ref8[1];
    try {
      switch (key) {
        case "range": {
          range = parseDataTypeInterval(value, dataType);
          break;
        }
        case "window": {
          window2 = validateDataTypeInterval(parseDataTypeInterval(value, dataType));
          break;
        }
        case "clamp": {
          if (typeof value !== "boolean") {
            errors.push(`Invalid clamp value: ${_JSON$stringify(value)}`);
          } else {
            clamp = value;
          }
          break;
        }
        case "channel": {
          channel = parseInvlerpChannel(value, channel.length);
          break;
        }
        default:
          errors.push(`Invalid parameter: ${key}`);
          break;
      }
    } catch (e) {
      errors.push(`Invalid ${key} value: ${e.message}`);
    }
  }
  if (errors.length > 0) {
    return { errors };
  }
  return {
    control: {
      type: "invlerp",
      dataType,
      clamp,
      default: { range, window: window2 !== null && window2 !== void 0 ? window2 : normalizeDataTypeInterval(range), channel }
    },
    errors: void 0
  };
}
const controlParsers = new _Map([["slider", parseSliderDirective], ["color", parseColorDirective], ["invlerp", parseInvlerpDirective], ["checkbox", parseCheckboxDirective]]);
function parseShaderUiControls(code, dataContext = {}) {
  code = stripComments(code);
  const directivePattern = /^[ \t]*#[ \t]*uicontrol[ \t]+(.*)$/mg;
  const innerPattern = /^([_a-zA-Z][_a-zA-Z0-9]*)[ \t]+([a-z][a-zA-Z0-9_]*)(?:[ \t]+([a-z]+))?[ \t]*(?:\([ \t]*(.*)\)[ \t]*)?/;
  let errors = [];
  const controls = new _Map();
  const newCode = code.replace(directivePattern, (_match, innerPart, offset) => {
    var _a;
    const m = innerPart.match(innerPattern);
    const getLineNumber = () => {
      return Math.max(0, code.substring(0, offset).split("\n").length - 1);
    };
    if (m === null) {
      errors.push({
        line: getLineNumber(),
        message: "Invalid #uicontrol syntax, expected: #uicontrol <type> <name> <control>(<param>=<value>, ...)"
      });
      return "";
    }
    const typeName = m[1];
    const variableName = m[2];
    const controlName = (_a = m[3]) !== null && _a !== void 0 ? _a : typeName;
    const parameterText = m[4];
    var _parseDirectiveParame = parseDirectiveParameters(parameterText);
    const parameters = _parseDirectiveParame.parameters, innerErrors = _parseDirectiveParame.errors;
    for (const error of innerErrors) {
      errors.push({ line: getLineNumber(), message: error });
    }
    if (controls.has(variableName)) {
      errors.push({ line: getLineNumber(), message: `Duplicate definition for control ${variableName}` });
    }
    if (innerErrors.length > 0) {
      return "";
    }
    const parser = controlParsers.get(controlName);
    if (parser === void 0) {
      errors.push({ line: getLineNumber(), message: `Invalid control type ${controlName}` });
      return "";
    }
    const result = parser(typeName, parameters, dataContext);
    if (result.errors !== void 0) {
      for (const error of result.errors) {
        errors.push({ line: getLineNumber(), message: error });
      }
      return "";
    }
    controls.set(variableName, result.control);
    return "";
  });
  return { source: code, code: newCode, errors, controls };
}
function uniformName(controlName) {
  return `u_shaderControl_${controlName}`;
}
function addControlsToBuilder(builderState, builder) {
  const builderValues = builderState.builderValues;
  for (const _ref9 of builderState.parseResult.controls) {
    var _ref10 = _slicedToArray(_ref9, 2);
    const name2 = _ref10[0];
    const control = _ref10[1];
    const uName = uniformName(name2);
    const builderValue = builderValues[name2];
    switch (control.type) {
      case "invlerp": {
        const code = [defineInvlerpShaderFunction(builder, uName, control.dataType, control.clamp), `
float ${uName}() {
  return ${uName}(getDataValue(${builderValue.channel.join(",")}));
}
`];
        builder.addFragmentCode(code);
        builder.addFragmentCode(`#define ${name2} ${uName}
`);
        break;
      }
      case "checkbox": {
        const code = `#define ${name2} ${builderValue.value}
`;
        builder.addFragmentCode(code);
        builder.addVertexCode(code);
        break;
      }
      default: {
        builder.addUniform(`highp ${control.valueType}`, uName);
        builder.addVertexCode(`#define ${name2} ${uName}
`);
        builder.addFragmentCode(`#define ${name2} ${uName}
`);
        break;
      }
    }
  }
}
function objectFromEntries(entries2) {
  const obj = {};
  for (const _ref11 of entries2) {
    var _ref12 = _slicedToArray(_ref11, 2);
    const key = _ref12[0];
    const value = _ref12[1];
    obj[key] = value;
  }
  return obj;
}
function encodeControls(controls) {
  if (controls === void 0) return void 0;
  return _JSON$stringify(objectFromEntries(controls));
}
class WatchableShaderUiControls {
  constructor() {
    this.changed = new NullarySignal();
    this.controls = void 0;
  }
  get value() {
    return this.controls;
  }
  set value(newControls) {
    if (encodeControls(newControls) === encodeControls(this.controls)) {
      return;
    }
    this.controls = newControls;
    this.changed.dispatch();
  }
}
function parseInvlerpParameters(obj, dataType, defaultValue) {
  if (obj === void 0) return defaultValue;
  verifyObject(obj);
  return {
    range: verifyOptionalObjectProperty(obj, "range", (x) => parseDataTypeInterval(x, dataType), defaultValue.range),
    window: verifyOptionalObjectProperty(obj, "window", (x) => validateDataTypeInterval(parseDataTypeInterval(x, dataType)), defaultValue.window),
    channel: verifyOptionalObjectProperty(obj, "channel", (x) => parseInvlerpChannel(x, defaultValue.channel.length), defaultValue.channel)
  };
}
class TrackableInvlerpParameters extends TrackableValue {
  constructor(dataType, defaultValue) {
    super(defaultValue, (obj) => parseInvlerpParameters(obj, dataType, defaultValue));
    this.dataType = dataType;
    this.defaultValue = defaultValue;
  }
  toJSON() {
    var _value = this.value;
    const range = _value.range, window2 = _value.window, channel = _value.channel, dataType = this.dataType, defaultValue = this.defaultValue;
    const rangeJson = dataTypeIntervalToJson(range, dataType, defaultValue.range);
    const windowJson = dataTypeIntervalToJson(window2, dataType, defaultValue.window);
    const channelJson = arraysEqual(defaultValue.channel, channel) ? void 0 : channel;
    if (rangeJson === void 0 && windowJson === void 0 && channelJson === void 0) {
      return void 0;
    }
    return { range: rangeJson, window: windowJson, channel: channelJson };
  }
}
function getControlTrackable(control) {
  switch (control.type) {
    case "slider":
      return {
        trackable: new TrackableValue(control.default, (x) => {
          let v;
          if (control.valueType === "float") {
            v = verifyFiniteFloat(x);
          } else {
            v = verifyInt(x);
          }
          if (v < control.min || v > control.max) {
            throw new Error(`${_JSON$stringify(x)} is outside valid range [${control.min}, ${control.max}]`);
          }
          return v;
        }),
        getBuilderValue: () => null
      };
    case "color":
      return { trackable: new TrackableRGB(control.default), getBuilderValue: () => null };
    case "invlerp":
      return {
        trackable: new TrackableInvlerpParameters(control.dataType, control.default),
        getBuilderValue: (value) => ({ channel: value.channel, dataType: control.dataType })
      };
    case "checkbox":
      return {
        trackable: new TrackableBoolean(control.default),
        getBuilderValue: (value) => ({ value })
      };
  }
}
function encodeBuilderStateKey(builderValues, parseResult) {
  return _JSON$stringify(builderValues) + "\0" + parseResult.source;
}
function getFallbackBuilderState(parseResult) {
  const builderValues = {};
  for (const _ref13 of parseResult.controls) {
    var _ref14 = _slicedToArray(_ref13, 2);
    const key = _ref14[0];
    const control = _ref14[1];
    var _getControlTrackable = getControlTrackable(control);
    const trackable = _getControlTrackable.trackable, getBuilderValue = _getControlTrackable.getBuilderValue;
    builderValues[key] = getBuilderValue(trackable.value);
  }
  return { builderValues, parseResult, key: encodeBuilderStateKey(builderValues, parseResult) };
}
class ShaderControlState extends RefCounted {
  constructor(fragmentMain, dataContext = constantWatchableValue({}), channelCoordinateSpaceCombiner) {
    super();
    this.fragmentMain = fragmentMain;
    this.dataContext = dataContext;
    this.channelCoordinateSpaceCombiner = channelCoordinateSpaceCombiner;
    this.changed = new NullarySignal();
    this.controls = new WatchableShaderUiControls();
    this.fragmentMainGeneration = -1;
    this.dataContextGeneration = -1;
    this.parseErrors_ = [];
    this.processedFragmentMain_ = "";
    this.controlsGeneration = -1;
    this.parseResultChanged = new NullarySignal();
    this.state_ = new _Map();
    this.unparsedJson = void 0;
    this.registerDisposer(fragmentMain.changed.add(() => this.handleFragmentMainChanged()));
    this.registerDisposer(this.controls.changed.add(() => this.handleControlsChanged()));
    this.registerDisposer(this.dataContext.changed.add(() => this.handleFragmentMainChanged()));
    this.handleFragmentMainChanged();
    const self2 = this;
    this.parseErrors = {
      changed: this.parseResultChanged,
      get value() {
        self2.handleFragmentMainChanged();
        return self2.parseErrors_;
      }
    };
    this.processedFragmentMain = {
      changed: this.parseResultChanged,
      get value() {
        self2.handleFragmentMainChanged();
        return self2.processedFragmentMain_;
      }
    };
    this.parseResult = {
      changed: this.parseResultChanged,
      get value() {
        return self2.parseResult_;
      }
    };
    this.builderState = makeCachedDerivedWatchableValue((parseResult, state) => {
      const builderValues = {};
      for (const _ref15 of state) {
        var _ref16 = _slicedToArray(_ref15, 2);
        const key = _ref16[0];
        var _ref16$ = _ref16[1];
        const trackable = _ref16$.trackable;
        const getBuilderValue = _ref16$.getBuilderValue;
        const builderValue = getBuilderValue(trackable.value);
        builderValues[key] = builderValue;
      }
      return {
        key: encodeBuilderStateKey(builderValues, parseResult),
        parseResult,
        builderValues
      };
    }, [this.parseResult, this], (a, b) => a.key === b.key);
    const histogramChannels = makeCachedDerivedWatchableValue((state) => {
      const channels = [];
      for (const _ref17 of state.values()) {
        const control = _ref17.control;
        const trackable = _ref17.trackable;
        if (control.type !== "invlerp") continue;
        channels.push({ channel: trackable.value.channel });
      }
      return channels;
    }, [this], (a, b) => arraysEqualWithPredicate(a, b, (ca, cb) => arraysEqual(ca.channel, cb.channel)));
    const histogramBounds = makeCachedLazyDerivedWatchableValue((state) => {
      const bounds = [];
      for (const _ref18 of state.values()) {
        const control = _ref18.control;
        const trackable = _ref18.trackable;
        if (control.type !== "invlerp") continue;
        bounds.push(trackable.value.window);
      }
      return bounds;
    }, this);
    this.histogramSpecifications = this.registerDisposer(new HistogramSpecifications(histogramChannels, histogramBounds));
  }
  handleFragmentMainChanged() {
    const generation = this.fragmentMain.changed.count;
    const dataContextGeneration = this.dataContext.changed.count;
    if (generation === this.fragmentMainGeneration && dataContextGeneration === this.dataContextGeneration) {
      return;
    }
    this.fragmentMainGeneration = generation;
    this.dataContextGeneration = dataContextGeneration;
    const dataContext = this.dataContext.value;
    if (dataContext === null) {
      this.parseResult_ = {
        source: "",
        code: "",
        controls: new _Map(),
        errors: [{ line: 0, message: "Loading" }]
      };
      this.parseErrors_ = [];
      this.processedFragmentMain_ = "";
      this.controls.value = void 0;
    } else {
      const result = this.parseResult_ = parseShaderUiControls(this.fragmentMain.value, dataContext);
      this.parseErrors_ = result.errors;
      this.processedFragmentMain_ = result.code;
      if (result.errors.length === 0) {
        this.controls.value = result.controls;
      }
    }
    this.parseResultChanged.dispatch();
  }
  handleControlsChanged() {
    const generation = this.controls.changed.count;
    if (generation === this.controlsGeneration) {
      return;
    }
    this.controlsGeneration = generation;
    const controls = this.controls.value;
    if (controls === void 0) {
      return;
    }
    let changed = false;
    const state_ = this.state_, unparsedJson = this.unparsedJson;
    for (const _ref19 of state_) {
      var _ref20 = _slicedToArray(_ref19, 2);
      const name2 = _ref20[0];
      const controlState = _ref20[1];
      const control = controls.get(name2);
      if (control === void 0) {
        controlState.trackable.changed.remove(this.changed.dispatch);
        state_.delete(name2);
        changed = true;
        continue;
      }
    }
    for (const _ref21 of controls) {
      var _ref22 = _slicedToArray(_ref21, 2);
      const name2 = _ref22[0];
      const control = _ref22[1];
      let controlState = state_.get(name2);
      if (controlState !== void 0 && _JSON$stringify(controlState.control) !== _JSON$stringify(control)) {
        controlState.trackable.changed.remove(this.changed.dispatch);
        controlState = void 0;
      }
      if (controlState === void 0) {
        var _getControlTrackable2 = getControlTrackable(control);
        const trackable = _getControlTrackable2.trackable, getBuilderValue = _getControlTrackable2.getBuilderValue;
        controlState = { control, trackable, getBuilderValue };
        controlState.trackable.changed.add(this.changed.dispatch);
        state_.set(name2, controlState);
        changed = true;
      }
      if (unparsedJson !== void 0 && unparsedJson.hasOwnProperty(name2)) {
        changed = true;
        try {
          controlState.trackable.restoreState(unparsedJson[name2]);
        } catch (_a) {
        }
      }
    }
    if (unparsedJson !== void 0) {
      changed = true;
    }
    this.unparsedJson = void 0;
    if (changed) {
      this.changed.dispatch();
    }
  }
  get state() {
    if (this.controls.changed.count !== this.controlsGeneration) {
      this.handleControlsChanged();
    }
    return this.state_;
  }
  get value() {
    return this.state;
  }
  restoreState(value) {
    if (value === void 0) return;
    const state = this.state;
    verifyObject(value);
    const controls = this.controls.value;
    if (controls === void 0) {
      this.unparsedJson = value;
      this.changed.dispatch();
      return;
    }
    for (const _ref23 of state) {
      var _ref24 = _slicedToArray(_ref23, 2);
      const key = _ref24[0];
      const controlState = _ref24[1];
      const trackable = controlState.trackable;
      trackable.reset();
      if (value.hasOwnProperty(key)) {
        try {
          trackable.restoreState(value[key]);
        } catch (_a) {
        }
      }
    }
    this.unparsedJson = void 0;
  }
  reset() {
    for (const controlState of this.state.values()) {
      controlState.trackable.reset();
    }
    if (this.unparsedJson !== void 0) {
      this.unparsedJson = void 0;
      this.changed.dispatch();
    }
  }
  toJSON() {
    const state = this.state;
    const unparsedJson = this.unparsedJson;
    if (unparsedJson !== void 0) return unparsedJson;
    const obj = {};
    let empty = true;
    for (const _ref25 of state) {
      var _ref26 = _slicedToArray(_ref25, 2);
      const key = _ref26[0];
      const value = _ref26[1];
      const valueJson = value.trackable.toJSON();
      if (valueJson !== void 0) {
        obj[key] = valueJson;
        empty = false;
      }
    }
    if (empty) return void 0;
    return obj;
  }
}
function setControlInShader(gl, shader, name2, control, value) {
  const uName = uniformName(name2);
  const uniform = shader.uniform(uName);
  switch (control.type) {
    case "slider":
      switch (control.valueType) {
        case "int":
        case "uint":
          gl.uniform1i(uniform, value);
          break;
        case "float":
          gl.uniform1f(uniform, value);
      }
      break;
    case "color":
      gl.uniform3fv(uniform, value);
      break;
    case "invlerp":
      enableLerpShaderFunction(shader, uName, control.dataType, value.range);
      break;
  }
}
function setControlsInShader(gl, shader, shaderControlState, controls) {
  const state = shaderControlState.state;
  if (shaderControlState.controls.value === controls) {
    for (const _ref27 of state) {
      var _ref28 = _slicedToArray(_ref27, 2);
      const name2 = _ref28[0];
      const controlState = _ref28[1];
      setControlInShader(gl, shader, name2, controlState.control, controlState.trackable.value);
    }
  } else {
    for (const _ref29 of controls) {
      var _ref30 = _slicedToArray(_ref29, 2);
      const name2 = _ref30[0];
      const control = _ref30[1];
      const controlState = state.get(name2);
      const value = controlState !== void 0 && _JSON$stringify(controlState.control) === _JSON$stringify(control) ? controlState.trackable.value : control.default;
      setControlInShader(gl, shader, name2, control, value);
    }
  }
}
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AnnotationHoverState extends WatchableValue {
}
class WatchableAnnotationRelationshipStates extends WatchableMap {
  constructor() {
    super((context, { showMatches, segmentationState }) => {
      context.registerDisposer(showMatches.changed.add(this.changed.dispatch));
      context.registerDisposer(segmentationState.changed.add(this.changed.dispatch));
      context.registerDisposer(registerNested((nestedContext, segmentationState2) => {
        if (segmentationState2 == null) return;
        const segmentationGroupState = segmentationState2.segmentationGroupState;
        nestedContext.registerDisposer(segmentationGroupState.changed.add(this.changed.dispatch));
        nestedContext.registerDisposer(registerNested((groupContext, groupState) => {
          const visibleSegments = groupState.visibleSegments;
          let wasEmpty = visibleSegments.size === 0;
          groupContext.registerDisposer(visibleSegments.changed.add(() => {
            const isEmpty = visibleSegments.size === 0;
            if (isEmpty !== wasEmpty) {
              wasEmpty = isEmpty;
              this.changed.dispatch();
            }
          }));
        }, segmentationGroupState));
      }, segmentationState));
    });
  }
  get(name2) {
    let value = super.get(name2);
    if (value === void 0) {
      value = {
        segmentationState: new WatchableValue(void 0),
        showMatches: new TrackableBoolean(false)
      };
      super.set(name2, value);
    }
    return value;
  }
}
const DEFAULT_FRAGMENT_MAIN$2 = `
void main() {
  setColor(defaultColor());
}
`;
class AnnotationDisplayState extends RefCounted {
  constructor() {
    super(...arguments);
    this.shader = makeTrackableFragmentMain(DEFAULT_FRAGMENT_MAIN$2);
    this.shaderControls = new ShaderControlState(this.shader);
    this.fallbackShaderControls = new WatchableValue(getFallbackBuilderState(parseShaderUiControls(DEFAULT_FRAGMENT_MAIN$2)));
    this.shaderError = makeWatchableShaderError();
    this.color = new TrackableRGB(fromValues$1(1, 1, 0));
    this.relationshipStates = this.registerDisposer(new WatchableAnnotationRelationshipStates());
    this.ignoreNullSegmentFilter = new TrackableBoolean(true);
    this.displayUnfiltered = makeCachedLazyDerivedWatchableValue((map2, ignoreNullSegmentFilter) => {
      for (const state of map2.values()) {
        if (state.showMatches.value) {
          if (!ignoreNullSegmentFilter) return false;
          const segmentationState = state.segmentationState.value;
          if (segmentationState != null) {
            if (segmentationState.segmentationGroupState.value.visibleSegments.size > 0) {
              return false;
            }
          }
        }
      }
      return true;
    }, this.relationshipStates, this.ignoreNullSegmentFilter);
    this.hoverState = new AnnotationHoverState(void 0);
  }
}
class AnnotationLayerState extends RefCounted {
  constructor(options) {
    super();
    const transform = options.transform, localPosition = options.localPosition, source = options.source;
    var _options$role = options.role;
    const role = _options$role === void 0 ? RenderLayerRole.ANNOTATION : _options$role;
    this.transform = transform;
    this.localPosition = localPosition;
    this.source = this.registerDisposer(source);
    this.role = role;
    this.displayState = options.displayState;
    this.chunkTransform = this.registerDisposer(makeCachedLazyDerivedWatchableValue((modelTransform) => makeValueOrError(() => getChunkTransformParameters(valueOrThrow(modelTransform))), this.transform));
    this.dataSource = options.dataSource;
    this.subsourceId = options.subsourceId;
    this.subsourceIndex = options.subsourceIndex;
  }
  get sourceIndex() {
    const dataSource = this.dataSource;
    return dataSource.layer.dataSources.indexOf(dataSource);
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChunkLayout {
  constructor(size, transform, finiteRank) {
    this.size = clone(size);
    this.transform = clone$1(transform);
    this.finiteRank = finiteRank;
    const invTransform = create$4();
    const det = inverse(invTransform, 4, transform, 4, 4);
    if (det === 0) {
      throw new Error("Transform is singular");
    }
    this.invTransform = invTransform;
    this.detTransform = det;
  }
  toObject() {
    return { size: this.size, transform: this.transform, finiteRank: this.finiteRank };
  }
  static fromObject(msg) {
    return new ChunkLayout(msg.size, msg.transform, msg.finiteRank);
  }
  /**
   * Transform global spatial coordinates to local spatial coordinates.
   */
  globalToLocalSpatial(out, globalSpatial) {
    return transformMat4(out, globalSpatial, this.invTransform);
  }
  localSpatialVectorToGlobal(out, localVector) {
    return transformVectorByMat4(out, localVector, this.transform);
  }
  /**
   * Returns the unnormalized normal vector.
   */
  globalToLocalNormal(globalNormal, localNormal) {
    return transformVectorByMat4Transpose(globalNormal, localNormal, this.transform);
  }
}
const tempMat4$6 = create$4();
function estimateSliceAreaPerChunk(chunkLayout, viewMatrix) {
  let viewZProjection = 0;
  let chunkVolume = Math.abs(chunkLayout.detTransform);
  const transform = chunkLayout.transform, size = chunkLayout.size;
  for (let i = 0; i < 3; ++i) {
    let sum = 0;
    for (let j = 0; j < 3; ++j) {
      sum += viewMatrix[j * 4 + 2] * transform[4 * i + j];
    }
    const s = size[i];
    viewZProjection += Math.abs(sum) * s;
    chunkVolume *= s;
  }
  return chunkVolume / viewZProjection;
}
function updateFixedCurPositionInChunks(tsource, globalPosition, localPosition) {
  const curPositionInChunks = tsource.curPositionInChunks, fixedPositionWithinChunk = tsource.fixedPositionWithinChunk;
  const nonDisplayLowerClipBound = tsource.nonDisplayLowerClipBound, nonDisplayUpperClipBound = tsource.nonDisplayUpperClipBound;
  var _tsource$source$spec = tsource.source.spec;
  const rank = _tsource$source$spec.rank, chunkDataSize = _tsource$source$spec.chunkDataSize;
  if (!getChunkPositionFromCombinedGlobalLocalPositions(curPositionInChunks, globalPosition, localPosition, tsource.layerRank, tsource.fixedLayerToChunkTransform)) {
    return false;
  }
  for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
    const x = curPositionInChunks[chunkDim];
    if (x < nonDisplayLowerClipBound[chunkDim] || x >= nonDisplayUpperClipBound[chunkDim]) {
      return false;
    }
    const chunkSize = chunkDataSize[chunkDim];
    const chunk = curPositionInChunks[chunkDim] = Math.floor(x / chunkSize);
    fixedPositionWithinChunk[chunkDim] = x - chunk * chunkSize;
  }
  return true;
}
function pickBestAlternativeSource(viewMatrix, alternatives) {
  let numAlternatives = alternatives.length;
  let bestAlternativeIndex = 0;
  if (numAlternatives > 1) {
    let bestSliceArea = 0;
    for (let alternativeIndex = 0; alternativeIndex < numAlternatives; ++alternativeIndex) {
      let alternative = alternatives[alternativeIndex];
      const chunkLayout = alternative.chunkLayout;
      let sliceArea = estimateSliceAreaPerChunk(chunkLayout, viewMatrix);
      if (sliceArea > bestSliceArea) {
        bestSliceArea = sliceArea;
        bestAlternativeIndex = alternativeIndex;
      }
    }
  }
  return bestAlternativeIndex;
}
const tempChunkLayout = new ChunkLayout(create$3(), create$4(), 0);
class SliceViewProjectionParameters extends ProjectionParameters {
  constructor() {
    super(...arguments);
    this.viewportNormalInGlobalCoordinates = create$3();
    this.viewportNormalInCanonicalCoordinates = create$3();
    this.centerDataPosition = create$3();
    this.pixelSize = 0;
  }
}
function visibleSourcesInvalidated(oldValue, newValue) {
  if (oldValue.displayDimensionRenderInfo !== newValue.displayDimensionRenderInfo) return true;
  if (oldValue.pixelSize !== newValue.pixelSize) return true;
  const oldViewMatrix = oldValue.viewMatrix;
  const newViewMatrix = newValue.viewMatrix;
  for (let i = 0; i < 12; ++i) {
    if (oldViewMatrix[i] !== newViewMatrix[i]) return true;
  }
  return false;
}
class SliceViewBase extends SharedObject {
  constructor(projectionParameters) {
    super();
    this.projectionParameters = projectionParameters;
    this.visibleLayers = new _Map();
    this.visibleSourcesStale = true;
    this.registerDisposer(projectionParameters.changed.add((oldValue, newValue) => {
      if (visibleSourcesInvalidated(oldValue, newValue)) {
        this.invalidateVisibleSources();
      }
      this.invalidateVisibleChunks();
    }));
  }
  invalidateVisibleSources() {
    this.visibleSourcesStale = true;
  }
  invalidateVisibleChunks() {
  }
  /**
   * Computes the list of sources to use for each visible layer, based on the
   * current pixelSize.
   */
  updateVisibleSources() {
    if (!this.visibleSourcesStale) {
      return;
    }
    this.visibleSourcesStale = false;
    const curDisplayDimensionRenderInfo = this.projectionParameters.value.displayDimensionRenderInfo;
    const visibleLayers = this.visibleLayers;
    for (const _ref of visibleLayers) {
      var _ref2 = _slicedToArray(_ref, 2);
      const renderLayer = _ref2[0];
      var _ref2$ = _ref2[1];
      const allSources = _ref2$.allSources;
      const visibleSources = _ref2$.visibleSources;
      const displayDimensionRenderInfo = _ref2$.displayDimensionRenderInfo;
      visibleSources.length = 0;
      if (displayDimensionRenderInfo !== curDisplayDimensionRenderInfo || allSources.length === 0) {
        continue;
      }
      const preferredOrientationIndex = pickBestAlternativeSource(this.projectionParameters.value.viewMatrix, allSources.map((x) => x[0]));
      const sources = allSources[preferredOrientationIndex];
      for (const source of renderLayer.filterVisibleSources(this, sources)) {
        visibleSources.push(source);
      }
      visibleSources.reverse();
    }
  }
}
const DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 = 18;
function getNearIsotropicBlockSize(options) {
  let rank = options.rank, upperVoxelBound = options.upperVoxelBound;
  var _options$maxVoxelsPer = options.maxVoxelsPerChunkLog2;
  let maxVoxelsPerChunkLog2 = _options$maxVoxelsPer === void 0 ? DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 : _options$maxVoxelsPer, chunkToViewTransform = options.chunkToViewTransform, displayRank = options.displayRank, minBlockSize = options.minBlockSize, maxBlockSize = options.maxBlockSize;
  var _options$lowerVoxelBo = options.lowerVoxelBound;
  const lowerVoxelBound = _options$lowerVoxelBo === void 0 ? new Uint32Array(rank) : _options$lowerVoxelBo;
  const effectiveVoxelSize = new Float32Array(rank);
  for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
    let factor = 0;
    for (let displayDim = 0; displayDim < displayRank; ++displayDim) {
      const c = chunkToViewTransform[chunkDim * displayRank + displayDim];
      factor += c * c;
    }
    effectiveVoxelSize[chunkDim] = Math.sqrt(factor);
  }
  const chunkDataSize = new Uint32Array(rank);
  if (minBlockSize !== void 0) {
    chunkDataSize.set(minBlockSize);
  } else {
    chunkDataSize.fill(1);
  }
  const chunkDataSizeUpperBound = new Array(rank);
  for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
    let bound = Number.POSITIVE_INFINITY;
    if (effectiveVoxelSize[chunkDim] === 0) {
      bound = chunkDataSize[chunkDim];
    } else {
      if (upperVoxelBound !== void 0) {
        bound = Math.pow(2, Math.floor(_Math$log$1(upperVoxelBound[chunkDim] - lowerVoxelBound[chunkDim])));
      }
      if (maxBlockSize !== void 0) {
        bound = Math.min(bound, maxBlockSize[chunkDim]);
      }
    }
    chunkDataSizeUpperBound[chunkDim] = bound;
  }
  function findNextDimension() {
    let minSize = Infinity;
    let minDimension = -1;
    for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
      if (chunkDataSize[chunkDim] >= chunkDataSizeUpperBound[chunkDim]) {
        continue;
      }
      let size = chunkDataSize[chunkDim] * effectiveVoxelSize[chunkDim];
      if (size < minSize) {
        minSize = size;
        minDimension = chunkDim;
      }
    }
    return minDimension;
  }
  maxVoxelsPerChunkLog2 -= _Math$log$1(prod(chunkDataSize));
  for (let i = 0; i < maxVoxelsPerChunkLog2; ++i) {
    let nextDim = findNextDimension();
    if (nextDim === -1) {
      break;
    }
    chunkDataSize[nextDim] *= 2;
  }
  return chunkDataSize;
}
function getTwoDimensionalBlockSizes(options) {
  const chunkDataSizes = [];
  const displayRank = options.displayRank, chunkToViewTransform = options.chunkToViewTransform, rank = options.rank;
  if (displayRank > 3) {
    throw new Error("Unsupported view transform");
  }
  if (displayRank < 3) {
    return [getNearIsotropicBlockSize(options)];
  }
  for (let i = 0; i < 3; ++i) {
    const excludedDim = (i + 2) % 3;
    const restrictedTransform = new Float32Array(chunkToViewTransform);
    for (let j = 0; j < rank; ++j) {
      restrictedTransform[j * displayRank + excludedDim] = 0;
    }
    chunkDataSizes[i] = getNearIsotropicBlockSize(_Object$assign(_Object$assign({}, options), { chunkToViewTransform: restrictedTransform }));
  }
  return chunkDataSizes;
}
var ChunkLayoutPreference;
(function(ChunkLayoutPreference2) {
  ChunkLayoutPreference2[ChunkLayoutPreference2["ISOTROPIC"] = 0] = "ISOTROPIC";
  ChunkLayoutPreference2[ChunkLayoutPreference2["FLAT"] = 1] = "FLAT";
})(ChunkLayoutPreference || (ChunkLayoutPreference = {}));
function getChunkDataSizes(options) {
  if (options.chunkDataSizes !== void 0) {
    return options.chunkDataSizes;
  }
  var _options$chunkLayoutP = options.chunkLayoutPreference;
  const chunkLayoutPreference = _options$chunkLayoutP === void 0 ? ChunkLayoutPreference.ISOTROPIC : _options$chunkLayoutP;
  switch (chunkLayoutPreference) {
    case ChunkLayoutPreference.ISOTROPIC:
      return [getNearIsotropicBlockSize(options)];
    case ChunkLayoutPreference.FLAT:
      return getTwoDimensionalBlockSizes(options);
  }
}
function makeSliceViewChunkSpecification(options) {
  const rank = options.rank, chunkDataSize = options.chunkDataSize, upperVoxelBound = options.upperVoxelBound;
  var _options$lowerVoxelBo2 = options.lowerVoxelBound;
  const lowerVoxelBound = _options$lowerVoxelBo2 === void 0 ? new Float32Array(rank) : _options$lowerVoxelBo2;
  const lowerChunkBound = new Float32Array(rank);
  const upperChunkBound = new Float32Array(rank);
  for (let i = 0; i < rank; ++i) {
    lowerChunkBound[i] = Math.floor(lowerVoxelBound[i] / chunkDataSize[i]);
    upperChunkBound[i] = Math.floor((upperVoxelBound[i] - 1) / chunkDataSize[i] + 1);
  }
  return {
    rank,
    chunkDataSize,
    lowerChunkBound,
    upperChunkBound,
    lowerVoxelBound,
    upperVoxelBound
  };
}
function* filterVisibleSources(sliceView, renderLayer, sources) {
  const pixelSize = sliceView.projectionParameters.value.pixelSize * 1.1;
  const smallestVoxelSize = sources[0].effectiveVoxelSize;
  const renderScaleTarget = renderLayer.renderScaleTarget.value;
  const canImproveOnVoxelSize = (voxelSize) => {
    const targetSize = pixelSize * renderScaleTarget;
    for (let i = 0; i < 3; ++i) {
      const size = voxelSize[i];
      if (size > targetSize && size > 1.01 * smallestVoxelSize[i]) {
        return true;
      }
    }
    return false;
  };
  const improvesOnPrevVoxelSize = (voxelSize, prevVoxelSize2) => {
    const targetSize = pixelSize * renderScaleTarget;
    for (let i = 0; i < 3; ++i) {
      const size = voxelSize[i];
      const prevSize = prevVoxelSize2[i];
      if (Math.abs(targetSize - size) < Math.abs(targetSize - prevSize) && size < 1.01 * prevSize) {
        return true;
      }
    }
    return false;
  };
  let scaleIndex = sources.length - 1;
  let prevVoxelSize;
  while (true) {
    const transformedSource = sources[scaleIndex];
    if (prevVoxelSize !== void 0 && !improvesOnPrevVoxelSize(transformedSource.effectiveVoxelSize, prevVoxelSize)) {
      break;
    }
    yield transformedSource;
    if (scaleIndex === 0 || !canImproveOnVoxelSize(transformedSource.effectiveVoxelSize)) {
      break;
    }
    prevVoxelSize = transformedSource.effectiveVoxelSize;
    --scaleIndex;
  }
}
const SLICEVIEW_RPC_ID = "SliceView";
const SLICEVIEW_RENDERLAYER_RPC_ID = "sliceview/RenderLayer";
const SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID = "SliceView.addVisibleLayer";
const SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID = "SliceView.removeVisibleLayer";
const tempVisibleVolumetricChunkLower = new Float32Array(3);
const tempVisibleVolumetricChunkUpper = new Float32Array(3);
const tempVisibleVolumetricModelViewProjection = create$4();
const tempVisibleVolumetricClippingPlanes$1 = new Float32Array(24);
function forEachVolumetricChunkWithinFrustrum(clippingPlanes, transformedSource, callback, predicate) {
  const lower = tempVisibleVolumetricChunkLower;
  const upper = tempVisibleVolumetricChunkUpper;
  const lowerChunkDisplayBound = transformedSource.lowerChunkDisplayBound, upperChunkDisplayBound = transformedSource.upperChunkDisplayBound;
  for (let i = 0; i < 3; ++i) {
    lower[i] = Math.max(lower[i], lowerChunkDisplayBound[i]);
    upper[i] = Math.min(upper[i], upperChunkDisplayBound[i]);
  }
  const curPositionInChunks = transformedSource.curPositionInChunks, chunkDisplayDimensionIndices = transformedSource.chunkDisplayDimensionIndices;
  function recurse() {
    if (!predicate(lower[0], lower[1], lower[2], upper[0], upper[1], upper[2], clippingPlanes)) {
      return;
    }
    let splitDim = 0;
    let splitSize = Math.max(0, upper[0] - lower[0]);
    let volume = splitSize;
    for (let i = 1; i < 3; ++i) {
      const size = Math.max(0, upper[i] - lower[i]);
      volume *= size;
      if (size > splitSize) {
        splitSize = size;
        splitDim = i;
      }
    }
    if (volume === 0) return;
    if (volume === 1) {
      curPositionInChunks[chunkDisplayDimensionIndices[0]] = lower[0];
      curPositionInChunks[chunkDisplayDimensionIndices[1]] = lower[1];
      curPositionInChunks[chunkDisplayDimensionIndices[2]] = lower[2];
      callback(lower, clippingPlanes);
      return;
    }
    const prevLower = lower[splitDim];
    const prevUpper = upper[splitDim];
    const splitPoint = Math.floor(0.5 * (prevLower + prevUpper));
    upper[splitDim] = splitPoint;
    recurse();
    upper[splitDim] = prevUpper;
    lower[splitDim] = splitPoint;
    recurse();
    lower[splitDim] = prevLower;
  }
  recurse();
}
function forEachVisibleVolumetricChunk(projectionParameters, localPosition, transformedSource, callback) {
  if (!updateFixedCurPositionInChunks(transformedSource, projectionParameters.globalPosition, localPosition)) {
    return;
  }
  const chunkSize = transformedSource.chunkLayout.size;
  const modelViewProjection = multiply$3(tempVisibleVolumetricModelViewProjection, projectionParameters.viewProjectionMat, transformedSource.chunkLayout.transform);
  for (let i = 0; i < 3; ++i) {
    const s = chunkSize[i];
    for (let j = 0; j < 4; ++j) {
      modelViewProjection[4 * i + j] *= s;
    }
  }
  const clippingPlanes = tempVisibleVolumetricClippingPlanes$1;
  getFrustrumPlanes(clippingPlanes, modelViewProjection);
  const lower = tempVisibleVolumetricChunkLower;
  const upper = tempVisibleVolumetricChunkUpper;
  lower.fill(Number.NEGATIVE_INFINITY);
  upper.fill(Number.POSITIVE_INFINITY);
  forEachVolumetricChunkWithinFrustrum(clippingPlanes, transformedSource, callback, isAABBVisible);
}
function forEachPlaneIntersectingVolumetricChunk(projectionParameters, localPosition, transformedSource, chunkLayout, callback) {
  if (!updateFixedCurPositionInChunks(transformedSource, projectionParameters.globalPosition, localPosition)) {
    return;
  }
  const chunkSize = chunkLayout.size;
  const modelViewProjection = multiply$3(tempVisibleVolumetricModelViewProjection, projectionParameters.viewProjectionMat, chunkLayout.transform);
  for (let i = 0; i < 3; ++i) {
    const s = chunkSize[i];
    for (let j = 0; j < 4; ++j) {
      modelViewProjection[4 * i + j] *= s;
    }
  }
  const invModelViewProjection = tempMat4$6;
  invert$1(invModelViewProjection, modelViewProjection);
  const lower = tempVisibleVolumetricChunkLower;
  const upper = tempVisibleVolumetricChunkUpper;
  const epsilon = 1e-3;
  for (let i = 0; i < 3; ++i) {
    const c = invModelViewProjection[12 + i] + epsilon / chunkSize[i];
    const xCoeff = Math.abs(invModelViewProjection[i]);
    const yCoeff = Math.abs(invModelViewProjection[4 + i]);
    lower[i] = Math.floor(c - xCoeff - yCoeff);
    upper[i] = Math.floor(c + xCoeff + yCoeff + 1);
  }
  const clippingPlanes = tempVisibleVolumetricClippingPlanes$1;
  for (let i = 0; i < 3; ++i) {
    const xCoeff = modelViewProjection[4 * i];
    const yCoeff = modelViewProjection[4 * i + 1];
    const zCoeff = modelViewProjection[4 * i + 2];
    clippingPlanes[i] = xCoeff;
    clippingPlanes[4 + i] = -xCoeff;
    clippingPlanes[8 + i] = +yCoeff;
    clippingPlanes[12 + i] = -yCoeff;
    clippingPlanes[16 + i] = +zCoeff;
    clippingPlanes[20 + i] = -zCoeff;
  }
  {
    const i = 3;
    const xCoeff = modelViewProjection[4 * i];
    const yCoeff = modelViewProjection[4 * i + 1];
    const zCoeff = modelViewProjection[4 * i + 2];
    clippingPlanes[i] = 1 + xCoeff;
    clippingPlanes[4 + i] = 1 - xCoeff;
    clippingPlanes[8 + i] = 1 + yCoeff;
    clippingPlanes[12 + i] = 1 - yCoeff;
    clippingPlanes[16 + i] = zCoeff;
    clippingPlanes[20 + i] = -zCoeff;
  }
  forEachVolumetricChunkWithinFrustrum(clippingPlanes, transformedSource, callback, isAABBIntersectingPlane);
}
function getNormalizedChunkLayout(projectionParameters, chunkLayout) {
  const finiteRank = chunkLayout.finiteRank;
  if (finiteRank === 3) return chunkLayout;
  tempChunkLayout.finiteRank = finiteRank;
  copy$3(tempChunkLayout.size, chunkLayout.size);
  const transform = copy$4(tempChunkLayout.transform, chunkLayout.transform);
  const invTransform = copy$4(tempChunkLayout.invTransform, chunkLayout.invTransform);
  tempChunkLayout.detTransform = chunkLayout.detTransform;
  const invViewMatrix = projectionParameters.invViewMatrix, width = projectionParameters.width, height = projectionParameters.height;
  const depth = getViewFrustrumDepthRange(projectionParameters.projectionMat);
  for (let chunkRenderDim = finiteRank; chunkRenderDim < 3; ++chunkRenderDim) {
    const offset = invViewMatrix[12 + chunkRenderDim];
    let lower = offset, upper = offset;
    const xc = Math.abs(invViewMatrix[chunkRenderDim] * width);
    lower -= xc;
    upper += xc;
    const yc = Math.abs(invViewMatrix[chunkRenderDim + 4] * height);
    lower -= yc;
    upper += yc;
    const zc = Math.abs(invViewMatrix[chunkRenderDim + 8] * depth);
    lower -= zc;
    upper += zc;
    const scaleFactor = Math.max(1, upper - lower);
    transform[12 + chunkRenderDim] = lower;
    transform[5 * chunkRenderDim] = scaleFactor;
  }
  invert$1(invTransform, transform);
  return tempChunkLayout;
}
const ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID = "annotation.MetadataChunkSource";
const ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID = "annotation.GeometryChunkSource";
const ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID = "annotation.SubsetGeometryChunkSource";
const ANNOTATION_REFERENCE_ADD_RPC_ID = "annotation.reference.add";
const ANNOTATION_REFERENCE_DELETE_RPC_ID = "annotation.reference.delete";
const ANNOTATION_COMMIT_UPDATE_RPC_ID = "annotation.commit";
const ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID = "annotation.commit";
const ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID = "annotation/SpatiallyIndexedRenderLayer";
const ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID = "annotation/PerspectiveRenderLayer:updateSources";
const ANNOTATION_RENDER_LAYER_RPC_ID = "annotation/RenderLayer";
const ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID = "annotation/RenderLayer.updateSegmentation";
const tempMat3$2 = create$5();
function forEachVisibleAnnotationChunk(projectionParameters, localPosition, renderScaleTarget, transformedSources, beginScale, callback) {
  const displayDimensionRenderInfo = projectionParameters.displayDimensionRenderInfo, viewMatrix = projectionParameters.viewMatrix, projectionMat = projectionParameters.projectionMat, width = projectionParameters.width, height = projectionParameters.height;
  const voxelPhysicalScales = displayDimensionRenderInfo.voxelPhysicalScales;
  const viewDet = Math.abs(determinant(mat3FromMat4(tempMat3$2, viewMatrix)));
  const canonicalToPhysicalScale = prod3(voxelPhysicalScales);
  const viewFrustrumVolume = getViewFrustrumVolume(projectionMat) / viewDet * canonicalToPhysicalScale;
  if (transformedSources.length === 0) return;
  const baseSource = transformedSources[0];
  let sourceVolume = Math.abs(baseSource.chunkLayout.detTransform) * canonicalToPhysicalScale;
  const lowerClipDisplayBound = baseSource.lowerClipDisplayBound, upperClipDisplayBound = baseSource.upperClipDisplayBound;
  for (let i = 0; i < 3; ++i) {
    sourceVolume *= upperClipDisplayBound[i] - lowerClipDisplayBound[i];
  }
  const effectiveVolume = Math.min(sourceVolume, viewFrustrumVolume);
  const viewportArea = width * height;
  const targetNumAnnotations = viewportArea / renderScaleTarget ** 2;
  const physicalDensityTarget = targetNumAnnotations / effectiveVolume;
  let totalPhysicalDensity = 0;
  for (let scaleIndex = transformedSources.length - 1; scaleIndex >= 0 && totalPhysicalDensity < physicalDensityTarget; --scaleIndex) {
    const transformedSource = transformedSources[scaleIndex];
    const spec = transformedSource.source.spec;
    const chunkLayout = transformedSource.chunkLayout;
    const physicalVolume = prod3(chunkLayout.size) * Math.abs(chunkLayout.detTransform) * canonicalToPhysicalScale;
    const limit = spec.limit, rank = spec.rank;
    const nonDisplayLowerClipBound = transformedSource.nonDisplayLowerClipBound, nonDisplayUpperClipBound = transformedSource.nonDisplayUpperClipBound;
    let sliceFraction = 1;
    for (let i = 0; i < rank; ++i) {
      const b = nonDisplayUpperClipBound[i] - nonDisplayLowerClipBound[i];
      if (_Number$isFinite(b)) sliceFraction /= b;
    }
    const physicalDensity = limit * sliceFraction / physicalVolume;
    const newTotalPhysicalDensity = totalPhysicalDensity + physicalDensity;
    const totalPhysicalSpacing = Math.pow(1 / newTotalPhysicalDensity, 1 / 3);
    const totalPixelSpacing = Math.sqrt(viewportArea / (newTotalPhysicalDensity * effectiveVolume));
    const desiredCount = (physicalDensityTarget - totalPhysicalDensity) * physicalVolume / sliceFraction;
    const drawFraction = Math.min(1, desiredCount / spec.limit);
    forEachVisibleVolumetricChunk(projectionParameters, localPosition, transformedSource, () => {
      callback(transformedSource, scaleIndex, drawFraction, totalPhysicalSpacing, totalPixelSpacing);
    });
    totalPhysicalDensity = newTotalPhysicalDensity;
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const glsl_COLORMAPS = `vec3 colormapJet(float x) {
  vec3 result;
  result.r = x < 0.89 ? ((x - 0.35) / 0.31) : (1.0 - (x - 0.89) / 0.11 * 0.5);
  result.g = x < 0.64 ? ((x - 0.125) * 4.0) : (1.0 - (x - 0.64) / 0.27);
  result.b = x < 0.34 ? (0.5 + x * 0.5 / 0.11) : (1.0 - (x - 0.34) / 0.31);
  return clamp(result, 0.0, 1.0);
}
vec3 colormapCubehelix(float x) {
  float xclamp = clamp(x, 0.0, 1.0);
  float angle = 2.0 * 3.1415926 * (4.0 / 3.0 + xclamp);
  float amp = xclamp * (1.0 - xclamp) / 2.0;
  vec3 result;
  float cosangle = cos(angle);
  float sinangle = sin(angle);
  result.r = -0.14861 * cosangle + 1.78277 * sinangle;
  result.g = -0.29227 * cosangle + -0.90649 * sinangle;
  result.b = 1.97294 * cosangle;
  result = clamp(xclamp + amp * result, 0.0, 1.0);
  return result;
}
`;
function makeSimplePropertyRenderHandler(shaderType, bind) {
  return {
    defineShader(builder, identifier) {
      const propName = `prop_${identifier}`;
      const aName = `a_${propName}`;
      builder.addAttribute(`${shaderType}`, aName);
      builder.addVertexCode(`${shaderType} ${propName}() { return ${aName}; }`);
      builder.addInitializer((shader) => {
        const location2 = shader.attribute(aName);
        const gl = shader.gl;
        shader.vertexShaderInputBinders[propName] = location2 === -1 ? {
          enable() {
          },
          disable() {
          },
          bind() {
          }
        } : {
          enable(divisor) {
            gl.enableVertexAttribArray(location2);
            gl.vertexAttribDivisor(location2, divisor);
          },
          disable() {
            gl.vertexAttribDivisor(location2, 0);
            gl.disableVertexAttribArray(location2);
          },
          bind(stride, offset) {
            bind(gl, location2, stride, offset);
          }
        };
      });
    }
  };
}
function makeFloatPropertyRenderHandler(shaderType, numComponents, attributeType, normalized) {
  return makeSimplePropertyRenderHandler(shaderType, (gl, location2, stride, offset) => {
    gl.vertexAttribPointer(
      location2,
      /*size=*/
      numComponents,
      /*type=*/
      attributeType,
      /*normalized=*/
      normalized,
      stride,
      offset
    );
  });
}
function makeIntegerPropertyRenderHandler(shaderType, numComponents, attributeType) {
  return makeSimplePropertyRenderHandler(shaderType, (gl, location2, stride, offset) => {
    gl.vertexAttribIPointer(
      location2,
      /*size=*/
      numComponents,
      /*type=*/
      attributeType,
      stride,
      offset
    );
  });
}
const annotationPropertyTypeRenderHandlers = {
  "rgb": makeFloatPropertyRenderHandler(
    "highp vec3",
    3,
    WebGL2RenderingContext.UNSIGNED_BYTE,
    /*normalized=*/
    true
  ),
  "rgba": makeFloatPropertyRenderHandler(
    "highp vec4",
    4,
    WebGL2RenderingContext.UNSIGNED_BYTE,
    /*normalized=*/
    true
  ),
  "float32": makeFloatPropertyRenderHandler(
    "highp float",
    1,
    WebGL2RenderingContext.FLOAT,
    /*normalized=*/
    false
  ),
  "uint32": makeIntegerPropertyRenderHandler("highp uint", 1, WebGL2RenderingContext.UNSIGNED_INT),
  "int32": makeIntegerPropertyRenderHandler("highp int", 1, WebGL2RenderingContext.INT),
  "uint16": makeIntegerPropertyRenderHandler("highp uint", 1, WebGL2RenderingContext.UNSIGNED_SHORT),
  "int16": makeIntegerPropertyRenderHandler("highp int", 1, WebGL2RenderingContext.SHORT),
  "uint8": makeIntegerPropertyRenderHandler("highp uint", 1, WebGL2RenderingContext.UNSIGNED_BYTE),
  "int8": makeIntegerPropertyRenderHandler("highp int", 1, WebGL2RenderingContext.BYTE)
};
class AnnotationRenderHelper extends RefCounted {
  constructor(gl, annotationType, rank, properties, shaderControlState, fallbackShaderParameters, shaderError) {
    super();
    this.gl = gl;
    this.annotationType = annotationType;
    this.rank = rank;
    this.properties = properties;
    this.shaderControlState = shaderControlState;
    this.fallbackShaderParameters = fallbackShaderParameters;
    this.shaderError = shaderError;
    const serializedGeometryBytesPerAnnotation = this.serializedGeometryBytesPerAnnotation = annotationTypeHandlers[annotationType].serializedBytes(rank);
    var _getPropertyOffsets = getPropertyOffsets(rank, serializedGeometryBytesPerAnnotation, properties);
    const offsets = _getPropertyOffsets.offsets, serializedBytesPerAnnotation = _getPropertyOffsets.serializedBytes, propertyGroupBytes = _getPropertyOffsets.propertyGroupBytes;
    this.serializedBytesPerAnnotation = serializedBytesPerAnnotation;
    this.propertyOffsets = offsets;
    this.propertyGroupBytes = propertyGroupBytes;
    this.geometryDataStride = propertyGroupBytes[0];
  }
  getDependentShader(memoizeKey, _defineShader) {
    return parameterizedEmitterDependentShaderGetter(this, this.gl, {
      memoizeKey: {
        t: "annotation",
        targetIsSliceView: this.targetIsSliceView,
        type: this.annotationType,
        subType: memoizeKey,
        properties: this.properties,
        rank: this.rank
      },
      fallbackParameters: this.fallbackShaderParameters,
      parameters: this.shaderControlState.builderState,
      shaderError: this.shaderError,
      defineShader: (builder, parameters) => {
        const rank = this.rank, properties = this.properties;
        const referencedProperties = [];
        const processedCode = parameters.parseResult.code;
        for (let i = 0, numProperties = properties.length; i < numProperties; ++i) {
          const property = properties[i];
          const functionName = `prop_${property.identifier}`;
          if (!processedCode.match(new RegExp(`\\b${functionName}\\b`))) continue;
          referencedProperties.push(i);
          const handler = annotationPropertyTypeRenderHandlers[property.type];
          handler.defineShader(builder, property.identifier, rank);
        }
        const propertyOffsets = this.propertyOffsets;
        const propertyGroupBytes = this.propertyGroupBytes;
        const propertyGroupCumulativeBytes = new Array(propertyGroupBytes.length);
        propertyGroupCumulativeBytes[0] = 0;
        for (let i = 1; i < propertyGroupBytes.length; ++i) {
          propertyGroupCumulativeBytes[i] = propertyGroupCumulativeBytes[i - 1] + propertyGroupBytes[i - 1];
        }
        builder.addInitializer((shader) => {
          const binders = referencedProperties.map((i) => shader.vertexShaderInputBinders[`prop_${properties[i].identifier}`]);
          const numProperties = binders.length;
          shader.vertexShaderInputBinders["properties"] = {
            enable(divisor) {
              for (let i = 0; i < numProperties; ++i) {
                binders[i].enable(divisor);
              }
            },
            bind(stride, offset) {
              for (let i = 0; i < numProperties; ++i) {
                var _propertyOffsets$refe = propertyOffsets[referencedProperties[i]];
                let group = _propertyOffsets$refe.group, propertyOffset = _propertyOffsets$refe.offset;
                binders[i].bind(
                  /*stride=*/
                  propertyGroupBytes[group],
                  /*offset=*/
                  offset + propertyOffset + propertyGroupCumulativeBytes[group] * stride
                );
              }
            },
            disable() {
              for (let i = 0; i < numProperties; ++i) {
                binders[i].disable();
              }
            }
          };
        });
        builder.addUniform("highp vec3", "uColor");
        builder.addUniform("highp uint", "uSelectedIndex");
        builder.addVarying("highp vec4", "vColor");
        builder.addUniform("highp vec3", "uSubspaceMatrix", rank);
        builder.addUniform("highp mat4", "uModelViewProjection");
        builder.addUniform("highp float", "uModelClipBounds", rank * 2);
        builder.addUniform("highp uint", "uPickID");
        builder.addVarying("highp uint", "vPickID", "flat");
        builder.addVertexCode(glsl_COLORMAPS);
        builder.addVertexCode(`
vec3 defaultColor() { return uColor; }
highp uint getPickBaseOffset() { return uint(gl_InstanceID) * ${this.pickIdsPerInstance}u; }
`);
        builder.addFragmentCode(`
void emitAnnotation(vec4 color) {
  emit(color, vPickID);
}
`);
        const glsl_getSubspaceClipCoefficient = `
float getSubspaceClipCoefficient(float modelPoint[${this.rank}]) {
  float coefficient = 1.0;
  for (int i = 0; i < ${rank}; ++i) {
    float d = abs(modelPoint[i] - uModelClipBounds[i]) * uModelClipBounds[${rank} + i];
    coefficient *= max(0.0, 1.0 - d);
  }
  return coefficient;
}
`;
        builder.addVertexCode(glsl_getSubspaceClipCoefficient);
        builder.addFragmentCode(glsl_getSubspaceClipCoefficient);
        builder.addVertexCode(`
vec3 projectModelVectorToSubspace(float modelPoint[${this.rank}]) {
  vec3 result = vec3(0.0, 0.0, 0.0);
  for (int i = 0; i < ${rank}; ++i) {
    result += uSubspaceMatrix[i] * modelPoint[i];
  }
  return result;
}

float getMaxEndpointSubspaceClipCoefficient(float modelPointA[${this.rank}],  float modelPointB[${this.rank}]) {
  float coefficient = 1.0;
  for (int i = 0; i < ${rank}; ++i) {
    float dA = abs(modelPointA[i] - uModelClipBounds[i]) * uModelClipBounds[${rank} + i];
    float dB = abs(modelPointB[i] - uModelClipBounds[i]) * uModelClipBounds[${rank} + i];
    coefficient *= max(0.0, 1.0 - min(dA, dB));
  }
  return coefficient;
}

float getMaxSubspaceClipCoefficient(float modelPointA[${this.rank}],  float modelPointB[${this.rank}]) {
  float coefficient = 1.0;
  for (int i = 0; i < ${rank}; ++i) {
    float a = modelPointA[i];
    float b = modelPointB[i];
    float c = uModelClipBounds[i];
    float x = clamp(c, min(a, b), max(a, b));
    float d = abs(x - c) * uModelClipBounds[${rank} + i];
    coefficient *= max(0.0, 1.0 - d);
  }
  return coefficient;
}

`);
        addControlsToBuilder(parameters, builder);
        builder.addVertexCode(`
const bool PROJECTION_VIEW = ${!this.targetIsSliceView};
bool ng_discardValue;
#define discard ng_discard()
void ng_discard() {
  ng_discardValue = true;
}
void setLineColor(vec4 startColor, vec4 endColor);
void setLineWidth(float width);

void setAxisColor(vec4 startColor, vec4 endColor);
void setAxisWidth(float width);
void setSphereColor(vec4 color);

void setEndpointMarkerColor(vec4 startColor, vec4 endColor);
void setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor);
void setEndpointMarkerSize(float startSize, float endSize);
void setEndpointMarkerBorderWidth(float startSize, float endSize);

void setPointMarkerColor(vec4 color);
void setPointMarkerBorderColor(vec4 color);
void setPointMarkerSize(float size);
void setPointMarkerBorderWidth(float size);
void setPointMarkerBorderColor(vec3 color) { setPointMarkerBorderColor(vec4(color, 1.0)); }

void setAxisEndpointMarkerColor(vec4 startColor, vec4 endColor);
void setAxisEndpointMarkerBorderColor(vec4 startColor, vec4 endColor);
void setAxisEndpointMarkerSize(float startSize, float endSize);
void setAxisEndpointMarkerBorderWidth(float startSize, float endSize);

void setAxisPointMarkerColor(vec4 color);
void setAxisPointMarkerBorderColor(vec4 color);
void setAxisPointMarkerSize(float size);
void setAxisPointMarkerBorderWidth(float size);

void setEllipsoidFillColor(vec4 color);

void setBoundingBoxBorderColor(vec4 color);
void setBoundingBoxBorderWidth(float size);
void setBoundingBoxFillColor(vec4 color);

void setEndpointMarkerColor(vec3 startColor, vec3 endColor) {
  setEndpointMarkerColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setEndpointMarkerBorderColor(vec3 startColor, vec3 endColor) {
  setEndpointMarkerBorderColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setEndpointMarkerColor(vec3 color) { setEndpointMarkerColor(color, color); }
void setEndpointMarkerColor(vec4 color) { setEndpointMarkerColor(color, color); }
void setEndpointMarkerBorderColor(vec3 color) { setEndpointMarkerBorderColor(color, color); }
void setEndpointMarkerBorderColor(vec4 color) { setEndpointMarkerBorderColor(color, color); }
void setEndpointMarkerSize(float size) { setEndpointMarkerSize(size, size); }
void setEndpointMarkerBorderWidth(float size) { setEndpointMarkerBorderWidth(size, size); }
void setLineColor(vec4 color) { setLineColor(color, color); }
void setLineColor(vec3 color) { setLineColor(vec4(color, 1.0)); }
void setLineColor(vec3 startColor, vec3 endColor) { setLineColor(vec4(startColor, 1.0), vec4(endColor, 1.0)); }
void setAxisColor(vec4 color) { setAxisColor(color, color); }
void setAxisColor(vec3 color) { setAxisColor(vec4(color, 1.0)); }
void setAxisColor(vec3 startColor, vec3 endColor) { setAxisColor(vec4(startColor, 1.0), vec4(endColor, 1.0)); }
void setAxisEndpointMarkerColor(vec3 startColor, vec3 endColor) {
  setAxisEndpointMarkerColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setAxisEndpointMarkerBorderColor(vec3 startColor, vec3 endColor) {
  setAxisEndpointMarkerBorderColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setAxisEndpointMarkerColor(vec3 color) { setAxisEndpointMarkerColor(color, color); }
void setAxisEndpointMarkerColor(vec4 color) { setAxisEndpointMarkerColor(color, color); }
void setAxisEndpointMarkerBorderColor(vec3 color) { setAxisEndpointMarkerBorderColor(color, color); }
void setAxisEndpointMarkerBorderColor(vec4 color) { setAxisEndpointMarkerBorderColor(color, color); }
void setAxisEndpointMarkerSize(float size) { setAxisEndpointMarkerSize(size, size); }
void setAxisEndpointMarkerBorderWidth(float size) { setAxisEndpointMarkerBorderWidth(size, size); }
void setColor(vec4 color) {
  setPointMarkerColor(color);
  setLineColor(color);
  setEndpointMarkerColor(color);
  setBoundingBoxBorderColor(color);
  setEllipsoidFillColor(vec4(color.rgb, color.a * (PROJECTION_VIEW ? 1.0 : 0.5)));
  setAxisColor(color);
  setAxisEndpointMarkerColor(color);
  setSphereColor(color);
}
void setEllipsoidFillColor(vec3 color) { setEllipsoidFillColor(vec4(color, 1.0)); }

void setBoundingBoxFillColor(vec3 color) { setBoundingBoxFillColor(vec4(color, 1.0)); }
void setBoundingBoxBorderColor(vec3 color) { setBoundingBoxBorderColor(vec4(color, 1.0)); }

void setColor(vec3 color) { setColor(vec4(color, 1.0)); }
void userMain();
`);
        for (const _ref of annotationTypeRenderHandlers) {
          var _ref2 = _slicedToArray(_ref, 2);
          const annotationType = _ref2[0];
          const renderHandler = _ref2[1];
          if (annotationType === this.annotationType) continue;
          renderHandler.defineShaderNoOpSetters(builder);
        }
        _defineShader(builder);
        builder.addVertexCode(`
#define main userMain
` + shaderCodeWithLineDirective(parameters.parseResult.code) + `
#undef main
`);
      }
    });
  }
  setPartIndex(builder, ...partIndexExpressions) {
    let s = `
void setPartIndex(${partIndexExpressions.map((_, i) => `highp uint partIndex${i}`).join()}) {
  highp uint pickID = uPickID;
  highp uint pickBaseOffset = getPickBaseOffset();
${partIndexExpressions.map((_, i) => `highp uint pickOffset${i} = pickBaseOffset + partIndex${i};`).join("\n")}
`;
    if (partIndexExpressions.length === 0) {
      s += `
  highp uint pickOffset0 = pickBaseOffset;
`;
    }
    s += `
  vPickID = pickID + pickOffset0;
  highp uint selectedIndex = uSelectedIndex;
if (selectedIndex == pickBaseOffset${partIndexExpressions.map((_, i) => ` || selectedIndex == pickOffset${i}`).join("")}) {
    vColor = vec4(mix(vColor.rgb, vec3(1.0, 1.0, 1.0), 0.75), vColor.a);
  }
}
`;
    builder.addVertexCode(s);
    return `setPartIndex(${partIndexExpressions.join()})`;
  }
  get invokeUserMain() {
    return `
ng_discardValue = false;
userMain();
if (ng_discardValue) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
`;
  }
  getCrossSectionFadeFactor() {
    if (this.targetIsSliceView) {
      return `(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))`;
    } else {
      return `(1.0)`;
    }
  }
  enable(shaderGetter, context, callback) {
    var _shaderGetter = shaderGetter(context.renderContext.emitter);
    const shader = _shaderGetter.shader, parameters = _shaderGetter.parameters;
    if (shader === null) return;
    shader.bind();
    const gl = this.gl;
    const renderContext = context.renderContext;
    const annotationLayer = context.annotationLayer;
    setControlsInShader(gl, shader, this.shaderControlState, parameters.parseResult.controls);
    gl.uniform3fv(shader.uniform("uSubspaceMatrix"), context.subspaceMatrix);
    gl.uniform1fv(shader.uniform("uModelClipBounds"), context.modelClipBounds);
    gl.uniformMatrix4fv(shader.uniform("uModelViewProjection"), false, context.modelViewProjectionMatrix);
    if (renderContext.emitPickID) {
      gl.uniform1ui(shader.uniform("uPickID"), context.basePickId);
    }
    if (renderContext.emitColor) {
      const color2 = annotationLayer.state.displayState.color.value;
      gl.uniform3f(shader.uniform("uColor"), color2[0], color2[1], color2[2]);
      gl.uniform1ui(shader.uniform("uSelectedIndex"), context.selectedIndex);
    }
    const binder = shader.vertexShaderInputBinders["properties"];
    binder.enable(1);
    gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, context.buffer.buffer);
    binder.bind(
      /*stride=*/
      context.count,
      context.bufferOffset
    );
    callback(shader);
    binder.disable();
  }
}
const annotationTypeRenderHandlers = new _Map();
function registerAnnotationTypeRenderHandler(type, handler) {
  annotationTypeRenderHandlers.set(type, handler);
}
function getAnnotationTypeRenderHandler(type) {
  return annotationTypeRenderHandlers.get(type);
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
class Chunk {
  constructor(source) {
    this.source = source;
    this.state = ChunkState.SYSTEM_MEMORY;
  }
  get gl() {
    return this.source.gl;
  }
  copyToGPU(_gl) {
    this.state = ChunkState.GPU_MEMORY;
  }
  freeGPUMemory(_gl) {
    this.state = ChunkState.SYSTEM_MEMORY;
  }
}
function validateLimitValue(x) {
  if (typeof x !== "number" || x < 0) {
    throw new Error(`Expected non-negative number as limit, but received: ${_JSON$stringify(x)}`);
  }
  return x;
}
class CapacitySpecification {
  constructor({ defaultItemLimit = Number.POSITIVE_INFINITY, defaultSizeLimit = Number.POSITIVE_INFINITY } = {}) {
    this.sizeLimit = new TrackableValue(defaultSizeLimit, validateLimitValue);
    this.itemLimit = new TrackableValue(defaultItemLimit, validateLimitValue);
  }
}
let ChunkQueueManager = class ChunkQueueManager2 extends SharedObject {
  constructor(rpc, gl, frameNumberCounter, capacities) {
    super();
    this.gl = gl;
    this.frameNumberCounter = frameNumberCounter;
    this.capacities = capacities;
    this.visibleChunksChanged = new NullarySignal();
    this.pendingChunkUpdates = null;
    this.pendingChunkUpdatesTail = null;
    this.chunkUpdateDeadline = null;
    this.chunkUpdateDelay = 30;
    this.enablePrefetch = new TrackableBoolean(true, true);
    const makeCapacityCounterparts = (capacity) => {
      return {
        itemLimit: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, capacity.itemLimit)).rpcId,
        sizeLimit: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, capacity.sizeLimit)).rpcId
      };
    };
    this.initializeCounterpart(rpc, {
      "gpuMemoryCapacity": makeCapacityCounterparts(capacities.gpuMemory),
      "systemMemoryCapacity": makeCapacityCounterparts(capacities.systemMemory),
      "downloadCapacity": makeCapacityCounterparts(capacities.download),
      "computeCapacity": makeCapacityCounterparts(capacities.compute),
      "enablePrefetch": this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.enablePrefetch)).rpcId
    });
  }
  scheduleChunkUpdate() {
    let deadline = this.chunkUpdateDeadline;
    let delay;
    if (deadline === null || Date.now() < deadline) {
      delay = 0;
    } else {
      delay = this.chunkUpdateDelay;
    }
    setTimeout(this.processPendingChunkUpdates.bind(this), delay);
  }
  processPendingChunkUpdates(flush = false) {
    let deadline = this.chunkUpdateDeadline;
    if (!flush && deadline === null) {
      deadline = Date.now() + 30;
    }
    let visibleChunksChanged = false;
    let numUpdates = 0;
    while (true) {
      if (!flush && Date.now() > deadline) {
        this.chunkUpdateDeadline = null;
        setTimeout(() => this.processPendingChunkUpdates(), this.chunkUpdateDelay);
        break;
      }
      let update = this.pendingChunkUpdates;
      if (update == null) break;
      if (this.applyChunkUpdate(update)) {
        visibleChunksChanged = true;
      }
      ++numUpdates;
      let nextUpdate = this.pendingChunkUpdates = update.nextUpdate;
      if (nextUpdate == null) {
        this.pendingChunkUpdatesTail = null;
        break;
      }
    }
    if (visibleChunksChanged) {
      this.visibleChunksChanged.dispatch();
    }
    return numUpdates;
  }
  handleFetch_(source, update) {
    var _update$promise = update["promise"];
    const resolve = _update$promise.resolve, reject = _update$promise.reject, cancellationToken = _update$promise.cancellationToken;
    if (cancellationToken.isCanceled) {
      reject(CANCELED);
      return;
    }
    const key = update["key"];
    const chunk = source.chunks.get(key);
    if (!chunk) {
      reject(new Error(`No chunk found at ${key} for source ${source.constructor.name}`));
      return;
    }
    const data = chunk["data"];
    if (!data) {
      reject(new Error(`At ${key} for source ${source.constructor.name}: chunk has no data`));
      return;
    }
    resolve({ value: data });
  }
  applyChunkUpdate(update) {
    let visibleChunksChanged = false;
    let rpc = this.rpc;
    const source = rpc.get(update["source"]);
    if (update["promise"] !== void 0) {
      this.handleFetch_(source, update);
    } else if (update["id"] === void 0) {
      for (const chunkKey of source.chunks.keys()) {
        source.deleteChunk(chunkKey);
      }
      visibleChunksChanged = true;
    } else {
      let newState = update["state"];
      if (newState === ChunkState.EXPIRED) {
        source.deleteChunk(update["id"]);
      } else {
        let chunk;
        let key = update["id"];
        if (update["new"]) {
          chunk = source.getChunk(update);
          source.addChunk(key, chunk);
        } else {
          chunk = source.chunks.get(key);
        }
        let oldState = chunk.state;
        if (newState !== oldState) {
          switch (newState) {
            case ChunkState.GPU_MEMORY:
              chunk.copyToGPU(this.gl);
              visibleChunksChanged = true;
              break;
            case ChunkState.SYSTEM_MEMORY:
              chunk.freeGPUMemory(this.gl);
              break;
            default:
              throw new Error(`INTERNAL ERROR: Invalid chunk state: ${ChunkState[newState]}`);
          }
        }
      }
    }
    return visibleChunksChanged;
  }
  flushPendingChunkUpdates() {
    return this.processPendingChunkUpdates(true);
  }
  async getStatistics() {
    const rpc = this.rpc;
    const rawData = await rpc.promiseInvoke(REQUEST_CHUNK_STATISTICS_RPC_ID, { queue: this.rpcId });
    const data = new _Map();
    for (const _ref of rawData) {
      var _ref2 = _slicedToArray(_ref, 2);
      const id = _ref2[0];
      const statistics = _ref2[1];
      const source = rpc.get(id);
      if (source === void 0) continue;
      data.set(source, statistics);
    }
    return data;
  }
};
ChunkQueueManager = __decorate$8([registerSharedObjectOwner(CHUNK_QUEUE_MANAGER_RPC_ID)], ChunkQueueManager);
function updateChunk(rpc, x) {
  let source = rpc.get(x["source"]);
  let queueManager = source.chunkManager.chunkQueueManager;
  if (source.immediateChunkUpdates) {
    if (queueManager.applyChunkUpdate(x)) {
      queueManager.visibleChunksChanged.dispatch();
    }
    return;
  }
  let pendingTail = queueManager.pendingChunkUpdatesTail;
  if (pendingTail == null) {
    queueManager.pendingChunkUpdates = x;
    queueManager.pendingChunkUpdatesTail = x;
    queueManager.scheduleChunkUpdate();
  } else {
    pendingTail.nextUpdate = x;
    queueManager.pendingChunkUpdatesTail = x;
  }
}
registerRPC("Chunk.update", function(x) {
  updateChunk(this, x);
});
registerPromiseRPC("Chunk.retrieve", function(x, cancellationToken) {
  return new _Promise((resolve, reject) => {
    x["promise"] = { resolve, reject, cancellationToken };
    updateChunk(this, x);
  });
});
registerRPC(CHUNK_LAYER_STATISTICS_RPC_ID, function(x) {
  const chunkManager = this.get(x.id);
  for (const stats of chunkManager.prevStatisticsLayers) {
    stats.numVisibleChunksNeeded = 0;
    stats.numVisibleChunksAvailable = 0;
    stats.numPrefetchChunksNeeded = 0;
    stats.numPrefetchChunksAvailable = 0;
  }
  chunkManager.prevStatisticsLayers.length = 0;
  for (const layerUpdate of x.layers) {
    const layer = this.get(layerUpdate.id);
    if (layer === void 0) continue;
    const stats = layer.layerChunkProgressInfo;
    stats.numVisibleChunksAvailable = layerUpdate.numVisibleChunksAvailable;
    stats.numVisibleChunksNeeded = layerUpdate.numVisibleChunksNeeded;
    stats.numPrefetchChunksAvailable = layerUpdate.numPrefetchChunksAvailable;
    stats.numPrefetchChunksNeeded = layerUpdate.numPrefetchChunksNeeded;
    chunkManager.prevStatisticsLayers.push(stats);
  }
  chunkManager.layerChunkStatisticsUpdated.dispatch();
});
let ChunkManager = class ChunkManager2 extends SharedObject {
  constructor(chunkQueueManager) {
    super();
    this.chunkQueueManager = chunkQueueManager;
    this.memoize = new StringMemoize();
    this.prevStatisticsLayers = [];
    this.layerChunkStatisticsUpdated = new NullarySignal();
    this.registerDisposer(chunkQueueManager.addRef());
    this.initializeCounterpart(chunkQueueManager.rpc, { "chunkQueueManager": chunkQueueManager.rpcId });
  }
  get gl() {
    return this.chunkQueueManager.gl;
  }
  getChunkSource(constructorFunction, options) {
    const keyObject = constructorFunction.encodeOptions(options);
    keyObject["constructorId"] = getObjectId(constructorFunction);
    const key = stableStringify(keyObject);
    return this.memoize.get(key, () => {
      const newSource = new constructorFunction(this, options);
      newSource.initializeCounterpart(this.rpc, {});
      newSource.key = keyObject;
      return newSource;
    });
  }
};
ChunkManager = __decorate$8([registerSharedObjectOwner(CHUNK_MANAGER_RPC_ID)], ChunkManager);
class ChunkSource extends SharedObject {
  constructor(chunkManager, _options = {}) {
    super();
    this.chunkManager = chunkManager;
    this.chunks = new _Map();
    this.immediateChunkUpdates = false;
  }
  initializeCounterpart(rpc, options) {
    options["chunkManager"] = this.chunkManager.rpcId;
    super.initializeCounterpart(rpc, options);
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  deleteChunk(key) {
    const chunk = this.chunks.get(key);
    if (chunk.state === ChunkState.GPU_MEMORY) {
      chunk.freeGPUMemory(this.gl);
    }
    this.chunks.delete(key);
  }
  addChunk(key, chunk) {
    this.chunks.set(key, chunk);
  }
  /**
   * Default implementation for use with backendOnly chunk sources.
   */
  getChunk(_x) {
    throw new Error("Not implemented.");
  }
  /**
   * Invalidates the chunk cache.  Operates asynchronously.
   */
  invalidateCache() {
    this.rpc.invoke(CHUNK_SOURCE_INVALIDATE_RPC_ID, { "id": this.rpcId });
  }
  static encodeOptions(_options) {
    return {};
  }
}
function WithParameters(Base2, parametersConstructor) {
  let C = class C extends Base2 {
    constructor(...args) {
      super(...args);
      const options = args[1];
      this.parameters = options.parameters;
    }
    initializeCounterpart(rpc, options) {
      options["parameters"] = this.parameters;
      super.initializeCounterpart(rpc, options);
    }
    static encodeOptions(options) {
      return _Object$assign({ parameters: options.parameters }, super.encodeOptions(options));
    }
  };
  C = __decorate$8([registerSharedObjectOwner(parametersConstructor.RPC_ID)], C);
  return C;
}
class ChunkRenderLayerFrontend extends SharedObject {
  constructor(layerChunkProgressInfo) {
    super();
    this.layerChunkProgressInfo = layerChunkProgressInfo;
  }
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VisibleSegmentEquivalencePolicy;
(function(VisibleSegmentEquivalencePolicy2) {
  VisibleSegmentEquivalencePolicy2[VisibleSegmentEquivalencePolicy2["MIN_REPRESENTATIVE"] = 0] = "MIN_REPRESENTATIVE";
  VisibleSegmentEquivalencePolicy2[VisibleSegmentEquivalencePolicy2["MAX_REPRESENTATIVE"] = 1] = "MAX_REPRESENTATIVE";
  VisibleSegmentEquivalencePolicy2[VisibleSegmentEquivalencePolicy2["REPRESENTATIVE_EXCLUDED"] = 2] = "REPRESENTATIVE_EXCLUDED";
  VisibleSegmentEquivalencePolicy2[VisibleSegmentEquivalencePolicy2["NONREPRESENTATIVE_EXCLUDED"] = 4] = "NONREPRESENTATIVE_EXCLUDED";
})(VisibleSegmentEquivalencePolicy || (VisibleSegmentEquivalencePolicy = {}));
class SegmentationGraphSource {
}
class SegmentationGraphSourceConnection extends RefCounted {
  constructor(graph, segmentsState, transform) {
    super();
    this.graph = graph;
    this.segmentsState = segmentsState;
    this.transform = transform;
  }
  createRenderLayers(chunkManager, displayState, localPosition) {
    return [];
  }
}
function isBaseSegmentId(segmentId) {
  return segmentId.high >>> 31 ? false : true;
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VISIBLE_SEGMENTS_STATE_PROPERTIES = ["visibleSegments", "segmentEquivalences", "temporaryVisibleSegments", "temporarySegmentEquivalences", "useTemporaryVisibleSegments", "useTemporarySegmentEquivalences"];
function onVisibleSegmentsStateChanged(context, state, callback) {
  context.registerDisposer(state.visibleSegments.changed.add(callback));
  context.registerDisposer(state.segmentEquivalences.changed.add(callback));
}
function onTemporaryVisibleSegmentsStateChanged(context, state, callback) {
  context.registerDisposer(state.temporaryVisibleSegments.changed.add(callback));
  context.registerDisposer(state.temporarySegmentEquivalences.changed.add(callback));
  context.registerDisposer(state.useTemporaryVisibleSegments.changed.add(callback));
  context.registerDisposer(state.useTemporarySegmentEquivalences.changed.add(callback));
}
function getObjectKey(objectId) {
  return `${objectId.low},${objectId.high}`;
}
function isHighBitSegment(segmentId) {
  return segmentId.high >>> 31 ? true : false;
}
function getVisibleSegments(state) {
  return state.useTemporaryVisibleSegments.value ? state.temporaryVisibleSegments : state.visibleSegments;
}
function getSegmentEquivalences(state) {
  return state.useTemporarySegmentEquivalences.value ? state.temporarySegmentEquivalences : state.segmentEquivalences;
}
function forEachVisibleSegment(state, callback) {
  const visibleSegments = getVisibleSegments(state);
  const segmentEquivalences = getSegmentEquivalences(state);
  if (segmentEquivalences.disjointSets) {
    const equivalencePolicy = segmentEquivalences.disjointSets.visibleSegmentEquivalencePolicy.value;
    for (let rootObjectId of visibleSegments.unsafeKeys()) {
      if (equivalencePolicy & VisibleSegmentEquivalencePolicy.NONREPRESENTATIVE_EXCLUDED) {
        const rootObjectId2 = segmentEquivalences.get(rootObjectId);
        callback(rootObjectId, rootObjectId2);
      } else {
        if (segmentEquivalences.disjointSets === void 0 || !segmentEquivalences.disjointSets.isMinElement(rootObjectId)) {
          continue;
        }
        for (let objectId of segmentEquivalences.setElements(rootObjectId)) {
          if (equivalencePolicy & VisibleSegmentEquivalencePolicy.REPRESENTATIVE_EXCLUDED && equivalencePolicy & VisibleSegmentEquivalencePolicy.MAX_REPRESENTATIVE && isHighBitSegment(objectId)) {
            continue;
          }
          callback(objectId, rootObjectId);
        }
      }
    }
  }
}
const numRenderScaleHistogramBins = 40;
const renderScaleHistogramBinSize = 0.5;
const renderScaleHistogramOrigin = -4;
function getRenderScaleHistogramOffset(renderScale) {
  return (_Math$log$1(renderScale) - renderScaleHistogramOrigin) / renderScaleHistogramBinSize;
}
function getRenderScaleFromHistogramOffset(offset) {
  return 2 ** (offset * renderScaleHistogramBinSize + renderScaleHistogramOrigin);
}
function trackableRenderScaleTarget(initialValue) {
  return new TrackableValue(initialValue, verifyFinitePositiveFloat);
}
class RenderScaleHistogram {
  constructor() {
    this.visibility = new VisibilityPriorityAggregator();
    this.changed = new NullarySignal();
    this.frameNumber = -1;
    this.spatialScales = new _Map();
    this.numHistogramRows = 1;
    this.value = new Uint32Array(numRenderScaleHistogramBins * this.numHistogramRows * 2);
  }
  begin(frameNumber) {
    if (frameNumber !== this.frameNumber) {
      this.value.fill(0);
      this.frameNumber = frameNumber;
      this.spatialScales.clear();
      this.changed.dispatch();
    }
  }
  /**
   * Adds a count to the histogram.
   *
   * @param spatialScale Spatial resolution of data in nanometers.
   * @param renderScale Rendered scale of data in screen pixels.
   * @param presentCount Number of present chunks.
   * @param notPresentCount Number of desired but not-present chunks.
   */
  add(spatialScale, renderScale, presentCount, notPresentCount) {
    let spatialScales = this.spatialScales, numHistogramRows = this.numHistogramRows, value = this.value;
    let spatialScaleIndex = spatialScales.get(spatialScale);
    if (spatialScaleIndex === void 0) {
      spatialScaleIndex = spatialScales.size;
      spatialScales.set(spatialScale, spatialScaleIndex);
    }
    if (spatialScaleIndex >= numHistogramRows) {
      this.numHistogramRows = numHistogramRows *= 2;
      const newValue = new Uint32Array(numHistogramRows * numRenderScaleHistogramBins * 2);
      newValue.set(value);
      this.value = value = newValue;
    }
    const index2 = spatialScaleIndex * numRenderScaleHistogramBins * 2 + Math.min(Math.max(0, Math.round(getRenderScaleHistogramOffset(renderScale))), numRenderScaleHistogramBins - 1);
    value[index2] += presentCount;
    value[index2 + numRenderScaleHistogramBins] += notPresentCount;
  }
}
class SliceViewRenderLayer extends RenderLayer {
  constructor(chunkManager, multiscaleSource, options) {
    var _a;
    super();
    this.chunkManager = chunkManager;
    this.multiscaleSource = multiscaleSource;
    this.rpcId = null;
    this.rpcTransfer = {};
    this.visibleSources = new _Map();
    this.visibleSourcesList_ = [];
    var _options$renderScaleT = options.renderScaleTarget;
    const renderScaleTarget = _options$renderScaleT === void 0 ? trackableRenderScaleTarget(1) : _options$renderScaleT;
    this.renderScaleTarget = renderScaleTarget;
    this.renderScaleHistogram = options.renderScaleHistogram;
    this.transform = options.transform;
    this.localPosition = options.localPosition;
    this.rpcTransfer = options.rpcTransfer || {};
    this.dataHistogramSpecifications = this.registerDisposer((_a = options.dataHistogramSpecifications) !== null && _a !== void 0 ? _a : new HistogramSpecifications(constantWatchableValue([]), constantWatchableValue([])));
    this.registerDisposer(this.dataHistogramSpecifications.visibility.changed.add(this.redrawNeeded.dispatch));
  }
  getDataHistogramCount() {
    const dataHistogramSpecifications = this.dataHistogramSpecifications;
    if (!dataHistogramSpecifications.visibility.visible) return 0;
    return dataHistogramSpecifications.bounds.value.length;
  }
  getSources(options) {
    return this.multiscaleSource.getSources(options);
  }
  addSource(source, chunkTransform) {
    const visibleSources = this.visibleSources;
    const info = visibleSources.get(source);
    if (info !== void 0) {
      ++info.refCount;
      info.chunkTransform = chunkTransform;
    } else {
      visibleSources.set(source, { source, refCount: 1, chunkTransform });
      this.visibleSourcesList_.length = 0;
    }
  }
  removeSource(source) {
    const visibleSources = this.visibleSources;
    const info = visibleSources.get(source);
    if (info.refCount !== 1) {
      --info.refCount;
    } else {
      visibleSources.delete(source);
      this.visibleSourcesList_.length = 0;
    }
  }
  get visibleSourcesList() {
    const visibleSources = this.visibleSources, visibleSourcesList_ = this.visibleSourcesList_;
    if (visibleSourcesList_.length === 0 && visibleSources.size !== 0) {
      for (const info of visibleSources.values()) {
        visibleSourcesList_.push(info);
      }
      visibleSourcesList_.sort((a, b) => {
        return a.chunkTransform.chunkToLayerTransformDet - b.chunkTransform.chunkToLayerTransformDet;
      });
    }
    return visibleSourcesList_;
  }
  initializeCounterpart() {
    const sharedObject = this.registerDisposer(new ChunkRenderLayerFrontend(this.layerChunkProgressInfo));
    const rpc = this.chunkManager.rpc;
    sharedObject.RPC_TYPE_ID = this.RPC_TYPE_ID;
    sharedObject.initializeCounterpart(rpc, _Object$assign({ localPosition: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.localPosition)).rpcId, renderScaleTarget: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.renderScaleTarget)).rpcId }, this.rpcTransfer));
    this.rpcId = sharedObject.rpcId;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  setGLBlendMode(gl, renderLayerNum) {
    if (renderLayerNum > 0) {
      gl.enable(WebGL2RenderingContext.BLEND);
      gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
    } else {
      gl.disable(WebGL2RenderingContext.BLEND);
    }
  }
  filterVisibleSources(sliceView, sources) {
    return filterVisibleSources(sliceView, this, sources);
  }
}
SliceViewRenderLayer.prototype.RPC_TYPE_ID = SLICEVIEW_RENDERLAYER_RPC_ID;
class SliceViewPanelRenderLayer extends VisibilityTrackedRenderLayer {
  draw(renderContext, attachment) {
  }
  isReady(renderContext, attachment) {
    return true;
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
class FrontendSliceViewBase extends SliceViewBase {
}
const Base$4 = withSharedVisibility(FrontendSliceViewBase);
function serializeTransformedSource(tsource) {
  return {
    source: tsource.source.addCounterpartRef(),
    effectiveVoxelSize: tsource.effectiveVoxelSize,
    layerRank: tsource.layerRank,
    nonDisplayLowerClipBound: tsource.nonDisplayLowerClipBound,
    nonDisplayUpperClipBound: tsource.nonDisplayUpperClipBound,
    lowerClipBound: tsource.lowerClipBound,
    upperClipBound: tsource.upperClipBound,
    lowerClipDisplayBound: tsource.lowerClipDisplayBound,
    upperClipDisplayBound: tsource.upperClipDisplayBound,
    chunkDisplayDimensionIndices: tsource.chunkDisplayDimensionIndices,
    lowerChunkDisplayBound: tsource.lowerChunkDisplayBound,
    upperChunkDisplayBound: tsource.upperChunkDisplayBound,
    fixedLayerToChunkTransform: tsource.fixedLayerToChunkTransform,
    combinedGlobalLocalToChunkTransform: tsource.combinedGlobalLocalToChunkTransform,
    chunkLayout: tsource.chunkLayout.toObject()
  };
}
function serializeAllTransformedSources(allSources) {
  return allSources.map((scales) => scales.map(serializeTransformedSource));
}
function disposeTransformedSources(layer, allSources) {
  for (const scales of allSources) {
    for (const _ref of scales) {
      const source = _ref.source;
      layer.removeSource(source);
      source.dispose();
    }
  }
}
let SliceView = class SliceView2 extends Base$4 {
  constructor(chunkManager, layerManager, navigationState, wireFrame) {
    super(new DerivedProjectionParameters({
      parametersConstructor: SliceViewProjectionParameters,
      navigationState,
      update: (out, navigationState2) => {
        const invViewMatrix = out.invViewMatrix, centerDataPosition = out.centerDataPosition;
        navigationState2.toMat4(invViewMatrix);
        var _out$displayDimension = out.displayDimensionRenderInfo;
        const canonicalVoxelFactors = _out$displayDimension.canonicalVoxelFactors, voxelPhysicalScales = _out$displayDimension.voxelPhysicalScales;
        for (let i = 0; i < 3; ++i) {
          centerDataPosition[i] = invViewMatrix[12 + i];
        }
        const logicalWidth = out.logicalWidth, logicalHeight = out.logicalHeight, projectionMat = out.projectionMat, viewportNormalInGlobalCoordinates = out.viewportNormalInGlobalCoordinates, viewportNormalInCanonicalCoordinates = out.viewportNormalInCanonicalCoordinates;
        const relativeDepthRange = navigationState2.relativeDepthRange;
        ortho(projectionMat, -logicalWidth / 2, logicalWidth / 2, logicalHeight / 2, -logicalHeight / 2, -relativeDepthRange, relativeDepthRange);
        applyRenderViewportToProjectionMatrix(out, projectionMat);
        updateProjectionParametersFromInverseViewAndProjection(out);
        const viewMatrix = out.viewMatrix;
        for (let i = 0; i < 3; ++i) {
          const x = viewportNormalInGlobalCoordinates[i] = viewMatrix[i * 4 + 2];
          viewportNormalInCanonicalCoordinates[i] = x / canonicalVoxelFactors[i];
        }
        normalize$2(viewportNormalInGlobalCoordinates, viewportNormalInGlobalCoordinates);
        normalize$2(viewportNormalInCanonicalCoordinates, viewportNormalInCanonicalCoordinates);
        let newPixelSize = 0;
        for (let i = 0; i < 3; ++i) {
          const s = voxelPhysicalScales[i];
          const x = invViewMatrix[i];
          newPixelSize += (s * x) ** 2;
        }
        newPixelSize = Math.sqrt(newPixelSize);
        out.pixelSize = newPixelSize;
      }
    }));
    this.chunkManager = chunkManager;
    this.layerManager = layerManager;
    this.navigationState = navigationState;
    this.wireFrame = wireFrame;
    this.gl = this.chunkManager.gl;
    this.viewChanged = new NullarySignal();
    this.renderingStale = true;
    this.visibleChunksStale = true;
    this.visibleLayerList = new Array();
    this.offscreenFramebuffer = this.registerDisposer(new FramebufferConfiguration(this.gl, {
      colorBuffers: makeTextureBuffers(this.gl, 1),
      depthBuffer: new DepthTextureBuffer(this.gl)
    }));
    this.histogramInputTextures = [];
    this.offscreenFramebuffersWithHistograms = [this.offscreenFramebuffer];
    this.histogramGenerator = TextureHistogramGenerator.get(this.gl);
    this.updateVisibleLayers = this.registerCancellable(debounce(() => {
      this.updateVisibleLayersNow();
    }, 0));
    this.registerDisposer(navigationState);
    this.registerDisposer(this.projectionParameters);
    this.registerDisposer(this.projectionParameters.changed.add((oldValue, newValue) => {
      if (oldValue.displayDimensionRenderInfo !== newValue.displayDimensionRenderInfo) {
        this.updateVisibleLayers();
      }
    }));
    const rpc = this.chunkManager.rpc;
    const sharedProjectionParameters = this.sharedProjectionParameters = this.registerDisposer(new SharedProjectionParameters(rpc, this.projectionParameters));
    this.initializeCounterpart(rpc, {
      chunkManager: chunkManager.rpcId,
      projectionParameters: sharedProjectionParameters.rpcId
    });
    this.registerDisposer(layerManager.layersChanged.add(() => {
      this.updateVisibleLayers();
    }));
    this.wireFrame.changed.add(this.viewChanged.dispatch);
    this.viewChanged.add(() => {
      this.renderingStale = true;
    });
    this.registerDisposer(chunkManager.chunkQueueManager.visibleChunksChanged.add(this.viewChanged.dispatch));
    this.updateVisibleLayers();
  }
  get displayDimensionRenderInfo() {
    return this.navigationState.displayDimensionRenderInfo;
  }
  computeHistograms(count, histogramSpecifications) {
    this.histogramGenerator.compute(count, this.offscreenFramebuffer.depthBuffer.texture, this.histogramInputTextures, histogramSpecifications, this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
  }
  flushBackendProjectionParameters() {
    this.sharedProjectionParameters.flush();
  }
  forEachVisibleChunk(tsource, chunkLayout, callback) {
    forEachPlaneIntersectingVolumetricChunk(this.projectionParameters.value, tsource.renderLayer.localPosition.value, tsource, chunkLayout, () => {
      callback(tsource.curPositionInChunks.join());
    });
  }
  isReady() {
    if (!this.navigationState.valid) {
      return false;
    }
    this.updateVisibleLayers.flush();
    this.updateVisibleSources();
    let numValidChunks = 0;
    let totalChunks = 0;
    for (const _ref2 of this.visibleLayers.values()) {
      const visibleSources = _ref2.visibleSources;
      for (const tsource of visibleSources) {
        const chunkLayout = getNormalizedChunkLayout(this.projectionParameters.value, tsource.chunkLayout);
        const source = tsource.source;
        const chunks = source.chunks;
        this.forEachVisibleChunk(tsource, chunkLayout, (key) => {
          const chunk = chunks.get(key);
          ++totalChunks;
          if (chunk && chunk.state === ChunkState.GPU_MEMORY) {
            ++numValidChunks;
          }
        });
      }
    }
    return numValidChunks === totalChunks;
  }
  invalidateVisibleSources() {
    super.invalidateVisibleSources();
    this.viewChanged.dispatch();
  }
  bindVisibleRenderLayer(renderLayer, disposers) {
    disposers.push(renderLayer.localPosition.changed.add(() => this.invalidateVisibleChunks()));
    disposers.push(renderLayer.redrawNeeded.add(this.viewChanged.dispatch));
    disposers.push(renderLayer.transform.changed.add(this.updateVisibleLayers));
    disposers.push(renderLayer.renderScaleTarget.changed.add(() => this.invalidateVisibleSources()));
    const renderScaleHistogram = renderLayer.renderScaleHistogram;
    if (renderScaleHistogram !== void 0) {
      disposers.push(renderScaleHistogram.visibility.add(this.visibility));
    }
    disposers.push(renderLayer.dataHistogramSpecifications.producerVisibility.add(this.visibility));
  }
  updateVisibleLayersNow() {
    if (this.wasDisposed) {
      return false;
    }
    if (!this.navigationState.valid) return false;
    const curUpdateGeneration = Date.now();
    const visibleLayers = this.visibleLayers, visibleLayerList = this.visibleLayerList;
    const displayDimensionRenderInfo = this.projectionParameters.value.displayDimensionRenderInfo;
    let rpc = this.rpc;
    let rpcMessage = { "id": this.rpcId };
    let changed = false;
    visibleLayerList.length = 0;
    for (let renderLayer of this.layerManager.readyRenderLayers()) {
      if (renderLayer instanceof SliceViewRenderLayer) {
        visibleLayerList.push(renderLayer);
        let layerInfo = visibleLayers.get(renderLayer);
        if (layerInfo === void 0) {
          const disposers = [];
          const messages = new MessageList();
          layerInfo = {
            messages,
            allSources: this.getTransformedSources(renderLayer, messages),
            transformGeneration: renderLayer.transform.changed.count,
            visibleSources: [],
            disposers,
            lastSeenGeneration: curUpdateGeneration,
            displayDimensionRenderInfo
          };
          disposers.push(renderLayer.messages.addChild(layerInfo.messages));
          visibleLayers.set(renderLayer.addRef(), layerInfo);
          this.bindVisibleRenderLayer(renderLayer, disposers);
        } else {
          layerInfo.lastSeenGeneration = curUpdateGeneration;
          const curTransformGeneration = renderLayer.transform.changed.count;
          if (layerInfo.transformGeneration === curTransformGeneration && layerInfo.displayDimensionRenderInfo === displayDimensionRenderInfo) {
            continue;
          }
          const allSources = layerInfo.allSources;
          layerInfo.allSources = this.getTransformedSources(renderLayer, layerInfo.messages);
          disposeTransformedSources(renderLayer, allSources);
          layerInfo.visibleSources.length = 0;
          layerInfo.displayDimensionRenderInfo = displayDimensionRenderInfo;
          layerInfo.transformGeneration = curTransformGeneration;
        }
        rpcMessage["layerId"] = renderLayer.rpcId;
        rpcMessage["sources"] = serializeAllTransformedSources(layerInfo.allSources);
        this.flushBackendProjectionParameters();
        rpc.invoke(SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID, rpcMessage);
        changed = true;
      }
    }
    for (const _ref3 of visibleLayers) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const renderLayer = _ref4[0];
      const layerInfo = _ref4[1];
      if (layerInfo.lastSeenGeneration === curUpdateGeneration) continue;
      rpcMessage["layerId"] = renderLayer.rpcId;
      rpc.invoke(SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID, rpcMessage);
      visibleLayers.delete(renderLayer);
      disposeTransformedSources(renderLayer, layerInfo.allSources);
      invokeDisposers(layerInfo.disposers);
      renderLayer.dispose();
      changed = true;
    }
    if (changed) {
      this.visibleSourcesStale = true;
    }
    this.viewChanged.dispatch();
    return changed;
  }
  invalidateVisibleChunks() {
    super.invalidateVisibleChunks();
    this.viewChanged.dispatch();
  }
  get valid() {
    return this.navigationState.valid;
  }
  getOffscreenFramebufferWithHistograms(count) {
    const offscreenFramebuffersWithHistograms = this.offscreenFramebuffersWithHistograms;
    let framebuffer = offscreenFramebuffersWithHistograms[count];
    if (framebuffer === void 0) {
      const gl = this.gl, histogramInputTextures = this.histogramInputTextures, offscreenFramebuffer = this.offscreenFramebuffer;
      if (histogramInputTextures.length < count) {
        histogramInputTextures.push(...makeTextureBuffers(gl, count - histogramInputTextures.length, WebGL2RenderingContext.R8, WebGL2RenderingContext.RED));
      }
      let colorBuffers = [offscreenFramebuffer.colorBuffers[0].addRef()];
      for (let i = 0; i < count; ++i) {
        colorBuffers.push(histogramInputTextures[i].addRef());
      }
      framebuffer = this.registerDisposer(new FramebufferConfiguration(gl, { colorBuffers, depthBuffer: offscreenFramebuffer.depthBuffer.addRef() }));
      offscreenFramebuffersWithHistograms[count] = framebuffer;
    }
    return framebuffer;
  }
  updateRendering() {
    const projectionParameters = this.projectionParameters.value;
    const width = projectionParameters.width, height = projectionParameters.height;
    if (!this.renderingStale || !this.valid || width === 0 || height === 0) {
      return;
    }
    this.renderingStale = false;
    this.updateVisibleLayers.flush();
    this.updateVisibleSources();
    let gl = this.gl, offscreenFramebuffer = this.offscreenFramebuffer;
    offscreenFramebuffer.bind(width, height);
    gl.disable(gl.SCISSOR_TEST);
    gl.clearColor(0, 0, 0, 0);
    gl.colorMask(true, true, true, true);
    gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
    let renderLayerNum = 0;
    const wireFrame = this.wireFrame.value;
    const renderContext = { sliceView: this, projectionParameters, wireFrame };
    for (let renderLayer of this.visibleLayerList) {
      const histogramCount = wireFrame ? 0 : renderLayer.getDataHistogramCount();
      let framebuffer = this.getOffscreenFramebufferWithHistograms(histogramCount);
      framebuffer.bind(width, height);
      for (let i = 0; i < histogramCount; ++i) {
        gl.clearBufferfv(WebGL2RenderingContext.COLOR, 1 + i, kZeroVec4);
      }
      gl.enable(WebGL2RenderingContext.DEPTH_TEST);
      gl.depthFunc(WebGL2RenderingContext.LESS);
      gl.clearDepth(1);
      gl.clear(WebGL2RenderingContext.DEPTH_BUFFER_BIT);
      renderLayer.setGLBlendMode(gl, renderLayerNum);
      renderLayer.draw(renderContext);
      ++renderLayerNum;
    }
    gl.disable(WebGL2RenderingContext.BLEND);
    gl.disable(WebGL2RenderingContext.DEPTH_TEST);
    offscreenFramebuffer.unbind();
  }
  disposed() {
    for (const _ref5 of this.visibleLayers) {
      var _ref6 = _slicedToArray(_ref5, 2);
      const renderLayer = _ref6[0];
      const layerInfo = _ref6[1];
      disposeTransformedSources(renderLayer, layerInfo.allSources);
      invokeDisposers(layerInfo.disposers);
      renderLayer.dispose();
    }
    this.visibleLayers.clear();
    this.visibleLayerList.length = 0;
  }
  getTransformedSources(layer, messages) {
    const transformedSources = getVolumetricTransformedSources(this.projectionParameters.value.displayDimensionRenderInfo, layer.transform.value, (options) => layer.getSources(options), messages, layer);
    for (const scales of transformedSources) {
      for (const tsource of scales) {
        layer.addSource(tsource.source, tsource.chunkTransform);
      }
    }
    return transformedSources;
  }
};
SliceView = __decorate$7([registerSharedObjectOwner(SLICEVIEW_RPC_ID)], SliceView);
class SliceViewChunkSource extends ChunkSource {
  constructor(chunkManager, options) {
    super(chunkManager, options);
    this.spec = options.spec;
  }
  static encodeSpec(spec) {
    return {
      chunkDataSize: _Array$from(spec.chunkDataSize),
      lowerVoxelBound: _Array$from(spec.lowerVoxelBound),
      upperVoxelBound: _Array$from(spec.upperVoxelBound)
    };
  }
  static encodeOptions(options) {
    const encoding = super.encodeOptions(options);
    encoding.spec = this.encodeSpec(options.spec);
    return encoding;
  }
  initializeCounterpart(rpc, options) {
    options["spec"] = this.spec;
    super.initializeCounterpart(rpc, options);
  }
}
class SliceViewChunk extends Chunk {
  constructor(source, x) {
    super(source);
    this.chunkGridPosition = x["chunkGridPosition"];
    this.state = ChunkState.SYSTEM_MEMORY;
  }
}
let SliceViewRenderHelper$2 = class SliceViewRenderHelper extends RefCounted {
  constructor(gl, emitter) {
    super();
    this.gl = gl;
    this.copyVertexPositionsBuffer = getSquareCornersBuffer(this.gl);
    this.textureCoordinateAdjustment = new Float32Array(4);
    let builder = new ShaderBuilder(gl);
    builder.addVarying("vec2", "vTexCoord");
    builder.addUniform("sampler2D", "uSampler");
    builder.addInitializer((shader) => {
      gl.uniform1i(shader.uniform("uSampler"), 0);
    });
    builder.addUniform("vec4", "uColorFactor");
    builder.addUniform("vec4", "uBackgroundColor");
    builder.addUniform("mat4", "uProjectionMatrix");
    builder.addUniform("vec4", "uTextureCoordinateAdjustment");
    builder.require(emitter);
    builder.setFragmentMain(`
vec4 sampledColor = texture(uSampler, vTexCoord);
if (sampledColor.a == 0.0) {
  sampledColor = uBackgroundColor;
}
emit(sampledColor * uColorFactor, 0u);
`);
    builder.addAttribute("vec4", "aVertexPosition");
    builder.setVertexMain(`
vTexCoord = uTextureCoordinateAdjustment.xy + 0.5 * (aVertexPosition.xy + 1.0) * uTextureCoordinateAdjustment.zw;
gl_Position = uProjectionMatrix * aVertexPosition;
`);
    this.shader = this.registerDisposer(builder.build());
  }
  draw(texture, projectionMatrix, colorFactor, backgroundColor, xStart, yStart, xEnd, yEnd) {
    let gl = this.gl, shader = this.shader, textureCoordinateAdjustment = this.textureCoordinateAdjustment;
    textureCoordinateAdjustment[0] = xStart;
    textureCoordinateAdjustment[1] = yStart;
    textureCoordinateAdjustment[2] = xEnd - xStart;
    textureCoordinateAdjustment[3] = yEnd - yStart;
    shader.bind();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.disable(WebGL2RenderingContext.BLEND);
    gl.uniformMatrix4fv(shader.uniform("uProjectionMatrix"), false, projectionMatrix);
    gl.uniform4fv(shader.uniform("uColorFactor"), colorFactor);
    gl.uniform4fv(shader.uniform("uBackgroundColor"), backgroundColor);
    gl.uniform4fv(shader.uniform("uTextureCoordinateAdjustment"), textureCoordinateAdjustment);
    let aVertexPosition = shader.attribute("aVertexPosition");
    this.copyVertexPositionsBuffer.bindToVertexAttrib(
      aVertexPosition,
      /*components=*/
      2
    );
    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
    gl.disableVertexAttribArray(aVertexPosition);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }
  static get(gl, emitter) {
    return gl.memoize.get(`sliceview/SliceViewRenderHelper:${getObjectId(emitter)}`, () => new SliceViewRenderHelper(gl, emitter));
  }
};
class MultiscaleSliceViewChunkSource {
  constructor(chunkManager) {
    this.chunkManager = chunkManager;
  }
}
function getVolumetricTransformedSources(displayDimensionRenderInfo, transform, getSources, messages, layer) {
  messages.clearMessages();
  const returnError = (message) => {
    messages.addMessage({
      severity: MessageSeverity.error,
      message
    });
    return [];
  };
  if (transform.error !== void 0) {
    return returnError(transform.error);
  }
  const layerRank = transform.rank;
  const chunkRank = transform.unpaddedRank;
  const displayDimensionIndices = displayDimensionRenderInfo.displayDimensionIndices, displayRank = displayDimensionRenderInfo.displayRank, canonicalVoxelFactors = displayDimensionRenderInfo.canonicalVoxelFactors;
  const layerDisplayDimensionMapping = getLayerDisplayDimensionMapping(transform, displayDimensionIndices);
  const displayToLayerDimensionIndices = layerDisplayDimensionMapping.displayToLayerDimensionIndices;
  const multiscaleToViewTransform = new Float32Array(displayRank * chunkRank);
  const modelToRenderLayerTransform = transform.modelToRenderLayerTransform;
  for (let displayDim = 0; displayDim < displayRank; ++displayDim) {
    const layerDim = displayToLayerDimensionIndices[displayDim];
    if (layerDim === -1) continue;
    const factor = canonicalVoxelFactors[displayDim];
    for (let chunkDim = 0; chunkDim < chunkRank; ++chunkDim) {
      multiscaleToViewTransform[displayRank * chunkDim + displayDim] = modelToRenderLayerTransform[(layerRank + 1) * chunkDim + layerDim] * factor;
    }
  }
  const allSources = getSources({
    displayRank,
    multiscaleToViewTransform,
    modelChannelDimensionIndices: transform.channelToRenderLayerDimensions
  });
  const globalScales = displayDimensionRenderInfo.voxelPhysicalScales;
  try {
    const getTransformedSource = (singleResolutionSource) => {
      const source = singleResolutionSource.chunkSource;
      const spec = source.spec;
      var _singleResolutionSour = singleResolutionSource.lowerClipBound;
      const lowerClipBound = _singleResolutionSour === void 0 ? spec.lowerVoxelBound : _singleResolutionSour;
      var _singleResolutionSour2 = singleResolutionSource.upperClipBound;
      const upperClipBound = _singleResolutionSour2 === void 0 ? spec.upperVoxelBound : _singleResolutionSour2;
      const chunkTransform = getChunkTransformParameters(transform, singleResolutionSource.chunkToMultiscaleTransform);
      const chunkDataSize = spec.chunkDataSize;
      const channelToChunkDimensionIndices = chunkTransform.channelToChunkDimensionIndices;
      const nonDisplayLowerClipBound = new Float32Array(chunkRank);
      const nonDisplayUpperClipBound = new Float32Array(chunkRank);
      nonDisplayLowerClipBound.set(lowerClipBound);
      nonDisplayUpperClipBound.set(upperClipBound);
      const channelRank = channelToChunkDimensionIndices.length;
      const channelSpaceShape = transform.channelSpaceShape;
      for (let channelDim = 0; channelDim < channelRank; ++channelDim) {
        const chunkDim = channelToChunkDimensionIndices[channelDim];
        if (chunkDim === -1) continue;
        const size = channelSpaceShape[channelDim];
        if (chunkDataSize[chunkDim] !== size) {
          throw new Error(`Channel dimension ` + transform.layerDimensionNames[transform.channelToRenderLayerDimensions[channelDim]] + ` has extent ${size} but corresponding chunk dimension has extent ${chunkDataSize[chunkDim]}`);
        }
        nonDisplayLowerClipBound[chunkDim] = Number.NEGATIVE_INFINITY;
        nonDisplayUpperClipBound[chunkDim] = Number.POSITIVE_INFINITY;
      }
      const chunkDisplayTransform = getChunkDisplayTransformParameters(chunkTransform, layerDisplayDimensionMapping);
      const lowerChunkDisplayBound = create$3();
      const upperChunkDisplayBound = create$3();
      const lowerClipDisplayBound = create$3();
      const upperClipDisplayBound = create$3();
      const chunkDisplaySize = create$3();
      const numChunkDisplayDims = chunkDisplayTransform.numChunkDisplayDims, chunkDisplayDimensionIndices = chunkDisplayTransform.chunkDisplayDimensionIndices;
      const combinedGlobalLocalToChunkTransform = chunkTransform.combinedGlobalLocalToChunkTransform, layerRank2 = chunkTransform.layerRank, combinedGlobalLocalRank = chunkTransform.combinedGlobalLocalRank;
      const fixedLayerToChunkTransform = new Float32Array(combinedGlobalLocalToChunkTransform);
      for (let chunkDisplayDimIndex = 0; chunkDisplayDimIndex < numChunkDisplayDims; ++chunkDisplayDimIndex) {
        const chunkDim = chunkDisplayDimensionIndices[chunkDisplayDimIndex];
        for (let i = 0; i <= combinedGlobalLocalRank; ++i) {
          fixedLayerToChunkTransform[chunkDim + i * layerRank2] = 0;
        }
        if (chunkDim < chunkRank) {
          chunkDisplaySize[chunkDisplayDimIndex] = spec.chunkDataSize[chunkDim];
          lowerChunkDisplayBound[chunkDisplayDimIndex] = spec.lowerChunkBound[chunkDim];
          upperChunkDisplayBound[chunkDisplayDimIndex] = spec.upperChunkBound[chunkDim];
          lowerClipDisplayBound[chunkDisplayDimIndex] = lowerClipBound[chunkDim];
          upperClipDisplayBound[chunkDisplayDimIndex] = upperClipBound[chunkDim];
          nonDisplayLowerClipBound[chunkDim] = Number.NEGATIVE_INFINITY;
          nonDisplayUpperClipBound[chunkDim] = Number.POSITIVE_INFINITY;
        } else {
          chunkDisplaySize[chunkDisplayDimIndex] = 1;
          lowerChunkDisplayBound[chunkDisplayDimIndex] = 0;
          upperChunkDisplayBound[chunkDisplayDimIndex] = 1;
          lowerClipDisplayBound[chunkDisplayDimIndex] = 0;
          upperClipDisplayBound[chunkDisplayDimIndex] = 1;
        }
      }
      chunkDisplaySize.fill(1, numChunkDisplayDims);
      lowerChunkDisplayBound.fill(0, numChunkDisplayDims);
      upperChunkDisplayBound.fill(1, numChunkDisplayDims);
      lowerClipDisplayBound.fill(0, numChunkDisplayDims);
      upperClipDisplayBound.fill(1, numChunkDisplayDims);
      const chunkLayout = new ChunkLayout(chunkDisplaySize, chunkDisplayTransform.displaySubspaceModelMatrix, numChunkDisplayDims);
      const effectiveVoxelSize = chunkLayout.localSpatialVectorToGlobal(
        create$3(),
        /*baseVoxelSize=*/
        kOneVec
      );
      for (let i = 0; i < displayRank; ++i) {
        effectiveVoxelSize[i] = Math.abs(effectiveVoxelSize[i] * globalScales[i]);
      }
      effectiveVoxelSize.fill(1, displayRank);
      return {
        layerRank: layerRank2,
        lowerClipBound,
        upperClipBound,
        nonDisplayLowerClipBound,
        nonDisplayUpperClipBound,
        renderLayer: layer,
        source,
        lowerChunkDisplayBound,
        upperChunkDisplayBound,
        lowerClipDisplayBound,
        upperClipDisplayBound,
        effectiveVoxelSize,
        chunkLayout,
        chunkDisplayDimensionIndices,
        fixedLayerToChunkTransform,
        curPositionInChunks: new Float32Array(chunkRank),
        combinedGlobalLocalToChunkTransform: chunkTransform.combinedGlobalLocalToChunkTransform,
        fixedPositionWithinChunk: new Uint32Array(chunkRank),
        chunkTransform,
        chunkDisplayTransform
      };
    };
    return allSources.map((scales) => scales.map((s) => getTransformedSource(s)));
  } catch (e) {
    for (const scales of allSources) {
      for (const _ref7 of scales) {
        const source = _ref7.chunkSource;
        source.dispose();
      }
    }
    const globalDimensionNames = displayDimensionRenderInfo.globalDimensionNames;
    const dimensionDesc = _Array$from(displayDimensionRenderInfo.displayDimensionIndices.filter((i) => i !== -1), (i) => globalDimensionNames[i]).join(", ");
    const message = `Cannot render (${dimensionDesc}) cross section: ${e.message}`;
    return returnError(message);
  }
}
let statusContainer = null;
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_STATUS_DELAY = 200;
class StatusMessage {
  constructor(delay = false) {
    if (statusContainer === null) {
      statusContainer = document.createElement("ul");
      statusContainer.id = "statusContainer";
      const el = document.getElementById("neuroglancer-container");
      if (el) {
        el.appendChild(statusContainer);
      } else {
        document.body.appendChild(statusContainer);
      }
    }
    let element = document.createElement("li");
    this.element = element;
    if (delay === true) {
      delay = DEFAULT_STATUS_DELAY;
    }
    if (delay !== false) {
      this.setVisible(false);
      this.timer = window.setTimeout(this.setVisible.bind(this, true), delay);
    } else {
      this.timer = null;
    }
    statusContainer.appendChild(element);
  }
  dispose() {
    statusContainer.removeChild(this.element);
    this.element = void 0;
    if (this.timer !== null) {
      clearTimeout(this.timer);
    }
  }
  setText(text, makeVisible) {
    this.element.textContent = text;
    if (makeVisible) {
      this.setVisible(true);
    }
  }
  setHTML(text, makeVisible) {
    this.element.innerHTML = text;
    if (makeVisible) {
      this.setVisible(true);
    }
  }
  setVisible(value) {
    if (this.timer !== null) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    this.element.style.display = value ? "block" : "none";
  }
  static forPromise(promise2, options) {
    let status = new StatusMessage(options.delay);
    status.setText(options.initialMessage);
    let dispose = status.dispose.bind(status);
    promise2.then(dispose, (reason) => {
      let msg;
      if (reason instanceof Error) {
        msg = reason.message;
      } else {
        msg = "" + reason;
      }
      var _options$errorPrefix = options.errorPrefix;
      let errorPrefix = _options$errorPrefix === void 0 ? "" : _options$errorPrefix;
      status.setErrorMessage(errorPrefix + msg);
      status.setVisible(true);
    });
    return promise2;
  }
  setErrorMessage(message) {
    this.element.textContent = message + " ";
    let button = document.createElement("button");
    button.textContent = "Dismiss";
    button.addEventListener("click", () => {
      this.dispose();
    });
    this.element.appendChild(button);
  }
  static showMessage(message) {
    const msg = new StatusMessage();
    msg.element.textContent = message;
    msg.setVisible(true);
    return msg;
  }
  static showTemporaryMessage(message, closeAfter = 2e3) {
    const msg = this.showMessage(message);
    window.setTimeout(() => msg.dispose(), closeAfter);
    return msg;
  }
}
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
function computeNumPickIds(serializedAnnotations) {
  let numPickIds = 0;
  const typeToIds = serializedAnnotations.typeToIds;
  for (const annotationType of annotationTypes) {
    numPickIds += getAnnotationTypeRenderHandler(annotationType).pickIdsPerInstance * typeToIds[annotationType].length;
  }
  return numPickIds;
}
class AnnotationGeometryData {
  constructor(x) {
    this.bufferValid = false;
    this.numPickIds = 0;
    this.serializedAnnotations = {
      data: x.data,
      typeToIds: x.typeToIds,
      typeToOffset: x.typeToOffset,
      typeToIdMaps: x.typeToIdMaps
    };
  }
  freeGPUMemory(gl) {
    const buffer = this.buffer;
    if (buffer !== void 0) {
      buffer.dispose();
      this.bufferValid = false;
      this.buffer = void 0;
    }
  }
}
class AnnotationSubsetGeometryChunk extends Chunk {
  constructor(source, x) {
    super(source);
    if (x.data !== void 0) {
      this.data = new AnnotationGeometryData(x);
    }
  }
  freeGPUMemory(gl) {
    super.freeGPUMemory(gl);
    const data = this.data;
    if (data !== void 0) {
      data.freeGPUMemory(gl);
    }
  }
  dispose() {
    this.data = void 0;
  }
}
class AnnotationGeometryChunk extends SliceViewChunk {
  constructor(source, x) {
    super(source, x);
    if (x.data !== void 0) {
      this.data = new AnnotationGeometryData(x);
    }
  }
  freeGPUMemory(gl) {
    super.freeGPUMemory(gl);
    const data = this.data;
    if (data !== void 0) {
      data.freeGPUMemory(gl);
    }
  }
  dispose() {
    this.data = void 0;
  }
}
let AnnotationGeometryChunkSource = class AnnotationGeometryChunkSource2 extends SliceViewChunkSource {
  constructor(chunkManager, options) {
    super(chunkManager, options);
    this.immediateChunkUpdates = true;
    const parent = this.parent = options.parent;
    parent.spatiallyIndexedSources.add(this);
    var _spec = this.spec;
    const rank = _spec.rank, chunkDataSize = _spec.chunkDataSize;
    const multiscaleToChunkTransform = this.multiscaleToChunkTransform = new Float32Array((rank + 1) ** 2);
    inverse(multiscaleToChunkTransform, rank + 1, this.spec.chunkToMultiscaleTransform, rank + 1, rank + 1);
    for (let i = 0; i < rank; ++i) {
      for (let j = 0; j < rank + 1; ++j) {
        multiscaleToChunkTransform[(rank + 1) * j + i] /= chunkDataSize[i];
      }
    }
  }
  disposed() {
    this.parent.spatiallyIndexedSources.delete(this);
    super.disposed();
  }
  initializeCounterpart(rpc, options) {
    options["parent"] = this.parent.rpcId;
    super.initializeCounterpart(rpc, options);
  }
  addChunk(key, chunk) {
    super.addChunk(key, chunk);
  }
  getChunk(x) {
    return new AnnotationGeometryChunk(this, x);
  }
};
AnnotationGeometryChunkSource = __decorate$6([registerSharedObjectOwner(ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID)], AnnotationGeometryChunkSource);
let AnnotationSubsetGeometryChunkSource = class AnnotationSubsetGeometryChunkSource2 extends ChunkSource {
  constructor(chunkManager, parent, relationshipIndex) {
    super(chunkManager, {});
    this.parent = parent;
    this.relationshipIndex = relationshipIndex;
    this.immediateChunkUpdates = true;
  }
  addChunk(key, chunk) {
    super.addChunk(key, chunk);
  }
  getChunk(x) {
    return new AnnotationSubsetGeometryChunk(this, x);
  }
};
AnnotationSubsetGeometryChunkSource = __decorate$6([registerSharedObjectOwner(ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID)], AnnotationSubsetGeometryChunkSource);
class AnnotationMetadataChunk extends Chunk {
  constructor(source, x) {
    super(source);
    this.annotation = fixAnnotationAfterStructuredCloning(x.annotation);
  }
}
let AnnotationMetadataChunkSource = class AnnotationMetadataChunkSource2 extends ChunkSource {
  constructor(chunkManager, parent) {
    super(chunkManager);
    this.parent = parent;
  }
  getChunk(x) {
    return new AnnotationMetadataChunk(this, x);
  }
  addChunk(key, chunk) {
    super.addChunk(key, chunk);
    const references = this.parent.references;
    const reference = references.get(key);
    if (reference !== void 0) {
      reference.value = chunk.annotation;
      reference.changed.dispatch();
    }
  }
  deleteChunk(key) {
    const references = this.parent.references;
    const reference = references.get(key);
    if (reference !== void 0) {
      reference.value = void 0;
      reference.changed.dispatch();
    }
  }
};
AnnotationMetadataChunkSource = __decorate$6([registerSharedObjectOwner(ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID)], AnnotationMetadataChunkSource);
function copyOtherAnnotations(serializedAnnotations, propertySerializers, excludedType, excludedTypeAdjustment) {
  const newData = new Uint8Array(serializedAnnotations.data.length + excludedTypeAdjustment);
  for (const otherType of annotationTypes) {
    if (otherType === excludedType) continue;
    let otherTypeOffset = serializedAnnotations.typeToOffset[otherType];
    let newTypeOffset = otherTypeOffset;
    if (otherType > excludedType) {
      newTypeOffset += excludedTypeAdjustment;
      serializedAnnotations.typeToOffset[otherType] = newTypeOffset;
    }
    newData.set(serializedAnnotations.data.subarray(otherTypeOffset, otherTypeOffset + serializedAnnotations.typeToIds[otherType].length * propertySerializers[otherType].serializedBytes), newTypeOffset);
  }
  return newData;
}
function copyAnnotationSlice(serializedAnnotations, propertySerializers, type, dest, sourceBeginIndex, sourceEndIndex, destBeginIndex, destCount) {
  const typeOffset = serializedAnnotations.typeToOffset[type];
  let sourceGroupOffset = typeOffset;
  let destGroupOffset = typeOffset;
  const propertyGroupBytes = propertySerializers[type].propertyGroupBytes;
  const numGroups = propertyGroupBytes.length;
  const count = serializedAnnotations.typeToIds[type].length;
  for (let groupIndex = 0; groupIndex < numGroups; ++groupIndex) {
    const groupBytes = propertyGroupBytes[groupIndex];
    dest.set(serializedAnnotations.data.subarray(sourceGroupOffset + sourceBeginIndex * groupBytes, sourceGroupOffset + sourceEndIndex * groupBytes), destGroupOffset + destBeginIndex * groupBytes);
    sourceGroupOffset += groupBytes * count;
    destGroupOffset += groupBytes * destCount;
  }
}
function updateAnnotation(chunk, annotation, propertySerializers) {
  const type = annotation.type;
  const rank = propertySerializers[type].rank;
  const serializedAnnotations = chunk.serializedAnnotations;
  const ids = serializedAnnotations.typeToIds[type];
  const idMap = serializedAnnotations.typeToIdMaps[type];
  const handler = annotationTypeHandlers[type];
  const numBytes = propertySerializers[type].serializedBytes;
  let index2 = idMap.get(annotation.id);
  if (index2 === void 0) {
    index2 = idMap.size;
    idMap.set(annotation.id, index2);
    const newData = copyOtherAnnotations(serializedAnnotations, propertySerializers, type, numBytes);
    copyAnnotationSlice(
      serializedAnnotations,
      propertySerializers,
      type,
      newData,
      /*sourceBeginIndex=*/
      0,
      /*sourceEndIndex=*/
      index2,
      /*destBeginIndex=*/
      0,
      /*destCount=*/
      index2 + 1
    );
    ids.push(annotation.id);
    serializedAnnotations.data = newData;
  }
  const bufferOffset = serializedAnnotations.typeToOffset[type];
  const dv = new DataView(serializedAnnotations.data.buffer, serializedAnnotations.data.byteOffset, serializedAnnotations.data.byteLength);
  const isLittleEndian = ENDIANNESS === Endianness.LITTLE;
  const propertySerializer = propertySerializers[type];
  handler.serialize(dv, bufferOffset + propertySerializer.propertyGroupBytes[0] * index2, isLittleEndian, rank, annotation);
  propertySerializer.serialize(dv, bufferOffset, index2, ids.length, isLittleEndian, annotation.properties);
  chunk.bufferValid = false;
}
function deleteAnnotation(chunk, type, id, propertySerializers) {
  const serializedAnnotations = chunk.serializedAnnotations;
  const idMap = serializedAnnotations.typeToIdMaps[type];
  const index2 = idMap.get(id);
  if (index2 === void 0) {
    return false;
  }
  const ids = serializedAnnotations.typeToIds[type];
  const numBytes = propertySerializers[type].serializedBytes;
  const newData = copyOtherAnnotations(serializedAnnotations, propertySerializers, type, -numBytes);
  copyAnnotationSlice(
    serializedAnnotations,
    propertySerializers,
    type,
    newData,
    /*sourceBeginIndex=*/
    0,
    /*sourceEndIndex=*/
    index2,
    /*destBeginIndex=*/
    0,
    /*destCount=*/
    ids.length - 1
  );
  copyAnnotationSlice(
    serializedAnnotations,
    propertySerializers,
    type,
    newData,
    /*sourceBeginIndex=*/
    index2 + 1,
    /*sourceEndIndex=*/
    ids.length,
    /*destBeginIndex=*/
    index2,
    /*destCount=*/
    ids.length - 1
  );
  ids.splice(index2, 1);
  idMap.delete(id);
  for (let i = index2, count = ids.length; i < count; ++i) {
    idMap.set(ids[i], i);
  }
  serializedAnnotations.data = newData;
  chunk.bufferValid = false;
  return true;
}
function makeTemporaryChunk() {
  const typeToIds = [];
  const typeToOffset = [];
  const typeToIdMaps = [];
  for (const annotationType of annotationTypes) {
    typeToIds[annotationType] = [];
    typeToOffset[annotationType] = 0;
    typeToIdMaps[annotationType] = new _Map();
  }
  return new AnnotationGeometryChunk(void 0, { data: new Uint8Array(0), numPickIds: 0, typeToOffset, typeToIds, typeToIdMaps });
}
class MultiscaleAnnotationSource extends SharedObject {
  constructor(chunkManager, options) {
    super();
    this.chunkManager = chunkManager;
    this.metadataChunkSource = this.registerDisposer(new AnnotationMetadataChunkSource(this.chunkManager, this));
    this.spatiallyIndexedSources = new _Set();
    this.temporary = makeTemporaryChunk();
    this.references = new _Map();
    this.localUpdates = new _Map();
    this.numCommitsInProgress = 0;
    this.changed = new NullarySignal();
    this.referencesChanged = new Signal();
    this.readonly = false;
    this.childRefreshed = new NullarySignal();
    this.rank = options.rank;
    this.properties = options.properties;
    this.annotationPropertySerializers = makeAnnotationPropertySerializers(this.rank, this.properties);
    const segmentFilteredSources = this.segmentFilteredSources = [];
    const relationships = options.relationships;
    this.relationships = relationships;
    for (let i = 0, count = relationships.length; i < count; ++i) {
      segmentFilteredSources.push(this.registerDisposer(new AnnotationSubsetGeometryChunkSource(chunkManager, this, i)));
    }
  }
  hasNonSerializedProperties() {
    return this.relationships.length > 0;
  }
  getSources(_options) {
    throw new Error("not implemented");
  }
  initializeCounterpart(rpc, options) {
    this.metadataChunkSource.initializeCounterpart(rpc, {});
    for (const source of this.segmentFilteredSources) {
      source.initializeCounterpart(rpc, {});
    }
    options.segmentFilteredSource = this.segmentFilteredSources.map((x) => x.addCounterpartRef());
    options.metadataChunkSource = this.metadataChunkSource.addCounterpartRef();
    options.chunkManager = this.chunkManager.rpcId;
    super.initializeCounterpart(rpc, options);
  }
  add(annotation, commit = true) {
    annotation.id = makeAnnotationId();
    const reference = new AnnotationReference(annotation.id);
    reference.value = annotation;
    this.references.set(reference.id, reference);
    this.referencesChanged.dispatch({ action: "adding", id: reference.id });
    reference.registerDisposer(() => {
      this.references.delete(reference.id);
      this.referencesChanged.dispatch({ action: "deref", id: reference.id });
    });
    this.applyLocalUpdate(
      reference,
      /*existing=*/
      false,
      /*commit=*/
      commit,
      /*newAnnotation=*/
      annotation
    );
    return reference;
  }
  applyLocalUpdate(reference, existing, commit, newAnnotation) {
    const localUpdates = this.localUpdates;
    const id = reference.id;
    let localUpdate = this.localUpdates.get(id);
    const annotation = reference.value;
    if (annotation == null) {
      throw new Error(`Cannot create local update from null annotation`);
    }
    if (localUpdate === void 0) {
      localUpdate = {
        type: annotation.type,
        reference: reference.addRef(),
        existingAnnotation: existing ? annotation : void 0,
        pendingCommit: void 0,
        commitInProgress: void 0
      };
      localUpdates.set(id, localUpdate);
      this.forEachPossibleChunk(annotation, (chunk) => {
        const data = chunk.data;
        if (data === void 0) return;
        const annotationType = annotation.type;
        deleteAnnotation(data, annotationType, id, this.annotationPropertySerializers);
      });
      if (newAnnotation !== null) {
        updateAnnotation(this.temporary.data, newAnnotation, this.annotationPropertySerializers);
      }
    } else {
      if (newAnnotation === null) {
        deleteAnnotation(this.temporary.data, annotation.type, annotation.id, this.annotationPropertySerializers);
      } else {
        updateAnnotation(this.temporary.data, newAnnotation, this.annotationPropertySerializers);
      }
      reference.value = newAnnotation;
    }
    if (commit) {
      if (localUpdate.commitInProgress !== void 0) {
        localUpdate.pendingCommit = newAnnotation;
      } else {
        if (newAnnotation === null && localUpdate.existingAnnotation === void 0) {
          localUpdates.delete(id);
          localUpdate.reference.dispose();
          return;
        }
        this.sendCommitRequest(localUpdate, newAnnotation);
      }
    }
    this.notifyChanged(reference.id, newAnnotation || void 0);
  }
  sendCommitRequest(localUpdate, newAnnotation) {
    this.updateCommitsInProgress(1);
    localUpdate.commitInProgress = newAnnotation;
    this.rpc.invoke(ANNOTATION_COMMIT_UPDATE_RPC_ID, {
      id: this.rpcId,
      annotationId: localUpdate.existingAnnotation && localUpdate.reference.id,
      newAnnotation
    });
  }
  delete(reference) {
    this.applyLocalUpdate(
      reference,
      /*existing=*/
      true,
      /*commit=*/
      true,
      /*newAnnotation=*/
      null
    );
  }
  update(reference, newAnnotation) {
    this.applyLocalUpdate(
      reference,
      /*existing=*/
      true,
      /*commit=*/
      false,
      /*newAnnotation=*/
      newAnnotation
    );
  }
  notifyChanged(id, annotation) {
    const reference = this.references.get(id);
    const chunk = this.metadataChunkSource.chunks.get(id);
    if (chunk !== void 0) {
      chunk.annotation = annotation || null;
    }
    if (reference !== void 0) {
      reference.value = annotation || null;
      reference.changed.dispatch();
      this.referencesChanged.dispatch({ action: "changed", id });
    }
    this.chunkManager.chunkQueueManager.visibleChunksChanged.dispatch();
  }
  /**
   * Must be called after `add` or `update` to commit the result.
   */
  commit(reference) {
    this.applyLocalUpdate(
      reference,
      /*existing=*/
      true,
      /*commit=*/
      true,
      reference.value
    );
  }
  updateReference(annotation) {
    let existing = this.references.get(annotation.id);
    if (existing !== void 0) {
      existing.value = annotation;
    } else {
      let reference = new AnnotationReference(annotation.id);
      this.references.set(annotation.id, reference);
      reference.value = annotation;
      this.referencesChanged.dispatch({ action: "update", id: reference.id });
      reference.registerDisposer(() => {
        this.references.delete(reference.id);
        this.referencesChanged.dispatch({ action: "deref", id: reference.id });
      });
    }
  }
  hasReference(id) {
    return this.references.has(id);
  }
  getReference(id) {
    let existing = this.references.get(id);
    if (existing !== void 0) {
      return existing.addRef();
    }
    existing = new AnnotationReference(id);
    this.references.set(id, existing);
    this.referencesChanged.dispatch({ "action": "get", id });
    this.rpc.invoke(ANNOTATION_REFERENCE_ADD_RPC_ID, { id: this.rpcId, annotation: id });
    existing.registerDisposer(() => {
      this.references.delete(id);
      this.referencesChanged.dispatch({ "action": "deref", id });
      this.rpc.invoke(ANNOTATION_REFERENCE_DELETE_RPC_ID, { id: this.rpcId, annotation: id });
    });
    const chunk = this.metadataChunkSource.chunks.get(id);
    if (chunk !== void 0 && chunk.annotation !== null) {
      existing.value = chunk.annotation;
    }
    return existing;
  }
  forEachPossibleChunk(annotation, callback) {
    const relatedSegments = annotation.relatedSegments;
    if (relatedSegments !== void 0) {
      const numRelationships = relatedSegments.length;
      const segmentFilteredSources = this.segmentFilteredSources;
      for (let i = 0; i < numRelationships; ++i) {
        const segments = relatedSegments[i];
        if (segments === void 0) return;
        const source = segmentFilteredSources[i];
        for (const segment of segments) {
          const chunk = source.chunks.get(getObjectKey(segment));
          if (chunk === void 0) {
            continue;
          }
          callback(chunk);
        }
      }
    }
    const rank = this.rank;
    const tempLower = new Float32Array(rank);
    const tempUpper = new Float32Array(rank);
    const tempChunk = new Float32Array(rank);
    for (const source of this.spatiallyIndexedSources) {
      switch (annotation.type) {
        case AnnotationType.POINT:
          transformPoint(tempLower, source.multiscaleToChunkTransform, rank + 1, annotation.point, rank);
          tempUpper.set(tempLower);
          break;
        case AnnotationType.LINE:
        case AnnotationType.SPHERE:
        case AnnotationType.AXIS_ALIGNED_BOUNDING_BOX:
          transformPoint(tempLower, source.multiscaleToChunkTransform, rank + 1, annotation.pointA, rank);
          transformPoint(tempUpper, source.multiscaleToChunkTransform, rank + 1, annotation.pointB, rank);
          break;
        case AnnotationType.ELLIPSOID:
          transformPoint(tempLower, source.multiscaleToChunkTransform, rank + 1, annotation.center, rank);
          transformVector(tempUpper, source.multiscaleToChunkTransform, rank + 1, annotation.radii, rank);
          for (let i = 0; i < rank; ++i) {
            const c = tempLower[i];
            const r = tempUpper[i];
            tempLower[i] = c - r;
            tempUpper[i] = c + r;
          }
          break;
      }
      let totalChunks = 1;
      for (let i = 0; i < rank; ++i) {
        const a = tempLower[i];
        const b = tempUpper[i];
        const lower = Math.min(a, b);
        const upper = Math.max(a, b);
        tempLower[i] = Math.ceil(lower - 1);
        tempUpper[i] = Math.floor(upper + 1);
        totalChunks *= tempUpper[i] - tempLower[i];
      }
      const chunks = source.chunks;
      for (let chunkIndex = 0; chunkIndex < totalChunks; ++chunkIndex) {
        let remainder = chunkIndex;
        for (let i = 0; i < rank; ++i) {
          const lower = tempLower[i];
          const upper = tempUpper[i];
          const size = upper - lower;
          const x = tempChunk[i] = remainder % size;
          remainder = (remainder - x) / size;
        }
        const chunk = chunks.get(tempChunk.join());
        if (chunk !== void 0) {
          callback(chunk);
        }
      }
    }
  }
  static encodeOptions(_options) {
    return {};
  }
  handleSuccessfulUpdate(id, newAnnotation) {
    const localUpdate = this.localUpdates.get(id);
    if (localUpdate === void 0 || localUpdate.commitInProgress === void 0) {
      throw new Error(`Received invalid successful update notification`);
    }
    this.updateCommitsInProgress(-1);
    if (newAnnotation !== null && localUpdate.reference.id !== newAnnotation.id) {
      if (localUpdate.commitInProgress === null) {
        throw new Error(`Received invalid successful update notification`);
      }
      localUpdate.reference.id = newAnnotation.id;
      this.references.delete(id);
      this.references.set(newAnnotation.id, localUpdate.reference.addRef());
      this.localUpdates.delete(id);
      this.localUpdates.set(newAnnotation.id, localUpdate);
      if (localUpdate.reference.value !== null) {
        localUpdate.reference.value.id = newAnnotation.id;
        deleteAnnotation(this.temporary.data, localUpdate.type, id, this.annotationPropertySerializers);
        updateAnnotation(this.temporary.data, localUpdate.reference.value, this.annotationPropertySerializers);
      }
      localUpdate.reference.changed.dispatch();
    }
    let added = localUpdate.existingAnnotation === void 0;
    localUpdate.existingAnnotation = newAnnotation || void 0;
    localUpdate.commitInProgress = void 0;
    let pendingCommit = localUpdate.pendingCommit;
    localUpdate.pendingCommit = void 0;
    if (newAnnotation === null) {
      pendingCommit = void 0;
    }
    if (pendingCommit !== void 0) {
      if (pendingCommit !== null) {
        pendingCommit.id = newAnnotation.id;
      }
      this.sendCommitRequest(localUpdate, pendingCommit);
    } else {
      this.revertLocalUpdate(localUpdate);
      if (added) {
        this.childAdded.dispatch(newAnnotation);
        this.referencesChanged.dispatch({ action: "added", id: newAnnotation.id });
      } else if (newAnnotation === null) {
        this.references.get(id).dispose();
        this.childDeleted.dispatch(id);
        this.referencesChanged.dispatch({ action: "deleted", id });
      } else {
        this.childUpdated.dispatch(newAnnotation);
        this.referencesChanged.dispatch({ action: "updated", id: newAnnotation.id });
      }
    }
  }
  disposed() {
    const commitStatus = this.commitStatus;
    if (commitStatus !== void 0) {
      commitStatus.dispose();
    }
  }
  updateCommitsInProgress(amount) {
    this.numCommitsInProgress += amount;
    if (this.numCommitsInProgress === 0) {
      if (this.commitStatus !== void 0) {
        this.commitStatus.dispose();
        this.commitStatus = void 0;
      }
    } else if (this.commitStatus === void 0) {
      const status = this.commitStatus = new StatusMessage(
        /*delay=*/
        true
      );
      status.setText("Commiting annotations");
    }
  }
  handleFailedUpdate(id, message) {
    const localUpdate = this.localUpdates.get(id);
    if (localUpdate === void 0 || localUpdate.commitInProgress === void 0) {
      throw new Error(`Received invalid update notification`);
    }
    const status = new StatusMessage();
    status.setErrorMessage(`Error commiting annotation update: ${message}`);
    this.revertLocalUpdate(localUpdate);
    this.updateCommitsInProgress(-1);
  }
  revertLocalUpdate(localUpdate) {
    deleteAnnotation(this.temporary.data, localUpdate.type, localUpdate.reference.id, this.annotationPropertySerializers);
    const existingAnnotation = localUpdate.existingAnnotation;
    if (existingAnnotation !== void 0) {
      this.forEachPossibleChunk(existingAnnotation, (chunk) => {
        const data = chunk.data;
        if (data === void 0) return;
        updateAnnotation(data, existingAnnotation, this.annotationPropertySerializers);
      });
    }
    const reference = localUpdate.reference;
    const id = reference.id;
    reference.value = existingAnnotation || null;
    reference.changed.dispatch();
    reference.dispose();
    this.localUpdates.delete(id);
  }
  *[_Symbol$iterator]() {
  }
}
registerRPC(ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, function(x) {
  const source = this.get(x.id);
  const annotationId = x.annotationId;
  const error = x.error;
  if (error !== void 0) {
    source.handleFailedUpdate(annotationId, error);
  } else {
    const newAnnotation = fixAnnotationAfterStructuredCloning(x.newAnnotation);
    source.handleSuccessfulUpdate(annotationId, newAnnotation);
  }
});
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function defaultStringCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
const emptyCompletionResult = {
  offset: 0,
  completions: []
};
function applyCompletionOffset(offset, completionResult) {
  completionResult.offset += offset;
  return completionResult;
}
function getPrefixMatches(prefix, options) {
  let result = [];
  for (let option of options) {
    if (option.startsWith(prefix)) {
      result.push({ value: option });
    }
  }
  result.sort((a, b) => defaultStringCompare(a.value, b.value));
  return result;
}
function getPrefixMatchesWithDescriptions(prefix, options, getValue, getDescription) {
  let result = [];
  for (let option of options) {
    let key = getValue(option);
    if (key.startsWith(prefix)) {
      result.push({ value: key, description: getDescription(option) });
    }
  }
  result.sort((a, b) => defaultStringCompare(a.value, b.value));
  return result;
}
async function completeQueryStringParameters(queryString, keyCompleter, valueCompleter) {
  if (queryString.startsWith("{")) return emptyCompletionResult;
  const m = queryString.match(/^(?:(.*)[&;])?([^&;]*)$/);
  const part = m[2];
  let offset = queryString.length - part.length;
  const equalsIndex = part.indexOf("=");
  if (equalsIndex === -1) {
    const completions = await keyCompleter(part);
    return {
      offset: completions.offset + offset,
      completions: completions.completions.map((x) => _Object$assign(_Object$assign({}, x), { value: `${x.value}=` }))
    };
  }
  return applyCompletionOffset(offset + equalsIndex + 1, await valueCompleter(part.substring(0, equalsIndex), part.substring(equalsIndex + 1)));
}
async function completeQueryStringParametersFromTable(queryString, table) {
  return completeQueryStringParameters(queryString, async (key) => {
    const results = [];
    for (const entry of table) {
      const keyEntry = entry.key;
      if (keyEntry.value.startsWith(key)) results.push(keyEntry);
    }
    return { offset: 0, completions: results };
  }, async (key, value) => {
    for (const entry of table) {
      if (entry.key.value !== key) continue;
      return { offset: 0, completions: entry.values.filter((x) => x.value.startsWith(value)) };
    }
    return emptyCompletionResult;
  });
}
class RedirectError extends Error {
  constructor(redirectTarget) {
    super(`Redirected to: ${redirectTarget}`);
    this.redirectTarget = redirectTarget;
  }
}
function findSourceGroupBasedOnSeparator(path, separator) {
  if (separator === void 0) {
    if (path.indexOf("/") === -1) {
      separator = ":";
    } else {
      separator = "/";
    }
  }
  let index2 = path.lastIndexOf(separator);
  if (index2 === -1) {
    return 0;
  }
  return index2 + 1;
}
function suggestLayerNameBasedOnSeparator(path, separator) {
  let groupIndex = findSourceGroupBasedOnSeparator(path, separator);
  return path.substring(groupIndex);
}
var LocalDataSource;
(function(LocalDataSource2) {
  LocalDataSource2[LocalDataSource2["annotations"] = 0] = "annotations";
  LocalDataSource2[LocalDataSource2["equivalences"] = 1] = "equivalences";
})(LocalDataSource || (LocalDataSource = {}));
function makeEmptyDataSourceSpecification() {
  return { url: "", transform: void 0, enableDefaultSubsources: true, subsources: new _Map() };
}
class DataSourceProvider extends RefCounted {
  normalizeUrl(options) {
    return options.url;
  }
  convertLegacyUrl(options) {
    return options.url;
  }
  async completeUrl(options) {
    throw null;
  }
}
const localAnnotationsUrl = "local://annotations";
const localEquivalencesUrl = "local://equivalences";
class LocalDataSourceProvider extends DataSourceProvider {
  get description() {
    return "Local in-memory";
  }
  async get(options) {
    switch (options.url) {
      case localAnnotationsUrl: {
        const transform = options.transform;
        let modelTransform;
        if (transform === void 0) {
          const baseSpace = options.globalCoordinateSpace.value;
          const rank = baseSpace.rank, names = baseSpace.names, scales = baseSpace.scales, units = baseSpace.units;
          const inputSpace = makeCoordinateSpace({
            rank,
            scales,
            units,
            names: names.map((_, i) => `${i}`)
          });
          const outputSpace = makeCoordinateSpace({ rank, scales, units, names });
          modelTransform = {
            rank,
            sourceRank: rank,
            inputSpace,
            outputSpace,
            transform: createIdentity(Float64Array, rank + 1)
          };
        } else {
          modelTransform = makeIdentityTransform(emptyValidCoordinateSpace);
        }
        return {
          modelTransform,
          canChangeModelSpaceRank: true,
          subsources: [{
            id: "default",
            default: true,
            subsource: {
              local: LocalDataSource.annotations
            }
          }]
        };
      }
      case localEquivalencesUrl: {
        return {
          modelTransform: makeIdentityTransform(emptyValidCoordinateSpace),
          canChangeModelSpaceRank: false,
          subsources: [{
            id: "default",
            default: true,
            subsource: {
              local: LocalDataSource.equivalences
            }
          }]
        };
      }
    }
    throw new Error("Invalid local data source URL");
  }
  async completeUrl(options) {
    return {
      offset: 0,
      completions: getPrefixMatchesWithDescriptions(options.providerUrl, [{
        value: "annotations",
        description: "Annotations stored in the JSON state"
      }, {
        value: "equivalences",
        description: "Segmentation equivalence graph stored in the JSON state"
      }], (x) => x.value, (x) => x.description)
    };
  }
}
const protocolPattern = /^(?:([a-zA-Z][a-zA-Z0-9-+_]*):\/\/)?(.*)$/;
class DataSourceProviderRegistry extends RefCounted {
  constructor(credentialsManager) {
    super();
    this.credentialsManager = credentialsManager;
    this.dataSources = new _Map([["local", new LocalDataSourceProvider()]]);
  }
  register(name2, dataSource) {
    this.dataSources.set(name2, this.registerDisposer(dataSource));
  }
  getProvider(url) {
    const m = url.match(protocolPattern);
    if (m === null || m[1] === void 0) {
      throw new Error(`Data source URL must have the form "<protocol>://<path>".`);
    }
    var _m = _slicedToArray(m, 3);
    const providerProtocol = _m[1], providerUrl = _m[2];
    const factory = this.dataSources.get(providerProtocol);
    if (factory === void 0) {
      throw new Error(`Unsupported data source: ${_JSON$stringify(providerProtocol)}.`);
    }
    return [factory, providerUrl, providerProtocol];
  }
  async get(options) {
    const redirectLog = new _Set();
    var _options$cancellation = options.cancellationToken;
    const cancellationToken = _options$cancellation === void 0 ? uncancelableToken : _options$cancellation;
    let url = options.url;
    while (true) {
      var _getProvider = this.getProvider(options.url), _getProvider2 = _slicedToArray(_getProvider, 3);
      const provider = _getProvider2[0], providerUrl = _getProvider2[1], providerProtocol = _getProvider2[2];
      redirectLog.add(options.url);
      try {
        return provider.get(_Object$assign(_Object$assign({}, options), {
          url,
          providerProtocol,
          providerUrl,
          registry: this,
          cancellationToken,
          credentialsManager: this.credentialsManager
        }));
      } catch (e) {
        if (e instanceof RedirectError) {
          const redirect = e.redirectTarget;
          if (redirectLog.has(redirect)) {
            throw Error(`Layer source redirection contains loop: ${_JSON$stringify(_Array$from(redirectLog))}`);
          }
          if (redirectLog.size >= 10) {
            throw Error(`Too many layer source redirections: ${_JSON$stringify(_Array$from(redirectLog))}`);
          }
          url = redirect;
          continue;
        }
        throw e;
      }
    }
  }
  convertLegacyUrl(options) {
    try {
      var _getProvider3 = this.getProvider(options.url), _getProvider4 = _slicedToArray(_getProvider3, 3);
      const provider = _getProvider4[0], providerUrl = _getProvider4[1], providerProtocol = _getProvider4[2];
      return provider.convertLegacyUrl(_Object$assign(_Object$assign({}, options), { providerUrl, providerProtocol, registry: this }));
    } catch (_a) {
      return options.url;
    }
  }
  normalizeUrl(options) {
    try {
      var _getProvider5 = this.getProvider(options.url), _getProvider6 = _slicedToArray(_getProvider5, 3);
      const provider = _getProvider6[0], providerUrl = _getProvider6[1], providerProtocol = _getProvider6[2];
      return provider.normalizeUrl(_Object$assign(_Object$assign({}, options), { providerUrl, providerProtocol, registry: this }));
    } catch (_a) {
      return options.url;
    }
  }
  async completeUrl(options) {
    const url = options.url;
    var _options$cancellation2 = options.cancellationToken;
    const cancellationToken = _options$cancellation2 === void 0 ? uncancelableToken : _options$cancellation2;
    let protocolMatch = url.match(protocolPattern);
    let protocol = protocolMatch[1];
    if (protocol === void 0) {
      return _Promise.resolve({
        offset: 0,
        completions: getPrefixMatchesWithDescriptions(url, this.dataSources, ([name2]) => `${name2}://`, ([, factory]) => factory.description)
      });
    } else {
      const factory = this.dataSources.get(protocol);
      if (factory !== void 0) {
        const completions = await factory.completeUrl({
          registry: this,
          url,
          providerUrl: protocolMatch[2],
          chunkManager: options.chunkManager,
          cancellationToken,
          credentialsManager: this.credentialsManager
        });
        return applyCompletionOffset(protocol.length + 3, completions);
      }
      throw null;
    }
  }
  suggestLayerName(url) {
    var _getProvider7 = this.getProvider(url), _getProvider8 = _slicedToArray(_getProvider7, 2);
    let dataSource = _getProvider8[0], path = _getProvider8[1];
    if (path.endsWith("/")) {
      path = path.substring(0, path.length - 1);
    }
    let suggestor = dataSource.suggestLayerName;
    if (suggestor !== void 0) {
      return suggestor(path);
    }
    return suggestLayerNameBasedOnSeparator(path);
  }
  findSourceGroup(url) {
    var _getProvider9 = this.getProvider(url), _getProvider10 = _slicedToArray(_getProvider9, 3);
    let dataSource = _getProvider10[0], path = _getProvider10[1], dataSourceName = _getProvider10[2];
    let helper = dataSource.findSourceGroup || findSourceGroupBasedOnSeparator;
    return helper(path) + dataSourceName.length + 3;
  }
}
var es7_object_entries = {};
var _objectToArray;
var hasRequired_objectToArray;
function require_objectToArray() {
  if (hasRequired_objectToArray) return _objectToArray;
  hasRequired_objectToArray = 1;
  var DESCRIPTORS = require_descriptors();
  var getKeys = require_objectKeys();
  var toIObject = require_toIobject();
  var isEnum = require_objectPie().f;
  _objectToArray = function(isEntries) {
    return function(it) {
      var O = toIObject(it);
      var keys2 = getKeys(O);
      var length2 = keys2.length;
      var i = 0;
      var result = [];
      var key;
      while (length2 > i) {
        key = keys2[i++];
        if (!DESCRIPTORS || isEnum.call(O, key)) {
          result.push(isEntries ? [key, O[key]] : O[key]);
        }
      }
      return result;
    };
  };
  return _objectToArray;
}
var hasRequiredEs7_object_entries;
function requireEs7_object_entries() {
  if (hasRequiredEs7_object_entries) return es7_object_entries;
  hasRequiredEs7_object_entries = 1;
  var $export = require_export();
  var $entries = require_objectToArray()(true);
  $export($export.S, "Object", {
    entries: function entries2(it) {
      return $entries(it);
    }
  });
  return es7_object_entries;
}
var entries$1;
var hasRequiredEntries$1;
function requireEntries$1() {
  if (hasRequiredEntries$1) return entries$1;
  hasRequiredEntries$1 = 1;
  requireEs7_object_entries();
  entries$1 = require_core().Object.entries;
  return entries$1;
}
var entries;
var hasRequiredEntries;
function requireEntries() {
  if (hasRequiredEntries) return entries;
  hasRequiredEntries = 1;
  entries = { "default": requireEntries$1(), __esModule: true };
  return entries;
}
var entriesExports = requireEntries();
const _Object$entries = /* @__PURE__ */ getDefaultExportFromCjs(entriesExports);
var es6_weakSet = {};
var _collectionWeak;
var hasRequired_collectionWeak;
function require_collectionWeak() {
  if (hasRequired_collectionWeak) return _collectionWeak;
  hasRequired_collectionWeak = 1;
  var redefineAll = require_redefineAll();
  var getWeak = require_meta().getWeak;
  var anObject = require_anObject();
  var isObject = require_isObject();
  var anInstance = require_anInstance();
  var forOf = require_forOf();
  var createArrayMethod = require_arrayMethods();
  var $has = require_has();
  var validate = require_validateCollection();
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var id = 0;
  var uncaughtFrozenStore = function(that) {
    return that._l || (that._l = new UncaughtFrozenStore());
  };
  var UncaughtFrozenStore = function() {
    this.a = [];
  };
  var findUncaughtFrozen = function(store, key) {
    return arrayFind(store.a, function(it) {
      return it[0] === key;
    });
  };
  UncaughtFrozenStore.prototype = {
    get: function(key) {
      var entry = findUncaughtFrozen(this, key);
      if (entry) return entry[1];
    },
    has: function(key) {
      return !!findUncaughtFrozen(this, key);
    },
    set: function(key, value) {
      var entry = findUncaughtFrozen(this, key);
      if (entry) entry[1] = value;
      else this.a.push([key, value]);
    },
    "delete": function(key) {
      var index2 = arrayFindIndex(this.a, function(it) {
        return it[0] === key;
      });
      if (~index2) this.a.splice(index2, 1);
      return !!~index2;
    }
  };
  _collectionWeak = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        anInstance(that, C, NAME, "_i");
        that._t = NAME;
        that._i = id++;
        that._l = void 0;
        if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        // 23.3.3.2 WeakMap.prototype.delete(key)
        // 23.4.3.3 WeakSet.prototype.delete(value)
        "delete": function(key) {
          if (!isObject(key)) return false;
          var data = getWeak(key);
          if (data === true) return uncaughtFrozenStore(validate(this, NAME))["delete"](key);
          return data && $has(data, this._i) && delete data[this._i];
        },
        // 23.3.3.4 WeakMap.prototype.has(key)
        // 23.4.3.4 WeakSet.prototype.has(value)
        has: function has(key) {
          if (!isObject(key)) return false;
          var data = getWeak(key);
          if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
          return data && $has(data, this._i);
        }
      });
      return C;
    },
    def: function(that, key, value) {
      var data = getWeak(anObject(key), true);
      if (data === true) uncaughtFrozenStore(that).set(key, value);
      else data[that._i] = value;
      return that;
    },
    ufstore: uncaughtFrozenStore
  };
  return _collectionWeak;
}
var hasRequiredEs6_weakSet;
function requireEs6_weakSet() {
  if (hasRequiredEs6_weakSet) return es6_weakSet;
  hasRequiredEs6_weakSet = 1;
  var weak = require_collectionWeak();
  var validate = require_validateCollection();
  var WEAK_SET = "WeakSet";
  require_collection()(WEAK_SET, function(get) {
    return function WeakSet2() {
      return get(this, arguments.length > 0 ? arguments[0] : void 0);
    };
  }, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function add2(value) {
      return weak.def(validate(this, WEAK_SET), value, true);
    }
  }, weak, false, true);
  return es6_weakSet;
}
var es7_weakSet_of = {};
var hasRequiredEs7_weakSet_of;
function requireEs7_weakSet_of() {
  if (hasRequiredEs7_weakSet_of) return es7_weakSet_of;
  hasRequiredEs7_weakSet_of = 1;
  require_setCollectionOf()("WeakSet");
  return es7_weakSet_of;
}
var es7_weakSet_from = {};
var hasRequiredEs7_weakSet_from;
function requireEs7_weakSet_from() {
  if (hasRequiredEs7_weakSet_from) return es7_weakSet_from;
  hasRequiredEs7_weakSet_from = 1;
  require_setCollectionFrom()("WeakSet");
  return es7_weakSet_from;
}
var weakSet$1;
var hasRequiredWeakSet$1;
function requireWeakSet$1() {
  if (hasRequiredWeakSet$1) return weakSet$1;
  hasRequiredWeakSet$1 = 1;
  requireWeb_dom_iterable();
  requireEs6_weakSet();
  requireEs7_weakSet_of();
  requireEs7_weakSet_from();
  weakSet$1 = require_core().WeakSet;
  return weakSet$1;
}
var weakSet;
var hasRequiredWeakSet;
function requireWeakSet() {
  if (hasRequiredWeakSet) return weakSet;
  hasRequiredWeakSet = 1;
  weakSet = { "default": requireWeakSet$1(), __esModule: true };
  return weakSet;
}
var weakSetExports = requireWeakSet();
const _WeakSet = /* @__PURE__ */ getDefaultExportFromCjs(weakSetExports);
var throttle_1;
var hasRequiredThrottle;
function requireThrottle() {
  if (hasRequiredThrottle) return throttle_1;
  hasRequiredThrottle = 1;
  var debounce2 = requireDebounce(), isObject = requireIsObject();
  var FUNC_ERROR_TEXT = "Expected a function";
  function throttle2(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce2(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  throttle_1 = throttle2;
  return throttle_1;
}
var throttleExports = requireThrottle();
const throttle = /* @__PURE__ */ getDefaultExportFromCjs(throttleExports);
function parseDataSubsourceSpecificationFromJson(json2) {
  if (typeof json2 === "boolean") {
    return { enabled: json2 };
  }
  verifyObject(json2);
  return { enabled: verifyOptionalObjectProperty(json2, "enabled", verifyBoolean) };
}
function layerDataSourceSpecificationFromJson(obj, legacyTransform = void 0) {
  if (typeof obj === "string") {
    return {
      url: obj,
      transform: legacyTransform,
      enableDefaultSubsources: true,
      subsources: new _Map()
    };
  }
  verifyObject(obj);
  return {
    url: verifyObjectProperty(obj, "url", verifyString),
    transform: verifyObjectProperty(obj, "transform", coordinateTransformSpecificationFromJson) || legacyTransform,
    enableDefaultSubsources: verifyOptionalObjectProperty(obj, "enableDefaultSubsources", verifyBoolean, true),
    subsources: verifyOptionalObjectProperty(obj, "subsources", (subsourcesObj) => verifyObjectAsMap(subsourcesObj, parseDataSubsourceSpecificationFromJson), new _Map())
  };
}
function dataSubsourceSpecificationToJson(spec) {
  return spec.enabled;
}
function layerDataSourceSpecificationToJson(spec) {
  const transform = coordinateTransformSpecificationToJson(spec.transform);
  const subsourcesJson = {};
  let emptySubsources = true;
  for (const _ref of spec.subsources) {
    var _ref2 = _slicedToArray(_ref, 2);
    const id = _ref2[0];
    const subsource = _ref2[1];
    const j = dataSubsourceSpecificationToJson(subsource);
    if (j !== void 0) {
      subsourcesJson[id] = j;
      emptySubsources = false;
    }
  }
  if (transform === void 0 && emptySubsources && spec.enableDefaultSubsources === true) {
    return spec.url;
  }
  return {
    url: spec.url,
    transform,
    subsources: emptySubsources ? void 0 : subsourcesJson,
    enableDefaultSubsources: spec.enableDefaultSubsources === true ? void 0 : false
  };
}
class LoadedDataSubsource {
  constructor(loadedDataSource, subsourceEntry, subsourceSpec, subsourceIndex, enableDefaultSubsources) {
    this.loadedDataSource = loadedDataSource;
    this.subsourceEntry = subsourceEntry;
    this.subsourceSpec = subsourceSpec;
    this.subsourceIndex = subsourceIndex;
    this.activated = void 0;
    this.guardValues = [];
    this.messages = new MessageList();
    this.isActiveChanged = new NullarySignal();
    let enabled;
    if (subsourceSpec === void 0 || subsourceSpec.enabled === void 0) {
      enabled = subsourceEntry.default && enableDefaultSubsources;
    } else {
      enabled = subsourceSpec.enabled;
    }
    const modelRank = loadedDataSource.dataSource.modelTransform.sourceRank;
    let modelSubspaceDimensionIndices = subsourceEntry.modelSubspaceDimensionIndices;
    if (modelSubspaceDimensionIndices === void 0) {
      modelSubspaceDimensionIndices = new Array(modelRank);
      for (let i = 0; i < modelRank; ++i) {
        modelSubspaceDimensionIndices[i] = i;
      }
    }
    var _subsourceEntry$subso = subsourceEntry.subsourceToModelSubspaceTransform;
    const subsourceToModelSubspaceTransform = _subsourceEntry$subso === void 0 ? createIdentity(Float32Array, modelSubspaceDimensionIndices.length + 1) : _subsourceEntry$subso;
    this.enabled = enabled;
    this.subsourceToModelSubspaceTransform = subsourceToModelSubspaceTransform;
    this.modelSubspaceDimensionIndices = modelSubspaceDimensionIndices;
    this.isActiveChanged.add(loadedDataSource.activatedSubsourcesChanged.dispatch);
  }
  activate(callback, ...guardValues) {
    this.messages.clearMessages();
    if (this.activated !== void 0) {
      if (arraysEqual(guardValues, this.guardValues)) return;
      this.activated.dispose();
    }
    this.guardValues = guardValues;
    const activated = this.activated = new RefCounted();
    callback(activated);
    this.isActiveChanged.dispatch();
  }
  deactivate(error) {
    this.messages.clearMessages();
    this.messages.addMessage({ severity: MessageSeverity.error, message: error });
    const activated = this.activated;
    if (activated === void 0) return;
    this.activated = void 0;
    activated.dispose();
    this.isActiveChanged.dispatch();
  }
  addRenderLayer(renderLayer) {
    const activated = this.activated;
    activated.registerDisposer(this.loadedDataSource.layer.addRenderLayer(renderLayer));
    activated.registerDisposer(this.messages.addChild(renderLayer.messages));
  }
  getRenderLayerTransform(channelCoordinateSpace) {
    const activated = this.activated;
    var _loadedDataSource = this.loadedDataSource;
    const layer = _loadedDataSource.layer, transform = _loadedDataSource.transform;
    return activated.registerDisposer(getWatchableRenderLayerTransform(layer.manager.root.coordinateSpace, layer.localPosition.coordinateSpace, transform, this, channelCoordinateSpace));
  }
}
class LoadedLayerDataSource extends RefCounted {
  constructor(layerDataSource, dataSource, spec) {
    super();
    this.layerDataSource = layerDataSource;
    this.dataSource = dataSource;
    this.error = void 0;
    this.enabledSubsourcesChanged = new NullarySignal();
    this.activatedSubsourcesChanged = new NullarySignal();
    this.messages = new MessageList();
    if (dataSource.canChangeModelSpaceRank) {
      this.transform = new WatchableCoordinateSpaceTransform(makeIdentityTransform(makeCoordinateSpace({ rank: 0, scales: new Float64Array(0), units: [], names: [] })), true);
      this.transform.value = dataSource.modelTransform;
    } else {
      this.transform = new WatchableCoordinateSpaceTransform(dataSource.modelTransform);
    }
    if (spec.transform !== void 0) {
      this.transform.spec = spec.transform;
    }
    const subsourceSpecs = spec.subsources;
    this.enableDefaultSubsources = spec.enableDefaultSubsources;
    this.subsources = dataSource.subsources.map((subsourceEntry, subsourceIndex) => new LoadedDataSubsource(this, subsourceEntry, subsourceSpecs.get(subsourceEntry.id), subsourceIndex, this.enableDefaultSubsources));
  }
  get enabledSubsources() {
    return this.subsources.filter((x) => x.enabled);
  }
  get layer() {
    return this.layerDataSource.layer;
  }
  disposed() {
    for (const subsource of this.subsources) {
      const activated = subsource.activated;
      if (activated !== void 0) {
        subsource.activated = void 0;
        activated.dispose();
      }
    }
  }
}
class LayerDataSource extends RefCounted {
  constructor(layer, spec = void 0) {
    super();
    this.layer = layer;
    this.changed = new NullarySignal();
    this.messages = new MessageList();
    this.loadState_ = void 0;
    this.specGeneration = -1;
    this.refCounted_ = void 0;
    this.registerDisposer(this.changed.add(layer.dataSourcesChanged.dispatch));
    if (spec === void 0) {
      this.spec_ = makeEmptyDataSourceSpecification();
    } else {
      this.spec = spec;
    }
  }
  get spec() {
    const loadState = this.loadState;
    if (loadState !== void 0 && loadState.error === void 0) {
      const generation = this.changed.count;
      if (generation !== this.specGeneration) {
        this.specGeneration = generation;
        this.spec_ = {
          url: this.spec.url,
          transform: loadState.transform.spec,
          enableDefaultSubsources: loadState.enableDefaultSubsources,
          subsources: new _Map(_Array$from(loadState.subsources, (loadedSubsource) => {
            const defaultEnabledValue = loadState.enableDefaultSubsources && loadedSubsource.subsourceEntry.default;
            return [loadedSubsource.subsourceEntry.id, {
              enabled: loadedSubsource.enabled !== defaultEnabledValue ? loadedSubsource.enabled : void 0
            }];
          }))
        };
      }
    }
    return this.spec_;
  }
  get loadState() {
    return this.loadState_;
  }
  set spec(spec) {
    const layer = this.layer;
    this.messages.clearMessages();
    if (spec.url.length === 0) {
      if (layer.dataSources.length !== 1) {
        const index2 = layer.dataSources.indexOf(this);
        if (index2 !== -1) {
          layer.dataSources.splice(index2, 1);
          layer.dataSourcesChanged.dispatch();
          this.dispose();
          return;
        }
      }
      this.spec_ = spec;
      if (this.refCounted_ !== void 0) {
        this.refCounted_.dispose();
        this.refCounted_ = void 0;
        this.loadState_ = void 0;
        this.changed.dispatch();
      }
      return;
    }
    const refCounted = new RefCounted();
    const retainer = refCounted.registerDisposer(disposableOnce(layer.markLoading()));
    if (this.refCounted_ !== void 0) {
      this.refCounted_.dispose();
      this.loadState_ = void 0;
    }
    this.refCounted_ = refCounted;
    this.spec_ = spec;
    const chunkManager = layer.manager.chunkManager;
    const registry = layer.manager.dataSourceProviderRegistry;
    const cancellationToken = new CancellationTokenSource();
    this.messages.addMessage({ severity: MessageSeverity.info, message: "Loading data source" });
    registry.get({
      chunkManager,
      url: spec.url,
      cancellationToken,
      globalCoordinateSpace: layer.manager.root.coordinateSpace,
      transform: spec.transform
    }).then((source) => {
      if (refCounted.wasDisposed) return;
      this.messages.clearMessages();
      const loaded = refCounted.registerDisposer(new LoadedLayerDataSource(this, source, spec));
      loaded.registerDisposer(layer.addCoordinateSpace(loaded.transform.outputSpace));
      loaded.registerDisposer(loaded.transform.changed.add(this.changed.dispatch));
      this.loadState_ = loaded;
      loaded.registerDisposer(loaded.enabledSubsourcesChanged.add(this.changed.dispatch));
      this.changed.dispatch();
      retainer();
    }).catch((error) => {
      if (this.wasDisposed) return;
      this.loadState_ = { error };
      this.messages.clearMessages();
      this.messages.addMessage({ severity: MessageSeverity.error, message: error.message });
      this.changed.dispatch();
    });
    refCounted.registerDisposer(() => {
      cancellationToken.cancel();
    });
    this.changed.dispatch();
  }
  disposed() {
    const refCounted = this.refCounted_;
    if (refCounted !== void 0) {
      refCounted.dispose();
    }
  }
  toJSON() {
    const loadState = this.loadState;
    if (loadState === void 0 || loadState.error !== void 0) {
      return layerDataSourceSpecificationToJson(this.spec);
    }
    return layerDataSourceSpecificationToJson({
      url: this.spec.url,
      transform: loadState.transform.spec,
      enableDefaultSubsources: loadState.enableDefaultSubsources,
      subsources: new _Map(_Array$from(loadState.subsources, (loadedSubsource) => {
        const defaultEnabledValue = loadState.enableDefaultSubsources && loadedSubsource.subsourceEntry.default;
        return [loadedSubsource.subsourceEntry.id, {
          enabled: loadedSubsource.enabled !== defaultEnabledValue ? loadedSubsource.enabled : void 0
        }];
      }))
    });
  }
}
var es6_object_is = {};
var _sameValue;
var hasRequired_sameValue;
function require_sameValue() {
  if (hasRequired_sameValue) return _sameValue;
  hasRequired_sameValue = 1;
  _sameValue = Object.is || function is2(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  return _sameValue;
}
var hasRequiredEs6_object_is;
function requireEs6_object_is() {
  if (hasRequiredEs6_object_is) return es6_object_is;
  hasRequiredEs6_object_is = 1;
  var $export = require_export();
  $export($export.S, "Object", { is: require_sameValue() });
  return es6_object_is;
}
var is$1;
var hasRequiredIs$1;
function requireIs$1() {
  if (hasRequiredIs$1) return is$1;
  hasRequiredIs$1 = 1;
  requireEs6_object_is();
  is$1 = require_core().Object.is;
  return is$1;
}
var is;
var hasRequiredIs;
function requireIs() {
  if (hasRequiredIs) return is;
  hasRequiredIs = 1;
  is = { "default": requireIs$1(), __esModule: true };
  return is;
}
var isExports = requireIs();
const _Object$is = /* @__PURE__ */ getDefaultExportFromCjs(isExports);
var es6_math_sign = {};
var _mathSign;
var hasRequired_mathSign;
function require_mathSign() {
  if (hasRequired_mathSign) return _mathSign;
  hasRequired_mathSign = 1;
  _mathSign = Math.sign || function sign2(x) {
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
  };
  return _mathSign;
}
var hasRequiredEs6_math_sign;
function requireEs6_math_sign() {
  if (hasRequiredEs6_math_sign) return es6_math_sign;
  hasRequiredEs6_math_sign = 1;
  var $export = require_export();
  $export($export.S, "Math", { sign: require_mathSign() });
  return es6_math_sign;
}
var sign$1;
var hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  requireEs6_math_sign();
  sign$1 = require_core().Math.sign;
  return sign$1;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  sign = { "default": requireSign$1(), __esModule: true };
  return sign;
}
var signExports = requireSign();
const _Math$sign = /* @__PURE__ */ getDefaultExportFromCjs(signExports);
var es6_weakMap = { exports: {} };
var hasRequiredEs6_weakMap;
function requireEs6_weakMap() {
  if (hasRequiredEs6_weakMap) return es6_weakMap.exports;
  hasRequiredEs6_weakMap = 1;
  var global = require_global();
  var each = require_arrayMethods()(0);
  var redefine = require_redefine();
  var meta = require_meta();
  var assign = require_objectAssign();
  var weak = require_collectionWeak();
  var isObject = require_isObject();
  var validate = require_validateCollection();
  var NATIVE_WEAK_MAP = require_validateCollection();
  var IS_IE11 = !global.ActiveXObject && "ActiveXObject" in global;
  var WEAK_MAP = "WeakMap";
  var getWeak = meta.getWeak;
  var isExtensible = Object.isExtensible;
  var uncaughtFrozenStore = weak.ufstore;
  var InternalMap;
  var wrapper = function(get) {
    return function WeakMap() {
      return get(this, arguments.length > 0 ? arguments[0] : void 0);
    };
  };
  var methods = {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function get(key) {
      if (isObject(key)) {
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
        return data ? data[this._i] : void 0;
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function set2(key, value) {
      return weak.def(validate(this, WEAK_MAP), key, value);
    }
  };
  var $WeakMap = es6_weakMap.exports = require_collection()(WEAK_MAP, wrapper, methods, weak, true, true);
  if (NATIVE_WEAK_MAP && IS_IE11) {
    InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
    assign(InternalMap.prototype, methods);
    meta.NEED = true;
    each(["delete", "has", "get", "set"], function(key) {
      var proto = $WeakMap.prototype;
      var method = proto[key];
      redefine(proto, key, function(a, b) {
        if (isObject(a) && !isExtensible(a)) {
          if (!this._f) this._f = new InternalMap();
          var result = this._f[key](a, b);
          return key == "set" ? this : result;
        }
        return method.call(this, a, b);
      });
    });
  }
  return es6_weakMap.exports;
}
var es7_weakMap_of = {};
var hasRequiredEs7_weakMap_of;
function requireEs7_weakMap_of() {
  if (hasRequiredEs7_weakMap_of) return es7_weakMap_of;
  hasRequiredEs7_weakMap_of = 1;
  require_setCollectionOf()("WeakMap");
  return es7_weakMap_of;
}
var es7_weakMap_from = {};
var hasRequiredEs7_weakMap_from;
function requireEs7_weakMap_from() {
  if (hasRequiredEs7_weakMap_from) return es7_weakMap_from;
  hasRequiredEs7_weakMap_from = 1;
  require_setCollectionFrom()("WeakMap");
  return es7_weakMap_from;
}
var weakMap$1;
var hasRequiredWeakMap$1;
function requireWeakMap$1() {
  if (hasRequiredWeakMap$1) return weakMap$1;
  hasRequiredWeakMap$1 = 1;
  requireWeb_dom_iterable();
  requireEs6_weakMap();
  requireEs7_weakMap_of();
  requireEs7_weakMap_from();
  weakMap$1 = require_core().WeakMap;
  return weakMap$1;
}
var weakMap;
var hasRequiredWeakMap;
function requireWeakMap() {
  if (hasRequiredWeakMap) return weakMap;
  hasRequiredWeakMap = 1;
  weakMap = { "default": requireWeakMap$1(), __esModule: true };
  return weakMap;
}
var weakMapExports = requireWeakMap();
const _WeakMap = /* @__PURE__ */ getDefaultExportFromCjs(weakMapExports);
function optionallyRestoreFromJsonMember(obj, member, restorable) {
  verifyOptionalObjectProperty(obj, member, (x) => restorable.restoreState(x));
}
class CompoundTrackable extends RefCounted {
  constructor() {
    super(...arguments);
    this.children = new _Map();
    this.changed = new NullarySignal();
  }
  add(key, value) {
    const children = this.children;
    if (children.has(key)) {
      throw new Error(`Key ${_JSON$stringify(key)} already registered.`);
    }
    this.children.set(key, value);
    value.changed.add(this.changed.dispatch);
    this.changed.dispatch();
    return () => {
      this.remove(key);
    };
  }
  remove(key) {
    const children = this.children;
    if (children.has(key)) {
      throw new Error(`Key ${_JSON$stringify(key)} not registered.`);
    }
    const value = children.get(key);
    this.children.delete(key);
    value.changed.remove(this.changed.dispatch);
    this.changed.dispatch();
  }
  disposed() {
    const changed = this.changed;
    for (let value of this.children.values()) {
      value.changed.remove(changed.dispatch);
    }
    this.children = void 0;
    super.disposed();
  }
  toJSON() {
    const result = this.baseJSON();
    for (let _ref of this.children) {
      var _ref2 = _slicedToArray(_ref, 2);
      let key = _ref2[0];
      let value = _ref2[1];
      result[key] = value.toJSON();
    }
    return result;
  }
  baseJSON() {
    return {};
  }
  reset() {
    for (let value of this.children.values()) {
      value.reset();
    }
  }
  restoreState(x) {
    verifyObject(x);
    for (let _ref3 of this.children) {
      var _ref4 = _slicedToArray(_ref3, 2);
      let key = _ref4[0];
      let value = _ref4[1];
      try {
        if (x.hasOwnProperty(key)) {
          const subValue = x[key];
          if (subValue === void 0) {
            continue;
          }
          value.restoreState(subValue);
        }
      } catch (restoreError) {
        throw new Error(`Error restoring property ${_JSON$stringify(key)}: ${restoreError.message}`);
      }
    }
  }
}
const jsonCache = new _WeakMap();
function getCachedJson(root) {
  let cacheState = jsonCache.get(root);
  const generation = root.changed.count;
  if (cacheState !== void 0) {
    if (cacheState.generation === generation) {
      return cacheState;
    }
  }
  let value;
  if (root instanceof CompoundTrackable) {
    value = root.baseJSON();
    for (let _ref5 of root.children) {
      var _ref6 = _slicedToArray(_ref5, 2);
      let k = _ref6[0];
      let v = _ref6[1];
      value[k] = getCachedJson(v).value;
    }
  } else {
    value = root.toJSON();
  }
  if (cacheState === void 0) {
    cacheState = { generation, value };
    jsonCache.set(root, cacheState);
  } else {
    cacheState.generation = generation;
    cacheState.value = value;
  }
  return cacheState;
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TrackableEnum {
  constructor(enumType, value_, defaultValue = value_) {
    this.enumType = enumType;
    this.value_ = value_;
    this.defaultValue = defaultValue;
    this.changed = new NullarySignal();
  }
  set value(value) {
    if (this.value_ !== value) {
      this.value_ = value;
      this.changed.dispatch();
    }
  }
  get value() {
    return this.value_;
  }
  reset() {
    this.value = this.defaultValue;
  }
  restoreState(obj) {
    this.value = verifyEnumString(obj, this.enumType);
  }
  toJSON() {
    if (this.value_ === this.defaultValue) return void 0;
    return this.enumType[this.value_].toLowerCase();
  }
}
var NavigationLinkType;
(function(NavigationLinkType2) {
  NavigationLinkType2[NavigationLinkType2["LINKED"] = 0] = "LINKED";
  NavigationLinkType2[NavigationLinkType2["RELATIVE"] = 1] = "RELATIVE";
  NavigationLinkType2[NavigationLinkType2["UNLINKED"] = 2] = "UNLINKED";
})(NavigationLinkType || (NavigationLinkType = {}));
var NavigationSimpleLinkType;
(function(NavigationSimpleLinkType2) {
  NavigationSimpleLinkType2[NavigationSimpleLinkType2["LINKED"] = 0] = "LINKED";
  NavigationSimpleLinkType2[NavigationSimpleLinkType2["UNLINKED"] = 2] = "UNLINKED";
})(NavigationSimpleLinkType || (NavigationSimpleLinkType = {}));
class TrackableNavigationLink extends TrackableEnum {
  constructor(value = NavigationLinkType.LINKED) {
    super(NavigationLinkType, value);
  }
}
class TrackableNavigationSimpleLink extends TrackableEnum {
  constructor(value = NavigationSimpleLinkType.LINKED) {
    super(NavigationSimpleLinkType, value);
  }
}
const tempVec3$5 = create$3();
const tempQuat = create$1();
function makeLinked(self2, peer, link, operations) {
  let updatingSelf = false;
  let selfMinusPeer;
  self2.registerDisposer(peer);
  const handlePeerUpdate = () => {
    updatingSelf = true;
    switch (link.value) {
      case NavigationLinkType.UNLINKED:
        if (operations.isValid(self2)) {
          break;
        }
      case NavigationLinkType.LINKED:
        operations.assign(self2, peer);
        break;
      case NavigationLinkType.RELATIVE:
        operations.add(self2, peer, selfMinusPeer);
        break;
    }
    updatingSelf = false;
  };
  const handleSelfUpdate = () => {
    if (updatingSelf) {
      return;
    }
    switch (link.value) {
      case NavigationLinkType.UNLINKED:
        break;
      case NavigationLinkType.LINKED:
        operations.assign(peer, self2);
        break;
      case NavigationLinkType.RELATIVE:
        operations.subtract(peer, self2, selfMinusPeer);
        break;
    }
  };
  let previousLinkValue = NavigationLinkType.UNLINKED;
  const handleLinkUpdate = () => {
    const linkValue = link.value;
    if (linkValue !== previousLinkValue) {
      switch (linkValue) {
        case NavigationLinkType.UNLINKED:
          selfMinusPeer = void 0;
          break;
        case NavigationLinkType.LINKED:
          selfMinusPeer = void 0;
          operations.assign(self2, peer);
          break;
        case NavigationLinkType.RELATIVE:
          selfMinusPeer = operations.difference(self2, peer);
          break;
      }
    }
    previousLinkValue = linkValue;
    self2.changed.dispatch();
  };
  self2.registerDisposer(self2.changed.add(handleSelfUpdate));
  self2.registerDisposer(peer.changed.add(handlePeerUpdate));
  self2.registerDisposer(link.changed.add(handleLinkUpdate));
  handleLinkUpdate();
  return self2;
}
function makeSimpleLinked(self2, peer, link, operations) {
  return makeLinked(self2, peer, link, operations);
}
class Position extends RefCounted {
  constructor(coordinateSpace) {
    super();
    this.coordinateSpace = coordinateSpace;
    this.coordinates_ = kEmptyFloat32Vec;
    this.changed = new NullarySignal();
    this.registerDisposer(coordinateSpace.changed.add(() => {
      this.handleCoordinateSpaceChanged();
    }));
  }
  get valid() {
    return this.coordinateSpace.value.valid;
  }
  /**
   * Returns the position in voxels.
   */
  get value() {
    this.handleCoordinateSpaceChanged();
    return this.coordinates_;
  }
  reset() {
    this.curCoordinateSpace = void 0;
    this.coordinates_ = kEmptyFloat32Vec;
    this.changed.dispatch();
  }
  set value(coordinates) {
    const curCoordinateSpace = this.curCoordinateSpace;
    if (curCoordinateSpace === void 0 || !curCoordinateSpace.valid || curCoordinateSpace.rank !== coordinates.length) {
      return;
    }
    const coordinates_ = this.coordinates_;
    coordinates_.set(coordinates);
    this.changed.dispatch();
  }
  handleCoordinateSpaceChanged() {
    const coordinateSpace = this.coordinateSpace.value;
    const prevCoordinateSpace = this.curCoordinateSpace;
    if (coordinateSpace === prevCoordinateSpace) return;
    this.curCoordinateSpace = coordinateSpace;
    const rank = coordinateSpace.rank;
    if (!coordinateSpace.valid) return;
    if (prevCoordinateSpace === void 0 || !prevCoordinateSpace.valid) {
      let coordinates_ = this.coordinates_;
      if (coordinates_ !== void 0 && coordinates_.length === rank) ;
      else {
        coordinates_ = this.coordinates_ = new Float32Array(rank);
        getBoundingBoxCenter(coordinates_, coordinateSpace.bounds);
        for (let i = 0; i < rank; ++i) {
          coordinates_[i] = Math.floor(coordinates_[i]) + 0.5;
        }
      }
      this.changed.dispatch();
      return;
    }
    const newCoordinates = new Float32Array(rank);
    const prevCoordinates = this.coordinates_;
    const ids = coordinateSpace.ids, newScales = coordinateSpace.scales;
    const prevDimensionIds = prevCoordinateSpace.ids, oldScales = prevCoordinateSpace.scales;
    for (let newDim = 0; newDim < rank; ++newDim) {
      const newDimId = ids[newDim];
      const oldDim = prevDimensionIds.indexOf(newDimId);
      if (oldDim === -1) {
        newCoordinates[newDim] = getCenterBound(coordinateSpace.bounds.lowerBounds[newDim], coordinateSpace.bounds.upperBounds[newDim]);
      } else {
        newCoordinates[newDim] = prevCoordinates[oldDim] * (oldScales[oldDim] / newScales[newDim]);
      }
    }
    this.coordinates_ = newCoordinates;
    this.changed.dispatch();
  }
  toJSON() {
    if (!this.valid && this.coordinates_.length === 0) return void 0;
    this.handleCoordinateSpaceChanged();
    const value = this.value;
    if (value.length === 0) return void 0;
    return _Array$from(value);
  }
  restoreState(obj) {
    if (obj === void 0) {
      this.reset();
      return;
    }
    this.curCoordinateSpace = void 0;
    this.coordinates_ = Float32Array.from(parseArray(obj, verifyFiniteFloat));
    this.handleCoordinateSpaceChanged();
    this.changed.dispatch();
  }
  snapToVoxel() {
    this.handleCoordinateSpaceChanged();
    const coordinates_ = this.coordinates_;
    const rank = coordinates_.length;
    for (let i = 0; i < rank; ++i) {
      coordinates_[i] = Math.floor(coordinates_[i]) + 0.5;
    }
    this.changed.dispatch();
  }
  assign(other) {
    other.handleCoordinateSpaceChanged();
    const curCoordinateSpace = other.curCoordinateSpace, coordinates_ = other.coordinates_;
    this.curCoordinateSpace = curCoordinateSpace;
    this.coordinates_ = Float32Array.from(coordinates_);
    this.changed.dispatch();
  }
  /**
   * Get the offset of `a` relative to `b`.
   */
  static getOffset(a, b) {
    const aCoordinates = a.coordinates_;
    const bCoordinates = b.coordinates_;
    const rank = aCoordinates.length;
    if (rank === bCoordinates.length) {
      return subtract(new Float32Array(aCoordinates.length), aCoordinates, bCoordinates);
    }
    return void 0;
  }
  static addOffset(target, source, offset, scale2 = 1) {
    target.handleCoordinateSpaceChanged();
    const sourceCoordinates = source.value;
    if (offset !== void 0 && sourceCoordinates.length === offset.length) {
      scaleAndAdd(target.value, sourceCoordinates, offset, scale2);
      target.changed.dispatch();
    }
  }
  get legacyJsonView() {
    const self2 = this;
    return {
      changed: self2.changed,
      toJSON() {
        return self2.toJSON();
      },
      reset() {
        self2.reset();
      },
      restoreState(obj) {
        if (obj === void 0 || Array.isArray(obj)) {
          self2.restoreState(obj);
          return;
        }
        verifyObject(obj);
        optionallyRestoreFromJsonMember(obj, "voxelCoordinates", self2);
      }
    };
  }
}
function restoreLinkedFromJson(link, value, json2) {
  if (json2 === void 0 || _Object$keys(json2).length === 0) {
    link.value = NavigationLinkType.LINKED;
    return;
  }
  verifyObject(json2);
  link.value = NavigationLinkType.UNLINKED;
  verifyObjectProperty(json2, "value", (x) => {
    if (x !== void 0) {
      value.restoreState(x);
    }
  });
  verifyObjectProperty(json2, "link", (x) => link.restoreState(x));
}
class LinkedBase {
  constructor(peer, link = new TrackableNavigationLink()) {
    this.peer = peer;
    this.link = link;
  }
  get changed() {
    return this.value.changed;
  }
  toJSON() {
    const link = this.link;
    if (link.value === NavigationLinkType.LINKED) {
      return void 0;
    }
    return { link: link.toJSON(), value: this.getValueJson() };
  }
  getValueJson() {
    return this.value.toJSON();
  }
  reset() {
    this.link.value = NavigationLinkType.LINKED;
  }
  restoreState(obj) {
    restoreLinkedFromJson(this.link, this.value, obj);
  }
  copyToPeer() {
    if (this.link.value !== NavigationLinkType.LINKED) {
      this.link.value = NavigationLinkType.UNLINKED;
      this.peer.assign(this.value);
      this.link.value = NavigationLinkType.LINKED;
    }
  }
}
class SimpleLinkedBase extends LinkedBase {
  constructor(peer, link = new TrackableNavigationSimpleLink()) {
    super(peer, link);
  }
}
class LinkedPosition extends LinkedBase {
  constructor() {
    super(...arguments);
    this.value = makeLinked(new Position(this.peer.coordinateSpace), this.peer, this.link, {
      assign: (a, b) => a.assign(b),
      isValid: (a) => {
        return a.valid;
      },
      difference: Position.getOffset,
      add: Position.addOffset,
      subtract: (target, source, amount) => {
        Position.addOffset(target, source, amount, -1);
      }
    });
  }
}
function quaternionIsIdentity(q) {
  return q[0] === 0 && q[1] === 0 && q[2] === 0 && q[3] === 1;
}
class OrientationState extends RefCounted {
  constructor(orientation) {
    super();
    this.changed = new NullarySignal();
    if (orientation == null) {
      orientation = create$1();
    }
    this.orientation = orientation;
  }
  toJSON() {
    let orientation = this.orientation;
    normalize(this.orientation, this.orientation);
    if (quaternionIsIdentity(orientation)) {
      return void 0;
    }
    return Array.prototype.slice.call(this.orientation);
  }
  restoreState(obj) {
    try {
      parseFiniteVec(this.orientation, obj);
      normalize(this.orientation, this.orientation);
    } catch (ignoredError) {
      identity$1(this.orientation);
    }
    this.changed.dispatch();
  }
  reset() {
    identity$1(this.orientation);
    this.changed.dispatch();
  }
  snap() {
    let mat = create$5();
    fromQuat$1(mat, this.orientation);
    let usedAxes = [false, false, false];
    for (let i = 0; i < 3; ++i) {
      let maxComponent = 0;
      let argmaxComponent = 0;
      for (let j = 0; j < 3; ++j) {
        let value = mat[i * 3 + j];
        mat[i * 3 + j] = 0;
        if (usedAxes[j]) {
          continue;
        }
        if (Math.abs(value) > Math.abs(maxComponent)) {
          maxComponent = value;
          argmaxComponent = j;
        }
      }
      mat[i * 3 + argmaxComponent] = _Math$sign(maxComponent);
      usedAxes[argmaxComponent] = true;
    }
    fromMat3(this.orientation, mat);
    this.changed.dispatch();
  }
  /**
   * Returns a new OrientationState with orientation fixed to peerToSelf * peer.orientation.  Any
   * changes to the returned OrientationState will cause a corresponding change in peer, and vice
   * versa.
   */
  static makeRelative(peer, peerToSelf) {
    let self2 = new OrientationState(multiply$1(create$1(), peer.orientation, peerToSelf));
    let updatingPeer = false;
    self2.registerDisposer(peer.changed.add(() => {
      if (!updatingPeer) {
        updatingSelf = true;
        multiply$1(self2.orientation, peer.orientation, peerToSelf);
        self2.changed.dispatch();
        updatingSelf = false;
      }
    }));
    let updatingSelf = false;
    const selfToPeer = invert(create$1(), peerToSelf);
    self2.registerDisposer(self2.changed.add(() => {
      if (!updatingSelf) {
        updatingPeer = true;
        multiply$1(peer.orientation, self2.orientation, selfToPeer);
        peer.changed.dispatch();
        updatingPeer = false;
      }
    }));
    return self2;
  }
  assign(other) {
    copy$1(this.orientation, other.orientation);
    this.changed.dispatch();
  }
}
class LinkedOrientationState extends LinkedBase {
  constructor() {
    super(...arguments);
    this.value = makeLinked(new OrientationState(), this.peer, this.link, {
      assign: (a, b) => a.assign(b),
      isValid: () => true,
      difference: (a, b) => {
        const temp = create$1();
        return multiply$1(temp, invert(temp, b.orientation), a.orientation);
      },
      add: (target, source, amount) => {
        multiply$1(target.orientation, source.orientation, amount);
        target.changed.dispatch();
      },
      subtract: (target, source, amount) => {
        multiply$1(target.orientation, source.orientation, invert(tempQuat, amount));
        target.changed.dispatch();
      }
    });
  }
}
class TrackableRelativeDisplayScales extends RefCounted {
  constructor(coordinateSpace) {
    super();
    this.coordinateSpace = coordinateSpace;
    this.changed = new NullarySignal();
    this.curCoordinateSpace = emptyInvalidCoordinateSpace;
    this.value_ = { factors: new Float64Array(0) };
    this.registerDisposer(coordinateSpace.changed.add(() => this.update()));
    this.update();
  }
  get value() {
    return this.update();
  }
  reset() {
    this.value_ = { factors: new Float64Array(0) };
    this.curCoordinateSpace = emptyInvalidCoordinateSpace;
    this.changed.dispatch();
  }
  toJSON() {
    const json2 = {};
    let nonEmpty = false;
    const value = this.value;
    const factors = value.factors;
    var _curCoordinateSpace = this.curCoordinateSpace;
    const names = _curCoordinateSpace.names, rank = _curCoordinateSpace.rank;
    for (let i = 0; i < rank; ++i) {
      const factor = factors[i];
      if (factor === 1) continue;
      json2[names[i]] = factor;
      nonEmpty = true;
    }
    if (nonEmpty) return json2;
    return void 0;
  }
  restoreState(json2) {
    const coordinateSpace = this.coordinateSpace.value;
    const names = coordinateSpace.names, rank = coordinateSpace.rank;
    const factors = new Float64Array(rank);
    factors.fill(-1);
    if (json2 !== void 0) {
      const obj = verifyObject(json2);
      for (let i = 0; i < rank; ++i) {
        factors[i] = verifyObjectProperty(obj, names[i], (x) => x === void 0 ? 1 : verifyFinitePositiveFloat(x));
      }
    }
    this.value_ = { factors };
    this.curCoordinateSpace = coordinateSpace;
    this.changed.dispatch();
  }
  setFactors(factors) {
    const coordinateSpace = this.coordinateSpace.value;
    if (factors.length !== coordinateSpace.rank) return;
    this.value_ = { factors };
    this.curCoordinateSpace = coordinateSpace;
    this.changed.dispatch();
  }
  update() {
    const coordinateSpace = this.coordinateSpace.value;
    let value = this.value_;
    const curCoordinateSpace = this.curCoordinateSpace;
    if (curCoordinateSpace === coordinateSpace) return value;
    const oldDimensionIds = curCoordinateSpace.ids;
    const newDimensionIds = coordinateSpace.ids, rank = coordinateSpace.rank;
    const oldFactors = value.factors;
    const newFactors = new Float64Array(rank);
    newFactors.fill(1);
    for (let i = 0; i < rank; ++i) {
      const id = newDimensionIds[i];
      const oldIndex = oldDimensionIds.indexOf(id);
      if (oldIndex === -1) continue;
      newFactors[i] = oldFactors[oldIndex];
    }
    if (arraysEqual(newFactors, oldFactors)) return value;
    value = this.value_ = { factors: newFactors };
    this.curCoordinateSpace = coordinateSpace;
    this.changed.dispatch();
    return value;
  }
  assign(other) {
    this.setFactors(other.value.factors);
  }
}
function mapPerDimensionValues(arrayConstructor, input, oldCoordinateSpace, newCoordinateSpace, defaultValue) {
  if (oldCoordinateSpace === newCoordinateSpace) return input;
  const oldDimensionIds = oldCoordinateSpace.ids;
  const newRank = newCoordinateSpace.rank, newDimensionIds = newCoordinateSpace.ids;
  const output = new arrayConstructor(newRank);
  for (let newDim = 0; newDim < newRank; ++newDim) {
    const id = newDimensionIds[newDim];
    const oldDim = oldDimensionIds.indexOf(id);
    output[newDim] = oldDim === -1 ? defaultValue(newDim) : input[oldDim];
  }
  return output;
}
class LinkedRelativeDisplayScales extends LinkedBase {
  constructor() {
    super(...arguments);
    this.value = makeLinked(new TrackableRelativeDisplayScales(this.peer.coordinateSpace), this.peer, this.link, {
      assign: (target, source) => target.assign(source),
      difference: (a, b) => {
        const fa = a.value.factors;
        const coordinateSpace = a.coordinateSpace.value;
        const fb = b.value.factors;
        return {
          coordinateSpace,
          offsets: subtract(new Float64Array(fa.length), fa, fb)
        };
      },
      add: (target, source, delta) => {
        const newOffsets = mapPerDimensionValues(Float64Array, delta.offsets, delta.coordinateSpace, target.coordinateSpace.value, () => 0);
        target.setFactors(add(new Float64Array(newOffsets.length), newOffsets, source.value.factors));
      },
      subtract: (target, source, delta) => {
        const newOffsets = mapPerDimensionValues(Float64Array, delta.offsets, delta.coordinateSpace, target.coordinateSpace.value, () => 0);
        target.setFactors(subtract(new Float64Array(newOffsets.length), source.value.factors, newOffsets));
      },
      isValid: () => true
    });
  }
}
function getDisplayDimensionRenderInfo(coordinateSpace, displayDimensions, relativeDisplayScales) {
  const globalRank = coordinateSpace.rank, globalDimensionNames = coordinateSpace.names, units = coordinateSpace.units;
  const displayRank = displayDimensions.displayRank, displayDimensionIndices = displayDimensions.displayDimensionIndices;
  const canonicalVoxelFactors = new Float64Array(3);
  let voxelPhysicalScales = new Float64Array(3);
  let canonicalVoxelPhysicalSize;
  const factors = relativeDisplayScales.factors;
  const displayDimensionUnits = new Array(3);
  const displayDimensionScales = new Float64Array(3);
  canonicalVoxelFactors.fill(1);
  voxelPhysicalScales.fill(1);
  displayDimensionScales.fill(1);
  displayDimensionUnits.fill("");
  if (displayRank === 0) {
    canonicalVoxelPhysicalSize = 1;
  } else {
    canonicalVoxelPhysicalSize = Number.POSITIVE_INFINITY;
    const scales = coordinateSpace.scales;
    for (let i = 0; i < displayRank; ++i) {
      const dim = displayDimensionIndices[i];
      const s = voxelPhysicalScales[i] = factors[dim] * scales[dim];
      canonicalVoxelPhysicalSize = Math.min(canonicalVoxelPhysicalSize, s);
      displayDimensionUnits[i] = units[dim];
      displayDimensionScales[i] = scales[dim];
    }
    for (let i = 0; i < displayRank; ++i) {
      canonicalVoxelFactors[i] = voxelPhysicalScales[i] / canonicalVoxelPhysicalSize;
    }
  }
  return {
    globalRank,
    globalDimensionNames,
    displayRank,
    displayDimensionIndices,
    displayDimensionUnits,
    displayDimensionScales,
    canonicalVoxelFactors,
    voxelPhysicalScales,
    canonicalVoxelPhysicalSize
  };
}
function displayDimensionRenderInfosEqual(a, b) {
  return arraysEqual(a.globalDimensionNames, b.globalDimensionNames) && arraysEqual(a.displayDimensionIndices, b.displayDimensionIndices) && arraysEqual(a.canonicalVoxelFactors, b.canonicalVoxelFactors) && arraysEqual(a.voxelPhysicalScales, b.voxelPhysicalScales) && a.canonicalVoxelPhysicalSize === b.canonicalVoxelPhysicalSize && arraysEqual(a.displayDimensionUnits, b.displayDimensionUnits) && arraysEqual(a.displayDimensionScales, b.displayDimensionScales);
}
class WatchableDisplayDimensionRenderInfo extends RefCounted {
  constructor(relativeDisplayScales, displayDimensions) {
    super();
    this.relativeDisplayScales = relativeDisplayScales;
    this.displayDimensions = displayDimensions;
    this.changed = new NullarySignal();
    this.curRelativeDisplayScales = this.relativeDisplayScales.value;
    this.curDisplayDimensions = this.displayDimensions.value;
    this.curCoordinateSpace = this.relativeDisplayScales.coordinateSpace.value;
    this.value_ = getDisplayDimensionRenderInfo(this.curCoordinateSpace, this.curDisplayDimensions, this.curRelativeDisplayScales);
    this.registerDisposer(relativeDisplayScales);
    this.registerDisposer(displayDimensions);
    const maybeUpdateValue = () => {
      this.value;
    };
    this.registerDisposer(relativeDisplayScales.changed.add(maybeUpdateValue));
    this.registerDisposer(displayDimensions.changed.add(maybeUpdateValue));
  }
  get value() {
    var _relativeDisplayScale = this.relativeDisplayScales;
    const relativeDisplayScales = _relativeDisplayScale.value, coordinateSpace = _relativeDisplayScale.coordinateSpace.value, displayDimensions = this.displayDimensions.value, curRelativeDisplayScales = this.curRelativeDisplayScales, curDisplayDimensions = this.curDisplayDimensions, curCoordinateSpace = this.curCoordinateSpace;
    let value = this.value_;
    if (curRelativeDisplayScales !== relativeDisplayScales || curDisplayDimensions !== displayDimensions || curCoordinateSpace !== coordinateSpace) {
      this.curRelativeDisplayScales = relativeDisplayScales;
      this.curDisplayDimensions = displayDimensions;
      this.curCoordinateSpace = coordinateSpace;
      const newValue = getDisplayDimensionRenderInfo(coordinateSpace, displayDimensions, relativeDisplayScales);
      if (!displayDimensionRenderInfosEqual(value, newValue)) {
        this.value_ = value = newValue;
        this.changed.dispatch();
      }
    }
    return value;
  }
}
class TrackableDisplayDimensions extends RefCounted {
  constructor(coordinateSpace) {
    super();
    this.coordinateSpace = coordinateSpace;
    this.changed = new NullarySignal();
    this.default_ = true;
    this.value_ = void 0;
    this.registerDisposer(this.coordinateSpace.changed.add(this.changed.dispatch));
    this.update();
  }
  get value() {
    this.update();
    return this.value_;
  }
  update() {
    const coordinateSpace = this.coordinateSpace.value;
    const value = this.value_;
    if (value !== void 0 && value.coordinateSpace === coordinateSpace) {
      return;
    }
    if (value === void 0 || this.default_) {
      this.setToDefault(coordinateSpace);
      return;
    }
    const newDimensionIndices = new Int32Array(3);
    const oldDimensionIds = value.coordinateSpace.ids;
    const newDimensionIds = coordinateSpace.ids;
    const oldDimensionIndices = value.displayDimensionIndices;
    const oldRank = value.displayRank;
    let newRank = 0;
    for (let i = 0; i < oldRank; ++i) {
      const newDim = newDimensionIds.indexOf(oldDimensionIds[oldDimensionIndices[i]]);
      if (newDim === -1) continue;
      newDimensionIndices[newRank] = newDim;
      ++newRank;
    }
    newDimensionIndices.fill(-1, newRank);
    if (newRank === 0) {
      this.default_ = true;
      this.setToDefault(coordinateSpace);
      return;
    }
    this.assignValue(coordinateSpace, newRank, newDimensionIndices);
    this.changed.dispatch();
  }
  setToDefault(coordinateSpace) {
    const displayRank = Math.min(coordinateSpace.rank, 3);
    const displayDimensionIndices = new Int32Array(3);
    displayDimensionIndices.fill(-1);
    for (let i = 0; i < displayRank; ++i) {
      displayDimensionIndices[i] = i;
    }
    this.assignValue(coordinateSpace, displayRank, displayDimensionIndices);
  }
  assignValue(coordinateSpace, displayRank, displayDimensionIndices) {
    this.value_ = {
      coordinateSpace,
      displayRank,
      displayDimensionIndices
    };
    this.changed.dispatch();
  }
  reset() {
    this.default_ = true;
    this.value_ = void 0;
    this.changed.dispatch();
  }
  restoreState(obj) {
    if (obj === void 0) {
      this.reset();
      return;
    }
    const displayDimensionNames = dimensionNamesFromJson(obj);
    if (displayDimensionNames.length > 3) {
      throw new Error("Number of spatial dimensions must be <= 3");
    }
    const coordinateSpace = this.coordinateSpace.value;
    const displayDimensionIndices = new Int32Array(3);
    displayDimensionIndices.fill(-1);
    const names = coordinateSpace.names;
    let displayRank = 0;
    for (const name2 of displayDimensionNames) {
      const index2 = names.indexOf(name2);
      if (index2 === -1) continue;
      displayDimensionIndices[displayRank++] = index2;
    }
    if (displayRank === 0) {
      this.reset();
      return;
    }
    this.default_ = false;
    this.assignValue(coordinateSpace, displayRank, displayDimensionIndices);
  }
  get default() {
    this.update();
    return this.default_;
  }
  set default(value) {
    if (this.default_ === value) return;
    if (value) {
      this.default_ = true;
      this.setToDefault(this.coordinateSpace.value);
    } else {
      this.default_ = false;
      this.changed.dispatch();
    }
  }
  setDimensionIndices(rank, dimensionIndices) {
    this.default_ = false;
    this.assignValue(this.coordinateSpace.value, rank, dimensionIndices);
  }
  toJSON() {
    if (this.default_) return void 0;
    const value = this.value;
    const displayDimensionNames = [];
    const displayRank = value.displayRank, displayDimensionIndices = value.displayDimensionIndices, names = value.coordinateSpace.names;
    if (displayRank === 0) return void 0;
    for (let i = 0; i < displayRank; ++i) {
      displayDimensionNames[i] = names[displayDimensionIndices[i]];
    }
    return displayDimensionNames;
  }
  assign(other) {
    if (other.default) {
      this.default = true;
    } else {
      var _other$value = other.value;
      const displayRank = _other$value.displayRank, displayDimensionIndices = _other$value.displayDimensionIndices;
      this.setDimensionIndices(displayRank, displayDimensionIndices);
    }
  }
}
class LinkedDisplayDimensions extends SimpleLinkedBase {
  constructor(peer) {
    super(peer);
    this.value = makeSimpleLinked(new TrackableDisplayDimensions(this.peer.coordinateSpace), this.peer, this.link, {
      assign: (target, source) => target.assign(source),
      isValid: () => true
    });
  }
}
class DisplayPose extends RefCounted {
  constructor(position, displayDimensionRenderInfo, orientation) {
    super();
    this.position = position;
    this.displayDimensionRenderInfo = displayDimensionRenderInfo;
    this.orientation = orientation;
    this.changed = new NullarySignal();
    this.registerDisposer(position);
    this.registerDisposer(orientation);
    this.registerDisposer(displayDimensionRenderInfo);
    this.registerDisposer(position.changed.add(this.changed.dispatch));
    this.registerDisposer(orientation.changed.add(this.changed.dispatch));
    this.registerDisposer(displayDimensionRenderInfo.changed.add(this.changed.dispatch));
  }
  get displayDimensions() {
    return this.displayDimensionRenderInfo.displayDimensions;
  }
  get relativeDisplayScales() {
    return this.displayDimensionRenderInfo.relativeDisplayScales;
  }
  get valid() {
    return this.position.valid;
  }
  /**
   * Resets everything.
   */
  reset() {
    this.position.reset();
    this.orientation.reset();
    this.displayDimensions.reset();
  }
  updateDisplayPosition(fun, temp = tempVec3$5) {
    var _position = this.position;
    const coordinateSpace = _position.coordinateSpace.value, voxelCoordinates = _position.value;
    var _displayDimensions$va = this.displayDimensions.value;
    const displayDimensionIndices = _displayDimensions$va.displayDimensionIndices, displayRank = _displayDimensions$va.displayRank;
    if (coordinateSpace === void 0) return false;
    temp.fill(0);
    for (let i = 0; i < displayRank; ++i) {
      const dim = displayDimensionIndices[i];
      temp[i] = voxelCoordinates[dim];
    }
    if (fun(temp) !== false) {
      for (let i = 0; i < displayRank; ++i) {
        const dim = displayDimensionIndices[i];
        voxelCoordinates[dim] = temp[i];
      }
      this.position.changed.dispatch();
      return true;
    }
    return false;
  }
  // Transform from view coordinates to global spatial coordinates.
  toMat4(mat, zoom) {
    fromQuat(mat, this.orientation.orientation);
    const voxelCoordinates = this.position.value;
    var _displayDimensionRend = this.displayDimensionRenderInfo.value;
    const canonicalVoxelFactors = _displayDimensionRend.canonicalVoxelFactors, displayDimensionIndices = _displayDimensionRend.displayDimensionIndices;
    for (let i = 0; i < 3; ++i) {
      const dim = displayDimensionIndices[i];
      const scale2 = zoom / canonicalVoxelFactors[i];
      mat[i] *= scale2;
      mat[4 + i] *= scale2;
      mat[8 + i] *= scale2;
      mat[12 + i] = voxelCoordinates[dim] || 0;
    }
  }
  toMat3(mat, zoom) {
    fromQuat$1(mat, this.orientation.orientation);
    var _displayDimensionRend2 = this.displayDimensionRenderInfo.value;
    const canonicalVoxelFactors = _displayDimensionRend2.canonicalVoxelFactors, displayRank = _displayDimensionRend2.displayRank;
    for (let i = 0; i < displayRank; ++i) {
      const scale2 = zoom / canonicalVoxelFactors[i];
      mat[i] *= scale2;
      mat[3 + i] *= scale2;
      mat[6 + i] *= scale2;
    }
  }
  /**
   * Snaps the orientation to the nearest axis-aligned orientation, and
   * snaps the position to the nearest voxel.
   */
  snap() {
    this.orientation.snap();
    this.position.snapToVoxel();
    this.changed.dispatch();
  }
  translateDimensionRelative(dimensionIndex, adjustment) {
    if (!this.valid) {
      return;
    }
    const position = this.position;
    const voxelCoordinates = position.value;
    var _position$coordinateS = position.coordinateSpace.value.bounds;
    const lowerBounds = _position$coordinateS.lowerBounds, upperBounds = _position$coordinateS.upperBounds;
    let newValue = voxelCoordinates[dimensionIndex] + adjustment;
    if (adjustment > 0) {
      const bound = upperBounds[dimensionIndex];
      if (_Number$isFinite(bound)) {
        newValue = Math.min(newValue, Math.ceil(bound - 1));
      }
    } else {
      const bound = lowerBounds[dimensionIndex];
      if (_Number$isFinite(bound)) {
        newValue = Math.max(newValue, Math.floor(bound));
      }
    }
    voxelCoordinates[dimensionIndex] = newValue;
    position.changed.dispatch();
  }
  translateVoxelsRelative(translation, round = false) {
    if (!this.valid) {
      return;
    }
    const temp = transformQuat(tempVec3$5, translation, this.orientation.orientation);
    const position = this.position;
    const voxelCoordinates = position.value;
    var _displayDimensions$va2 = this.displayDimensions.value;
    const displayDimensionIndices = _displayDimensions$va2.displayDimensionIndices, displayRank = _displayDimensions$va2.displayRank;
    var _position$coordinateS2 = position.coordinateSpace.value.bounds;
    const lowerBounds = _position$coordinateS2.lowerBounds, upperBounds = _position$coordinateS2.upperBounds;
    for (let i = 0; i < displayRank; ++i) {
      const dim = displayDimensionIndices[i];
      const adjustment = temp[i];
      if (adjustment === 0) continue;
      let newValue = voxelCoordinates[dim] + adjustment;
      if (adjustment > 0) {
        const bound = upperBounds[dim];
        if (_Number$isFinite(bound)) {
          newValue = Math.min(newValue, Math.ceil(bound - 1));
        }
      } else {
        const bound = lowerBounds[dim];
        if (_Number$isFinite(bound)) {
          newValue = Math.max(newValue, Math.floor(bound));
        }
      }
      if (round) newValue = Math.floor(newValue) + 0.5;
      voxelCoordinates[dim] = newValue;
    }
    this.position.changed.dispatch();
  }
  rotateRelative(axis, angle) {
    var temp = create$1();
    setAxisAngle(temp, axis, angle);
    var orientation = this.orientation.orientation;
    multiply$1(orientation, orientation, temp);
    this.orientation.changed.dispatch();
  }
  rotateAbsolute(axis, angle, fixedPoint) {
    var _position2 = this.position;
    const coordinateSpace = _position2.coordinateSpace.value, voxelCoordinates = _position2.value;
    if (coordinateSpace === void 0) return;
    const relativeDisplayScales = this.relativeDisplayScales.value.factors;
    var _displayDimensions$va3 = this.displayDimensions.value;
    const displayDimensionIndices = _displayDimensions$va3.displayDimensionIndices, displayRank = _displayDimensions$va3.displayRank;
    const scales = coordinateSpace.scales;
    const temp = create$1();
    setAxisAngle(temp, axis, angle);
    const orientation = this.orientation.orientation;
    const fixedPointLocal = tempVec3$5;
    tempVec3$5.fill(0);
    for (let i = 0; i < displayRank; ++i) {
      const dim = displayDimensionIndices[i];
      const diff = fixedPoint[dim] - voxelCoordinates[dim];
      fixedPointLocal[i] = diff * scales[dim] * relativeDisplayScales[dim];
    }
    const invOrientation = invert(tempQuat, orientation);
    transformQuat(fixedPointLocal, fixedPointLocal, invOrientation);
    multiply$1(orientation, temp, orientation);
    transformQuat(fixedPointLocal, fixedPointLocal, orientation);
    for (let i = 0; i < displayRank; ++i) {
      const dim = displayDimensionIndices[i];
      voxelCoordinates[dim] = fixedPoint[dim] - fixedPointLocal[i] / (scales[dim] * relativeDisplayScales[dim]);
    }
    this.position.changed.dispatch();
    this.orientation.changed.dispatch();
  }
  translateNonDisplayDimension(nonSpatialDimensionIndex, adjustment) {
    if (!this.valid) return;
    const displayDimensionIndices = this.displayDimensions.value.displayDimensionIndices;
    const position = this.position;
    const rank = position.coordinateSpace.value.rank;
    for (let i = 0; i < rank; ++i) {
      if (displayDimensionIndices.indexOf(i) !== -1) continue;
      if (nonSpatialDimensionIndex-- === 0) {
        this.translateDimensionRelative(i, adjustment);
        return;
      }
    }
  }
}
class LinkedZoomState extends LinkedBase {
  constructor(peer, displayDimensionRenderInfo) {
    super(peer);
    this.value = (() => {
      const self2 = new peer.constructor(displayDimensionRenderInfo);
      const assign = (target, source) => {
        target.assign(source);
      };
      const difference = (a, b) => {
        return a.value / b.value * (a.canonicalVoxelPhysicalSize / b.canonicalVoxelPhysicalSize);
      };
      const add2 = (target, source, amount) => {
        target.setPhysicalScale(source.value * amount, source.canonicalVoxelPhysicalSize);
      };
      const subtract2 = (target, source, amount) => {
        target.setPhysicalScale(source.value / amount, source.canonicalVoxelPhysicalSize);
      };
      const isValid = (x) => x.coordinateSpaceValue.valid && x.canonicalVoxelPhysicalSize !== 0;
      makeLinked(self2, this.peer, this.link, { assign, isValid, difference, add: add2, subtract: subtract2 });
      return self2;
    })();
  }
}
function linkedStateLegacyJsonView(linked) {
  return {
    changed: linked.changed,
    toJSON() {
      return linked.toJSON();
    },
    restoreState(obj) {
      restoreLinkedFromJson(linked.link, linked.value.legacyJsonView, obj);
    },
    reset() {
      linked.reset();
    }
  };
}
class TrackableZoom extends RefCounted {
  constructor(displayDimensionRenderInfo) {
    super();
    this.displayDimensionRenderInfo = displayDimensionRenderInfo;
    this.changed = new NullarySignal();
    this.curCanonicalVoxelPhysicalSize = 0;
    this.value_ = Number.NaN;
    this.legacyValue_ = Number.NaN;
    this.registerDisposer(displayDimensionRenderInfo);
    this.registerDisposer(displayDimensionRenderInfo.changed.add(() => this.handleCoordinateSpaceChanged()));
    this.registerDisposer(displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace.changed.add(() => this.handleCoordinateSpaceChanged()));
    this.handleCoordinateSpaceChanged();
  }
  /**
   * Zoom factor.  For cross section views, in canonical voxels per viewport pixel.  For projection
   * views, in canonical voxels per viewport height (for orthographic projection).
   */
  get value() {
    this.handleCoordinateSpaceChanged();
    return this.value_;
  }
  set value(value) {
    const canonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;
    if (_Object$is(value, this.value_) && canonicalVoxelPhysicalSize === this.curCanonicalVoxelPhysicalSize) {
      return;
    }
    this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;
    this.legacyValue_ = Number.NaN;
    this.value_ = value;
    this.changed.dispatch();
  }
  get canonicalVoxelPhysicalSize() {
    return this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
  }
  get coordinateSpaceValue() {
    return this.displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace.value;
  }
  /**
   * Sets the zoom factor in the legacy units.  For cross section views, `1e-9` spatial units per
   * viewport pixel.  For projection views, `2 * 100 * Math.tan(Math.PI / 8) * 1e-9` spatial units
   * per viewport height (for orthographic projection).
   */
  set legacyValue(value) {
    if (_Object$is(value, this.legacyValue_)) return;
    this.value_ = Number.NaN;
    this.legacyValue_ = value;
    this.curCanonicalVoxelPhysicalSize = 0;
    this.changed.dispatch();
  }
  get legacyValue() {
    return this.legacyValue_;
  }
  handleCoordinateSpaceChanged() {
    const value_ = this.value_;
    var _displayDimensionRend3 = this.displayDimensionRenderInfo;
    const canonicalVoxelPhysicalSize = _displayDimensionRend3.value.canonicalVoxelPhysicalSize, coordinateSpace = _displayDimensionRend3.relativeDisplayScales.coordinateSpace.value;
    const curCanonicalVoxelPhysicalSize = this.curCanonicalVoxelPhysicalSize;
    if (!_Number$isNaN(value_) && canonicalVoxelPhysicalSize === curCanonicalVoxelPhysicalSize) {
      return;
    }
    if (!_Number$isNaN(value_)) {
      if (curCanonicalVoxelPhysicalSize !== 0) {
        this.value_ = value_ * (curCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize);
        this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;
        this.changed.dispatch();
      }
      return;
    }
    if (!coordinateSpace.valid || canonicalVoxelPhysicalSize === 0) {
      return;
    }
    this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;
    this.value_ = this.getDefaultValue();
    this.changed.dispatch();
  }
  toJSON() {
    const value = this.value;
    return _Number$isNaN(value) ? void 0 : value;
  }
  restoreState(obj) {
    this.curCanonicalVoxelPhysicalSize = 0;
    this.legacyValue_ = Number.NaN;
    if (obj === void 0) {
      this.value_ = Number.NaN;
    } else {
      this.value_ = verifyFinitePositiveFloat(obj);
    }
    this.changed.dispatch();
  }
  reset() {
    this.curCanonicalVoxelPhysicalSize = 0;
    this.value_ = Number.NaN;
    this.legacyValue_ = Number.NaN;
    this.changed.dispatch();
  }
  get legacyJsonView() {
    const self2 = this;
    return {
      changed: self2.changed,
      toJSON() {
        return self2.toJSON();
      },
      reset() {
        return self2.reset();
      },
      restoreState(obj) {
        self2.legacyValue = verifyFinitePositiveFloat(obj);
      }
    };
  }
  setPhysicalScale(scaleInCanonicalVoxels, canonicalVoxelPhysicalSize) {
    const curCanonicalVoxelPhysicalSize = this.curCanonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;
    this.value = scaleInCanonicalVoxels * (canonicalVoxelPhysicalSize / curCanonicalVoxelPhysicalSize);
  }
  assign(source) {
    const legacyValue = source.legacyValue;
    if (!_Number$isNaN(legacyValue)) {
      this.legacyValue = legacyValue;
    } else {
      this.setPhysicalScale(source.value, source.canonicalVoxelPhysicalSize);
    }
  }
}
class TrackableCrossSectionZoom extends TrackableZoom {
  getDefaultValue() {
    const legacyValue_ = this.legacyValue_;
    if (_Number$isNaN(legacyValue_)) {
      return 1;
    }
    const canonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;
    return this.legacyValue_ * 1e-9 / canonicalVoxelPhysicalSize;
  }
}
class TrackableProjectionZoom extends TrackableZoom {
  getDefaultValue() {
    const legacyValue_ = this.legacyValue_;
    if (!_Number$isNaN(legacyValue_)) {
      this.legacyValue_ = Number.NaN;
      const canonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;
      return 2 * 100 * Math.tan(Math.PI / 8) * 1e-9 * legacyValue_ / canonicalVoxelPhysicalSize;
    }
    var _coordinateSpaceValue = this.coordinateSpaceValue.bounds;
    const lowerBounds = _coordinateSpaceValue.lowerBounds, upperBounds = _coordinateSpaceValue.upperBounds;
    var _displayDimensionRend4 = this.displayDimensionRenderInfo.value;
    const canonicalVoxelFactors = _displayDimensionRend4.canonicalVoxelFactors, displayDimensionIndices = _displayDimensionRend4.displayDimensionIndices;
    let value = canonicalVoxelFactors.reduce((x, factor, i) => {
      const dim = displayDimensionIndices[i];
      const extent = (upperBounds[dim] - lowerBounds[dim]) * factor;
      return Math.max(x, extent);
    }, 0);
    if (!_Number$isFinite(value)) {
      value = 1024;
    } else {
      value = 2 ** Math.ceil(_Math$log$1(value));
    }
    return value;
  }
}
class TrackableDepthRange extends RefCounted {
  constructor(defaultValue, displayDimensionRenderInfo) {
    super();
    this.defaultValue = defaultValue;
    this.displayDimensionRenderInfo = displayDimensionRenderInfo;
    this.changed = new NullarySignal();
    this.value_ = defaultValue;
    this.canonicalVoxelPhysicalSize = displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
    this.registerDisposer(displayDimensionRenderInfo.changed.add(() => {
      this.value;
    }));
  }
  get value() {
    let value_ = this.value_;
    if (value_ > 0) {
      const canonicalVoxelPhysicalSize = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
      const prevCanonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;
      if (canonicalVoxelPhysicalSize !== prevCanonicalVoxelPhysicalSize) {
        this.canonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;
        value_ = this.value_ = value_ = prevCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize;
        this.changed.dispatch();
      }
    }
    return value_;
  }
  set value(value) {
    if (value === this.value) return;
    this.value_ = value;
    const canonicalVoxelPhysicalSize = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
    this.canonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;
    this.changed.dispatch();
  }
  toJSON() {
    const value = this.value;
    if (value === this.defaultValue) return void 0;
    return value;
  }
  reset() {
    this.value = this.defaultValue;
  }
  restoreState(obj) {
    if (typeof obj !== "number" || !_Number$isFinite(obj) || obj === 0) {
      this.value = this.defaultValue;
    } else {
      this.value = obj;
    }
  }
  setValueAbsolute(value, sourceCanonicalVoxelPhysicalSize) {
    if (value > 0) {
      const canonicalVoxelPhysicalSize = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
      value = value * (sourceCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize);
    }
    this.value = value;
  }
  assign(other) {
    this.setValueAbsolute(other.value, other.canonicalVoxelPhysicalSize);
  }
}
class LinkedDepthRange extends SimpleLinkedBase {
  constructor(peer, displayDimensionRenderInfo) {
    super(peer);
    this.value = makeSimpleLinked(new TrackableDepthRange(peer.defaultValue, displayDimensionRenderInfo), this.peer, this.link, {
      assign: (target, source) => target.assign(source),
      isValid: () => true
    });
  }
}
class NavigationState extends RefCounted {
  constructor(pose, zoomFactor, depthRange) {
    super();
    this.pose = pose;
    this.zoomFactor = zoomFactor;
    this.depthRange = depthRange;
    this.changed = new NullarySignal();
    this.registerDisposer(pose);
    this.registerDisposer(zoomFactor);
    this.registerDisposer(depthRange);
    this.registerDisposer(this.pose.changed.add(this.changed.dispatch));
    this.registerDisposer(this.zoomFactor.changed.add(this.changed.dispatch));
    this.registerDisposer(this.depthRange.changed.add(this.changed.dispatch));
  }
  get coordinateSpace() {
    return this.pose.position.coordinateSpace;
  }
  /**
   * Resets everything.
   */
  reset() {
    this.pose.reset();
    this.zoomFactor.reset();
  }
  get position() {
    return this.pose.position;
  }
  get displayDimensions() {
    return this.pose.displayDimensions;
  }
  get relativeDisplayScales() {
    return this.pose.relativeDisplayScales;
  }
  get displayDimensionRenderInfo() {
    return this.pose.displayDimensionRenderInfo;
  }
  toMat4(mat) {
    this.pose.toMat4(mat, this.zoomFactor.value);
  }
  toMat3(mat) {
    this.pose.toMat3(mat, this.zoomFactor.value);
  }
  get relativeDepthRange() {
    let depthRange = this.depthRange.value;
    if (depthRange > 0) {
      depthRange /= this.zoomFactor.value;
    } else {
      depthRange *= -1;
    }
    return depthRange;
  }
  get valid() {
    return this.pose.valid && !_Number$isNaN(this.zoomFactor.value);
  }
  zoomBy(factor) {
    this.zoomFactor.value *= factor;
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MESH_LAYER_RPC_ID = "mesh/MeshLayer";
const MULTISCALE_MESH_LAYER_RPC_ID = "mesh/MultiscaleMeshLayer";
const FRAGMENT_SOURCE_RPC_ID = "mesh/FragmentSource";
const MULTISCALE_FRAGMENT_SOURCE_RPC_ID = "mesh/MultiscaleFragmentSource";
var VertexPositionFormat;
(function(VertexPositionFormat2) {
  VertexPositionFormat2[VertexPositionFormat2["float32"] = 0] = "float32";
  VertexPositionFormat2[VertexPositionFormat2["uint10"] = 1] = "uint10";
  VertexPositionFormat2[VertexPositionFormat2["uint16"] = 2] = "uint16";
})(VertexPositionFormat || (VertexPositionFormat = {}));
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getOctreeChildIndex(x, y, z) {
  return x & 1 | y << 1 & 2 | z << 2 & 4;
}
function getDesiredMultiscaleMeshChunks(manifest, modelViewProjection, clippingPlanes, detailCutoff, viewportWidth, viewportHeight, callback) {
  const octree = manifest.octree, lodScales = manifest.lodScales, chunkGridSpatialOrigin = manifest.chunkGridSpatialOrigin, chunkShape = manifest.chunkShape;
  const maxLod = lodScales.length - 1;
  const m00 = modelViewProjection[0], m01 = modelViewProjection[4], m02 = modelViewProjection[8], m10 = modelViewProjection[1], m11 = modelViewProjection[5], m12 = modelViewProjection[9], m30 = modelViewProjection[3], m31 = modelViewProjection[7], m32 = modelViewProjection[11], m33 = modelViewProjection[15];
  const minWXcoeff = m30 > 0 ? 0 : 1;
  const minWYcoeff = m31 > 0 ? 0 : 1;
  const minWZcoeff = m32 > 0 ? 0 : 1;
  const nearA = clippingPlanes[4 * 4], nearB = clippingPlanes[4 * 4 + 1], nearC = clippingPlanes[4 * 4 + 2], nearD = clippingPlanes[4 * 4 + 3];
  function getPointW(x, y, z) {
    return m30 * x + m31 * y + m32 * z + m33;
  }
  function getBoxW(xLower, yLower, zLower, xUpper, yUpper, zUpper) {
    return getPointW(xLower + minWXcoeff * (xUpper - xLower), yLower + minWYcoeff * (yUpper - yLower), zLower + minWZcoeff * (zUpper - zLower));
  }
  const minWClip = getPointW(-nearD * nearA, -nearD * nearB, -nearD * nearC);
  const objectXLower = manifest.clipLowerBound[0], objectYLower = manifest.clipLowerBound[1], objectZLower = manifest.clipLowerBound[2];
  const objectXUpper = manifest.clipUpperBound[0], objectYUpper = manifest.clipUpperBound[1], objectZUpper = manifest.clipUpperBound[2];
  const xScale = Math.sqrt((m00 * viewportWidth) ** 2 + (m10 * viewportHeight) ** 2);
  const yScale = Math.sqrt((m01 * viewportWidth) ** 2 + (m11 * viewportHeight) ** 2);
  const zScale = Math.sqrt((m02 * viewportWidth) ** 2 + (m12 * viewportHeight) ** 2);
  const scaleFactor = Math.max(xScale, yScale, zScale);
  function handleChunk(lod, row, priorLodScale) {
    const size = 1 << lod;
    const rowOffset = row * 5;
    const gridX = octree[rowOffset], gridY = octree[rowOffset + 1], gridZ = octree[rowOffset + 2], childBegin = octree[rowOffset + 3], childEndAndEmpty = octree[rowOffset + 4];
    let xLower = gridX * size * chunkShape[0] + chunkGridSpatialOrigin[0], yLower = gridY * size * chunkShape[1] + chunkGridSpatialOrigin[1], zLower = gridZ * size * chunkShape[2] + chunkGridSpatialOrigin[2];
    let xUpper = xLower + size * chunkShape[0], yUpper = yLower + size * chunkShape[1], zUpper = zLower + size * chunkShape[2];
    xLower = Math.max(xLower, objectXLower);
    yLower = Math.max(yLower, objectYLower);
    zLower = Math.max(zLower, objectZLower);
    xUpper = Math.min(xUpper, objectXUpper);
    yUpper = Math.min(yUpper, objectYUpper);
    zUpper = Math.min(zUpper, objectZUpper);
    if (isAABBVisible(xLower, yLower, zLower, xUpper, yUpper, zUpper, clippingPlanes)) {
      const minW = Math.max(minWClip, getBoxW(xLower, yLower, zLower, xUpper, yUpper, zUpper));
      const pixelSize = minW / scaleFactor;
      if (priorLodScale === 0 || pixelSize * detailCutoff < priorLodScale) {
        const lodScale = lodScales[lod];
        if (lodScale !== 0) {
          callback(lod, row, lodScale / pixelSize, childEndAndEmpty >>> 31);
        }
        if (lod > 0 && (lodScale === 0 || pixelSize * detailCutoff < lodScale)) {
          const nextPriorLodScale = lodScale === 0 ? priorLodScale : lodScale;
          const childEnd = (childEndAndEmpty & 2147483647) >>> 0;
          for (let childRow = childBegin; childRow < childEnd; ++childRow) {
            handleChunk(lod - 1, childRow, nextPriorLodScale);
          }
        }
      }
    }
  }
  handleChunk(maxLod, octree.length / 5 - 1, 0);
}
function getMultiscaleChunksToDraw(manifest, modelViewProjection, clippingPlanes, detailCutoff, viewportWidth, viewportHeight, hasChunk, callback) {
  const lodScales = manifest.lodScales;
  let maxLod = 0;
  while (maxLod + 1 < lodScales.length && lodScales[maxLod + 1] !== 0) {
    ++maxLod;
  }
  const stackEntryStride = 3;
  const stack = [];
  let stackDepth = 0;
  let priorSubChunkIndex = 0;
  function emitChunksUpTo(targetStackIndex, subChunkIndex) {
    while (true) {
      if (stackDepth === 0) return;
      const stackIndex = stackDepth - 1;
      const entryLod = maxLod - stackIndex;
      const entryRow = stack[stackIndex * stackEntryStride];
      const numSubChunks = entryLod === 0 ? 1 : 8;
      const entrySubChunkIndex = stack[stackIndex * stackEntryStride + 1];
      const entryRenderScale = stack[stackIndex * stackEntryStride + 2];
      if (targetStackIndex === stackDepth) {
        const endSubChunk = subChunkIndex & numSubChunks - 1;
        if (priorSubChunkIndex !== endSubChunk && entryRow !== -1) {
          callback(entryLod, entryRow, priorSubChunkIndex, endSubChunk, entryRenderScale);
        }
        priorSubChunkIndex = endSubChunk + 1;
        return;
      }
      if (priorSubChunkIndex !== numSubChunks && entryRow !== -1) {
        callback(entryLod, entryRow, priorSubChunkIndex, numSubChunks, entryRenderScale);
      }
      priorSubChunkIndex = entrySubChunkIndex + 1;
      --stackDepth;
    }
  }
  let priorMissingLod = 0;
  const octree = manifest.octree;
  getDesiredMultiscaleMeshChunks(manifest, modelViewProjection, clippingPlanes, detailCutoff, viewportWidth, viewportHeight, (lod, row, renderScale, empty) => {
    if (!empty && !hasChunk(lod, row, renderScale)) {
      priorMissingLod = Math.max(lod, priorMissingLod);
      return;
    }
    if (lod < priorMissingLod) {
      return;
    }
    priorMissingLod = 0;
    const rowOffset = row * 5;
    const x = octree[rowOffset], y = octree[rowOffset + 1], z = octree[rowOffset + 2];
    const subChunkIndex = getOctreeChildIndex(x, y, z);
    const stackIndex = maxLod - lod;
    emitChunksUpTo(stackIndex, subChunkIndex);
    const stackOffset = stackIndex * stackEntryStride;
    stack[stackOffset] = empty ? -1 : row;
    stack[stackOffset + 1] = subChunkIndex;
    stack[stackOffset + 2] = renderScale;
    priorSubChunkIndex = 0;
    stackDepth = stackIndex + 1;
  });
  emitChunksUpTo(0, 0);
}
function getMultiscaleFragmentKey(objectKey, lod, chunkIndex) {
  return `${objectKey}/${lod}:${chunkIndex}`;
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PerspectiveViewRenderLayer extends VisibilityTrackedRenderLayer {
  draw(renderContext, attachment) {
  }
  isReady(renderContext, attachment) {
    return true;
  }
  get transparentPickEnabled() {
    return true;
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const k1 = 3432918353;
const k2 = 461845907;
function hashCombine(state, value) {
  value >>>= 0;
  state >>>= 0;
  value = _Math$imul(value, k1) >>> 0;
  value = (value << 15 | value >>> 17) >>> 0;
  value = _Math$imul(value, k2) >>> 0;
  state = (state ^ value) >>> 0;
  state = (state << 13 | state >>> 19) >>> 0;
  state = state * 5 + 3864292196 >>> 0;
  return state;
}
var _for$1;
var hasRequired_for$1;
function require_for$1() {
  if (hasRequired_for$1) return _for$1;
  hasRequired_for$1 = 1;
  requireEs6_symbol();
  _for$1 = require_core().Symbol["for"];
  return _for$1;
}
var _for;
var hasRequired_for;
function require_for() {
  if (hasRequired_for) return _for;
  hasRequired_for = 1;
  _for = { "default": require_for$1(), __esModule: true };
  return _for;
}
var _forExports = require_for();
const _Symbol$for = /* @__PURE__ */ getDefaultExportFromCjs(_forExports);
const NUM_ALTERNATIVES = 3;
const DEFAULT_LOAD_FACTOR = 0.8;
let pendingLow = 0, pendingHigh = 0, backupPendingLow = 0, backupPendingHigh = 0;
class HashTableBase {
  constructor(hashSeeds = HashTableBase.generateHashSeeds(NUM_ALTERNATIVES)) {
    this.hashSeeds = hashSeeds;
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    this.size = 0;
    this.emptyLow = 4294967295;
    this.emptyHigh = 4294967295;
    this.maxRehashAttempts = 5;
    this.maxAttempts = 5;
    this.generation = 0;
    this.mungedEmptyKey = -1;
    let initialSize = 8;
    while (initialSize < 2 * hashSeeds.length) {
      initialSize *= 2;
    }
    this.allocate(initialSize);
  }
  updateHashFunctions(numHashes) {
    this.hashSeeds = HashTableBase.generateHashSeeds(numHashes);
    this.mungedEmptyKey = -1;
  }
  /**
   * Invokes callback with a modified version of the hash table data array.
   *
   * Replaces all slots that appear to be valid entries for (emptyLow, emptyHigh), i.e. slots that
   * contain (emptyLow, emptyHigh) and to which (emptyLow, emptyHigh) hashes, with (mungedEmptyKey,
   * mungedEmptyKey).
   *
   * mungedEmptyKey is chosen to be a 32-bit value with the property that the 64-bit value
   * (mungedEmptyKey, mungedEmptyKey) does not hash to any of the same slots as (emptyLow,
   * emptyHigh).
   *
   * This allows the modified data array to be used for lookups without special casing the empty
   * key.
   */
  tableWithMungedEmptyKey(callback) {
    const numHashes = this.hashSeeds.length;
    const emptySlots = new Array(numHashes);
    for (let i = 0; i < numHashes; ++i) {
      emptySlots[i] = this.getHash(i, this.emptyLow, this.emptyHigh);
    }
    let mungedEmptyKey = this.mungedEmptyKey;
    if (mungedEmptyKey === -1) {
      chooseMungedEmptyKey: while (true) {
        mungedEmptyKey = Math.random() * 16777216 >>> 0;
        for (let i = 0; i < numHashes; ++i) {
          let h = this.getHash(i, mungedEmptyKey, mungedEmptyKey);
          for (let j = 0; j < numHashes; ++j) {
            if (emptySlots[j] === h) {
              continue chooseMungedEmptyKey;
            }
          }
        }
        this.mungedEmptyKey = mungedEmptyKey;
        break;
      }
    }
    let table = this.table, emptyLow = this.emptyLow, emptyHigh = this.emptyHigh;
    for (let i = 0; i < numHashes; ++i) {
      let h = emptySlots[i];
      if (table[h] === emptyLow && table[h + 1] === emptyHigh) {
        table[h] = mungedEmptyKey;
        table[h + 1] = mungedEmptyKey;
      }
    }
    try {
      callback(table);
    } finally {
      for (let i = 0; i < numHashes; ++i) {
        let h = emptySlots[i];
        if (table[h] === mungedEmptyKey && table[h + 1] === mungedEmptyKey) {
          table[h] = emptyLow;
          table[h + 1] = emptyHigh;
        }
      }
    }
  }
  static generateHashSeeds(numAlternatives = NUM_ALTERNATIVES) {
    return getRandomValues(new Uint32Array(numAlternatives));
  }
  getHash(hashIndex, low, high) {
    let hash = this.hashSeeds[hashIndex];
    hash = hashCombine(hash, low);
    hash = hashCombine(hash, high);
    return this.entryStride * (hash & this.tableSize - 1);
  }
  /**
   * Iterates over the Uint64 keys contained in the hash set.
   *
   * Creates a new Uint64 object at every iteration (otherwise spread and Array.from() fail)
   */
  *keys() {
    let emptyLow = this.emptyLow, emptyHigh = this.emptyHigh, entryStride = this.entryStride;
    let table = this.table;
    for (let i = 0, length2 = table.length; i < length2; i += entryStride) {
      let low = table[i], high = table[i + 1];
      if (low !== emptyLow || high !== emptyHigh) {
        yield new Uint64(low, high);
      }
    }
  }
  /**
   * Iterates over the Uint64 keys contained in the hash set.
   *
   * The same temp value will be modified and yielded at every iteration.
   */
  *unsafeKeys(temp = new Uint64()) {
    let emptyLow = this.emptyLow, emptyHigh = this.emptyHigh, entryStride = this.entryStride;
    let table = this.table;
    for (let i = 0, length2 = table.length; i < length2; i += entryStride) {
      let low = table[i], high = table[i + 1];
      if (low !== emptyLow || high !== emptyHigh) {
        temp.low = low;
        temp.high = high;
        yield temp;
      }
    }
  }
  indexOfPair(low, high) {
    let table = this.table, emptyLow = this.emptyLow, emptyHigh = this.emptyHigh;
    if (low === emptyLow && high === emptyHigh) {
      return -1;
    }
    for (let i = 0, numHashes = this.hashSeeds.length; i < numHashes; ++i) {
      let h = this.getHash(i, low, high);
      if (table[h] === low && table[h + 1] === high) {
        return h;
      }
    }
    return -1;
  }
  /**
   * Returns the offset into the hash table of the specified element, or -1 if the element is not
   * present.
   */
  indexOf(x) {
    return this.indexOfPair(x.low, x.high);
  }
  /**
   * Changes the empty key to a value that is not equal to the current empty key and is not present
   * in the table.
   *
   * This is called when an attempt is made to insert the empty key.
   */
  chooseAnotherEmptyKey() {
    let emptyLow = this.emptyLow, emptyHigh = this.emptyHigh, table = this.table, entryStride = this.entryStride;
    let newLow, newHigh;
    while (true) {
      newLow = Math.random() * 4294967296 >>> 0;
      newHigh = Math.random() * 4294967296 >>> 0;
      if (newLow === emptyLow && newHigh === emptyHigh) {
        continue;
      }
      if (this.hasPair(newLow, newHigh)) {
        continue;
      }
      break;
    }
    this.emptyLow = newLow;
    this.emptyHigh = newHigh;
    for (let h = 0, length2 = table.length; h < length2; h += entryStride) {
      if (table[h] === emptyLow && table[h + 1] === emptyHigh) {
        table[h] = newLow;
        table[h + 1] = newHigh;
      }
    }
  }
  /**
   * Returns true iff the specified element is present.
   */
  has(x) {
    return this.indexOf(x) !== -1;
  }
  /**
   * Returns true iff the specified element is present.
   */
  hasPair(low, high) {
    return this.indexOfPair(low, high) !== -1;
  }
  delete(x) {
    let index2 = this.indexOf(x);
    if (index2 !== -1) {
      let table = this.table;
      table[index2] = this.emptyLow;
      table[index2 + 1] = this.emptyHigh;
      ++this.generation;
      this.size--;
      return true;
    }
    return false;
  }
  clearTable() {
    let table = this.table, entryStride = this.entryStride, emptyLow = this.emptyLow, emptyHigh = this.emptyHigh;
    let length2 = table.length;
    for (let h = 0; h < length2; h += entryStride) {
      table[h] = emptyLow;
      table[h + 1] = emptyHigh;
    }
  }
  clear() {
    if (this.size === 0) {
      return false;
    }
    this.size = 0;
    ++this.generation;
    this.clearTable();
    return true;
  }
  reserve(x) {
    if (x > this.capacity) {
      this.backupPending();
      this.grow(x);
      this.restorePending();
      return true;
    }
    return false;
  }
  swapPending(table, offset) {
    let tempLow = pendingLow, tempHigh = pendingHigh;
    this.storePending(table, offset);
    table[offset] = tempLow;
    table[offset + 1] = tempHigh;
  }
  storePending(table, offset) {
    pendingLow = table[offset];
    pendingHigh = table[offset + 1];
  }
  backupPending() {
    backupPendingLow = pendingLow;
    backupPendingHigh = pendingHigh;
  }
  restorePending() {
    pendingLow = backupPendingLow;
    pendingHigh = backupPendingHigh;
  }
  tryToInsert() {
    let attempt = 0;
    let emptyLow = this.emptyLow, emptyHigh = this.emptyHigh, maxAttempts2 = this.maxAttempts, table = this.table;
    let numHashes = this.hashSeeds.length;
    let tableIndex = Math.floor(Math.random() * numHashes);
    while (true) {
      let h = this.getHash(tableIndex, pendingLow, pendingHigh);
      this.swapPending(table, h);
      if (pendingLow === emptyLow && pendingHigh === emptyHigh) {
        return true;
      }
      if (++attempt === maxAttempts2) {
        break;
      }
      tableIndex = (tableIndex + Math.floor(Math.random() * (numHashes - 1)) + 1) % numHashes;
    }
    return false;
  }
  allocate(tableSize) {
    this.tableSize = tableSize;
    let entryStride = this.entryStride;
    this.table = new Uint32Array(tableSize * entryStride);
    this.maxAttempts = tableSize;
    this.clearTable();
    this.capacity = tableSize * this.loadFactor;
    this.mungedEmptyKey = -1;
  }
  rehash(oldTable, tableSize) {
    this.allocate(tableSize);
    this.updateHashFunctions(this.hashSeeds.length);
    let emptyLow = this.emptyLow, emptyHigh = this.emptyHigh, entryStride = this.entryStride;
    for (let h = 0, length2 = oldTable.length; h < length2; h += entryStride) {
      let low = oldTable[h], high = oldTable[h + 1];
      if (low !== emptyLow || high !== emptyHigh) {
        this.storePending(oldTable, h);
        if (!this.tryToInsert()) {
          return false;
        }
      }
    }
    return true;
  }
  grow(desiredTableSize) {
    let oldTable = this.table;
    let tableSize = this.tableSize;
    while (tableSize < desiredTableSize) {
      tableSize *= 2;
    }
    while (true) {
      for (let rehashAttempt = 0; rehashAttempt < this.maxRehashAttempts; ++rehashAttempt) {
        if (this.rehash(oldTable, tableSize)) {
          return;
        }
      }
      tableSize *= 2;
    }
  }
  insertInternal() {
    ++this.generation;
    if (pendingLow === this.emptyLow && pendingHigh === this.emptyHigh) {
      this.chooseAnotherEmptyKey();
    }
    if (++this.size > this.capacity) {
      this.backupPending();
      this.grow(this.tableSize * 2);
      this.restorePending();
    }
    while (!this.tryToInsert()) {
      this.backupPending();
      this.grow(this.tableSize);
      this.restorePending();
    }
  }
}
class HashSetUint64 extends HashTableBase {
  add(x) {
    let low = x.low, high = x.high;
    if (this.hasPair(low, high)) {
      return false;
    }
    pendingLow = low;
    pendingHigh = high;
    this.insertInternal();
    return true;
  }
  /**
   * Iterates over the keys.
   * Creates a new Uint64 object at every iteration (otherwise spread and Array.from() fail)
   */
  [_Symbol$iterator]() {
    return this.unsafeKeys();
  }
}
HashSetUint64.prototype.entryStride = 2;
let pendingValueLow = 0, pendingValueHigh = 0, backupPendingValueLow = 0, backupPendingValueHigh = 0;
class HashMapUint64 extends HashTableBase {
  set(key, value) {
    let low = key.low, high = key.high;
    if (this.hasPair(low, high)) {
      return false;
    }
    pendingLow = low;
    pendingHigh = high;
    pendingValueLow = value.low;
    pendingValueHigh = value.high;
    this.insertInternal();
    return true;
  }
  get(key, value) {
    let h = this.indexOf(key);
    if (h === -1) {
      return false;
    }
    let table = this.table;
    value.low = table[h + 2];
    value.high = table[h + 3];
    return true;
  }
  swapPending(table, offset) {
    let tempLow = pendingValueLow, tempHigh = pendingValueHigh;
    super.swapPending(table, offset);
    table[offset + 2] = tempLow;
    table[offset + 3] = tempHigh;
  }
  storePending(table, offset) {
    super.storePending(table, offset);
    pendingValueLow = table[offset + 2];
    pendingValueHigh = table[offset + 3];
  }
  backupPending() {
    super.backupPending();
    backupPendingValueLow = pendingValueLow;
    backupPendingValueHigh = pendingValueHigh;
  }
  restorePending() {
    super.restorePending();
    pendingValueLow = backupPendingValueLow;
    pendingValueHigh = backupPendingValueHigh;
  }
  /**
   * Iterates over entries.  The same temporary value will be modified and yielded at every
   * iteration.
   */
  [_Symbol$iterator]() {
    return this.unsafeEntries();
  }
  /**
   * Iterates over entries.
   * Creates new Uint64 objects at every iteration (otherwise spread and Array.from() fail)
   */
  *entries() {
    let emptyLow = this.emptyLow, emptyHigh = this.emptyHigh, entryStride = this.entryStride;
    let table = this.table;
    for (let i = 0, length2 = table.length; i < length2; i += entryStride) {
      let low = table[i], high = table[i + 1];
      if (low !== emptyLow || high !== emptyHigh) {
        let key = new Uint64(low, high);
        let value = new Uint64(table[i + 2], table[i + 3]);
        yield [key, value];
      }
    }
  }
  /**
   * Iterates over entries.  The same temporary value will be modified and yielded at every
   * iteration.
   */
  *unsafeEntries(temp = [new Uint64(), new Uint64()]) {
    let emptyLow = this.emptyLow, emptyHigh = this.emptyHigh, entryStride = this.entryStride;
    let table = this.table;
    var _temp = _slicedToArray(temp, 2);
    let key = _temp[0], value = _temp[1];
    for (let i = 0, length2 = table.length; i < length2; i += entryStride) {
      let low = table[i], high = table[i + 1];
      if (low !== emptyLow || high !== emptyHigh) {
        key.low = low;
        key.high = high;
        value.low = table[i + 2];
        value.high = table[i + 3];
        yield temp;
      }
    }
  }
}
HashMapUint64.prototype.entryStride = 4;
class TextureFormat {
}
const integerTextureFormatForNumComponents = [-1, WebGL2RenderingContext.RED_INTEGER, WebGL2RenderingContext.RG_INTEGER, WebGL2RenderingContext.RGB_INTEGER, WebGL2RenderingContext.RGBA_INTEGER];
const floatTextureFormatForNumComponents = [-1, WebGL2RenderingContext.RED, WebGL2RenderingContext.RG, WebGL2RenderingContext.RGB, WebGL2RenderingContext.RGBA];
const textureSelectorForNumComponents = ["", "r", "rg", "rgb", "rgba"];
const internalUint8FormatForNumComponents = [-1, WebGL2RenderingContext.R8UI, WebGL2RenderingContext.RG8UI, WebGL2RenderingContext.RGB8UI, WebGL2RenderingContext.RGBA8UI];
const internalInt8FormatForNumComponents = [-1, WebGL2RenderingContext.R8I, WebGL2RenderingContext.RG8I, WebGL2RenderingContext.RGB8I, WebGL2RenderingContext.RGBA8I];
const internalUint16FormatForNumComponents = [-1, WebGL2RenderingContext.R16UI, WebGL2RenderingContext.RG16UI, WebGL2RenderingContext.RGB16UI, WebGL2RenderingContext.RGBA16UI];
const internalInt16FormatForNumComponents = [-1, WebGL2RenderingContext.R16I, WebGL2RenderingContext.RG16I, WebGL2RenderingContext.RGB16I, WebGL2RenderingContext.RGBA16I];
const internalUint32FormatForNumComponents = [-1, WebGL2RenderingContext.R32UI, WebGL2RenderingContext.RG32UI, WebGL2RenderingContext.RGB32UI, WebGL2RenderingContext.RGBA32UI];
const internalInt32FormatForNumComponents = [-1, WebGL2RenderingContext.R32I, WebGL2RenderingContext.RG32I, WebGL2RenderingContext.RGB32I, WebGL2RenderingContext.RGBA32I];
const internalFloatFormatForNumComponents = [-1, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RG32F, WebGL2RenderingContext.RGB32F, WebGL2RenderingContext.RGBA32F];
function getSamplerPrefixForDataType(dataType) {
  return dataType === DataType.FLOAT32 ? "" : DATA_TYPE_SIGNED[dataType] ? "i" : "u";
}
function computeTextureFormat(format, dataType, numComponents = 1) {
  switch (dataType) {
    case DataType.UINT8:
      if (numComponents < 1 || numComponents > 4) {
        break;
      }
      format.texelsPerElement = 1;
      format.textureInternalFormat = internalUint8FormatForNumComponents[numComponents];
      format.textureFormat = integerTextureFormatForNumComponents[numComponents];
      format.texelType = WebGL2RenderingContext.UNSIGNED_BYTE;
      format.arrayElementsPerTexel = numComponents;
      format.arrayConstructor = Uint8Array;
      format.samplerPrefix = "u";
      return format;
    case DataType.INT8:
      if (numComponents < 1 || numComponents > 4) {
        break;
      }
      format.texelsPerElement = 1;
      format.textureInternalFormat = internalInt8FormatForNumComponents[numComponents];
      format.textureFormat = integerTextureFormatForNumComponents[numComponents];
      format.texelType = WebGL2RenderingContext.BYTE;
      format.arrayElementsPerTexel = numComponents;
      format.arrayConstructor = Int8Array;
      format.samplerPrefix = "i";
      return format;
    case DataType.UINT16:
      if (numComponents < 1 || numComponents > 4) {
        break;
      }
      format.texelsPerElement = 1;
      format.textureInternalFormat = internalUint16FormatForNumComponents[numComponents];
      format.textureFormat = integerTextureFormatForNumComponents[numComponents];
      format.texelType = WebGL2RenderingContext.UNSIGNED_SHORT;
      format.arrayElementsPerTexel = numComponents;
      format.arrayConstructor = Uint16Array;
      format.samplerPrefix = "u";
      return format;
    case DataType.INT16:
      if (numComponents < 1 || numComponents > 4) {
        break;
      }
      format.texelsPerElement = 1;
      format.textureInternalFormat = internalInt16FormatForNumComponents[numComponents];
      format.textureFormat = integerTextureFormatForNumComponents[numComponents];
      format.texelType = WebGL2RenderingContext.SHORT;
      format.arrayElementsPerTexel = numComponents;
      format.arrayConstructor = Int16Array;
      format.samplerPrefix = "i";
      return format;
    case DataType.UINT32:
      if (numComponents < 1 || numComponents > 4) {
        break;
      }
      format.texelsPerElement = 1;
      format.textureInternalFormat = internalUint32FormatForNumComponents[numComponents];
      format.textureFormat = integerTextureFormatForNumComponents[numComponents];
      format.texelType = WebGL2RenderingContext.UNSIGNED_INT;
      format.arrayElementsPerTexel = 1;
      format.arrayConstructor = Uint32Array;
      format.samplerPrefix = "u";
      return format;
    case DataType.INT32:
      if (numComponents < 1 || numComponents > 4) {
        break;
      }
      format.texelsPerElement = 1;
      format.textureInternalFormat = internalInt32FormatForNumComponents[numComponents];
      format.textureFormat = integerTextureFormatForNumComponents[numComponents];
      format.texelType = WebGL2RenderingContext.INT;
      format.arrayElementsPerTexel = 1;
      format.arrayConstructor = Int32Array;
      format.samplerPrefix = "i";
      return format;
    case DataType.UINT64:
      if (numComponents < 1 || numComponents > 2) {
        break;
      }
      format.texelsPerElement = 1;
      format.textureInternalFormat = internalUint32FormatForNumComponents[numComponents * 2];
      format.textureFormat = integerTextureFormatForNumComponents[numComponents * 2];
      format.texelType = WebGL2RenderingContext.UNSIGNED_INT;
      format.arrayElementsPerTexel = 2 * numComponents;
      format.arrayConstructor = Uint32Array;
      format.samplerPrefix = "u";
      return format;
    case DataType.FLOAT32:
      if (numComponents < 1 || numComponents > 4) {
        break;
      }
      format.texelsPerElement = 1;
      format.textureInternalFormat = internalFloatFormatForNumComponents[numComponents];
      format.textureFormat = floatTextureFormatForNumComponents[numComponents];
      format.texelType = WebGL2RenderingContext.FLOAT;
      format.arrayElementsPerTexel = numComponents;
      format.arrayConstructor = Float32Array;
      format.samplerPrefix = "";
      return format;
  }
  throw new Error(`No supported texture format for ${DataType[dataType]}[${numComponents}].`);
}
function setOneDimensionalTextureData(gl, format, data) {
  const arrayConstructor = format.arrayConstructor, arrayElementsPerTexel = format.arrayElementsPerTexel, textureInternalFormat = format.textureInternalFormat, textureFormat2 = format.textureFormat, texelsPerElement = format.texelsPerElement;
  const maxTextureSize = gl.maxTextureSize;
  const numElements = data.length / arrayElementsPerTexel;
  if (numElements * texelsPerElement > maxTextureSize * maxTextureSize) {
    throw new Error("Number of elements exceeds maximum texture size: " + texelsPerElement + " * " + numElements);
  }
  const minX = Math.ceil(numElements / maxTextureSize);
  const textureXBits = Math.ceil(_Math$log$1(minX));
  const textureWidth = (1 << textureXBits) * texelsPerElement;
  const textureHeight = Math.ceil(numElements / (1 << textureXBits));
  const requiredSize = textureWidth * textureHeight * arrayElementsPerTexel;
  if (data.constructor !== arrayConstructor) {
    data = new arrayConstructor(data.buffer, data.byteOffset, data.byteLength / arrayConstructor.BYTES_PER_ELEMENT);
  }
  let padded = maybePadArray(data, requiredSize);
  gl.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1);
  setRawTextureParameters(gl);
  gl.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    /*level=*/
    0,
    textureInternalFormat,
    /*width=*/
    textureWidth,
    /*height=*/
    textureHeight,
    /*border=*/
    0,
    textureFormat2,
    format.texelType,
    padded
  );
}
function setTwoDimensionalTextureData(gl, format, data, width, height) {
  const arrayConstructor = format.arrayConstructor, textureInternalFormat = format.textureInternalFormat, textureFormat2 = format.textureFormat, texelsPerElement = format.texelsPerElement;
  if (data.constructor !== arrayConstructor) {
    data = new arrayConstructor(data.buffer, data.byteOffset, data.byteLength / arrayConstructor.BYTES_PER_ELEMENT);
  }
  gl.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1);
  setRawTextureParameters(gl);
  gl.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    /*level=*/
    0,
    textureInternalFormat,
    /*width=*/
    width * texelsPerElement,
    /*height=*/
    height,
    /*border=*/
    0,
    textureFormat2,
    format.texelType,
    data
  );
}
function setThreeDimensionalTextureData(gl, format, data, width, height, depth) {
  const arrayConstructor = format.arrayConstructor, textureInternalFormat = format.textureInternalFormat, textureFormat2 = format.textureFormat, texelsPerElement = format.texelsPerElement;
  if (data.constructor !== arrayConstructor) {
    data = new arrayConstructor(data.buffer, data.byteOffset, data.byteLength / arrayConstructor.BYTES_PER_ELEMENT);
  }
  gl.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1);
  setRawTexture3DParameters(gl);
  gl.texImage3D(
    WebGL2RenderingContext.TEXTURE_3D,
    /*level=*/
    0,
    textureInternalFormat,
    /*width=*/
    width * texelsPerElement,
    /*height=*/
    height,
    /*depth=*/
    depth,
    /*border=*/
    0,
    textureFormat2,
    format.texelType,
    data
  );
}
function getShaderCodeForDataType(dataType) {
  switch (dataType) {
    case DataType.UINT8:
      return glsl_uint8;
    case DataType.INT8:
      return glsl_int8;
    case DataType.UINT16:
      return glsl_uint16;
    case DataType.INT16:
      return glsl_int16;
    case DataType.UINT32:
      return glsl_uint32;
    case DataType.INT32:
      return glsl_int32;
    case DataType.UINT64:
      return glsl_uint64;
    case DataType.FLOAT32:
      return glsl_float;
  }
}
function getAccessorFunction(functionName, readTextureValue, samplerName, indexType, dataType, numComponents) {
  const shaderType = getShaderType(dataType, numComponents);
  let parts = [getShaderCodeForDataType(dataType)];
  let code = `
${shaderType} ${functionName}(${indexType} index) {
`;
  switch (dataType) {
    case DataType.UINT8:
    case DataType.UINT16:
    case DataType.UINT32:
      code += `
  ${shaderType} result;
  highp uvec4 temp;
  ${readTextureValue}(${samplerName}, index, temp);
  result.value = temp.${textureSelectorForNumComponents[numComponents]};
  return result;
`;
      break;
    case DataType.INT8:
    case DataType.INT16:
    case DataType.INT32:
      code += `
  ${shaderType} result;
  highp ivec4 temp;
  ${readTextureValue}(${samplerName}, index, temp);
  result.value = temp.${textureSelectorForNumComponents[numComponents]};
  return result;
`;
      break;
    case DataType.UINT64:
      parts.push(glsl_unpackUint64leFromUint32);
      code += `
  highp uvec4 temp;
  ${readTextureValue}(${samplerName}, index, temp);
  return unpackUint64leFromUint32(temp.${textureSelectorForNumComponents[numComponents * 2]});
`;
      break;
    case DataType.FLOAT32:
      parts.push(glsl_float);
      code += `
  highp vec4 temp;
  ${readTextureValue}(${samplerName}, index, temp);
  return temp.${textureSelectorForNumComponents[numComponents]};
`;
      break;
  }
  code += `
}
`;
  parts.push(code);
  return parts;
}
class OneDimensionalTextureAccessHelper {
  constructor(key) {
    this.key = key;
    this.readTextureValue = `readTextureValue_${this.key}`;
  }
  defineShader(builder) {
  }
  getReadTextureValueCode(texelsPerElement, samplerPrefix) {
    let code = `
void ${this.readTextureValue}(highp ${samplerPrefix}sampler2D sampler, highp uint index`;
    for (let i = 0; i < texelsPerElement; ++i) {
      code += `, out ${samplerPrefix}vec4 output${i}`;
    }
    code += `) {
  highp int width = textureSize(sampler, 0).x / ${texelsPerElement};
  highp uint log2width = log2Exact(uint(width));
  highp int y = int(index >> log2width);
  highp int x = int((index - (uint(y) << log2width)) * ${texelsPerElement}u);
`;
    for (let i = 0; i < texelsPerElement; ++i) {
      code += `
  output${i} = texelFetch(sampler, ivec2(x + ${i}, y), 0);
`;
    }
    code += `
}
`;
    return [glsl_log2Exact, code];
  }
  getAccessor(functionName, samplerName, dataType, numComponents = 1) {
    const samplerPrefix = getSamplerPrefixForDataType(dataType);
    return [this.getReadTextureValueCode(1, samplerPrefix), ...getAccessorFunction(functionName, this.readTextureValue, samplerName, "highp uint", dataType, numComponents)];
  }
}
class TextureAccessHelper {
  constructor(key, textureDims) {
    this.key = key;
    this.textureDims = textureDims;
    this.readTextureValue = `readTextureValue_${this.key}`;
  }
  getReadTextureValueCode(texelsPerElement, samplerPrefix) {
    const textureDims = this.textureDims;
    let code = `
void ${this.readTextureValue}(highp ${samplerPrefix}sampler${this.textureDims}D sampler, highp ivec${textureDims} p`;
    for (let i = 0; i < texelsPerElement; ++i) {
      code += `, out ${samplerPrefix}vec4 output${i}`;
    }
    code += `) {
`;
    for (let i = 0; i < texelsPerElement; ++i) {
      code += `
  output${i} = texelFetch(sampler, ivec${textureDims}(p.x * ${texelsPerElement} + ${i}, p.y
                                         ${textureDims === 3 ? ", p.z" : ""}), 0);
`;
    }
    code += `
}
`;
    return code;
  }
  getAccessor(functionName, samplerName, dataType, numComponents = 1) {
    const samplerPrefix = getSamplerPrefixForDataType(dataType);
    return [this.getReadTextureValueCode(1, samplerPrefix), ...getAccessorFunction(functionName, this.readTextureValue, samplerName, `highp ivec${this.textureDims}`, dataType, numComponents)];
  }
}
const glsl_hashCombine = [glsl_uint64, `
highp uint hashCombine(highp uint state, highp uint value) {
  value *= 0xcc9e2d51u;
  value = (value << 15u) | (value >> 17u);
  value *= 0x1b873593u;
  state ^= value;
  state = (state << 13u) | (state >> 19u);
  state = (state * 5u) + 0xe6546b64u;
  return state;
}
highp uint hashCombine(highp uint state, uint64_t x) {
  state = hashCombine(state, x.value[0]);
  return hashCombine(state, x.value[1]);
}
`];
const textureFormat$1 = computeTextureFormat(new TextureFormat(), DataType.UINT64, 1);
class GPUHashTable extends RefCounted {
  constructor(gl, hashTable) {
    super();
    this.gl = gl;
    this.hashTable = hashTable;
    this.generation = -1;
    this.texture = null;
    this.texture = gl.createTexture();
  }
  copyToGPU() {
    let hashTable = this.hashTable;
    let generation = hashTable.generation;
    if (this.generation === generation) {
      return;
    }
    const gl = this.gl, texture = this.texture;
    this.generation = generation;
    gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + gl.tempTextureUnit);
    gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
    hashTable.tableWithMungedEmptyKey((table) => {
      setOneDimensionalTextureData(this.gl, textureFormat$1, table);
    });
    gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
  }
  disposed() {
    let gl = this.gl;
    gl.deleteTexture(this.texture);
    this.texture = null;
    this.gl = void 0;
    this.hashTable = void 0;
    super.disposed();
  }
  static get(gl, hashTable) {
    return gl.memoize.get(hashTable, () => new this(gl, hashTable));
  }
}
class HashSetShaderManager {
  constructor(prefix, numAlternatives = NUM_ALTERNATIVES) {
    this.prefix = prefix;
    this.numAlternatives = numAlternatives;
    this.textureUnitSymbol = _Symbol$for(`gpuhashtable:${this.prefix}`);
    this.accessHelper = new OneDimensionalTextureAccessHelper(`gpuhashtable_${this.prefix}`);
    this.samplerName = this.prefix + "_sampler";
    this.hashSeedsName = this.prefix + "_seeds";
    this.hashKeyMask = this.prefix + "_keyMask";
    this.readTable = this.prefix + "_readTable";
  }
  defineShader(builder) {
    let hashSeedsName = this.hashSeedsName, samplerName = this.samplerName, numAlternatives = this.numAlternatives, hashKeyMask = this.hashKeyMask;
    builder.addUniform("highp uint", hashSeedsName, numAlternatives);
    builder.addUniform("highp uint", hashKeyMask);
    builder.addTextureSampler("usampler2D", samplerName, this.textureUnitSymbol);
    builder.addFragmentCode(glsl_hashCombine);
    builder.addFragmentCode(glsl_uint64);
    builder.addFragmentCode(glsl_equalUint64);
    this.accessHelper.defineShader(builder);
    builder.addFragmentCode(this.accessHelper.getAccessor(this.readTable, this.samplerName, DataType.UINT64, 1));
    let s = "";
    s += `
bool ${this.hasFunctionName}(uint64_t x) {
`;
    for (let alt = 0; alt < numAlternatives; ++alt) {
      s += `
  {
    uint h = hashCombine(${hashSeedsName}[${alt}], x) & ${hashKeyMask};
    uint64_t key = ${this.readTable}(h);
    if (equals(key, x)) {
      return true;
    }
  }
`;
    }
    s += `
  return false;
}
`;
    builder.addFragmentCode(s);
  }
  get hasFunctionName() {
    return `${this.prefix}_has`;
  }
  enable(gl, shader, hashTable) {
    hashTable.copyToGPU();
    const textureUnit = shader.textureUnit(this.textureUnitSymbol);
    gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + textureUnit);
    gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, hashTable.texture);
    gl.uniform1ui(shader.uniform(this.hashKeyMask), hashTable.hashTable.tableSize - 1);
    gl.uniform1uiv(shader.uniform(this.hashSeedsName), hashTable.hashTable.hashSeeds);
  }
  disable(gl, shader) {
    const textureUnit = shader.textureUnit(this.textureUnitSymbol);
    gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + textureUnit);
    gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
  }
}
class HashMapShaderManager extends HashSetShaderManager {
  defineShader(builder) {
    super.defineShader(builder);
    let numAlternatives = this.numAlternatives, hashSeedsName = this.hashSeedsName, hashKeyMask = this.hashKeyMask;
    let s = `
bool ${this.getFunctionName}(uint64_t x, out uint64_t value) {
`;
    for (let alt = 0; alt < numAlternatives; ++alt) {
      s += `
  {
    uint h = hashCombine(${hashSeedsName}[${alt}], x) & ${hashKeyMask};
    uint64_t key = ${this.readTable}(h * 2u);
    if (equals(key, x)) {
      value = ${this.readTable}(h * 2u + 1u);
      return true;
    }
  }
`;
    }
    s += `
  return false;
}
`;
    builder.addFragmentCode(s);
  }
  get getFunctionName() {
    return `${this.prefix}_get`;
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hsvToRgb(out, h, s, v) {
  h *= 6;
  let hueIndex = Math.floor(h);
  let remainder = h - hueIndex;
  let val1 = v * (1 - s);
  let val2 = v * (1 - s * remainder);
  let val3 = v * (1 - s * (1 - remainder));
  switch (hueIndex % 6) {
    case 0:
      out[0] = v;
      out[1] = val3;
      out[2] = val1;
      break;
    case 1:
      out[0] = val2;
      out[1] = v;
      out[2] = val1;
      break;
    case 2:
      out[0] = val1;
      out[1] = v;
      out[2] = val3;
      break;
    case 3:
      out[0] = val1;
      out[1] = val2;
      out[2] = v;
      break;
    case 4:
      out[0] = val3;
      out[1] = val1;
      out[2] = v;
      break;
    case 5:
      out[0] = v;
      out[1] = val1;
      out[2] = val2;
      break;
  }
  return out;
}
function rgbToHsv(out, r, g, b) {
  const max = Math.max(Math.max(r, g), b);
  const min2 = Math.min(Math.min(r, g), b);
  out[2] = max;
  if (min2 === max) {
    out[0] = 0;
    out[1] = 0;
  } else {
    const delta = max - min2;
    out[1] = delta / max;
    if (r === max) {
      out[0] = (g - b) / delta;
    } else if (g === max) {
      out[0] = 2 + (b - r) / delta;
    } else {
      out[0] = 4 + (r - g) / delta;
    }
    out[0] /= 6;
    if (out[0] < 0) {
      out[0] += 1;
    }
    if (out[0] > 1) {
      out[0] -= 1;
    }
  }
  return out;
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NUM_COMPONENTS = 2;
class SegmentColorShaderManager {
  constructor(prefix) {
    this.prefix = prefix;
    this.seedName = this.prefix + "_seed";
  }
  defineShader(builder) {
    const seedName = this.seedName;
    builder.addUniform("highp uint", seedName);
    builder.addFragmentCode(glsl_uint64);
    builder.addFragmentCode(glsl_hashCombine);
    builder.addFragmentCode(glsl_hsvToRgb);
    let s = `
vec3 ${this.prefix}(uint64_t x) {
  uint h = hashCombine(${seedName}, x);
  vec${NUM_COMPONENTS} v;
`;
    for (let i = 0; i < NUM_COMPONENTS; ++i) {
      s += `
  v[${i}] = float(h & 0xFFu) / 255.0;
  h >>= 8u;
`;
    }
    s += `
  vec3 hsv = vec3(v.x, 0.5 + v.y * 0.5, 1.0);
  return hsvToRgb(hsv);
}
`;
    builder.addFragmentCode(s);
  }
  enable(gl, shader, segmentColorHash) {
    gl.uniform1ui(shader.uniform(this.seedName), segmentColorHash);
  }
}
let tempColor$1 = new Float32Array(3);
function getCssColor(color2) {
  return `rgb(${color2[0] * 100}%,${color2[1] * 100}%,${color2[2] * 100}%)`;
}
class SegmentColorHash {
  constructor(hashSeed = getRandomUint32()) {
    this.hashSeed = hashSeed;
    this.changed = new NullarySignal();
  }
  static getDefault() {
    return new SegmentColorHash(0);
  }
  get value() {
    return this.hashSeed;
  }
  set value(value) {
    if (value !== this.hashSeed) {
      this.hashSeed = value;
      this.changed.dispatch();
    }
  }
  compute(out, x) {
    let h = hashCombine(this.hashSeed, x.low);
    h = hashCombine(h, x.high);
    const c0 = (h & 255) / 255;
    const c1 = (h >> 8 & 255) / 255;
    hsvToRgb(out, c0, 0.5 + 0.5 * c1, 1);
    return out;
  }
  computeCssColor(x) {
    this.compute(tempColor$1, x);
    return getCssColor(tempColor$1);
  }
  randomize() {
    this.hashSeed = getRandomUint32();
    this.changed.dispatch();
  }
  toString() {
    return `new SegmentColorHash(${this.hashSeed})`;
  }
  toJSON() {
    return this.hashSeed === 0 ? void 0 : this.hashSeed;
  }
  reset() {
    this.restoreState(0);
  }
  restoreState(x) {
    const newSeed = x >>> 0;
    if (newSeed !== this.hashSeed) {
      this.hashSeed = newSeed;
      this.changed.dispatch();
    }
  }
}
class SegmentStatedColorShaderManager {
  constructor(prefix) {
    this.prefix = prefix;
    this.hashMapShaderManager = new HashMapShaderManager("segmentStatedColorHash");
  }
  defineShader(builder) {
    this.hashMapShaderManager.defineShader(builder);
    let s = `
bool ${this.getFunctionName}(uint64_t x, out vec3 value) {
  uint64_t uint64Value;
  if (${this.hashMapShaderManager.getFunctionName}(x, uint64Value)) {
    uint uintValue = uint64Value.value[0];
    value.r = float((uintValue & 0x0000ffu))       / 255.0;
    value.g = float((uintValue & 0x00ff00u) >>  8) / 255.0;
    value.b = float((uintValue & 0xff0000u) >> 16) / 255.0;
    return true;
  }
  return false;
}
`;
    builder.addFragmentCode(s);
  }
  get getFunctionName() {
    return `${this.prefix}_get`;
  }
  enable(gl, shader, hashTable) {
    this.hashMapShaderManager.enable(gl, shader, hashTable);
  }
  disable(gl, shader) {
    this.hashMapShaderManager.disable(gl, shader);
  }
}
const svg_arrowLeft = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="arrowLeftIconTitle"><title id="arrowLeftIconTitle">Arrow Left</title><path d="M9 6l-6 6 6 6"></path><path d="M21 12H4"></path><path stroke-linecap="round" d="M3 12h1"></path></svg>';
const svg_arrowRight = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="arrowRightIconTitle"><title id="arrowRightIconTitle">Arrow Right</title><path d="M15 18l6-6-6-6"></path><path d="M3 12h17"></path><path stroke-linecap="round" d="M21 12h-1"></path></svg>';
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HierarchicalMap {
  /**
   * If an existing HierarchicalMap is specified, a shallow copy is made.
   *
   * @param existing Existing map to make a shallow copy of.
   */
  constructor(existing) {
    this.parents = new Array();
    this.parentPriorities = new Array();
    this.bindings = new _Map();
    if (existing !== void 0) {
      this.parents.push(...existing.parents);
      this.parentPriorities.push(...existing.parentPriorities);
      for (const _ref of existing.bindings) {
        var _ref2 = _slicedToArray(_ref, 2);
        const k = _ref2[0];
        const v = _ref2[1];
        this.bindings.set(k, v);
      }
    }
  }
  /**
   * Register `parent` as a parent map.  If `priority > 0`, this map will take precedence over
   * direct bindings.
   *
   * @returns A nullary function that unregisters the parent (and may be called at most once).
   */
  addParent(parent, priority) {
    const parents = this.parents, parentPriorities = this.parentPriorities;
    let index2 = 0;
    const length2 = parents.length;
    while (index2 < length2 && priority < parentPriorities[index2]) {
      ++index2;
    }
    parents.splice(index2, 0, parent);
    parentPriorities.splice(index2, 0, priority);
    return () => {
      this.removeParent(parent);
    };
  }
  /**
   * Unregisters `parent` as a parent.
   */
  removeParent(parent) {
    const index2 = this.parents.indexOf(parent);
    if (index2 === -1) {
      throw new Error(`Attempt to remove non-existent parent map.`);
    }
    this.parents.splice(index2, 1);
    this.parentPriorities.splice(index2, 1);
  }
  /**
   * Register a direct binding.
   */
  set(key, value) {
    this.bindings.set(key, value);
  }
  /**
   * Unregister a direct binding.
   */
  delete(key) {
    this.bindings.delete(key);
  }
  /**
   * Deletes all bindings, including parents.
   */
  clear() {
    this.bindings.clear();
    this.parents.length = 0;
    this.parentPriorities.length = 0;
  }
  /**
   * Lookup the highest priority value to which the specified key is mapped.
   */
  get(key) {
    const parents = this.parents, parentPriorities = this.parentPriorities;
    const numParents = parentPriorities.length;
    let parentIndex = 0;
    let value;
    for (; parentIndex < numParents && parentPriorities[parentIndex] > 0; ++parentIndex) {
      value = parents[parentIndex].get(key);
      if (value !== void 0) {
        return value;
      }
    }
    value = this.bindings.get(key);
    if (value !== void 0) {
      return value;
    }
    for (; parentIndex < numParents; ++parentIndex) {
      value = parents[parentIndex].get(key);
      if (value !== void 0) {
        return value;
      }
    }
    return void 0;
  }
  /**
   * Find all values to which the specified key is mapped.
   */
  *getAll(key) {
    const parents = this.parents, parentPriorities = this.parentPriorities;
    const numParents = parentPriorities.length;
    let parentIndex = 0;
    let value;
    while (parentIndex < numParents && parentPriorities[parentIndex] > 0) {
      value = parents[parentIndex].get(key);
      if (value !== void 0) {
        yield value;
      }
    }
    value = this.bindings.get(key);
    if (value !== void 0) {
      yield value;
    }
    while (parentIndex < numParents) {
      value = parents[parentIndex].get(key);
      if (value !== void 0) {
        yield value;
      }
    }
  }
  *entries() {
    const parents = this.parents, parentPriorities = this.parentPriorities;
    const numParents = parentPriorities.length;
    let parentIndex = 0;
    for (; parentIndex < numParents && parentPriorities[parentIndex] > 0; ++parentIndex) {
      yield* parents[parentIndex].entries();
    }
    yield* this.bindings.entries();
    for (; parentIndex < numParents; ++parentIndex) {
      yield* parents[parentIndex].entries();
    }
  }
}
var Modifiers;
(function(Modifiers2) {
  Modifiers2[Modifiers2["CONTROL"] = 1] = "CONTROL";
  Modifiers2[Modifiers2["ALT"] = 2] = "ALT";
  Modifiers2[Modifiers2["META"] = 4] = "META";
  Modifiers2[Modifiers2["SHIFT"] = 8] = "SHIFT";
})(Modifiers || (Modifiers = {}));
function getEventModifierMask(event) {
  return (event.ctrlKey ? 1 : 0) | (event.altKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);
}
function getStrokeIdentifier(keyName, modifiers) {
  let identifier = "";
  if (modifiers & 1) {
    identifier += "control+";
  }
  if (modifiers & 2) {
    identifier += "alt+";
  }
  if (modifiers & 4) {
    identifier += "meta+";
  }
  if (modifiers & 8) {
    identifier += "shift+";
  }
  identifier += keyName;
  return identifier;
}
function getStrokeIdentifierWithOptionalModifiers(keyName, modifiers, optionalModifiers) {
  let identifier = "";
  if (modifiers & 1) {
    identifier += "control+";
  }
  if (optionalModifiers & 1) {
    identifier += "control?+";
  }
  if (modifiers & 2) {
    identifier += "alt+";
  }
  if (optionalModifiers & 2) {
    identifier += "alt?+";
  }
  if (modifiers & 4) {
    identifier += "meta+";
  }
  if (optionalModifiers & 4) {
    identifier += "meta?+";
  }
  if (modifiers & 8) {
    identifier += "shift+";
  }
  if (optionalModifiers & 8) {
    identifier += "shift?+";
  }
  identifier += keyName;
  return identifier;
}
function parseEventIdentifier(identifier) {
  const firstColonOffset = identifier.indexOf(":");
  let phase;
  if (firstColonOffset !== -1) {
    phase = identifier.substring(0, firstColonOffset);
    if (phase !== "at" && phase !== "bubble") {
      throw new Error(`Invalid event phase: ${_JSON$stringify(phase)}`);
    }
  }
  const parts = identifier.substring(firstColonOffset + 1).split("+");
  let keyName;
  let modifiers = 0;
  let optionalModifiers = 0;
  loop: for (let part of parts) {
    switch (part) {
      case "control":
        modifiers |= 1;
        break;
      case "control?":
        optionalModifiers |= 1;
        break;
      case "alt":
        modifiers |= 2;
        break;
      case "alt?":
        optionalModifiers |= 2;
        break;
      case "meta":
        modifiers |= 4;
        break;
      case "meta?":
        optionalModifiers |= 4;
        break;
      case "shift":
        modifiers |= 8;
        break;
      case "shift?":
        optionalModifiers |= 8;
        break;
      default:
        if (keyName === void 0) {
          keyName = part;
        } else {
          keyName = void 0;
          break loop;
        }
    }
  }
  if (keyName === void 0 || modifiers & optionalModifiers) {
    throw new Error(`Invalid event identifier: ${_JSON$stringify(identifier)}`);
  }
  return { phase, keyName, modifiers, optionalModifiers };
}
function* getNormalizedStrokeIdentifiers(keyName, modifiers, optionalModifiers) {
  if (optionalModifiers === 0) {
    yield getStrokeIdentifier(keyName, modifiers);
  }
  for (let m = 0; m < 16; ++m) {
    if ((m & (modifiers | optionalModifiers)) !== m) continue;
    if ((m & modifiers) !== modifiers) continue;
    yield getStrokeIdentifier(keyName, m);
  }
}
function* getNormalizedEventIdentifiers(parsed) {
  const phase = parsed.phase;
  const strokeIdentifiers = getNormalizedStrokeIdentifiers(parsed.keyName, parsed.modifiers, parsed.optionalModifiers);
  if (phase === void 0) {
    for (const suffix of strokeIdentifiers) {
      yield `at:${suffix}`;
      yield `bubble:${suffix}`;
    }
  } else {
    for (const suffix of strokeIdentifiers) {
      yield `${phase}:${suffix}`;
    }
  }
}
function normalizeEventAction(parsed, action) {
  const identifier = getStrokeIdentifierWithOptionalModifiers(parsed.keyName, parsed.modifiers, parsed.optionalModifiers);
  if (typeof action === "string") {
    return { action, originalEventIdentifier: identifier };
  }
  return _Object$assign(_Object$assign({}, action), { originalEventIdentifier: identifier });
}
class EventActionMap extends HierarchicalMap {
  /**
   * Returns a new EventActionMap with the specified bindings.
   *
   * The keys of the `bindings` object specify unnormalized event identifiers to be mapped to their
   * corresponding `ActionOrEventAction` values.
   */
  static fromObject(bindings, options = {}) {
    const map2 = new EventActionMap();
    map2.label = options.label;
    if (options.parents !== void 0) {
      for (const _ref of options.parents) {
        var _ref2 = _slicedToArray(_ref, 2);
        const parent = _ref2[0];
        const priority = _ref2[1];
        map2.addParent(parent, priority);
      }
    }
    for (const key of _Object$keys(bindings)) {
      map2.set(key, bindings[key]);
    }
    return map2;
  }
  setFromObject(bindings) {
    for (const key of _Object$keys(bindings)) {
      this.set(key, bindings[key]);
    }
  }
  /**
   * Maps the specified event `identifier` to the specified `action`.
   *
   * The `identifier` may be unnormalized; the actual mapping is created for each corresponding
   * normalized identifier.
   */
  set(identifier, action) {
    const parsedIdentifier = parseEventIdentifier(identifier);
    const normalizedAction = normalizeEventAction(parsedIdentifier, action);
    for (const normalizedIdentifier of getNormalizedEventIdentifiers(parsedIdentifier)) {
      super.set(normalizedIdentifier, normalizedAction);
    }
  }
  /**
   * Deletes the mapping for the specified `identifier`.
   *
   * The `identifier` may be unnormalized; the mapping is deleted for each corresponding normalized
   * identifier.
   */
  delete(identifier) {
    for (const normalizedIdentifier of getNormalizedEventIdentifiers(parseEventIdentifier(identifier))) {
      super.delete(normalizedIdentifier);
    }
  }
  describe() {
    const bindings = [];
    const uniqueBindings = new _Map();
    for (const _ref3 of this.entries()) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const value = _ref4[1];
      uniqueBindings.set(value.originalEventIdentifier, value.action);
    }
    for (const _ref5 of uniqueBindings) {
      var _ref6 = _slicedToArray(_ref5, 2);
      const key = _ref6[0];
      const value = _ref6[1];
      bindings.push(`${key}→${value}`);
    }
    return bindings.join(", ");
  }
}
function dispatchEventAction(originalEvent, detail, eventAction) {
  if (eventAction === void 0) {
    return;
  }
  if (eventAction.stopPropagation !== false) {
    originalEvent.stopPropagation();
  }
  const actionEvent = new CustomEvent("action:" + eventAction.action, { "bubbles": true, detail, cancelable: true });
  const cancelled = !originalEvent.target.dispatchEvent(actionEvent);
  if (eventAction.preventDefault !== false || cancelled) {
    originalEvent.preventDefault();
  }
}
const eventPhaseNames = [];
eventPhaseNames[Event.AT_TARGET] = "at";
eventPhaseNames[Event.CAPTURING_PHASE] = "capture";
eventPhaseNames[Event.BUBBLING_PHASE] = "bubble";
function dispatchEvent(baseIdentifier, originalEvent, eventPhase, detail, eventMap) {
  const eventIdentifier = eventPhaseNames[eventPhase] + ":" + baseIdentifier;
  const eventAction = eventMap.get(eventIdentifier);
  dispatchEventAction(originalEvent, detail, eventAction);
}
function dispatchEventWithModifiers(baseIdentifier, originalEvent, detail, eventMap) {
  dispatchEvent(getStrokeIdentifier(baseIdentifier, getEventModifierMask(originalEvent)), originalEvent, originalEvent.eventPhase, detail, eventMap);
}
function registerActionListener(target, action, listener, options) {
  return registerEventListener(target, `action:${action}`, listener, options);
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let defaultGlobalBindings;
function getDefaultGlobalBindings() {
  if (defaultGlobalBindings === void 0) {
    const map2 = new EventActionMap();
    map2.set("keyl", "recolor");
    map2.set("keyx", "clear-segments");
    map2.set("keys", "toggle-show-slices");
    map2.set("keyb", "toggle-scale-bar");
    map2.set("keyv", "toggle-default-annotations");
    map2.set("keya", "toggle-axis-lines");
    map2.set("keyo", "toggle-orthographic-projection");
    for (let i = 1; i <= 9; ++i) {
      map2.set("digit" + i, "toggle-layer-" + i);
      map2.set("control+digit" + i, "select-layer-" + i);
      map2.set("alt+digit" + i, "toggle-pick-layer-" + i);
    }
    for (let i = 0; i < 26; ++i) {
      const lowercase = String.fromCharCode(97 + i);
      const uppercase = String.fromCharCode(65 + i);
      map2.set(`alt?+control?+shift+key${lowercase}`, `tool-${uppercase}`);
    }
    map2.set("keyn", "add-layer");
    map2.set("keyh", "help");
    map2.set("space", "toggle-layout");
    map2.set("shift+space", "toggle-layout-alternative");
    map2.set("backslash", "toggle-show-statistics");
    defaultGlobalBindings = map2;
  }
  return defaultGlobalBindings;
}
let defaultSelectBindings;
function getDefaultSelectBindings() {
  if (defaultSelectBindings === void 0) {
    defaultSelectBindings = EventActionMap.fromObject({ "control+mousedown2": "select-position" });
  }
  return defaultSelectBindings;
}
let defaultAnnotationListBindings;
function getDefaultAnnotationListBindings() {
  if (defaultAnnotationListBindings === void 0) {
    defaultAnnotationListBindings = EventActionMap.fromObject({
      "click0": "pin-annotation",
      "mousedown2": "move-to-annotation"
    }, { parents: [[getDefaultSelectBindings(), 0]] });
  }
  return defaultAnnotationListBindings;
}
let defaultRenderedDataPanelBindings;
function getDefaultRenderedDataPanelBindings() {
  if (defaultRenderedDataPanelBindings === void 0) {
    defaultRenderedDataPanelBindings = EventActionMap.fromObject({
      "arrowleft": "x-",
      "arrowright": "x+",
      "arrowup": "y-",
      "arrowdown": "y+",
      "comma": "z-",
      "period": "z+",
      "bracketleft": "t-",
      "bracketright": "t+",
      "keyz": "snap",
      "control+equal": "zoom-in",
      "alt+equal": "depth-range-decrease",
      "control+shift+equal": "zoom-in",
      "alt+shift+equal": "depth-range-decrease",
      "control+minus": "zoom-out",
      "alt+minus": "depth-range-increase",
      "keyr": "rotate-relative-z-",
      "keye": "rotate-relative-z+",
      "shift+arrowdown": "rotate-relative-x-",
      "shift+arrowup": "rotate-relative-x+",
      "shift+arrowleft": "rotate-relative-y-",
      "shift+arrowright": "rotate-relative-y+",
      "control+wheel": { action: "zoom-via-wheel", preventDefault: true },
      "alt+wheel": { action: "adjust-depth-range-via-wheel", preventDefault: true },
      "at:wheel": { action: "z+1-via-wheel", preventDefault: true },
      "at:shift+wheel": { action: "z+10-via-wheel", preventDefault: true },
      "at:alt+mousedown2": "copy-segment-id",
      "at:alt+shift+mousedown2": "add-copy-segment-id",
      "at:dblclick0": "select",
      "at:control+mousedown0": "annotate",
      "at:mousedown2": "move-to-mouse-position",
      "at:alt+mousedown0": "move-annotation",
      "at:control+alt+mousedown2": "delete-annotation",
      "at:touchpinch": "zoom-via-touchpinch",
      "at:touchrotate": "rotate-in-plane-via-touchrotate",
      "at:touchtranslate2": "translate-in-plane-via-touchtranslate",
      "at:touchhold1": "move-to-mouse-position",
      "at:touchtap1x2": "select",
      "at:touchtap2x3": "snap"
    }, {
      label: "All Data Panels",
      parents: [[getDefaultSelectBindings(), 0]]
    });
  }
  return defaultRenderedDataPanelBindings;
}
let defaultPerspectivePanelBindings;
function getDefaultPerspectivePanelBindings() {
  if (defaultPerspectivePanelBindings === void 0) {
    defaultPerspectivePanelBindings = EventActionMap.fromObject({
      "at:mousedown0": { action: "rotate-via-mouse-drag", stopPropagation: true },
      "at:shift+mousedown0": { action: "translate-via-mouse-drag", stopPropagation: true },
      "at:touchtranslate1": "rotate-out-of-plane-via-touchtranslate"
    }, { parents: [[getDefaultRenderedDataPanelBindings(), Number.NEGATIVE_INFINITY]] });
  }
  return defaultPerspectivePanelBindings;
}
let defaultSliceViewPanelBindings;
function getDefaultSliceViewPanelBindings() {
  if (defaultSliceViewPanelBindings === void 0) {
    defaultSliceViewPanelBindings = EventActionMap.fromObject({
      "at:mousedown0": { action: "translate-via-mouse-drag", stopPropagation: true },
      "at:shift+mousedown0": { action: "rotate-via-mouse-drag", stopPropagation: true },
      "at:touchtranslate1": "translate-z-via-touchtranslate"
    }, { parents: [[getDefaultRenderedDataPanelBindings(), Number.NEGATIVE_INFINITY]] });
  }
  return defaultSliceViewPanelBindings;
}
function setDefaultInputEventBindings(inputEventBindings) {
  inputEventBindings.global.addParent(getDefaultGlobalBindings(), Number.NEGATIVE_INFINITY);
  inputEventBindings.sliceView.addParent(getDefaultSliceViewPanelBindings(), Number.NEGATIVE_INFINITY);
  inputEventBindings.perspectiveView.addParent(getDefaultPerspectivePanelBindings(), Number.NEGATIVE_INFINITY);
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function removeChildren(element) {
  while (true) {
    let child = element.firstChild;
    if (!child) {
      break;
    }
    element.removeChild(child);
  }
}
function removeFromParent(element) {
  let parentElement = element.parentElement;
  if (parentElement) {
    parentElement.removeChild(element);
    return true;
  }
  return false;
}
function updateInputFieldWidth$1(element, length2 = Math.max(1, element.value.length)) {
  const newWidth = `${length2}ch`;
  if (element.style.width !== newWidth) {
    element.style.width = "0px";
    element.offsetWidth;
    element.style.width = newWidth;
  }
}
function updateChildren(element, children) {
  let nextChild = element.firstElementChild;
  for (const child of children) {
    if (child !== nextChild) {
      element.insertBefore(child, nextChild);
    }
    nextChild = child.nextElementSibling;
  }
  while (nextChild !== null) {
    let next = nextChild.nextElementSibling;
    element.removeChild(nextChild);
    nextChild = next;
  }
}
function isInputTextTarget(target) {
  if (!(target instanceof HTMLElement)) return false;
  if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target.isContentEditable) {
    return true;
  }
  return false;
}
function measureElementClone(element) {
  const clone2 = element.cloneNode(
    /*deep=*/
    true
  );
  clone2.style.position = "absolute";
  document.body.appendChild(clone2);
  return clone2.getBoundingClientRect();
}
let dragStatusElement;
let dragStatusStack = [];
function getStatusElement() {
  if (dragStatusElement === void 0) {
    const element = dragStatusElement = document.createElement("div");
    element.classList.add("neuroglancer-drag-status");
    document.body.appendChild(element);
  }
  return dragStatusElement;
}
function clearStatus() {
  if (dragStatusElement !== void 0) {
    removeChildren(dragStatusElement);
    dragStatusElement.style.display = "none";
  }
}
function applyStatus(status) {
  const element = getStatusElement();
  removeChildren(element);
  if (typeof status === "string") {
    element.appendChild(document.createTextNode(status));
  } else {
    element.appendChild(status());
  }
  element.style.display = "";
}
function removeDragStatus(target, operation) {
  filterArrayInplace(dragStatusStack, (entry) => !(entry.target === target && entry.operation === operation));
}
function pushDragStatus(target, operation, status) {
  removeDragStatus(target, operation);
  dragStatusStack.push({ target, operation, status });
  applyStatus(status);
}
function popDragStatus(target, operation) {
  removeDragStatus(target, operation);
  const entry = dragStatusStack.length === 0 ? void 0 : dragStatusStack[dragStatusStack.length - 1];
  if (entry === void 0) {
    clearStatus();
  } else {
    applyStatus(entry.status);
  }
}
const DEFAULT_SIDE_PANEL_WIDTH = 300;
const DEFAULT_MIN_SIDE_PANEL_WIDTH = 100;
const DEFAULT_SIDE_PANEL_LOCATION = {
  side: "right",
  col: 0,
  row: Infinity,
  flex: 1,
  size: DEFAULT_SIDE_PANEL_WIDTH,
  minSize: DEFAULT_MIN_SIDE_PANEL_WIDTH,
  visible: false
};
class TrackableSidePanelLocation {
  constructor(defaultValue = DEFAULT_SIDE_PANEL_LOCATION, value = defaultValue) {
    this.defaultValue = defaultValue;
    this.value = value;
    this.changed = new Signal();
    this.locationChanged = new Signal();
    this.locationChanged.add(this.changed.dispatch);
    const self2 = this;
    this.watchableVisible = {
      get value() {
        return self2.visible;
      },
      set value(value2) {
        self2.visible = value2;
      },
      changed: self2.locationChanged
    };
  }
  toJSON(defaultValue = this.defaultValue) {
    const obj = {};
    const value = this.value;
    for (const key in value) {
      if (value[key] === defaultValue[key]) {
        continue;
      }
      obj[key] = value[key];
    }
    return obj;
  }
  get visible() {
    return this.value.visible;
  }
  set visible(visible) {
    const value = this.value;
    if (value.visible !== visible) {
      this.value = _Object$assign(_Object$assign({}, value), { visible });
      this.locationChanged.dispatch();
    }
  }
  reset() {
    if (this.value !== this.defaultValue) {
      this.value = this.defaultValue;
      this.locationChanged.dispatch();
    }
  }
  restoreState(obj, defaultLocation = this.defaultValue) {
    if (obj === void 0) return;
    verifyObject(obj);
    const location2 = {
      side: verifyOptionalObjectProperty(obj, "side", (x) => {
        if (x !== "left" && x !== "right" && x !== "top" && x !== "bottom") {
          throw new Error(`Expected "left", "right", "top", or "bottom", but received: ${_JSON$stringify(x)}`);
        }
        return x;
      }, defaultLocation.side),
      col: verifyOptionalObjectProperty(obj, "col", verifyFiniteFloat, defaultLocation.col),
      row: verifyOptionalObjectProperty(obj, "row", verifyFiniteFloat, defaultLocation.row),
      flex: verifyOptionalObjectProperty(obj, "flex", verifyFiniteFloat, defaultLocation.flex),
      size: verifyOptionalObjectProperty(obj, "size", verifyPositiveInt, defaultLocation.size),
      visible: verifyOptionalObjectProperty(obj, "visible", verifyBoolean, defaultLocation.visible),
      // minSize cannot be modified.
      minSize: defaultLocation.minSize
    };
    this.value = location2;
    this.locationChanged.dispatch();
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function startRelativeMouseDrag(initialEvent, handler, finishDragHandler) {
  const document2 = initialEvent.view.document;
  let prevClientX = initialEvent.clientX, prevClientY = initialEvent.clientY;
  const mouseMoveHandler = (e) => {
    const deltaX = e.clientX - prevClientX;
    const deltaY = e.clientY - prevClientY;
    prevClientX = e.clientX;
    prevClientY = e.clientY;
    handler(e, deltaX, deltaY);
  };
  const button = initialEvent.button;
  const cancel = (e) => {
    document2.removeEventListener("pointermove", mouseMoveHandler, true);
    document2.removeEventListener("pointerup", mouseUpHandler, false);
    if (finishDragHandler !== void 0) {
      finishDragHandler(e, e.clientX - prevClientX, e.clientY - prevClientY);
    }
  };
  const mouseUpHandler = (e) => {
    if (e.button === button) {
      cancel(e);
    }
  };
  document2.addEventListener("pointermove", mouseMoveHandler, true);
  document2.addEventListener("pointerup", mouseUpHandler, false);
  document2.addEventListener("pointercancel", cancel, false);
}
const svg_close = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="closeIconTitle"><title id="closeIconTitle">Close</title><path d="M6.34314575 6.34314575L17.6568542 17.6568542M6.34314575 17.6568542L17.6568542 6.34314575"></path></svg>';
const svg_refresh = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="refreshIconTitle"><title id="refreshIconTitle">Refresh</title><polyline points="22 12 19 15 16 12"></polyline><path d="M11,20 C6.581722,20 3,16.418278 3,12 C3,7.581722 6.581722,4 11,4 C15.418278,4 19,7.581722 19,12 L19,14"></path></svg>';
function makeIcon(options) {
  const title = options.title, onClick = options.onClick, href = options.href;
  let element;
  if (href !== void 0) {
    element = document.createElement("a");
    element.href = href;
    element.target = "_blank";
  } else {
    element = document.createElement("div");
  }
  if (title !== void 0) {
    element.title = title;
  }
  if (onClick !== void 0) {
    element.addEventListener("click", onClick);
  }
  const svg = options.svg;
  element.className = "neuroglancer-icon";
  if (svg !== void 0) {
    element.innerHTML = svg;
  }
  if (options.text !== void 0) {
    element.appendChild(document.createTextNode(options.text));
  }
  return element;
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function makeCloseButton(options = {}) {
  return makeIcon(_Object$assign({ svg: svg_close }, options));
}
function makeRefreshButton(options = {}) {
  return makeIcon(_Object$assign({ svg: svg_refresh }, options));
}
const DRAG_OVER_CLASSNAME = "neuroglancer-drag-over";
const LOCATION_KEY_FOR_DIRECTION = {
  "row": "row",
  "column": "col"
};
const OPPOSITE_SIDE = {
  "left": "right",
  "right": "left",
  "top": "bottom",
  "bottom": "top"
};
const FLEX_DIRECTION_FOR_SIDE = {
  "left": "column",
  "right": "column",
  "top": "row",
  "bottom": "row"
};
const CROSS_DIRECTION_FOR_SIDE = {
  "left": "row",
  "right": "row",
  "top": "column",
  "bottom": "column"
};
const SIZE_FOR_DIRECTION = {
  "row": "width",
  "column": "height"
};
const BEGIN_SIDE_FOR_DIRECTION = {
  "row": "left",
  "column": "top"
};
const END_SIDE_FOR_DIRECTION = {
  "row": "right",
  "column": "bottom"
};
const MARGIN_FOR_SIDE = {
  "left": "marginLeft",
  "right": "marginRight",
  "top": "marginTop",
  "bottom": "marginBottom"
};
const OUTWARDS_SIGN_FOR_SIDE = {
  "left": -1,
  "right": 1,
  "top": -1,
  "bottom": 1
};
class SidePanel extends RefCounted {
  constructor(sidePanelManager, location2 = new TrackableSidePanelLocation()) {
    super();
    this.sidePanelManager = sidePanelManager;
    this.location = location2;
    this.element = document.createElement("div");
    this.visibility = new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE);
    const element = this.element;
    element.classList.add("neuroglancer-side-panel");
    element.draggable = true;
    element.addEventListener("dragstart", (event) => {
      this.sidePanelManager.startDrag(this.makeDragSource(), event);
      element.style.backgroundColor = "black";
      setTimeout(() => {
        element.style.backgroundColor = "";
      }, 0);
      pushDragStatus(element, "drag", () => {
        return document.createTextNode("Drag side panel to move it to the left/right/top/bottom of another panel");
      });
    });
    element.addEventListener("dragend", (event) => {
      this.sidePanelManager.endDrag();
      popDragStatus(element, "drag");
    });
  }
  makeDragSource() {
    return {
      dropAsNewPanel: (location2) => {
        const oldLocation = this.location.value;
        this.location.value = _Object$assign(_Object$assign({}, oldLocation), location2);
        this.location.locationChanged.dispatch();
      }
    };
  }
  close() {
    this.location.visible = false;
  }
  addTitleBar(options) {
    const titleBar = document.createElement("div");
    titleBar.classList.add("neuroglancer-side-panel-titlebar");
    const title = options.title;
    let titleElement;
    if (title !== void 0) {
      titleElement = document.createElement("div");
      titleElement.classList.add("neuroglancer-side-panel-title");
      titleElement.textContent = title;
      titleBar.appendChild(titleElement);
    }
    const closeButton = makeCloseButton({
      title: "Close panel",
      onClick: () => {
        this.close();
      }
    });
    closeButton.style.order = "100";
    titleBar.appendChild(closeButton);
    this.element.appendChild(titleBar);
    return { titleBar, titleElement, closeButton };
  }
  addBody(body) {
    body.draggable = true;
    body.addEventListener("dragstart", (event) => {
      event.preventDefault();
      event.stopPropagation();
    });
    this.element.appendChild(body);
  }
}
class SidePanelManager extends RefCounted {
  constructor(display, center, visibility = new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE)) {
    super();
    this.display = display;
    this.center = center;
    this.visibility = visibility;
    this.element = document.createElement("div");
    this.centerColumn = document.createElement("div");
    this.beforeRender = new Signal();
    this.sides = {
      "left": this.makeSidePanelSideState("left"),
      "right": this.makeSidePanelSideState("right"),
      "top": this.makeSidePanelSideState("top"),
      "bottom": this.makeSidePanelSideState("bottom")
    };
    this.registeredPanels = new _Set();
    this.layoutNeedsUpdate = false;
    this.invalidateLayout = () => {
      this.layoutNeedsUpdate = true;
      this.display.scheduleRedraw();
    };
    const element = this.element, centerColumn = this.centerColumn;
    element.style.display = "flex";
    element.style.flex = "1";
    element.style.flexDirection = "row";
    centerColumn.style.display = "flex";
    centerColumn.style.flex = "1";
    centerColumn.style.flexDirection = "column";
    centerColumn.style.flexBasis = "0px";
    centerColumn.style.minWidth = "0px";
    this.render();
    this.registerDisposer(display.updateStarted.add(() => {
      this.beforeRender.dispatch();
      if (!this.layoutNeedsUpdate) return;
      this.render();
      ++display.resizeGeneration;
    }));
    this.registerDisposer(this.visibility.changed.add(this.invalidateLayout));
  }
  get visible() {
    return this.visibility.visible;
  }
  makeSidePanelSideState(side) {
    return {
      flexGroups: [],
      outerDropZoneElement: this.makeDropZone(
        side,
        /*crossIndex=*/
        OUTWARDS_SIGN_FOR_SIDE[side] * Infinity,
        /*flexIndex=*/
        0,
        /*zoneSide=*/
        side,
        /*centered=*/
        false
      )
    };
  }
  hasDroppablePanel() {
    return this.dragSource !== void 0;
  }
  startDrag(dragSource2, event) {
    setTimeout(() => {
      if (this.dragSource === dragSource2) {
        this.element.dataset.neuroglancerSidePanelDrag = "true";
      }
    }, 0);
    this.dragSource = dragSource2;
    event.stopPropagation();
    event.dataTransfer.setData("neuroglancer-side-panel", "");
  }
  endDrag() {
    delete this.element.dataset.neuroglancerSidePanelDrag;
    this.dragSource = void 0;
  }
  makeDropZone(side, crossIndex, flexIndex, zoneSide, centered = false) {
    const element = document.createElement("div");
    element.className = "neuroglancer-side-panel-drop-zone";
    const size = 10;
    const zoneFlexDirection = FLEX_DIRECTION_FOR_SIDE[zoneSide];
    const zoneCrossDirection = CROSS_DIRECTION_FOR_SIDE[zoneSide];
    element.style[SIZE_FOR_DIRECTION[zoneCrossDirection]] = `${size}px`;
    element.style[SIZE_FOR_DIRECTION[zoneFlexDirection]] = "100%";
    if (centered) {
      element.style.position = "absolute";
      element.style[zoneSide] = "50%";
      element.style[MARGIN_FOR_SIDE[zoneSide]] = "-${size/2}px";
    } else {
      element.style.position = "relative";
      element.style[MARGIN_FOR_SIDE[OPPOSITE_SIDE[zoneSide]]] = `-${size}px`;
    }
    element.addEventListener("dragenter", (event) => {
      if (!this.hasDroppablePanel()) return;
      element.classList.add(DRAG_OVER_CLASSNAME);
      event.preventDefault();
      pushDragStatus(element, "drop", () => document.createTextNode(`Drop side panel as new ${zoneFlexDirection}`));
    });
    element.addEventListener("dragleave", () => {
      popDragStatus(element, "drop");
      element.classList.remove(DRAG_OVER_CLASSNAME);
    });
    element.addEventListener("dragover", (event) => {
      if (!this.hasDroppablePanel()) return;
      event.preventDefault();
    });
    element.addEventListener("drop", (event) => {
      const dragSource2 = this.dragSource;
      if (dragSource2 === void 0) return;
      popDragStatus(element, "drop");
      element.classList.remove(DRAG_OVER_CLASSNAME);
      const flexDirection = FLEX_DIRECTION_FOR_SIDE[side];
      dragSource2.dropAsNewPanel({
        side,
        row: flexDirection === "column" ? flexIndex : crossIndex,
        col: flexDirection === "row" ? flexIndex : crossIndex
      });
      this.dragSource = void 0;
      event.preventDefault();
      event.stopPropagation();
    });
    return element;
  }
  registerPanel(registeredPanel) {
    this.registeredPanels.add(registeredPanel);
    this.invalidateLayout();
    registeredPanel.location.locationChanged.add(this.invalidateLayout);
    return () => {
      this.unregisterPanel(registeredPanel);
    };
  }
  unregisterPanel(registeredPanel) {
    var _a;
    this.registeredPanels.delete(registeredPanel);
    registeredPanel.location.locationChanged.remove(this.invalidateLayout);
    (_a = registeredPanel.panel) === null || _a === void 0 ? void 0 : _a.dispose();
    this.invalidateLayout();
  }
  disposed() {
    for (const _ref of this.registeredPanels) {
      const panel = _ref.panel;
      panel === null || panel === void 0 ? void 0 : panel.dispose();
    }
    super.disposed();
  }
  render() {
    this.layoutNeedsUpdate = false;
    const sides = { "left": [], "right": [], "top": [], "bottom": [] };
    for (const panel of this.registeredPanels) {
      sides[panel.location.value.side].push(panel);
    }
    const getSideChildren = (side) => this.renderSide(side, this.sides[side].flexGroups, sides[side]);
    const self2 = this;
    function* getRowChildren() {
      yield self2.sides["left"].outerDropZoneElement;
      yield* getSideChildren("left");
      yield self2.centerColumn;
      yield* getSideChildren("right");
      yield self2.sides["right"].outerDropZoneElement;
    }
    updateChildren(this.element, getRowChildren());
    function* getColumnChildren() {
      yield self2.sides["top"].outerDropZoneElement;
      yield* getSideChildren("top");
      yield self2.center;
      yield* getSideChildren("bottom");
      yield self2.sides["bottom"].outerDropZoneElement;
    }
    updateChildren(this.centerColumn, getColumnChildren());
  }
  makeCrossGutter(side, crossIndex) {
    const gutter = document.createElement("div");
    gutter.style.position = "relative";
    const direction = CROSS_DIRECTION_FOR_SIDE[side];
    gutter.className = `neuroglancer-resize-gutter-${direction === "row" ? "horizontal" : "vertical"}`;
    gutter.addEventListener("pointerdown", (event) => {
      if ("button" in event && event.button !== 0) {
        return;
      }
      event.preventDefault();
      const flexGroup = this.sides[side].flexGroups[crossIndex];
      if (flexGroup === void 0 || !flexGroup.visible) return;
      const initialRect = flexGroup.element.getBoundingClientRect();
      let size = initialRect[SIZE_FOR_DIRECTION[direction]];
      const minSize = flexGroup.minSize;
      const updateMessage = () => {
        pushDragStatus(gutter, "drag", `Drag to resize, current ${SIZE_FOR_DIRECTION[direction]} is ${flexGroup.crossSize}px`);
      };
      updateMessage();
      startRelativeMouseDrag(event, (_event, deltaX, deltaY) => {
        const delta = direction === "row" ? deltaX : deltaY;
        size -= OUTWARDS_SIGN_FOR_SIDE[side] * delta;
        flexGroup.crossSize = Math.max(minSize, Math.round(size));
        updateMessage();
        this.invalidateLayout();
      }, () => {
        popDragStatus(gutter, "drag");
      });
    });
    const dropZone = this.makeDropZone(
      side,
      crossIndex - OUTWARDS_SIGN_FOR_SIDE[side] * 0.5,
      /*flexIndex=*/
      0,
      /*zoneSide=*/
      side,
      /*centered=*/
      true
    );
    gutter.appendChild(dropZone);
    return gutter;
  }
  makeFlexGutter(side, crossIndex, flexIndex) {
    const gutter = document.createElement("div");
    gutter.style.position = "relative";
    const direction = FLEX_DIRECTION_FOR_SIDE[side];
    gutter.className = `neuroglancer-resize-gutter-${direction === "row" ? "horizontal" : "vertical"}`;
    gutter.addEventListener("pointerdown", (event) => {
      if ("button" in event && event.button !== 0) {
        return;
      }
      event.preventDefault();
      const flexGroup = this.sides[side].flexGroups[crossIndex];
      if (flexGroup === void 0 || !flexGroup.visible) return;
      const cells = flexGroup.cells;
      const cell = cells[flexIndex];
      if (cell === void 0 || !cell.registeredPanel.location.visible) return;
      let nextFlexIndex = flexIndex + 1;
      while (nextFlexIndex < cells.length && !cells[nextFlexIndex].registeredPanel.location.visible) {
        ++nextFlexIndex;
      }
      if (nextFlexIndex === cells.length) return;
      const nextCell = cells[nextFlexIndex];
      const updateMessage = () => {
        pushDragStatus(gutter, "drag", `Drag to resize, current ${SIZE_FOR_DIRECTION[direction]} ratio is ${cell.registeredPanel.location.value.flex} : ${nextCell.registeredPanel.location.value.flex}`);
      };
      updateMessage();
      startRelativeMouseDrag(event, (newEvent) => {
        const firstPanel = cell.registeredPanel.panel;
        const secondPanel = nextCell.registeredPanel.panel;
        if (firstPanel === void 0 || secondPanel === void 0) return;
        const firstRect = firstPanel.element.getBoundingClientRect();
        const secondRect = secondPanel.element.getBoundingClientRect();
        const firstFraction = Math.max(0.1, Math.min(0.9, direction === "column" ? (newEvent.clientY - firstRect.top) / (secondRect.bottom - firstRect.top) : (newEvent.clientX - firstRect.left) / (secondRect.right - firstRect.left)));
        const firstLocation = cell.registeredPanel.location.value;
        const secondLocation = nextCell.registeredPanel.location.value;
        const existingFlexSum = firstLocation.flex + secondLocation.flex;
        cell.registeredPanel.location.value = _Object$assign(_Object$assign({}, firstLocation), { flex: Math.round(firstFraction * existingFlexSum * 100) / 100 });
        nextCell.registeredPanel.location.value = _Object$assign(_Object$assign({}, secondLocation), { flex: Math.round((1 - firstFraction) * existingFlexSum * 100) / 100 });
        updateMessage();
        cell.registeredPanel.location.locationChanged.dispatch();
        nextCell.registeredPanel.location.locationChanged.dispatch();
        this.invalidateLayout();
      }, () => {
        popDragStatus(gutter, "drag");
      });
    });
    const dropZone = this.makeDropZone(
      side,
      crossIndex,
      /*flexIndex=*/
      flexIndex + 0.5,
      /*zoneSide=*/
      BEGIN_SIDE_FOR_DIRECTION[FLEX_DIRECTION_FOR_SIDE[side]],
      /*centered=*/
      true
    );
    gutter.appendChild(dropZone);
    return gutter;
  }
  renderSide(side, flexGroups, panels) {
    const flexKey = LOCATION_KEY_FOR_DIRECTION[CROSS_DIRECTION_FOR_SIDE[side]];
    const crossKey = LOCATION_KEY_FOR_DIRECTION[FLEX_DIRECTION_FOR_SIDE[side]];
    panels.sort((a, b) => {
      const aLoc = a.location.value, bLoc = b.location.value;
      const crossDiff = aLoc[crossKey] - bLoc[crossKey];
      if (crossDiff !== 0) return crossDiff;
      return aLoc[flexKey] - bLoc[flexKey];
    });
    const self2 = this;
    function* getFlexGroups() {
      let panelIndex = 0, numPanels = panels.length;
      let crossIndex = 0;
      for (; panelIndex < numPanels; ) {
        const origCrossIndex = panels[panelIndex].location.value[crossKey];
        let endPanelIndex = panelIndex;
        let numVisible = 0;
        let minSize = 0;
        do {
          const location2 = panels[endPanelIndex].location.value;
          if (location2[crossKey] !== origCrossIndex) break;
          if (location2.visible) {
            ++numVisible;
            minSize = Math.max(minSize, location2.minSize);
          }
          ++endPanelIndex;
        } while (endPanelIndex < numPanels);
        const visible = numVisible > 0;
        let flexGroup = flexGroups[crossIndex];
        if (flexGroup === void 0) {
          const gutter = self2.makeCrossGutter(side, crossIndex);
          const flexGroupElement = document.createElement("div");
          flexGroupElement.className = `neuroglancer-side-panel-${FLEX_DIRECTION_FOR_SIDE[side]}`;
          flexGroup = flexGroups[crossIndex] = {
            element: flexGroupElement,
            gutterElement: gutter,
            cells: [],
            crossSize: -1,
            minSize,
            visible,
            beginDropZone: self2.makeDropZone(
              side,
              crossIndex,
              /*flexIndex=*/
              -Infinity,
              BEGIN_SIDE_FOR_DIRECTION[FLEX_DIRECTION_FOR_SIDE[side]]
            ),
            endDropZone: self2.makeDropZone(
              side,
              crossIndex,
              /*flexIndex=*/
              Infinity,
              END_SIDE_FOR_DIRECTION[FLEX_DIRECTION_FOR_SIDE[side]]
            )
          };
        } else {
          flexGroup.visible = visible;
          flexGroup.minSize = minSize;
          flexGroup.crossSize = Math.max(flexGroup.crossSize, minSize);
        }
        function* getCells() {
          yield flexGroup.beginDropZone;
          let prevVisible = 0;
          for (let i = panelIndex, flexIndex = 0; i < endPanelIndex; ++i, ++flexIndex) {
            const registeredPanel = panels[i];
            let cell = flexGroup.cells[flexIndex];
            if (cell === void 0) {
              cell = flexGroup.cells[flexIndex] = {
                registeredPanel,
                gutterElement: void 0
              };
            } else {
              cell.registeredPanel = registeredPanel;
            }
            const oldLocation = cell.registeredPanel.location.value;
            if (flexGroup.crossSize == -1) {
              flexGroup.crossSize = Math.max(minSize, oldLocation.size);
            }
            if (oldLocation[crossKey] !== crossIndex || oldLocation[flexKey] !== flexIndex || oldLocation.visible && oldLocation.size !== flexGroup.crossSize) {
              cell.registeredPanel.location.value = _Object$assign(_Object$assign({}, oldLocation), { [crossKey]: crossIndex, [flexKey]: flexIndex, size: oldLocation.visible ? flexGroup.crossSize : oldLocation.size });
              cell.registeredPanel.location.changed.dispatch();
            }
            const visible2 = oldLocation.visible && self2.visibility.visible;
            let panel = registeredPanel.panel;
            if (!visible2) {
              if (panel !== void 0) {
                panel.dispose();
                registeredPanel.panel = void 0;
              }
              continue;
            }
            ++prevVisible;
            if (panel === void 0) {
              panel = registeredPanel.panel = registeredPanel.makePanel();
            }
            panel.element.style.flex = numVisible > 1 ? `${oldLocation.flex}` : "1";
            yield panel.element;
            if (prevVisible === numVisible) {
              cell.gutterElement = void 0;
            } else {
              if (cell.gutterElement === void 0) {
                cell.gutterElement = self2.makeFlexGutter(side, crossIndex, flexIndex);
              }
              yield cell.gutterElement;
            }
          }
          yield flexGroup.endDropZone;
        }
        updateChildren(flexGroup.element, getCells());
        flexGroup.cells.length = endPanelIndex - panelIndex;
        if (visible) {
          flexGroup.element.style[SIZE_FOR_DIRECTION[CROSS_DIRECTION_FOR_SIDE[side]]] = `${flexGroup.crossSize}px`;
          if (OUTWARDS_SIGN_FOR_SIDE[side] > 0) {
            yield flexGroup.gutterElement;
            yield flexGroup.element;
          } else {
            yield flexGroup.element;
            yield flexGroup.gutterElement;
          }
        }
        panelIndex = endPanelIndex;
        ++crossIndex;
      }
      flexGroups.length = crossIndex;
    }
    return getFlexGroups();
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function setClipboard(data, format = "text/plain") {
  let success = false;
  const cleanup = registerEventListener(document, "copy", (event) => {
    const clipboardData = event.clipboardData;
    if (clipboardData !== null) {
      clipboardData.setData(format, data);
      success = true;
    }
    event.stopPropagation();
    event.preventDefault();
  }, true);
  try {
    document.execCommand("copy");
  } finally {
    cleanup();
  }
  return success;
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MouseEventBinder extends RefCounted {
  constructor(target, eventMap, commonHandler) {
    super();
    this.target = target;
    this.eventMap = eventMap;
    this.registerEventListener(target, "wheel", (event) => {
      if (commonHandler !== void 0) commonHandler(event);
      this.dispatch("wheel", event);
    });
    this.registerEventListener(target, "click", (event) => {
      if (commonHandler !== void 0) commonHandler(event);
      this.dispatch(`click${event.button}`, event);
    });
    this.registerEventListener(target, "dblclick", (event) => {
      if (commonHandler !== void 0) commonHandler(event);
      this.dispatch(`dblclick${event.button}`, event);
    });
    this.registerEventListener(target, "mousedown", (event) => {
      if (commonHandler !== void 0) commonHandler(event);
      let button = event.button;
      if (button === 2 && (event.buttons & 3) === 1) {
        button = 0;
      }
      this.dispatch(`mousedown${button}`, event);
    });
    this.registerEventListener(target, "mouseup", (event) => {
      if (commonHandler !== void 0) commonHandler(event);
      this.dispatch(`mouseup${event.button}`, event);
    });
  }
  dispatch(baseIdentifier, event) {
    dispatchEventWithModifiers(baseIdentifier, event, event, this.eventMap);
  }
}
class CheckboxIcon extends RefCounted {
  constructor(model, options) {
    super();
    this.element = makeIcon(_Object$assign(_Object$assign({}, options), { onClick: () => {
      model.value = !model.value;
    } }));
    this.element.classList.add("neuroglancer-checkbox-icon");
    this.element.classList.add(options.backgroundScheme === "dark" ? "dark-background" : "light-background");
    const updateView = () => {
      const value = model.value;
      this.element.dataset.checked = value ? "true" : "false";
      this.element.title = (value ? options.disableTitle : options.enableTitle) || "";
    };
    this.registerDisposer(model.changed.add(updateView));
    updateView();
  }
}
const svg_copy = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="copyIconTitle"><title id="copyIconTitle">Copy</title><rect width="12" height="14" x="8" y="7"></rect><polyline points="16 3 4 3 4 17"></polyline></svg>';
function makeCopyButton(options = {}) {
  return makeIcon(_Object$assign({ svg: svg_copy }, options));
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DependentViewContext extends RefCounted {
  constructor(redraw) {
    super();
    this.redraw = redraw;
  }
}
class DependentViewWidget extends RefCounted {
  constructor(model, render, visibility = new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE)) {
    super();
    this.model = model;
    this.render = render;
    this.visibility = visibility;
    this.element = document.createElement("div");
    this.generation = -1;
    this.currentViewDisposer = void 0;
    this.debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateView()));
    this.element.style.display = "contents";
    this.registerDisposer(model.changed.add(this.debouncedUpdateView));
    this.registerDisposer(visibility.changed.add(() => {
      if (this.visible) this.debouncedUpdateView();
    }));
    this.updateView();
  }
  get visible() {
    return this.visibility.visible;
  }
  updateView() {
    if (!this.visible) return;
    const model = this.model;
    const generation = model.changed.count;
    if (generation === this.generation) return;
    this.disposeCurrentView();
    const currentViewDisposer = this.currentViewDisposer = new DependentViewContext(this.debouncedUpdateView);
    this.render(model.value, this.element, currentViewDisposer);
  }
  disposeCurrentView() {
    let currentViewDisposer = this.currentViewDisposer;
    if (currentViewDisposer !== void 0) {
      currentViewDisposer.dispose();
    }
    removeChildren(this.element);
  }
  disposed() {
    this.disposeCurrentView();
    super.disposed();
  }
}
function makeMoveToButton(options = {}) {
  return makeIcon(_Object$assign({ text: "↗" }, options));
}
function isWithinSelectionPanel(element) {
  return element.closest(".neuroglancer-selection-details");
}
class SelectionDetailsPanel extends SidePanel {
  constructor(sidePanelManager, state, manager, selectedLayer) {
    super(sidePanelManager, state.location);
    this.sidePanelManager = sidePanelManager;
    this.state = state;
    this.manager = manager;
    this.selectedLayer = selectedLayer;
    this.body = document.createElement("div");
    const element = this.element, body = this.body;
    element.classList.add("neuroglancer-selection-details");
    this.registerDisposer(new MouseEventBinder(this.element, getDefaultSelectBindings()));
    var _addTitleBar = this.addTitleBar({ title: "Selection" });
    const titleBar = _addTitleBar.titleBar;
    const backButton = makeIcon({
      svg: svg_arrowLeft,
      title: "Previous selection",
      onClick: () => {
        this.state.goBack();
      }
    });
    const forwardButton = makeIcon({
      svg: svg_arrowRight,
      title: "Next selection",
      onClick: () => {
        this.state.goForward();
      }
    });
    titleBar.appendChild(backButton);
    titleBar.appendChild(forwardButton);
    titleBar.appendChild(this.registerDisposer(new CheckboxIcon(state.pin, {
      // Note: \ufe0e forces text display, as otherwise the pin icon may as an emoji with
      // color.
      text: "📌︎",
      enableTitle: "Pin selection",
      disableTitle: "Unpin selection"
    })).element);
    body.classList.add("neuroglancer-selection-details-body");
    this.addBody(body);
    body.appendChild(this.registerDisposer(new DependentViewWidget(state, (stateValue, parent, context) => {
      if (!state.location.visible) return;
      backButton.style.visibility = state.canGoBack() ? "visible" : "hidden";
      forwardButton.style.visibility = state.canGoForward() ? "visible" : "hidden";
      if (stateValue === void 0) return;
      const position = stateValue.position;
      if (position !== void 0) {
        const positionElement = document.createElement("div");
        positionElement.classList.add("neuroglancer-selection-details-position");
        const copyButton = makeCopyButton({
          title: "Copy position",
          onClick: () => {
            setClipboard(position2.map((x) => Math.floor(x)).join(", "));
          }
        });
        positionElement.appendChild(copyButton);
        var _stateValue$coordinat = stateValue.coordinateSpace;
        const rank = _stateValue$coordinat.rank, names = _stateValue$coordinat.names, position2 = stateValue.position;
        for (let i = 0; i < rank; ++i) {
          const dimElement = document.createElement("span");
          dimElement.classList.add("neuroglancer-selection-details-position-dimension");
          const nameElement = document.createElement("span");
          nameElement.classList.add("neuroglancer-selection-details-position-dimension-name");
          nameElement.textContent = names[i];
          const coordinateElement = document.createElement("span");
          coordinateElement.classList.add("neuroglancer-selection-details-position-dimension-coordinate");
          coordinateElement.textContent = Math.floor(position2[i]).toString();
          dimElement.appendChild(nameElement);
          dimElement.appendChild(coordinateElement);
          positionElement.appendChild(dimElement);
        }
        const moveToButton = makeMoveToButton({
          title: "Move to position",
          onClick: () => {
            this.manager.globalPosition.value = position2;
          }
        });
        positionElement.appendChild(moveToButton);
        parent.appendChild(positionElement);
      }
      for (const layerData of stateValue.layers) {
        const layer = layerData.layer;
        parent.appendChild(context.registerDisposer(new DependentViewWidget({
          value: void 0,
          changed: layer.managedLayer.layerChanged
        }, (_, parent2, context2) => {
          if (layer.wasDisposed) return;
          if (!layer.isReady) {
            return;
          }
          const layerBody = document.createElement("div");
          layerBody.classList.add("neuroglancer-selection-details-layer-body");
          if (!layer.displaySelectionState(layerData.state, layerBody, context2)) {
            return;
          }
          const layerElement = document.createElement("div");
          parent2.appendChild(layerElement);
          layerElement.classList.add("neuroglancer-selection-details-layer");
          const layerTitle = document.createElement("div");
          layerTitle.classList.add("neuroglancer-selection-details-layer-title");
          layerTitle.textContent = layer.managedLayer.name;
          layerTitle.addEventListener("click", () => {
            this.selectedLayer.layer = layer.managedLayer;
            this.selectedLayer.visible = true;
          });
          layerTitle.title = "Click to show layer side panel";
          layerElement.appendChild(layerTitle);
          layerElement.appendChild(layerBody);
        })).element);
      }
    })).element);
  }
  close() {
    super.close();
    this.state.value = void 0;
    this.state.pin.value = true;
  }
}
const svg_filter = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="filterIconTitle"><title id="filterIconTitle">Filter</title><path d="M10 12.261L4.028 3.972h16L14 12.329V17l-4 3z"></path></svg>';
function makeFilterButton(options = {}) {
  return makeIcon(_Object$assign({ svg: svg_filter }, options));
}
class Uint64MapEntry {
  constructor(key, value, label) {
    this.key = key;
    this.value = value;
    this.label = label;
  }
  toString() {
    const key = this.key, value = this.value, label = this.label;
    let baseString;
    if (value === void 0) {
      baseString = `${key}`;
    } else {
      baseString = `${key}→${value}`;
    }
    if (label === void 0) return baseString;
    return `${baseString} ${label}`;
  }
}
class SegmentSelectionState extends RefCounted {
  constructor() {
    super(...arguments);
    this.selectedSegment = new Uint64();
    this.baseSelectedSegment = new Uint64();
    this.hasSelectedSegment = false;
    this.changed = new NullarySignal();
  }
  get value() {
    return this.hasSelectedSegment ? this.selectedSegment : void 0;
  }
  get baseValue() {
    return this.hasSelectedSegment ? this.baseSelectedSegment : void 0;
  }
  set(value, hideSegmentZero = false) {
    const selectedSegment = this.selectedSegment, baseSelectedSegment = this.baseSelectedSegment;
    let newLow = 0, newHigh = 0, newBaseLow = 0, newBaseHigh = 0;
    let hasSelectedSegment;
    if (value == null) {
      hasSelectedSegment = false;
    } else if (typeof value === "number") {
      newLow = newBaseLow = value >>> 0;
      newHigh = newBaseHigh = value < 0 ? 4294967295 : 0;
      hasSelectedSegment = true;
    } else if (value instanceof Uint64MapEntry) {
      const valueMapped = value.value || value.key;
      newLow = valueMapped.low;
      newHigh = valueMapped.high;
      newBaseLow = value.key.low;
      newBaseHigh = value.key.high;
      hasSelectedSegment = true;
    } else if (value instanceof Uint64) {
      newLow = newBaseLow = value.low;
      newHigh = newBaseHigh = value.high;
      hasSelectedSegment = true;
    } else {
      hasSelectedSegment = false;
    }
    if (hideSegmentZero && newLow === 0 && newHigh === 0) {
      hasSelectedSegment = false;
    }
    if (!hasSelectedSegment) {
      if (this.hasSelectedSegment) {
        this.hasSelectedSegment = false;
        this.changed.dispatch();
      }
    } else if (hasSelectedSegment && (!this.hasSelectedSegment || selectedSegment.low !== newLow || selectedSegment.high !== newHigh || baseSelectedSegment.low !== newBaseLow || baseSelectedSegment.high !== newBaseHigh)) {
      selectedSegment.low = newLow;
      selectedSegment.high = newHigh;
      baseSelectedSegment.low = newBaseLow;
      baseSelectedSegment.high = newBaseHigh;
      this.hasSelectedSegment = true;
      this.changed.dispatch();
    }
  }
  isSelected(value) {
    return this.hasSelectedSegment && Uint64.equal(value, this.selectedSegment);
  }
  bindTo(layerSelectedValues, userLayer) {
    this.registerDisposer(layerSelectedValues.changed.add(() => {
      const state = layerSelectedValues.get(userLayer);
      let value = void 0;
      if (state !== void 0) {
        value = state.value;
      }
      this.set(value, userLayer.displayState.segmentationGroupState.value.hideSegmentZero.value);
    }));
  }
}
function resetTemporaryVisibleSegmentsState(state) {
  state.useTemporarySegmentEquivalences.value = false;
  state.useTemporaryVisibleSegments.value = false;
  state.temporaryVisibleSegments.clear();
  state.temporarySegmentEquivalences.clear();
}
function maybeAugmentSegmentId(displayState, value, mustCopy = false) {
  let id;
  let mappedValue;
  let mapped;
  let label;
  if (typeof value === "number") {
    id = new Uint64(value >>> 0, value < 0 ? 4294967295 : 0);
  } else if (typeof value === "string") {
    id = Uint64.parseString(value);
  } else {
    id = mustCopy ? value.clone() : value;
  }
  if (displayState == null) return id;
  var _displayState$segment = displayState.segmentationGroupState.value;
  const segmentEquivalences = _displayState$segment.segmentEquivalences, segmentPropertyMap = _displayState$segment.segmentPropertyMap.value;
  if (segmentEquivalences.size !== 0) {
    mappedValue = segmentEquivalences.get(id);
    if (Uint64.equal(mappedValue, id)) {
      mapped = void 0;
    } else {
      mapped = mappedValue;
    }
  } else {
    mappedValue = id;
  }
  label = segmentPropertyMap === null || segmentPropertyMap === void 0 ? void 0 : segmentPropertyMap.getSegmentLabel(mappedValue);
  if (label === void 0 && mapped == void 0) {
    return id;
  }
  return new Uint64MapEntry(id, mapped, label);
}
function augmentSegmentId(displayState, value) {
  if (value instanceof Uint64MapEntry) return value;
  let newValue = maybeAugmentSegmentId(displayState, value);
  if (newValue instanceof Uint64) {
    return new Uint64MapEntry(newValue);
  }
  return newValue;
}
function updateIdStringWidth(idStringWidth, idString) {
  const length2 = idString.length;
  if (idStringWidth.value < length2) {
    idStringWidth.value = length2;
  }
}
function bindSegmentListWidth(displayState, element) {
  return observeWatchable((width) => element.style.setProperty("--neuroglancer-segment-list-width", `${width}ch`), displayState.segmentationGroupState.value.maxIdLength);
}
const segmentWidgetTemplate = (() => {
  const template = document.createElement("div");
  template.classList.add("neuroglancer-segment-list-entry");
  const stickyContainer = document.createElement("div");
  stickyContainer.classList.add("neuroglancer-segment-list-entry-sticky");
  template.appendChild(stickyContainer);
  const copyButton = makeCopyButton({
    title: `Copy segment ID`
  });
  copyButton.classList.add("neuroglancer-segment-list-entry-copy");
  const copyContainer = document.createElement("div");
  copyContainer.classList.add("neuroglancer-segment-list-entry-copy-container");
  const copyIndex = copyContainer.childElementCount;
  copyContainer.appendChild(copyButton);
  const copyContainerIndex = stickyContainer.childElementCount;
  stickyContainer.appendChild(copyContainer);
  const visibleIndex = stickyContainer.childElementCount;
  const checkbox = document.createElement("input");
  checkbox.type = "checkbox";
  checkbox.title = "Toggle segment visibility";
  checkbox.classList.add("neuroglancer-segment-list-entry-visible-checkbox");
  stickyContainer.appendChild(checkbox);
  const idContainer = document.createElement("div");
  idContainer.classList.add("neuroglancer-segment-list-entry-id-container");
  const idContainerIndex = stickyContainer.childElementCount;
  stickyContainer.appendChild(idContainer);
  const idElement = document.createElement("div");
  idElement.classList.add("neuroglancer-segment-list-entry-id");
  const idIndex = idContainer.childElementCount;
  idContainer.appendChild(idElement);
  const nameElement = document.createElement("span");
  nameElement.classList.add("neuroglancer-segment-list-entry-name");
  const labelIndex = template.childElementCount;
  template.appendChild(nameElement);
  const filterElement = makeFilterButton({
    title: "Filter by label"
  });
  filterElement.classList.add("neuroglancer-segment-list-entry-filter");
  const filterIndex = template.childElementCount;
  template.appendChild(filterElement);
  return {
    template,
    copyContainerIndex,
    copyIndex,
    visibleIndex,
    idContainerIndex,
    idIndex,
    labelIndex,
    filterIndex,
    unmappedIdIndex: -1,
    unmappedCopyIndex: -1
  };
})();
const segmentWidgetTemplateWithUnmapped = (() => {
  const t = segmentWidgetTemplate;
  const template = t.template.cloneNode(
    /*deep=*/
    true
  );
  const stickyContainer = template.children[0];
  const idContainer = stickyContainer.children[t.idContainerIndex];
  const unmappedIdIndex = idContainer.childElementCount;
  const unmappedIdElement = idContainer.children[t.idIndex].cloneNode(
    /*deep=*/
    true
  );
  unmappedIdElement.classList.add("neuroglancer-segment-list-entry-unmapped-id");
  idContainer.appendChild(unmappedIdElement);
  const copyContainer = stickyContainer.children[t.copyContainerIndex];
  const unmappedCopyIndex = copyContainer.childElementCount;
  copyContainer.appendChild(copyContainer.children[t.copyIndex].cloneNode(
    /*deep=*/
    true
  ));
  return _Object$assign(_Object$assign({}, t), { template, unmappedIdIndex, unmappedCopyIndex });
})();
function segmentWidgetTemplateWithExtraColumns(numExtraColumns) {
  let origTemplate = segmentWidgetTemplate;
  const templateElement = origTemplate.template.cloneNode(
    /*deep=*/
    true
  );
  const numericalPropertyIndices = [];
  for (let i = 0; i < numExtraColumns; ++i) {
    numericalPropertyIndices.push(templateElement.childElementCount);
    const child = document.createElement("div");
    child.classList.add("neuroglancer-segment-list-entry-extra-property");
    child.style.width = `max(var(--neuroglancer-column-${i}-width), var(--neuroglancer-column-${i}-label-width))`;
    templateElement.appendChild(child);
  }
  return _Object$assign(_Object$assign({}, origTemplate), { template: templateElement, numericalPropertyIndices });
}
const cachedRegisterSegmentWidgetEventHandlers = new _WeakMap();
function makeRegisterSegmentWidgetEventHandlers(displayState) {
  const onMouseEnter = (event) => {
    const entryElement = event.currentTarget;
    const idString = entryElement.dataset.id;
    const id = tempStatedColor;
    id.tryParseString(idString);
    displayState.segmentSelectionState.set(id);
    if (!isWithinSelectionPanel(entryElement)) {
      displayState.selectSegment(id, false);
    }
  };
  const selectHandler = (event) => {
    const entryElement = event.currentTarget;
    const idString = entryElement.dataset.id;
    const id = tempStatedColor;
    id.tryParseString(idString);
    displayState.selectSegment(id, isWithinSelectionPanel(entryElement) ? "toggle" : true);
  };
  const onMouseLeave = () => {
    displayState.segmentSelectionState.set(null);
  };
  const getEntryElement = (event) => {
    return event.currentTarget.closest(".neuroglancer-segment-list-entry");
  };
  const copyHandler = (event) => {
    const entryElement = getEntryElement(event);
    setClipboard(entryElement.dataset.id);
    event.stopPropagation();
  };
  const unmappedCopyHandler = (event) => {
    const entryElement = getEntryElement(event);
    setClipboard(entryElement.dataset.unmappedId);
    event.stopPropagation();
  };
  const visibleCheckboxHandler = (event) => {
    const entryElement = getEntryElement(event);
    const idString = entryElement.dataset.id;
    const id = tempStatedColor;
    id.tryParseString(idString);
    const visibleSegments = displayState.segmentationGroupState.value.visibleSegments;
    visibleSegments.set(id, !visibleSegments.has(id));
    event.stopPropagation();
  };
  const filterHandler = (event) => {
    const entryElement = getEntryElement(event);
    const idString = entryElement.dataset.id;
    const id = tempStatedColor;
    id.tryParseString(idString);
    displayState.filterBySegmentLabel(id);
    event.stopPropagation();
  };
  const onMousedown = (event) => {
    if (event.button !== 2 || event.ctrlKey || event.altKey || event.metaKey || event.shiftKey) {
      return;
    }
    const entryElement = event.currentTarget;
    const idString = entryElement.dataset.id;
    const id = tempStatedColor;
    id.tryParseString(idString);
    displayState.moveToSegment(id);
  };
  return (element, template) => {
    const children = element.children;
    const stickyChildren = children[0].children;
    element.addEventListener("mousedown", onMousedown);
    const copyContainer = stickyChildren[template.copyContainerIndex];
    if (template.unmappedCopyIndex !== -1) {
      copyContainer.children[template.unmappedCopyIndex].addEventListener("click", unmappedCopyHandler);
    }
    copyContainer.children[template.copyIndex].addEventListener("click", copyHandler);
    element.addEventListener("mouseenter", onMouseEnter);
    element.addEventListener("mouseleave", onMouseLeave);
    stickyChildren[template.visibleIndex].addEventListener("click", visibleCheckboxHandler);
    children[template.filterIndex].addEventListener("click", filterHandler);
    element.addEventListener("action:select-position", selectHandler);
  };
}
class SegmentWidgetFactory {
  constructor(displayState, template) {
    this.displayState = displayState;
    this.template = template;
    if (displayState !== void 0) {
      let r = cachedRegisterSegmentWidgetEventHandlers.get(displayState);
      if (r === void 0) {
        r = makeRegisterSegmentWidgetEventHandlers(displayState);
        cachedRegisterSegmentWidgetEventHandlers.set(displayState, r);
      }
      this.registerEventHandlers = r;
    }
  }
  static make(displayState, includeUnmapped) {
    return new SegmentWidgetFactory(displayState, includeUnmapped ? segmentWidgetTemplateWithUnmapped : segmentWidgetTemplate);
  }
  get(rawId) {
    const displayState = this.displayState;
    return this.getWithNormalizedId(augmentSegmentId(displayState, rawId));
  }
  getWithNormalizedId(normalizedId) {
    var _a, _b;
    const displayState = this.displayState;
    const template = this.template;
    const container = template.template.cloneNode(
      /*deep=*/
      true
    );
    const id = normalizedId.key;
    const mapped = (_a = normalizedId.value) !== null && _a !== void 0 ? _a : id;
    const mappedIdString = mapped.toString();
    container.dataset.id = mappedIdString;
    const children = container.children;
    const stickyChildren = children[0].children;
    const idContainer = stickyChildren[template.idContainerIndex];
    idContainer.children[template.idIndex].textContent = mappedIdString;
    const unmappedIdIndex = template.unmappedIdIndex;
    if (displayState !== void 0) {
      this.registerEventHandlers(container, template);
    } else {
      stickyChildren[template.visibleIndex].style.display = "none";
    }
    if (unmappedIdIndex !== -1) {
      const unmappedIdElement = idContainer.children[unmappedIdIndex];
      if (!Uint64.equal(id, mapped)) {
        const unmappedIdString = id.toString();
        container.dataset.unmappedId = unmappedIdString;
        unmappedIdElement.textContent = unmappedIdString;
        if (displayState !== void 0) {
          updateIdStringWidth(displayState.segmentationGroupState.value.maxIdLength, unmappedIdString);
        }
      } else {
        unmappedIdElement.style.display = "none";
        const copyContainer = stickyChildren[template.copyContainerIndex];
        copyContainer.children[template.unmappedCopyIndex].style.display = "none";
      }
    }
    children[template.labelIndex].textContent = (_b = normalizedId.label) !== null && _b !== void 0 ? _b : "";
    if (displayState !== void 0) {
      this.updateWithId(container, mapped);
      updateIdStringWidth(displayState.segmentationGroupState.value.maxIdLength, mappedIdString);
    }
    return container;
  }
  update(container) {
    const id = tempStatedColor;
    const idString = container.dataset.id;
    if (idString === void 0) return;
    id.parseString(idString);
    this.updateWithId(container, id);
  }
  updateWithId(container, mapped) {
    const children = container.children;
    const stickyChildren = children[0].children;
    const template = this.template;
    const displayState = this.displayState;
    const segmentSelectionState = displayState.segmentSelectionState;
    const visibleSegments = displayState.segmentationGroupState.value.visibleSegments;
    stickyChildren[template.visibleIndex].checked = visibleSegments.has(mapped);
    container.dataset.selected = (segmentSelectionState.hasSelectedSegment && Uint64.equal(segmentSelectionState.selectedSegment, mapped)).toString();
    const idContainer = stickyChildren[template.idContainerIndex];
    setSegmentIdElementStyle(idContainer.children[template.idIndex], getBaseObjectColor(this.displayState, mapped));
    const unmappedIdIndex = template.unmappedIdIndex;
    if (unmappedIdIndex !== -1) {
      let unmappedIdString;
      let color2;
      if (displayState.baseSegmentColoring.value && (unmappedIdString = container.dataset.unmappedId) !== void 0) {
        const unmappedId = tempStatedColor;
        unmappedId.parseString(unmappedIdString);
        color2 = getBaseObjectColor(this.displayState, unmappedId);
      } else {
        color2 = kOneVec;
      }
      setSegmentIdElementStyle(idContainer.children[unmappedIdIndex], color2);
    }
  }
}
function setSegmentIdElementStyle(element, color2) {
  element.style.backgroundColor = getCssColor(color2);
  element.style.color = useWhiteBackground(color2) ? "white" : "black";
}
class SegmentWidgetWithExtraColumnsFactory extends SegmentWidgetFactory {
  constructor(displayState, parentElement, includeProperty) {
    var _a;
    const segmentPropertyMap = displayState.segmentationGroupState.value.segmentPropertyMap.value;
    const numericalProperties = ((_a = segmentPropertyMap === null || segmentPropertyMap === void 0 ? void 0 : segmentPropertyMap.numericalProperties) !== null && _a !== void 0 ? _a : []).filter(includeProperty);
    const template = segmentWidgetTemplateWithExtraColumns(numericalProperties.length);
    super(displayState, template);
    this.parentElement = parentElement;
    this.segmentPropertyMap = segmentPropertyMap;
    this.numericalProperties = numericalProperties;
    const numericalPropertyWidths = this.numericalPropertyWidths = new Array(this.numericalProperties.length);
    numericalPropertyWidths.fill(0);
  }
  getWithNormalizedId(normalizedId) {
    var _a, _b, _c;
    const container = super.getWithNormalizedId(normalizedId);
    const numericalProperties = this.numericalProperties;
    const numericalPropertyIndices = this.template.numericalPropertyIndices;
    if (numericalPropertyIndices.length > 0) {
      const index2 = (_c = (_a = this.segmentPropertyMap) === null || _a === void 0 ? void 0 : _a.getSegmentInlineIndex((_b = normalizedId.value) !== null && _b !== void 0 ? _b : normalizedId.key)) !== null && _c !== void 0 ? _c : -1;
      if (index2 !== -1) {
        const numericalPropertyWidths = this.numericalPropertyWidths;
        for (let i = 0, n = numericalPropertyIndices.length; i < n; ++i) {
          const value = numericalProperties[i].values[index2];
          if (!isNaN(value)) {
            const s = value.toString();
            const w = s.length;
            if (w > numericalPropertyWidths[i]) {
              numericalPropertyWidths[i] = w;
              this.parentElement.style.setProperty(`--neuroglancer-column-${i}-width`, `${w}ch`);
            }
            container.children[numericalPropertyIndices[i]].textContent = s;
          }
        }
      }
    }
    return container;
  }
  makeHeaderLabel(id, widthProperty, parent) {
    const label = document.createElement("span");
    label.textContent = id;
    label.classList.add("neuroglancer-segment-list-header-label");
    label.classList.add("neuroglancer-segment-list-header-label");
    if (id === "label") {
      parent.style.textAlign = "left";
    }
    const sortIcon = document.createElement("span");
    sortIcon.classList.add("neuroglancer-segment-list-header-label-sort");
    label.appendChild(sortIcon);
    sortIcon.textContent = "▲";
    const width = measureElementClone(label).width;
    this.parentElement.style.setProperty(widthProperty, `${width}px`);
    parent.appendChild(label);
    return { id, label, sortIcon };
  }
  getHeader() {
    const template = this.template;
    const container = template.template.cloneNode(
      /*deep=*/
      true
    );
    const children = container.children;
    const stickyChildren = children[0].children;
    const copyContainer = stickyChildren[template.copyContainerIndex];
    copyContainer.style.visibility = "hidden";
    stickyChildren[template.visibleIndex].style.visibility = "hidden";
    children[template.filterIndex].style.visibility = "hidden";
    const idContainer = stickyChildren[template.idContainerIndex];
    const propertyLabels = [this.makeHeaderLabel("id", "--neuroglancer-id-column-label-width", idContainer.children[template.idIndex]), this.makeHeaderLabel("label", "--neuroglancer-label-column-label-width", children[template.labelIndex])];
    const numericalProperties = this.numericalProperties;
    const numericalPropertyIndices = this.template.numericalPropertyIndices;
    for (let i = 0, n = numericalPropertyIndices.length; i < n; ++i) {
      const property = numericalProperties[i];
      const headerLabel = this.makeHeaderLabel(property.id, `--neuroglancer-column-${i}-label-width`, container.children[numericalPropertyIndices[i]]);
      const description = property.description;
      if (description) {
        headerLabel.label.title = description;
      }
      propertyLabels.push(headerLabel);
    }
    return { container, propertyLabels };
  }
}
function makeSegmentWidget(displayState, normalizedId) {
  const factory = SegmentWidgetFactory.make(
    displayState !== null && displayState !== void 0 ? displayState : void 0,
    /*includeUnmapped=*/
    true
  );
  return factory.getWithNormalizedId(normalizedId);
}
function registerCallbackWhenSegmentationDisplayStateChanged(displayState, context, callback) {
  context.registerDisposer(registerNestedSync((c, groupState) => {
    onVisibleSegmentsStateChanged(c, groupState, callback);
  }, displayState.segmentationGroupState));
  context.registerDisposer(registerNestedSync((c, colorGroupState) => {
    c.registerDisposer(colorGroupState.segmentColorHash.changed.add(callback));
    c.registerDisposer(colorGroupState.segmentDefaultColor.changed.add(callback));
  }, displayState.segmentationColorGroupState));
  context.registerDisposer(displayState.saturation.changed.add(callback));
  context.registerDisposer(displayState.segmentSelectionState.changed.add(callback));
  context.registerDisposer(displayState.baseSegmentColoring.changed.add(callback));
}
function registerRedrawWhenSegmentationDisplayStateChanged(displayState, renderLayer) {
  const callback = renderLayer.redrawNeeded.dispatch;
  registerCallbackWhenSegmentationDisplayStateChanged(displayState, renderLayer, callback);
  renderLayer.registerDisposer(registerNestedSync((c, groupState) => {
    onTemporaryVisibleSegmentsStateChanged(c, groupState, callback);
  }, displayState.segmentationGroupState));
}
function registerRedrawWhenSegmentationDisplayStateWithAlphaChanged(displayState, renderLayer) {
  registerRedrawWhenSegmentationDisplayStateChanged(displayState, renderLayer);
  renderLayer.registerDisposer(displayState.objectAlpha.changed.add(renderLayer.redrawNeeded.dispatch));
}
function registerRedrawWhenSegmentationDisplayState3DChanged(displayState, renderLayer) {
  registerRedrawWhenSegmentationDisplayStateWithAlphaChanged(displayState, renderLayer);
  renderLayer.registerDisposer(displayState.transform.changed.add(renderLayer.redrawNeeded.dispatch));
  renderLayer.registerDisposer(displayState.renderScaleTarget.changed.add(renderLayer.redrawNeeded.dispatch));
  renderLayer.registerDisposer(displayState.transparentPickEnabled.changed.add(renderLayer.redrawNeeded.dispatch));
}
const tempColor = create$2();
const tempStatedColor = new Uint64();
function getBaseObjectColor(displayState, objectId, color2 = tempColor) {
  if (displayState == null) {
    color2.fill(1);
    return color2;
  }
  const colorGroupState = displayState.segmentationColorGroupState.value;
  const segmentStatedColors = colorGroupState.segmentStatedColors;
  if (segmentStatedColors.size !== 0 && colorGroupState.segmentStatedColors.get(objectId, tempStatedColor)) {
    color2[0] = (tempStatedColor.low & 255) / 255;
    color2[1] = ((tempStatedColor.low & 65280) >>> 8) / 255;
    color2[2] = ((tempStatedColor.low & 16711680) >>> 16) / 255;
    return color2;
  }
  const segmentDefaultColor = colorGroupState.segmentDefaultColor.value;
  if (segmentDefaultColor !== void 0) {
    color2[0] = segmentDefaultColor[0];
    color2[1] = segmentDefaultColor[1];
    color2[2] = segmentDefaultColor[2];
    return color2;
  }
  colorGroupState.segmentColorHash.compute(color2, objectId);
  return color2;
}
function getObjectColor(displayState, objectId, alpha = 1) {
  const color2 = tempColor;
  color2[3] = alpha;
  getBaseObjectColor(displayState, objectId, color2);
  let saturation = displayState.saturation.value;
  if (displayState.segmentSelectionState.isSelected(objectId)) {
    if (saturation > 0.5) {
      saturation = saturation -= 0.5;
    } else {
      saturation += 0.5;
    }
  }
  for (let i = 0; i < 3; ++i) {
    color2[i] = color2[i] * saturation + (1 - saturation);
  }
  color2[0] *= alpha;
  color2[1] *= alpha;
  color2[2] *= alpha;
  return color2;
}
function sendVisibleSegmentsState(state, options = {}) {
  for (const property of VISIBLE_SEGMENTS_STATE_PROPERTIES) {
    options[property] = state[property].rpcId;
  }
  return options;
}
const Base$3 = withSharedVisibility(ChunkRenderLayerFrontend);
class SegmentationLayerSharedObject extends Base$3 {
  constructor(chunkManager, displayState, chunkRenderLayer) {
    super(chunkRenderLayer);
    this.chunkManager = chunkManager;
    this.displayState = displayState;
  }
  initializeCounterpartWithChunkManager(options) {
    let displayState = this.displayState;
    options["chunkManager"] = this.chunkManager.rpcId;
    sendVisibleSegmentsState(displayState.segmentationGroupState.value, options);
    options["transform"] = this.registerDisposer(SharedWatchableValue.makeFromExisting(this.chunkManager.rpc, this.displayState.transform)).rpcId;
    options["renderScaleTarget"] = this.registerDisposer(SharedWatchableValue.makeFromExisting(this.chunkManager.rpc, this.displayState.renderScaleTarget)).rpcId;
    super.initializeCounterpart(this.chunkManager.rpc, options);
  }
}
function forEachVisibleSegmentToDraw(displayState, renderLayer, emitColor, pickIDs, callback) {
  const alpha = Math.min(1, displayState.objectAlpha.value);
  const baseSegmentColoring = displayState.baseSegmentColoring.value;
  forEachVisibleSegment(displayState.segmentationGroupState.value, (objectId, rootObjectId) => {
    let pickIndex = pickIDs === null || pickIDs === void 0 ? void 0 : pickIDs.registerUint64(renderLayer, objectId);
    let color2 = emitColor ? getObjectColor(displayState, baseSegmentColoring ? objectId : rootObjectId, alpha) : void 0;
    callback(objectId, color2, pickIndex, rootObjectId);
  });
}
const frontend = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SegmentSelectionState,
  SegmentWidgetFactory,
  SegmentWidgetWithExtraColumnsFactory,
  SegmentationLayerSharedObject,
  Uint64MapEntry,
  augmentSegmentId,
  bindSegmentListWidth,
  forEachVisibleSegmentToDraw,
  getBaseObjectColor,
  getObjectColor,
  makeSegmentWidget,
  maybeAugmentSegmentId,
  registerCallbackWhenSegmentationDisplayStateChanged,
  registerRedrawWhenSegmentationDisplayState3DChanged,
  registerRedrawWhenSegmentationDisplayStateChanged,
  registerRedrawWhenSegmentationDisplayStateWithAlphaChanged,
  resetTemporaryVisibleSegmentsState,
  segmentWidgetTemplateWithExtraColumns,
  sendVisibleSegmentsState,
  updateIdStringWidth
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
const tempMat4$5 = create$4();
const tempMat3$1 = create$5();
function copyMeshDataToGpu(gl, chunk) {
  chunk.vertexBuffer = Buffer.fromData(gl, chunk.meshData.vertexPositions, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
  chunk.indexBuffer = Buffer.fromData(gl, chunk.meshData.indices, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW);
  chunk.normalBuffer = Buffer.fromData(gl, chunk.meshData.vertexNormals, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
}
function freeGpuMeshData(chunk) {
  chunk.vertexBuffer.dispose();
  chunk.indexBuffer.dispose();
  chunk.normalBuffer.dispose();
}
const glsl_decodeNormalOctahedronSnorm8 = `
highp vec3 decodeNormalOctahedronSnorm8(highp vec2 e) {
  vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  if (v.z < 0.0) v.xy = (1.0 - abs(v.yx)) * vec2(v.x > 0.0 ? 1.0 : -1.0, v.y > 0.0 ? 1.0 : -1.0);
  return normalize(v);
}
`;
function getFloatPositionHandler(glAttributeType) {
  return {
    defineShader: (builder) => {
      builder.addAttribute("highp vec3", "aVertexPosition");
      builder.addVertexCode(`highp vec3 getVertexPosition() { return aVertexPosition; }`);
    },
    bind(_gl, shader, fragmentChunk) {
      fragmentChunk.vertexBuffer.bindToVertexAttrib(
        shader.attribute("aVertexPosition"),
        /*components=*/
        3,
        glAttributeType,
        /* normalized=*/
        true
      );
    },
    endLayer: (gl, shader) => {
      gl.disableVertexAttribArray(shader.attribute("aVertexPosition"));
    }
  };
}
const vertexPositionHandlers = {
  [VertexPositionFormat.float32]: getFloatPositionHandler(WebGL2RenderingContext.FLOAT),
  [VertexPositionFormat.uint16]: getFloatPositionHandler(WebGL2RenderingContext.UNSIGNED_SHORT),
  [VertexPositionFormat.uint10]: {
    defineShader: (builder) => {
      builder.addAttribute("highp uint", "aVertexPosition");
      builder.addVertexCode(`
highp vec3 getVertexPosition() {
  return vec3(float(aVertexPosition & 1023u),
              float((aVertexPosition >> 10) & 1023u),
              float((aVertexPosition >> 20) & 1023u)) / 1023.0;
}
`);
    },
    bind(_gl, shader, fragmentChunk) {
      fragmentChunk.vertexBuffer.bindToVertexAttribI(
        shader.attribute("aVertexPosition"),
        /*components=*/
        1,
        WebGL2RenderingContext.UNSIGNED_INT
      );
    },
    endLayer: (gl, shader) => {
      gl.disableVertexAttribArray(shader.attribute("aVertexPosition"));
    }
  }
};
class MeshShaderManager {
  constructor(fragmentRelativeVertices, vertexPositionFormat) {
    this.fragmentRelativeVertices = fragmentRelativeVertices;
    this.vertexPositionFormat = vertexPositionFormat;
    this.tempLightVec = new Float32Array(4);
    this.vertexPositionHandler = vertexPositionHandlers[this.vertexPositionFormat];
  }
  beginLayer(gl, shader, renderContext, displayState) {
    let lightDirection = renderContext.lightDirection, ambientLighting = renderContext.ambientLighting, directionalLighting = renderContext.directionalLighting;
    let lightVec = this.tempLightVec;
    scale$1(lightVec, lightDirection, directionalLighting);
    lightVec[3] = ambientLighting;
    gl.uniform4fv(shader.uniform("uLightDirection"), lightVec);
    const silhouetteRendering = displayState.silhouetteRendering.value;
    if (silhouetteRendering > 0) {
      gl.uniform1f(shader.uniform("uSilhouettePower"), silhouetteRendering);
    }
  }
  setColor(gl, shader, color2) {
    gl.uniform4fv(shader.uniform("uColor"), color2);
  }
  setPickID(gl, shader, pickID) {
    gl.uniform1ui(shader.uniform("uPickID"), pickID);
  }
  beginModel(gl, shader, renderContext, modelMat) {
    const projectionParameters = renderContext.projectionParameters;
    gl.uniformMatrix4fv(shader.uniform("uModelViewProjection"), false, multiply$3(tempMat4$5, projectionParameters.viewProjectionMat, modelMat));
    mat3FromMat4(tempMat3$1, modelMat);
    scaleMat3Output(tempMat3$1, tempMat3$1, projectionParameters.displayDimensionRenderInfo.canonicalVoxelFactors);
    invert$2(tempMat3$1, tempMat3$1);
    transpose$1(tempMat3$1, tempMat3$1);
    gl.uniformMatrix3fv(shader.uniform("uNormalMatrix"), false, tempMat3$1);
  }
  drawFragmentHelper(gl, shader, fragmentChunk, indexBegin, indexEnd) {
    this.vertexPositionHandler.bind(gl, shader, fragmentChunk);
    const meshData = fragmentChunk.meshData;
    fragmentChunk.normalBuffer.bindToVertexAttrib(
      shader.attribute("aVertexNormal"),
      /*components=*/
      2,
      WebGL2RenderingContext.BYTE,
      /*normalized=*/
      true
    );
    fragmentChunk.indexBuffer.bind();
    const indices = meshData.indices;
    gl.drawElements(meshData.strips ? WebGL2RenderingContext.TRIANGLE_STRIP : WebGL2RenderingContext.TRIANGLES, indexEnd - indexBegin, indices.BYTES_PER_ELEMENT === 2 ? WebGL2RenderingContext.UNSIGNED_SHORT : WebGL2RenderingContext.UNSIGNED_INT, indexBegin * indices.BYTES_PER_ELEMENT);
  }
  drawFragment(gl, shader, fragmentChunk) {
    const meshData = fragmentChunk.meshData;
    const indices = meshData.indices;
    this.drawFragmentHelper(gl, shader, fragmentChunk, 0, indices.length);
  }
  drawMultiscaleFragment(gl, shader, fragmentChunk, subChunkBegin, subChunkEnd) {
    const indexBegin = fragmentChunk.meshData.subChunkOffsets[subChunkBegin];
    const indexEnd = fragmentChunk.meshData.subChunkOffsets[subChunkEnd];
    this.drawFragmentHelper(gl, shader, fragmentChunk, indexBegin, indexEnd);
  }
  endLayer(gl, shader) {
    this.vertexPositionHandler.endLayer(gl, shader);
    gl.disableVertexAttribArray(shader.attribute("aVertexNormal"));
  }
  makeGetter(layer) {
    const silhouetteRenderingEnabled = layer.registerDisposer(makeCachedDerivedWatchableValue((x) => x > 0, [layer.displayState.silhouetteRendering]));
    return parameterizedEmitterDependentShaderGetter(layer, layer.gl, {
      memoizeKey: `mesh/MeshShaderManager/${this.fragmentRelativeVertices}/${this.vertexPositionFormat}`,
      parameters: silhouetteRenderingEnabled,
      defineShader: (builder, silhouetteRenderingEnabled2) => {
        this.vertexPositionHandler.defineShader(builder);
        builder.addAttribute("highp vec2", "aVertexNormal");
        builder.addVarying("highp vec4", "vColor");
        builder.addUniform("highp vec4", "uLightDirection");
        builder.addUniform("highp vec4", "uColor");
        builder.addUniform("highp mat3", "uNormalMatrix");
        builder.addUniform("highp mat4", "uModelViewProjection");
        builder.addUniform("highp uint", "uPickID");
        if (silhouetteRenderingEnabled2) {
          builder.addUniform("highp float", "uSilhouettePower");
        }
        if (this.fragmentRelativeVertices) {
          builder.addUniform("highp vec3", "uFragmentOrigin");
          builder.addUniform("highp vec3", "uFragmentShape");
        }
        builder.addVertexCode(glsl_decodeNormalOctahedronSnorm8);
        let vertexMain = ``;
        if (this.fragmentRelativeVertices) {
          vertexMain += `
highp vec3 vertexPosition = uFragmentOrigin + uFragmentShape * getVertexPosition();
highp vec3 normalMultiplier = 1.0 / uFragmentShape;
`;
        } else {
          vertexMain += `
highp vec3 vertexPosition = getVertexPosition();
highp vec3 normalMultiplier = vec3(1.0, 1.0, 1.0);
`;
        }
        vertexMain += `
gl_Position = uModelViewProjection * vec4(vertexPosition, 1.0);
vec3 origNormal = decodeNormalOctahedronSnorm8(aVertexNormal);
vec3 normal = normalize(uNormalMatrix * (normalMultiplier * origNormal));
float absCosAngle = abs(dot(normal, uLightDirection.xyz));
float lightingFactor = absCosAngle + uLightDirection.w;
vColor = vec4(lightingFactor * uColor.rgb, uColor.a);
`;
        if (silhouetteRenderingEnabled2) {
          vertexMain += `
vColor *= pow(1.0 - absCosAngle, uSilhouettePower);
`;
        }
        builder.setVertexMain(vertexMain);
        builder.setFragmentMain(`emit(vColor, uPickID);`);
      }
    });
  }
}
class MeshLayer extends PerspectiveViewRenderLayer {
  constructor(chunkManager, source, displayState) {
    super();
    this.chunkManager = chunkManager;
    this.source = source;
    this.displayState = displayState;
    this.meshShaderManager = new MeshShaderManager(
      /*fragmentRelativeVertices=*/
      false,
      VertexPositionFormat.float32
    );
    this.getShader = this.meshShaderManager.makeGetter(this);
    registerRedrawWhenSegmentationDisplayState3DChanged(displayState, this);
    this.registerDisposer(displayState.silhouetteRendering.changed.add(this.redrawNeeded.dispatch));
    let sharedObject = this.backend = this.registerDisposer(new SegmentationLayerSharedObject(chunkManager, displayState, this.layerChunkProgressInfo));
    sharedObject.RPC_TYPE_ID = MESH_LAYER_RPC_ID;
    sharedObject.initializeCounterpartWithChunkManager({
      "source": source.addCounterpartRef()
    });
    sharedObject.visibility.add(this.visibility);
    this.registerDisposer(displayState.renderScaleHistogram.visibility.add(this.visibility));
  }
  get isTransparent() {
    const displayState = this.displayState;
    return displayState.objectAlpha.value < 1 || displayState.silhouetteRendering.value > 0;
  }
  get transparentPickEnabled() {
    return this.displayState.transparentPickEnabled.value;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  draw(renderContext, attachment) {
    if (!renderContext.emitColor && renderContext.alreadyEmittedPickID) {
      return;
    }
    const gl = this.gl, displayState = this.displayState, meshShaderManager = this.meshShaderManager;
    if (displayState.objectAlpha.value <= 0) {
      return;
    }
    const modelMatrix = update3dRenderLayerAttachment(displayState.transform.value, renderContext.projectionParameters.displayDimensionRenderInfo, attachment);
    if (modelMatrix === void 0) {
      return;
    }
    var _getShader = this.getShader(renderContext.emitter);
    const shader = _getShader.shader;
    if (shader === null) return;
    shader.bind();
    meshShaderManager.beginLayer(gl, shader, renderContext, this.displayState);
    meshShaderManager.beginModel(gl, shader, renderContext, modelMatrix);
    const manifestChunks = this.source.chunks;
    let totalChunks = 0, presentChunks = 0;
    const renderScaleHistogram = this.displayState.renderScaleHistogram;
    const fragmentChunks = this.source.fragmentSource.chunks;
    forEachVisibleSegmentToDraw(displayState, this, renderContext.emitColor, renderContext.emitPickID ? renderContext.pickIDs : void 0, (objectId, color2, pickIndex) => {
      const key = getObjectKey(objectId);
      const manifestChunk = manifestChunks.get(key);
      ++totalChunks;
      if (manifestChunk === void 0) return;
      ++presentChunks;
      if (renderContext.emitColor) {
        meshShaderManager.setColor(gl, shader, color2);
      }
      if (renderContext.emitPickID) {
        meshShaderManager.setPickID(gl, shader, pickIndex);
      }
      totalChunks += manifestChunk.fragmentIds.length;
      for (const fragmentId of manifestChunk.fragmentIds) {
        var _source$getFragmentKe = this.source.getFragmentKey(key, fragmentId);
        const fragmentKey = _source$getFragmentKe.key;
        const fragment = fragmentChunks.get(fragmentKey);
        if (fragment !== void 0 && fragment.state === ChunkState.GPU_MEMORY) {
          meshShaderManager.drawFragment(gl, shader, fragment);
          ++presentChunks;
        }
      }
    });
    if (renderContext.emitColor) {
      renderScaleHistogram.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
      renderScaleHistogram.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, presentChunks, totalChunks - presentChunks);
    }
    meshShaderManager.endLayer(gl, shader);
  }
  isReady() {
    const displayState = this.displayState, source = this.source;
    let ready = true;
    const fragmentChunks = source.fragmentSource.chunks;
    forEachVisibleSegment(displayState.segmentationGroupState.value, (objectId) => {
      const key = getObjectKey(objectId);
      const manifestChunk = source.chunks.get(key);
      if (manifestChunk === void 0) {
        ready = false;
        return;
      }
      for (const fragmentId of manifestChunk.fragmentIds) {
        var _source$getFragmentKe2 = this.source.getFragmentKey(key, fragmentId);
        const fragmentKey = _source$getFragmentKe2.key;
        const fragmentChunk = fragmentChunks.get(fragmentKey);
        if (fragmentChunk === void 0 || fragmentChunk.state !== ChunkState.GPU_MEMORY) {
          ready = false;
          return;
        }
      }
    });
    return ready;
  }
}
class ManifestChunk extends Chunk {
  constructor(source, x) {
    super(source);
    this.fragmentIds = x.fragmentIds;
  }
}
class FragmentChunk extends Chunk {
  constructor(source, x) {
    super(source);
    this.meshData = x;
  }
  copyToGPU(gl) {
    super.copyToGPU(gl);
    copyMeshDataToGpu(gl, this);
  }
  freeGPUMemory(gl) {
    super.freeGPUMemory(gl);
    freeGpuMeshData(this);
  }
}
class MeshSource extends ChunkSource {
  constructor(chunkManager, options) {
    super(chunkManager, options);
    this.fragmentSource = this.registerDisposer(new FragmentSource(this.chunkManager, this));
  }
  initializeCounterpart(rpc, options) {
    this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {});
    options["fragmentSource"] = this.fragmentSource.addCounterpartRef();
    super.initializeCounterpart(rpc, options);
  }
  getChunk(x) {
    return new ManifestChunk(this, x);
  }
  getFragmentKey(objectKey, fragmentId) {
    return { key: `${objectKey}/${fragmentId}`, fragmentId };
  }
}
let FragmentSource = class FragmentSource2 extends ChunkSource {
  constructor(chunkManager, meshSource) {
    super(chunkManager);
    this.meshSource = meshSource;
  }
  get key() {
    return this.meshSource.key;
  }
  getChunk(x) {
    return new FragmentChunk(this, x);
  }
};
FragmentSource = __decorate$5([registerSharedObjectOwner(FRAGMENT_SOURCE_RPC_ID)], FragmentSource);
function hasFragmentChunk(fragmentChunks, objectKey, lod, chunkIndex) {
  const fragmentChunk = fragmentChunks.get(getMultiscaleFragmentKey(objectKey, lod, chunkIndex));
  return fragmentChunk !== void 0 && fragmentChunk.state === ChunkState.GPU_MEMORY;
}
class MultiscaleMeshLayer extends PerspectiveViewRenderLayer {
  constructor(chunkManager, source, displayState) {
    super();
    this.chunkManager = chunkManager;
    this.source = source;
    this.displayState = displayState;
    this.meshShaderManager = new MeshShaderManager(
      /*fragmentRelativeVertices=*/
      this.source.format.fragmentRelativeVertices,
      this.source.format.vertexPositionFormat
    );
    this.getShader = this.meshShaderManager.makeGetter(this);
    registerRedrawWhenSegmentationDisplayState3DChanged(displayState, this);
    this.registerDisposer(displayState.silhouetteRendering.changed.add(this.redrawNeeded.dispatch));
    let sharedObject = this.backend = this.registerDisposer(new SegmentationLayerSharedObject(chunkManager, displayState, this.layerChunkProgressInfo));
    sharedObject.RPC_TYPE_ID = MULTISCALE_MESH_LAYER_RPC_ID;
    sharedObject.initializeCounterpartWithChunkManager({
      "source": source.addCounterpartRef()
    });
    sharedObject.visibility.add(this.visibility);
    this.registerDisposer(displayState.renderScaleHistogram.visibility.add(this.visibility));
  }
  get isTransparent() {
    const displayState = this.displayState;
    return displayState.objectAlpha.value < 1 || displayState.silhouetteRendering.value > 0;
  }
  get transparentPickEnabled() {
    return this.displayState.transparentPickEnabled.value;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  draw(renderContext, attachment) {
    if (!renderContext.emitColor && renderContext.alreadyEmittedPickID) {
      return;
    }
    const gl = this.gl, displayState = this.displayState, meshShaderManager = this.meshShaderManager;
    if (displayState.objectAlpha.value <= 0) {
      return;
    }
    const modelMatrix = update3dRenderLayerAttachment(displayState.transform.value, renderContext.projectionParameters.displayDimensionRenderInfo, attachment);
    if (modelMatrix === void 0) return;
    var _getShader2 = this.getShader(renderContext.emitter);
    const shader = _getShader2.shader;
    if (shader === null) return;
    shader.bind();
    meshShaderManager.beginLayer(gl, shader, renderContext, this.displayState);
    const renderScaleHistogram = this.displayState.renderScaleHistogram;
    if (renderContext.emitColor) {
      renderScaleHistogram.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
    }
    mat3FromMat4(tempMat3$1, modelMatrix);
    scaleMat3Output(tempMat3$1, tempMat3$1, renderContext.projectionParameters.displayDimensionRenderInfo.voxelPhysicalScales);
    const scaleMultiplier = Math.pow(Math.abs(determinant(tempMat3$1)), 1 / 3);
    const chunks = this.source.chunks;
    const fragmentChunks = this.source.fragmentSource.chunks;
    const projectionParameters = renderContext.projectionParameters;
    const modelViewProjection = multiply$3(create$4(), projectionParameters.viewProjectionMat, modelMatrix);
    const clippingPlanes = getFrustrumPlanes(new Float32Array(24), modelViewProjection);
    const detailCutoff = this.displayState.renderScaleTarget.value;
    const fragmentRelativeVertices = this.source.format.fragmentRelativeVertices;
    meshShaderManager.beginModel(gl, shader, renderContext, modelMatrix);
    let totalManifestChunks = 0;
    let presentManifestChunks = 0;
    forEachVisibleSegmentToDraw(displayState, this, renderContext.emitColor, renderContext.emitPickID ? renderContext.pickIDs : void 0, (objectId, color2, pickIndex) => {
      const key = getObjectKey(objectId);
      const manifestChunk = chunks.get(key);
      ++totalManifestChunks;
      if (manifestChunk === void 0) return;
      ++presentManifestChunks;
      const manifest = manifestChunk.manifest;
      const octree = manifest.octree, chunkShape = manifest.chunkShape, chunkGridSpatialOrigin = manifest.chunkGridSpatialOrigin, vertexOffsets = manifest.vertexOffsets;
      if (renderContext.emitColor) {
        meshShaderManager.setColor(gl, shader, color2);
      }
      if (renderContext.emitPickID) {
        meshShaderManager.setPickID(gl, shader, pickIndex);
      }
      getMultiscaleChunksToDraw(manifest, modelViewProjection, clippingPlanes, detailCutoff, projectionParameters.width, projectionParameters.height, (lod, chunkIndex, renderScale) => {
        const has = hasFragmentChunk(fragmentChunks, key, lod, chunkIndex);
        if (renderContext.emitColor) {
          renderScaleHistogram.add(manifest.lodScales[lod] * scaleMultiplier, renderScale, has ? 1 : 0, has ? 0 : 1);
        }
        return has;
      }, (lod, chunkIndex, subChunkBegin, subChunkEnd) => {
        const fragmentKey = getMultiscaleFragmentKey(key, lod, chunkIndex);
        const fragmentChunk = fragmentChunks.get(fragmentKey);
        const x = octree[5 * chunkIndex], y = octree[5 * chunkIndex + 1], z = octree[5 * chunkIndex + 2];
        const scale2 = 1 << lod;
        if (fragmentRelativeVertices) {
          gl.uniform3f(shader.uniform("uFragmentOrigin"), chunkGridSpatialOrigin[0] + x * chunkShape[0] * scale2 + vertexOffsets[lod * 3 + 0], chunkGridSpatialOrigin[1] + y * chunkShape[1] * scale2 + vertexOffsets[lod * 3 + 1], chunkGridSpatialOrigin[2] + z * chunkShape[2] * scale2 + vertexOffsets[lod * 3 + 2]);
          gl.uniform3f(shader.uniform("uFragmentShape"), chunkShape[0] * scale2, chunkShape[1] * scale2, chunkShape[2] * scale2);
        }
        meshShaderManager.drawMultiscaleFragment(gl, shader, fragmentChunk, subChunkBegin, subChunkEnd);
      });
    });
    renderScaleHistogram.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, presentManifestChunks, totalManifestChunks - presentManifestChunks);
    meshShaderManager.endLayer(gl, shader);
  }
  isReady(renderContext, attachment) {
    let displayState = this.displayState;
    if (displayState.objectAlpha.value <= 0) {
      return true;
    }
    const modelMatrix = update3dRenderLayerAttachment(displayState.transform.value, renderContext.projectionParameters.displayDimensionRenderInfo, attachment);
    if (modelMatrix === void 0) return false;
    const chunks = this.source.chunks;
    const fragmentChunks = this.source.fragmentSource.chunks;
    const projectionParameters = renderContext.projectionParameters;
    const modelViewProjection = multiply$3(create$4(), projectionParameters.viewProjectionMat, modelMatrix);
    const clippingPlanes = getFrustrumPlanes(new Float32Array(24), modelViewProjection);
    const detailCutoff = this.displayState.renderScaleTarget.value;
    let hasAllChunks = true;
    forEachVisibleSegment(displayState.segmentationGroupState.value, (objectId) => {
      if (!hasAllChunks) return;
      const key = getObjectKey(objectId);
      const manifestChunk = chunks.get(key);
      if (manifestChunk === void 0) {
        hasAllChunks = false;
        return;
      }
      const manifest = manifestChunk.manifest;
      getMultiscaleChunksToDraw(manifest, modelViewProjection, clippingPlanes, detailCutoff, projectionParameters.width, projectionParameters.height, (lod, chunkIndex) => {
        hasAllChunks = hasAllChunks && hasFragmentChunk(fragmentChunks, key, lod, chunkIndex);
        return hasAllChunks;
      }, () => {
      });
    });
    return hasAllChunks;
  }
  getObjectPosition(id) {
    const transform = this.displayState.transform.value;
    if (transform.error !== void 0) return void 0;
    const chunk = this.source.chunks.get(getObjectKey(id));
    if (chunk === void 0) return void 0;
    const manifest = chunk.manifest;
    const clipLowerBound = manifest.clipLowerBound, clipUpperBound = manifest.clipUpperBound;
    const rank = transform.rank;
    const modelCenter = new Float32Array(rank);
    for (let i = 0; i < 3; ++i) {
      modelCenter[i] = (clipLowerBound[i] + clipUpperBound[i]) / 2;
    }
    const layerCenter = new Float32Array(rank);
    transformPoint(layerCenter, transform.modelToRenderLayerTransform, rank + 1, modelCenter, rank);
    return layerCenter;
  }
}
class MultiscaleManifestChunk extends Chunk {
  constructor(source, x) {
    super(source);
    this.manifest = x["manifest"];
  }
}
class MultiscaleFragmentChunk extends Chunk {
  constructor(source, x) {
    super(source);
    this.meshData = x;
  }
  copyToGPU(gl) {
    super.copyToGPU(gl);
    copyMeshDataToGpu(gl, this);
  }
  freeGPUMemory(gl) {
    super.freeGPUMemory(gl);
    freeGpuMeshData(this);
  }
}
class MultiscaleMeshSource extends ChunkSource {
  constructor(chunkManager, options) {
    super(chunkManager, options);
    this.fragmentSource = this.registerDisposer(new MultiscaleFragmentSource(this.chunkManager, this));
    this.format = options.format;
  }
  static encodeOptions(options) {
    return _Object$assign({ format: options.format }, super.encodeOptions(options));
  }
  initializeCounterpart(rpc, options) {
    this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {});
    options["fragmentSource"] = this.fragmentSource.addCounterpartRef();
    options["format"] = this.format;
    super.initializeCounterpart(rpc, options);
  }
  getChunk(x) {
    return new MultiscaleManifestChunk(this, x);
  }
}
let MultiscaleFragmentSource = class MultiscaleFragmentSource2 extends ChunkSource {
  constructor(chunkManager, meshSource) {
    super(chunkManager);
    this.meshSource = meshSource;
  }
  get key() {
    return this.meshSource.key;
  }
  getChunk(x) {
    return new MultiscaleFragmentChunk(this, x);
  }
};
MultiscaleFragmentSource = __decorate$5([registerSharedObjectOwner(MULTISCALE_FRAGMENT_SOURCE_RPC_ID)], MultiscaleFragmentSource);
var es7_object_values = {};
var hasRequiredEs7_object_values;
function requireEs7_object_values() {
  if (hasRequiredEs7_object_values) return es7_object_values;
  hasRequiredEs7_object_values = 1;
  var $export = require_export();
  var $values = require_objectToArray()(false);
  $export($export.S, "Object", {
    values: function values2(it) {
      return $values(it);
    }
  });
  return es7_object_values;
}
var values$1;
var hasRequiredValues$1;
function requireValues$1() {
  if (hasRequiredValues$1) return values$1;
  hasRequiredValues$1 = 1;
  requireEs7_object_values();
  values$1 = require_core().Object.values;
  return values$1;
}
var values;
var hasRequiredValues;
function requireValues() {
  if (hasRequiredValues) return values;
  hasRequiredValues = 1;
  values = { "default": requireValues$1(), __esModule: true };
  return values;
}
var valuesExports = requireValues();
const _Object$values = /* @__PURE__ */ getDefaultExportFromCjs(valuesExports);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SKELETON_LAYER_RPC_ID = "skeleton/SkeletonLayer";
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VERTICES_PER_QUAD = 6;
const glsl_getQuadVertexPosition = `
vec2 getQuadVertexPosition(vec2 lower, vec2 upper) {
  const vec2 coeffs[] = vec2[](
    vec2(0.0, 0.0),
    vec2(0.0, 1.0),
    vec2(1.0, 1.0),
    vec2(1.0, 1.0),
    vec2(1.0, 0.0),
    vec2(0.0, 0.0)
  );
  int v = gl_VertexID % 6;
  return mix(lower, upper, coeffs[v]);
}
`;
function drawQuads(gl, quadsPerInstance, numInstances) {
  gl.drawArraysInstanced(WebGL2RenderingContext.TRIANGLES, 0, VERTICES_PER_QUAD * quadsPerInstance, numInstances);
}
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getSphereVertexArray(latitudeBands, longitudeBands) {
  const result = new Float32Array((latitudeBands + 1) * (longitudeBands + 1) * 3);
  let i = 0;
  for (let latIndex = 0; latIndex <= latitudeBands; ++latIndex) {
    const theta = latIndex * Math.PI / latitudeBands;
    const sinTheta = Math.sin(theta);
    const cosTheta = Math.cos(theta);
    for (let lonIndex = 0; lonIndex <= longitudeBands; ++lonIndex) {
      const phi = lonIndex * 2 * Math.PI / longitudeBands;
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      result[i++] = cosPhi * sinTheta;
      result[i++] = cosTheta;
      result[i++] = sinPhi * sinTheta;
    }
  }
  return result;
}
function getSphereIndexArray(latitudeBands, longitudeBands) {
  const result = new Uint16Array(latitudeBands * longitudeBands * 6);
  let i = 0;
  for (let latIndex = 0; latIndex < latitudeBands; latIndex++) {
    for (let lonIndex = 0; lonIndex < longitudeBands; lonIndex++) {
      const first = latIndex * (longitudeBands + 1) + lonIndex;
      const second = first + longitudeBands + 1;
      result[i++] = first;
      result[i++] = second;
      result[i++] = first + 1;
      result[i++] = second;
      result[i++] = second + 1;
      result[i++] = first + 1;
    }
  }
  return result;
}
class SphereRenderHelper extends RefCounted {
  constructor(gl, latitudeBands, longitudeBands) {
    super();
    this.vertexBuffer = this.registerDisposer(getMemoizedBuffer(gl, WebGL2RenderingContext.ARRAY_BUFFER, getSphereVertexArray, latitudeBands, longitudeBands)).value;
    this.indexBuffer = this.registerDisposer(getMemoizedBuffer(gl, WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, getSphereIndexArray, latitudeBands, longitudeBands)).value;
    this.numIndices = latitudeBands * longitudeBands * 6;
  }
  defineShader(builder) {
    builder.addAttribute("highp vec3", "aSphereVertex");
    builder.addVarying("highp float", "vLightingFactor");
    builder.addVertexCode(`
void emitSphere(mat4 projectionMatrix, mat4 normalTransformMatrix, vec3 centerPosition, vec3 radii, vec4 lightDirection) {
  vec3 vertexPosition = aSphereVertex * radii + centerPosition;
  gl_Position = projectionMatrix * vec4(vertexPosition, 1.0);
  vec3 normal = normalize((normalTransformMatrix * vec4(aSphereVertex / max(radii, 1e-6), 0.0)).xyz);
  vLightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;
}
`);
  }
  draw(shader, numInstances) {
    const aSphereVertex = shader.attribute("aSphereVertex");
    this.vertexBuffer.bindToVertexAttrib(
      aSphereVertex,
      /*components=*/
      3,
      /*attributeType=*/
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false
    );
    this.indexBuffer.bind();
    shader.gl.drawElementsInstanced(
      WebGL2RenderingContext.TRIANGLES,
      this.numIndices,
      WebGL2RenderingContext.UNSIGNED_SHORT,
      /*offset=*/
      0,
      numInstances
    );
    shader.gl.disableVertexAttribArray(aSphereVertex);
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VERTICES_PER_CIRCLE = VERTICES_PER_QUAD;
function defineCircleShader(builder, crossSectionFade) {
  builder.addVertexCode(glsl_getQuadVertexPosition);
  builder.addUniform("highp vec3", "uCircleParams");
  builder.addVarying("highp vec4", "vCircleCoord");
  builder.addVertexCode(`
void emitCircle(vec4 position, float diameter, float borderWidth) {
  gl_Position = position;
  float totalDiameter = diameter + 2.0 * (borderWidth + uCircleParams.z);
  if (diameter == 0.0) totalDiameter = 0.0;
  vec2 circleCornerOffset = getQuadVertexPosition(vec2(-1.0, -1.0), vec2(1.0, 1.0));
  gl_Position.xy += circleCornerOffset * uCircleParams.xy * gl_Position.w * totalDiameter;
  vCircleCoord.xy = circleCornerOffset;
  if (borderWidth == 0.0) {
    vCircleCoord.z = totalDiameter;
    vCircleCoord.w = 1e-6;
  } else {
    vCircleCoord.z = diameter / totalDiameter;
    vCircleCoord.w = uCircleParams.z / totalDiameter;
  }
}
`);
  if (crossSectionFade) {
    builder.addFragmentCode(`
float getCircleAlphaMultiplier() {
  return 1.0 - 2.0 * abs(0.5 - gl_FragCoord.z);
}
`);
  } else {
    builder.addFragmentCode(`
float getCircleAlphaMultiplier() {
  return 1.0;
}
`);
  }
  builder.addFragmentCode(`
vec4 getCircleColor(vec4 interiorColor, vec4 borderColor) {
  float radius = length(vCircleCoord.xy);
  if (radius > 1.0) {
    discard;
  }

  float borderColorFraction = clamp((radius - vCircleCoord.z) / vCircleCoord.w, 0.0, 1.0);
  float feather = clamp((1.0 - radius) / vCircleCoord.w, 0.0, 1.0);
  vec4 color = mix(interiorColor, borderColor, borderColorFraction);

  return vec4(color.rgb, color.a * feather * getCircleAlphaMultiplier());
}
`);
}
function initializeCircleShader(shader, projectionParameters, options) {
  const gl = shader.gl;
  gl.uniform3f(shader.uniform("uCircleParams"), 1 / projectionParameters.width, 1 / projectionParameters.height, Math.max(1e-6, options.featherWidthInPixels));
}
function drawCircles(gl, circlesPerInstance, numInstances) {
  drawQuads(gl, circlesPerInstance, numInstances);
}
class SphereShader extends RefCounted {
  constructor(gl) {
    super();
    this.lightDirection = new Float32Array([1, 0, 0, 0]);
    this.sphereHelper = this.registerDisposer(new SphereRenderHelper(gl, 20, 20));
  }
  defineShader(builder) {
    builder.addUniform("highp vec4", "uLightDirection");
    builder.addUniform("highp mat4", "uNormalTransform");
    builder.addVertexCode(`
float getRadiusAdjustment(vec3 vertex, float r) {
  float radiusAdjustment = 1.0;
  for (int i = 0; i < 3; ++i) {
    if (r != 0.0) {
      float d = vertex[i] - uModelClipBounds[i];
      radiusAdjustment -= d * d / (r * r);
    }
  }

  return sqrt(max(0.1, radiusAdjustment));
}
    `);
    this.sphereHelper.defineShader(builder);
  }
  draw(shader, context, count) {
    const gl = shader.gl;
    gl.uniformMatrix4fv(
      shader.uniform("uNormalTransform"),
      /*transpose=*/
      false,
      transpose(create$4(), context.renderSubspaceInvModelMatrix)
    );
    gl.uniform4f(shader.uniform("uLightDirection"), this.lightDirection[0], this.lightDirection[1], this.lightDirection[2], this.lightDirection[3]);
    this.sphereHelper.draw(shader, count);
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VERTICES_PER_LINE = VERTICES_PER_QUAD;
function defineLineShader(builder, rounded = false) {
  builder.addVertexCode(glsl_getQuadVertexPosition);
  builder.addUniform("highp vec3", "uLineParams");
  builder.addVarying("highp float", "vLineCoord");
  builder.addVarying("highp float", "vLineFeatherFraction");
  if (rounded) {
    builder.addVarying("highp float", "vEndpointFraction");
    builder.addVarying("highp float", "vLineCoordT");
    builder.addVarying("highp float", "vLineBorderStartFraction");
  }
  builder.addVertexCode(glsl_clipLineToDepthRange);
  builder.addVertexCode(`
vec2 getLineOffset() { return getQuadVertexPosition(vec2(0.0, -1.0), vec2(1.0, 1.0)); }
float getLineEndpointCoefficient() { return getLineOffset().x; }
uint getLineEndpointIndex() { return uint(getLineEndpointCoefficient()); }
void emitLine(vec4 vertexAClip, vec4 vertexBClip, float lineWidthInPixels
              ${rounded ? ", float borderWidth" : ""}) {
  if (!clipLineToDepthRange(vertexAClip, vertexBClip)) {
    gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
    return;
  }
  vec3 vertexADevice = vertexAClip.xyz / vertexAClip.w;
  vec3 vertexBDevice = vertexBClip.xyz / vertexBClip.w;

  vec2 lineDirectionUnnormalized = vertexBDevice.xy - vertexADevice.xy;
  vec2 lineDirection;
  float linePixelLength = length(lineDirectionUnnormalized / uLineParams.xy * 0.5);

  if (linePixelLength < 1e-3) {
    lineDirection = vec2(1.0, 0.0);
    vertexADevice.z = vertexBDevice.z = 0.0;
  } else {
    lineDirection = normalize(lineDirectionUnnormalized);
  }
  vec2 lineNormal = normalize(vec2(lineDirection.y, -lineDirection.x) / uLineParams.yx * uLineParams.xy);

  vec2 lineOffset = getLineOffset();
  gl_Position = vec4(mix(vertexADevice, vertexBDevice, lineOffset.x), 1.0);
  float totalLineWidth = lineWidthInPixels + 2.0 * uLineParams.z ${rounded ? " + 2.0 * borderWidth" : ""};
  if (lineWidthInPixels == 0.0) totalLineWidth = 0.0;
  vLineFeatherFraction = max(1e-6, uLineParams.z) / totalLineWidth;
  gl_Position.xy += (lineOffset.y * lineNormal
                     ${rounded ? "+ lineDirection * (2.0 * lineOffset.x - 1.0)" : ""})
                  * totalLineWidth * uLineParams.xy;
  vLineCoord = lineOffset.y;
  ${rounded ? "vEndpointFraction = totalLineWidth / (linePixelLength + totalLineWidth * 2.0);" : ""}
  ${rounded ? "vLineCoordT = lineOffset.x; vLineBorderStartFraction = lineWidthInPixels / totalLineWidth;" : ""}
}
void emitLine(mat4 projection, vec3 vertexA, vec3 vertexB, float lineWidthInPixels
              ${rounded ? ", float borderWidth" : ""}) {
  emitLine(projection * vec4(vertexA, 1.0), projection * vec4(vertexB, 1.0),
           lineWidthInPixels
           ${rounded ? ", borderWidth" : ""});
}
`);
  if (rounded) {
    builder.addFragmentCode(`
vec4 getRoundedLineColor(vec4 interiorColor, vec4 borderColor) {
  float radius;
  if (vLineCoordT < vEndpointFraction || vLineCoordT > 1.0 - vEndpointFraction) {
    radius = length(vec2(1.0 - min(vLineCoordT, 1.0 - vLineCoordT) / vEndpointFraction,
                         vLineCoord));
    if (radius > 1.0) {
      discard;
    }
  } else {
    radius = abs(vLineCoord);
  }
  float borderColorFraction = clamp((radius - vLineBorderStartFraction) / vLineFeatherFraction, 0.0, 1.0);
  float feather = clamp((1.0 - radius) / vLineFeatherFraction, 0.0, 1.0);
  vec4 color = mix(interiorColor, borderColor, borderColorFraction);
  return vec4(color.rgb, color.a * feather);
}
`);
  }
  builder.addFragmentCode(`
float getLineAlpha() {
  return clamp((1.0 - abs(vLineCoord)) / vLineFeatherFraction, 0.0, 1.0);
}
`);
}
function drawLines(gl, linesPerInstance, numInstances) {
  drawQuads(gl, linesPerInstance, numInstances);
}
function initializeLineShader(shader, projectionParameters, featherWidthInPixels) {
  const gl = shader.gl;
  gl.uniform3f(shader.uniform("uLineParams"), 1 / projectionParameters.width, 1 / projectionParameters.height, featherWidthInPixels);
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function defineVertexId(builder) {
  builder.addAttribute("int", "aDummyVertexId", 0);
  builder.addVertexCode(`
int getVertexId () {
  return aDummyVertexId + gl_VertexID;
}
#define gl_VertexID (getVertexId())
`);
}
class VertexIdHelper extends RefCounted {
  constructor(gl) {
    super();
    this.buffer = new Buffer(gl);
    this.size = 0;
  }
  disposed() {
    this.buffer.dispose();
  }
  enable(size = 256) {
    const buffer = this.buffer;
    const gl = buffer.gl;
    buffer.bind();
    if (size > this.size) {
      this.size = size;
      gl.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, new Int32Array(size), WebGL2RenderingContext.STATIC_DRAW);
    }
    gl.vertexAttribIPointer(0, 1, WebGL2RenderingContext.INT, 0, 0);
    gl.vertexAttribDivisor(0, 0);
    gl.enableVertexAttribArray(0);
  }
  disable() {
    const gl = this.buffer.gl;
    gl.disableVertexAttribArray(0);
  }
  static get(gl) {
    return gl.memoize.get("VertexIdHelper", () => new VertexIdHelper(gl));
  }
}
const tempMat2 = create$4();
const DEFAULT_FRAGMENT_MAIN$1 = `void main() {
  emitDefault();
}
`;
const vertexAttributeSamplerSymbols = [];
const vertexPositionTextureFormat = computeTextureFormat(new TextureFormat(), DataType.FLOAT32, 3);
let RenderHelper$5 = class RenderHelper extends RefCounted {
  constructor(base, targetIsSliceView) {
    super();
    this.base = base;
    this.targetIsSliceView = targetIsSliceView;
    this.textureAccessHelper = new OneDimensionalTextureAccessHelper("vertexData");
    this.vertexIdHelper = this.registerDisposer(VertexIdHelper.get(this.gl));
    this.edgeShaderGetter = parameterizedEmitterDependentShaderGetter(this, this.gl, {
      memoizeKey: { type: "skeleton/SkeletonShaderManager/edge", vertexAttributes: this.vertexAttributes },
      fallbackParameters: this.base.fallbackShaderParameters,
      parameters: this.base.displayState.skeletonRenderingOptions.shaderControlState.builderState,
      shaderError: this.base.displayState.shaderError,
      defineShader: (builder, shaderBuilderState) => {
        if (shaderBuilderState.parseResult.errors.length !== 0) {
          throw new Error("Invalid UI control specification");
        }
        this.defineCommonShader(builder);
        this.defineAttributeAccess(builder);
        defineLineShader(builder);
        builder.addAttribute("highp uvec2", "aVertexIndex");
        builder.addUniform("highp float", "uLineWidth");
        let vertexMain = `
highp vec3 vertexA = readAttribute0(aVertexIndex.x);
highp vec3 vertexB = readAttribute0(aVertexIndex.y);
emitLine(uProjection, vertexA, vertexB, uLineWidth);
highp uint lineEndpointIndex = getLineEndpointIndex();
highp uint vertexIndex = aVertexIndex.x * lineEndpointIndex + aVertexIndex.y * (1u - lineEndpointIndex);
`;
        builder.addFragmentCode(`
vec4 segmentColor() {
  return uColor;
}
void emitRGB(vec3 color) {
  emit(vec4(color * uColor.a, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);
}
void emitDefault() {
  emit(vec4(uColor.rgb, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);
}
`);
        builder.addFragmentCode(glsl_COLORMAPS);
        const vertexAttributes = this.vertexAttributes;
        const numAttributes = vertexAttributes.length;
        for (let i = 1; i < numAttributes; ++i) {
          const info = vertexAttributes[i];
          builder.addVarying(`highp ${info.glslDataType}`, `vCustom${i}`);
          vertexMain += `vCustom${i} = readAttribute${i}(vertexIndex);
`;
          builder.addFragmentCode(`#define ${info.name} vCustom${i}
`);
        }
        builder.setVertexMain(vertexMain);
        addControlsToBuilder(shaderBuilderState, builder);
        builder.setFragmentMainFunction(shaderCodeWithLineDirective(shaderBuilderState.parseResult.code));
      }
    });
    this.nodeShaderGetter = parameterizedEmitterDependentShaderGetter(this, this.gl, {
      memoizeKey: { type: "skeleton/SkeletonShaderManager/node", vertexAttributes: this.vertexAttributes },
      fallbackParameters: this.base.fallbackShaderParameters,
      parameters: this.base.displayState.skeletonRenderingOptions.shaderControlState.builderState,
      shaderError: this.base.displayState.shaderError,
      defineShader: (builder, shaderBuilderState) => {
        if (shaderBuilderState.parseResult.errors.length !== 0) {
          throw new Error("Invalid UI control specification");
        }
        this.defineCommonShader(builder);
        this.defineAttributeAccess(builder);
        defineCircleShader(
          builder,
          /*crossSectionFade=*/
          this.targetIsSliceView
        );
        builder.addUniform("highp float", "uNodeDiameter");
        let vertexMain = `
highp uint vertexIndex = uint(gl_InstanceID);
highp vec3 vertexPosition = readAttribute0(vertexIndex);
emitCircle(uProjection * vec4(vertexPosition, 1.0), uNodeDiameter, 0.0);
`;
        builder.addFragmentCode(`
vec4 segmentColor() {
  return uColor;
}
void emitRGBA(vec4 color) {
  vec4 borderColor = color;
  emit(getCircleColor(color, borderColor), uPickID);
}
void emitRGB(vec3 color) {
  emitRGBA(vec4(color, 1.0));
}
void emitDefault() {
  emitRGBA(uColor);
}
`);
        builder.addFragmentCode(glsl_COLORMAPS);
        const vertexAttributes = this.vertexAttributes;
        const numAttributes = vertexAttributes.length;
        for (let i = 1; i < numAttributes; ++i) {
          const info = vertexAttributes[i];
          builder.addVarying(`highp ${info.glslDataType}`, `vCustom${i}`);
          vertexMain += `vCustom${i} = readAttribute${i}(vertexIndex);
`;
          builder.addFragmentCode(`#define ${info.name} vCustom${i}
`);
        }
        builder.setVertexMain(vertexMain);
        addControlsToBuilder(shaderBuilderState, builder);
        builder.setFragmentMainFunction(shaderCodeWithLineDirective(shaderBuilderState.parseResult.code));
      }
    });
  }
  get vertexAttributes() {
    return this.base.vertexAttributes;
  }
  defineCommonShader(builder) {
    defineVertexId(builder);
    builder.addUniform("highp vec4", "uColor");
    builder.addUniform("highp mat4", "uProjection");
    builder.addUniform("highp uint", "uPickID");
  }
  get gl() {
    return this.base.gl;
  }
  defineAttributeAccess(builder) {
    const textureAccessHelper = this.textureAccessHelper;
    textureAccessHelper.defineShader(builder);
    const numAttributes = this.vertexAttributes.length;
    for (let j = vertexAttributeSamplerSymbols.length; j < numAttributes; ++j) {
      vertexAttributeSamplerSymbols[j] = _Symbol(`SkeletonShader.vertexAttributeTextureUnit${j}`);
    }
    this.vertexAttributes.forEach((info, i) => {
      builder.addTextureSampler(`${getSamplerPrefixForDataType(info.dataType)}sampler2D`, `uVertexAttributeSampler${i}`, vertexAttributeSamplerSymbols[i]);
      builder.addVertexCode(textureAccessHelper.getAccessor(`readAttribute${i}`, `uVertexAttributeSampler${i}`, info.dataType, info.numComponents));
    });
  }
  getCrossSectionFadeFactor() {
    if (this.targetIsSliceView) {
      return `(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))`;
    } else {
      return `(1.0)`;
    }
  }
  beginLayer(gl, shader, renderContext, modelMatrix) {
    const viewProjectionMat = renderContext.projectionParameters.viewProjectionMat;
    let mat = multiply$3(tempMat2, viewProjectionMat, modelMatrix);
    gl.uniformMatrix4fv(shader.uniform("uProjection"), false, mat);
    this.vertexIdHelper.enable();
  }
  setColor(gl, shader, color2) {
    gl.uniform4fv(shader.uniform("uColor"), color2);
  }
  setPickID(gl, shader, pickID) {
    gl.uniform1ui(shader.uniform("uPickID"), pickID);
  }
  drawSkeleton(gl, edgeShader, nodeShader, skeletonChunk, projectionParameters) {
    const vertexAttributes = this.vertexAttributes;
    const numAttributes = vertexAttributes.length;
    const vertexAttributeTextures = skeletonChunk.vertexAttributeTextures;
    for (let i = 0; i < numAttributes; ++i) {
      const textureUnit = WebGL2RenderingContext.TEXTURE0 + edgeShader.textureUnit(vertexAttributeSamplerSymbols[i]);
      gl.activeTexture(textureUnit);
      gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, vertexAttributeTextures[i]);
    }
    {
      edgeShader.bind();
      const aVertexIndex = edgeShader.attribute("aVertexIndex");
      skeletonChunk.indexBuffer.bindToVertexAttribI(aVertexIndex, 2, WebGL2RenderingContext.UNSIGNED_INT);
      gl.vertexAttribDivisor(aVertexIndex, 1);
      initializeLineShader(edgeShader, projectionParameters, this.targetIsSliceView ? 1 : 0);
      drawLines(gl, 1, skeletonChunk.numIndices / 2);
      gl.vertexAttribDivisor(aVertexIndex, 0);
      gl.disableVertexAttribArray(aVertexIndex);
    }
    if (nodeShader !== null) {
      nodeShader.bind();
      initializeCircleShader(nodeShader, projectionParameters, { featherWidthInPixels: this.targetIsSliceView ? 1 : 0 });
      drawCircles(nodeShader.gl, 2, skeletonChunk.numVertices);
    }
  }
  endLayer(gl, shader) {
    const vertexAttributes = this.vertexAttributes;
    const numAttributes = vertexAttributes.length;
    for (let i = 0; i < numAttributes; ++i) {
      let curTextureUnit = shader.textureUnit(vertexAttributeSamplerSymbols[i]) + WebGL2RenderingContext.TEXTURE0;
      gl.activeTexture(curTextureUnit);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    this.vertexIdHelper.disable();
  }
};
var SkeletonRenderMode;
(function(SkeletonRenderMode2) {
  SkeletonRenderMode2[SkeletonRenderMode2["LINES"] = 0] = "LINES";
  SkeletonRenderMode2[SkeletonRenderMode2["LINES_AND_POINTS"] = 1] = "LINES_AND_POINTS";
})(SkeletonRenderMode || (SkeletonRenderMode = {}));
class TrackableSkeletonRenderMode extends TrackableEnum {
  constructor(value, defaultValue = value) {
    super(SkeletonRenderMode, value, defaultValue);
  }
}
class TrackableSkeletonLineWidth extends TrackableValue {
  constructor(value, defaultValue = value) {
    super(value, verifyFinitePositiveFloat, defaultValue);
  }
}
class SkeletonRenderingOptions {
  constructor() {
    this.compound = new CompoundTrackable();
    this.shader = makeTrackableFragmentMain(DEFAULT_FRAGMENT_MAIN$1);
    this.shaderControlState = new ShaderControlState(this.shader);
    this.params2d = {
      mode: new TrackableSkeletonRenderMode(SkeletonRenderMode.LINES_AND_POINTS),
      lineWidth: new TrackableSkeletonLineWidth(2)
    };
    this.params3d = {
      mode: new TrackableSkeletonRenderMode(SkeletonRenderMode.LINES),
      lineWidth: new TrackableSkeletonLineWidth(1)
    };
    const compound = this.compound;
    compound.add("shader", this.shader);
    compound.add("shaderControls", this.shaderControlState);
    compound.add("mode2d", this.params2d.mode);
    compound.add("lineWidth2d", this.params2d.lineWidth);
    compound.add("mode3d", this.params3d.mode);
    compound.add("lineWidth3d", this.params3d.lineWidth);
  }
  get changed() {
    return this.compound.changed;
  }
  reset() {
    this.compound.reset();
  }
  restoreState(obj) {
    if (obj === void 0) return;
    this.compound.restoreState(obj);
  }
  toJSON() {
    const obj = this.compound.toJSON();
    for (const v of _Object$values(obj)) {
      if (v !== void 0) return obj;
    }
    return void 0;
  }
}
class SkeletonLayer extends RefCounted {
  constructor(chunkManager, source, displayState) {
    super();
    this.chunkManager = chunkManager;
    this.source = source;
    this.displayState = displayState;
    this.layerChunkProgressInfo = new LayerChunkProgressInfo();
    this.redrawNeeded = new NullarySignal();
    this.fallbackShaderParameters = new WatchableValue(getFallbackBuilderState(parseShaderUiControls(DEFAULT_FRAGMENT_MAIN$1)));
    registerRedrawWhenSegmentationDisplayState3DChanged(displayState, this);
    this.displayState.shaderError.value = void 0;
    const renderingOptions = displayState.skeletonRenderingOptions;
    this.registerDisposer(renderingOptions.shader.changed.add(() => {
      this.displayState.shaderError.value = void 0;
      this.redrawNeeded.dispatch();
    }));
    let sharedObject = this.sharedObject = this.registerDisposer(new SegmentationLayerSharedObject(chunkManager, displayState, this.layerChunkProgressInfo));
    sharedObject.RPC_TYPE_ID = SKELETON_LAYER_RPC_ID;
    sharedObject.initializeCounterpartWithChunkManager({
      "source": source.addCounterpartRef()
    });
    const vertexAttributes = this.vertexAttributes = [vertexPositionAttribute];
    for (let _ref of source.vertexAttributes) {
      var _ref2 = _slicedToArray(_ref, 2);
      let name2 = _ref2[0];
      let info = _ref2[1];
      vertexAttributes.push({
        name: name2,
        dataType: info.dataType,
        numComponents: info.numComponents,
        webglDataType: getWebglDataType(info.dataType),
        glslDataType: info.numComponents > 1 ? `vec${info.numComponents}` : "float"
      });
    }
  }
  get visibility() {
    return this.sharedObject.visibility;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  draw(renderContext, layer, renderHelper, renderOptions, attachment) {
    let lineWidth = renderOptions.lineWidth.value;
    const gl = this.gl, source = this.source, displayState = this.displayState;
    if (displayState.objectAlpha.value <= 0) {
      return;
    }
    const modelMatrix = update3dRenderLayerAttachment(displayState.transform.value, renderContext.projectionParameters.displayDimensionRenderInfo, attachment);
    if (modelMatrix === void 0) return;
    let pointDiameter;
    if (renderOptions.mode.value === SkeletonRenderMode.LINES_AND_POINTS) {
      pointDiameter = Math.max(5, lineWidth * 2);
    } else {
      pointDiameter = lineWidth;
    }
    const edgeShaderResult = renderHelper.edgeShaderGetter(renderContext.emitter);
    const nodeShaderResult = renderHelper.nodeShaderGetter(renderContext.emitter);
    const edgeShader = edgeShaderResult.shader, edgeShaderParameters = edgeShaderResult.parameters;
    const nodeShader = nodeShaderResult.shader, nodeShaderParameters = nodeShaderResult.parameters;
    if (edgeShader === null || nodeShader === null) {
      return;
    }
    const shaderControlState = this.displayState.skeletonRenderingOptions.shaderControlState;
    edgeShader.bind();
    renderHelper.beginLayer(gl, edgeShader, renderContext, modelMatrix);
    setControlsInShader(gl, edgeShader, shaderControlState, edgeShaderParameters.parseResult.controls);
    gl.uniform1f(edgeShader.uniform("uLineWidth"), lineWidth);
    nodeShader.bind();
    renderHelper.beginLayer(gl, nodeShader, renderContext, modelMatrix);
    gl.uniform1f(nodeShader.uniform("uNodeDiameter"), pointDiameter);
    setControlsInShader(gl, nodeShader, shaderControlState, nodeShaderParameters.parseResult.controls);
    const skeletons = source.chunks;
    forEachVisibleSegmentToDraw(displayState, layer, renderContext.emitColor, renderContext.emitPickID ? renderContext.pickIDs : void 0, (objectId, color2, pickIndex) => {
      const key = getObjectKey(objectId);
      const skeleton = skeletons.get(key);
      if (skeleton === void 0 || skeleton.state !== ChunkState.GPU_MEMORY) {
        return;
      }
      if (color2 !== void 0) {
        edgeShader.bind();
        renderHelper.setColor(gl, edgeShader, color2);
        nodeShader.bind();
        renderHelper.setColor(gl, nodeShader, color2);
      }
      if (pickIndex !== void 0) {
        edgeShader.bind();
        renderHelper.setPickID(gl, edgeShader, pickIndex);
        nodeShader.bind();
        renderHelper.setPickID(gl, nodeShader, pickIndex);
      }
      renderHelper.drawSkeleton(gl, edgeShader, nodeShader, skeleton, renderContext.projectionParameters);
    });
    renderHelper.endLayer(gl, edgeShader);
  }
  isReady() {
    const source = this.source, displayState = this.displayState;
    if (displayState.objectAlpha.value <= 0) {
      return true;
    }
    const skeletons = source.chunks;
    let ready = true;
    forEachVisibleSegment(displayState.segmentationGroupState.value, (objectId) => {
      const key = getObjectKey(objectId);
      const skeleton = skeletons.get(key);
      if (skeleton === void 0 || skeleton.state !== ChunkState.GPU_MEMORY) {
        ready = false;
        return;
      }
    });
    return ready;
  }
}
class PerspectiveViewSkeletonLayer extends PerspectiveViewRenderLayer {
  constructor(base) {
    super();
    this.base = base;
    this.renderHelper = this.registerDisposer(new RenderHelper$5(this.base, false));
    this.renderOptions = this.base.displayState.skeletonRenderingOptions.params3d;
    this.layerChunkProgressInfo = base.layerChunkProgressInfo;
    this.registerDisposer(base);
    this.registerDisposer(base.redrawNeeded.add(this.redrawNeeded.dispatch));
    const renderOptions = this.renderOptions;
    this.registerDisposer(renderOptions.mode.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(renderOptions.lineWidth.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(base.visibility.add(this.visibility));
  }
  get gl() {
    return this.base.gl;
  }
  get isTransparent() {
    return this.base.displayState.objectAlpha.value < 1;
  }
  draw(renderContext, attachment) {
    if (!renderContext.emitColor && renderContext.alreadyEmittedPickID) {
      return;
    }
    this.base.draw(renderContext, this, this.renderHelper, this.renderOptions, attachment);
  }
  isReady() {
    return this.base.isReady();
  }
}
class SliceViewPanelSkeletonLayer extends SliceViewPanelRenderLayer {
  constructor(base) {
    super();
    this.base = base;
    this.renderHelper = this.registerDisposer(new RenderHelper$5(this.base, true));
    this.renderOptions = this.base.displayState.skeletonRenderingOptions.params2d;
    this.layerChunkProgressInfo = base.layerChunkProgressInfo;
    this.registerDisposer(base);
    const renderOptions = this.renderOptions;
    this.registerDisposer(renderOptions.mode.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(renderOptions.lineWidth.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(base.redrawNeeded.add(this.redrawNeeded.dispatch));
    this.registerDisposer(base.visibility.add(this.visibility));
  }
  get gl() {
    return this.base.gl;
  }
  draw(renderContext, attachment) {
    this.base.draw(renderContext, this, this.renderHelper, this.renderOptions, attachment);
  }
  isReady() {
    return this.base.isReady();
  }
}
function getWebglDataType(dataType) {
  switch (dataType) {
    case DataType.FLOAT32:
      return WebGL2RenderingContext.FLOAT;
    default:
      throw new Error(`Data type not supported by WebGL: ${DataType[dataType]}`);
  }
}
const vertexPositionAttribute = {
  dataType: DataType.FLOAT32,
  numComponents: 3,
  name: "",
  webglDataType: WebGL2RenderingContext.FLOAT,
  glslDataType: "vec3"
};
class SkeletonChunk extends Chunk {
  constructor(source, x) {
    super(source);
    this.vertexAttributes = x["vertexAttributes"];
    let indices = this.indices = x["indices"];
    this.numVertices = x["numVertices"];
    this.vertexAttributeOffsets = x["vertexAttributeOffsets"];
    this.numIndices = indices.length;
  }
  copyToGPU(gl) {
    super.copyToGPU(gl);
    const attributeTextureFormats = this.source.attributeTextureFormats;
    const vertexAttributes = this.vertexAttributes, vertexAttributeOffsets = this.vertexAttributeOffsets;
    const vertexAttributeTextures = this.vertexAttributeTextures = [];
    for (let i = 0, numAttributes = vertexAttributeOffsets.length; i < numAttributes; ++i) {
      const texture = gl.createTexture();
      gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
      setOneDimensionalTextureData(gl, attributeTextureFormats[i], vertexAttributes.subarray(vertexAttributeOffsets[i], i + 1 !== numAttributes ? vertexAttributeOffsets[i + 1] : vertexAttributes.length));
      vertexAttributeTextures[i] = texture;
    }
    gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
    this.indexBuffer = Buffer.fromData(gl, this.indices, WebGL2RenderingContext.ARRAY_BUFFER, WebGL2RenderingContext.STATIC_DRAW);
  }
  freeGPUMemory(gl) {
    super.freeGPUMemory(gl);
    const vertexAttributeTextures = this.vertexAttributeTextures;
    for (const texture of vertexAttributeTextures) {
      gl.deleteTexture(texture);
    }
    vertexAttributeTextures.length = 0;
    this.indexBuffer.dispose();
  }
}
const emptyVertexAttributes = new _Map();
function getAttributeTextureFormats(vertexAttributes) {
  const attributeTextureFormats = [vertexPositionTextureFormat];
  for (const info of vertexAttributes.values()) {
    attributeTextureFormats.push(computeTextureFormat(new TextureFormat(), info.dataType, info.numComponents));
  }
  return attributeTextureFormats;
}
class SkeletonSource extends ChunkSource {
  constructor(chunkManager, options) {
    super(chunkManager, options);
  }
  get attributeTextureFormats() {
    let attributeTextureFormats = this.attributeTextureFormats_;
    if (attributeTextureFormats === void 0) {
      attributeTextureFormats = this.attributeTextureFormats_ = getAttributeTextureFormats(this.vertexAttributes);
    }
    return attributeTextureFormats;
  }
  getChunk(x) {
    return new SkeletonChunk(this, x);
  }
  get vertexAttributes() {
    return emptyVertexAttributes;
  }
}
function defineChunkDataShaderAccess(builder, chunkFormat, numChannelDimensions, getPositionWithinChunkExpr) {
  const dataType = chunkFormat.dataType;
  chunkFormat.defineShader(builder, numChannelDimensions);
  let dataAccessChannelParams = ``;
  let dataAccessChannelArgs = ``;
  if (numChannelDimensions === 0) {
    dataAccessChannelParams += `highp int ignoredChannelIndex`;
  } else {
    for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
      if (channelDim !== 0) dataAccessChannelParams += `, `;
      dataAccessChannelParams += `highp int channelIndex${channelDim}`;
      dataAccessChannelArgs += `, channelIndex${channelDim}`;
    }
  }
  builder.addFragmentCode(glsl_mixLinear);
  let dataAccessCode = `
${getShaderType(dataType)} getDataValue(${dataAccessChannelParams}) {
  highp ivec3 p = ivec3(max(vec3(0.0, 0.0, 0.0), min(floor(${getPositionWithinChunkExpr}), uChunkDataSize - 1.0)));
  return getDataValueAt(p${dataAccessChannelArgs});
}
${getShaderType(dataType)} getInterpolatedDataValue(${dataAccessChannelParams}) {
  highp vec3 positionWithinChunk = ${getPositionWithinChunkExpr};
  highp ivec3[2] points;
  points[0] = ivec3(max(vec3(0.0, 0.0, 0.0), min(floor(positionWithinChunk - 0.5), uChunkDataSize - 1.0)));
  points[1] = ivec3(max(vec3(0.0, 0.0, 0.0), min(ceil(positionWithinChunk - 0.5), uChunkDataSize - 1.0)));
  highp vec3 mixCoeff = fract(positionWithinChunk - 0.5);
  ${getShaderType(dataType)} xvalues[2];
  for (int ix = 0; ix < 2; ++ix) {
    ${getShaderType(dataType)} yvalues[2];
    for (int iy = 0; iy < 2; ++iy) {
      ${getShaderType(dataType)} zvalues[2];
      for (int iz = 0; iz < 2; ++iz) {
        zvalues[iz] = getDataValueAt(ivec3(points[ix].x, points[iy].y, points[iz].z)
                                     ${dataAccessChannelArgs});
      }
      yvalues[iy] = mixLinear(zvalues[0], zvalues[1], mixCoeff.z);
    }
    xvalues[ix] = mixLinear(yvalues[0], yvalues[1], mixCoeff.y);
  }
  return mixLinear(xvalues[0], xvalues[1], mixCoeff.x);
}
`;
  builder.addFragmentCode(dataAccessCode);
  if (numChannelDimensions <= 1) {
    builder.addFragmentCode(`
${getShaderType(dataType)} getDataValue() { return getDataValue(0); }
${getShaderType(dataType)} getInterpolatedDataValue() { return getInterpolatedDataValue(0); }
`);
  }
}
var chunkFormatHandlers = new Array();
function registerChunkFormatHandler(factory) {
  chunkFormatHandlers.push(factory);
}
function getChunkFormatHandler(gl, spec) {
  for (let handler of chunkFormatHandlers) {
    let result = handler(gl, spec);
    if (result != null) {
      return result;
    }
  }
  throw new Error("No chunk format handler found.");
}
class VolumeChunkSource extends SliceViewChunkSource {
  constructor(chunkManager, options) {
    super(chunkManager, options);
    this.chunkFormatHandler = this.registerDisposer(getChunkFormatHandler(chunkManager.chunkQueueManager.gl, this.spec));
    const rank = this.spec.upperVoxelBound.length;
    this.tempChunkGridPosition = new Float32Array(rank);
    this.tempPositionWithinChunk = new Uint32Array(rank);
  }
  static encodeSpec(spec) {
    const s = spec;
    return _Object$assign(_Object$assign({}, super.encodeSpec(spec)), { dataType: s.dataType, compressedSegmentationBlockSize: s.compressedSegmentationBlockSize && _Array$from(s.compressedSegmentationBlockSize), baseVoxelOffset: _Array$from(s.baseVoxelOffset) });
  }
  get chunkFormat() {
    return this.chunkFormatHandler.chunkFormat;
  }
  getValueAt(chunkPosition, channelAccess) {
    const rank = this.spec.rank;
    const chunkGridPosition = this.tempChunkGridPosition;
    const positionWithinChunk = this.tempPositionWithinChunk;
    const spec = this.spec;
    {
      const chunkDataSize2 = spec.chunkDataSize;
      for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
        const voxel = chunkPosition[chunkDim];
        const chunkSize = chunkDataSize2[chunkDim];
        const chunk2 = Math.floor(voxel / chunkSize);
        chunkGridPosition[chunkDim] = chunk2;
        positionWithinChunk[chunkDim] = Math.floor(voxel - chunkSize * chunk2);
      }
    }
    const chunk = this.chunks.get(chunkGridPosition.join());
    if (chunk === void 0) {
      return null;
    }
    const chunkDataSize = chunk.chunkDataSize;
    for (let i = 0; i < 3; ++i) {
      if (positionWithinChunk[i] >= chunkDataSize[i]) {
        return void 0;
      }
    }
    if (channelAccess.channelSpaceShape.length === 0) {
      return chunk.getValueAt(positionWithinChunk);
    }
    const numChannels = channelAccess.numChannels, chunkChannelCoordinates = channelAccess.chunkChannelCoordinates, chunkChannelDimensionIndices = channelAccess.chunkChannelDimensionIndices;
    const chunkChannelRank = chunkChannelDimensionIndices.length;
    let offset = 0;
    const values2 = new Array(numChannels);
    for (let channelIndex = 0; channelIndex < numChannels; ++channelIndex) {
      for (let i = 0; i < chunkChannelRank; ++i) {
        positionWithinChunk[chunkChannelDimensionIndices[i]] = chunkChannelCoordinates[offset++];
      }
      values2[channelIndex] = chunk.getValueAt(positionWithinChunk);
    }
    return values2;
  }
  getChunk(x) {
    return this.chunkFormatHandler.getChunk(this, x);
  }
}
class VolumeChunk extends SliceViewChunk {
  constructor(source, x) {
    super(source, x);
    this.chunkDataSize = x["chunkDataSize"] || source.spec.chunkDataSize;
  }
  get chunkFormat() {
    return this.source.chunkFormat;
  }
}
let MultiscaleVolumeChunkSource$3 = class MultiscaleVolumeChunkSource extends MultiscaleSliceViewChunkSource {
};
const svg_plus = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="plusIconTitle"><title id="plusIconTitle">Plus</title><path d="M20 12L4 12M12 4L12 20"></path></svg>';
function makeAddButton(options = {}) {
  return makeIcon(_Object$assign({ svg: svg_plus }, options));
}
const svg_updateArrow = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="arrowUpIconTitle"><title id="arrowUpIconTitle">Arrow Up</title><path d="M18 9l-6-6-6 6"></path><path d="M12 21V4"></path><path stroke-linecap="round" d="M12 3v1"></path></svg>';
const globalModifiers = new WatchableValue(0);
window.addEventListener("keydown", (event) => {
  globalModifiers.value = getEventModifierMask(event);
});
window.addEventListener("keyup", (event) => {
  globalModifiers.value = getEventModifierMask(event);
});
const globalKeys = new _Set(["f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "escape", "pause"]);
const DEFAULT_TEXT_INPUTS = new _Set(["color", "date", "datetime", "datetime-local", "email", "month", "number", "password", "search", "tel", "text", "time", "url", "week"]);
class KeyboardEventBinder extends RefCounted {
  constructor(target, eventMap) {
    super();
    this.target = target;
    this.eventMap = eventMap;
    this.modifierShortcutsAreGlobal = true;
    this.allShortcutsAreGlobal = false;
    this.allowSpaceKeyOnButtons = false;
    this.registerEventListener(
      target,
      "keydown",
      this.handleKeyDown.bind(this),
      /*useCapture=*/
      false
    );
  }
  shouldIgnoreEvent(key, event) {
    var el = event.target;
    let tagName = el.tagName;
    if (el === this.target) {
      return false;
    }
    var isFormElement = tagName === "TEXTAREA" || tagName === "INPUT" || tagName === "BUTTON" || tagName === "SELECT";
    var isContentEditable = !isFormElement && (el.isContentEditable || el.ownerDocument && el.ownerDocument.designMode === "on");
    if (!isFormElement && !isContentEditable) {
      return false;
    }
    if (this.allShortcutsAreGlobal || globalKeys.has(key)) {
      return false;
    }
    if (isContentEditable) {
      return true;
    }
    if (this.modifierShortcutsAreGlobal && (event.altKey || event.ctrlKey || event.metaKey)) {
      return true;
    }
    if (tagName === "INPUT" && DEFAULT_TEXT_INPUTS.has(el.type)) {
      return key !== "enter";
    }
    if (tagName === "INPUT" || tagName === "BUTTON") {
      if (this.allowSpaceKeyOnButtons) {
        return false;
      } else {
        return key === "space";
      }
    }
    return true;
  }
  handleKeyDown(event) {
    const key = getEventKeyName(event);
    if (this.shouldIgnoreEvent(key, event)) {
      return;
    }
    dispatchEventWithModifiers(key, event, event, this.eventMap);
  }
}
function getEventKeyName(event) {
  return event.code.toLowerCase();
}
function updateInputFieldWidth(element, value = element.value) {
  element.style.minWidth = value.length + 1 + "ch";
}
const singletonClassName = "neuroglancer-coordinate-space-transform-singleton";
function formatBounds(lower, upper) {
  let lowerString;
  if (lower === Number.NEGATIVE_INFINITY) {
    lowerString = "(-∞,";
  } else {
    lowerString = `[${Math.floor(lower)},`;
  }
  let upperString;
  if (upper === Number.POSITIVE_INFINITY) {
    upperString = "+∞)";
  } else {
    upperString = `${Math.floor(upper)})`;
  }
  return { lower: lowerString, upper: upperString };
}
const inputEventMap$5 = EventActionMap.fromObject({
  "arrowup": { action: "move-up" },
  "arrowdown": { action: "move-down" },
  "arrowleft": { action: "move-left", preventDefault: false },
  "arrowright": { action: "move-right", preventDefault: false },
  "enter": { action: "commit" },
  "escape": { action: "cancel" }
});
function makeScaleElement() {
  const cellElement = document.createElement("div");
  const inputElement = document.createElement("input");
  cellElement.classList.add("neuroglancer-coordinate-space-transform-scale-container");
  inputElement.spellcheck = false;
  inputElement.autocomplete = "off";
  inputElement.size = 1;
  inputElement.classList.add("neuroglancer-coordinate-space-transform-scale");
  cellElement.appendChild(inputElement);
  const suggestionElement = document.createElement("div");
  const suggestionArrow = document.createElement("span");
  suggestionArrow.innerHTML = svg_updateArrow;
  suggestionElement.appendChild(suggestionArrow);
  const textNode = document.createTextNode("");
  suggestionElement.appendChild(textNode);
  suggestionElement.classList.add("neuroglancer-coordinate-space-transform-scale-suggestion");
  cellElement.appendChild(suggestionElement);
  return { cellElement, inputElement, suggestionElement };
}
function updateScaleSuggestionElement(suggestionElement, suggested, existingScale, existingUnit, prefix) {
  if (suggested === void 0 || suggested.scale === existingScale && suggested.unit === existingUnit) {
    suggestionElement.style.display = "none";
  } else {
    suggestionElement.style.display = "";
    const suggestedString = formatScaleWithUnitAsString(suggested.scale, suggested.unit, { elide1: false });
    suggestionElement.lastChild.textContent = suggestedString;
    suggestionElement.title = `${prefix}${suggestedString}`;
  }
}
function makeOutputNameElement() {
  const inputElement = document.createElement("input");
  inputElement.spellcheck = false;
  inputElement.autocomplete = "off";
  inputElement.size = 1;
  inputElement.placeholder = " ";
  inputElement.classList.add("neuroglancer-coordinate-space-transform-output-name");
  return inputElement;
}
function updateCoordinateSpaceScales(scaleElements, modified, watchable) {
  const scalesAndUnits = scaleElements.map((x) => parseScale(x.value));
  if (scalesAndUnits.includes(void 0)) {
    return false;
  }
  const newScales = Float64Array.from(scalesAndUnits, (x) => x.scale);
  const newUnits = _Array$from(scalesAndUnits, (x) => x.unit);
  const existing = watchable.value;
  const scales = existing.scales, units = existing.units, rank = existing.rank;
  for (let i = 0; i < rank; ++i) {
    if (!modified[i]) {
      newScales[i] = scales[i];
      newUnits[i] = units[i];
    }
  }
  if (arraysEqual(scales, newScales) && arraysEqual(units, newUnits)) return false;
  const timestamps = existing.timestamps.map((t, i) => newScales[i] === scales[i] && newUnits[i] === units[i] ? t : Date.now());
  const newSpace = makeCoordinateSpace({
    valid: existing.valid,
    rank: existing.rank,
    scales: newScales,
    units: newUnits,
    timestamps,
    ids: existing.ids,
    names: existing.names,
    boundingBoxes: existing.boundingBoxes,
    coordinateArrays: existing.coordinateArrays
  });
  watchable.value = newSpace;
  return true;
}
function updateCoordinateSpaceSingleDimensionScale(space, dimIndex, scale2, unit) {
  const scales = new Float64Array(space.scales);
  const units = _Array$from(space.units);
  if (scales[dimIndex] === scale2 && units[dimIndex] === unit) return space;
  const timestamps = _Array$from(space.timestamps);
  scales[dimIndex] = scale2;
  units[dimIndex] = unit;
  timestamps[dimIndex] = Date.now();
  return _Object$assign(_Object$assign({}, space), { scales, units, timestamps });
}
class CoordinateSpaceTransformWidget extends RefCounted {
  constructor(transform, localCombiner, globalCombiner) {
    super();
    this.transform = transform;
    this.localCombiner = localCombiner;
    this.globalCombiner = globalCombiner;
    this.element = document.createElement("div");
    this.coefficientContainer = document.createElement("div");
    this.translationContainer = document.createElement("div");
    this.outputNameContainer = document.createElement("div");
    this.outputScaleContainer = document.createElement("div");
    this.inputNameContainer = document.createElement("div");
    this.inputScaleContainer = document.createElement("div");
    this.inputLowerBoundsContainer = document.createElement("div");
    this.inputUpperBoundsContainer = document.createElement("div");
    this.coefficientElements = [];
    this.inputNameElements = [];
    this.outputNameElements = [];
    this.outputScaleElements = [];
    this.outputScaleSuggestionElements = [];
    this.inputScaleSuggestionElements = [];
    this.inputScaleElements = [];
    this.inputBoundsElements = [];
    this.outputBoundsElements = [];
    this.addSourceDimensionIcon = makeIcon({ svg: svg_plus, text: "S" });
    this.addOutputDimensionIcon = makeIcon({ svg: svg_plus, text: "V" });
    this.addOutputDimensionCell = document.createElement("div");
    this.addOutputDimensionInput = makeOutputNameElement();
    this.inputScaleModified = [];
    this.outputScaleModified = [];
    this.curSourceRank = -1;
    this.curRank = -1;
    this.curTransform = void 0;
    this.addingSourceDimension = false;
    this.resetToIdentityButton = makeIcon({
      text: "Set to identity",
      title: "Reset to identity transform",
      onClick: () => {
        const transform2 = this.transform;
        const rank = transform2.value.rank;
        transform2.transform = createIdentity(Float64Array, rank + 1);
      }
    });
    this.resetToDefaultButton = makeIcon({
      text: "Reset to default",
      title: "Reset to default input scales, transform, and output dimensions.",
      onClick: () => {
        const transform2 = this.transform;
        if (transform2.mutableSourceRank) return;
        const defaultTransform = transform2.defaultTransform;
        let newOutputSpace = defaultTransform.outputSpace;
        const ids = newOutputSpace.ids.map(() => newDimensionId());
        transform2.value = _Object$assign(_Object$assign({}, defaultTransform), { outputSpace: _Object$assign(_Object$assign({}, newOutputSpace), { ids }) });
      }
    });
    const element = this.element;
    const keyboardHandler = this.registerDisposer(new KeyboardEventBinder(element, inputEventMap$5));
    keyboardHandler.allShortcutsAreGlobal = true;
    element.classList.add("neuroglancer-coordinate-space-transform-widget");
    this.registerDisposer(new MouseEventBinder(element, inputEventMap$5));
    const updateView = animationFrameDebounce(() => this.updateView());
    this.registerDisposer(transform.changed.add(updateView));
    const coefficientContainer = this.coefficientContainer, translationContainer = this.translationContainer, outputNameContainer = this.outputNameContainer, inputNameContainer = this.inputNameContainer, inputScaleContainer = this.inputScaleContainer, inputLowerBoundsContainer = this.inputLowerBoundsContainer, inputUpperBoundsContainer = this.inputUpperBoundsContainer, outputScaleContainer = this.outputScaleContainer, addOutputDimensionCell = this.addOutputDimensionCell, addOutputDimensionIcon = this.addOutputDimensionIcon, addSourceDimensionIcon = this.addSourceDimensionIcon, resetToIdentityButton = this.resetToIdentityButton, resetToDefaultButton = this.resetToDefaultButton;
    coefficientContainer.style.display = "contents";
    translationContainer.style.display = "contents";
    outputNameContainer.style.display = "contents";
    inputNameContainer.style.display = "contents";
    inputScaleContainer.style.display = "contents";
    outputScaleContainer.style.display = "contents";
    inputLowerBoundsContainer.style.display = "contents";
    inputUpperBoundsContainer.style.display = "contents";
    const resetButtons = document.createElement("div");
    resetButtons.classList.add("neuroglancer-coordinate-space-transform-widget-reset-buttons");
    resetToIdentityButton.classList.add("neuroglancer-coordinate-space-transform-widget-reset-to-identity");
    resetToDefaultButton.classList.add("neuroglancer-coordinate-space-transform-widget-reset-to-default");
    resetButtons.appendChild(resetToIdentityButton);
    resetButtons.appendChild(resetToDefaultButton);
    element.appendChild(resetButtons);
    for (const _ref of [["source", "Source dimensions"], ["output", "Output dimensions"], ["input-lower", "Lower"], ["input-upper", "Upper"], ["input-scale", "Scale"], ["translation", "Translation"]]) {
      var _ref2 = _slicedToArray(_ref, 2);
      const className = _ref2[0];
      const textContent = _ref2[1];
      const label = document.createElement("div");
      label.classList.add(`neuroglancer-coordinate-space-transform-${className}-label`);
      label.classList.add(`neuroglancer-coordinate-space-transform-label`);
      label.textContent = textContent;
      element.appendChild(label);
    }
    if (transform.mutableSourceRank) {
      addOutputDimensionCell.appendChild(addSourceDimensionIcon);
    }
    addOutputDimensionCell.appendChild(addOutputDimensionIcon);
    addOutputDimensionCell.classList.add("neuroglancer-coordinate-space-transform-output-extend");
    const extendOutputDimensionsTitle = "Embed in additional output dimension";
    const extendSourceDimensionsTitle = "Extend to additional source dimension";
    addOutputDimensionIcon.title = extendOutputDimensionsTitle;
    addSourceDimensionIcon.title = extendSourceDimensionsTitle;
    addOutputDimensionCell.appendChild(this.addOutputDimensionInput);
    addOutputDimensionCell.dataset.isActive = "false";
    addOutputDimensionIcon.addEventListener("click", () => {
      this.addingSourceDimension = false;
      this.addOutputDimensionInput.title = extendOutputDimensionsTitle;
      this.addOutputDimensionCell.dataset.isActive = "true";
      this.addOutputDimensionInput.focus();
    });
    addSourceDimensionIcon.addEventListener("click", () => {
      this.addingSourceDimension = true;
      this.addOutputDimensionInput.title = extendSourceDimensionsTitle;
      this.addOutputDimensionCell.dataset.isActive = "true";
      this.addOutputDimensionInput.focus();
    });
    this.addOutputDimensionInput.addEventListener("blur", () => {
      this.updateAddOutputDimensionCellStyle();
    });
    element.appendChild(coefficientContainer);
    element.appendChild(outputNameContainer);
    element.appendChild(inputNameContainer);
    element.appendChild(inputScaleContainer);
    element.appendChild(outputScaleContainer);
    element.appendChild(inputLowerBoundsContainer);
    element.appendChild(inputUpperBoundsContainer);
    coefficientContainer.appendChild(translationContainer);
    element.addEventListener("input", (event) => {
      const target = event.target;
      if (target instanceof HTMLInputElement) {
        updateInputFieldWidth(target);
        let index2 = this.inputScaleElements.indexOf(target);
        if (index2 !== -1) {
          this.inputScaleModified[index2] = true;
          this.updateScaleValidity(target);
          return;
        }
        index2 = this.outputScaleElements.indexOf(target);
        if (index2 !== -1) {
          this.outputScaleModified[index2] = true;
          this.updateScaleValidity(target);
          return;
        }
        index2 = this.outputNameElements.indexOf(target);
        if (index2 !== -1) {
          this.updateOutputNameValidity();
          return;
        }
        if (this.coefficientContainer.contains(target)) {
          this.updateCoefficientValidity(target);
          return;
        }
      }
    });
    const registerMoveUpDown = (action, rowDelta, colDelta) => {
      registerActionListener(element, action, (event) => {
        event.stopPropagation();
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) return;
        if (colDelta !== 0) {
          if (target.selectionStart !== target.selectionEnd || target.selectionStart !== (colDelta === 1 ? target.value.length : 0)) {
            return;
          }
        }
        const gridPos = this.getElementGridPosition(target);
        if (gridPos === void 0) return;
        const newElement = this.getElementByGridPosition(gridPos.row + rowDelta, gridPos.col + colDelta);
        if (newElement !== null) {
          newElement.focus();
          event.preventDefault();
        }
      });
    };
    registerMoveUpDown("move-up", -1, 0);
    registerMoveUpDown("move-down", 1, 0);
    registerMoveUpDown("move-left", 0, -1);
    registerMoveUpDown("move-right", 0, 1);
    const registerFocusout = (container, handler) => {
      container.addEventListener("focusout", (event) => {
        const relatedTarget = event.relatedTarget;
        if (relatedTarget instanceof Node && container.contains(relatedTarget)) {
          return;
        }
        handler(event);
      });
    };
    registerFocusout(coefficientContainer, () => {
      if (!this.updateModelTransform()) {
        this.updateViewTransformCoefficients();
      }
    });
    registerFocusout(outputNameContainer, () => {
      if (!this.updateModelOutputNames()) {
        this.updateViewOutputNames();
      }
    });
    registerFocusout(inputScaleContainer, () => {
      if (!this.updateModelInputScales()) {
        this.updateViewInputScales();
      }
    });
    registerFocusout(outputScaleContainer, () => {
      if (!this.updateModelOutputScales()) {
        this.updateViewOutputScales();
      }
    });
    registerActionListener(element, "cancel", (event) => {
      this.curTransform = void 0;
      this.updateView();
      event.target.blur();
    });
    registerActionListener(coefficientContainer, "commit", () => {
      this.updateModelTransform();
    });
    registerActionListener(outputNameContainer, "commit", () => {
      this.updateModelOutputNames();
    });
    registerActionListener(inputScaleContainer, "commit", () => {
      this.updateModelInputScales();
    });
    registerActionListener(outputScaleContainer, "commit", () => {
      this.updateModelOutputScales();
    });
    element.addEventListener("focusin", (event) => {
      const target = event.target;
      if (target instanceof HTMLInputElement) {
        target.select();
      }
    });
    this.updateView();
  }
  updateWillBeDeletedAttributes(dimensionWillBeDeleted) {
    const rank = this.transform.value.rank;
    if (dimensionWillBeDeleted === void 0) {
      dimensionWillBeDeleted = new Array(rank);
      dimensionWillBeDeleted.fill(false);
    }
    const coefficientElements = this.coefficientElements, inputBoundsElements = this.inputBoundsElements, inputScaleElements = this.inputScaleElements;
    for (let row = 0; row < rank; ++row) {
      const rowDeleted = dimensionWillBeDeleted[row];
      for (let col = 0; col <= rank; ++col) {
        const element = coefficientElements[rank * col + row];
        const colDeleted = col < rank && dimensionWillBeDeleted[col];
        element.dataset.willBeDeleted = (rowDeleted || colDeleted).toString();
      }
      inputScaleElements[row].dataset.willBeDeleted = rowDeleted.toString();
      var _inputBoundsElements$ = inputBoundsElements[row];
      const lower = _inputBoundsElements$.lower, upper = _inputBoundsElements$.upper;
      lower.dataset.willBeDeleted = rowDeleted.toString();
      upper.dataset.willBeDeleted = rowDeleted.toString();
    }
  }
  updateAddOutputDimensionCellStyle() {
    const addOutputDimensionInput = this.addOutputDimensionInput;
    this.addOutputDimensionCell.dataset.isActive = (addOutputDimensionInput.value.length !== 0 || document.activeElement === addOutputDimensionInput).toString();
  }
  updateOutputNameValidity() {
    const outputNameElements = this.outputNameElements;
    const names = outputNameElements.map((x) => x.value);
    var _transform = this.transform, _transform$value = _transform.value;
    const sourceRank = _transform$value.sourceRank, rank = _transform$value.rank, mutableSourceRank = _transform.mutableSourceRank;
    if (outputNameElements.length !== rank + 1) return;
    const isValid = getDimensionNameValidity(names);
    let dimensionWillBeDeleted = new Array(rank);
    dimensionWillBeDeleted.fill(false);
    for (let i = 0; i <= rank; ++i) {
      let valid = isValid[i];
      if (names[i].length === 0 && (mutableSourceRank || i >= sourceRank)) {
        valid = true;
        dimensionWillBeDeleted[i] = true;
      }
      outputNameElements[i].dataset.isValid = valid.toString();
    }
    this.updateWillBeDeletedAttributes(dimensionWillBeDeleted);
    this.updateAddOutputDimensionCellStyle();
  }
  updateScaleValidity(element) {
    const isValid = parseScale(element.value) !== void 0;
    element.dataset.isValid = isValid.toString();
  }
  updateCoefficientValidity(element) {
    const isValid = _Number$isFinite(Number(element.value));
    element.dataset.isValid = isValid.toString();
  }
  getElementGridPosition(element) {
    {
      const i = this.outputNameElements.indexOf(element);
      if (i !== -1) {
        return { row: i, col: -2 };
      }
    }
    {
      const i = this.inputScaleElements.indexOf(element);
      if (i !== -1) {
        return { row: -1, col: i };
      }
    }
    {
      const i = this.coefficientElements.indexOf(element);
      const rank = this.transform.value.rank;
      if (i !== -1) {
        return { row: i % rank, col: Math.floor(i / rank) };
      }
    }
    {
      const i = this.outputScaleElements.indexOf(element);
      if (i !== -1) {
        return { row: i, col: -1 };
      }
    }
    return void 0;
  }
  getElementByGridPosition(row, col) {
    const rank = this.transform.value.rank;
    if (row === -1) {
      if (col < 0 || col >= rank) return null;
      return this.inputScaleElements[col];
    }
    if (col === -2) {
      if (row < 0 || row > rank) return null;
      return this.outputNameElements[row];
    }
    if (col === -1) {
      if (row < 0 || row >= rank) return null;
      return this.outputScaleElements[row];
    }
    if (row < 0 || row >= rank || col < 0 || col > rank) return null;
    return this.coefficientElements[col * rank + row];
  }
  dimensionRefCount(name2) {
    const combiner = isLocalDimension(name2) ? this.localCombiner : this.globalCombiner;
    return combiner.dimensionRefCounts.get(name2) || 0;
  }
  updateModelInputScales() {
    return updateCoordinateSpaceScales(this.inputScaleElements, this.inputScaleModified, this.transform.inputSpace);
  }
  updateModelOutputScales() {
    return updateCoordinateSpaceScales(this.outputScaleElements, this.outputScaleModified, this.transform.outputSpace);
  }
  updateModelOutputNames() {
    const outputNames = this.outputNameElements.map((e) => e.value);
    var _transform2 = this.transform;
    const existingValue = _transform2.value, mutableSourceRank = _transform2.mutableSourceRank;
    const outputSpace = existingValue.outputSpace, rank = existingValue.rank, sourceRank = existingValue.sourceRank;
    if (outputNames.length !== rank + 1) return;
    const newToOldDimensionIndices = [];
    const newNames = [];
    const add2 = outputNames[rank].length !== 0;
    let newSourceRank = sourceRank;
    for (let i = 0; i <= rank; ++i) {
      const name2 = outputNames[i];
      if (name2.length === 0) {
        if (i < sourceRank) {
          if (!mutableSourceRank) return false;
          --newSourceRank;
        }
        continue;
      }
      newNames.push(name2);
      newToOldDimensionIndices.push(i);
    }
    if (!validateDimensionNames(newNames)) return false;
    const existingNames = outputSpace.names;
    if (!add2 && arraysEqual(existingNames, newNames)) {
      return true;
    }
    let newInputSpace = existingValue.inputSpace;
    let newOutputSpace = existingValue.outputSpace;
    let newTransform = existingValue.transform;
    if (add2) {
      if (this.addingSourceDimension) ++newSourceRank;
      const newName = outputNames[rank];
      const space = (isLocalDimension(newName) ? this.localCombiner : this.globalCombiner).combined.value;
      const existingIndex = space.names.indexOf(newName);
      let unit;
      let scale2;
      if (existingIndex !== -1) {
        unit = space.units[existingIndex];
        scale2 = space.scales[existingIndex];
      } else {
        unit = "";
        scale2 = 1;
      }
      const boundingBoxes = newInputSpace.boundingBoxes.map((boundingBox) => extendTransformedBoundingBoxUpToRank(boundingBox, rank, rank + 1));
      if (!this.addingSourceDimension) {
        boundingBoxes.push(makeSingletonDimTransformedBoundingBox(rank + 1, rank));
      }
      newInputSpace = makeCoordinateSpace({
        valid: newInputSpace.valid,
        rank: rank + 1,
        names: [...newInputSpace.names, ""],
        ids: [...newInputSpace.ids, newDimensionId()],
        timestamps: [...newInputSpace.timestamps, Date.now()],
        scales: Float64Array.from([...newInputSpace.scales, scale2]),
        units: [...newInputSpace.units, unit],
        boundingBoxes,
        coordinateArrays: [...newInputSpace.coordinateArrays, void 0]
      });
      newOutputSpace = makeCoordinateSpace({
        valid: outputSpace.valid,
        rank: rank + 1,
        names: [...outputSpace.names, newName],
        ids: [...outputSpace.ids, newDimensionId()],
        timestamps: [...outputSpace.timestamps, Date.now()],
        scales: Float64Array.from([...outputSpace.scales, scale2]),
        units: [...outputSpace.units, unit],
        coordinateArrays: [...outputSpace.coordinateArrays, void 0]
      });
      newTransform = extendHomogeneousTransform(new Float64Array((rank + 2) ** 2), rank + 1, newTransform, rank);
    }
    newTransform = homogeneousTransformSubmatrix(Float64Array, newTransform, newInputSpace.rank, newToOldDimensionIndices, newToOldDimensionIndices);
    newInputSpace = permuteCoordinateSpace(newInputSpace, newToOldDimensionIndices);
    newOutputSpace = permuteCoordinateSpace(newOutputSpace, newToOldDimensionIndices);
    const ids = newOutputSpace.ids.map((id, i) => {
      const oldIndex = newToOldDimensionIndices[i];
      if (oldIndex === rank) return id;
      const newName = newNames[i];
      const existingName = existingNames[oldIndex];
      return newName === existingName || this.dimensionRefCount(existingName) === 1 && this.dimensionRefCount(newName) === (existingNames.includes(newName) ? 1 : 0) ? id : newDimensionId();
    });
    const timestamps = newOutputSpace.timestamps.map((t, i) => {
      const oldIndex = newToOldDimensionIndices[i];
      return oldIndex === rank || newNames[i] === existingNames[oldIndex] ? t : Date.now();
    });
    newOutputSpace = _Object$assign(_Object$assign({}, newOutputSpace), {
      names: newNames,
      ids,
      timestamps
    });
    let newValue = {
      rank: newOutputSpace.rank,
      sourceRank: newSourceRank,
      outputSpace: newOutputSpace,
      inputSpace: newInputSpace,
      transform: newTransform
    };
    this.transform.value = newValue;
    return true;
  }
  updateModelTransform() {
    const coefficientElements = this.coefficientElements;
    const rank = this.transform.value.rank;
    const newTransform = new Float64Array((rank + 1) ** 2);
    newTransform[newTransform.length - 1] = 1;
    for (let row = 0; row < rank; ++row) {
      for (let col = 0; col <= rank; ++col) {
        const e = coefficientElements[col * rank + row];
        const v = parseFloat(e.value);
        if (!_Number$isFinite(v)) {
          return false;
        }
        newTransform[col * (rank + 1) + row] = v;
      }
    }
    this.transform.transform = newTransform;
    return true;
  }
  updateViewOutputNames() {
    var _transform$value2 = this.transform.value;
    const outputSpace = _transform$value2.outputSpace, rank = _transform$value2.rank;
    if (rank !== this.curRank) return;
    const outputNameElements = this.outputNameElements;
    const outputNames = outputSpace.names;
    for (let outputDim = 0; outputDim < rank; ++outputDim) {
      const outputNameElement = outputNameElements[outputDim];
      outputNameElement.value = outputNames[outputDim];
      outputNameElement.dataset.isValid = "true";
      updateInputFieldWidth(outputNameElement);
    }
    outputNameElements[rank].value = "";
    this.updateWillBeDeletedAttributes();
  }
  updateViewTransformCoefficients() {
    var _transform$value3 = this.transform.value;
    const transform = _transform$value3.transform, rank = _transform$value3.rank;
    const coefficientElements = this.coefficientElements;
    for (let outputDim = 0; outputDim < rank; ++outputDim) {
      for (let inputDim = 0; inputDim <= rank; ++inputDim) {
        const coeffElement = coefficientElements[inputDim * rank + outputDim];
        coeffElement.value = transform[inputDim * (rank + 1) + outputDim].toString();
        coeffElement.dataset.isValid = "true";
        updateInputFieldWidth(coeffElement);
      }
    }
  }
  ensureViewRankUpdated() {
    const transform = this.transform.value;
    const rank = transform.rank;
    const sourceRank = transform.sourceRank;
    if (this.curSourceRank === sourceRank && this.curRank === rank) {
      return;
    }
    const inputBoundsElements = this.inputBoundsElements, inputNameElements = this.inputNameElements, inputScaleElements = this.inputScaleElements;
    const element = this.element, coefficientElements = this.coefficientElements, outputNameElements = this.outputNameElements, outputScaleElements = this.outputScaleElements, outputScaleSuggestionElements = this.outputScaleSuggestionElements, inputScaleSuggestionElements = this.inputScaleSuggestionElements, outputBoundsElements = this.outputBoundsElements, coefficientContainer = this.coefficientContainer, translationContainer = this.translationContainer, outputNameContainer = this.outputNameContainer, inputNameContainer = this.inputNameContainer, inputScaleContainer = this.inputScaleContainer, inputLowerBoundsContainer = this.inputLowerBoundsContainer, inputUpperBoundsContainer = this.inputUpperBoundsContainer, outputScaleContainer = this.outputScaleContainer;
    element.style.gridTemplateColumns = `[outputLabel headerStart] min-content [outputNames] 1fr [outputScales] 1fr [headerEnd] repeat(${Math.max(1, rank) + 1}, [sourceDim] 1fr)`;
    element.style.gridTemplateRows = `[sourceLabel headerStart] auto [sourceNames] auto [sourceLower] auto [sourceUpper] auto [sourceScales] auto [headerEnd]repeat(${rank + 1}, [outputDim] auto)`;
    removeChildren(coefficientContainer);
    removeChildren(translationContainer);
    coefficientContainer.appendChild(translationContainer);
    removeChildren(outputNameContainer);
    removeChildren(inputNameContainer);
    removeChildren(inputScaleContainer);
    removeChildren(inputLowerBoundsContainer);
    removeChildren(inputUpperBoundsContainer);
    removeChildren(outputScaleContainer);
    inputNameElements.length = 0;
    inputScaleElements.length = 0;
    inputBoundsElements.length = 0;
    outputScaleElements.length = 0;
    outputScaleSuggestionElements.length = 0;
    inputScaleSuggestionElements.length = 0;
    coefficientElements.length = 0;
    outputNameElements.length = 0;
    outputBoundsElements.length = 0;
    for (let inputDim = 0; inputDim < rank; ++inputDim) {
      const addClasses = (element2) => {
        element2.classList.add("neuroglancer-coordinate-space-transform-input");
        if (inputDim >= sourceRank) {
          element2.classList.add(singletonClassName);
        }
      };
      {
        const cellElement = document.createElement("div");
        cellElement.classList.add("neuroglancer-coordinate-space-transform-input-name");
        addClasses(cellElement);
        cellElement.style.gridRowStart = "sourceNames";
        cellElement.style.gridColumnStart = `sourceDim ${inputDim + 1}`;
        inputNameContainer.appendChild(cellElement);
        inputNameElements.push(cellElement);
      }
      {
        var _makeScaleElement = makeScaleElement();
        const cellElement = _makeScaleElement.cellElement, inputElement = _makeScaleElement.inputElement, suggestionElement = _makeScaleElement.suggestionElement;
        cellElement.classList.add("neuroglancer-coordinate-space-transform-input-scale-container");
        addClasses(cellElement);
        cellElement.style.gridRowStart = `sourceScales`;
        cellElement.style.gridColumnStart = `sourceDim ${inputDim + 1}`;
        inputScaleContainer.appendChild(cellElement);
        inputScaleElements.push(inputElement);
        inputScaleSuggestionElements.push(suggestionElement);
        const dim = inputDim;
        suggestionElement.addEventListener("click", () => {
          const suggested = getDefaultInputScale(this.transform, dim);
          if (suggested === void 0) return;
          this.transform.inputSpace.value = updateCoordinateSpaceSingleDimensionScale(this.transform.inputSpace.value, dim, suggested.scale, suggested.unit);
        });
      }
      {
        const lower = document.createElement("div");
        addClasses(lower);
        lower.classList.add("neuroglancer-coordinate-space-transform-input-bounds");
        lower.style.gridRowStart = `sourceLower`;
        lower.style.gridColumnStart = `sourceDim ${inputDim + 1}`;
        inputLowerBoundsContainer.appendChild(lower);
        const upper = document.createElement("div");
        addClasses(upper);
        upper.classList.add("neuroglancer-coordinate-space-transform-input-bounds");
        upper.style.gridRowStart = `sourceUpper`;
        upper.style.gridColumnStart = `sourceDim ${inputDim + 1}`;
        inputUpperBoundsContainer.appendChild(upper);
        inputBoundsElements.push({ lower, upper });
      }
    }
    for (let outputDim = 0; outputDim < rank; ++outputDim) {
      for (let inputDim = 0; inputDim <= rank; ++inputDim) {
        const cellElement = document.createElement("input");
        cellElement.classList.add("neuroglancer-coordinate-space-transform-coeff");
        cellElement.spellcheck = false;
        cellElement.autocomplete = "off";
        cellElement.size = 1;
        cellElement.style.gridRowStart = `outputDim ${outputDim + 1}`;
        cellElement.placeholder = " ";
        cellElement.style.gridColumnStart = `sourceDim ${inputDim + 1}`;
        coefficientElements[inputDim * rank + outputDim] = cellElement;
        if (inputDim === rank) {
          cellElement.classList.add("neuroglancer-coordinate-space-transform-translation-coeff");
        } else if (inputDim == sourceRank) {
          cellElement.classList.add(singletonClassName);
        }
        (inputDim === rank ? translationContainer : coefficientContainer).appendChild(cellElement);
      }
      {
        var _makeScaleElement2 = makeScaleElement();
        const cellElement = _makeScaleElement2.cellElement, suggestionElement = _makeScaleElement2.suggestionElement, inputElement = _makeScaleElement2.inputElement;
        cellElement.classList.add("neuroglancer-coordinate-space-transform-output-scale-container");
        cellElement.style.gridRowStart = `outputDim ${outputDim + 1}`;
        cellElement.style.gridColumnStart = `outputScales`;
        const dim = outputDim;
        suggestionElement.addEventListener("click", () => {
          const transform2 = this.transform.value;
          const suggested = getInferredOutputScale(transform2, dim);
          if (suggested === void 0) return;
          this.transform.outputSpace.value = updateCoordinateSpaceSingleDimensionScale(transform2.outputSpace, dim, suggested.scale, suggested.unit);
        });
        outputScaleSuggestionElements.push(suggestionElement);
        outputScaleContainer.appendChild(cellElement);
        outputScaleElements.push(inputElement);
      }
      {
        const cellElement = document.createElement("div");
        cellElement.classList.add("neuroglancer-coordinate-space-transform-output-name-container");
        cellElement.style.gridRowStart = `outputDim ${outputDim + 1}`;
        cellElement.style.gridColumnStart = `outputNames`;
        const nameInput = makeOutputNameElement();
        nameInput.title = "Rebind to a different dimension";
        if (outputDim >= sourceRank) {
          nameInput.title += `, or delete to remove singleton dimension`;
        } else if (this.transform.mutableSourceRank) {
          nameInput.title += `, or delete to remove source dimension`;
        }
        nameInput.title += `.  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).`;
        outputNameElements.push(nameInput);
        outputNameContainer.appendChild(cellElement);
        cellElement.appendChild(nameInput);
        const lower = document.createElement("div");
        lower.classList.add("neuroglancer-coordinate-space-transform-output-bounds");
        cellElement.appendChild(lower);
        const upper = document.createElement("div");
        upper.classList.add("neuroglancer-coordinate-space-transform-output-bounds");
        cellElement.appendChild(upper);
        outputBoundsElements.push({ lower, upper });
        cellElement.addEventListener("mousedown", (event) => {
          if (event.target === nameInput) return;
          nameInput.focus();
          event.preventDefault();
        });
      }
    }
    outputNameElements.push(this.addOutputDimensionInput);
    this.addOutputDimensionInput.value = "";
    outputNameContainer.appendChild(this.addOutputDimensionCell);
    this.curSourceRank = sourceRank;
    this.curRank = rank;
  }
  updateViewInputScales() {
    this.ensureViewRankUpdated();
    this.inputScaleModified.length = 0;
    var _transform$value4 = this.transform.value;
    const inputSpace = _transform$value4.inputSpace, rank = _transform$value4.rank, sourceRank = _transform$value4.sourceRank;
    const inputBoundsElements = this.inputBoundsElements, inputNameElements = this.inputNameElements, inputScaleElements = this.inputScaleElements, inputScaleSuggestionElements = this.inputScaleSuggestionElements;
    const inputNames = inputSpace.names, inputScales = inputSpace.scales, inputUnits = inputSpace.units;
    var _inputSpace$bounds = inputSpace.bounds;
    const inputLowerBounds = _inputSpace$bounds.lowerBounds, inputUpperBounds = _inputSpace$bounds.upperBounds;
    for (let inputDim = 0; inputDim < rank; ++inputDim) {
      const inputScaleElement = inputScaleElements[inputDim];
      const scale2 = inputScales[inputDim];
      const unit = inputUnits[inputDim];
      inputScaleElement.value = formatScaleWithUnitAsString(scale2, unit, { elide1: false });
      inputScaleElement.dataset.isValid = "true";
      updateInputFieldWidth(inputScaleElement);
      let dimensionNameString;
      if (inputDim < sourceRank) {
        let name2 = inputNames[inputDim];
        if (!name2) name2 = `${inputDim}`;
        inputNameElements[inputDim].textContent = name2;
        dimensionNameString = `source dimension ${name2}`;
        inputScaleElement.title = `Override scale of ${dimensionNameString}`;
      } else {
        dimensionNameString = `singleton dimension`;
        inputScaleElement.title = `Set extent of ${dimensionNameString}`;
      }
      var _formatBounds = formatBounds(inputLowerBounds[inputDim], inputUpperBounds[inputDim]);
      const lower = _formatBounds.lower, upper = _formatBounds.upper;
      const elements = inputBoundsElements[inputDim];
      elements.lower.textContent = lower;
      elements.lower.title = `Lower bound of ${dimensionNameString}`;
      elements.upper.title = `Upper bound of ${dimensionNameString}`;
      elements.upper.textContent = upper;
      updateScaleSuggestionElement(inputScaleSuggestionElements[inputDim], getDefaultInputScale(this.transform, inputDim), scale2, unit, `Revert scale of ${dimensionNameString} to `);
    }
  }
  updateViewOutputScales() {
    const transform = this.transform.value;
    var _transform$outputSpac = transform.outputSpace;
    const rank = _transform$outputSpac.rank, names = _transform$outputSpac.names, outputUnits = _transform$outputSpac.units, outputScales = _transform$outputSpac.scales;
    var _transform$outputSpac2 = _transform$outputSpac.bounds;
    const outputLowerBounds = _transform$outputSpac2.lowerBounds, outputUpperBounds = _transform$outputSpac2.upperBounds;
    const outputScaleElements = this.outputScaleElements, outputBoundsElements = this.outputBoundsElements, outputScaleSuggestionElements = this.outputScaleSuggestionElements;
    for (let outputDim = 0; outputDim < rank; ++outputDim) {
      const scaleElement = outputScaleElements[outputDim];
      const scale2 = outputScales[outputDim];
      const unit = outputUnits[outputDim];
      scaleElement.value = formatScaleWithUnitAsString(scale2, unit, { elide1: false });
      updateInputFieldWidth(scaleElement);
      const name2 = names[outputDim];
      scaleElement.dataset.isValid = "true";
      const titlePrefix = `Change coordinates of ${isLocalDimension(name2) ? "local" : "global"} dimension ${name2}`;
      scaleElement.title = `${titlePrefix} (does not rescale the source)`;
      var _formatBounds2 = formatBounds(outputLowerBounds[outputDim], outputUpperBounds[outputDim]);
      const lower = _formatBounds2.lower, upper = _formatBounds2.upper;
      const elements = outputBoundsElements[outputDim];
      elements.lower.textContent = lower;
      elements.upper.textContent = upper;
      updateScaleSuggestionElement(outputScaleSuggestionElements[outputDim], getInferredOutputScale(transform, outputDim), scale2, unit, `${titlePrefix} to inferred scale of `);
    }
  }
  updateResetButtonVisibility(coefficientsModified = false, dimensionsModified = false) {
    var _transform3 = this.transform;
    const transform = _transform3.value, mutableSourceRank = _transform3.mutableSourceRank, defaultTransform = _transform3.defaultTransform;
    const rank = transform.rank;
    this.resetToIdentityButton.style.visibility = coefficientsModified || !isIdentity(transform.transform, rank + 1, rank + 1) ? "visible" : "hidden";
    this.resetToDefaultButton.style.visibility = !mutableSourceRank && (coefficientsModified || dimensionsModified || !coordinateSpaceTransformsEquivalent(defaultTransform, transform)) ? "visible" : "hidden";
  }
  updateView() {
    const transform = this.transform.value;
    if (this.curTransform === transform) return;
    this.curTransform = transform;
    this.ensureViewRankUpdated();
    this.updateViewInputScales();
    this.updateViewOutputNames();
    this.updateViewTransformCoefficients();
    this.updateViewOutputScales();
    this.updateAddOutputDimensionCellStyle();
    this.updateResetButtonVisibility();
  }
  disposed() {
    removeFromParent(this.element);
    super.disposed();
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function positionDropdown(dropdownElement, associatedElement, { horizontal = false, vertical = true, topMargin = 6, bottomMargin = 6, leftMargin = 6, rightMargin = 6, maxHeight = true, maxWidth = true } = {}) {
  const rect = associatedElement.getBoundingClientRect();
  if (horizontal) {
    const viewportWidth = dropdownElement.ownerDocument.documentElement.clientWidth;
    let distanceLeft = rect.right;
    let distanceRight = viewportWidth - rect.left;
    if (distanceLeft > distanceRight) {
      dropdownElement.style.left = "";
      dropdownElement.style.right = `${viewportWidth - rect.right}px`;
      if (maxWidth) {
        dropdownElement.style.maxWidth = distanceLeft - leftMargin + "px";
      }
    } else {
      dropdownElement.style.right = "";
      dropdownElement.style.left = `${rect.left}px`;
      if (maxWidth) {
        dropdownElement.style.maxWidth = distanceRight - rightMargin + "px";
      }
    }
  }
  if (vertical) {
    const viewportHeight = dropdownElement.ownerDocument.documentElement.clientHeight;
    let distanceToTop = rect.top - topMargin;
    let distanceToBottom = viewportHeight - rect.bottom - bottomMargin;
    dropdownElement.style.left = `${rect.left}px`;
    dropdownElement.style.width = `${rect.width}px`;
    if (distanceToTop > distanceToBottom * 3) {
      dropdownElement.style.top = "";
      dropdownElement.style.bottom = `${viewportHeight - rect.top}px`;
      if (maxHeight) {
        dropdownElement.style.maxHeight = distanceToTop + "px";
      }
    } else {
      dropdownElement.style.top = `${rect.bottom}px`;
      dropdownElement.style.bottom = "";
      if (maxHeight) {
        dropdownElement.style.maxHeight = distanceToBottom + "px";
      }
    }
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function longestCommonPrefix(strings) {
  let it = _getIterator(strings);
  var _it$next = it.next();
  let firstValue = _it$next.value, noValues = _it$next.done;
  if (noValues) {
    return "";
  }
  let commonPrefixLength = firstValue.length;
  while (commonPrefixLength > 0) {
    var _it$next2 = it.next();
    let value = _it$next2.value, done = _it$next2.done;
    if (done) {
      break;
    }
    let i = 0;
    for (; i < commonPrefixLength; ++i) {
      if (firstValue.charCodeAt(i) !== value.charCodeAt(i)) {
        break;
      }
    }
    commonPrefixLength = i;
  }
  return firstValue.substring(0, commonPrefixLength);
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const defaultNumItemsToRender = 10;
const overRenderFraction = 0.5;
class VirtualListState {
  constructor() {
    this.anchorIndex = 0;
    this.anchorClientOffset = 0;
  }
  splice(splices) {
    let anchorIndex = this.anchorIndex;
    let offset = 0;
    for (const splice of splices) {
      offset += splice.retainCount;
      if (anchorIndex < offset) break;
      const deleteCount = splice.deleteCount;
      if (anchorIndex < offset + deleteCount) {
        anchorIndex = offset;
        break;
      }
      const insertCount = splice.insertCount;
      anchorIndex = anchorIndex - deleteCount + insertCount;
      offset += insertCount - insertCount;
    }
    this.anchorIndex = anchorIndex;
  }
}
class RenderParameters {
  constructor() {
    this.startIndex = 0;
    this.endIndex = 0;
    this.anchorIndex = 0;
    this.anchorOffset = 0;
    this.scrollOffset = 0;
  }
}
class SizeEstimates {
  constructor() {
    this.itemSize = [];
    this.totalKnownSize = 0;
    this.numItemsInTotalKnownSize = 0;
  }
  get averageSize() {
    return this.totalKnownSize / this.numItemsInTotalKnownSize;
  }
  getEstimatedSize(index2) {
    var _a;
    return (_a = this.itemSize[index2]) !== null && _a !== void 0 ? _a : this.averageSize;
  }
  getEstimatedTotalSize() {
    return this.totalKnownSize / this.numItemsInTotalKnownSize * this.itemSize.length;
  }
  getEstimatedOffset(index2, hintIndex = 0, hintOffset = 0) {
    for (; hintIndex < index2; ++hintIndex) {
      hintOffset += this.getEstimatedSize(hintIndex);
    }
    for (; hintIndex > index2; --hintIndex) {
      hintOffset -= this.getEstimatedSize(hintIndex - 1);
    }
    return hintOffset;
  }
  getRangeSize(begin, end) {
    var _a;
    let size = 0;
    const itemSize = this.itemSize, averageSize = this.averageSize;
    for (let i = begin; i < end; ++i) {
      size += (_a = itemSize[i]) !== null && _a !== void 0 ? _a : averageSize;
    }
    return size;
  }
  splice(splices) {
    let itemSize = this.itemSize;
    itemSize = this.itemSize = spliceArray(itemSize, splices);
    this.totalKnownSize = itemSize.reduce((a, b) => a + b, 0);
    this.numItemsInTotalKnownSize = itemSize.reduce((a) => a + 1, 0);
  }
}
function updateRenderParameters(newParams, prevParams, numItems, viewportHeight, sizes, state) {
  let anchorIndex = state.anchorIndex, anchorClientOffset = state.anchorClientOffset;
  let anchorOffset = sizes.getEstimatedOffset(anchorIndex);
  let renderStartIndex;
  let renderEndIndex;
  let renderAnchorOffset;
  let renderScrollOffset;
  let renderAnchorIndex;
  if (viewportHeight === 0 || sizes.totalKnownSize === 0) {
    renderStartIndex = Math.max(0, anchorIndex - defaultNumItemsToRender / 2);
    renderEndIndex = Math.min(numItems, renderStartIndex + defaultNumItemsToRender);
    renderAnchorIndex = anchorIndex;
    renderAnchorOffset = 0;
    renderScrollOffset = anchorClientOffset;
  } else {
    const totalSize = sizes.getEstimatedTotalSize();
    const maxScrollOffset = Math.max(0, totalSize - viewportHeight);
    renderScrollOffset = anchorOffset - anchorClientOffset;
    renderScrollOffset = Math.max(0, Math.min(maxScrollOffset, renderScrollOffset));
    const minStartOffset = renderScrollOffset - 2 * overRenderFraction * viewportHeight;
    const maxStartOffset = renderScrollOffset - overRenderFraction * viewportHeight;
    const minEndOffset = renderScrollOffset + viewportHeight + overRenderFraction * viewportHeight;
    const maxEndOffset = anchorOffset - anchorClientOffset + viewportHeight + 2 * overRenderFraction * viewportHeight;
    renderStartIndex = Math.min(numItems, prevParams.startIndex);
    let renderStartOffset = sizes.getEstimatedOffset(renderStartIndex, anchorIndex, anchorOffset);
    if (renderStartOffset < minStartOffset) {
      for (; renderStartIndex + 1 < numItems; ++renderStartIndex) {
        const itemSize = sizes.getEstimatedSize(renderStartIndex);
        if (renderStartOffset + itemSize >= maxStartOffset) break;
        renderStartOffset += itemSize;
      }
    }
    if (renderStartOffset >= maxStartOffset) {
      for (; renderStartOffset > minStartOffset && renderStartIndex > 0; --renderStartIndex) {
        const itemSize = sizes.getEstimatedSize(renderStartIndex - 1);
        renderStartOffset -= itemSize;
      }
    }
    renderEndIndex = Math.min(numItems, prevParams.endIndex);
    let renderEndOffset = sizes.getEstimatedOffset(renderEndIndex, anchorIndex, anchorOffset);
    if (renderEndOffset < minEndOffset) {
      for (; renderEndOffset <= maxEndOffset && renderEndIndex + 1 <= numItems; ++renderEndIndex) {
        const itemSize = sizes.getEstimatedSize(renderEndIndex);
        renderEndOffset += itemSize;
      }
    } else if (renderEndOffset >= maxEndOffset) {
      for (; renderEndIndex > renderStartIndex; --renderEndIndex) {
        const itemSize = sizes.getEstimatedSize(renderEndIndex - 1);
        if (renderEndOffset - itemSize < minEndOffset) break;
        renderEndOffset -= itemSize;
      }
    }
    renderAnchorIndex = anchorIndex;
    renderAnchorOffset = anchorOffset;
    for (; renderAnchorIndex < renderStartIndex; ++renderAnchorIndex) {
      const itemSize = sizes.getEstimatedSize(renderAnchorIndex);
      renderAnchorOffset += itemSize;
    }
    for (; renderAnchorIndex > renderEndIndex; --renderAnchorIndex) {
      const itemSize = sizes.getEstimatedSize(renderAnchorIndex - 1);
      renderAnchorOffset -= itemSize;
    }
  }
  newParams.startIndex = renderStartIndex;
  newParams.endIndex = renderEndIndex;
  newParams.anchorIndex = renderAnchorIndex;
  newParams.anchorOffset = renderAnchorOffset;
  newParams.scrollOffset = renderScrollOffset;
}
function normalizeRenderParams(p, sizes) {
  const anchorOffset = sizes.getEstimatedOffset(p.anchorIndex);
  const oldAnchorOffset = p.anchorOffset;
  p.anchorOffset = anchorOffset;
  p.scrollOffset += anchorOffset - oldAnchorOffset;
}
function rerenderNeeded(newParams, prevParams) {
  return newParams.startIndex < prevParams.startIndex || newParams.endIndex > prevParams.endIndex;
}
class VirtualList extends RefCounted {
  constructor(options) {
    super();
    this.element = document.createElement("div");
    this.scrollContent = document.createElement("div");
    this.header = document.createElement("div");
    this.body = document.createElement("div");
    this.topItems = document.createElement("div");
    this.bottomItems = document.createElement("div");
    this.renderedItems = [];
    this.renderGeneration = -1;
    this.listGeneration = -1;
    this.newRenderedItems = [];
    this.state = new VirtualListState();
    this.renderParams = new RenderParameters();
    this.newRenderParams = new RenderParameters();
    this.sizes = new SizeEstimates();
    this.debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateView()));
    this.resizeObserver = new ResizeObserver(() => this.updateView());
    const selectedIndex = options.selectedIndex;
    if (selectedIndex !== void 0) {
      this.state.anchorIndex = selectedIndex;
      this.state.anchorClientOffset = 0;
    }
    const source = this.source = options.source;
    this.sizes.itemSize.length = source.length;
    const element = this.element, header = this.header, body = this.body, scrollContent = this.scrollContent, topItems = this.topItems, bottomItems = this.bottomItems;
    this.resizeObserver.observe(element);
    this.registerDisposer(() => this.resizeObserver.disconnect());
    element.appendChild(scrollContent);
    element.style.overflowAnchor = "none";
    scrollContent.appendChild(header);
    scrollContent.appendChild(body);
    header.style.position = "sticky";
    header.style.zIndex = "1";
    header.style.top = "0";
    if (options.horizontalScroll) {
      scrollContent.style.width = "min-content";
      scrollContent.style.minWidth = "100%";
      header.style.width = "min-content";
      header.style.minWidth = "100%";
      bottomItems.style.width = "min-content";
      bottomItems.style.minWidth = "100%";
    } else {
      scrollContent.style.width = "100%";
      header.style.width = "100%";
      bottomItems.style.width = "100%";
    }
    body.appendChild(topItems);
    body.appendChild(bottomItems);
    topItems.style.width = "min-content";
    topItems.style.position = "relative";
    topItems.style.height = "0";
    topItems.style.minWidth = "100%";
    bottomItems.style.height = "0";
    bottomItems.style.position = "relative";
    element.addEventListener("scroll", () => {
      const scrollOffset = element.scrollTop;
      this.state.anchorClientOffset = this.renderParams.anchorOffset - scrollOffset;
      this.renderParams.scrollOffset = scrollOffset;
      this.debouncedUpdateView();
    });
    if (source.changed !== void 0) {
      this.registerDisposer(source.changed.add((splices) => {
        this.sizes.splice(splices);
        this.state.splice(splices);
        this.renderedItems.length = 0;
        this.debouncedUpdateView();
      }));
    }
    if (source.renderChanged !== void 0) {
      this.registerDisposer(source.renderChanged.add(this.debouncedUpdateView));
    }
  }
  updateView() {
    const element = this.element;
    if (element.offsetHeight === 0) {
      return;
    }
    const viewportHeight = element.clientHeight - this.header.offsetHeight;
    const source = this.source, state = this.state, sizes = this.sizes;
    const numItems = source.length;
    const body = this.body, topItems = this.topItems, bottomItems = this.bottomItems;
    const changed = source.changed, renderChanged = source.renderChanged;
    let renderParams;
    while (true) {
      renderParams = this.newRenderParams;
      const prevRenderParams = this.renderParams;
      updateRenderParameters(renderParams, prevRenderParams, numItems, viewportHeight, sizes, state);
      let forceRender;
      if (renderChanged !== void 0 && renderChanged.count !== this.renderGeneration || changed !== void 0 && changed.count !== this.listGeneration) {
        this.renderGeneration = renderChanged === void 0 ? -1 : renderChanged.count;
        this.listGeneration = changed === void 0 ? -1 : changed.count;
        forceRender = true;
        this.renderedItems.length = 0;
      } else {
        forceRender = false;
      }
      if (!forceRender && !rerenderNeeded(renderParams, prevRenderParams)) {
        prevRenderParams.scrollOffset = renderParams.scrollOffset;
        renderParams = prevRenderParams;
        break;
      }
      this.renderParams = renderParams;
      this.newRenderParams = prevRenderParams;
      const prevRenderedItems = this.renderedItems;
      const renderedItems = this.newRenderedItems;
      renderedItems.length = 0;
      this.renderedItems = renderedItems;
      this.newRenderedItems = prevRenderedItems;
      const source2 = this.source;
      const render = source2.render;
      var _renderParams = renderParams;
      const curStartIndex = _renderParams.startIndex, curEndIndex = _renderParams.endIndex, anchorIndex = _renderParams.anchorIndex;
      function* getChildren(start, end) {
        for (let i = start; i < end; ++i) {
          let item = prevRenderedItems[i];
          if (item === void 0) {
            item = render.call(source2, i);
          }
          renderedItems[i] = item;
          yield item;
        }
      }
      updateChildren(topItems, getChildren(curStartIndex, anchorIndex));
      updateChildren(bottomItems, getChildren(anchorIndex, curEndIndex));
      for (let i = curStartIndex; i < curEndIndex; ++i) {
        const element2 = renderedItems[i];
        const bounds = element2.getBoundingClientRect();
        const newSize = bounds.height;
        const existingSize = sizes.itemSize[i];
        if (existingSize !== void 0) {
          sizes.totalKnownSize -= existingSize;
          --sizes.numItemsInTotalKnownSize;
        }
        sizes.itemSize[i] = newSize;
        sizes.totalKnownSize += newSize;
        ++sizes.numItemsInTotalKnownSize;
      }
    }
    normalizeRenderParams(renderParams, sizes);
    state.anchorIndex = renderParams.anchorIndex;
    state.anchorClientOffset = renderParams.anchorOffset - renderParams.scrollOffset;
    const topSize = sizes.getRangeSize(renderParams.startIndex, renderParams.anchorIndex);
    const totalHeight = sizes.getEstimatedTotalSize();
    body.style.height = `${totalHeight}px`;
    topItems.style.top = `${renderParams.anchorOffset - topSize}px`;
    bottomItems.style.top = `${renderParams.anchorOffset}px`;
    element.scrollTop = renderParams.scrollOffset;
  }
  getItemElement(index2) {
    return this.renderedItems[index2];
  }
  forEachRenderedItem(callback) {
    var _renderParams2 = this.renderParams;
    const startIndex = _renderParams2.startIndex, endIndex = _renderParams2.endIndex;
    const renderedItems = this.renderedItems;
    for (let i = startIndex; i < endIndex; ++i) {
      const item = renderedItems[i];
      if (item === void 0) continue;
      callback(item, i);
    }
  }
  scrollToTop() {
    this.state.anchorIndex = 0;
    this.state.anchorClientOffset = 0;
    this.debouncedUpdateView();
  }
  scrollItemIntoView(index2) {
    const itemStartOffset = this.sizes.getEstimatedOffset(index2);
    const itemEndOffset = itemStartOffset + this.sizes.getEstimatedSize(index2);
    const startOffset = this.element.scrollTop;
    if (itemStartOffset < startOffset) {
      this.state.anchorIndex = index2;
      this.state.anchorClientOffset = 0;
    } else if (itemStartOffset > startOffset && itemEndOffset > startOffset + this.element.offsetHeight) {
      this.state.anchorIndex = index2 + 1;
      this.state.anchorClientOffset = this.element.offsetHeight;
    } else {
      return;
    }
    this.debouncedUpdateView();
  }
  disposed() {
    removeFromParent(this.element);
  }
}
const ACTIVE_COMPLETION_CLASS_NAME = "neuroglancer-multiline-autocomplete-completion-active";
function makeDefaultCompletionElement(completion) {
  let element = document.createElement("div");
  element.textContent = completion.value;
  return element;
}
function* splitByWordBreaks(value) {
  while (value.length > 0) {
    const m = value.match(/[:/_]+/);
    if (m === null) {
      yield value;
      return;
    }
    const endOffset = m.index + m[0].length;
    yield value.substring(0, endOffset);
    value = value.substring(endOffset);
  }
}
function makeCompletionElementWithDescription(completion) {
  let element = document.createElement("div");
  element.className = "neuroglancer-multiline-autocomplete-completion-with-description";
  element.textContent = completion.value;
  let descriptionElement = document.createElement("div");
  descriptionElement.className = "neuroglancer-multiline-autocomplete-completion-description";
  descriptionElement.textContent = completion.description || "";
  element.appendChild(descriptionElement);
  return element;
}
const keyMap$1 = EventActionMap.fromObject({
  "arrowdown": { action: "cycle-next-active-completion" },
  "arrowup": { action: "cycle-prev-active-completion" },
  "home": { action: "home" },
  "end": { action: "end" },
  "tab": { action: "choose-active-completion-or-prefix", preventDefault: false },
  "enter": { action: "commit" },
  "escape": { action: "cancel", preventDefault: false, stopPropagation: false }
});
const DEFAULT_COMPLETION_DELAY = 200;
class AutocompleteTextInput extends RefCounted {
  constructor(options) {
    super();
    this.element = document.createElement("div");
    this.inputElement = document.createElement("span");
    this.hintElement = document.createElement("span");
    this.completionsVirtualList = void 0;
    this.onCommit = new Signal();
    this.onInput = new Signal();
    this.prevInputValue = "";
    this.completionsVisible = false;
    this.activeCompletionPromise = null;
    this.activeCompletionCancellationToken = void 0;
    this.hasFocus = false;
    this.completionResult = null;
    this.dropdownContentsStale = true;
    this.hasResultForDropdown = false;
    this.commonPrefix = "";
    this.completionDisabled = -1;
    this.activeIndex = -1;
    this.dropdownStyleStale = true;
    this.resizeHandler = () => {
      if (!this.completionsVisible) return;
      this.updateDropdownStyle();
    };
    this.resizeObserver = new ResizeObserver(this.resizeHandler);
    this.debouncedUpdateHintState = this.registerCancellable(debounce(() => this.updateHintState(), 0));
    this.completer = options.completer;
    var _options$delay = options.delay;
    const delay = _options$delay === void 0 ? DEFAULT_COMPLETION_DELAY : _options$delay;
    let debouncedCompleter = this.scheduleUpdateCompletions = debounce(() => {
      const cancellationToken = this.activeCompletionCancellationToken = new CancellationTokenSource();
      let activeCompletionPromise = this.activeCompletionPromise = this.completer(this.value, cancellationToken);
      if (activeCompletionPromise !== null) {
        activeCompletionPromise.then((completionResult) => {
          if (this.activeCompletionPromise === activeCompletionPromise) {
            this.setCompletions(completionResult);
            this.activeCompletionPromise = null;
          }
        });
      }
    }, delay);
    this.registerDisposer(() => {
      debouncedCompleter.cancel();
    });
    const element = this.element, inputElement = this.inputElement, hintElement = this.hintElement;
    element.classList.add("neuroglancer-multiline-autocomplete");
    this.registerEventListener(window, "resize", this.resizeHandler);
    this.resizeObserver.observe(element);
    this.registerDisposer(() => this.resizeObserver.unobserve(inputElement));
    inputElement.contentEditable = "true";
    inputElement.spellcheck = false;
    element.appendChild(document.createTextNode("​"));
    element.appendChild(inputElement);
    element.appendChild(hintElement);
    inputElement.classList.add("neuroglancer-multiline-autocomplete-input");
    hintElement.classList.add("neuroglancer-multiline-autocomplete-hint");
    inputElement.addEventListener("input", () => {
      this.completionDisabled = -1;
      this.setValueAndSelection(this.value, this.getSelectionRange());
      this.debouncedUpdateHintState();
    });
    inputElement.addEventListener("copy", (event) => {
      const clipboardData = event.clipboardData;
      if (clipboardData !== null) {
        const selection = window.getSelection();
        if (selection !== null && !selection.isCollapsed && selection.containsNode(
          inputElement,
          /*allowPartialContainment=*/
          true
        )) {
          clipboardData.setData("text/plain", selection.toString());
        }
      }
      event.preventDefault();
      event.stopPropagation();
    });
    this.registerEventListener(document, "selectionchange", () => {
      const newSelection = this.getSelectionRange();
      const completionDisabled = this.completionDisabled;
      if (newSelection !== void 0 && newSelection.begin === completionDisabled && newSelection.end === completionDisabled) {
        return;
      }
      this.completionDisabled = -1;
      this.debouncedUpdateHintState();
    });
    this.setValueAndSelection("");
    this.updateHintState();
    element.addEventListener("pointerdown", (event) => {
      const target = event.target;
      if (target instanceof Node) {
        if (inputElement.contains(target)) return;
        const completionsVirtualList = this.completionsVirtualList;
        if (completionsVirtualList !== void 0 && completionsVirtualList.element.contains(target)) {
          return;
        }
      }
      if (inputElement === document.activeElement) {
        this.moveCaretToEndOfInput();
        event.stopPropagation();
        event.preventDefault();
      }
    });
    element.addEventListener("click", () => {
      inputElement.focus();
    });
    this.registerEventListener(this.inputElement, "focus", () => {
      if (!this.hasFocus) {
        this.hasFocus = true;
        this.dropdownStyleStale = true;
        this.updateDropdown();
        const r = document.createRange();
        const childNodes = inputElement.childNodes;
        r.setStart(inputElement, 0);
        if (childNodes.length === 0) {
          r.setEnd(inputElement, 0);
        } else {
          r.setEndAfter(childNodes[childNodes.length - 1]);
        }
        const s = window.getSelection();
        if (s !== null) {
          s.removeAllRanges();
          s.addRange(r);
        }
        this.debouncedUpdateHintState();
      }
    });
    this.registerEventListener(this.inputElement, "blur", () => {
      if (this.hasFocus) {
        this.hasFocus = false;
        this.updateDropdown();
      }
      this.debouncedUpdateHintState();
      const s = window.getSelection();
      if (s !== null) {
        if (s.containsNode(this.inputElement, true)) {
          s.removeAllRanges();
        }
      }
      this.onCommit.dispatch(this.value, false);
    });
    this.registerEventListener(window, "resize", () => {
      this.dropdownStyleStale = true;
    });
    this.registerEventListener(window, "scroll", () => {
      this.dropdownStyleStale = true;
    });
    const keyboardHandler = this.registerDisposer(new KeyboardEventBinder(inputElement, keyMap$1));
    keyboardHandler.allShortcutsAreGlobal = true;
    registerActionListener(inputElement, "cycle-next-active-completion", () => {
      this.cycleActiveCompletion(1);
    });
    registerActionListener(inputElement, "cycle-prev-active-completion", () => {
      this.cycleActiveCompletion(-1);
    });
    registerActionListener(inputElement, "home", () => {
      this.moveCaretToBeginningOfInput();
    });
    registerActionListener(inputElement, "end", () => {
      this.moveCaretToEndOfInput();
    });
    registerActionListener(inputElement, "choose-active-completion-or-prefix", (event) => {
      if (this.selectActiveCompletion(
        /*allowPrefix=*/
        true
      )) {
        event.preventDefault();
      }
    });
    registerActionListener(inputElement, "commit", (event) => {
      if (this.selectActiveCompletion(
        /*allowPrefix=*/
        false
      )) {
        event.stopPropagation();
      } else {
        let explicit = !this.completionsVisible;
        this.disableCompletion();
        this.hideCompletions();
        this.onCommit.dispatch(this.value, explicit);
      }
    });
    registerActionListener(inputElement, "cancel", (event) => {
      event.stopPropagation();
      if (this.cancel()) {
        event.detail.preventDefault();
        event.detail.stopPropagation();
      }
    });
  }
  disableCompletion() {
    const selectionRange = this.getSelectionRange();
    this.completionDisabled = selectionRange !== void 0 && selectionRange.end === selectionRange.begin ? selectionRange.end : -1;
  }
  get placeholder() {
    return this.inputElement.dataset.placeholder || "";
  }
  set placeholder(value) {
    this.inputElement.dataset.placeholder = value;
  }
  getSelectionRange() {
    const s = window.getSelection();
    if (s === null) return void 0;
    if (s.rangeCount === 0) return void 0;
    const startRange = s.getRangeAt(0);
    const inputElement = this.inputElement;
    const beforeRange = document.createRange();
    beforeRange.setStart(inputElement, 0);
    beforeRange.setEnd(startRange.startContainer, startRange.startOffset);
    const begin = beforeRange.toString().length;
    const length2 = s.toString().length;
    return { begin, end: begin + length2 };
  }
  setValueAndSelection(value, selection = void 0) {
    const completionDisabled = this.completionDisabled !== -1;
    this.onInput.dispatch(value);
    const inputElement = this.inputElement;
    removeChildren(inputElement);
    let outputOffset = 0;
    const r = selection !== void 0 ? document.createRange() : void 0;
    let isFirst = true;
    for (const text of splitByWordBreaks(value)) {
      if (!isFirst) {
        inputElement.appendChild(document.createElement("wbr"));
      }
      isFirst = false;
      const newOutputOffset = outputOffset + text.length;
      const node = document.createTextNode(text);
      inputElement.appendChild(node);
      if (r !== void 0) {
        const begin = selection.begin, end = selection.end;
        if (begin >= outputOffset && begin <= newOutputOffset) {
          r.setStart(node, begin - outputOffset);
        }
        if (end >= outputOffset && end <= newOutputOffset) {
          r.setEnd(node, end - outputOffset);
        }
      }
      outputOffset = newOutputOffset;
    }
    if (r !== void 0) {
      if (isFirst) {
        r.setStart(inputElement, 0);
        r.setEnd(inputElement, 0);
      }
      const s = window.getSelection();
      if (s !== null) {
        s.removeAllRanges();
        s.addRange(r);
      }
    }
    this.completionDisabled = completionDisabled && selection !== void 0 && selection.end === selection.begin ? selection.end : -1;
  }
  shouldAttemptCompletion() {
    const inputElement = this.inputElement;
    if (document.activeElement !== inputElement) return false;
    const selection = this.getSelectionRange();
    return selection !== void 0 && selection.end === selection.begin && selection.end != this.completionDisabled && selection.end === this.value.length;
  }
  hideCompletions() {
    this.cancelActiveCompletion();
    this.clearCompletions();
    this.hintElement.textContent = "";
  }
  updateHintState() {
    this.debouncedUpdateHintState.cancel();
    if (!this.shouldAttemptCompletion()) {
      this.hideCompletions();
      return;
    } else {
      const value = this.value;
      if (value === this.prevInputValue) {
        return;
      }
      this.hideCompletions();
      this.prevInputValue = value;
      this.scheduleUpdateCompletions();
    }
  }
  handleDropdownClick(event) {
    let completionsVirtualList = this.completionsVirtualList;
    if (completionsVirtualList === void 0) return;
    const dropdownElement = completionsVirtualList.element;
    for (let target = event.target; target instanceof HTMLElement && target !== dropdownElement; target = target.parentElement) {
      const completionIndex = target.dataset.completionIndex;
      if (completionIndex !== void 0) {
        this.selectCompletion(Number(completionIndex));
        break;
      }
    }
  }
  cycleActiveCompletion(delta) {
    if (this.completionResult === null) {
      return;
    }
    let activeIndex = this.activeIndex;
    let numCompletions = this.completionResult.completions.length;
    if (activeIndex === -1) {
      if (delta > 0) {
        activeIndex = 0;
      } else {
        activeIndex = numCompletions - 1;
      }
    } else {
      activeIndex = (activeIndex + delta + numCompletions) % numCompletions;
    }
    this.setActiveIndex(activeIndex);
  }
  shouldShowDropdown() {
    let completionResult = this.completionResult;
    if (completionResult === null || !this.hasFocus) {
      return false;
    }
    return this.hasResultForDropdown;
  }
  updateDropdownStyle() {
    const completionsVirtualList = this.completionsVirtualList, element = this.element;
    if (completionsVirtualList !== void 0) {
      positionDropdown(completionsVirtualList.element, element, { horizontal: false });
    }
    this.dropdownStyleStale = false;
  }
  updateDropdown() {
    let completionsVirtualList = this.completionsVirtualList;
    if (this.shouldShowDropdown()) {
      if (this.dropdownContentsStale) {
        if (completionsVirtualList !== void 0) {
          completionsVirtualList.dispose();
        }
        const completionResult = this.completionResult;
        var _completionResult$mak = completionResult.makeElement;
        const makeElement = _completionResult$mak === void 0 ? makeDefaultCompletionElement : _completionResult$mak;
        completionsVirtualList = this.completionsVirtualList = new VirtualList({
          source: {
            length: completionResult.completions.length,
            render: (index2) => {
              const completion = completionResult.completions[index2];
              const completionElement = makeElement.call(completionResult, completion);
              completionElement.classList.add("neuroglancer-multiline-autocomplete-completion");
              completionElement.dataset.completionIndex = `${index2}`;
              if (this.activeIndex === index2) {
                completionElement.classList.add(ACTIVE_COMPLETION_CLASS_NAME);
              }
              return completionElement;
            }
          },
          selectedIndex: this.activeIndex === -1 ? void 0 : this.activeIndex
        });
        completionsVirtualList.element.classList.add("neuroglancer-multiline-autocomplete-dropdown");
        completionsVirtualList.element.addEventListener("mousedown", (event) => {
          this.inputElement.focus();
          event.preventDefault();
        });
        completionsVirtualList.element.addEventListener("mouseup", this.handleDropdownClick.bind(this));
        this.element.appendChild(completionsVirtualList.element);
        this.dropdownContentsStale = false;
      }
      if (this.dropdownStyleStale) {
        this.updateDropdownStyle();
      }
      if (!this.completionsVisible) {
        this.completionsVisible = true;
      }
      const activeIndex = this.activeIndex;
      if (activeIndex !== -1) {
        this.completionsVirtualList.scrollItemIntoView(activeIndex);
      }
    } else if (this.completionsVisible) {
      if (completionsVirtualList !== void 0) {
        completionsVirtualList.dispose();
        this.completionsVirtualList = void 0;
        this.dropdownContentsStale = true;
      }
      this.completionsVisible = false;
    }
  }
  setCompletions(completionResult) {
    this.clearCompletions();
    let completions = completionResult.completions;
    if (completions.length === 0) {
      return;
    }
    const value = this.prevInputValue;
    if (value === void 0) return;
    this.completionResult = completionResult;
    if (completions.length === 1) {
      let completion = completions[0];
      if (completionResult.showSingleResult) {
        this.hasResultForDropdown = true;
      } else {
        if (!completion.value.startsWith(value)) {
          this.hasResultForDropdown = true;
        } else {
          this.hasResultForDropdown = false;
        }
      }
      if (completionResult.selectSingleResult) {
        this.setActiveIndex(0);
      } else {
        this.setHintValue(this.getCompletedValueByIndex(0));
      }
    } else {
      this.hasResultForDropdown = true;
      let commonResultPrefix = longestCommonPrefix(function* () {
        for (let completion of completionResult.completions) {
          yield completion.value;
        }
      }());
      let commonPrefix = this.getCompletedValue(commonResultPrefix);
      if (commonPrefix.startsWith(value)) {
        this.commonPrefix = commonPrefix;
        this.setHintValue(commonPrefix);
      }
    }
    this.updateDropdown();
  }
  setHintValue(hintValue) {
    const value = this.prevInputValue;
    if (value === void 0) return;
    if (hintValue === value || !hintValue.startsWith(value)) {
      hintValue = "";
    }
    hintValue = hintValue.substring(value.length);
    const hintElement = this.hintElement;
    removeChildren(hintElement);
    let isFirst = true;
    for (const text of splitByWordBreaks(hintValue)) {
      if (!isFirst) {
        hintElement.appendChild(document.createElement("wbr"));
      }
      isFirst = false;
      const node = document.createTextNode(text);
      hintElement.appendChild(node);
    }
  }
  /**
   * This sets the active completion, which causes it to be highlighted and displayed as the hint.
   * Additionally, if the user hits tab then it is chosen.
   */
  setActiveIndex(index2) {
    if (!this.dropdownContentsStale) {
      let activeIndex = this.activeIndex;
      const completionsVirtualList = this.completionsVirtualList;
      if (completionsVirtualList !== void 0) {
        if (activeIndex !== -1) {
          const prevElement = completionsVirtualList.getItemElement(activeIndex);
          if (prevElement !== void 0) {
            prevElement.classList.remove(ACTIVE_COMPLETION_CLASS_NAME);
          }
        }
        if (index2 !== -1) {
          let completionElement = completionsVirtualList.getItemElement(index2);
          if (completionElement !== void 0) {
            completionElement.classList.add(ACTIVE_COMPLETION_CLASS_NAME);
          }
          completionsVirtualList.scrollItemIntoView(index2);
        }
      }
    }
    if (index2 !== -1) {
      this.setHintValue(this.getCompletedValueByIndex(index2));
    }
    this.activeIndex = index2;
  }
  getCompletedValueByIndex(index2) {
    return this.getCompletedValue(this.completionResult.completions[index2].value);
  }
  getCompletedValue(completionValue) {
    let completionResult = this.completionResult;
    let value = this.prevInputValue;
    if (value === void 0) return "";
    return value.substring(0, completionResult.offset) + completionValue;
  }
  moveCaretToBeginningOfInput() {
    const r = document.createRange();
    const inputElement = this.inputElement;
    r.setStart(inputElement, 0);
    r.setEnd(inputElement, 0);
    const s = window.getSelection();
    if (s !== null) {
      s.removeAllRanges();
      s.addRange(r);
      this.debouncedUpdateHintState();
    }
  }
  moveCaretToEndOfInput() {
    const r = document.createRange();
    const inputElement = this.inputElement;
    const childNodes = inputElement.childNodes;
    const lastNode = childNodes[childNodes.length - 1];
    if (lastNode === void 0) {
      r.setStart(inputElement, 0);
      r.setEnd(inputElement, 0);
    } else {
      r.setStartAfter(lastNode);
      r.setEndAfter(lastNode);
    }
    const s = window.getSelection();
    if (s !== null) {
      s.removeAllRanges();
      s.addRange(r);
      this.debouncedUpdateHintState();
    }
  }
  selectActiveCompletion(allowPrefix) {
    let activeIndex = this.activeIndex;
    if (activeIndex === -1) {
      if (!allowPrefix) {
        return false;
      }
      let completionResult = this.completionResult;
      if (completionResult !== null && completionResult.completions.length === 1) {
        activeIndex = 0;
      } else {
        let commonPrefix = this.commonPrefix;
        if (commonPrefix.length > this.value.length) {
          this.value = commonPrefix;
          this.moveCaretToEndOfInput();
          return true;
        }
        return false;
      }
    }
    let newValue = this.getCompletedValueByIndex(activeIndex);
    if (this.value === newValue) {
      return false;
    }
    this.value = newValue;
    this.moveCaretToEndOfInput();
    return true;
  }
  selectCompletion(index2) {
    this.value = this.getCompletedValueByIndex(index2);
    this.moveCaretToEndOfInput();
  }
  /**
   * Called when user presses escape.  Does nothing here, but may be overridden in a subclass.
   */
  cancel() {
    return false;
  }
  cancelActiveCompletion() {
    this.prevInputValue = void 0;
    const token = this.activeCompletionCancellationToken;
    if (token !== void 0) {
      token.cancel();
    }
    this.activeCompletionCancellationToken = void 0;
    this.activeCompletionPromise = null;
  }
  clearCompletions() {
    if (this.completionResult !== null) {
      this.activeIndex = -1;
      this.completionResult = null;
      this.dropdownContentsStale = true;
      this.dropdownStyleStale = true;
      this.commonPrefix = "";
      const completionsVirtualList = this.completionsVirtualList;
      if (completionsVirtualList !== void 0) {
        completionsVirtualList.dispose();
        this.completionsVirtualList = void 0;
      }
      this.updateDropdown();
    }
  }
  get value() {
    return this.inputElement.textContent || "";
  }
  set value(value) {
    if (value !== this.value) {
      this.completionDisabled = -1;
      this.setValueAndSelection(value);
      this.debouncedUpdateHintState();
    }
  }
  disposed() {
    const completionsVirtualList = this.completionsVirtualList;
    if (completionsVirtualList !== void 0) {
      completionsVirtualList.dispose();
    }
    removeFromParent(this.element);
    this.cancelActiveCompletion();
    super.disposed();
  }
}
class Tab extends RefCounted {
  constructor(visibility = new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE)) {
    super();
    this.visibility = visibility;
    this.element = document.createElement("div");
    const element = this.element;
    element.classList.add("neuroglancer-tab-content");
  }
  get visible() {
    return this.visibility.visible;
  }
  disposed() {
    removeFromParent(this.element);
    super.disposed();
  }
}
class OptionSpecification extends RefCounted {
  constructor() {
    super(...arguments);
    this.changed = new NullarySignal();
    this.options = new _Map();
    this.optionsChanged = new NullarySignal();
    this.selectedValue = void 0;
    this.defaultValue = void 0;
    this.ready_ = true;
  }
  get value() {
    const selectedValue = this.selectedValue;
    if (selectedValue !== void 0) {
      return selectedValue;
    }
    return this.defaultValue;
  }
  set default(value) {
    if (this.defaultValue !== value) {
      this.defaultValue = value;
      this.changed.dispatch();
    }
  }
  get default() {
    return this.defaultValue;
  }
  set value(value) {
    if (value !== void 0 && this.ready_ && !this.options.has(value)) {
      value = void 0;
    }
    const selectedValue = this.selectedValue;
    if (selectedValue !== value) {
      this.selectedValue = value;
      this.changed.dispatch();
    }
  }
  get validValue() {
    const value = this.selectedValue;
    if (value === void 0 || !this.options.has(value)) {
      return this.defaultValue;
    }
    return value;
  }
  add(id, value) {
    const options = this.options;
    if (options.has(id)) {
      throw new Error(`Option already defined: ${_JSON$stringify(id)}.`);
    }
    options.set(id, value);
    this.optionsChanged.dispatch();
    if (this.defaultValue === void 0) {
      this.default = id;
    }
  }
  toJSON() {
    const value = this.value, defaultValue = this.defaultValue;
    if (value === defaultValue) {
      return void 0;
    }
    return value;
  }
  reset() {
    this.value = void 0;
  }
  /**
   * When `ready` is `false`, the selected `value` may be set to an unknown option.
   */
  get ready() {
    return this.ready_;
  }
  set ready(value) {
    if (value !== this.ready_) {
      this.ready_ = value;
      if (value) {
        this.value = this.value;
      }
      this.changed.dispatch();
    }
  }
  restoreState(obj) {
    if (typeof obj !== "string") {
      obj = void 0;
    }
    this.value = obj;
  }
}
class StackView extends RefCounted {
  constructor(getter, selected, visibility = new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE), invalidateByDefault = false) {
    super();
    this.getter = getter;
    this.selected = selected;
    this.visibility = visibility;
    this.invalidateByDefault = invalidateByDefault;
    this.element = document.createElement("div");
    this.tabs = new _Map();
    this.tabVisibilityChanged = new Signal();
    this.debouncedUpdateSelectedTab = this.registerCancellable(animationFrameDebounce(() => this.updateSelectedTab()));
    const element = this.element;
    element.className = "neuroglancer-stack-view";
    this.registerDisposer(visibility.changed.add(this.debouncedUpdateSelectedTab));
    this.registerDisposer(selected.changed.add(this.debouncedUpdateSelectedTab));
    this.updateSelectedTab();
  }
  get visible() {
    return this.visibility.visible;
  }
  flush() {
    this.debouncedUpdateSelectedTab.flush();
  }
  invalidate(id) {
    const tabs = this.tabs;
    const tab = tabs.get(id);
    if (tab === void 0) {
      return;
    }
    tab.dispose();
    tabs.delete(id);
    if (id === this.displayedTab) {
      this.displayedTab = void 0;
      this.debouncedUpdateSelectedTab();
    }
  }
  hideTab(id) {
    const tab = this.tabs.get(id);
    if (tab !== void 0) {
      tab.visibility.value = WatchableVisibilityPriority.IGNORED;
      tab.element.style.display = "none";
    }
    this.tabVisibilityChanged.dispatch(id, false);
  }
  showTab(id) {
    const tabs = this.tabs;
    let tab = tabs.get(id);
    if (tab === void 0) {
      tab = this.getter(id);
      this.element.appendChild(tab.element);
      tabs.set(id, tab);
    }
    tab.element.style.display = "";
    tab.visibility.value = WatchableVisibilityPriority.VISIBLE;
    this.tabVisibilityChanged.dispatch(id, true);
  }
  updateSelectedTab() {
    const displayedTab = this.displayedTab;
    const newTab = this.visible ? this.selected.value : void 0;
    if (newTab === displayedTab && (newTab === void 0 || this.tabs.has(newTab))) {
      return;
    }
    if (displayedTab !== void 0) {
      this.hideTab(displayedTab);
    }
    if (this.invalidateByDefault) {
      this.invalidateAll();
    }
    this.displayedTab = newTab;
    if (newTab === void 0) {
      return;
    }
    this.showTab(newTab);
  }
  invalidateAll(predicate = void 0) {
    const tabs = this.tabs;
    for (const _ref of tabs) {
      var _ref2 = _slicedToArray(_ref, 2);
      const id = _ref2[0];
      const tab = _ref2[1];
      if (predicate !== void 0 && predicate(id)) continue;
      tabs.delete(id);
      tab.dispose();
    }
    this.debouncedUpdateSelectedTab();
  }
  disposed() {
    this.invalidateAll();
    removeFromParent(this.element);
    super.disposed();
  }
}
class TabSpecification extends OptionSpecification {
}
function updateTabLabelVisibilityStyle(labelElement, visible) {
  const className = "neuroglancer-selected-tab-label";
  if (visible) {
    labelElement.classList.add(className);
  } else {
    labelElement.classList.remove(className);
  }
}
class TabView extends RefCounted {
  constructor(options, visibility = new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE)) {
    super();
    this.visibility = visibility;
    this.element = document.createElement("div");
    this.tabBar = document.createElement("div");
    this.tabLabels = new _Map();
    this.tabsGeneration = -1;
    this.debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateTabs()));
    this.tabs = options.tabs;
    this.selectedTab = options.selectedTab;
    this.handleTabElement = options.handleTabElement;
    const element = this.element, tabBar = this.tabBar;
    element.className = "neuroglancer-tab-view";
    tabBar.className = "neuroglancer-tab-view-bar";
    element.appendChild(tabBar);
    this.registerDisposer(visibility.changed.add(this.debouncedUpdateView));
    const stack = this.stack = this.registerDisposer(new StackView(options.makeTab, options.selectedTab, this.visibility));
    element.appendChild(stack.element);
    this.registerDisposer(options.tabs.changed.add(this.debouncedUpdateView));
    this.registerDisposer(options.selectedTab.changed.add(() => this.updateTabLabelStyles()));
    this.updateTabs();
  }
  get visible() {
    return this.visibility.visible;
  }
  updateTabLabelStyles() {
    const selectedId = this.selectedTab.value;
    for (const _ref3 of this.tabLabels) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const id = _ref4[0];
      const element = _ref4[1];
      updateTabLabelVisibilityStyle(element, id === selectedId);
    }
  }
  updateTabs() {
    if (this.tabsGeneration !== this.tabs.changed.count) {
      this.destroyTabs();
      if (this.visible) {
        this.makeTabs();
      }
    }
  }
  destroyTabs() {
    if (this.tabsGeneration === -1) {
      return;
    }
    this.tabLabels.clear();
    if (!this.visible) {
      this.stack.invalidateAll();
    } else {
      const tabs = this.tabs.value;
      this.stack.invalidateAll((existingId) => tabs.find(({ id }) => id === existingId) !== void 0);
    }
    removeChildren(this.tabBar);
    this.tabsGeneration = -1;
  }
  makeTabs() {
    const tabBar = this.tabBar, tabLabels = this.tabLabels, handleTabElement = this.handleTabElement;
    for (const _ref5 of this.tabs.value) {
      const id = _ref5.id;
      const label = _ref5.label;
      const labelElement = document.createElement("div");
      labelElement.classList.add("neuroglancer-tab-label");
      labelElement.textContent = label;
      labelElement.addEventListener("click", () => {
        this.selectedTab.value = id;
      });
      if (handleTabElement !== void 0) {
        handleTabElement(id, labelElement);
      }
      tabLabels.set(id, labelElement);
      tabBar.appendChild(labelElement);
    }
    this.updateTabLabelStyles();
    this.tabsGeneration = this.tabs.changed.count;
  }
  disposed() {
    removeChildren(this.tabBar);
    this.tabLabels.clear();
    removeFromParent(this.element);
    super.disposed();
  }
}
class SourceUrlAutocomplete extends AutocompleteTextInput {
  constructor(dataSourceView) {
    const manager = dataSourceView.source.layer.manager;
    const sourceCompleter = (value, cancellationToken) => manager.dataSourceProviderRegistry.completeUrl({ url: value, chunkManager: manager.chunkManager, cancellationToken }).then((originalResult) => ({
      completions: originalResult.completions,
      makeElement: makeCompletionElementWithDescription,
      offset: originalResult.offset,
      showSingleResult: true
    }));
    super({ completer: sourceCompleter, delay: 0 });
    this.placeholder = "Data source URL";
    this.dataSourceView = dataSourceView;
    this.element.classList.add("neuroglancer-layer-data-source-url-input");
    this.dirty = new WatchableValue(false);
    const updateDirty = (value) => {
      if (value !== this.dataSourceView.source.spec.url) {
        this.dirty.value = true;
      }
    };
    updateDirty("");
    this.onInput.add(updateDirty);
  }
  cancel() {
    this.value = this.dataSourceView.source.spec.url;
    this.dirty.value = false;
    this.inputElement.blur();
    return true;
  }
}
class MessagesView extends RefCounted {
  constructor(model) {
    super();
    this.model = model;
    this.element = document.createElement("ul");
    this.generation = -1;
    this.element.classList.add("neuroglancer-layer-data-sources-source-messages");
    const debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateView()));
    this.registerDisposer(model.changed.add(debouncedUpdateView));
    this.registerDisposer(() => removeFromParent(this.element));
    this.updateView();
  }
  updateView() {
    const model = this.model;
    const generation = model.changed.count;
    if (generation === this.generation) return;
    this.generation = generation;
    const element = this.element;
    removeChildren(element);
    const seen = new _Set();
    for (const message of model) {
      const key = `${message.severity} ${message.message}`;
      if (seen.has(key)) continue;
      seen.add(key);
      const li = document.createElement("li");
      element.appendChild(li);
      li.classList.add("neuroglancer-message");
      li.classList.add(`neuroglancer-message-${MessageSeverity[message.severity]}`);
      li.textContent = message.message;
    }
  }
}
class DataSourceSubsourceView extends RefCounted {
  constructor(loadedSource, loadedSubsource) {
    super();
    this.loadedSubsource = loadedSubsource;
    this.element = document.createElement("div");
    const element = this.element;
    element.classList.add("neuroglancer-layer-data-source-subsource");
    const sourceInfoLine = document.createElement("label");
    const sourceType = document.createElement("span");
    const updateActiveAttribute = () => {
      sourceInfoLine.dataset.isActive = (loadedSubsource.activated !== void 0 || !loadedSubsource.enabled).toString();
    };
    updateActiveAttribute();
    this.registerDisposer(loadedSubsource.isActiveChanged.add(updateActiveAttribute));
    this.registerDisposer(loadedSource.enabledSubsourcesChanged.add(updateActiveAttribute));
    const enabledCheckbox = this.registerDisposer(new TrackableBooleanCheckbox({
      get value() {
        return loadedSubsource.enabled;
      },
      set value(value) {
        loadedSubsource.enabled = value;
        loadedSource.enableDefaultSubsources = false;
        loadedSource.enabledSubsourcesChanged.dispatch();
      },
      changed: loadedSource.enabledSubsourcesChanged
    }));
    sourceInfoLine.classList.add("neuroglancer-layer-data-sources-info-line");
    sourceInfoLine.appendChild(enabledCheckbox.element);
    const sourceId = document.createElement("span");
    sourceId.classList.add("neuroglancer-layer-data-sources-source-id");
    const id = loadedSubsource.subsourceEntry.id;
    if (id !== "default") {
      sourceId.textContent = id;
    }
    sourceInfoLine.appendChild(sourceId);
    sourceType.classList.add("neuroglancer-layer-data-sources-source-type");
    const messagesView = this.registerDisposer(new MessagesView(this.loadedSubsource.messages));
    element.appendChild(sourceInfoLine);
    sourceInfoLine.appendChild(sourceType);
    element.appendChild(messagesView.element);
    let sourceTypeStr = "";
    const subsource = loadedSubsource.subsourceEntry.subsource;
    const volume = subsource.volume;
    if (volume instanceof MultiscaleVolumeChunkSource$3) {
      sourceTypeStr = `${DataType[volume.dataType].toLowerCase()} volume`;
    } else if (subsource.mesh instanceof MeshSource) {
      sourceTypeStr = "meshes (single-res.)";
    } else if (subsource.mesh instanceof MultiscaleMeshSource) {
      sourceTypeStr = "meshes (multi-res.)";
    } else if (subsource.mesh instanceof SkeletonSource) {
      sourceTypeStr = "skeletons";
    } else if (subsource.segmentPropertyMap !== void 0) {
      sourceTypeStr = "segment property map";
    } else if (subsource.local !== void 0) {
      switch (subsource.local) {
        case LocalDataSource.annotations:
          sourceTypeStr = "Local annotations";
          break;
        case LocalDataSource.equivalences:
          sourceTypeStr = "local segmentation graph";
          break;
      }
    } else if (subsource.staticAnnotations !== void 0) {
      sourceTypeStr = "default annotations";
    } else if (subsource.annotation !== void 0) {
      sourceTypeStr = "annotations";
    } else if (subsource.singleMesh !== void 0) {
      sourceTypeStr = "single mesh";
    } else if (subsource.segmentationGraph !== void 0) {
      sourceTypeStr = "segmentation graph";
    }
    sourceType.textContent = sourceTypeStr;
  }
}
class LoadedDataSourceView extends RefCounted {
  constructor(source) {
    super();
    this.source = source;
    this.element = document.createElement("div");
    const element = this.element;
    const enableDefaultSubsourcesLabel = document.createElement("label");
    enableDefaultSubsourcesLabel.classList.add("neuroglancer-layer-data-sources-source-default");
    enableDefaultSubsourcesLabel.appendChild(this.registerDisposer(new TrackableBooleanCheckbox({
      changed: source.enabledSubsourcesChanged,
      get value() {
        return source.enableDefaultSubsources;
      },
      set value(value) {
        if (source.enableDefaultSubsources === value) return;
        source.enableDefaultSubsources = value;
        if (value) {
          for (const subsource of source.subsources) {
            subsource.enabled = subsource.subsourceEntry.default;
          }
        }
        source.enabledSubsourcesChanged.dispatch();
      }
    })).element);
    enableDefaultSubsourcesLabel.appendChild(document.createTextNode("Enable default subsource set"));
    enableDefaultSubsourcesLabel.title = "Enable the default set of subsources for this data source.";
    element.appendChild(enableDefaultSubsourcesLabel);
    for (const subsource of source.subsources) {
      element.appendChild(this.registerDisposer(new DataSourceSubsourceView(source, subsource)).element);
    }
    const transform = source.transform;
    if (transform.mutableSourceRank || transform.value.sourceRank !== 0) {
      const transformWidget = this.registerDisposer(new CoordinateSpaceTransformWidget(source.transform, source.layer.localCoordinateSpaceCombiner, source.layer.manager.root.coordinateSpaceCombiner));
      this.element.appendChild(transformWidget.element);
    }
    this.registerDisposer(() => removeFromParent(this.element));
  }
}
class DataSourceView extends RefCounted {
  constructor(tab, source) {
    super();
    this.tab = tab;
    this.source = source;
    this.element = document.createElement("div");
    this.seenGeneration = 0;
    this.generation = -1;
    const urlInput = this.urlInput = this.registerDisposer(new SourceUrlAutocomplete(this));
    const updateUrlFromView = (url, explicit) => {
      const source2 = this.source;
      const existingSpec = source2.spec;
      const userLayer = this.source.layer;
      url = userLayer.manager.dataSourceProviderRegistry.normalizeUrl({ url });
      if (url !== urlInput.value) {
        urlInput.disableCompletion();
        urlInput.setValueAndSelection(url, { begin: url.length, end: url.length });
      }
      urlInput.dirty.value = false;
      if (url && url === existingSpec.url) {
        if (explicit) {
          if (tab.detectedLayerConstructor !== void 0) {
            changeLayerTypeToDetected(source2.layer);
          }
        }
        return;
      }
      if (userLayer instanceof NewUserLayer) {
        try {
          const newName = userLayer.manager.dataSourceProviderRegistry.suggestLayerName(url);
          changeLayerName(userLayer.managedLayer, newName);
        } catch (_a) {
        }
      }
      source2.spec = _Object$assign(_Object$assign({}, existingSpec), { url });
    };
    urlInput.onCommit.add(updateUrlFromView);
    const element = this.element;
    element.classList.add("neuroglancer-layer-data-source");
    element.appendChild(urlInput.element);
    element.appendChild(this.registerDisposer(new MessagesView(source.messages)).element);
    this.updateView();
  }
  updateView() {
    const generation = this.source.changed.count;
    if (generation === this.generation) return;
    this.generation = generation;
    this.urlInput.value = this.source.spec.url;
    this.urlInput.dirty.value = false;
    const loadState = this.source.loadState;
    let loadedView = this.loadedView;
    if (loadedView !== void 0) {
      if (loadedView.source === loadState) {
        return;
      }
      loadedView.dispose();
      loadedView = this.loadedView = void 0;
    }
    if (loadState instanceof LoadedLayerDataSource) {
      loadedView = this.loadedView = new LoadedDataSourceView(loadState);
      this.element.appendChild(loadedView.element);
    }
  }
  disposed() {
    const loadedView = this.loadedView;
    if (loadedView !== void 0) {
      loadedView.dispose();
    }
    removeFromParent(this.element);
    super.disposed();
  }
}
function changeLayerTypeToDetected(userLayer) {
  if (userLayer instanceof NewUserLayer) {
    const layerConstructor = userLayer.detectedLayerConstructor;
    if (layerConstructor !== void 0) {
      changeLayerType(userLayer.managedLayer, layerConstructor);
      return true;
    }
  }
  return false;
}
class LayerDataSourcesTab extends Tab {
  constructor(layer) {
    super();
    this.layer = layer;
    this.generation = -1;
    this.sourceViews = new _Map();
    this.addDataSourceIcon = makeAddButton({ title: "Add additional data source" });
    this.layerTypeDetection = document.createElement("div");
    this.layerTypeElement = document.createElement("span");
    this.dataSourcesContainer = document.createElement("div");
    this.detectedLayerConstructor = void 0;
    const element = this.element, dataSourcesContainer = this.dataSourcesContainer;
    element.classList.add("neuroglancer-layer-data-sources-tab");
    dataSourcesContainer.classList.add("neuroglancer-layer-data-sources-container");
    const addDataSourceIcon = this.addDataSourceIcon;
    addDataSourceIcon.style.alignSelf = "start";
    addDataSourceIcon.addEventListener("click", () => {
      const layerDataSource = this.layer.addDataSource(void 0);
      this.updateView();
      const view = this.sourceViews.get(layerDataSource);
      if (view === void 0) return;
      view.urlInput.inputElement.focus();
    });
    element.appendChild(this.dataSourcesContainer);
    if (layer instanceof NewUserLayer) {
      const layerTypeDetection = this.layerTypeDetection, layerTypeElement = this.layerTypeElement;
      layerTypeDetection.style.display = "none";
      layerTypeElement.classList.add("neuroglancer-layer-data-sources-tab-type-detection-type");
      layerTypeDetection.appendChild(document.createTextNode(`Create as `));
      layerTypeDetection.appendChild(layerTypeElement);
      layerTypeDetection.appendChild(document.createTextNode(` layer`));
      element.appendChild(layerTypeDetection);
      layerTypeDetection.classList.add("neuroglancer-layer-data-sources-tab-type-detection");
      layerTypeDetection.addEventListener("click", () => {
        changeLayerTypeToDetected(layer);
      });
    }
    const reRender = this.reRender = animationFrameDebounce(() => this.updateView());
    this.registerDisposer(layer.dataSourcesChanged.add(reRender));
    this.registerDisposer(this.visibility.changed.add(reRender));
    this.updateView();
  }
  updateLayerTypeDetection() {
    const layerConstructor = (() => {
      const userLayer = this.layer;
      if (!(userLayer instanceof NewUserLayer)) return void 0;
      const layerConstructor2 = userLayer.detectedLayerConstructor;
      if (layerConstructor2 === void 0) return void 0;
      for (const view of this.sourceViews.values()) {
        if (view.urlInput.dirty.value) return void 0;
      }
      return layerConstructor2;
    })();
    if (layerConstructor === this.detectedLayerConstructor) return;
    const layerTypeDetection = this.layerTypeDetection;
    this.detectedLayerConstructor = layerConstructor;
    if (layerConstructor !== void 0) {
      const layerTypeElement = this.layerTypeElement;
      layerTypeElement.textContent = layerConstructor.type;
      layerTypeDetection.title = `Click here or press enter in the data source URL input box to create as ${layerConstructor.type} layer`;
      layerTypeDetection.style.display = "";
    } else {
      layerTypeDetection.style.display = "none";
    }
  }
  disposed() {
    const sourceViews = this.sourceViews;
    for (const dataSource of sourceViews.values()) {
      dataSource.dispose();
    }
    sourceViews.clear();
    super.disposed();
  }
  updateView() {
    if (!this.visible) return;
    const generation = this.layer.dataSourcesChanged.count;
    if (generation !== this.generation) {
      this.generation = generation;
      const curSeenGeneration = Date.now();
      const sourceViews = this.sourceViews;
      const layer = this.layer;
      function* getChildNodes() {
        let lastSourceUrlEmpty = true;
        const dataSources = layer.dataSources;
        for (const source of dataSources) {
          let view = sourceViews.get(source);
          if (view === void 0) {
            view = new DataSourceView(this, source);
            view.registerDisposer(view.urlInput.dirty.changed.add(this.reRender));
            sourceViews.set(source, view);
          }
          view.seenGeneration = curSeenGeneration;
          view.updateView();
          const url = source.spec.url;
          if (dataSources.length === 1 && url === "") {
            setTimeout(() => {
              view.urlInput.inputElement.focus();
            }, 0);
          }
          lastSourceUrlEmpty = source.spec.url.length === 0;
          yield view.element;
        }
        if (!lastSourceUrlEmpty) {
          yield this.addDataSourceIcon;
        }
      }
      updateChildren(this.dataSourcesContainer, getChildNodes.call(this));
      for (const _ref of sourceViews) {
        var _ref2 = _slicedToArray(_ref, 2);
        const source = _ref2[0];
        const view = _ref2[1];
        if (view.seenGeneration !== curSeenGeneration) {
          view.dispose();
          sourceViews.delete(source);
        }
      }
    }
    this.updateLayerTypeDetection();
  }
}
const TAB_JSON_KEY = "tab";
const TABS_JSON_KEY = "tabs";
const PANELS_JSON_KEY = "panels";
const SELECTED_LAYER_SIDE_PANEL_DEFAULT_LOCATION = _Object$assign(_Object$assign({}, DEFAULT_SIDE_PANEL_LOCATION), { row: 0 });
const LAYER_SIDE_PANEL_DEFAULT_LOCATION = _Object$assign(_Object$assign({}, DEFAULT_SIDE_PANEL_LOCATION), { visible: true, row: 0 });
class UserLayerSidePanelState extends RefCounted {
  constructor(panels) {
    super();
    this.panels = panels;
    this.layer = this.panels.layer;
    this.location = new TrackableSidePanelLocation(LAYER_SIDE_PANEL_DEFAULT_LOCATION);
    this.tabsChanged = new Signal();
    this.selectedTab = new WatchableValue(void 0);
    this.tabs = [];
  }
  initialize() {
    const panels = this.panels;
    this.tabsChanged.add(panels.specificationChanged.dispatch);
    this.selectedTab.changed.add(panels.specificationChanged.dispatch);
    this.location.changed.add(() => {
      var _a;
      panels.specificationChanged.dispatch();
      const layer = this.layer;
      const selectedLayer = layer.manager.root.selectedLayer;
      if (((_a = selectedLayer.layer) === null || _a === void 0 ? void 0 : _a.layer) !== layer) return;
      if (this !== layer.panels.panels[0]) return;
      const curLocation = this.location.value;
      if (selectedLayer.location.value !== curLocation) {
        selectedLayer.location.value = curLocation;
        selectedLayer.location.locationChanged.dispatch();
      }
    });
    this.location.locationChanged.add(() => {
      if (this.location.visible) return;
      if (this === this.panels.panels[0]) return;
      this.panels.removePanel(this);
    });
  }
  normalizeTabs() {
    const tabs = this.tabs;
    if (tabs.length === 0) {
      this.selectedTab.value = void 0;
      return;
    }
    const layerTabs = this.layer.tabs.options;
    const getOrder = (tab) => {
      var _a;
      return (_a = layerTabs.get(tab).order) !== null && _a !== void 0 ? _a : 0;
    };
    tabs.sort((a, b) => getOrder(a) - getOrder(b));
    const selectedTab = this.selectedTab;
    const selectedTabValue = selectedTab.value;
    if (selectedTabValue === void 0 || !tabs.includes(selectedTabValue)) {
      selectedTab.value = tabs[0];
    }
  }
  pin() {
    var _a;
    const layer = this.layer;
    const selectedLayer = layer.manager.root.selectedLayer;
    if (((_a = selectedLayer.layer) === null || _a === void 0 ? void 0 : _a.layer) !== layer) return;
    if (this !== layer.panels.panels[0]) return;
    if (this.tabs.length === 0) return;
    const panels = this.panels;
    const newPanel = layer.registerDisposer(new UserLayerSidePanelState(panels));
    panels.panels.splice(0, 1, newPanel);
    panels.panels.push(this);
    panels.updateTabs();
    newPanel.initialize();
    selectedLayer.layerManager.layersChanged.dispatch();
    this.panels.specificationChanged.dispatch();
  }
  unpin() {
    var _a;
    const panels = this.panels;
    const panelIndex = panels.panels.indexOf(this);
    if (panelIndex === -1 || panelIndex === 0) return;
    const layer = this.layer;
    const selectedLayer = layer.manager.root.selectedLayer;
    const selectedUserLayer = (_a = selectedLayer.layer) === null || _a === void 0 ? void 0 : _a.layer;
    if (selectedLayer.visible && selectedUserLayer != null && selectedUserLayer != layer) {
      const prevSelectedLayerPanel = selectedUserLayer.panels.panels[0];
      prevSelectedLayerPanel.pin();
    }
    panels.panels.splice(panelIndex, 1);
    var _panels$panels$splice = panels.panels.splice(0, 1, this), _panels$panels$splice2 = _slicedToArray(_panels$panels$splice, 1);
    const origSelectedPanel = _panels$panels$splice2[0];
    if (this.explicitTabs === void 0) {
      layer.unregisterDisposer(origSelectedPanel);
    } else {
      panels.panels.push(origSelectedPanel);
      for (let i = 1, length2 = panels.panels.length; i < length2; ++i) {
        const panel = panels.panels[i];
        if (panel.explicitTabs === void 0) {
          panel.explicitTabs = new _Set(panel.tabs);
        }
      }
    }
    this.explicitTabs = void 0;
    panels.updateTabs();
    selectedLayer.layer = layer.managedLayer;
    selectedLayer.location.value = this.location.value;
    selectedLayer.location.locationChanged.dispatch();
    selectedLayer.layerManager.layersChanged.dispatch();
    this.panels.specificationChanged.dispatch();
  }
  splitOffTab(tab, location2) {
    if (!this.tabs.includes(tab)) return;
    const panels = this.panels;
    {
      const explicitTabs = this.explicitTabs;
      if (explicitTabs !== void 0) {
        explicitTabs.delete(tab);
      }
    }
    const layer = this.layer;
    const newPanel = layer.registerDisposer(new UserLayerSidePanelState(panels));
    newPanel.location.value = location2;
    newPanel.explicitTabs = new _Set([tab]);
    panels.panels.splice(1, 0, newPanel);
    panels.updateTabs();
    newPanel.initialize();
    layer.manager.root.layerManager.layersChanged.dispatch();
    panels.specificationChanged.dispatch();
  }
  moveTabTo(tab, target) {
    if (!this.tabs.includes(tab)) return;
    {
      const explicitTabs = this.explicitTabs;
      if (explicitTabs !== void 0) {
        explicitTabs.delete(tab);
      }
    }
    {
      const explicitTabs = target.explicitTabs;
      if (explicitTabs !== void 0) {
        explicitTabs.add(tab);
      }
    }
    const panels = this.panels;
    panels.updateTabs();
    target.selectedTab.value = tab;
    panels.specificationChanged.dispatch();
  }
  mergeInto(target) {
    const explicitTabs = target.explicitTabs;
    if (explicitTabs !== void 0) {
      for (const tab of this.tabs) {
        explicitTabs.add(tab);
      }
    }
    const panels = this.panels;
    panels.removePanel(this);
  }
}
class UserLayerSidePanelsState {
  constructor(layer) {
    this.layer = layer;
    this.specificationChanged = new Signal();
    this.updating = false;
    this.panels = [layer.registerDisposer(new UserLayerSidePanelState(this))];
  }
  restoreState(obj) {
    const panels = this.panels;
    panels[0].selectedTab.value = verifyOptionalObjectProperty(obj, TAB_JSON_KEY, verifyString);
    const layer = this.layer;
    const tabs = layer.tabs;
    const availableTabs = new _Set(tabs.options.keys());
    verifyOptionalObjectProperty(obj, PANELS_JSON_KEY, (panelsObj) => parseArray(panelsObj, (panelObj) => {
      verifyObject(panelObj);
      const panel = new UserLayerSidePanelState(this);
      panel.location.restoreState(panelObj);
      if (!panel.location.visible) return;
      panel.selectedTab.value = verifyOptionalObjectProperty(panelObj, TAB_JSON_KEY, verifyString);
      panel.explicitTabs = verifyOptionalObjectProperty(panelObj, TABS_JSON_KEY, (tabsObj) => {
        const curTabs = new _Set();
        for (const tab of verifyStringArray(tabsObj)) {
          if (!availableTabs.has(tab)) continue;
          availableTabs.delete(tab);
          curTabs.add(tab);
        }
        return curTabs;
      });
      if (panel.explicitTabs === void 0) {
        panel.tabs = _Array$from(availableTabs);
        availableTabs.clear();
      } else {
        panel.tabs = _Array$from(panel.explicitTabs);
      }
      if (panel.tabs.length === 0) return;
      panel.normalizeTabs();
      layer.registerDisposer(panel);
      panel.initialize();
      panels.push(panel);
    }));
    panels[0].tabs = _Array$from(availableTabs);
    panels[0].normalizeTabs();
    this.panels[0].initialize();
  }
  removePanel(panel) {
    if (this.updating) return;
    const i = this.panels.indexOf(panel);
    this.panels.splice(i, 1);
    this.layer.unregisterDisposer(panel);
    this.updateTabs();
  }
  updateTabs() {
    var _a;
    const layer = this.layer;
    const tabs = layer.tabs;
    const availableTabs = new _Set(tabs.options.keys());
    const panels = this.panels;
    this.updating = true;
    const updatePanelTabs = (panel) => {
      const oldTabs = panel.tabs;
      if (panel.explicitTabs === void 0) {
        panel.tabs = _Array$from(availableTabs);
        availableTabs.clear();
      } else {
        panel.tabs = _Array$from(panel.explicitTabs);
        for (const tab of panel.tabs) {
          availableTabs.delete(tab);
        }
      }
      if (!arraysEqual(oldTabs, panel.tabs)) {
        panel.normalizeTabs();
        panel.tabsChanged.dispatch();
      }
    };
    for (let i = 1; i < panels.length; ) {
      const panel = panels[i];
      if (panel.location.visible) {
        updatePanelTabs(panel);
        if (panel.tabs.length !== 0) {
          ++i;
          continue;
        }
      }
      panels.splice(i, 1);
      layer.unregisterDisposer(panel);
    }
    updatePanelTabs(panels[0]);
    if (panels[0].tabs.length === 0) {
      const selectedLayer = this.layer.manager.root.selectedLayer;
      if (((_a = selectedLayer.layer) === null || _a === void 0 ? void 0 : _a.layer) === this.layer) {
        selectedLayer.location.visible = false;
      }
    }
    this.updating = false;
  }
  toJSON() {
    var _a;
    const panels = this.panels;
    const obj = {};
    obj[TAB_JSON_KEY] = panels[0].selectedTab.value;
    if (panels.length > 1) {
      const panelsObj = [];
      for (let i = 1, numPanels = panels.length; i < numPanels; ++i) {
        const panel = panels[i];
        const panelObj = (_a = panel.location.toJSON()) !== null && _a !== void 0 ? _a : {};
        panelObj[TAB_JSON_KEY] = panel.selectedTab.value;
        const explicitTabs = panel.explicitTabs;
        if (explicitTabs !== void 0) {
          panelObj[TABS_JSON_KEY] = _Array$from(explicitTabs);
        }
        panelsObj.push(panelObj);
      }
      obj[PANELS_JSON_KEY] = panelsObj;
    }
    return obj;
  }
}
const TOOL_KEY_PATTERN = /^[A-Z]$/;
class ToolActivation extends RefCounted {
  constructor(tool, inputEventMapBinder) {
    super();
    this.tool = tool;
    this.inputEventMapBinder = inputEventMapBinder;
  }
  bindAction(action, listener) {
    this.registerDisposer(registerActionListener(window, action, listener));
  }
  bindInputEventMap(inputEventMap2) {
    this.inputEventMapBinder(inputEventMap2, this);
  }
  cancel() {
    if (this == this.tool.layer.manager.root.toolBinder.activeTool_) {
      this.tool.layer.manager.root.toolBinder.deactivate_();
    }
  }
}
class Tool extends RefCounted {
  constructor(layer, toggle = false) {
    super();
    this.layer = layer;
    this.toggle = toggle;
    this.changed = new Signal();
    this.keyBinding = void 0;
  }
  get mouseState() {
    return this.layer.manager.root.layerSelectedValues.mouseState;
  }
  unbind() {
    const layer = this.layer;
    const keyBinding = this.keyBinding;
    if (keyBinding !== void 0) {
      layer.toolBinder.set(keyBinding, void 0);
    }
  }
}
class LegacyTool extends RefCounted {
  constructor(layer) {
    super();
    this.layer = layer;
    this.changed = new Signal();
  }
  get mouseState() {
    return this.layer.manager.root.layerSelectedValues.mouseState;
  }
  deactivate() {
  }
  unbind() {
    const layer = this.layer;
    if (layer.tool.value === this) {
      layer.tool.value = void 0;
    }
  }
}
function restoreTool(layer, obj) {
  var _a;
  if (obj === void 0) {
    return void 0;
  }
  if (typeof obj === "string") {
    obj = { "type": obj };
  }
  verifyObject(obj);
  const type = verifyObjectProperty(obj, "type", verifyString);
  let getter = (_a = layerTools.get(layer.constructor)) === null || _a === void 0 ? void 0 : _a.get(type);
  if (getter === void 0) {
    getter = tools.get(type);
  }
  if (getter === void 0) {
    throw new Error(`Invalid tool type: ${_JSON$stringify(obj)}.`);
  }
  return getter(layer, obj);
}
function restoreLegacyTool(layer, obj) {
  if (obj === void 0) {
    return void 0;
  }
  if (typeof obj === "string") {
    obj = { "type": obj };
  }
  verifyObject(obj);
  const type = verifyObjectProperty(obj, "type", verifyString);
  const getter = legacyTools.get(type);
  if (getter === void 0) {
    throw new Error(`Invalid tool type: ${_JSON$stringify(obj)}.`);
  }
  return getter(layer, obj);
}
const legacyTools = new _Map();
const tools = new _Map();
const layerTools = new _Map();
function registerLegacyTool(type, getter) {
  legacyTools.set(type, getter);
}
function registerLayerTool(layerType, type, getter) {
  let tools2 = layerTools.get(layerType);
  if (tools2 === void 0) {
    tools2 = new _Map();
    layerTools.set(layerType, tools2);
  }
  tools2.set(type, getter);
}
class SelectedLegacyTool extends RefCounted {
  constructor(layer) {
    super();
    this.layer = layer;
    this.changed = new Signal();
  }
  get value() {
    return this.value_;
  }
  set value(newValue) {
    if (newValue === this.value_) return;
    this.unregister();
    if (newValue !== void 0) {
      newValue.changed.add(this.changed.dispatch);
      this.value_ = newValue;
    }
    this.changed.dispatch();
  }
  unregister() {
    const existingValue = this.value_;
    if (existingValue !== void 0) {
      existingValue.changed.remove(this.changed.dispatch);
      existingValue.dispose();
      this.value_ = void 0;
    }
  }
  disposed() {
    this.unregister();
    super.disposed();
  }
  restoreState(obj) {
    this.value = restoreLegacyTool(this.layer, obj);
  }
  reset() {
    this.value = void 0;
  }
  toJSON() {
    const value = this.value_;
    if (value === void 0) return void 0;
    return value.toJSON();
  }
}
class ToolBinder extends RefCounted {
  constructor(inputEventMapBinder) {
    super();
    this.inputEventMapBinder = inputEventMapBinder;
    this.bindings = new _Map();
    this.changed = new Signal();
    this.debounceDeactivate = this.registerCancellable(debounce(() => this.deactivate_(), 100));
    this.debounceReactivate = this.registerCancellable(debounce(() => this.reactivateQueuedTool(), 100));
  }
  get(key) {
    return this.bindings.get(key);
  }
  set(key, tool) {
    const bindings = this.bindings;
    const existingTool = bindings.get(key);
    if (existingTool !== void 0) {
      existingTool.keyBinding = void 0;
      bindings.delete(key);
      const layerToolBinder = existingTool.layer.toolBinder;
      layerToolBinder.bindings.delete(key);
      layerToolBinder.jsonToKey.delete(_JSON$stringify(existingTool.toJSON()));
      this.destroyTool(existingTool);
      layerToolBinder.changed.dispatch();
    }
    if (tool !== void 0) {
      const layerToolBinder = tool.layer.toolBinder;
      const json2 = _JSON$stringify(tool.toJSON());
      const existingKey = layerToolBinder.jsonToKey.get(json2);
      if (existingKey !== void 0) {
        const existingTool2 = layerToolBinder.bindings.get(existingKey);
        existingTool2.keyBinding = void 0;
        bindings.delete(existingKey);
        layerToolBinder.bindings.delete(existingKey);
        layerToolBinder.jsonToKey.delete(json2);
        this.destroyTool(existingTool2);
      }
      layerToolBinder.bindings.set(key, tool);
      tool.keyBinding = key;
      layerToolBinder.jsonToKey.set(json2, key);
      bindings.set(key, tool);
      layerToolBinder.changed.dispatch();
    }
    this.changed.dispatch();
  }
  activate(key) {
    const tool = this.get(key);
    if (tool === void 0) {
      this.deactivate_();
      return;
    }
    this.debounceDeactivate.cancel();
    this.debounceReactivate.cancel();
    const activeTool = this.activeTool_;
    if (tool === (activeTool === null || activeTool === void 0 ? void 0 : activeTool.tool)) {
      if (tool.toggle) {
        this.deactivate_();
      }
      return;
    } else if (activeTool !== void 0) {
      if (activeTool.tool.toggle && !tool.toggle) {
        this.queuedTool = activeTool.tool;
      }
      this.deactivate_();
    }
    const activation = new ToolActivation(tool, this.inputEventMapBinder);
    this.activeTool_ = activation;
    if (!tool.toggle) {
      const expectedCode = `Key${key}`;
      activation.registerEventListener(window, "keyup", (event) => {
        if (event.code === expectedCode) {
          this.debounceDeactivate();
          this.debounceReactivate();
        }
      });
      activation.registerEventListener(window, "blur", () => {
        this.debounceDeactivate();
        this.debounceReactivate();
      });
    }
    tool.activate(activation);
    return tool;
  }
  reactivateQueuedTool() {
    if (this.queuedTool) {
      const activation = new ToolActivation(this.queuedTool, this.inputEventMapBinder);
      this.activeTool_ = activation;
      this.queuedTool.activate(activation);
      this.queuedTool = void 0;
    }
  }
  destroyTool(tool) {
    var _a;
    if (this.queuedTool === tool) {
      this.queuedTool = void 0;
    }
    if (((_a = this.activeTool_) === null || _a === void 0 ? void 0 : _a.tool) === tool) {
      this.deactivate_();
    }
    tool.dispose();
  }
  disposed() {
    this.deactivate_();
    super.disposed();
  }
  deactivate_() {
    this.debounceDeactivate.cancel();
    const activation = this.activeTool_;
    if (activation === void 0) return;
    this.activeTool_ = void 0;
    activation.dispose();
  }
}
class LayerToolBinder {
  constructor(layer) {
    this.layer = layer;
    this.bindings = new _Map();
    this.jsonToKey = new _Map();
    this.changed = new Signal();
    layer.registerDisposer(() => this.clear());
  }
  get globalBinder() {
    return this.layer.manager.root.toolBinder;
  }
  get(key) {
    return this.bindings.get(key);
  }
  set(key, tool) {
    this.globalBinder.set(key, tool);
  }
  setJson(key, toolJson) {
    const tool = restoreTool(this.layer, toolJson);
    if (tool === void 0) return;
    this.set(key, tool);
  }
  removeJsonString(toolJsonString) {
    const key = this.jsonToKey.get(toolJsonString);
    if (key === void 0) return;
    this.set(key, void 0);
  }
  toJSON() {
    const bindings = this.bindings;
    if (bindings.size === 0) return void 0;
    const obj = {};
    for (const _ref of bindings) {
      var _ref2 = _slicedToArray(_ref, 2);
      const key = _ref2[0];
      const value = _ref2[1];
      obj[key] = value.toJSON();
    }
    return obj;
  }
  clear() {
    const globalBinder = this.globalBinder, bindings = this.bindings;
    if (bindings.size !== 0) {
      for (const _ref3 of bindings) {
        var _ref4 = _slicedToArray(_ref3, 2);
        const key = _ref4[0];
        const tool = _ref4[1];
        tool.keyBinding = void 0;
        globalBinder.bindings.delete(key);
        globalBinder.destroyTool(tool);
      }
      bindings.clear();
      this.jsonToKey.clear();
      globalBinder.changed.dispatch();
      this.changed.dispatch();
    }
  }
  reset() {
    this.clear();
  }
  restoreState(obj) {
    if (obj === void 0) return;
    verifyObject(obj);
    for (const _ref5 of _Object$entries(obj)) {
      var _ref6 = _slicedToArray(_ref5, 2);
      const key = _ref6[0];
      const value = _ref6[1];
      if (!key.match(TOOL_KEY_PATTERN)) {
        throw new Error(`Invalid tool key: ${_JSON$stringify(key)}`);
      }
      const tool = restoreTool(this.layer, value);
      if (tool === void 0) return;
      this.set(key, tool);
    }
  }
}
class ToolBindingWidget extends RefCounted {
  constructor(layer, toolJson) {
    super();
    this.layer = layer;
    this.toolJson = toolJson;
    this.element = document.createElement("div");
    this.toolJsonString = _JSON$stringify(this.toolJson);
    const element = this.element;
    element.classList.add("neuroglancer-tool-key-binding");
    this.registerDisposer(layer.toolBinder.changed.add(this.registerCancellable(animationFrameDebounce(() => this.updateView()))));
    this.updateView();
    element.title = "click → bind key, dbclick → unbind";
    element.addEventListener("dblclick", () => {
      this.layer.toolBinder.removeJsonString(this.toolJsonString);
    });
    addToolKeyBindHandlers(this, element, (key) => this.layer.toolBinder.setJson(key, this.toolJson));
  }
  updateView() {
    const toolBinder = this.layer.toolBinder;
    const key = toolBinder.jsonToKey.get(this.toolJsonString);
    this.element.textContent = key !== null && key !== void 0 ? key : " ";
  }
}
function addToolKeyBindHandlers(context, element, bindKey) {
  let mousedownContext;
  element.addEventListener("mousedown", (event) => {
    if (event.button !== 0 || mousedownContext !== void 0) return;
    event.preventDefault();
    event.stopPropagation();
    mousedownContext = new RefCounted();
    context.registerDisposer(mousedownContext);
    const message = mousedownContext.registerDisposer(new StatusMessage(false));
    message.setText("Press A-Z to bind key");
    mousedownContext.registerEventListener(window, "keydown", (event2) => {
      const code = event2.code;
      const m = code.match(/^Key([A-Z])$/);
      if (m === null) return;
      event2.stopPropagation();
      event2.preventDefault();
      const key = m[1];
      bindKey(key);
    }, { capture: true });
    mousedownContext.registerEventListener(window, "mouseup", (event2) => {
      if (event2.button !== 0 || mousedownContext === void 0) return;
      event2.preventDefault();
      event2.stopPropagation();
      context.unregisterDisposer(mousedownContext);
      mousedownContext.dispose();
      mousedownContext = void 0;
    });
  });
  element.addEventListener("click", (event) => {
    event.preventDefault();
    event.stopPropagation();
  });
}
function makeToolButton(context, layer, options) {
  const element = document.createElement("div");
  element.classList.add("neuroglancer-tool-button");
  element.appendChild(context.registerDisposer(new ToolBindingWidget(layer, options.toolJson)).element);
  const labelElement = document.createElement("div");
  labelElement.classList.add("neuroglancer-tool-button-label");
  labelElement.textContent = options.label;
  if (options.title) {
    labelElement.title = options.title;
  }
  element.appendChild(labelElement);
  return element;
}
function makeToolActivationStatusMessage(activation) {
  const message = activation.registerDisposer(new StatusMessage(false));
  message.element.classList.add("neuroglancer-tool-status");
  const content = document.createElement("div");
  content.classList.add("neuroglancer-tool-status-content");
  message.element.appendChild(content);
  const inputEventMapBinder = activation.inputEventMapBinder;
  activation.inputEventMapBinder = (inputEventMap2, context) => {
    const bindingHelp = document.createElement("div");
    bindingHelp.textContent = inputEventMap2.describe();
    bindingHelp.classList.add("neuroglancer-tool-status-bindings");
    message.element.appendChild(bindingHelp);
    inputEventMapBinder(inputEventMap2, context);
  };
  return { message, content };
}
function makeToolActivationStatusMessageWithHeader(activation) {
  var _makeToolActivationSt = makeToolActivationStatusMessage(activation);
  const message = _makeToolActivationSt.message, content = _makeToolActivationSt.content;
  const header = document.createElement("div");
  header.classList.add("neuroglancer-tool-status-header");
  const headerContainer = document.createElement("div");
  headerContainer.classList.add("neuroglancer-tool-status-header-container");
  headerContainer.appendChild(header);
  content.appendChild(headerContainer);
  const body = document.createElement("div");
  body.classList.add("neuroglancer-tool-status-body");
  content.appendChild(body);
  return { message, body, header };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function removeSignalBinding(signal, handler) {
  signal.remove(handler);
}
function addSignalBinding(signal, handler) {
  signal.add(handler);
}
const svg_controls_alt = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-labelledby="controlsAltIconTitle"><title id="controlsAltIconTitle">Controls</title><circle cx="9" cy="6" r="2"></circle><path d="M4 6H7"></path><path d="M11 6H20"></path><circle cx="9" cy="18" r="2"></circle><path d="M4 18H7"></path><path d="M11 18H20"></path><circle cx="15" cy="12" r="2"></circle><path d="M4 12H13"></path><path d="M17 12L20 12"></path></svg>';
const svg_layers = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-labelledby="layersIconTitle"><title id="layersIconTitle">Layers</title><path d="M12 4L20 8.00004L12 12L4 8.00004L12 4Z"></path><path d="M20 12L12 16L4 12"></path><path d="M20 16L12 20L4 16"></path></svg>';
const svg_list = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="listIconTitle"><title id="listIconTitle"></title><path d="M10 7L18 7M10 12L18 12M10 17L18 17"></path><line x1="7" y1="7" x2="7" y2="7"></line><line x1="7" y1="12" x2="7" y2="12"></line><line x1="7" y1="17" x2="7" y2="17"></line></svg>';
const svg_settings = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="settingsIconTitle"><title id="settingsIconTitle">Settings</title><path d="M5.03506429,12.7050339 C5.01187484,12.4731696 5,12.2379716 5,12 C5,11.7620284 5.01187484,11.5268304 5.03506429,11.2949661 L3.20577137,9.23205081 L5.20577137,5.76794919 L7.9069713,6.32070904 C8.28729123,6.0461342 8.69629298,5.80882212 9.12862533,5.61412402 L10,3 L14,3 L14.8713747,5.61412402 C15.303707,5.80882212 15.7127088,6.0461342 16.0930287,6.32070904 L18.7942286,5.76794919 L20.7942286,9.23205081 L18.9649357,11.2949661 C18.9881252,11.5268304 19,11.7620284 19,12 C19,12.2379716 18.9881252,12.4731696 18.9649357,12.7050339 L20.7942286,14.7679492 L18.7942286,18.2320508 L16.0930287,17.679291 C15.7127088,17.9538658 15.303707,18.1911779 14.8713747,18.385876 L14,21 L10,21 L9.12862533,18.385876 C8.69629298,18.1911779 8.28729123,17.9538658 7.9069713,17.679291 L5.20577137,18.2320508 L3.20577137,14.7679492 L5.03506429,12.7050339 Z"></path><circle cx="12" cy="12" r="1"></circle></svg>';
class CredentialsProvider extends RefCounted {
}
function makeCachedCredentialsGetter(getUncached) {
  let cachedCredentials;
  let pendingCredentials;
  let pendingCancellationToken;
  return (invalidCredentials, cancellationToken) => {
    if (pendingCredentials !== void 0 && (cachedCredentials === void 0 || invalidCredentials === void 0 || cachedCredentials.generation !== invalidCredentials.generation)) {
      if (cachedCredentials === void 0) {
        pendingCancellationToken.addConsumer(cancellationToken);
      }
      return pendingCredentials;
    }
    cachedCredentials = void 0;
    pendingCancellationToken = new MultipleConsumerCancellationTokenSource();
    pendingCredentials = getUncached(invalidCredentials, pendingCancellationToken).then((credentials) => {
      cachedCredentials = credentials;
      pendingCancellationToken = void 0;
      return credentials;
    }, (reason) => {
      if (pendingCancellationToken.isCanceled) {
        pendingCancellationToken = void 0;
        pendingCredentials = void 0;
      }
      throw reason;
    });
    return pendingCredentials;
  };
}
function makeCredentialsGetter(getWithoutGeneration) {
  let generation = 0;
  return makeCachedCredentialsGetter((_invalidCredentials, cancellationToken) => getWithoutGeneration(cancellationToken).then((credentials) => ({ generation: ++generation, credentials })));
}
class MapBasedCredentialsManager {
  constructor() {
    this.providers = new _Map();
    this.topLevelManager = this;
  }
  register(key, providerGetter) {
    this.providers.set(key, providerGetter);
  }
  getCredentialsProvider(key, parameters) {
    const getter = this.providers.get(key);
    if (getter === void 0) {
      throw new Error(`No registered credentials provider: ${_JSON$stringify(key)}`);
    }
    return getter(parameters, this.topLevelManager);
  }
}
class CachingCredentialsManager extends RefCounted {
  constructor(base) {
    super();
    this.base = base;
    this.memoize = new StringMemoize();
  }
  getCredentialsProvider(key, parameters) {
    return this.memoize.get({ key, parameters }, () => this.registerDisposer(this.base.getCredentialsProvider(key, parameters).addRef()));
  }
}
class CachingMapBasedCredentialsManager extends CachingCredentialsManager {
  constructor() {
    super(new MapBasedCredentialsManager());
    this.base.topLevelManager = this;
  }
  register(key, providerGetter) {
    this.base.register(key, providerGetter);
  }
}
class AnonymousFirstCredentialsProvider extends CredentialsProvider {
  constructor(baseProvider, anonymousCredentials) {
    super();
    this.baseProvider = baseProvider;
    this.anonymousCredentials = anonymousCredentials;
    this.anonymous = true;
    this.get = makeCachedCredentialsGetter((invalidCredentials) => {
      if (this.anonymous && invalidCredentials === void 0) {
        return _Promise.resolve({ generation: -10, credentials: this.anonymousCredentials });
      }
      this.anonymous = false;
      return this.baseProvider.get(invalidCredentials);
    });
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const defaultCredentialsManager = new CachingMapBasedCredentialsManager();
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function withFlex(value, handler) {
  return (element) => {
    element.style.flex = value;
    handler(element);
  };
}
function box(flexDirection, spec) {
  return (container) => {
    container.style.display = "flex";
    container.style.flexDirection = flexDirection;
    for (let handler of spec) {
      let element = container.ownerDocument.createElement("div");
      container.appendChild(element);
      handler(element);
    }
  };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tempMat$1 = create$4();
function computeAxisLineMatrix(projectionParameters, axisLength) {
  const mat = identity$2(tempMat$1);
  const position = projectionParameters.globalPosition;
  var _projectionParameters = projectionParameters.displayDimensionRenderInfo;
  const canonicalVoxelFactors = _projectionParameters.canonicalVoxelFactors, displayDimensionIndices = _projectionParameters.displayDimensionIndices;
  for (let i = 0; i < 3; ++i) {
    const globalDim = displayDimensionIndices[i];
    mat[12 + i] = globalDim === -1 ? 0 : position[globalDim];
    mat[5 * i] = axisLength / canonicalVoxelFactors[i];
  }
  multiply$3(mat, projectionParameters.viewProjectionMat, mat);
  return mat;
}
class AxesLineHelper extends RefCounted {
  constructor(gl) {
    super();
    this.gl = gl;
    this.vertexBuffer = this.registerDisposer(Buffer.fromData(gl, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1]), gl.ARRAY_BUFFER, gl.STATIC_DRAW));
    let alpha = 0.5;
    this.colorBuffer = this.registerDisposer(Buffer.fromData(gl, new Float32Array([1, 0, 0, alpha, 1, 0, 0, alpha, 0, 1, 0, alpha, 0, 1, 0, alpha, 0, 0, 1, alpha, 0, 0, 1, alpha]), gl.ARRAY_BUFFER, gl.STATIC_DRAW));
    this.trivialColorShader = this.registerDisposer(trivialColorShader(gl));
  }
  static get(gl) {
    return gl.memoize.get("SliceViewPanel:AxesLineHelper", () => new AxesLineHelper(gl));
  }
  draw(mat, blend = true) {
    let shader = this.trivialColorShader;
    let gl = this.gl;
    shader.bind();
    gl.uniformMatrix4fv(shader.uniform("uProjectionMatrix"), false, mat);
    let aVertexPosition = shader.attribute("aVertexPosition");
    this.vertexBuffer.bindToVertexAttrib(aVertexPosition, 4);
    let aColor = shader.attribute("aColor");
    this.colorBuffer.bindToVertexAttrib(aColor, 4);
    if (blend) {
      gl.colorMask(false, false, false, true);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.colorMask(true, true, true, true);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.DST_ALPHA);
    }
    gl.lineWidth(1);
    gl.drawArrays(gl.LINES, 0, 6);
    if (blend) {
      gl.disable(gl.BLEND);
    }
    gl.disableVertexAttribArray(aVertexPosition);
    gl.disableVertexAttribArray(aColor);
  }
}
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PERSPECTIVE_VIEW_RPC_ID = "perspective_view/PerspectiveView";
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PickIDManager {
  constructor() {
    this.renderLayers = [null];
    this.pickData = [null];
    this.values = [0, 0, 0];
    this.nextPickID = 1;
  }
  clear() {
    this.renderLayers.length = 1;
    this.pickData.length = 1;
    this.values.length = 3;
    this.nextPickID = 1;
  }
  registerUint64(renderLayer, x, count = 1, data = null) {
    return this.register(renderLayer, count, x.low, x.high, data);
  }
  register(renderLayer, count = 1, low = 0, high = 0, data = null) {
    let renderLayers = this.renderLayers, values2 = this.values;
    let pickID = this.nextPickID;
    this.nextPickID += count;
    let index2 = renderLayers.length;
    renderLayers[index2] = renderLayer;
    let valuesOffset = index2 * 3;
    values2[valuesOffset] = pickID;
    values2[valuesOffset + 1] = low;
    values2[valuesOffset + 2] = high;
    this.pickData[index2] = data;
    return pickID;
  }
  /**
   * Set the object state according to the specified pick ID.
   */
  setMouseState(mouseState, pickID) {
    const renderLayers = this.renderLayers, values2 = this.values;
    let lower = 0, upper = renderLayers.length - 1;
    while (lower < upper) {
      const mid = Math.ceil(lower + (upper - lower) / 2);
      if (values2[mid * 3] > pickID) {
        upper = mid - 1;
      } else {
        lower = mid;
      }
    }
    const pickedRenderLayer = mouseState.pickedRenderLayer = renderLayers[lower];
    const valuesOffset = lower * 3;
    const pickedOffset = mouseState.pickedOffset = pickID - values2[valuesOffset];
    let pickedValue = mouseState.pickedValue;
    pickedValue.low = values2[valuesOffset + 1];
    pickedValue.high = values2[valuesOffset + 2];
    mouseState.pickedAnnotationId = void 0;
    mouseState.pickedAnnotationLayer = void 0;
    mouseState.pickedAnnotationBuffer = void 0;
    mouseState.pickedAnnotationBufferBaseOffset = void 0;
    mouseState.pickedAnnotationIndex = void 0;
    mouseState.pickedAnnotationCount = void 0;
    mouseState.pickedAnnotationType = void 0;
    const data = this.pickData[lower];
    if (pickedRenderLayer !== null) {
      pickedRenderLayer.updateMouseState(mouseState, pickedValue, pickedOffset, data);
    }
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LinkedListOperations {
  static insertAfter(head, x) {
    let next = head.next0;
    x.next0 = next;
    x.prev0 = head;
    head.next0 = x;
    next.prev0 = x;
  }
  static insertBefore(head, x) {
    let prev = head.prev0;
    x.prev0 = prev;
    x.next0 = head;
    head.prev0 = x;
    prev.next0 = x;
  }
  static front(head) {
    let next = head.next0;
    if (next === head) {
      return null;
    }
    return next;
  }
  static back(head) {
    let next = head.prev0;
    if (next === head) {
      return null;
    }
    return next;
  }
  static pop(x) {
    let next = x.next0;
    let prev = x.prev0;
    next.prev0 = prev;
    prev.next0 = next;
    x.next0 = null;
    x.prev0 = null;
    return x;
  }
  static *iterator(head) {
    for (let x = head.next0; x !== head; x = x.next0) {
      yield x;
    }
  }
  static *reverseIterator(head) {
    for (let x = head.prev0; x !== head; x = x.prev0) {
      yield x;
    }
  }
  static initializeHead(head) {
    head.next0 = head.prev0 = head;
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AutomaticFocusList {
  constructor() {
    LinkedListOperations.initializeHead(this);
  }
}
const automaticFocusList = new AutomaticFocusList();
const isTopLevel = window.top === window;
const maybeUpdateFocus = debounce(() => {
  if (!isTopLevel) return;
  var _document = document;
  const activeElement = _document.activeElement;
  if (activeElement === null || activeElement === document.body) {
    const node = LinkedListOperations.front(automaticFocusList);
    if (node !== null) {
      node.element.focus({ preventScroll: true });
    }
  }
});
window.addEventListener("focus", () => {
  maybeUpdateFocus();
}, true);
window.addEventListener("blur", () => {
  maybeUpdateFocus();
}, true);
class AutomaticallyFocusedElement extends RefCounted {
  constructor(element) {
    super();
    this.element = element;
    this.prev0 = null;
    this.next0 = null;
    this.lastFocusedElement = null;
    this.scheduleUpdateFocus = this.registerCancellable(debounce(() => {
      var _document2 = document;
      const activeElement = _document2.activeElement;
      const element2 = this.element;
      if (element2.contains(activeElement) || isInputTextTarget(activeElement)) {
        return;
      }
      if (activeElement != null && (activeElement === this.lastFocusedElement || activeElement.contains(element2))) {
        this.element.focus({ preventScroll: true });
      }
      this.lastFocusedElement = null;
    }, 0));
    element.tabIndex = -1;
    this.registerEventListener(element, "pointerdown", (event) => {
      if (event.target !== element) return;
      this.lastFocusedElement = null;
      element.focus({ preventScroll: true });
    });
    this.registerEventListener(element, "mouseenter", () => {
      this.lastFocusedElement = document.activeElement;
      this.scheduleUpdateFocus();
    });
    this.registerEventListener(element, "mouseleave", () => {
      this.scheduleUpdateFocus.cancel();
    });
    LinkedListOperations.insertBefore(automaticFocusList, this);
    this.registerEventListener(element, "focus", () => {
      LinkedListOperations.pop(this);
      LinkedListOperations.insertAfter(automaticFocusList, this);
    });
    maybeUpdateFocus();
  }
  disposed() {
    LinkedListOperations.pop(this);
    super.disposed();
  }
}
const moveThreshold = 10;
const holdThreshold = 1e3;
const maxTapDuration = 400;
const multiTapMaxInterval = 500;
const rotateThreshold = Math.PI / 20;
const pinchThreshold = 20;
const translateThreshold = 10;
function norm2(deltaX, deltaY) {
  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
}
function getTwoFingerDistanceAndAngle(touches) {
  var _touches = _slicedToArray(touches, 2);
  let t0 = _touches[0], t1 = _touches[1];
  if (t0.identifier > t1.identifier) {
    var _ref = [t0, t1];
    t1 = _ref[0];
    t0 = _ref[1];
  }
  const offsetX = t0.clientX - t1.clientX;
  const offsetY = t0.clientY - t1.clientY;
  const distance = norm2(offsetX, offsetY);
  const angle = Math.atan2(offsetX, offsetY);
  return { distance, angle };
}
function getAngleDifference(x, y) {
  const TAU = Math.PI * 2;
  const d = Math.abs(x - y) % TAU;
  return Math.min(d, TAU - d);
}
class TouchEventBinder extends RefCounted {
  constructor(target, eventMap) {
    super();
    this.target = target;
    this.eventMap = eventMap;
    this.prevTouches = new _Map();
    this.moved = false;
    this.prevAngle = 0;
    this.rotated = false;
    this.prevDistance = 0;
    this.pinched = false;
    this.prevCenterX = 0;
    this.prevCenterY = 0;
    this.translated = false;
    this.startHold = this.registerCancellable(throttle((event, eventPhase, centerX, centerY) => {
      const info = { event, centerX, centerY };
      this.dispatch(`touchhold${event.targetTouches.length}`, event, info, eventPhase);
    }, holdThreshold, { leading: false, trailing: true }));
    this.numPriorTaps = 0;
    this.priorTapNumTouches = 0;
    this.tapStartTime = 0;
    this.tapEndTime = 0;
    this.curTapNumTouches = 0;
    this.registerEventListener(target, "touchstart", (event) => {
      this.handleTouchEvent(event);
    });
    this.registerEventListener(target, "touchmove", (event) => {
      this.handleTouchEvent(event);
    });
    this.registerEventListener(target, "touchend", (event) => {
      this.handleTouchEvent(event);
    });
  }
  dispatch(eventIdentifier, event, detail, eventPhase = event.eventPhase) {
    dispatchEvent(eventIdentifier, event, eventPhase, detail, this.eventMap);
  }
  handleTouchEvent(event) {
    if (event.target === this.target) {
      event.preventDefault();
    } else {
      return;
    }
    const newTouches = new _Map();
    const prevTouches = this.prevTouches, prevEvent = this.prevEvent;
    let centerX = 0, centerY = 0;
    for (const touch of event.targetTouches) {
      newTouches.set(touch.identifier, touch);
      centerX += touch.clientX;
      centerY += touch.clientY;
    }
    centerX /= newTouches.size;
    centerY /= newTouches.size;
    for (const _ref2 of prevTouches.entries()) {
      var _ref3 = _slicedToArray(_ref2, 2);
      const key = _ref3[0];
      const touch = _ref3[1];
      const newTouch = newTouches.get(key);
      if (newTouch === void 0) {
        prevTouches.delete(key);
      } else {
        const deltaX2 = newTouch.clientX - touch.clientX;
        const deltaY2 = newTouch.clientY - touch.clientY;
        if (Math.abs(deltaX2) >= moveThreshold || Math.abs(deltaY2) >= moveThreshold) {
          this.moved = true;
        }
      }
    }
    if (prevEvent === void 0 || prevEvent.targetTouches.length !== newTouches.size || newTouches.size == 0) {
      this.moved = false;
      if (event.type === "touchstart") {
        this.startHold(event, event.eventPhase, centerX, centerY);
        if (prevEvent === void 0 || prevEvent.targetTouches.length === 0) {
          this.tapStartTime = Date.now();
          this.curTapNumTouches = 0;
        }
        this.curTapNumTouches = Math.max(this.curTapNumTouches, event.targetTouches.length);
      } else {
        if (event.type == "touchend") {
          const now = Date.now();
          if (event.targetTouches.length === 0 && now - this.tapStartTime < maxTapDuration) {
            if (this.curTapNumTouches !== this.priorTapNumTouches || now - this.tapEndTime >= multiTapMaxInterval) {
              this.numPriorTaps = 0;
            }
            ++this.numPriorTaps;
            this.tapEndTime = now;
            this.priorTapNumTouches = this.curTapNumTouches;
            const info = { event, centerX, centerY };
            this.dispatch(`touchtap${this.curTapNumTouches}x${this.numPriorTaps}`, event, info);
          }
        }
        this.startHold.cancel();
      }
      this.prevTouches = newTouches;
      this.prevEvent = event;
      this.prevCenterX = centerX;
      this.prevCenterY = centerY;
      this.translated = false;
      if (newTouches.size === 2) {
        var _getTwoFingerDistance = getTwoFingerDistanceAndAngle(newTouches.values());
        const distance = _getTwoFingerDistance.distance, angle = _getTwoFingerDistance.angle;
        this.prevDistance = distance;
        this.prevAngle = angle;
        this.rotated = false;
        this.pinched = false;
      }
      return;
    }
    if (!this.moved) {
      return;
    }
    this.tapStartTime = 0;
    this.startHold.cancel();
    this.prevTouches = newTouches;
    this.prevEvent = event;
    let prevCenterX = this.prevCenterX, prevCenterY = this.prevCenterY, translated = this.translated;
    const deltaX = centerX - prevCenterX;
    const deltaY = centerY - prevCenterY;
    if (translated === false && norm2(deltaX, deltaY) >= translateThreshold) {
      translated = this.translated = true;
    }
    if (translated === true && (deltaX !== 0 || deltaY !== 0)) {
      this.prevCenterX = centerX;
      this.prevCenterY = centerY;
      const info = { event, deltaX, deltaY, centerX, centerY };
      this.dispatch(`touchtranslate${newTouches.size}`, event, info);
    }
    if (newTouches.size === 2) {
      var _getTwoFingerDistance2 = getTwoFingerDistanceAndAngle(newTouches.values());
      const distance = _getTwoFingerDistance2.distance, angle = _getTwoFingerDistance2.angle;
      let pinched = this.pinched, rotated = this.rotated, prevDistance = this.prevDistance, prevAngle = this.prevAngle;
      if (pinched === false && Math.abs(distance - prevDistance) >= pinchThreshold) {
        this.pinched = pinched = true;
      }
      const angleDiff = getAngleDifference(angle, prevAngle);
      if (rotated === false && angleDiff >= rotateThreshold) {
        this.rotated = rotated = true;
      }
      if (pinched === true && distance != prevDistance) {
        this.prevDistance = distance;
        const info = { event, distance, prevDistance, centerX, centerY };
        this.dispatch(`touchpinch`, event, info);
      }
      if (rotated === true && angle !== prevAngle) {
        this.prevAngle = angle;
        this.dispatch(`touchrotate`, event, { event, centerX, centerY, angle, prevAngle });
      }
    }
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DOM_DELTA_PIXEL = 0;
const DOM_DELTA_LINE = 1;
const DOM_DELTA_PAGE = 2;
function getWheelZoomAmount(event) {
  let multiplier = 0;
  let deltaMode = event.deltaMode;
  switch (deltaMode) {
    case DOM_DELTA_PIXEL:
      multiplier = 1 / 200;
      break;
    case DOM_DELTA_LINE:
      multiplier = 1 / 10;
      break;
    case DOM_DELTA_PAGE:
      multiplier = 2;
      break;
  }
  return Math.exp(event.deltaY * multiplier);
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tempVec3$4 = create$3();
class FramePickingData {
  constructor() {
    this.pickIDs = new PickIDManager();
    this.viewportWidth = 0;
    this.viewportHeight = 0;
    this.invTransform = create$4();
    this.frameNumber = -1;
  }
}
class PickRequest {
  constructor() {
    this.buffer = null;
    this.glWindowX = 0;
    this.glWindowY = 0;
  }
}
const pickRequestInterval = 30;
const pickRadius = 5;
const pickDiameter = 1 + pickRadius * 2;
const pickOffsetSequence = (() => {
  const maxDist2 = pickRadius ** 2;
  const getDist2 = (x, y) => (x - pickRadius) ** 2 + (y - pickRadius) ** 2;
  let offsets = new Uint32Array(pickDiameter * pickDiameter);
  let count = 0;
  for (let x = 0; x < pickDiameter; ++x) {
    for (let y = 0; y < pickDiameter; ++y) {
      if (getDist2(x, y) > maxDist2) continue;
      offsets[count++] = y * pickDiameter + x;
    }
  }
  offsets = offsets.subarray(0, count);
  offsets.sort((a, b) => {
    const x1 = a % pickDiameter;
    const y1 = (a - x1) / pickDiameter;
    const x2 = b % pickDiameter;
    const y2 = (b - x2) / pickDiameter;
    return getDist2(x1, y1) - getDist2(x2, y2);
  });
  return offsets;
})();
function clearOutOfBoundsPickData(buffer, baseOffset, stride, glWindowX, glWindowY, viewportWidth, viewportHeight) {
  const startX = glWindowX - pickRadius;
  const startY = glWindowY - pickRadius;
  if (startX >= 0 && startY >= 0 && startX + pickDiameter <= viewportWidth && startY + pickDiameter <= viewportHeight) {
    return;
  }
  for (let relativeY = 0; relativeY < pickDiameter; ++relativeY) {
    for (let relativeX = 0; relativeX < pickDiameter; ++relativeX) {
      const x = startX + relativeX;
      const y = startY + relativeY;
      if (x < 0 || y < 0 || x >= viewportWidth || y >= viewportHeight) {
        buffer[baseOffset + (y * pickDiameter + x) * stride] = 0;
      }
    }
  }
}
class RenderedDataPanel extends RenderedPanel {
  constructor(context, element, viewer) {
    super(context, element, viewer.visibility);
    this.viewer = viewer;
    this.mouseX = -1;
    this.mouseY = -1;
    this.pickRequestPending = false;
    this.mouseStateForcer = () => this.blockOnPickRequest();
    this.pickingData = [new FramePickingData(), new FramePickingData()];
    this.pickRequests = [new PickRequest(), new PickRequest()];
    this.pickBufferContents = new Float32Array(2 * 4 * pickDiameter * pickDiameter);
    this.pickTimerId = -1;
    this.nextPickRequestTime = 0;
    this.pendingPickRequestTimerId = -1;
    this.pendingPickRequestTimerExpired = () => {
      this.pendingPickRequestTimerId = -1;
      if (!this.pickRequestPending) return;
      this.attemptToIssuePickRequest();
    };
    this.inputEventMap = viewer.inputEventMap;
    element.classList.add("neuroglancer-rendered-data-panel");
    element.classList.add("neuroglancer-panel");
    element.classList.add("neuroglancer-noselect");
    if (typeof NEUROGLANCER_SHOW_OBJECT_SELECTION_TOOLTIP !== "undefined" && NEUROGLANCER_SHOW_OBJECT_SELECTION_TOOLTIP === true) {
      element.title = "Double click to toggle display of object under mouse pointer.  Control+rightclick to pin/unpin selection.";
    }
    this.registerDisposer(new AutomaticallyFocusedElement(element));
    this.registerDisposer(new KeyboardEventBinder(element, this.inputEventMap));
    this.registerDisposer(new MouseEventBinder(element, this.inputEventMap, (event) => {
      this.onMousemove(event);
    }));
    this.registerDisposer(new TouchEventBinder(element, this.inputEventMap));
    this.registerEventListener(element, "mousemove", this.onMousemove.bind(this));
    this.registerEventListener(element, "touchstart", this.onTouchstart.bind(this));
    this.registerEventListener(element, "mouseleave", () => this.onMouseout());
    this.registerEventListener(
      element,
      "mouseover",
      (event) => {
        if (event.target !== element) {
          this.onMouseout();
        }
      },
      /*capture=*/
      true
    );
    registerActionListener(element, "select-position", () => {
      this.viewer.selectionDetailsState.select(false);
    });
    registerActionListener(element, "snap", () => {
      this.navigationState.pose.snap();
    });
    registerActionListener(element, "zoom-in", () => {
      this.navigationState.zoomBy(0.5);
    });
    registerActionListener(element, "zoom-out", () => {
      this.navigationState.zoomBy(2);
    });
    registerActionListener(element, "depth-range-decrease", () => {
      this.navigationState.depthRange.value *= 0.5;
    });
    registerActionListener(element, "depth-range-increase", () => {
      this.navigationState.depthRange.value *= 2;
    });
    for (let axis = 0; axis < 3; ++axis) {
      let axisName = AXES_NAMES[axis];
      for (let sign2 of [-1, 1]) {
        let signStr = sign2 < 0 ? "-" : "+";
        registerActionListener(element, `rotate-relative-${axisName}${signStr}`, () => {
          this.navigationState.pose.rotateRelative(kAxes[axis], sign2 * 0.1);
        });
        let tempOffset = create$3();
        registerActionListener(element, `${axisName}${signStr}`, () => {
          let navigationState = this.navigationState;
          let offset = tempOffset;
          offset[0] = 0;
          offset[1] = 0;
          offset[2] = 0;
          offset[axis] = sign2;
          navigationState.pose.translateVoxelsRelative(offset, true);
        });
      }
    }
    registerActionListener(element, "zoom-via-wheel", (event) => {
      const e = event.detail;
      this.onMousemove(e, false);
      this.zoomByMouse(getWheelZoomAmount(e));
    });
    registerActionListener(element, "adjust-depth-range-via-wheel", (event) => {
      const e = event.detail;
      this.navigationState.depthRange.value *= getWheelZoomAmount(e);
    });
    registerActionListener(element, "translate-via-mouse-drag", (e) => {
      startRelativeMouseDrag(e.detail, (_event, deltaX, deltaY) => {
        this.translateByViewportPixels(deltaX, deltaY);
      });
    });
    registerActionListener(element, "translate-in-plane-via-touchtranslate", (e) => {
      const detail = e.detail;
      this.translateByViewportPixels(detail.deltaX, detail.deltaY);
    });
    registerActionListener(element, "translate-z-via-touchtranslate", (e) => {
      const detail = e.detail;
      let navigationState = this.navigationState;
      let offset = tempVec3$4;
      offset[0] = 0;
      offset[1] = 0;
      offset[2] = detail.deltaY + detail.deltaX;
      navigationState.pose.translateVoxelsRelative(offset, true);
    });
    for (const amount of [1, 10]) {
      registerActionListener(element, `z+${amount}-via-wheel`, (event) => {
        const e = event.detail;
        let navigationState = this.navigationState;
        let offset = tempVec3$4;
        let delta = e.deltaY !== 0 ? e.deltaY : e.deltaX;
        offset[0] = 0;
        offset[1] = 0;
        offset[2] = (delta > 0 ? -1 : 1) * amount;
        navigationState.pose.translateVoxelsRelative(offset, true);
      });
    }
    registerActionListener(element, "move-to-mouse-position", () => {
      const mouseState = this.viewer.mouseState;
      if (mouseState.updateUnconditionally()) {
        this.navigationState.position.value = mouseState.position;
      }
    });
    registerActionListener(element, "snap", () => this.navigationState.pose.snap());
    registerActionListener(element, "move-annotation", (e) => {
      const mouseState = this.viewer.mouseState;
      const selectedAnnotationId = mouseState.pickedAnnotationId;
      const annotationLayer = mouseState.pickedAnnotationLayer;
      if (annotationLayer !== void 0) {
        if (selectedAnnotationId !== void 0) {
          e.stopPropagation();
          let annotationRef = annotationLayer.source.getReference(selectedAnnotationId);
          let ann = annotationRef.value;
          const handler = getAnnotationTypeRenderHandler(ann.type);
          const pickedOffset = mouseState.pickedOffset;
          const chunkTransform = annotationLayer.chunkTransform.value;
          if (chunkTransform.error !== void 0) return;
          const layerRank = chunkTransform.layerRank;
          const repPoint = new Float32Array(layerRank);
          handler.getRepresentativePoint(repPoint, ann, mouseState.pickedOffset);
          let totDeltaVec = set(create(), 0, 0);
          if (mouseState.updateUnconditionally()) {
            startRelativeMouseDrag(e.detail, (_event, deltaX, deltaY) => {
              add$1(totDeltaVec, totDeltaVec, [deltaX, deltaY]);
              const layerPoint = new Float32Array(layerRank);
              transformPoint(layerPoint, chunkTransform.chunkToLayerTransform, layerRank + 1, repPoint, layerRank);
              const renderPt = tempVec3$4;
              const displayDimensionIndices = this.navigationState.pose.displayDimensions.value.displayDimensionIndices;
              layerToDisplayCoordinates(renderPt, layerPoint, chunkTransform.modelTransform, displayDimensionIndices);
              this.translateDataPointByViewportPixels(renderPt, renderPt, totDeltaVec[0], totDeltaVec[1]);
              displayToLayerCoordinates(layerPoint, renderPt, chunkTransform.modelTransform, displayDimensionIndices);
              const newPoint = new Float32Array(layerRank);
              transformPoint(newPoint, chunkTransform.layerToChunkTransform, layerRank + 1, layerPoint, layerRank);
              let newAnnotation = handler.updateViaRepresentativePoint(ann, newPoint, pickedOffset);
              annotationLayer.source.update(annotationRef, newAnnotation);
            }, (_event) => {
              annotationLayer.source.commit(annotationRef);
              annotationRef.dispose();
            });
          }
        }
      }
    });
    registerActionListener(element, "delete-annotation", () => {
      const mouseState = this.viewer.mouseState;
      const selectedAnnotationId = mouseState.pickedAnnotationId;
      const annotationLayer = mouseState.pickedAnnotationLayer;
      if (annotationLayer !== void 0 && !annotationLayer.source.readonly && selectedAnnotationId !== void 0) {
        const ref = annotationLayer.source.getReference(selectedAnnotationId);
        try {
          annotationLayer.source.delete(ref);
        } finally {
          ref.dispose();
        }
      }
    });
    registerActionListener(element, "zoom-via-touchpinch", (e) => {
      const detail = e.detail;
      this.handleMouseMove(detail.centerX, detail.centerY);
      const ratio = detail.prevDistance / detail.distance;
      if (ratio > 0.1 && ratio < 10) {
        this.zoomByMouse(ratio);
      }
    });
  }
  cancelPickRequests() {
    const gl = this.gl;
    for (const request of this.pickRequests) {
      const sync = request.sync;
      if (sync !== null) {
        gl.deleteSync(sync);
      }
      request.sync = null;
    }
    clearTimeout(this.pickTimerId);
    this.pickTimerId = -1;
  }
  issuePickRequestInternal(pickRequest) {
    const gl = this.gl;
    let buffer = pickRequest.buffer;
    if (buffer === null) {
      buffer = pickRequest.buffer = gl.createBuffer();
      gl.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, buffer);
      gl.bufferData(WebGL2RenderingContext.PIXEL_PACK_BUFFER, 2 * 4 * 4 * pickDiameter * pickDiameter, WebGL2RenderingContext.STREAM_READ);
    } else {
      gl.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, buffer);
    }
    const renderViewport = this.renderViewport;
    let glWindowX = this.mouseX - renderViewport.visibleLeftFraction * renderViewport.logicalWidth;
    let glWindowY = renderViewport.height - (this.mouseY - renderViewport.visibleTopFraction * renderViewport.logicalHeight);
    this.issuePickRequest(glWindowX, glWindowY);
    pickRequest.sync = gl.fenceSync(WebGL2RenderingContext.SYNC_GPU_COMMANDS_COMPLETE, 0);
    pickRequest.frameNumber = this.context.frameNumber;
    pickRequest.glWindowX = glWindowX;
    pickRequest.glWindowY = glWindowY;
    gl.flush();
    gl.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, null);
    if (this.pickTimerId === -1) {
      this.scheduleCheckForPickRequestCompletion();
    }
    this.pickRequestPending = false;
    const pickRequests = this.pickRequests;
    if (pickRequest !== pickRequests[0]) {
      pickRequests[1] = pickRequests[0];
      pickRequests[0] = pickRequest;
    }
    this.nextPickRequestTime = Date.now() + pickRequestInterval;
  }
  completePickInternal(pickRequest) {
    const gl = this.gl;
    const pickBufferContents = this.pickBufferContents;
    gl.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, pickRequest.buffer);
    gl.getBufferSubData(WebGL2RenderingContext.PIXEL_PACK_BUFFER, 0, pickBufferContents);
    gl.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, null);
    const pickingData = this.pickingData;
    const frameNumber = pickRequest.frameNumber;
    this.completePickRequest(pickRequest.glWindowX, pickRequest.glWindowY, pickBufferContents, pickingData[0].frameNumber === frameNumber ? pickingData[0] : pickingData[1]);
  }
  scheduleCheckForPickRequestCompletion() {
    this.pickTimerId = window.setTimeout(() => {
      this.pickTimerId = -1;
      this.checkForPickRequestCompletion();
    }, 0);
  }
  checkForPickRequestCompletion(checkingBeforeDraw = false, block = false) {
    let currentFrameNumber = this.context.frameNumber;
    let cancelIfNotReadyFrameNumber = -1;
    if (checkingBeforeDraw) {
      --currentFrameNumber;
      cancelIfNotReadyFrameNumber = currentFrameNumber - 1;
    }
    const pickRequests = this.pickRequests;
    const gl = this.gl;
    let remaining = false;
    let cancelRemaining = false;
    let available;
    for (const pickRequest of pickRequests) {
      const sync = pickRequest.sync;
      if (sync === null) continue;
      const frameNumber = pickRequest.frameNumber;
      if (!cancelRemaining && frameNumber >= currentFrameNumber - 1) {
        if (block || gl.getSyncParameter(sync, WebGL2RenderingContext.SYNC_STATUS) === WebGL2RenderingContext.SIGNALED) {
          this.completePickInternal(pickRequest);
          cancelRemaining = true;
        } else if (frameNumber !== cancelIfNotReadyFrameNumber) {
          remaining = true;
          continue;
        }
      }
      gl.deleteSync(sync);
      pickRequest.sync = null;
      available = pickRequest;
    }
    const pickTimerId = this.pickTimerId;
    if (remaining && pickTimerId === -1) {
      this.scheduleCheckForPickRequestCompletion();
    } else if (!remaining && pickTimerId !== -1) {
      window.clearTimeout(pickTimerId);
      this.pickTimerId = -1;
    }
    if (!checkingBeforeDraw && available !== void 0 && this.pickRequestPending && this.canIssuePickRequest()) {
      this.issuePickRequestInternal(available);
    }
  }
  blockOnPickRequest() {
    if (this.pickRequestPending) {
      this.cancelPickRequests();
      this.nextPickRequestTime = 0;
      this.attemptToIssuePickRequest();
    }
    this.checkForPickRequestCompletion(
      /*checkingBeforeDraw=*/
      false,
      /*block=*/
      true
    );
  }
  draw() {
    var _renderViewport = this.renderViewport;
    const width = _renderViewport.width, height = _renderViewport.height;
    this.checkForPickRequestCompletion(true);
    const pickingData = this.pickingData;
    pickingData[0] = pickingData[1];
    const currentFrameNumber = this.context.frameNumber;
    const newPickingData = pickingData[1];
    newPickingData.frameNumber = currentFrameNumber;
    newPickingData.viewportWidth = width;
    newPickingData.viewportHeight = height;
    newPickingData.pickIDs.clear();
    if (!this.drawWithPicking(newPickingData)) {
      newPickingData.frameNumber = -1;
      return;
    }
    this.nextPickRequestTime = 0;
    if (this.mouseX >= 0) {
      this.attemptToIssuePickRequest();
    }
  }
  canIssuePickRequest() {
    const time = Date.now();
    const nextPickRequestTime = this.nextPickRequestTime, pendingPickRequestTimerId = this.pendingPickRequestTimerId;
    if (time < nextPickRequestTime) {
      if (pendingPickRequestTimerId == -1) {
        this.pendingPickRequestTimerId = window.setTimeout(this.pendingPickRequestTimerExpired, nextPickRequestTime - time);
      }
      return false;
    }
    return true;
  }
  attemptToIssuePickRequest() {
    if (!this.canIssuePickRequest()) return;
    const currentFrameNumber = this.context.frameNumber;
    const gl = this.gl;
    const pickRequests = this.pickRequests;
    for (const pickRequest of pickRequests) {
      let sync = pickRequest.sync;
      if (sync !== null) {
        if (pickRequest.frameNumber < currentFrameNumber - 1) {
          gl.deleteSync(sync);
        } else {
          continue;
        }
      }
      this.issuePickRequestInternal(pickRequest);
      return;
    }
  }
  /**
   * Called each time the mouse position relative to the top level of the rendered viewport changes.
   */
  updateMousePosition(mouseX, mouseY) {
    if (mouseX === this.mouseX && mouseY === this.mouseY) {
      return;
    }
    this.mouseX = mouseX;
    this.mouseY = mouseY;
    if (mouseX < 0) {
      this.pickRequestPending = false;
      this.cancelPickRequests();
      return;
    }
    const currentFrameNumber = this.context.frameNumber;
    const pickingData = this.pickingData[1];
    if (pickingData.frameNumber !== currentFrameNumber || this.renderViewport.width !== pickingData.viewportWidth || this.renderViewport.height !== pickingData.viewportHeight) {
      return;
    }
    this.pickRequestPending = true;
    this.attemptToIssuePickRequest();
  }
  onMouseout() {
    this.updateMousePosition(-1, -1);
    this.viewer.mouseState.setForcer(void 0);
  }
  handleMouseMove(clientX, clientY) {
    const element = this.element;
    const bounds = element.getBoundingClientRect();
    const mouseX = clientX - (bounds.left + element.clientLeft);
    const mouseY = clientY - (bounds.top + element.clientTop);
    const mouseState = this.viewer.mouseState;
    mouseState.pageX = clientX + window.scrollX;
    mouseState.pageY = clientY + window.scrollY;
    mouseState.setForcer(this.mouseStateForcer);
    this.updateMousePosition(mouseX, mouseY);
  }
  onMousemove(event, atOnly = true) {
    const element = this.element;
    if (atOnly && event.target !== element) {
      return;
    }
    this.handleMouseMove(event.clientX, event.clientY);
  }
  onTouchstart(event) {
    let element = this.element;
    if (event.target !== element || event.targetTouches.length !== 1) {
      return;
    }
    var _event$targetTouches$ = event.targetTouches[0];
    const clientX = _event$targetTouches$.clientX, clientY = _event$targetTouches$.clientY;
    this.handleMouseMove(clientX, clientY);
  }
  disposed() {
    let mouseState = this.viewer.mouseState;
    mouseState.removeForcer(this.mouseStateForcer);
    const gl = this.gl;
    this.cancelPickRequests();
    const pendingPickRequestTimerId = this.pendingPickRequestTimerId;
    if (pendingPickRequestTimerId !== -1) {
      window.clearTimeout(pendingPickRequestTimerId);
    }
    for (const request of this.pickRequests) {
      gl.deleteBuffer(request.buffer);
    }
    super.disposed();
  }
}
const DEFAULT_ALLOWED_SIGNIFICANDS = [1.5, 2, 3, 5, 7.5, 10];
class ScaleBarDimensions {
  constructor() {
    this.allowedSignificands = DEFAULT_ALLOWED_SIGNIFICANDS;
    this.targetLengthInPixels = 0;
    this.physicalSizePerPixel = 0;
    this.prevPhysicalSizePerPixel = 0;
    this.prevTargetLengthInPixels = 0;
    this.prevPhysicalUnit = "\0";
  }
  /**
   * Updates physicalLength, physicalUnit, and lengthInPixels to be the optimal values corresponding
   * to targetLengthInPixels and physicalSizePerPixel.
   *
   * @returns true if the scale bar has changed, false if it is unchanged.
   */
  update() {
    let physicalSizePerPixel = this.physicalSizePerPixel, targetLengthInPixels = this.targetLengthInPixels;
    if (this.prevPhysicalSizePerPixel === physicalSizePerPixel && this.prevTargetLengthInPixels === targetLengthInPixels && this.prevPhysicalUnit === this.physicalUnit) {
      return false;
    }
    this.prevPhysicalSizePerPixel = physicalSizePerPixel;
    this.prevTargetLengthInPixels = targetLengthInPixels;
    this.prevPhysicalUnit = this.physicalUnit;
    const targetPhysicalSize = targetLengthInPixels * physicalSizePerPixel;
    const exponent = Math.floor(_Math$log(targetPhysicalSize));
    const tenToThePowerExponent = 10 ** exponent;
    const targetSignificand = targetPhysicalSize / tenToThePowerExponent;
    let bestSignificand = 1;
    for (let allowedSignificand of this.allowedSignificands) {
      if (Math.abs(allowedSignificand - targetSignificand) < Math.abs(bestSignificand - targetSignificand)) {
        bestSignificand = allowedSignificand;
      } else {
        break;
      }
    }
    const physicalSize = bestSignificand * tenToThePowerExponent;
    const siPrefix = pickSiPrefix(physicalSize);
    this.lengthInPixels = Math.round(physicalSize / physicalSizePerPixel);
    this.physicalUnit = `${siPrefix.prefix}${this.physicalBaseUnit}`;
    this.physicalLength = bestSignificand * 10 ** (exponent - siPrefix.exponent);
    return true;
  }
}
function makeScaleBarTexture(dimensions, gl, texture, label, options) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const textHeight = options.textHeightInPixels * options.scaleFactor;
  const font = `bold ${textHeight}px ${options.fontName}`;
  ctx.font = font;
  ctx.fillStyle = "white";
  const text = `${label}${dimensions.physicalLength} ${dimensions.physicalUnit}`;
  const textMetrics = ctx.measureText(text);
  const innerWidth = Math.max(dimensions.lengthInPixels, textMetrics.width);
  const barHeight = options.barHeightInPixels * options.scaleFactor;
  const barTopMargin = options.barTopMarginInPixels * options.scaleFactor;
  const innerHeight = barHeight + barTopMargin + textHeight;
  const padding = options.paddingInPixels * options.scaleFactor;
  const totalHeight = innerHeight + 2 * padding;
  const totalWidth = innerWidth + 2 * padding;
  canvas.width = totalWidth;
  canvas.height = totalHeight;
  ctx.font = font;
  ctx.textAlign = "center";
  ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
  ctx.fillRect(0, 0, totalWidth, totalHeight);
  ctx.fillStyle = "white";
  ctx.fillText(text, totalWidth / 2, totalHeight - padding - barHeight - barTopMargin);
  ctx.fillRect(padding, totalHeight - padding - barHeight, dimensions.lengthInPixels, barHeight);
  setTextureFromCanvas(gl, texture, canvas);
  return { width: totalWidth, height: totalHeight };
}
class ScaleBarTexture extends RefCounted {
  constructor(gl, dimensions = new ScaleBarDimensions()) {
    super();
    this.gl = gl;
    this.dimensions = dimensions;
    this.texture = null;
    this.width = 0;
    this.height = 0;
    this.label = "";
    this.factor = 1;
    this.priorOptions = void 0;
    this.prevLabel = "";
  }
  update(options) {
    const dimensions = this.dimensions, label = this.label;
    let texture = this.texture;
    if (!dimensions.update() && texture !== null && options === this.priorOptions && label == this.prevLabel) {
      return;
    }
    if (texture === null) {
      texture = this.texture = this.gl.createTexture();
    }
    var _makeScaleBarTexture = makeScaleBarTexture(dimensions, this.gl, texture, label, options);
    const width = _makeScaleBarTexture.width, height = _makeScaleBarTexture.height;
    this.priorOptions = options;
    this.prevLabel = label;
    this.width = width;
    this.height = height;
  }
  disposed() {
    this.gl.deleteTexture(this.texture);
    this.texture = null;
    super.disposed();
  }
}
class MultipleScaleBarTextures extends RefCounted {
  constructor(gl) {
    super();
    this.gl = gl;
    this.scaleBarCopyHelper = this.registerDisposer(OffscreenCopyHelper.get(this.gl));
    this.scaleBars = [];
    for (let i = 0; i < 3; ++i) {
      this.scaleBars.push(this.registerDisposer(new ScaleBarTexture(gl)));
    }
  }
  draw(viewport, displayDimensionRenderInfo, relativeDisplayScales, effectiveZoom, options) {
    const scaleBars = this.scaleBars;
    const displayRank = displayDimensionRenderInfo.displayRank, displayDimensionIndices = displayDimensionRenderInfo.displayDimensionIndices, canonicalVoxelFactors = displayDimensionRenderInfo.canonicalVoxelFactors, globalDimensionNames = displayDimensionRenderInfo.globalDimensionNames, displayDimensionUnits = displayDimensionRenderInfo.displayDimensionUnits, displayDimensionScales = displayDimensionRenderInfo.displayDimensionScales;
    const factors = relativeDisplayScales.factors;
    const targetLengthInPixels = Math.min(options.maxWidthFraction * viewport.logicalWidth, options.maxWidthInPixels * options.scaleFactor);
    let numScaleBars = 0;
    for (let i = 0; i < displayRank; ++i) {
      const dim = displayDimensionIndices[i];
      const unit = displayDimensionUnits[i];
      const factor = factors[dim];
      let barIndex;
      let scaleBar;
      let scaleBarDimensions;
      for (barIndex = 0; barIndex < numScaleBars; ++barIndex) {
        scaleBar = scaleBars[barIndex];
        scaleBarDimensions = scaleBar.dimensions;
        if (scaleBarDimensions.physicalBaseUnit === unit && scaleBar.factor === factor) {
          break;
        }
      }
      if (barIndex === numScaleBars) {
        ++numScaleBars;
        scaleBar = scaleBars[barIndex];
        scaleBar.label = "";
        scaleBarDimensions = scaleBar.dimensions;
        scaleBar.factor = factor;
        scaleBarDimensions.physicalBaseUnit = unit;
        scaleBarDimensions.targetLengthInPixels = targetLengthInPixels;
        scaleBarDimensions.physicalSizePerPixel = displayDimensionScales[i] * effectiveZoom / canonicalVoxelFactors[i];
      }
      scaleBar.label += `${globalDimensionNames[dim]} `;
    }
    const gl = this.gl, scaleBarCopyHelper = this.scaleBarCopyHelper;
    let bottomPixelOffset = options.bottomPixelOffset * options.scaleFactor;
    for (let barIndex = numScaleBars - 1; barIndex >= 0; --barIndex) {
      const scaleBar = scaleBars[barIndex];
      if (numScaleBars === 1) {
        scaleBar.label = "";
      } else {
        scaleBar.label += ": ";
      }
      scaleBar.update(options);
      gl.viewport(options.leftPixelOffset * options.scaleFactor - viewport.visibleLeftFraction * viewport.logicalWidth, bottomPixelOffset - (1 - (viewport.visibleTopFraction + viewport.visibleHeightFraction)) * viewport.logicalHeight, scaleBar.width, scaleBar.height);
      scaleBarCopyHelper.draw(scaleBar.texture);
      bottomPixelOffset += scaleBar.height + options.marginPixelsBetweenScaleBars * options.scaleFactor;
    }
  }
}
const defaultScaleBarTextureOptions = {
  scaleFactor: 1,
  textHeightInPixels: 15,
  barHeightInPixels: 8,
  barTopMarginInPixels: 5,
  fontName: "sans-serif",
  paddingInPixels: 2
};
const defaultScaleBarOptions = _Object$assign(_Object$assign({}, defaultScaleBarTextureOptions), { maxWidthInPixels: 100, maxWidthFraction: 0.25, leftPixelOffset: 10, bottomPixelOffset: 10, marginPixelsBetweenScaleBars: 5 });
function parseScaleBarOptions(obj) {
  const result = _Object$assign({}, defaultScaleBarOptions);
  for (const k of ["textHeightInPixels", "barTopMarginInPixels", "barHeightInPixels", "paddingInPixels", "scaleFactor", "maxWidthInPixels", "maxWidthFraction", "leftPixelOffset", "bottomPixelOffset"]) {
    verifyObjectProperty(obj, k, (x) => {
      if (x !== void 0) {
        result[k] = verifyFloat(x);
      }
    });
  }
  verifyObjectProperty(obj, "fontName", (x) => {
    if (x !== void 0) {
      result.fontName = verifyString(x);
    }
  });
  return result;
}
class TrackableScaleBarOptions extends TrackableValue {
  constructor() {
    super(defaultScaleBarOptions, parseScaleBarOptions);
  }
}
var OffscreenTextures$1;
(function(OffscreenTextures2) {
  OffscreenTextures2[OffscreenTextures2["COLOR"] = 0] = "COLOR";
  OffscreenTextures2[OffscreenTextures2["Z"] = 1] = "Z";
  OffscreenTextures2[OffscreenTextures2["PICK"] = 2] = "PICK";
  OffscreenTextures2[OffscreenTextures2["NUM_TEXTURES"] = 3] = "NUM_TEXTURES";
})(OffscreenTextures$1 || (OffscreenTextures$1 = {}));
const glsl_perspectivePanelEmit = `
void emit(vec4 color, highp uint pickId) {
  out_color = color;
  float zValue = 1.0 - gl_FragCoord.z;
  out_z = vec4(zValue, zValue, zValue, 1.0);
  float pickIdFloat = float(pickId);
  out_pickId = vec4(pickIdFloat, pickIdFloat, pickIdFloat, 1.0);
}
`;
const glsl_computeOITWeight = `
float computeOITWeight(float alpha) {
  float a = min(1.0, alpha) * 8.0 + 0.01;
  float b = -gl_FragCoord.z * 0.95 + 1.0;
  return a * a * a * b * b * b;
}
`;
const glsl_perspectivePanelEmitOIT = [glsl_computeOITWeight, `
void emit(vec4 color, highp uint pickId) {
  float weight = computeOITWeight(color.a);
  vec4 accum = color * weight;
  v4f_fragData0 = vec4(accum.rgb, color.a);
  v4f_fragData1 = vec4(accum.a, 0.0, 0.0, 0.0);
}
`];
function perspectivePanelEmit(builder) {
  builder.addOutputBuffer("vec4", `out_color`, OffscreenTextures$1.COLOR);
  builder.addOutputBuffer("highp vec4", `out_z`, OffscreenTextures$1.Z);
  builder.addOutputBuffer("highp vec4", `out_pickId`, OffscreenTextures$1.PICK);
  builder.addFragmentCode(glsl_perspectivePanelEmit);
}
function perspectivePanelEmitOIT(builder) {
  builder.addOutputBuffer("vec4", "v4f_fragData0", 0);
  builder.addOutputBuffer("vec4", "v4f_fragData1", 1);
  builder.addFragmentCode(glsl_perspectivePanelEmitOIT);
}
const tempVec3$3 = create$3();
const tempVec4$1 = create$2();
const tempMat4$4 = create$4();
function defineTransparencyCopyShader(builder) {
  builder.addOutputBuffer("vec4", "v4f_fragColor", null);
  builder.setFragmentMain(`
vec4 v0 = getValue0();
vec4 v1 = getValue1();
vec4 accum = vec4(v0.rgb, v1.r);
float revealage = v0.a;

v4f_fragColor = vec4(accum.rgb / accum.a, revealage);
`);
}
const PerspectiveViewStateBase = withSharedVisibility(SharedObject);
class PerspectiveViewState extends PerspectiveViewStateBase {
  constructor(panel) {
    super();
    this.panel = panel;
  }
  initializeCounterpart(rpc, options) {
    this.sharedProjectionParameters = this.registerDisposer(new SharedProjectionParameters(rpc, this.panel.projectionParameters));
    options.projectionParameters = this.sharedProjectionParameters.rpcId;
    super.initializeCounterpart(rpc, options);
  }
}
class PerspectivePanel extends RenderedDataPanel {
  constructor(context, element, viewer) {
    super(context, element, viewer);
    this.sliceViews = this.registerDisposer(new WatchableMap((context2, _unconditional, sliceView) => {
      context2.registerDisposer(sliceView);
      context2.registerDisposer(sliceView.visibility.add(this.visibility));
    }));
    this.axesLineHelper = this.registerDisposer(AxesLineHelper.get(this.gl));
    this.sliceViewRenderHelper = this.registerDisposer(SliceViewRenderHelper$2.get(this.gl, perspectivePanelEmit));
    this.offscreenFramebuffer = this.registerDisposer(new FramebufferConfiguration(this.gl, {
      colorBuffers: [new TextureBuffer(this.gl, WebGL2RenderingContext.RGBA8, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE), new TextureBuffer(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT), new TextureBuffer(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT)],
      depthBuffer: new DepthStencilRenderbuffer(this.gl)
    }));
    this.offscreenCopyHelper = this.registerDisposer(OffscreenCopyHelper.get(this.gl));
    this.transparencyCopyHelper = this.registerDisposer(OffscreenCopyHelper.get(this.gl, defineTransparencyCopyShader, 2));
    this.scaleBars = this.registerDisposer(new MultipleScaleBarTextures(this.gl));
    this.projectionParameters = this.registerDisposer(new DerivedProjectionParameters({
      navigationState: this.navigationState,
      update: (out, navigationState) => {
        const invViewMatrix = out.invViewMatrix, projectionMat = out.projectionMat, logicalWidth = out.logicalWidth, logicalHeight = out.logicalHeight;
        const widthOverHeight = logicalWidth / logicalHeight;
        const fovy = Math.PI / 4;
        let relativeDepthRange = navigationState.relativeDepthRange;
        const baseZoomFactor = navigationState.zoomFactor.value;
        let zoomFactor = baseZoomFactor / 2;
        if (this.viewer.orthographicProjection.value) {
          const nearBound = Math.max(0.1, 1 - relativeDepthRange);
          const farBound = 1 + relativeDepthRange;
          ortho(projectionMat, -widthOverHeight, widthOverHeight, -1, 1, nearBound, farBound);
        } else {
          const f = 1 / Math.tan(fovy / 2);
          relativeDepthRange /= f;
          const nearBound = Math.max(0.1, 1 - relativeDepthRange);
          const farBound = 1 + relativeDepthRange;
          zoomFactor *= f;
          perspective(projectionMat, fovy, widthOverHeight, nearBound, farBound);
        }
        applyRenderViewportToProjectionMatrix(out, projectionMat);
        navigationState.pose.toMat4(invViewMatrix, zoomFactor);
        scale$2(invViewMatrix, invViewMatrix, set$1(tempVec3$3, 1, -1, -1));
        translate(invViewMatrix, invViewMatrix, kAxes[2]);
        updateProjectionParametersFromInverseViewAndProjection(out);
      }
    }));
    this.projectionParameters.changed.add(() => this.context.scheduleRedraw());
    const sharedObject = this.sharedObject = this.registerDisposer(new PerspectiveViewState(this));
    sharedObject.RPC_TYPE_ID = PERSPECTIVE_VIEW_RPC_ID;
    sharedObject.initializeCounterpart(viewer.rpc, {});
    sharedObject.visibility.add(this.visibility);
    this.visibleLayerTracker = makeRenderedPanelVisibleLayerTracker(this.viewer.layerManager, PerspectiveViewRenderLayer, this.viewer.visibleLayerRoles, this);
    registerActionListener(element, "rotate-via-mouse-drag", (e) => {
      startRelativeMouseDrag(e.detail, (_event, deltaX, deltaY) => {
        this.navigationState.pose.rotateRelative(kAxes[1], deltaX / 4 * Math.PI / 180);
        this.navigationState.pose.rotateRelative(kAxes[0], -deltaY / 4 * Math.PI / 180);
      });
    });
    registerActionListener(element, "rotate-in-plane-via-touchrotate", (e) => {
      const detail = e.detail;
      this.navigationState.pose.rotateRelative(kAxes[2], detail.angle - detail.prevAngle);
    });
    registerActionListener(element, "rotate-out-of-plane-via-touchtranslate", (e) => {
      const detail = e.detail;
      this.navigationState.pose.rotateRelative(kAxes[1], detail.deltaX / 4 * Math.PI / 180);
      this.navigationState.pose.rotateRelative(kAxes[0], -detail.deltaY / 4 * Math.PI / 180);
    });
    if (viewer.showSliceViewsCheckbox) {
      let showSliceViewsCheckbox = this.registerDisposer(new TrackableBooleanCheckbox(viewer.showSliceViews));
      showSliceViewsCheckbox.element.className = "perspective-panel-show-slice-views neuroglancer-noselect";
      let showSliceViewsLabel = document.createElement("label");
      showSliceViewsLabel.className = "perspective-panel-show-slice-views neuroglancer-noselect";
      showSliceViewsLabel.appendChild(document.createTextNode("Sections"));
      showSliceViewsLabel.appendChild(showSliceViewsCheckbox.element);
      this.element.appendChild(showSliceViewsLabel);
    }
    this.registerDisposer(viewer.orthographicProjection.changed.add(() => {
      this.projectionParameters.update();
      this.scheduleRedraw();
    }));
    this.registerDisposer(viewer.showScaleBar.changed.add(() => this.scheduleRedraw()));
    this.registerDisposer(viewer.scaleBarOptions.changed.add(() => this.scheduleRedraw()));
    this.registerDisposer(viewer.showSliceViews.changed.add(() => this.scheduleRedraw()));
    this.registerDisposer(viewer.showAxisLines.changed.add(() => this.scheduleRedraw()));
    this.registerDisposer(viewer.crossSectionBackgroundColor.changed.add(() => this.scheduleRedraw()));
    this.registerDisposer(viewer.perspectiveViewBackgroundColor.changed.add(() => this.scheduleRedraw()));
    this.registerDisposer(viewer.wireFrame.changed.add(() => this.scheduleRedraw()));
    this.sliceViews.changed.add(() => this.scheduleRedraw());
  }
  get rpc() {
    return this.sharedObject.rpc;
  }
  get rpcId() {
    return this.sharedObject.rpcId;
  }
  get displayDimensionRenderInfo() {
    return this.navigationState.displayDimensionRenderInfo;
  }
  flushBackendProjectionParameters() {
    this.sharedObject.sharedProjectionParameters.flush();
  }
  translateByViewportPixels(deltaX, deltaY) {
    const temp = tempVec3$3;
    var _projectionParameters = this.projectionParameters.value;
    const viewProjectionMat = _projectionParameters.viewProjectionMat, invViewProjectionMat = _projectionParameters.invViewProjectionMat, logicalWidth = _projectionParameters.logicalWidth, logicalHeight = _projectionParameters.logicalHeight;
    const pose = this.viewer.navigationState.pose;
    pose.updateDisplayPosition((pos) => {
      transformMat4(temp, pos, viewProjectionMat);
      temp[0] += -2 * deltaX / logicalWidth;
      temp[1] += 2 * deltaY / logicalHeight;
      transformMat4(pos, temp, invViewProjectionMat);
    });
  }
  get navigationState() {
    return this.viewer.navigationState;
  }
  ensureBoundsUpdated() {
    super.ensureBoundsUpdated();
    this.projectionParameters.setViewport(this.renderViewport);
  }
  isReady() {
    if (!this.visible) {
      return true;
    }
    for (const _ref of this.sliceViews) {
      var _ref2 = _slicedToArray(_ref, 2);
      const sliceView = _ref2[0];
      const unconditional = _ref2[1];
      if (unconditional || this.viewer.showSliceViews.value) {
        if (!sliceView.isReady()) {
          return false;
        }
      }
    }
    this.ensureBoundsUpdated();
    var _renderViewport = this.renderViewport;
    const width = _renderViewport.width, height = _renderViewport.height;
    if (width === 0 || height === 0) {
      return true;
    }
    const projectionParameters = this.projectionParameters.value;
    const renderContext = {
      projectionParameters
    };
    const visibleLayers = this.visibleLayerTracker.visibleLayers;
    for (const _ref3 of visibleLayers) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const renderLayer = _ref4[0];
      const attachment = _ref4[1];
      if (!renderLayer.isReady(renderContext, attachment)) {
        return false;
      }
    }
    return true;
  }
  disposed() {
    this.sliceViews.clear();
    super.disposed();
  }
  getDepthArray() {
    if (!this.navigationState.valid) {
      return void 0;
    }
    const offscreenFramebuffer = this.offscreenFramebuffer;
    var _renderViewport2 = this.renderViewport;
    const width = _renderViewport2.width, height = _renderViewport2.height;
    const numPixels = width * height;
    const depthArrayRGBA = new Float32Array(numPixels * 4);
    try {
      offscreenFramebuffer.bindSingle(OffscreenTextures$1.Z);
      this.gl.readPixels(0, 0, width, height, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, depthArrayRGBA);
    } finally {
      offscreenFramebuffer.framebuffer.unbind();
    }
    const depthArray = new Float32Array(numPixels);
    for (let i = 0; i < numPixels; ++i) {
      depthArray[i] = depthArrayRGBA[i * 4];
    }
    return depthArray;
  }
  issuePickRequest(glWindowX, glWindowY) {
    const offscreenFramebuffer = this.offscreenFramebuffer;
    offscreenFramebuffer.readPixelFloat32IntoBuffer(OffscreenTextures$1.Z, glWindowX - pickRadius, glWindowY - pickRadius, 0, pickDiameter, pickDiameter);
    offscreenFramebuffer.readPixelFloat32IntoBuffer(OffscreenTextures$1.PICK, glWindowX - pickRadius, glWindowY - pickRadius, 4 * 4 * pickDiameter * pickDiameter, pickDiameter, pickDiameter);
  }
  completePickRequest(glWindowX, glWindowY, data, pickingData) {
    const mouseState = this.viewer.mouseState;
    mouseState.pickedRenderLayer = null;
    clearOutOfBoundsPickData(data, 0, 4, glWindowX, glWindowY, pickingData.viewportWidth, pickingData.viewportHeight);
    const numOffsets = pickOffsetSequence.length;
    for (let i = 0; i < numOffsets; ++i) {
      const offset = pickOffsetSequence[i];
      let zValue = data[4 * offset];
      if (zValue === 0) continue;
      const relativeX = offset % pickDiameter;
      const relativeY = (offset - relativeX) / pickDiameter;
      let glWindowZ = 1 - zValue;
      tempVec3$3[0] = 2 * (glWindowX + relativeX - pickRadius) / pickingData.viewportWidth - 1;
      tempVec3$3[1] = 2 * (glWindowY + relativeY - pickRadius) / pickingData.viewportHeight - 1;
      tempVec3$3[2] = 2 * glWindowZ - 1;
      transformMat4(tempVec3$3, tempVec3$3, pickingData.invTransform);
      let mousePosition = mouseState.position, unsnappedPosition = mouseState.unsnappedPosition;
      const voxelCoordinates = this.navigationState.position.value;
      const rank = voxelCoordinates.length;
      if (mousePosition.length !== rank) {
        mousePosition = mouseState.position = new Float32Array(rank);
      }
      if (unsnappedPosition.length !== rank) {
        unsnappedPosition = mouseState.unsnappedPosition = new Float32Array(rank);
      }
      mousePosition.set(voxelCoordinates);
      mouseState.coordinateSpace = this.navigationState.coordinateSpace.value;
      const displayDimensions = this.navigationState.pose.displayDimensions.value;
      const displayDimensionIndices = displayDimensions.displayDimensionIndices;
      for (let i2 = 0, spatialRank = displayDimensionIndices.length; i2 < spatialRank; ++i2) {
        mousePosition[displayDimensionIndices[i2]] = tempVec3$3[i2];
      }
      unsnappedPosition.set(mousePosition);
      const pickValue = data[4 * pickDiameter * pickDiameter + 4 * offset];
      pickingData.pickIDs.setMouseState(mouseState, pickValue);
      mouseState.displayDimensions = displayDimensions;
      mouseState.setActive(true);
      return;
    }
    mouseState.setActive(false);
  }
  translateDataPointByViewportPixels(out, orig, deltaX, deltaY) {
    const temp = tempVec3$3;
    var _projectionParameters2 = this.projectionParameters.value;
    const viewProjectionMat = _projectionParameters2.viewProjectionMat, invViewProjectionMat = _projectionParameters2.invViewProjectionMat, width = _projectionParameters2.width, height = _projectionParameters2.height;
    transformMat4(temp, orig, viewProjectionMat);
    temp[0] += 2 * deltaX / width;
    temp[1] += -2 * deltaY / height;
    return transformMat4(out, temp, invViewProjectionMat);
  }
  get transparentConfiguration() {
    let transparentConfiguration = this.transparentConfiguration_;
    if (transparentConfiguration === void 0) {
      transparentConfiguration = this.transparentConfiguration_ = this.registerDisposer(new FramebufferConfiguration(this.gl, {
        colorBuffers: makeTextureBuffers(this.gl, 2, this.gl.RGBA32F, this.gl.RGBA, this.gl.FLOAT),
        depthBuffer: this.offscreenFramebuffer.depthBuffer.addRef()
      }));
    }
    return transparentConfiguration;
  }
  drawWithPicking(pickingData) {
    if (!this.navigationState.valid) {
      return false;
    }
    var _renderViewport3 = this.renderViewport;
    const width = _renderViewport3.width, height = _renderViewport3.height;
    const showSliceViews = this.viewer.showSliceViews.value;
    for (const _ref5 of this.sliceViews) {
      var _ref6 = _slicedToArray(_ref5, 2);
      const sliceView = _ref6[0];
      const unconditional = _ref6[1];
      if (unconditional || showSliceViews) {
        sliceView.updateRendering();
      }
    }
    let gl = this.gl;
    this.offscreenFramebuffer.bind(width, height);
    gl.disable(gl.SCISSOR_TEST);
    gl.enable(WebGL2RenderingContext.STENCIL_TEST);
    gl.stencilMask(4294967295);
    gl.clearStencil(0);
    gl.clear(WebGL2RenderingContext.STENCIL_BUFFER_BIT);
    gl.stencilOp(
      /*sfail=*/
      WebGL2RenderingContext.KEEP,
      /*dpfail=*/
      WebGL2RenderingContext.KEEP,
      /*dppass=*/
      WebGL2RenderingContext.REPLACE
    );
    gl.stencilFunc(
      /*func=*/
      WebGL2RenderingContext.ALWAYS,
      /*ref=*/
      1,
      /*mask=*/
      1
    );
    const backgroundColor = this.viewer.perspectiveViewBackgroundColor.value;
    this.gl.clearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], 0);
    gl.clear(gl.DEPTH_BUFFER_BIT);
    gl.clearBufferfv(WebGL2RenderingContext.COLOR, OffscreenTextures$1.COLOR, [backgroundColor[0], backgroundColor[1], backgroundColor[2], 0]);
    gl.clearBufferfv(WebGL2RenderingContext.COLOR, OffscreenTextures$1.Z, kZeroVec4);
    gl.clearBufferfv(WebGL2RenderingContext.COLOR, OffscreenTextures$1.PICK, kZeroVec4);
    gl.enable(gl.DEPTH_TEST);
    const projectionParameters = this.projectionParameters.value;
    let lightingDirection = create$3();
    transformQuat(lightingDirection, kAxes[2], this.navigationState.pose.orientation.orientation);
    scale$1(lightingDirection, lightingDirection, -1);
    let ambient = 0.2;
    let directional = 1 - ambient;
    const renderContext = {
      wireFrame: this.viewer.wireFrame.value,
      projectionParameters,
      lightDirection: lightingDirection,
      ambientLighting: ambient,
      directionalLighting: directional,
      pickIDs: pickingData.pickIDs,
      emitter: perspectivePanelEmit,
      emitColor: true,
      emitPickID: true,
      alreadyEmittedPickID: false
    };
    copy$4(pickingData.invTransform, projectionParameters.invViewProjectionMat);
    const visibleLayers = this.visibleLayerTracker.visibleLayers;
    let hasTransparent = false;
    let hasAnnotation = false;
    for (const _ref7 of visibleLayers) {
      var _ref8 = _slicedToArray(_ref7, 2);
      const renderLayer = _ref8[0];
      const attachment = _ref8[1];
      if (!renderLayer.isTransparent) {
        if (!renderLayer.isAnnotation) {
          renderLayer.draw(renderContext, attachment);
        } else {
          hasAnnotation = true;
        }
      } else {
        hasTransparent = true;
      }
    }
    this.drawSliceViews(renderContext);
    if (hasAnnotation) {
      gl.enable(WebGL2RenderingContext.BLEND);
      gl.depthFunc(WebGL2RenderingContext.LEQUAL);
      gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
      for (const _ref9 of visibleLayers) {
        var _ref10 = _slicedToArray(_ref9, 2);
        const renderLayer = _ref10[0];
        const attachment = _ref10[1];
        if (renderLayer.isAnnotation) {
          renderLayer.draw(renderContext, attachment);
        }
      }
      gl.depthFunc(WebGL2RenderingContext.LESS);
      gl.disable(WebGL2RenderingContext.BLEND);
    }
    if (this.viewer.showAxisLines.value) {
      this.drawAxisLines();
    }
    gl.stencilOp(
      /*sfail=*/
      WebGL2RenderingContext.KEEP,
      /*dpfail=*/
      WebGL2RenderingContext.KEEP,
      /*dppass=*/
      WebGL2RenderingContext.KEEP
    );
    if (hasTransparent) {
      gl.depthMask(false);
      gl.enable(WebGL2RenderingContext.BLEND);
      const transparentConfiguration = this.transparentConfiguration;
      transparentConfiguration.bind(width, height);
      this.gl.clearColor(0, 0, 0, 1);
      gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
      renderContext.emitter = perspectivePanelEmitOIT;
      gl.blendFuncSeparate(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
      renderContext.emitPickID = false;
      for (const _ref11 of visibleLayers) {
        var _ref12 = _slicedToArray(_ref11, 2);
        const renderLayer = _ref12[0];
        const attachment = _ref12[1];
        if (renderLayer.isTransparent) {
          renderLayer.draw(renderContext, attachment);
        }
      }
      gl.disable(WebGL2RenderingContext.DEPTH_TEST);
      this.offscreenFramebuffer.bindSingle(OffscreenTextures$1.COLOR);
      gl.blendFunc(WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA, WebGL2RenderingContext.SRC_ALPHA);
      this.transparencyCopyHelper.draw(transparentConfiguration.colorBuffers[0].texture, transparentConfiguration.colorBuffers[1].texture);
      gl.depthMask(true);
      gl.disable(WebGL2RenderingContext.BLEND);
      gl.enable(WebGL2RenderingContext.DEPTH_TEST);
      this.offscreenFramebuffer.bind(width, height);
      gl.enable(WebGL2RenderingContext.STENCIL_TEST);
      gl.drawBuffers([gl.NONE, gl.COLOR_ATTACHMENT1, gl.COLOR_ATTACHMENT2]);
      renderContext.emitter = perspectivePanelEmit;
      renderContext.emitPickID = true;
      renderContext.emitColor = false;
      gl.stencilFunc(
        /*func=*/
        WebGL2RenderingContext.NOTEQUAL,
        /*ref=*/
        3,
        /*mask=*/
        1
      );
      gl.stencilOp(
        /*sfail=*/
        WebGL2RenderingContext.KEEP,
        /*dpfail=*/
        WebGL2RenderingContext.KEEP,
        /*dppass=*/
        WebGL2RenderingContext.REPLACE
      );
      gl.stencilMask(2);
      for (const _ref13 of visibleLayers) {
        var _ref14 = _slicedToArray(_ref13, 2);
        const renderLayer = _ref14[0];
        const attachment = _ref14[1];
        if (!renderLayer.isTransparent || !renderLayer.transparentPickEnabled) {
          continue;
        }
        renderLayer.draw(renderContext, attachment);
      }
      gl.stencilFunc(
        /*func=*/
        WebGL2RenderingContext.EQUAL,
        /*ref=*/
        0,
        /*mask=*/
        3
      );
      gl.stencilOp(
        /*sfail=*/
        WebGL2RenderingContext.KEEP,
        /*dpfail=*/
        WebGL2RenderingContext.KEEP,
        /*dppass=*/
        WebGL2RenderingContext.KEEP
      );
      gl.stencilMask(0);
      for (const _ref15 of visibleLayers) {
        var _ref16 = _slicedToArray(_ref15, 2);
        const renderLayer = _ref16[0];
        const attachment = _ref16[1];
        if (!renderLayer.isTransparent || renderLayer.transparentPickEnabled) {
          continue;
        }
        renderLayer.draw(renderContext, attachment);
      }
    }
    gl.stencilMask(4294967295);
    gl.disable(WebGL2RenderingContext.STENCIL_TEST);
    if (this.viewer.showScaleBar.value && this.viewer.orthographicProjection.value) {
      gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
      gl.disable(WebGL2RenderingContext.DEPTH_TEST);
      gl.enable(WebGL2RenderingContext.BLEND);
      gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
      const scaleBars = this.scaleBars;
      const options = this.viewer.scaleBarOptions.value;
      scaleBars.draw(this.renderViewport, this.navigationState.displayDimensionRenderInfo.value, this.navigationState.relativeDisplayScales.value, this.navigationState.zoomFactor.value / this.renderViewport.logicalHeight, options);
      gl.disable(WebGL2RenderingContext.BLEND);
    }
    this.offscreenFramebuffer.unbind();
    this.setGLClippedViewport();
    this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[OffscreenTextures$1.COLOR].texture);
    return true;
  }
  drawSliceViews(renderContext) {
    let sliceViewRenderHelper = this.sliceViewRenderHelper;
    let lightDirection = renderContext.lightDirection, ambientLighting = renderContext.ambientLighting, directionalLighting = renderContext.directionalLighting, viewProjectionMat = renderContext.projectionParameters.viewProjectionMat;
    const showSliceViews = this.viewer.showSliceViews.value;
    for (const _ref17 of this.sliceViews) {
      var _ref18 = _slicedToArray(_ref17, 2);
      const sliceView = _ref18[0];
      const unconditional = _ref18[1];
      if (!unconditional && !showSliceViews) {
        continue;
      }
      var _sliceView$projection = sliceView.projectionParameters.value;
      const sliceViewWidth = _sliceView$projection.width, sliceViewHeight = _sliceView$projection.height, sliceViewInvViewMatrix = _sliceView$projection.invViewMatrix, viewportNormalInCanonicalCoordinates = _sliceView$projection.viewportNormalInCanonicalCoordinates;
      if (sliceViewWidth === 0 || sliceViewHeight === 0 || !sliceView.valid) {
        continue;
      }
      let scalar = Math.abs(dot(lightDirection, viewportNormalInCanonicalCoordinates));
      let factor = ambientLighting + scalar * directionalLighting;
      let mat = tempMat4$4;
      identity$2(mat);
      mat[0] = sliceViewWidth / 2;
      mat[5] = -sliceViewHeight / 2;
      multiply$3(mat, sliceViewInvViewMatrix, mat);
      multiply$3(mat, viewProjectionMat, mat);
      const backgroundColor = tempVec4$1;
      const crossSectionBackgroundColor = this.viewer.crossSectionBackgroundColor.value;
      backgroundColor[0] = crossSectionBackgroundColor[0];
      backgroundColor[1] = crossSectionBackgroundColor[1];
      backgroundColor[2] = crossSectionBackgroundColor[2];
      backgroundColor[3] = 1;
      sliceViewRenderHelper.draw(sliceView.offscreenFramebuffer.colorBuffers[0].texture, mat, fromValues(factor, factor, factor, 1), tempVec4$1, 0, 0, 1, 1);
    }
  }
  drawAxisLines() {
    const zoom = this.viewer.navigationState.zoomFactor.value;
    const projectionParameters = this.projectionParameters.value;
    const axisRatio = Math.min(projectionParameters.logicalWidth, projectionParameters.logicalHeight) / this.renderViewport.logicalHeight / 4;
    const axisLength = zoom * axisRatio;
    const gl = this.gl;
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    this.axesLineHelper.draw(
      computeAxisLineMatrix(projectionParameters, axisLength),
      /*blend=*/
      false
    );
  }
  zoomByMouse(factor) {
    this.navigationState.zoomBy(factor);
  }
}
var OffscreenTextures;
(function(OffscreenTextures2) {
  OffscreenTextures2[OffscreenTextures2["COLOR"] = 0] = "COLOR";
  OffscreenTextures2[OffscreenTextures2["PICK"] = 1] = "PICK";
  OffscreenTextures2[OffscreenTextures2["NUM_TEXTURES"] = 2] = "NUM_TEXTURES";
})(OffscreenTextures || (OffscreenTextures = {}));
function sliceViewPanelEmitColorAndPickID(builder) {
  builder.addOutputBuffer("vec4", "out_fragColor", 0);
  builder.addOutputBuffer("highp vec4", "out_pickId", 1);
  builder.addFragmentCode(`
void emit(vec4 color, highp uint pickId) {
  out_fragColor = color;
  float pickIdFloat = float(pickId);
  out_pickId = vec4(pickIdFloat, pickIdFloat, pickIdFloat, 1.0);
}
`);
}
function sliceViewPanelEmitColor(builder) {
  builder.addOutputBuffer("vec4", "out_fragColor", null);
  builder.addFragmentCode(`
void emit(vec4 color, highp uint pickId) {
  out_fragColor = color;
}
`);
}
const tempVec3$2 = create$3();
const tempVec3b$1 = create$3();
const tempVec4 = create$2();
class SliceViewPanel extends RenderedDataPanel {
  constructor(context, element, sliceView, viewer) {
    super(context, element, viewer);
    this.sliceView = sliceView;
    this.axesLineHelper = this.registerDisposer(AxesLineHelper.get(this.gl));
    this.sliceViewRenderHelper = this.registerDisposer(SliceViewRenderHelper$2.get(this.gl, sliceViewPanelEmitColor));
    this.colorFactor = fromValues(1, 1, 1, 1);
    this.pickIDs = new PickIDManager();
    this.offscreenFramebuffer = this.registerDisposer(new FramebufferConfiguration(this.gl, {
      colorBuffers: [new TextureBuffer(this.gl, WebGL2RenderingContext.RGBA8, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE), new TextureBuffer(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT)]
    }));
    this.offscreenCopyHelper = this.registerDisposer(OffscreenCopyHelper.get(this.gl));
    this.scaleBars = this.registerDisposer(new MultipleScaleBarTextures(this.gl));
    viewer.wireFrame.changed.add(() => this.scheduleRedraw());
    registerActionListener(element, "rotate-via-mouse-drag", (e) => {
      const mouseState = this.viewer.mouseState;
      if (mouseState.updateUnconditionally()) {
        const initialPosition = Float32Array.from(mouseState.position);
        startRelativeMouseDrag(e.detail, (_event, deltaX, deltaY) => {
          const pose = this.navigationState.pose;
          const xAxis = transformQuat(tempVec3$2, kAxes[0], pose.orientation.orientation);
          const yAxis = transformQuat(tempVec3b$1, kAxes[1], pose.orientation.orientation);
          this.viewer.navigationState.pose.rotateAbsolute(yAxis, -deltaX / 4 * Math.PI / 180, initialPosition);
          this.viewer.navigationState.pose.rotateAbsolute(xAxis, -deltaY / 4 * Math.PI / 180, initialPosition);
        });
      }
    });
    registerActionListener(element, "rotate-in-plane-via-touchrotate", (e) => {
      const detail = e.detail;
      const mouseState = this.viewer.mouseState;
      this.handleMouseMove(detail.centerX, detail.centerY);
      if (mouseState.updateUnconditionally()) {
        this.navigationState.pose.rotateAbsolute(this.sliceView.projectionParameters.value.viewportNormalInCanonicalCoordinates, detail.angle - detail.prevAngle, mouseState.position);
      }
    });
    this.registerDisposer(sliceView);
    this.visibleLayerTracker = makeRenderedPanelVisibleLayerTracker(this.viewer.layerManager, SliceViewPanelRenderLayer, this.viewer.visibleLayerRoles, this);
    this.registerDisposer(viewer.crossSectionBackgroundColor.changed.add(() => this.scheduleRedraw()));
    this.registerDisposer(sliceView.visibility.add(this.visibility));
    this.registerDisposer(sliceView.viewChanged.add(() => {
      if (this.visible) {
        context.scheduleRedraw();
      }
    }));
    this.registerDisposer(viewer.showAxisLines.changed.add(() => {
      if (this.visible) {
        this.scheduleRedraw();
      }
    }));
    this.registerDisposer(viewer.showScaleBar.changed.add(() => {
      if (this.visible) {
        this.context.scheduleRedraw();
      }
    }));
    this.registerDisposer(viewer.scaleBarOptions.changed.add(() => {
      if (this.visible) {
        this.context.scheduleRedraw();
      }
    }));
  }
  flushBackendProjectionParameters() {
    this.sliceView.flushBackendProjectionParameters();
  }
  get displayDimensionRenderInfo() {
    return this.navigationState.displayDimensionRenderInfo;
  }
  // FIXME: use separate backend object for the panel
  get rpc() {
    return this.sliceView.rpc;
  }
  get rpcId() {
    return this.sliceView.rpcId;
  }
  get navigationState() {
    return this.sliceView.navigationState;
  }
  translateByViewportPixels(deltaX, deltaY) {
    const pose = this.viewer.navigationState.pose;
    pose.updateDisplayPosition((pos) => {
      set$1(pos, -deltaX, -deltaY, 0);
      transformMat4(pos, pos, this.sliceView.projectionParameters.value.invViewMatrix);
    });
  }
  translateDataPointByViewportPixels(out, orig, deltaX, deltaY) {
    const projectionParameters = this.sliceView.projectionParameters.value;
    transformMat4(out, orig, projectionParameters.viewMatrix);
    set$1(out, out[0] + deltaX, out[1] + deltaY, out[2]);
    transformMat4(out, out, projectionParameters.invViewMatrix);
    return out;
  }
  isReady() {
    if (!this.visible) {
      return false;
    }
    const sliceView = this.sliceView;
    this.ensureBoundsUpdated();
    if (!sliceView.isReady()) {
      return false;
    }
    const renderContext = {
      projectionParameters: sliceView.projectionParameters.value,
      sliceView
    };
    for (const _ref of this.visibleLayerTracker.visibleLayers) {
      var _ref2 = _slicedToArray(_ref, 2);
      const renderLayer = _ref2[0];
      const attachment = _ref2[1];
      if (!renderLayer.isReady(renderContext, attachment)) {
        return false;
      }
    }
    return true;
  }
  drawWithPicking(pickingData) {
    const sliceView = this.sliceView;
    if (!sliceView.valid) {
      return false;
    }
    sliceView.updateRendering();
    const projectionParameters = sliceView.projectionParameters.value;
    const width = projectionParameters.width, height = projectionParameters.height, invViewProjectionMat = projectionParameters.invViewProjectionMat;
    copy$4(pickingData.invTransform, invViewProjectionMat);
    const gl = this.gl;
    this.offscreenFramebuffer.bind(width, height);
    gl.disable(WebGL2RenderingContext.SCISSOR_TEST);
    this.gl.clearColor(0, 0, 0, 0);
    gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
    const backgroundColor = tempVec4;
    const crossSectionBackgroundColor = this.viewer.crossSectionBackgroundColor.value;
    backgroundColor[0] = crossSectionBackgroundColor[0];
    backgroundColor[1] = crossSectionBackgroundColor[1];
    backgroundColor[2] = crossSectionBackgroundColor[2];
    backgroundColor[3] = 1;
    this.offscreenFramebuffer.bindSingle(OffscreenTextures.COLOR);
    this.sliceViewRenderHelper.draw(sliceView.offscreenFramebuffer.colorBuffers[0].texture, identityMat4, this.colorFactor, backgroundColor, 0, 0, 1, 1);
    const visibleLayers = this.visibleLayerTracker.visibleLayers;
    let pickIDs = this.pickIDs;
    pickIDs.clear();
    const renderContext = {
      wireFrame: this.viewer.wireFrame.value,
      projectionParameters,
      pickIDs,
      emitter: sliceViewPanelEmitColorAndPickID,
      emitColor: true,
      emitPickID: true,
      sliceView
    };
    this.offscreenFramebuffer.bind(width, height);
    gl.enable(WebGL2RenderingContext.BLEND);
    gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
    for (const _ref3 of visibleLayers) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const renderLayer = _ref4[0];
      const attachment = _ref4[1];
      renderLayer.draw(renderContext, attachment);
    }
    gl.disable(WebGL2RenderingContext.BLEND);
    if (this.viewer.showAxisLines.value || this.viewer.showScaleBar.value) {
      this.offscreenFramebuffer.bindSingle(OffscreenTextures.COLOR);
      if (this.viewer.showAxisLines.value) {
        const axisLength = Math.min(projectionParameters.logicalWidth, projectionParameters.logicalHeight) / 4 * 1.5;
        const zoom = this.viewer.navigationState.zoomFactor.value;
        this.axesLineHelper.draw(disableZProjection(computeAxisLineMatrix(projectionParameters, axisLength * zoom)));
      }
      if (this.viewer.showScaleBar.value) {
        gl.enable(WebGL2RenderingContext.BLEND);
        gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
        this.scaleBars.draw(projectionParameters, this.navigationState.displayDimensionRenderInfo.value, this.navigationState.relativeDisplayScales.value, this.navigationState.zoomFactor.value, this.viewer.scaleBarOptions.value);
        gl.disable(WebGL2RenderingContext.BLEND);
      }
    }
    this.offscreenFramebuffer.unbind();
    this.setGLClippedViewport();
    this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[OffscreenTextures.COLOR].texture);
    return true;
  }
  ensureBoundsUpdated() {
    super.ensureBoundsUpdated();
    this.sliceView.projectionParameters.setViewport(this.renderViewport);
  }
  issuePickRequest(glWindowX, glWindowY) {
    const offscreenFramebuffer = this.offscreenFramebuffer;
    offscreenFramebuffer.readPixelFloat32IntoBuffer(OffscreenTextures.PICK, glWindowX - pickRadius, glWindowY - pickRadius, 0, pickDiameter, pickDiameter);
  }
  completePickRequest(glWindowX, glWindowY, data, pickingData) {
    const mouseState = this.viewer.mouseState;
    mouseState.pickedRenderLayer = null;
    clearOutOfBoundsPickData(data, 0, 4, glWindowX, glWindowY, pickingData.viewportWidth, pickingData.viewportHeight);
    const viewportWidth = pickingData.viewportWidth, viewportHeight = pickingData.viewportHeight;
    const numOffsets = pickOffsetSequence.length;
    const voxelCoordinates = this.navigationState.position.value;
    const rank = voxelCoordinates.length;
    const displayDimensions = this.navigationState.pose.displayDimensions.value;
    const displayRank = displayDimensions.displayRank, displayDimensionIndices = displayDimensions.displayDimensionIndices;
    const setPosition = (xOffset, yOffset, position) => {
      const x = glWindowX + xOffset;
      const y = glWindowY + yOffset;
      tempVec3$2[0] = 2 * x / viewportWidth - 1;
      tempVec3$2[1] = 2 * y / viewportHeight - 1;
      tempVec3$2[2] = 0;
      transformMat4(tempVec3$2, tempVec3$2, pickingData.invTransform);
      position.set(voxelCoordinates);
      for (let i = 0; i < displayRank; ++i) {
        position[displayDimensionIndices[i]] = tempVec3$2[i];
      }
    };
    let unsnappedPosition = mouseState.unsnappedPosition;
    if (unsnappedPosition.length !== rank) {
      unsnappedPosition = mouseState.unsnappedPosition = new Float32Array(rank);
    }
    mouseState.coordinateSpace = this.navigationState.coordinateSpace.value;
    mouseState.displayDimensions = displayDimensions;
    setPosition(0, 0, unsnappedPosition);
    const setStateFromRelative = (relativeX, relativeY, pickId) => {
      let mousePosition = mouseState.position;
      if (mousePosition.length !== rank) {
        mousePosition = mouseState.position = new Float32Array(rank);
      }
      setPosition(relativeX - pickRadius, relativeY - pickRadius, mousePosition);
      this.pickIDs.setMouseState(mouseState, pickId);
      mouseState.setActive(true);
    };
    for (let i = 0; i < numOffsets; ++i) {
      const offset = pickOffsetSequence[i];
      const pickId = data[4 * i];
      if (pickId === 0) continue;
      const relativeX = offset % pickDiameter;
      const relativeY = (offset - relativeX) / pickDiameter;
      setStateFromRelative(relativeX, relativeY, pickId);
      return;
    }
    setStateFromRelative(pickRadius, pickRadius, 0);
  }
  /**
   * Zooms by the specified factor, maintaining the data position that projects to the current mouse
   * position.
   */
  zoomByMouse(factor) {
    const navigationState = this.navigationState;
    if (!navigationState.valid) {
      return;
    }
    const sliceView = this.sliceView;
    var _sliceView$projection = sliceView.projectionParameters.value;
    const width = _sliceView$projection.width, height = _sliceView$projection.height, invViewMatrix = _sliceView$projection.invViewMatrix;
    var _sliceView$projection2 = _sliceView$projection.displayDimensionRenderInfo;
    const displayDimensionIndices = _sliceView$projection2.displayDimensionIndices, displayRank = _sliceView$projection2.displayRank;
    let mouseX = this.mouseX, mouseY = this.mouseY;
    mouseX -= width / 2;
    mouseY -= height / 2;
    const position = this.navigationState.position.value;
    for (let i = 0; i < displayRank; ++i) {
      const dim = displayDimensionIndices[i];
      const f = invViewMatrix[i] * mouseX + invViewMatrix[4 + i] * mouseY;
      position[dim] += f * (1 - factor);
    }
    this.navigationState.position.changed.dispatch();
    navigationState.zoomBy(factor);
  }
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function numberToStringFixed(v, maxDigits) {
  let s = "";
  for (let digits = 0; digits <= maxDigits; ++digits) {
    s = v.toFixed(digits);
    if (parseFloat(s) === v) {
      break;
    }
  }
  return s;
}
const dimensionColors = ["#f00", "#0f0", "#00f"];
const inputEventMap$4 = EventActionMap.fromObject({
  "arrowup": { action: "move-up" },
  "arrowdown": { action: "move-down" },
  "wheel": { action: "adjust-via-wheel" },
  "enter": { action: "commit" },
  "escape": { action: "cancel" }
});
function formatScaleFactor(x) {
  if (x < 1 || x > 1024) {
    const exponent = _Math$log$1(x) | 0;
    const coeff = x / 2 ** exponent;
    return `${numberToStringFixed(coeff, 1)}p${exponent}`;
  }
  return x.toString();
}
const widgetFieldGetters$1 = [(x) => x.name, (x) => x.scaleFactor];
const postActivityDisplayPeriod = 2e3;
class DisplayDimensionsWidget extends RefCounted {
  constructor(displayDimensionRenderInfo, zoom, depthRange, displayUnit = "px") {
    super();
    this.displayDimensionRenderInfo = displayDimensionRenderInfo;
    this.zoom = zoom;
    this.depthRange = depthRange;
    this.displayUnit = displayUnit;
    this.element = document.createElement("div");
    this.dimensionGridContainer = document.createElement("div");
    this.depthGridContainer = document.createElement("div");
    this.defaultCheckbox = document.createElement("input");
    this.dimensionElements = _Array$from(Array(3), (_, i) => {
      const container = document.createElement("div");
      container.classList.add("neuroglancer-display-dimensions-widget-dimension");
      container.style.display = "contents";
      registerActionListener(container, "adjust-via-wheel", (actionEvent) => {
        const event = actionEvent.detail;
        const deltaY = event.deltaY;
        if (deltaY === 0) {
          return;
        }
        this.zoomDimension(i, _Math$sign(deltaY));
      });
      const name2 = document.createElement("input");
      name2.classList.add("neuroglancer-display-dimensions-widget-name");
      name2.title = "Change display dimensions";
      name2.spellcheck = false;
      name2.autocomplete = "off";
      name2.style.color = dimensionColors[i];
      name2.style.gridColumn = "1";
      name2.style.gridRow = `${i + 1}`;
      name2.addEventListener("focus", () => {
        name2.select();
      });
      container.appendChild(name2);
      const scaleFactorContainer = document.createElement("span");
      scaleFactorContainer.classList.add("neuroglancer-display-dimensions-widget-scale-factor");
      const scaleFactor = document.createElement("input");
      scaleFactor.spellcheck = false;
      scaleFactor.title = "Change relative scale at which dimension is displayed";
      scaleFactor.autocomplete = "off";
      scaleFactorContainer.style.gridColumn = "2";
      scaleFactorContainer.style.gridRow = `${i + 1}`;
      scaleFactor.addEventListener("focus", () => {
        scaleFactor.select();
      });
      scaleFactorContainer.appendChild(scaleFactor);
      container.appendChild(scaleFactorContainer);
      const scale2 = document.createElement("span");
      scale2.classList.add("neuroglancer-display-dimensions-widget-scale");
      scale2.style.gridColumn = "3";
      scale2.style.gridRow = `${i + 1}`;
      container.appendChild(scale2);
      this.dimensionGridContainer.appendChild(container);
      const dimWidget = {
        name: name2,
        container,
        scaleFactor,
        scale: scale2,
        scaleFactorModified: false
      };
      name2.addEventListener("input", () => {
        updateInputFieldWidth$1(name2);
        this.updateNameValidity();
      });
      registerActionListener(name2, "commit", () => {
        this.updateNames();
      });
      name2.addEventListener("blur", (event) => {
        const relatedTarget = event.relatedTarget;
        if (this.dimensionElements.some((x) => x.name === relatedTarget)) {
          return;
        }
        if (!this.updateNames()) {
          this.updateView();
        }
      });
      scaleFactorContainer.addEventListener("click", (event) => {
        const target = event.target;
        if (target === scaleFactor) return;
        scaleFactor.focus();
        event.preventDefault();
      });
      scaleFactor.addEventListener("input", () => {
        updateInputFieldWidth$1(scaleFactor);
        dimWidget.scaleFactorModified = true;
      });
      registerActionListener(scaleFactor, "commit", () => {
        this.updateScaleFactors();
      });
      scaleFactor.addEventListener("blur", () => {
        if (!this.updateScaleFactors()) {
          this.updateView();
        }
      });
      for (const getter of widgetFieldGetters$1) {
        registerActionListener(getter(dimWidget), "move-up", () => {
          if (i !== 0) {
            getter(this.dimensionElements[i - 1]).focus();
          }
        });
        registerActionListener(getter(dimWidget), "move-down", () => {
          if (i !== 2) {
            getter(this.dimensionElements[i + 1]).focus();
          }
        });
      }
      return dimWidget;
    });
    this.scheduleUpdateView = animationFrameDebounce(() => this.updateView());
    const element = this.element, dimensionGridContainer = this.dimensionGridContainer, defaultCheckbox = this.defaultCheckbox;
    const defaultCheckboxLabel = document.createElement("label");
    const hideWidgetDetails = this.registerCancellable(debounce(() => {
      element.dataset.active = "false";
    }, postActivityDisplayPeriod));
    const handleActivity = () => {
      element.dataset.active = "true";
      hideWidgetDetails();
    };
    this.registerDisposer(zoom.changed.add(handleActivity));
    this.registerDisposer(displayDimensionRenderInfo.relativeDisplayScales.changed.add(handleActivity));
    this.registerDisposer(depthRange.changed.add(handleActivity));
    element.classList.add("neuroglancer-display-dimensions-widget");
    element.appendChild(dimensionGridContainer);
    dimensionGridContainer.classList.add("neuroglancer-display-dimensions-widget-dimension-grid");
    element.addEventListener("pointerleave", () => {
      const focused = document.activeElement;
      if (focused instanceof HTMLElement && element.contains(focused)) {
        focused.blur();
      }
    });
    defaultCheckbox.type = "checkbox";
    defaultCheckboxLabel.appendChild(defaultCheckbox);
    defaultCheckboxLabel.appendChild(document.createTextNode("Default"));
    defaultCheckboxLabel.title = "Display first 3 dimensions";
    defaultCheckboxLabel.classList.add("neuroglancer-display-dimensions-widget-default");
    defaultCheckbox.addEventListener("change", () => {
      this.updateDefault();
    });
    dimensionGridContainer.appendChild(defaultCheckboxLabel);
    this.registerDisposer(displayDimensionRenderInfo);
    this.registerDisposer(depthRange);
    this.registerDisposer(zoom.changed.add(this.scheduleUpdateView));
    this.registerDisposer(displayDimensionRenderInfo.changed.add(this.scheduleUpdateView));
    const keyboardHandler = this.registerDisposer(new KeyboardEventBinder(element, inputEventMap$4));
    keyboardHandler.allShortcutsAreGlobal = true;
    this.registerDisposer(new MouseEventBinder(element, inputEventMap$4));
    registerActionListener(dimensionGridContainer, "cancel", () => {
      this.updateView();
      const focused = document.activeElement;
      if (focused instanceof HTMLElement && element.contains(focused)) {
        focused.blur();
      }
    });
    const depthGridContainer = this.depthGridContainer;
    depthGridContainer.classList.add("neuroglancer-depth-range-widget-grid");
    element.appendChild(depthGridContainer);
    const relativeCheckboxLabel = document.createElement("label");
    const relativeCheckbox = document.createElement("input");
    relativeCheckbox.type = "checkbox";
    relativeCheckboxLabel.classList.add("neuroglancer-depth-range-relative-checkbox-label");
    relativeCheckbox.classList.add("neuroglancer-depth-range-relative-checkbox");
    relativeCheckboxLabel.appendChild(relativeCheckbox);
    relativeCheckboxLabel.appendChild(document.createTextNode("Zoom-relative"));
    relativeCheckbox.addEventListener("change", () => {
      const relative = relativeCheckbox.checked;
      let value = this.depthRange.value;
      if (relative === value < 0) return;
      if (relative) {
        value = -value / this.zoom.value;
      } else {
        value = -value * this.zoom.value;
      }
      this.depthRange.value = value;
    });
    relativeCheckboxLabel.title = "Depth range is multiplied by scale";
    element.appendChild(relativeCheckboxLabel);
    registerActionListener(depthGridContainer, "adjust-via-wheel", (actionEvent) => {
      const event = actionEvent.detail;
      const deltaY = event.deltaY;
      if (deltaY === 0) {
        return;
      }
      const value = this.depthRange.value;
      this.depthRange.value = value * 2 ** _Math$sign(deltaY);
    });
    this.registerDisposer(registerNested((context, displayDimensionRenderInfoValue, { factors }) => {
      removeChildren(depthGridContainer);
      const displayRank = displayDimensionRenderInfoValue.displayRank, globalDimensionNames = displayDimensionRenderInfoValue.globalDimensionNames, displayDimensionIndices = displayDimensionRenderInfoValue.displayDimensionIndices, displayDimensionUnits = displayDimensionRenderInfoValue.displayDimensionUnits, displayDimensionScales = displayDimensionRenderInfoValue.displayDimensionScales, canonicalVoxelFactors = displayDimensionRenderInfoValue.canonicalVoxelFactors;
      const widgets = [];
      const updateView = () => {
        relativeCheckbox.checked = this.depthRange.value < 0;
        let rangeValue = this.depthRange.value;
        if (rangeValue < 0) {
          rangeValue *= -this.zoom.value;
        }
        for (const widget of widgets) {
          const input = widget.input;
          input.value = formatScaleWithUnitAsString(rangeValue * widget.scale, widget.unit, { precision: 2, elide1: false });
          updateInputFieldWidth$1(input);
        }
      };
      const updateModel = (widget) => {
        const result = parseScale(widget.input.value);
        if (result === void 0 || result.unit !== widget.unit) return false;
        let value = result.scale / widget.scale;
        if (this.depthRange.value < 0) {
          value = -value / this.zoom.value;
        }
        this.depthRange.value = value;
        return true;
      };
      for (let i = 0; i < displayRank; ++i) {
        const dim = displayDimensionIndices[i];
        const name2 = globalDimensionNames[dim];
        const unit = displayDimensionUnits[i];
        const factor = factors[dim];
        let widget = widgets.find((w) => w.unit === unit && w.factor === factor);
        if (widget === void 0) {
          const container = document.createElement("div");
          container.title = "Visible depth range";
          container.style.display = "contents";
          depthGridContainer.appendChild(container);
          const plusMinus = document.createElement("span");
          plusMinus.textContent = "±";
          container.appendChild(plusMinus);
          const input = document.createElement("input");
          input.spellcheck = false;
          input.autocomplete = "off";
          input.addEventListener("focus", () => {
            input.select();
          });
          registerActionListener(input, "commit", () => {
            updateModel(widget);
          });
          input.addEventListener("change", () => {
            if (!updateModel(widget)) {
              updateView();
            }
          });
          input.addEventListener("input", () => {
            updateInputFieldWidth$1(input);
          });
          container.appendChild(input);
          const label = document.createElement("span");
          label.classList.add("neuroglancer-depth-range-widget-dimension-names");
          container.appendChild(label);
          widget = {
            unit,
            factor,
            dimensionNames: [],
            input,
            label,
            scale: displayDimensionScales[i] / canonicalVoxelFactors[i]
          };
          widgets.push(widget);
        }
        widget.dimensionNames.push(name2);
      }
      for (const widget of widgets) {
        if (widget.dimensionNames.length !== displayRank) {
          widget.label.textContent = widget.dimensionNames.join(" ");
        }
      }
      context.registerDisposer(registerActionListener(depthGridContainer, "cancel", () => {
        updateView();
        const focused = document.activeElement;
        if (focused instanceof HTMLElement && depthGridContainer.contains(focused)) {
          focused.blur();
        }
      }));
      const debouncedUpdateView = context.registerCancellable(animationFrameDebounce(updateView));
      context.registerDisposer(this.depthRange.changed.add(debouncedUpdateView));
      context.registerDisposer(this.zoom.changed.add(debouncedUpdateView));
      updateView();
    }, displayDimensionRenderInfo, this.relativeDisplayScales));
    this.updateView();
  }
  zoomDimension(i, sign2) {
    this.updateScaleFactors();
    const displayDimensions = this.displayDimensions;
    const relativeDisplayScales = this.relativeDisplayScales;
    const displayDimensionIndices = displayDimensions.value.displayDimensionIndices;
    const dim = displayDimensionIndices[i];
    if (dim === -1) return;
    const factors = relativeDisplayScales.value.factors;
    const newFactors = new Float64Array(factors);
    newFactors[dim] *= 2 ** -sign2;
    relativeDisplayScales.setFactors(newFactors);
  }
  updateNameValidity() {
    const dimensionElements = this.dimensionElements;
    const displayDimensionIndices = this.displayDimensions.value.displayDimensionIndices;
    const displayDimensionNames = dimensionElements.map((w) => w.name.value);
    const isValid = getDimensionNameValidity(displayDimensionNames);
    const coordinateSpace = this.displayDimensions.coordinateSpace.value;
    const names = coordinateSpace.names;
    const rank = displayDimensionNames.length;
    for (let i = 0; i < rank; ++i) {
      let valid = isValid[i];
      const name2 = displayDimensionNames[i];
      let newIndex = -1;
      if (name2.length === 0) {
        valid = true;
      } else {
        newIndex = names.indexOf(name2);
        if (newIndex === -1) {
          valid = false;
        }
      }
      const dimElements = dimensionElements[i];
      dimElements.name.dataset.isValid = valid.toString();
      dimElements.container.dataset.isModified = (newIndex !== displayDimensionIndices[i]).toString();
    }
  }
  get displayDimensions() {
    return this.displayDimensionRenderInfo.displayDimensions;
  }
  get relativeDisplayScales() {
    return this.displayDimensionRenderInfo.relativeDisplayScales;
  }
  updateNames() {
    const displayDimensionNames = this.dimensionElements.map((x) => x.name.value).filter((x) => x.length > 0);
    if (!validateDimensionNames(displayDimensionNames)) return false;
    const displayDimensions = this.displayDimensionRenderInfo.displayDimensions;
    if (displayDimensionNames.length === 0) {
      displayDimensions.reset();
      return true;
    }
    const dimensionIndices = new Int32Array(3);
    dimensionIndices.fill(-1);
    const coordinateSpace = displayDimensions.coordinateSpace.value;
    const names = coordinateSpace.names;
    const rank = displayDimensionNames.length;
    for (let i = 0; i < rank; ++i) {
      const index2 = names.indexOf(displayDimensionNames[i]);
      if (index2 === -1) return false;
      dimensionIndices[i] = index2;
    }
    if (arraysEqual(dimensionIndices, displayDimensions.value.displayDimensionIndices)) {
      return true;
    }
    displayDimensions.setDimensionIndices(rank, dimensionIndices);
    return true;
  }
  updateDefault() {
    this.displayDimensions.default = this.defaultCheckbox.checked;
  }
  updateScaleFactors() {
    const displayDimensions = this.displayDimensions;
    const relativeDisplayScales = this.relativeDisplayScales;
    var _displayDimensions$va = displayDimensions.value;
    const displayDimensionIndices = _displayDimensions$va.displayDimensionIndices, displayRank = _displayDimensions$va.displayRank;
    const factors = relativeDisplayScales.value.factors;
    const dimensionElements = this.dimensionElements;
    const newFactors = new Float64Array(factors);
    for (let i = 0; i < displayRank; ++i) {
      const dimElements = dimensionElements[i];
      if (!dimElements.scaleFactorModified) continue;
      const factor = Number(dimElements.scaleFactor.value);
      const dim = displayDimensionIndices[i];
      if (!_Number$isFinite(factor) || factor <= 0) continue;
      newFactors[dim] = factor;
    }
    if (!arraysEqual(newFactors, factors)) {
      relativeDisplayScales.setFactors(newFactors);
    }
    return true;
  }
  updateView() {
    const dimensionElements = this.dimensionElements, isDefault = this.displayDimensions.default;
    var _displayDimensionRend = this.displayDimensionRenderInfo.value;
    const displayDimensionIndices = _displayDimensionRend.displayDimensionIndices, canonicalVoxelFactors = _displayDimensionRend.canonicalVoxelFactors, displayDimensionUnits = _displayDimensionRend.displayDimensionUnits, displayDimensionScales = _displayDimensionRend.displayDimensionScales, globalDimensionNames = _displayDimensionRend.globalDimensionNames;
    const factors = this.relativeDisplayScales.value.factors;
    this.defaultCheckbox.checked = isDefault;
    const zoom = this.zoom.value;
    const firstDim = displayDimensionIndices[0];
    let singleScale = true;
    if (firstDim !== -1) {
      const unit = displayDimensionUnits[0];
      const factor = factors[firstDim];
      for (let i = 1; i < 3; ++i) {
        const dim = displayDimensionIndices[i];
        if (dim === -1) continue;
        if (displayDimensionUnits[i] !== unit || factors[dim] !== factor) {
          singleScale = false;
          break;
        }
      }
    }
    for (let i = 0; i < 3; ++i) {
      const dim = displayDimensionIndices[i];
      const dimElements = dimensionElements[i];
      delete dimElements.name.dataset.isValid;
      dimElements.container.dataset.isModified = (dim === -1).toString();
      if (dim === -1) {
        dimElements.name.value = "";
        dimElements.scale.textContent = "";
        dimElements.scaleFactor.value = "";
      } else {
        dimElements.name.value = globalDimensionNames[dim];
        const totalScale = displayDimensionScales[i] * zoom / canonicalVoxelFactors[i];
        if (i === 0 || !singleScale) {
          const formattedScale = formatScaleWithUnitAsString(totalScale, displayDimensionUnits[i], { precision: 2, elide1: false });
          dimElements.scale.textContent = `${formattedScale}/${this.displayUnit}`;
        } else {
          dimElements.scale.textContent = "";
        }
        dimElements.scaleFactor.value = formatScaleFactor(factors[dim]);
      }
      updateInputFieldWidth$1(dimElements.name);
      updateInputFieldWidth$1(dimElements.scaleFactor);
    }
  }
  disposed() {
    removeFromParent(this.element);
    super.disposed();
  }
}
const AXES_RELATIVE_ORIENTATION = new _Map([["xy", void 0], ["xz", rotateX(create$1(), create$1(), Math.PI / 2)], ["yz", rotateY(create$1(), create$1(), Math.PI / 2)]]);
const oneSquareSymbol = "◻";
const LAYOUT_SYMBOLS = new _Map([["4panel", "◱"], ["3d", oneSquareSymbol]]);
function makeSliceView(viewerState, baseToSelf) {
  let navigationState;
  if (baseToSelf === void 0) {
    navigationState = viewerState.navigationState.addRef();
  } else {
    navigationState = new NavigationState(new DisplayPose(viewerState.navigationState.pose.position.addRef(), viewerState.navigationState.pose.displayDimensionRenderInfo.addRef(), OrientationState.makeRelative(viewerState.navigationState.pose.orientation, baseToSelf)), viewerState.navigationState.zoomFactor.addRef(), viewerState.navigationState.depthRange.addRef());
  }
  return new SliceView(viewerState.chunkManager, viewerState.layerManager, navigationState, viewerState.wireFrame);
}
function makeNamedSliceView(viewerState, axes) {
  return makeSliceView(viewerState, AXES_RELATIVE_ORIENTATION.get(axes));
}
function makeOrthogonalSliceViews(viewerState) {
  return new _Map([["xy", makeNamedSliceView(viewerState, "xy")], ["xz", makeNamedSliceView(viewerState, "xz")], ["yz", makeNamedSliceView(viewerState, "yz")]]);
}
function getCommonViewerState$1(viewer) {
  return {
    crossSectionBackgroundColor: viewer.crossSectionBackgroundColor,
    perspectiveViewBackgroundColor: viewer.perspectiveViewBackgroundColor,
    selectionDetailsState: viewer.selectionDetailsState,
    mouseState: viewer.mouseState,
    layerManager: viewer.layerManager,
    showAxisLines: viewer.showAxisLines,
    wireFrame: viewer.wireFrame,
    visibleLayerRoles: viewer.visibleLayerRoles,
    selectedLayer: viewer.selectedLayer,
    visibility: viewer.visibility,
    scaleBarOptions: viewer.scaleBarOptions
  };
}
function getCommonPerspectiveViewerState(container) {
  const viewer = container.viewer;
  return _Object$assign(_Object$assign({}, getCommonViewerState$1(viewer)), { navigationState: viewer.perspectiveNavigationState, inputEventMap: viewer.inputEventBindings.perspectiveView, orthographicProjection: container.specification.orthographicProjection, showScaleBar: viewer.showScaleBar, rpc: viewer.chunkManager.rpc });
}
function getCommonSliceViewerState(viewer) {
  return _Object$assign(_Object$assign({}, getCommonViewerState$1(viewer)), { navigationState: viewer.navigationState, inputEventMap: viewer.inputEventBindings.sliceView });
}
function addDisplayDimensionsWidget(layout, panel) {
  const navigationState = panel.navigationState;
  panel.element.appendChild(layout.registerDisposer(new DisplayDimensionsWidget(navigationState.pose.displayDimensionRenderInfo.addRef(), navigationState.zoomFactor, navigationState.depthRange.addRef(), panel instanceof SliceViewPanel ? "px" : "vh")).element);
}
function registerRelatedLayouts(layout, panel, relatedLayouts) {
  const controls = document.createElement("div");
  controls.className = "neuroglancer-data-panel-layout-controls";
  layout.registerDisposer(() => removeFromParent(controls));
  for (let i = 0; i < 2; ++i) {
    const relatedLayout = relatedLayouts[Math.min(relatedLayouts.length - 1, i)];
    layout.registerDisposer(registerActionListener(panel.element, i === 0 ? "toggle-layout" : "toggle-layout-alternative", (event) => {
      layout.container.name = relatedLayout;
      event.stopPropagation();
    }));
  }
  for (const relatedLayout of relatedLayouts) {
    const button = document.createElement("button");
    const innerDiv = document.createElement("div");
    button.appendChild(innerDiv);
    innerDiv.textContent = LAYOUT_SYMBOLS.get(relatedLayout);
    button.title = `Switch to ${relatedLayout} layout.`;
    button.addEventListener("click", () => {
      layout.container.name = relatedLayout;
    });
    controls.appendChild(button);
  }
  panel.element.appendChild(controls);
}
function makeSliceViewFromSpecification(viewer, specification) {
  const sliceView = new SliceView(viewer.chunkManager, viewer.layerManager, specification.navigationState.addRef(), viewer.wireFrame);
  const updateViewportSize = () => {
    const width = specification.width.value, height = specification.height.value;
    sliceView.projectionParameters.setViewport({
      width,
      height,
      logicalWidth: width,
      logicalHeight: height,
      visibleLeftFraction: 0,
      visibleTopFraction: 0,
      visibleWidthFraction: 1,
      visibleHeightFraction: 1
    });
  };
  sliceView.registerDisposer(specification.width.changed.add(updateViewportSize));
  sliceView.registerDisposer(specification.height.changed.add(updateViewportSize));
  updateViewportSize();
  return sliceView;
}
function addUnconditionalSliceViews(viewer, panel, crossSections) {
  const previouslyAdded = new _Map();
  const update = () => {
    const currentCrossSections = new _Set();
    for (const crossSection of crossSections.values()) {
      currentCrossSections.add(crossSection);
      if (previouslyAdded.has(crossSection)) {
        continue;
      }
      const sliceView = makeSliceViewFromSpecification(viewer, crossSection);
      panel.sliceViews.set(sliceView, true);
      previouslyAdded.set(crossSection, sliceView);
    }
    for (const _ref of previouslyAdded) {
      var _ref2 = _slicedToArray(_ref, 2);
      const crossSection = _ref2[0];
      const sliceView = _ref2[1];
      if (currentCrossSections.has(crossSection)) {
        continue;
      }
      panel.sliceViews.delete(sliceView);
    }
  };
  update();
}
class FourPanelLayout extends RefCounted {
  constructor(container, rootElement, viewer, crossSections) {
    super();
    this.container = container;
    this.rootElement = rootElement;
    this.viewer = viewer;
    let sliceViews = makeOrthogonalSliceViews(viewer);
    let display = viewer.display;
    const perspectiveViewerState = _Object$assign(_Object$assign({}, getCommonPerspectiveViewerState(container)), { showSliceViews: viewer.showPerspectiveSliceViews, showSliceViewsCheckbox: true });
    const sliceViewerState = _Object$assign(_Object$assign({}, getCommonSliceViewerState(viewer)), { showScaleBar: viewer.showScaleBar });
    const sliceViewerStateWithoutScaleBar = _Object$assign(_Object$assign({}, getCommonSliceViewerState(viewer)), { showScaleBar: new TrackableBoolean(false, false) });
    const makeSliceViewPanel = (axes, element, state, displayDimensionsWidget) => {
      const panel = this.registerDisposer(new SliceViewPanel(display, element, sliceViews.get(axes), state));
      if (displayDimensionsWidget) {
        addDisplayDimensionsWidget(this, panel);
      }
      registerRelatedLayouts(this, panel, [axes, `${axes}-3d`]);
      return panel;
    };
    let mainDisplayContents = [withFlex(1, box("column", [withFlex(1, box("row", [withFlex(1, (element) => {
      makeSliceViewPanel("xy", element, sliceViewerState, true);
    }), withFlex(1, (element) => {
      makeSliceViewPanel("xz", element, sliceViewerStateWithoutScaleBar, false);
    })])), withFlex(1, box("row", [withFlex(1, (element) => {
      let panel = this.registerDisposer(new PerspectivePanel(display, element, perspectiveViewerState));
      for (let sliceView of sliceViews.values()) {
        panel.sliceViews.set(sliceView.addRef(), false);
      }
      addDisplayDimensionsWidget(this, panel);
      addUnconditionalSliceViews(viewer, panel, crossSections);
      registerRelatedLayouts(this, panel, ["3d"]);
    }), withFlex(1, (element) => {
      makeSliceViewPanel("yz", element, sliceViewerStateWithoutScaleBar, false);
    })]))]))];
    box("row", mainDisplayContents)(rootElement);
  }
  disposed() {
    removeChildren(this.rootElement);
    super.disposed();
  }
}
class SliceViewPerspectiveTwoPanelLayout extends RefCounted {
  constructor(container, rootElement, viewer, direction, axes, crossSections) {
    super();
    this.container = container;
    this.rootElement = rootElement;
    this.viewer = viewer;
    this.direction = direction;
    let sliceView = makeNamedSliceView(viewer, axes);
    let display = viewer.display;
    const perspectiveViewerState = _Object$assign(_Object$assign({}, getCommonPerspectiveViewerState(container)), { showSliceViews: viewer.showPerspectiveSliceViews, showSliceViewsCheckbox: true });
    const sliceViewerState = _Object$assign(_Object$assign({}, getCommonSliceViewerState(viewer)), { showScaleBar: viewer.showScaleBar });
    withFlex(1, box(direction, [withFlex(1, (element) => {
      const panel = this.registerDisposer(new SliceViewPanel(display, element, sliceView, sliceViewerState));
      addDisplayDimensionsWidget(this, panel);
      registerRelatedLayouts(this, panel, [axes, "4panel"]);
    }), withFlex(1, (element) => {
      let panel = this.registerDisposer(new PerspectivePanel(display, element, perspectiveViewerState));
      panel.sliceViews.set(sliceView.addRef(), false);
      addUnconditionalSliceViews(viewer, panel, crossSections);
      addDisplayDimensionsWidget(this, panel);
      registerRelatedLayouts(this, panel, ["3d", "4panel"]);
    })]))(rootElement);
  }
  disposed() {
    removeChildren(this.rootElement);
    super.disposed();
  }
}
class SinglePanelLayout extends RefCounted {
  constructor(container, rootElement, viewer, axes) {
    super();
    this.container = container;
    this.rootElement = rootElement;
    this.viewer = viewer;
    let sliceView = makeNamedSliceView(viewer, axes);
    const sliceViewerState = _Object$assign(_Object$assign({}, getCommonSliceViewerState(viewer)), { showScaleBar: viewer.showScaleBar });
    box("row", [withFlex(1, (element) => {
      const panel = this.registerDisposer(new SliceViewPanel(viewer.display, element, sliceView, sliceViewerState));
      addDisplayDimensionsWidget(this, panel);
      registerRelatedLayouts(this, panel, ["4panel", `${axes}-3d`]);
    })])(rootElement);
  }
  disposed() {
    removeChildren(this.rootElement);
    super.disposed();
  }
}
class SinglePerspectiveLayout extends RefCounted {
  constructor(container, rootElement, viewer, crossSections) {
    super();
    this.container = container;
    this.rootElement = rootElement;
    this.viewer = viewer;
    let perspectiveViewerState = _Object$assign(_Object$assign({}, getCommonPerspectiveViewerState(container)), { showSliceViews: new TrackableBoolean(false, false) });
    box("row", [withFlex(1, (element) => {
      const panel = this.registerDisposer(new PerspectivePanel(viewer.display, element, perspectiveViewerState));
      addUnconditionalSliceViews(viewer, panel, crossSections);
      addDisplayDimensionsWidget(this, panel);
      registerRelatedLayouts(this, panel, ["4panel"]);
    })])(rootElement);
  }
  disposed() {
    removeChildren(this.rootElement);
    super.disposed();
  }
}
const LAYOUTS = new _Map([["4panel", {
  factory: (container, element, viewer, crossSections) => new FourPanelLayout(container, element, viewer, crossSections)
}], ["3d", {
  factory: (container, element, viewer, crossSections) => new SinglePerspectiveLayout(container, element, viewer, crossSections)
}]]);
for (const axes of AXES_RELATIVE_ORIENTATION.keys()) {
  LAYOUTS.set(axes, {
    factory: (container, element, viewer) => new SinglePanelLayout(container, element, viewer, axes)
  });
  const splitLayout = `${axes}-3d`;
  LAYOUT_SYMBOLS.set(axes, oneSquareSymbol);
  LAYOUT_SYMBOLS.set(splitLayout, "◫");
  LAYOUTS.set(splitLayout, {
    factory: (container, element, viewer, crossSections) => new SliceViewPerspectiveTwoPanelLayout(container, element, viewer, "row", axes, crossSections)
  });
}
function getLayoutByName(obj) {
  let layout = LAYOUTS.get(obj);
  if (layout === void 0) {
    throw new Error(`Invalid layout name: ${_JSON$stringify(obj)}.`);
  }
  return layout;
}
function validateLayoutName(obj) {
  getLayoutByName(obj);
  return obj;
}
class CrossSectionSpecification extends RefCounted {
  constructor(parent) {
    super();
    this.width = new TrackableValue(1e3, verifyPositiveInt);
    this.height = new TrackableValue(1e3, verifyPositiveInt);
    this.changed = new NullarySignal();
    this.position = new LinkedPosition(parent.position.addRef());
    this.position.changed.add(this.changed.dispatch);
    this.orientation = new LinkedOrientationState(parent.pose.orientation.addRef());
    this.orientation.changed.add(this.changed.dispatch);
    this.width.changed.add(this.changed.dispatch);
    this.height.changed.add(this.changed.dispatch);
    this.scale = new LinkedZoomState(parent.zoomFactor.addRef(), parent.zoomFactor.displayDimensionRenderInfo.addRef());
    this.scale.changed.add(this.changed.dispatch);
    this.navigationState = this.registerDisposer(new NavigationState(new DisplayPose(this.position.value, parent.pose.displayDimensionRenderInfo.addRef(), this.orientation.value), this.scale.value, parent.depthRange.addRef()));
  }
  restoreState(obj) {
    verifyObject(obj);
    optionallyRestoreFromJsonMember(obj, "width", this.width);
    optionallyRestoreFromJsonMember(obj, "height", this.height);
    optionallyRestoreFromJsonMember(obj, "position", linkedStateLegacyJsonView(this.position));
    optionallyRestoreFromJsonMember(obj, "orientation", this.orientation);
    optionallyRestoreFromJsonMember(obj, "scale", this.scale);
    optionallyRestoreFromJsonMember(obj, "zoom", linkedStateLegacyJsonView(this.scale));
  }
  reset() {
    this.width.reset();
    this.height.reset();
    this.position.reset();
    this.orientation.reset();
    this.scale.reset();
  }
  toJSON() {
    return {
      width: this.width.toJSON(),
      height: this.height.toJSON(),
      position: this.position.toJSON(),
      orientation: this.orientation.toJSON(),
      scale: this.scale.toJSON()
    };
  }
}
class CrossSectionSpecificationMap extends WatchableMap {
  constructor(parentNavigationState) {
    super((context, spec) => context.registerDisposer(context.registerDisposer(spec).changed.add(this.changed.dispatch)));
    this.parentNavigationState = parentNavigationState;
    this.registerDisposer(parentNavigationState);
  }
  restoreState(obj) {
    verifyObject(obj);
    for (const key of _Object$keys(obj)) {
      const state = new CrossSectionSpecification(this.parentNavigationState);
      try {
        this.set(key, state.addRef());
        state.restoreState(obj[key]);
      } finally {
        state.dispose();
      }
    }
  }
  reset() {
    this.clear();
  }
  toJSON() {
    if (this.size === 0) return void 0;
    const obj = {};
    for (const _ref3 of this) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const k = _ref4[0];
      const v = _ref4[1];
      obj[k] = v.toJSON();
    }
    return obj;
  }
}
class DataPanelLayoutSpecification extends RefCounted {
  constructor(parentNavigationState, defaultLayout) {
    super();
    this.changed = new NullarySignal();
    this.orthographicProjection = new TrackableBoolean(false);
    this.type = new TrackableValue(defaultLayout, validateLayoutName);
    this.type.changed.add(this.changed.dispatch);
    this.crossSections = this.registerDisposer(new CrossSectionSpecificationMap(parentNavigationState.addRef()));
    this.crossSections.changed.add(this.changed.dispatch);
    this.orthographicProjection.changed.add(this.changed.dispatch);
    this.registerDisposer(parentNavigationState);
  }
  reset() {
    this.crossSections.clear();
    this.orthographicProjection.reset();
    this.type.reset();
  }
  restoreState(obj) {
    this.crossSections.clear();
    this.orthographicProjection.reset();
    if (typeof obj === "string") {
      this.type.restoreState(obj);
    } else {
      verifyObject(obj);
      verifyObjectProperty(obj, "type", (x) => this.type.restoreState(x));
      verifyObjectProperty(obj, "orthographicProjection", (x) => this.orthographicProjection.restoreState(x));
      verifyObjectProperty(obj, "crossSections", (x) => x !== void 0 && this.crossSections.restoreState(x));
    }
  }
  toJSON() {
    const type = this.type, crossSections = this.crossSections, orthographicProjection = this.orthographicProjection;
    const orthographicProjectionJson = orthographicProjection.toJSON();
    if (crossSections.size === 0 && orthographicProjectionJson === void 0) {
      return type.value;
    }
    return {
      type: type.value,
      crossSections: crossSections.toJSON(),
      orthographicProjection: orthographicProjectionJson
    };
  }
}
class DataPanelLayoutContainer extends RefCounted {
  constructor(viewer, defaultLayout) {
    super();
    this.viewer = viewer;
    this.element = document.createElement("div");
    this.specification = this.registerDisposer(new DataPanelLayoutSpecification(this.viewer.navigationState.addRef(), defaultLayout));
    this.element.style.flex = "1";
    const scheduleUpdateLayout = this.registerCancellable(debounce(() => this.updateLayout(), 0));
    this.specification.type.changed.add(scheduleUpdateLayout);
    registerActionListener(this.element, "toggle-orthographic-projection", () => this.specification.orthographicProjection.toggle());
    this.registerDisposer(this.viewer.display.updateStarted.add(() => scheduleUpdateLayout.flush()));
    scheduleUpdateLayout();
  }
  get name() {
    return this.specification.type.value;
  }
  set name(value) {
    this.specification.type.value = value;
  }
  get changed() {
    return this.specification.changed;
  }
  toJSON() {
    return this.specification.toJSON();
  }
  restoreState(obj) {
    this.specification.restoreState(obj);
  }
  reset() {
    this.specification.reset();
  }
  disposeLayout() {
    let layout = this.layout;
    if (layout !== void 0) {
      layout.dispose();
      this.layout = void 0;
    }
  }
  updateLayout() {
    this.disposeLayout();
    this.layout = getLayoutByName(this.name).factory(this, this.element, this.viewer, this.specification.crossSections);
  }
  disposed() {
    this.disposeLayout();
    super.disposed();
  }
}
const providerFactories = new _Map();
function registerProvider(name2, factory) {
  providerFactories.set(name2, factory);
}
function getDefaultDataSourceProvider(options) {
  const provider = new DataSourceProviderRegistry(options.credentialsManager);
  for (const _ref of providerFactories) {
    var _ref2 = _slicedToArray(_ref, 2);
    const name2 = _ref2[0];
    const factory = _ref2[1];
    provider.register(name2, factory(options));
  }
  return provider;
}
class HttpError extends Error {
  constructor(url, status, statusText, response) {
    let message = `Fetching ${_JSON$stringify(url)} resulted in HTTP error ${status}`;
    if (statusText) {
      message += `: ${statusText}`;
    }
    message += ".";
    super(message);
    this.name = "HttpError";
    this.message = message;
    this.url = url;
    this.status = status;
    this.statusText = statusText;
    if (response) {
      this.response = response;
    }
  }
  static fromResponse(response) {
    return new HttpError(response.url, response.status, response.statusText, response);
  }
  static fromRequestError(input, error) {
    if (error instanceof TypeError) {
      let url;
      if (typeof input === "string") {
        url = input;
      } else {
        url = input.url;
      }
      return new HttpError(url, 0, "Network or CORS error");
    }
    return error;
  }
}
async function fetchOk(input, init) {
  let response;
  try {
    response = await fetch(input, init);
  } catch (error) {
    throw HttpError.fromRequestError(input, error);
  }
  if (!response.ok) throw HttpError.fromResponse(response);
  return response;
}
function responseArrayBuffer(response) {
  return response.arrayBuffer();
}
function responseJson(response) {
  return response.json();
}
async function cancellableFetchOk(input, init, transformResponse, cancellationToken = uncancelableToken) {
  if (cancellationToken === uncancelableToken) {
    const response = await fetchOk(input, init);
    return await transformResponse(response);
  }
  const abortController = new AbortController();
  const unregisterCancellation = cancellationToken.add(() => abortController.abort());
  try {
    const response = await fetchOk(input, _Object$assign(_Object$assign({}, init), { signal: abortController.signal }));
    return await transformResponse(response);
  } finally {
    unregisterCancellation();
  }
}
function parseUrl(url) {
  const urlProtocolPattern = /^([^:\/]+):\/\/([^\/]+)((?:\/.*)?)$/;
  let match = url.match(urlProtocolPattern);
  if (match === null) {
    throw new Error(`Invalid URL: ${_JSON$stringify(url)}`);
  }
  return { protocol: match[1], host: match[2], path: match[3] };
}
function isNotFoundError(e) {
  if (!(e instanceof HttpError)) return false;
  return e.status === 0 || e.status === 403 || e.status === 404;
}
const maxAttempts = 32;
const maxCredentialsAttempts = 3;
const minDelayMilliseconds = 500;
const maxDelayMilliseconds = 1e4;
function pickDelay(attemptNumber) {
  return Math.min(2 ** attemptNumber * minDelayMilliseconds, maxDelayMilliseconds / 2) * (1 + Math.random());
}
async function fetchWithCredentials(credentialsProvider, input, init, transformResponse, applyCredentials2, errorHandler, cancellationToken = uncancelableToken) {
  let credentials;
  credentialsLoop: for (let credentialsAttempt = 0; ; ) {
    throwIfCanceled(cancellationToken);
    if (credentialsAttempt > 1) {
      await new _Promise((resolve) => setTimeout(resolve, pickDelay(credentialsAttempt - 2)));
    }
    credentials = await credentialsProvider.get(credentials, cancellationToken);
    requestLoop: for (let requestAttempt = 0; ; ) {
      try {
        return await cancellableFetchOk(typeof input === "function" ? input(credentials.credentials) : input, applyCredentials2(credentials.credentials, init), transformResponse, cancellationToken);
      } catch (error) {
        if (error instanceof HttpError) {
          if (errorHandler(error, credentials.credentials) === "refresh") {
            if (++credentialsAttempt === maxCredentialsAttempts) throw error;
            continue credentialsLoop;
          }
          if (++requestAttempt === maxAttempts) throw error;
          await new _Promise((resolve) => setTimeout(resolve, pickDelay(requestAttempt - 1)));
          continue requestLoop;
        }
        throw error;
      }
    }
  }
}
function fetchWithOAuth2Credentials(credentialsProvider, input, init, transformResponse, cancellationToken = uncancelableToken) {
  if (credentialsProvider === void 0) {
    return cancellableFetchOk(input, init, transformResponse, cancellationToken);
  }
  return fetchWithCredentials(credentialsProvider, input, init, transformResponse, (credentials, init2) => {
    if (!credentials.accessToken) return init2;
    const headers = new Headers(init2.headers);
    headers.set("Authorization", `${credentials.tokenType} ${credentials.accessToken}`);
    return _Object$assign(_Object$assign({}, init2), { headers });
  }, (error, credentials) => {
    const status = error.status;
    if (status === 401) {
      return "refresh";
    } else if (status === 504 || status === 503) {
      return "retry";
    } else if (status === 403 && !credentials.accessToken) {
      return "refresh";
    }
    throw error;
  }, cancellationToken);
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getS3BucketListing(credentialsProvider, bucketUrl, prefix, delimiter, cancellationToken) {
  const response = await fetchWithOAuth2Credentials(
    credentialsProvider,
    `${bucketUrl}?prefix=${encodeURIComponent(prefix)}&delimiter=${encodeURIComponent(delimiter)}`,
    /*init=*/
    {},
    (x) => x.text(),
    cancellationToken
  );
  const doc = new DOMParser().parseFromString(response, "application/xml");
  const commonPrefixNodes = doc.evaluate('//*[name()="CommonPrefixes"]/*[name()="Prefix"]', doc, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  const results = [];
  for (let i = 0, n = commonPrefixNodes.snapshotLength; i < n; ++i) {
    results.push(commonPrefixNodes.snapshotItem(i).textContent || "");
  }
  const contents = doc.evaluate('//*[name()="Contents"]/*[name()="Key"]', doc, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = 0, n = contents.snapshotLength; i < n; ++i) {
    results.push(contents.snapshotItem(i).textContent || "");
  }
  return results;
}
async function getS3CompatiblePathCompletions(credentialsProvider, enteredBucketUrl, bucketUrl, path, cancellationToken) {
  let prefix = path;
  if (!prefix.startsWith("/")) throw null;
  const paths = await getS3BucketListing(credentialsProvider, bucketUrl, path.substring(1), "/", cancellationToken);
  let offset = path.lastIndexOf("/");
  return {
    offset: offset + enteredBucketUrl.length + 1,
    completions: paths.map((x) => ({ value: x.substring(offset) }))
  };
}
/**
 * @license
 * Copyright 2021 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class S3RegionProvider extends CredentialsProvider {
  constructor(bucket) {
    super();
    this.bucket = bucket;
    this.get = makeCredentialsGetter(async () => {
      var _a;
      const bucket2 = this.bucket;
      const response = await cancellableFetchOk(`https://s3.amazonaws.com/${bucket2}?location`, {}, (x) => x.text());
      const doc = new DOMParser().parseFromString(response, "application/xml");
      const locationElement = doc.querySelector("LocationConstraint");
      if (locationElement === null) {
        throw new Error(`Unable to determine location of S3 bucket: ${bucket2}`);
      }
      const location2 = ((_a = locationElement.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || "us-east-1";
      return { region: location2 };
    });
  }
}
let s3RegionCache;
function getS3RegionCredentials(bucket) {
  if (s3RegionCache === void 0) {
    s3RegionCache = new CachingMapBasedCredentialsManager();
    s3RegionCache.register("s3", (bucket2) => new S3RegionProvider(bucket2));
  }
  return s3RegionCache.getCredentialsProvider("s3", bucket);
}
async function cancellableFetchS3Ok(credentialsProvider, bucket, path, requestInit, transformResponse, cancellationToken = uncancelableToken) {
  const credentials = await credentialsProvider.get();
  const region = credentials.credentials.region;
  return await cancellableFetchOk(`https://${bucket}.s3.${region}.amazonaws.com${path}`, requestInit, transformResponse, cancellationToken);
}
async function getS3PathCompletions(bucket, path, cancellationToken) {
  const credentialsProvider = getS3RegionCredentials(bucket);
  const credentials = await credentialsProvider.get();
  const region = credentials.credentials.region;
  return await getS3CompatiblePathCompletions(void 0, `s3://${bucket}`, `https://${bucket}.s3.${region}.amazonaws.com`, path, cancellationToken);
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getMiddleAuthCredentialsProvider(credentialsManager, url) {
  return credentialsManager.getCredentialsProvider("middleauthapp", new URL(url).origin);
}
function getNgauthCredentialsProvider(credentialsManager, serverUrl, path) {
  const bucketPattern = /^\/([^\/]+)/;
  const m = path.match(bucketPattern);
  if (m === null) return void 0;
  return typeof NEUROGLANCER_PYTHON_INTEGRATION !== "undefined" ? credentialsManager.getCredentialsProvider("gcs", { bucket: m[1] }) : credentialsManager.getCredentialsProvider("ngauth_gcs", { authServer: serverUrl, bucket: m[1] });
}
function parseSpecialUrl(url, credentialsManager) {
  const u = parseUrl(url);
  switch (u.protocol) {
    case "gs":
    case "gs+json":
    case "gs+xml":
      return {
        credentialsProvider: typeof NEUROGLANCER_PYTHON_INTEGRATION !== "undefined" ? credentialsManager.getCredentialsProvider("gcs", { bucket: u.host }) : void 0,
        url
      };
    case "gs+ngauth+http":
      return {
        credentialsProvider: getNgauthCredentialsProvider(credentialsManager, `http://${u.host}`, u.path),
        url: "gs:/" + u.path
      };
    case "gs+ngauth+https":
      return {
        credentialsProvider: getNgauthCredentialsProvider(credentialsManager, `https://${u.host}`, u.path),
        url: "gs:/" + u.path
      };
    case "gs+xml+ngauth+http":
      return {
        credentialsProvider: getNgauthCredentialsProvider(credentialsManager, `http://${u.host}`, u.path),
        url: "gs+xml:/" + u.path
      };
    case "gs+xml+ngauth+https":
      return {
        credentialsProvider: getNgauthCredentialsProvider(credentialsManager, `https://${u.host}`, u.path),
        url: "gs+xml:/" + u.path
      };
    case "middleauth+https":
      url = url.substr("middleauth+".length);
      return {
        credentialsProvider: getMiddleAuthCredentialsProvider(credentialsManager, url),
        url
      };
    case "s3":
      return {
        credentialsProvider: getS3RegionCredentials(u.host),
        url
      };
    default:
      return {
        credentialsProvider: void 0,
        url
      };
  }
}
async function cancellableFetchSpecialOk(credentialsProvider, url, init, transformResponse, cancellationToken = uncancelableToken) {
  const u = parseUrl(url);
  switch (u.protocol) {
    case "gs":
      return fetchWithOAuth2Credentials(credentialsProvider, `https://www.googleapis.com/storage/v1/b/${u.host}/o/${encodeURIComponent(u.path.substring(1))}?alt=media&neuroglancerOrigin=${encodeURIComponent(location.origin)}`, init, transformResponse, cancellationToken);
    case "gs+json":
      return fetchWithOAuth2Credentials(credentialsProvider, `https://storage.googleapis.com/storage/v1/b/${u.host}/o/${encodeURIComponent(u.path.substring(1))}?alt=media`, init, transformResponse, cancellationToken);
    case "gs+xml":
      return fetchWithOAuth2Credentials(credentialsProvider, `https://storage.googleapis.com/${u.host}${u.path}`, init, transformResponse, cancellationToken);
    case "s3":
      return cancellableFetchS3Ok(credentialsProvider, u.host, u.path, init, transformResponse, cancellationToken);
    default:
      return fetchWithOAuth2Credentials(credentialsProvider, url, init, transformResponse, cancellationToken);
  }
}
const stateShareEnabled = typeof STATE_SERVERS !== "undefined" && _Object$keys(STATE_SERVERS).length > 0;
class StateShare extends RefCounted {
  constructor(viewer) {
    super();
    this.element = document.createElement("div");
    this.button = makeIcon({ text: "Share", title: "Share State" });
    if (typeof STATE_SERVERS === "undefined") {
      throw new Error("Cannot construct StateSare without defining STATE_SERVERS");
    }
    if (_Object$keys(STATE_SERVERS).length > 1) {
      const selectEl = document.createElement("select");
      selectEl.style.marginRight = "5px";
      this.registerDisposer(viewer.selectedStateServer.changed.add(() => {
        const valueFromState = viewer.selectedStateServer.value;
        if (_Object$values(STATE_SERVERS).map((s) => s.url).includes(valueFromState)) {
          selectEl.value = valueFromState;
        }
      }));
      this.registerEventListener(selectEl, "change", () => {
        viewer.selectedStateServer.value = selectEl.value;
      });
      for (let _ref of _Object$entries(STATE_SERVERS)) {
        var _ref2 = _slicedToArray(_ref, 2);
        let name2 = _ref2[0];
        let stateServer = _ref2[1];
        const option = document.createElement("option");
        option.textContent = name2;
        option.value = stateServer.url;
        option.selected = !!stateServer.default;
        selectEl.appendChild(option);
      }
      this.element.appendChild(selectEl);
      this.selectStateServerElement = selectEl;
    }
    this.element.appendChild(this.button);
    this.registerEventListener(this.button, "click", () => {
      const selectedStateServer = this.selectStateServerElement ? this.selectStateServerElement.value : _Object$values(STATE_SERVERS)[0].url;
      const protocol = new URL(selectedStateServer).protocol;
      var _parseSpecialUrl = parseSpecialUrl(selectedStateServer, defaultCredentialsManager);
      const parsedUrl = _parseSpecialUrl.url, credentialsProvider = _parseSpecialUrl.credentialsProvider;
      StatusMessage.forPromise(cancellableFetchSpecialOk(credentialsProvider, parsedUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: _JSON$stringify(viewer.state.toJSON())
      }, responseJson).then((res) => {
        const stateUrl = new URL(res);
        stateUrl.protocol = protocol;
        const link = `${window.location.origin}/#!${stateUrl}`;
        navigator.clipboard.writeText(link).then(() => {
          StatusMessage.showTemporaryMessage("Share link copied to clipboard");
        });
      }).catch(() => {
        StatusMessage.showTemporaryMessage(`Could not access state server.`, 4e3);
      }), {
        initialMessage: `Posting state to ${selectedStateServer}.`,
        delay: true,
        errorPrefix: ""
      });
    });
  }
  disposed() {
    this.element.remove();
    super.disposed();
  }
}
function formatKeyName(name2) {
  if (name2.startsWith("key")) {
    return name2.substring(3);
  }
  if (name2.startsWith("digit")) {
    return name2.substring(5);
  }
  if (name2.startsWith("arrow")) {
    return name2.substring(5);
  }
  return name2;
}
function formatKeyStroke(stroke) {
  let parts = stroke.split("+");
  return parts.map(formatKeyName).join("+");
}
const DEFAULT_HELP_PANEL_LOCATION = _Object$assign(_Object$assign({}, DEFAULT_SIDE_PANEL_LOCATION), { side: "left", row: 1 });
class HelpPanelState {
  constructor() {
    this.location = new TrackableSidePanelLocation(DEFAULT_HELP_PANEL_LOCATION);
  }
  get changed() {
    return this.location.changed;
  }
  toJSON() {
    return emptyToUndefined(this.location.toJSON());
  }
  reset() {
    this.location.reset();
  }
  restoreState(obj) {
    this.location.restoreState(obj);
  }
}
class InputEventBindingHelpDialog extends SidePanel {
  constructor(sidePanelManager, state, bindings, layerManager, toolBinder) {
    super(sidePanelManager, state.location);
    this.bindings = bindings;
    this.toolBinder = toolBinder;
    this.scroll = document.createElement("div");
    this.addTitleBar({ title: "Help" });
    const body = document.createElement("div");
    body.classList.add("neuroglancer-help-body");
    const scroll = this.scroll;
    scroll.classList.add("neuroglancer-help-scroll-container");
    body.appendChild(scroll);
    this.addBody(body);
    const debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateView()));
    this.registerDisposer(toolBinder.changed.add(debouncedUpdateView));
    this.registerDisposer(layerManager.layersChanged.add(debouncedUpdateView));
    this.updateView();
  }
  updateView() {
    const scroll = this.scroll, bindings = this.bindings, toolBinder = this.toolBinder;
    removeChildren(scroll);
    const uniqueMaps = new _Map();
    function addEntries(eventMap, entries2) {
      for (const parent of eventMap.parents) {
        if (parent.label !== void 0) {
          addMap(parent.label, parent);
        } else {
          addEntries(parent, entries2);
        }
      }
      for (const _ref of eventMap.bindings.entries()) {
        var _ref2 = _slicedToArray(_ref, 2);
        const event = _ref2[0];
        const eventAction = _ref2[1];
        const firstColon = event.indexOf(":");
        const suffix = event.substring(firstColon + 1);
        entries2.set(suffix, eventAction.action);
      }
    }
    function addMap(label, map2) {
      if (uniqueMaps.has(map2)) {
        return;
      }
      const list = {
        label,
        entries: new _Map()
      };
      addEntries(map2, list.entries);
      uniqueMaps.set(map2, list);
    }
    for (const _ref3 of bindings) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const label = _ref4[0];
      const eventMap = _ref4[1];
      addMap(label, eventMap);
    }
    const addGroup = (title, entries2) => {
      let header = document.createElement("h2");
      header.textContent = title;
      scroll.appendChild(header);
      for (const _ref5 of entries2) {
        var _ref6 = _slicedToArray(_ref5, 2);
        const event = _ref6[0];
        const action = _ref6[1];
        let dt = document.createElement("div");
        dt.className = "dt";
        dt.textContent = formatKeyStroke(event);
        let dd = document.createElement("div");
        dd.className = "dd";
        dd.textContent = action;
        scroll.appendChild(dt);
        scroll.appendChild(dd);
      }
    };
    const layerToolBindingsMap = new _Map();
    for (const _ref7 of toolBinder.bindings) {
      var _ref8 = _slicedToArray(_ref7, 2);
      const key = _ref8[0];
      const tool = _ref8[1];
      let layerBindings = layerToolBindingsMap.get(tool.layer);
      if (layerBindings === void 0) {
        layerBindings = [];
        layerToolBindingsMap.set(tool.layer, layerBindings);
      }
      layerBindings.push([`shift+key${key.toLowerCase()}`, tool.description]);
    }
    const layerToolBindings = _Array$from(layerToolBindingsMap.entries());
    if (layerToolBindings.length > 0) {
      layerToolBindings[0][0].manager.root.layerManager.updateNonArchivedLayerIndices();
      layerToolBindings.sort((a, b) => a[0].managedLayer.nonArchivedLayerIndex - b[0].managedLayer.nonArchivedLayerIndex);
    }
    for (const _ref9 of layerToolBindings) {
      var _ref10 = _slicedToArray(_ref9, 2);
      const layer = _ref10[0];
      const bindings2 = _ref10[1];
      bindings2.sort();
      addGroup(`Tool bindings for layer ${layer.managedLayer.nonArchivedLayerIndex + 1}: ${layer.managedLayer.name}`, bindings2);
    }
    for (const list of uniqueMaps.values()) {
      addGroup(list.label, list.entries);
    }
  }
}
function positionContextMenu(menu, event) {
  menu.style.display = "block";
  const offsetWidth = menu.offsetWidth, offsetHeight = menu.offsetHeight;
  const viewportWidth = document.documentElement.clientWidth;
  const viewportHeight = document.documentElement.clientHeight;
  const posX = document.documentElement.scrollLeft + Math.min(viewportWidth - offsetWidth, event.clientX);
  const posY = document.documentElement.scrollTop + Math.min(viewportHeight - offsetHeight, event.clientY);
  menu.style.left = posX + "px";
  menu.style.top = posY + "px";
}
class ContextMenu extends RefCounted {
  constructor(parent) {
    super();
    this.element = document.createElement("div");
    this.parentDisposers = new _Map();
    this.disabledValue = false;
    this.opened = new NullarySignal();
    this.closed = new NullarySignal();
    const element = this.element;
    element.className = "neuroglancer-context-menu";
    element.style.display = "none";
    element.tabIndex = -1;
    document.body.appendChild(element);
    if (parent !== void 0) {
      this.registerParent(parent);
    }
  }
  get disabled() {
    return this.disabledValue;
  }
  set disabled(value) {
    if (this.disabledValue !== value) {
      this.disabledValue = value;
      if (value) {
        this.hide();
      }
    }
  }
  get open() {
    return this.menuDisposer !== void 0;
  }
  registerParent(parent) {
    const parentDisposers = this.parentDisposers;
    if (parentDisposers.has(parent)) {
      return;
    }
    parentDisposers.set(parent, registerEventListener(parent, "contextmenu", (event) => {
      this.show(event);
      event.stopPropagation();
      event.preventDefault();
    }));
  }
  show(originalEvent) {
    if (this.disabledValue) {
      return;
    }
    this.hide();
    const element = this.element;
    const mousedownDisposer = registerEventListener(
      document,
      "mousedown",
      (event) => {
        if (event.target instanceof Node && !element.contains(event.target)) {
          this.hide();
        }
      },
      /*capture=*/
      true
    );
    const keydownDisposer = registerEventListener(
      document,
      "keydown",
      (event) => {
        if (event.code === "Escape") {
          this.hide();
        }
      },
      /*capture=*/
      true
    );
    const menuDisposer = () => {
      keydownDisposer();
      mousedownDisposer();
      element.style.display = "none";
    };
    this.opened.dispatch();
    positionContextMenu(element, originalEvent);
    this.menuDisposer = menuDisposer;
  }
  unregisterParent(parent) {
    const parentDisposers = this.parentDisposers;
    const disposer = parentDisposers.get(parent);
    if (disposer !== void 0) {
      disposer();
      parentDisposers.delete(parent);
    }
  }
  disposed() {
    const parentDisposers = this.parentDisposers;
    for (const disposer of parentDisposers.values()) {
      disposer();
    }
    parentDisposers.clear();
    removeFromParent(this.element);
  }
  hide() {
    if (this.menuDisposer !== void 0) {
      this.menuDisposer();
      this.menuDisposer = void 0;
      this.closed.dispatch();
    }
  }
}
function encodeStringAsDragType(s) {
  return hexEncode(new TextEncoder().encode(s));
}
function decodeStringFromDragType(s) {
  return new TextDecoder().decode(hexDecode(s));
}
function decodeParametersFromDragType(dragType, prefix) {
  if (!dragType.startsWith(prefix)) {
    return void 0;
  }
  try {
    const jsonString = decodeStringFromDragType(dragType.substring(prefix.length));
    return JSON.parse(jsonString);
  } catch (_a) {
    return void 0;
  }
}
function encodeParametersAsDragType(prefix, parameters) {
  return prefix + encodeStringAsDragType(_JSON$stringify(parameters));
}
function decodeParametersFromDragTypeList(dragTypes, prefix) {
  for (const dragType of dragTypes) {
    const parameters = decodeParametersFromDragType(dragType, prefix);
    if (parameters !== void 0) {
      return { parameters, dragType };
    }
  }
  return void 0;
}
let savedDropEffect;
function setDropEffect(event, dropEffect) {
  event.dataTransfer.dropEffect = dropEffect;
  savedDropEffect = dropEffect;
  return dropEffect;
}
function getDropEffect() {
  return savedDropEffect;
}
function preventDrag(element) {
  element.draggable = true;
  return registerEventListener(element, "dragstart", (event) => {
    event.stopPropagation();
    event.preventDefault();
  });
}
const layerDragTypePrefix = "neuroglancer-layer\0";
let dragSource$1;
function startLayerDrag(event, sourceInfo) {
  var _a;
  event.dataTransfer.setData(encodeParametersAsDragType(layerDragTypePrefix, sourceInfo.layers.map((layer) => ({ name: layer.name, visible: layer.visible }))), _JSON$stringify({ layers: sourceInfo.layers.map((layer) => layer.toJSON()), layout: sourceInfo.layoutSpec }));
  if (dragSource$1 !== void 0) {
    dragSource$1.disposer();
  }
  let newDragSource;
  let disposer = () => {
    sourceInfo.manager.unregisterDisposer(disposer);
    for (const layer of sourceInfo.layers) {
      layer.dispose();
    }
    sourceInfo.manager.dispose();
    if (dragSource$1 === newDragSource) {
      dragSource$1 = void 0;
    }
  };
  dragSource$1 = newDragSource = {
    manager: sourceInfo.manager.addRef(),
    layers: sourceInfo.layers.map((x) => x.addRef()),
    layoutSpec: sourceInfo.layoutSpec,
    isLayerListPanel: (_a = sourceInfo.isLayerListPanel) !== null && _a !== void 0 ? _a : false,
    disposer
  };
}
function endLayerDrag(dropEffect = "none") {
  if (dragSource$1 !== void 0) {
    if (dropEffect === "move") {
      const removedLayers = new _Set(dragSource$1.layers);
      dragSource$1.manager.layerManager.filter((x) => !removedLayers.has(x));
    }
    dragSource$1.disposer();
  }
}
function getLayerDragInfo(event) {
  return decodeParametersFromDragTypeList(event.dataTransfer.types, layerDragTypePrefix);
}
function getCompatibleDragSource(manager) {
  if (dragSource$1 !== void 0 && dragSource$1.manager.rootLayers === manager.rootLayers) {
    return dragSource$1;
  }
  return void 0;
}
class DropLayers {
  /**
   * Called in the 'drop' event handler to actually initialize the layers if they are external.
   * Returns false if any layers failed to initialized.
   */
  initializeExternalLayers(event) {
    const dragType = this.dragType;
    if (dragType !== void 0) {
      try {
        var _JSON$parse = JSON.parse(event.dataTransfer.getData(dragType));
        const spec = _JSON$parse.layers, layout = _JSON$parse.layout;
        if (!Array.isArray(spec) || this.numSourceLayers !== spec.length) {
          throw new Error("Invalid layer drop data");
        }
        this.layoutSpec = layout;
        for (const _ref of this.layers) {
          var _ref2 = _slicedToArray(_ref, 2);
          const layer = _ref2[0];
          const index2 = _ref2[1];
          initializeLayerFromSpecShowErrorStatus(layer, spec[index2]);
        }
      } catch (_a) {
        return false;
      }
    }
    return true;
  }
  updateArchiveStates(event) {
    const targetIsLayerListPanel = this.targetIsLayerListPanel;
    const dropEffect = event.dataTransfer.dropEffect;
    for (const layer of this.layers.keys()) {
      let shouldBeArchived = targetIsLayerListPanel;
      if (targetIsLayerListPanel && !layer.archived && dropEffect !== "copy") {
        if (this.sourceIsLayerListPanel) {
          shouldBeArchived = false;
        }
      }
      if (layer.archived !== shouldBeArchived || shouldBeArchived && layer.visible) {
        layer.archived = shouldBeArchived;
        if (shouldBeArchived) layer.visible = false;
        layer.layerChanged.dispatch();
      }
    }
  }
  get method() {
    if (this.sourceManager !== void 0) {
      if (this.manager === this.sourceManager && this.sourceIsLayerListPanel === this.targetIsLayerListPanel) {
        return "move";
      } else {
        return "link";
      }
    } else {
      return "copy";
    }
  }
  compatibleWithMethod(otherMethod) {
    if (this.method === otherMethod) {
      return true;
    }
    if (this.forceCopy && otherMethod !== "copy") {
      return false;
    }
    if (!this.moveSupported && otherMethod === "move") {
      return true;
    }
    return false;
  }
}
function getDropEffectFromModifiers(event, defaultDropEffect, moveAllowed) {
  let dropEffect;
  if (event.shiftKey) {
    dropEffect = "copy";
  } else if (event.ctrlKey && moveAllowed) {
    dropEffect = "move";
  } else {
    dropEffect = defaultDropEffect;
  }
  let message = "";
  const addMessage = (msg) => {
    if (message !== "") {
      message += ", ";
    }
    message += msg;
  };
  if (defaultDropEffect !== "none" && dropEffect !== defaultDropEffect) {
    if (event.shiftKey) {
      addMessage(`release SHIFT to ${defaultDropEffect}`);
    } else {
      addMessage(`release CONTROL to ${defaultDropEffect}`);
    }
  }
  if (dropEffect !== "copy") {
    addMessage("hold SHIFT to copy");
  }
  if (dropEffect !== "move" && moveAllowed && defaultDropEffect !== "move") {
    addMessage("hold CONTROL to move");
  }
  return { dropEffect, dropEffectMessage: message };
}
function getLayerDropEffect(event, manager, targetIsLayerListPanel, newTarget) {
  const source = getCompatibleDragSource(manager);
  let moveAllowed = false;
  let defaultDropEffect;
  if (source === void 0) {
    defaultDropEffect = "copy";
  } else {
    if (newTarget) {
      if (!source.isLayerListPanel) {
        moveAllowed = true;
      }
      defaultDropEffect = "link";
    } else {
      if (source.manager === manager && source.isLayerListPanel === targetIsLayerListPanel) {
        defaultDropEffect = "move";
        moveAllowed = true;
      } else if (targetIsLayerListPanel) {
        defaultDropEffect = "none";
      } else if (source.isLayerListPanel) {
        defaultDropEffect = "link";
      } else {
        moveAllowed = true;
        defaultDropEffect = "link";
      }
    }
  }
  return getDropEffectFromModifiers(event, defaultDropEffect, moveAllowed);
}
function updateLayerDropEffect(event, manager, targetIsLayerListPanel, newTarget) {
  const result = getLayerDropEffect(event, manager, targetIsLayerListPanel, newTarget);
  setDropEffect(event, result.dropEffect);
  return result;
}
function getDropLayers(event, manager, options) {
  const forceCopy = options.forceCopy, newTarget = options.newTarget;
  var _options$isLayerListP = options.isLayerListPanel;
  const isLayerListPanel = _options$isLayerListP === void 0 ? false : _options$isLayerListP;
  const source = getCompatibleDragSource(manager);
  if (!forceCopy && source !== void 0) {
    const moveSupported = !newTarget && source.manager === manager && (source.isLayerListPanel === isLayerListPanel || source.isLayerListPanel);
    const result = new DropLayers();
    result.manager = manager;
    result.numSourceLayers = source.layers.length;
    result.sourceManager = source.manager;
    result.targetIsLayerListPanel = isLayerListPanel;
    result.sourceIsLayerListPanel = source.isLayerListPanel;
    result.moveSupported = moveSupported;
    result.layers = new _Map();
    result.forceCopy = false;
    result.layoutSpec = source.layoutSpec;
    if (moveSupported) {
      source.layers.forEach((layer, index2) => {
        result.layers.set(layer, index2);
      });
    } else {
      source.layers.forEach((layer, index2) => {
        if (newTarget || !manager.layerManager.has(layer)) {
          result.layers.set(layer.addRef(), index2);
        }
      });
    }
    return result;
  }
  const info = getLayerDragInfo(event);
  if (info !== void 0) {
    try {
      const layers = parseArray(info.parameters, (layerInfo, index2) => {
        const name2 = verifyObjectProperty(layerInfo, "name", verifyString);
        let visible = verifyObjectProperty(layerInfo, "visible", verifyBoolean);
        const newLayer = new ManagedUserLayer(name2, manager);
        if (isLayerListPanel) visible = false;
        newLayer.visible = visible;
        newLayer.archived = isLayerListPanel;
        return [newLayer, index2];
      });
      const result = new DropLayers();
      result.numSourceLayers = layers.length;
      result.targetIsLayerListPanel = isLayerListPanel;
      result.sourceIsLayerListPanel = false;
      result.sourceManager = void 0;
      result.moveSupported = false;
      result.forceCopy = source !== void 0;
      result.manager = manager;
      result.dragType = info.dragType;
      result.layers = new _Map(layers);
      return result;
    } catch (_a) {
    }
  }
  return void 0;
}
function destroyDropLayers(dropLayers, targetLayer) {
  if (dropLayers.moveSupported) {
    return false;
  }
  dropLayers.manager.layerManager.filter((layer) => !dropLayers.layers.has(layer));
  return targetLayer !== void 0 && dropLayers.layers.has(targetLayer);
}
function registerLayerBarDropHandlers(panel, target, targetLayer, isLayerListPanel = false) {
  function update(event, updateDropEffect) {
    let dropLayers = panel.dropLayers;
    var _ref3 = updateDropEffect ? getLayerDropEffect(
      event,
      panel.manager,
      isLayerListPanel,
      /*newTarget=*/
      false
    ) : { dropEffect: getDropEffect(), dropEffectMessage: "" };
    const dropEffect = _ref3.dropEffect, dropEffectMessage = _ref3.dropEffectMessage;
    if (dropEffect === void 0) return void 0;
    setDropEffect(event, dropEffect);
    let existingDropLayers = true;
    if (dropLayers !== void 0) {
      if (!dropLayers.compatibleWithMethod(dropEffect)) {
        panel.dropLayers = void 0;
        if (destroyDropLayers(dropLayers, targetLayer)) {
          return void 0;
        }
      }
    }
    if (dropLayers === void 0) {
      dropLayers = panel.dropLayers = getDropLayers(event, panel.manager, { forceCopy: dropEffect === "copy", newTarget: false, isLayerListPanel });
      if (dropLayers === void 0) {
        return void 0;
      }
      existingDropLayers = dropLayers.method === "move";
    }
    if (targetLayer !== void 0 && dropLayers.layers.has(targetLayer)) {
      return { dropLayers, dropEffect, dropEffectMessage };
    }
    if (!existingDropLayers) {
      let newIndex;
      if (targetLayer !== void 0) {
        newIndex = panel.manager.layerManager.managedLayers.indexOf(targetLayer);
      }
      for (const newLayer of dropLayers.layers.keys()) {
        panel.manager.add(newLayer, newIndex);
      }
    } else {
      const layerManager = panel.manager.layerManager;
      const existingLayers = new _Set();
      let firstRemovalIndex = Number.POSITIVE_INFINITY;
      const managedLayers = layerManager.managedLayers = layerManager.managedLayers.filter((x, index2) => {
        if (dropLayers.layers.has(x)) {
          if (firstRemovalIndex === Number.POSITIVE_INFINITY) {
            firstRemovalIndex = index2;
          }
          existingLayers.add(x);
          return false;
        } else {
          return true;
        }
      });
      let newIndex;
      if (targetLayer !== void 0) {
        newIndex = managedLayers.indexOf(targetLayer);
        if (firstRemovalIndex <= newIndex) {
          ++newIndex;
        }
      } else {
        newIndex = managedLayers.length;
      }
      for (const layer of dropLayers.layers.keys()) {
        if (!existingLayers.has(layer)) {
          dropLayers.layers.delete(layer);
        }
      }
      managedLayers.splice(newIndex, 0, ...dropLayers.layers.keys());
      layerManager.layersChanged.dispatch();
    }
    return { dropLayers, dropEffect, dropEffectMessage };
  }
  target.addEventListener("dragenter", (event) => {
    if (update(
      event,
      /*updateDropEffect=*/
      true
    ) !== void 0) {
      event.preventDefault();
    } else {
      popDragStatus(panel.element, "drop");
    }
  });
  target.addEventListener("drop", (event) => {
    var _a;
    event.preventDefault();
    panel.dragEnterCount = 0;
    popDragStatus(panel.element, "drop");
    const dropLayers = (_a = update(
      event,
      /*updateDropEffect=*/
      false
    )) === null || _a === void 0 ? void 0 : _a.dropLayers;
    panel.dropLayers = void 0;
    if (dropLayers === void 0) return;
    if (!dropLayers.initializeExternalLayers(event)) {
      destroyDropLayers(dropLayers);
      return;
    }
    dropLayers.updateArchiveStates(event);
    endLayerDrag(dropLayers.method === "move" ? void 0 : event.dataTransfer.dropEffect);
  });
  target.addEventListener("dragover", (event) => {
    const updateResult = update(
      event,
      /*updateDropEffect=*/
      true
    );
    if (updateResult === void 0) {
      popDragStatus(panel.element, "drop");
      return;
    }
    const dropLayers = updateResult.dropLayers, dropEffect = updateResult.dropEffect, dropEffectMessage = updateResult.dropEffectMessage;
    const numLayers = dropLayers.layers.size;
    let message = "";
    const maybePlural = dropLayers.numSourceLayers === 1 ? "" : "s";
    const numSourceLayers = dropLayers.numSourceLayers;
    if (dropEffect === "none") {
      message = `Cannot link dragged layer${maybePlural} here`;
    } else {
      const layerCountMessage = numSourceLayers === numLayers ? `${numSourceLayers}` : `${numLayers}/${numSourceLayers}`;
      message = `Drop to ${dropEffect} ${layerCountMessage} layer${maybePlural}`;
    }
    if (dropEffectMessage) {
      message += ` (${dropEffectMessage})`;
    }
    pushDragStatus(panel.element, "drop", message);
    event.preventDefault();
    event.stopPropagation();
  });
}
function registerLayerDragHandlers(panel, element, layer, options) {
  element.draggable = true;
  element.addEventListener("dragstart", (event) => {
    pushDragStatus(element, "drag", "Drag layer to another layer bar/panel (including in another Neuroglancer window), or to the left/top/right/bottom edge of a layer group");
    startLayerDrag(event, {
      manager: panel.manager,
      layers: [layer],
      layoutSpec: options.getLayoutSpec(),
      isLayerListPanel: options.isLayerListPanel
    });
    event.stopPropagation();
  });
  element.addEventListener("dragend", () => {
    popDragStatus(element, "drag");
    endLayerDrag();
  });
}
function registerLayerBarDragLeaveHandler(panel) {
  panel.element.addEventListener("dragenter", () => {
    ++panel.dragEnterCount;
  });
  panel.element.addEventListener("dragleave", () => {
    if (--panel.dragEnterCount !== 0) return;
    popDragStatus(panel.element, "drop");
    const dropLayers = panel.dropLayers;
    if (dropLayers !== void 0) {
      destroyDropLayers(dropLayers);
      panel.manager.layerManager.layersChanged.dispatch();
      panel.dropLayers = void 0;
    }
  });
}
const svg_bin = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="binIconTitle"><title id="binIconTitle">Bin</title><path d="M19 6L5 6M14 5L10 5M6 10L6 20C6 20.6666667 6.33333333 21 7 21 7.66666667 21 11 21 17 21 17.6666667 21 18 20.6666667 18 20 18 19.3333333 18 16 18 10"></path></svg>';
function makeDeleteButton(options = {}) {
  const icon = makeIcon(_Object$assign({ svg: svg_bin }, options));
  const svg = icon.firstElementChild;
  svg.style.fill = "white";
  return icon;
}
var es6_string_raw = {};
var hasRequiredEs6_string_raw;
function requireEs6_string_raw() {
  if (hasRequiredEs6_string_raw) return es6_string_raw;
  hasRequiredEs6_string_raw = 1;
  var $export = require_export();
  var toIObject = require_toIobject();
  var toLength = require_toLength();
  $export($export.S, "String", {
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function raw2(callSite) {
      var tpl = toIObject(callSite.raw);
      var len2 = toLength(tpl.length);
      var aLen = arguments.length;
      var res = [];
      var i = 0;
      while (len2 > i) {
        res.push(String(tpl[i++]));
        if (i < aLen) res.push(String(arguments[i]));
      }
      return res.join("");
    }
  });
  return es6_string_raw;
}
var raw$1;
var hasRequiredRaw$1;
function requireRaw$1() {
  if (hasRequiredRaw$1) return raw$1;
  hasRequiredRaw$1 = 1;
  requireEs6_string_raw();
  raw$1 = require_core().String.raw;
  return raw$1;
}
var raw;
var hasRequiredRaw;
function requireRaw() {
  if (hasRequiredRaw) return raw;
  hasRequiredRaw = 1;
  raw = { "default": requireRaw$1(), __esModule: true };
  return raw;
}
var rawExports = requireRaw();
const _String$raw = /* @__PURE__ */ getDefaultExportFromCjs(rawExports);
const positionDragType = "neuroglancer-position";
const inputEventMap$3 = EventActionMap.fromObject({
  "arrowup": { action: "adjust-up" },
  "arrowdown": { action: "adjust-down" },
  "arrowleft": { action: "maybe-tab-backward", preventDefault: false },
  "arrowright": { action: "maybe-tab-forward", preventDefault: false },
  "tab": { action: "tab-forward" },
  "shift+tab": { action: "tab-backward" },
  "wheel": { action: "adjust-via-wheel" },
  "backspace": { action: "delete-backward", preventDefault: false },
  "enter": { action: "commit" },
  "escape": { action: "cancel" }
});
const widgetFieldGetters = [(w) => w.nameElement, (w) => w.coordinate, (w) => w.scaleElement];
function getCoordinateArray(coordinateSpace, dimensionIndex) {
  const coordinateArray = coordinateSpace.coordinateArrays[dimensionIndex];
  if (coordinateArray === void 0) return coordinateArray;
  if (coordinateSpace.units[dimensionIndex] != "" || coordinateSpace.scales[dimensionIndex] !== 1) {
    return null;
  }
  return coordinateArray;
}
let DimensionWidget$1 = class DimensionWidget {
  constructor(coordinateSpace, initialDimensionIndex) {
    this.coordinateSpace = coordinateSpace;
    this.container = document.createElement("div");
    this.nameContainer = document.createElement("span");
    this.nameElement = document.createElement("input");
    this.scaleContainer = document.createElement("span");
    this.scaleElement = document.createElement("input");
    this.coordinate = document.createElement("input");
    this.coordinateLabel = document.createElement("span");
    this.coordinateLabelWidth = 0;
    this.dropdownOwner = void 0;
    this.modified = false;
    this.draggingPosition = false;
    this.hasFocus = false;
    const container = this.container, scaleElement = this.scaleElement, scaleContainer = this.scaleContainer, coordinate = this.coordinate, nameElement = this.nameElement, nameContainer = this.nameContainer, coordinateLabel = this.coordinateLabel;
    container.title = "";
    container.classList.add("neuroglancer-position-dimension");
    container.draggable = true;
    container.tabIndex = -1;
    container.appendChild(nameContainer);
    container.appendChild(scaleElement);
    nameContainer.appendChild(nameElement);
    nameContainer.title = `Drag to reorder, double click to rename.  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).`;
    scaleContainer.appendChild(scaleElement);
    nameElement.classList.add("neuroglancer-position-dimension-name");
    nameElement.disabled = true;
    nameElement.spellcheck = false;
    nameElement.autocomplete = "off";
    nameElement.required = true;
    nameElement.placeholder = " ";
    scaleContainer.classList.add("neuroglancer-position-dimension-scale-container");
    scaleElement.classList.add("neuroglancer-position-dimension-scale");
    scaleElement.disabled = true;
    scaleElement.spellcheck = false;
    scaleElement.autocomplete = "off";
    container.appendChild(scaleContainer);
    container.appendChild(coordinate);
    coordinate.type = "text";
    coordinate.classList.add("neuroglancer-position-dimension-coordinate");
    coordinate.spellcheck = false;
    coordinate.autocomplete = "off";
    coordinate.pattern = _String$raw`(-?\d+(?:\.(?:\d+)?)?)`;
    const coordinateArray = getCoordinateArray(coordinateSpace, initialDimensionIndex);
    if (coordinateArray != null) {
      let maxLabelWidth = 0;
      for (const label of coordinateArray.labels) {
        maxLabelWidth = Math.max(maxLabelWidth, label.length);
      }
      this.coordinateLabelWidth = maxLabelWidth;
      coordinateLabel.style.width = `${maxLabelWidth + 2}ch`;
      container.appendChild(coordinateLabel);
    }
    coordinate.required = true;
    coordinate.placeholder = " ";
    coordinateLabel.classList.add("neuroglancer-position-dimension-coordinate-label");
  }
};
function getCanvasYFromCoordinate(coordinate, lowerBound, upperBound, canvasHeight) {
  return Math.floor((coordinate - lowerBound) * (canvasHeight - 1) / (upperBound - lowerBound));
}
function getNormalizedDimensionBounds(coordinateSpace, dimensionIndex, height) {
  const boundingBoxes = coordinateSpace.boundingBoxes, bounds = coordinateSpace.bounds;
  const lowerBound = Math.floor(bounds.lowerBounds[dimensionIndex]);
  const upperBound = Math.ceil(bounds.upperBounds[dimensionIndex] - 1);
  if (!_Number$isFinite(lowerBound) || !_Number$isFinite(upperBound)) {
    return void 0;
  }
  const normalizedBounds = [];
  const normalize2 = (x) => {
    return getCanvasYFromCoordinate(x, lowerBound, upperBound, height);
  };
  const rank = coordinateSpace.rank;
  for (const boundingBox of boundingBoxes) {
    const result = computeCombinedLowerUpperBound(boundingBox, dimensionIndex, rank);
    if (result === void 0) continue;
    result.lower = normalize2(result.lower);
    result.upper = normalize2(Math.ceil(result.upper - 1));
    normalizedBounds.push(result);
  }
  normalizedBounds.sort((a, b) => {
    const lowerDiff = a.lower - b.lower;
    if (lowerDiff !== 0) return lowerDiff;
    return b.upper - b.upper;
  });
  filterArrayInplace(normalizedBounds, (x, i) => {
    if (i === 0) return true;
    const prev = normalizedBounds[i - 1];
    return prev.lower !== x.lower || prev.upper !== x.upper;
  });
  return { lowerBound, upperBound, normalizedBounds };
}
const tickWidth = 10;
const barWidth = 15;
const barRightMargin = 10;
const canvasWidth = tickWidth + barWidth + barRightMargin;
function drawDimensionBounds(canvas, ctx, bounds) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const normalizedBounds = bounds.normalizedBounds;
  function drawTick(x) {
    ctx.fillRect(0, x, tickWidth, 1);
  }
  ctx.fillStyle = "#fff";
  for (const _ref of normalizedBounds) {
    const lower = _ref.lower;
    const upper = _ref.upper;
    drawTick(lower);
    drawTick(upper);
  }
  const length2 = normalizedBounds.length;
  ctx.fillStyle = "#ccc";
  for (let i = 0; i < length2; ++i) {
    var _normalizedBounds$i = normalizedBounds[i];
    const lower = _normalizedBounds$i.lower, upper = _normalizedBounds$i.upper;
    const startX = Math.floor(i * barWidth / length2);
    const width = Math.max(1, barWidth / length2);
    ctx.fillRect(startX + tickWidth, lower, width, upper + 1 - lower);
  }
}
function updateCoordinateFieldWidth(element, value) {
  updateInputFieldWidth$1(element, value.length + 1);
}
function updateScaleElementStyle(scaleElement) {
  const value = scaleElement.value;
  updateInputFieldWidth$1(scaleElement);
  scaleElement.parentElement.dataset.isEmpty = value === "" ? "true" : "false";
}
class PositionWidget extends RefCounted {
  constructor(position, combiner, { copyButton = true } = {}) {
    super();
    this.position = position;
    this.combiner = combiner;
    this.element = document.createElement("div");
    this.dimensionContainer = document.createElement("div");
    this.coordinateSpace = void 0;
    this.dimensionWidgets = new _Map();
    this.dimensionWidgetList = [];
    this.dragSource = void 0;
    const element = this.element, dimensionContainer = this.dimensionContainer;
    this.registerDisposer(position.coordinateSpace.changed.add(this.registerCancellable(animationFrameDebounce(() => this.updateDimensions()))));
    element.className = "neuroglancer-position-widget";
    dimensionContainer.style.display = "contents";
    element.appendChild(dimensionContainer);
    if (copyButton) {
      const copyButton2 = makeCopyButton({
        title: "Copy position to clipboard",
        onClick: () => {
          const result = setClipboard(this.getPositionText());
          StatusMessage.showTemporaryMessage(result ? "Position copied to clipboard" : "Failed to copy position to clipboard");
        }
      });
      copyButton2.addEventListener("dragstart", (event) => {
        event.dataTransfer.setData(positionDragType, _JSON$stringify({ position: position.toJSON(), dimensions: position.coordinateSpace.value.names }));
        event.dataTransfer.setData("text", this.getPositionText());
        event.stopPropagation();
      });
      copyButton2.draggable = true;
      element.appendChild(copyButton2);
    }
    this.registerDisposer(position.changed.add(this.registerCancellable(animationFrameDebounce(() => this.updateView()))));
    const keyboardHandler = this.registerDisposer(new KeyboardEventBinder(element, inputEventMap$3));
    keyboardHandler.allShortcutsAreGlobal = true;
    this.registerDisposer(new MouseEventBinder(element, inputEventMap$3));
    this.registerDisposer(registerActionListener(element, "cancel", (event) => {
      this.coordinateSpace = void 0;
      this.updateView();
      this.closeDropdown();
      const target = event.target;
      if (target instanceof HTMLElement) {
        target.blur();
      }
    }));
    this.updateView();
  }
  openRegularDropdown(widget, dropdown) {
    dropdown.classList.add("neuroglancer-position-dimension-dropdown");
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const lowerBoundElement = document.createElement("div");
    const lowerBoundContainer = document.createElement("div");
    lowerBoundContainer.appendChild(lowerBoundElement);
    const lowerBoundText = document.createTextNode("");
    lowerBoundElement.appendChild(lowerBoundText);
    const upperBoundElement = document.createElement("div");
    const hoverElement = document.createElement("div");
    lowerBoundContainer.classList.add("neuroglancer-position-dimension-dropdown-lowerbound");
    upperBoundElement.classList.add("neuroglancer-position-dimension-dropdown-upperbound");
    hoverElement.classList.add("neuroglancer-position-dimension-dropdown-hoverposition");
    dropdown.appendChild(lowerBoundContainer);
    dropdown.appendChild(upperBoundElement);
    dropdown.appendChild(hoverElement);
    dropdown.appendChild(canvas);
    const canvasHeight = 100;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    upperBoundElement.style.marginTop = `${canvasHeight - 1}px`;
    let prevLowerBound, prevUpperBound;
    let hoverPosition = void 0;
    const updateView = () => {
      const dimensionIndex = this.dimensionWidgetList.indexOf(widget);
      if (dimensionIndex === -1) return;
      const coordinateSpace = widget.coordinateSpace;
      const normalizedDimensionBounds = getNormalizedDimensionBounds(coordinateSpace, dimensionIndex, canvasHeight);
      if (normalizedDimensionBounds === void 0 || coordinateSpace.bounds.lowerBounds[dimensionIndex] + 1 === coordinateSpace.bounds.upperBounds[dimensionIndex]) {
        dropdown.style.display = "none";
        widget.container.dataset.dropdownVisible = void 0;
        return;
      }
      widget.container.dataset.dropdownVisible = "true";
      dropdown.style.display = "";
      const lowerBound = normalizedDimensionBounds.lowerBound, upperBound = normalizedDimensionBounds.upperBound;
      prevLowerBound = lowerBound;
      prevUpperBound = upperBound;
      lowerBoundText.textContent = lowerBound.toString();
      upperBoundElement.textContent = upperBound.toString();
      drawDimensionBounds(canvas, ctx, normalizedDimensionBounds);
      const curPosition = this.position.value[dimensionIndex];
      if (curPosition >= lowerBound && curPosition <= upperBound) {
        ctx.fillStyle = "#f66";
        ctx.fillRect(0, getCanvasYFromCoordinate(curPosition, lowerBound, upperBound, canvasHeight), canvasWidth, 1);
      }
      if (hoverPosition !== void 0 && hoverPosition >= lowerBound && hoverPosition <= upperBound) {
        ctx.fillStyle = "#66f";
        const hoverOffset = getCanvasYFromCoordinate(hoverPosition, lowerBound, upperBound, canvasHeight);
        ctx.fillRect(0, hoverOffset, canvasWidth, 1);
        hoverElement.textContent = hoverPosition.toString();
        const labelHeight = lowerBoundElement.clientHeight;
        lowerBoundElement.style.visibility = hoverOffset > labelHeight ? "" : "hidden";
        upperBoundElement.style.visibility = hoverOffset < canvasHeight - labelHeight ? "" : "hidden";
        hoverElement.style.display = "";
        hoverElement.style.visibility = "visible";
        hoverElement.style.marginTop = `${hoverOffset}px`;
      } else {
        lowerBoundElement.style.visibility = "";
        hoverElement.style.display = "none";
        upperBoundElement.style.visibility = "";
      }
    };
    const dropdownOwner = widget.dropdownOwner;
    const scheduleUpdateView = dropdownOwner.registerCancellable(animationFrameDebounce(updateView));
    dropdownOwner.registerDisposer(this.position.changed.add(scheduleUpdateView));
    const getPositionFromMouseEvent = (event) => {
      if (prevLowerBound === void 0 || prevUpperBound === void 0) return void 0;
      const canvasBounds = canvas.getBoundingClientRect();
      let relativeY = (event.clientY - canvasBounds.top) / canvasBounds.height;
      relativeY = Math.max(0, relativeY);
      relativeY = Math.min(1, relativeY);
      return Math.round(relativeY * (prevUpperBound - prevLowerBound)) + prevLowerBound;
    };
    const setPositionFromMouse = (event) => {
      const dimensionIndex = this.dimensionWidgetList.indexOf(widget);
      if (dimensionIndex === -1) return;
      const x = getPositionFromMouseEvent(event);
      if (x === void 0) return;
      const position = this.position;
      const voxelCoordinates = position.value;
      voxelCoordinates[dimensionIndex] = x + 0.5;
      widget.modified = false;
      position.value = voxelCoordinates;
    };
    canvas.addEventListener("pointermove", (event) => {
      const x = getPositionFromMouseEvent(event);
      hoverPosition = x;
      scheduleUpdateView();
    });
    canvas.addEventListener("pointerleave", () => {
      hoverPosition = void 0;
      scheduleUpdateView();
    });
    canvas.addEventListener("pointerdown", (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
        return;
      }
      startRelativeMouseDrag(event, (newEvent) => {
        if (widget.dropdownOwner === void 0) return;
        hoverPosition = void 0;
        setPositionFromMouse(newEvent);
        scheduleUpdateView();
        widget.draggingPosition = true;
      }, () => {
        widget.draggingPosition = false;
        this.updateDropdownVisibility(widget);
      });
      setPositionFromMouse(event);
    });
    updateView();
  }
  openCoordinateArrayDropdown(widget, dropdown, coordinateArray) {
    dropdown.classList.add("neuroglancer-position-dimension-coordinate-dropdown");
    const coordinates = coordinateArray.coordinates, labels = coordinateArray.labels;
    const length2 = coordinates.length;
    dropdown.style.setProperty("--neuroglancer-coordinate-label-width", `${widget.coordinateLabelWidth}ch`);
    for (let i = 0; i < length2; ++i) {
      const entryElement = document.createElement("div");
      entryElement.classList.add("neuroglancer-dimension-dropdown-coordinate-entry");
      const coordinateElement = document.createElement("div");
      coordinateElement.classList.add("neuroglancer-dimension-dropdown-coordinate");
      const labelElement = document.createElement("div");
      labelElement.classList.add("neuroglancer-dimension-dropdown-coordinate-label");
      labelElement.textContent = labels[i];
      coordinateElement.textContent = coordinates[i].toString();
      entryElement.appendChild(coordinateElement);
      entryElement.appendChild(labelElement);
      entryElement.addEventListener("click", () => {
        const dimensionIndex = this.dimensionWidgetList.indexOf(widget);
        if (dimensionIndex === -1) return;
        const position = this.position;
        const voxelCoordinates = position.value;
        voxelCoordinates[dimensionIndex] = coordinates[i] + 0.5;
        widget.modified = false;
        position.value = voxelCoordinates;
      });
      dropdown.appendChild(entryElement);
    }
  }
  openDropdown(widget) {
    if (widget.dropdownOwner !== void 0) return;
    const initialDimensionIndex = this.dimensionWidgetList.indexOf(widget);
    if (initialDimensionIndex === -1) return;
    this.closeDropdown();
    const dropdownOwner = widget.dropdownOwner = new RefCounted();
    const dropdown = document.createElement("div");
    dropdown.draggable = true;
    dropdown.addEventListener("dragstart", (event) => {
      event.stopPropagation();
      event.preventDefault();
    });
    dropdown.addEventListener("pointerenter", () => {
      widget.hasFocus = true;
    });
    dropdown.tabIndex = -1;
    widget.container.appendChild(dropdown);
    const coordinateArray = getCoordinateArray(widget.coordinateSpace, initialDimensionIndex);
    if (coordinateArray == null) {
      this.openRegularDropdown(widget, dropdown);
    } else {
      this.openCoordinateArrayDropdown(widget, dropdown, coordinateArray);
    }
    this.widgetWithOpenDropdown = widget;
    dropdownOwner.registerDisposer(() => {
      removeFromParent(dropdown);
      widget.dropdownOwner = void 0;
      delete widget.container.dataset.dropdownVisible;
      this.widgetWithOpenDropdown = void 0;
    });
    dropdownOwner.registerEventListener(document, "pointerdown", (event) => {
      const target = event.target;
      if (target instanceof Node && widget.container.contains(target)) {
        return;
      }
      this.closeDropdown(widget);
    }, { capture: true });
  }
  closeDropdown(widget = this.widgetWithOpenDropdown) {
    if (widget === void 0) return;
    const dropdownOwner = widget.dropdownOwner;
    if (dropdownOwner === void 0) return;
    dropdownOwner.dispose();
  }
  pasteString(widget, s) {
    while (true) {
      widget.coordinate.focus();
      const m = s.match(/^\s*(-?\d+(?:\.(?:\d+)?)?)((?:\s+(?![\s,]))|(?:\s*,\s*))?/);
      if (m === null) break;
      if (m[1] !== void 0) {
        document.execCommand("insertText", void 0, m[1]);
      }
      if (m[2] !== void 0) {
        const dimensionWidgetList = this.dimensionWidgetList;
        const dimensionIndex = dimensionWidgetList.indexOf(widget);
        if (dimensionIndex === -1 || dimensionIndex + 1 === dimensionWidgetList.length) {
          break;
        }
        const remaining = s.substring(m[0].length);
        const nextWidget = dimensionWidgetList[dimensionIndex + 1];
        widget = nextWidget;
        s = remaining;
        continue;
      }
      break;
    }
  }
  reorderDimensionTo(targetIndex, sourceIndex) {
    if (targetIndex === sourceIndex) return;
    const coordinateSpace = this.position.coordinateSpace;
    coordinateSpace.value = insertDimensionAt(coordinateSpace.value, targetIndex, sourceIndex);
  }
  updateDropdownVisibility(widget) {
    if (widget.hasFocus || widget.draggingPosition) {
      this.openDropdown(widget);
    } else {
      this.closeDropdown(widget);
    }
  }
  newDimension(coordinateSpace, initialDimensionIndex) {
    const widget = new DimensionWidget$1(coordinateSpace, initialDimensionIndex);
    widget.container.addEventListener("dragstart", (event) => {
      this.dragSource = widget;
      event.stopPropagation();
      event.dataTransfer.setData("neuroglancer-dimension", "");
    });
    widget.container.addEventListener("dragenter", (event) => {
      const dragSource2 = this.dragSource;
      if (dragSource2 === void 0 || dragSource2 === widget) return;
      const dimensionWidgetList = this.dimensionWidgetList;
      const sourceIndex = dimensionWidgetList.indexOf(dragSource2);
      const targetIndex = dimensionWidgetList.indexOf(widget);
      if (sourceIndex === -1 || targetIndex === -1) return;
      event.preventDefault();
      this.reorderDimensionTo(targetIndex, sourceIndex);
    });
    widget.container.addEventListener("dragend", (event) => {
      if (this.dragSource === widget) {
        this.dragSource = void 0;
      }
    });
    widget.nameContainer.addEventListener("dblclick", () => {
      widget.nameElement.disabled = false;
      widget.nameElement.focus();
      widget.nameElement.select();
    });
    widget.scaleContainer.addEventListener("dblclick", () => {
      widget.scaleElement.disabled = false;
      widget.scaleElement.focus();
      widget.scaleElement.select();
    });
    widget.coordinate.addEventListener("focus", () => {
      widget.coordinate.select();
    });
    widget.container.addEventListener("focusin", () => {
      widget.hasFocus = true;
      this.updateDropdownVisibility(widget);
    });
    widget.container.addEventListener("focusout", (event) => {
      const relatedTarget = event.relatedTarget;
      if (relatedTarget instanceof Node && widget.container.contains(relatedTarget)) {
        return;
      }
      widget.hasFocus = false;
      this.updateDropdownVisibility(widget);
    });
    widget.container.addEventListener("click", (event) => {
      if (!(event.target instanceof HTMLInputElement) || event.target.disabled) {
        widget.coordinate.focus();
      }
    });
    widget.coordinate.addEventListener("paste", (event) => {
      const input = widget.coordinate;
      const value = input.value;
      const clipboardData = event.clipboardData;
      if (clipboardData === null) return;
      let text = clipboardData.getData("text");
      let selectionEnd = input.selectionEnd, selectionStart = input.selectionStart;
      if (selectionStart !== 0 || selectionEnd !== value.length) {
        if (selectionStart == null) selectionStart = 0;
        if (selectionEnd == null) selectionEnd = 0;
        const invalidMatch = text.match(/[^\-0-9\.]/);
        if (invalidMatch !== null) {
          text = text.substring(0, invalidMatch.index);
        }
        if (text.length > 0) {
          document.execCommand("insertText", void 0, text);
        }
      } else {
        this.pasteString(widget, text);
      }
      event.preventDefault();
      event.stopPropagation();
    });
    widget.coordinate.addEventListener("input", () => {
      widget.modified = true;
      const input = widget.coordinate;
      const value = input.value;
      let selectionDirection = input.selectionDirection, selectionEnd = input.selectionEnd, selectionStart = input.selectionStart;
      if (selectionStart === null) selectionStart = 0;
      if (selectionEnd === null) selectionEnd = selectionStart;
      let newValue = "";
      const invalidPattern = /[^\-0-9\.]/g;
      newValue += value.substring(0, selectionStart).replace(invalidPattern, "");
      const newSelectionStart = newValue.length;
      newValue += value.substring(selectionStart, selectionEnd).replace(invalidPattern, "");
      const newSelectionEnd = newValue.length;
      newValue += value.substring(selectionEnd).replace(invalidPattern, "");
      input.value = newValue;
      input.selectionStart = newSelectionStart;
      input.selectionEnd = newSelectionEnd;
      input.selectionDirection = selectionDirection;
      updateCoordinateFieldWidth(input, newValue);
      if (selectionEnd === selectionStart && selectionEnd === value.length && value.match(/^(-?\d+(?:\.(?:\d+)?)?)((?:\s+(?![\s,]))|(?:\s*,\s*))$/)) {
        this.selectAdjacentCoordinate(widget, 1);
      }
    });
    widget.nameElement.addEventListener("input", () => {
      const nameElement = widget.nameElement;
      updateInputFieldWidth$1(nameElement);
      this.updateNameValidity();
    });
    widget.scaleElement.addEventListener("input", () => {
      const scaleElement = widget.scaleElement;
      updateScaleElementStyle(scaleElement);
      this.updateScaleValidity(widget);
    });
    widget.coordinate.addEventListener("blur", (event) => {
      const relatedTarget = event.relatedTarget;
      if (this.dimensionWidgetList.some((widget2) => widget2.coordinate === relatedTarget)) {
        return;
      }
      if (widget.modified) {
        this.updatePosition();
      }
    });
    widget.nameElement.addEventListener("blur", (event) => {
      widget.nameElement.disabled = true;
      const relatedTarget = event.relatedTarget;
      if (this.dimensionWidgetList.some((widget2) => widget2.nameElement === relatedTarget)) {
        return;
      }
      if (!this.updateNames()) {
        this.forceUpdateDimensions();
      }
    });
    widget.scaleElement.addEventListener("blur", (event) => {
      widget.scaleElement.disabled = true;
      const relatedTarget = event.relatedTarget;
      if (this.dimensionWidgetList.some((widget2) => widget2.scaleElement === relatedTarget)) {
        return;
      }
      if (!this.updateScales()) {
        this.forceUpdateDimensions();
      }
    });
    registerActionListener(widget.container, "adjust-via-wheel", (actionEvent) => {
      const event = actionEvent.detail;
      const deltaY = event.deltaY;
      if (deltaY === 0) {
        return;
      }
      this.adjustDimension(widget, _Math$sign(deltaY));
    });
    registerActionListener(widget.container, "adjust-up", () => {
      this.adjustDimension(widget, -1);
    });
    registerActionListener(widget.container, "adjust-down", () => {
      this.adjustDimension(widget, 1);
    });
    for (const getter of widgetFieldGetters) {
      const e = getter(widget);
      registerActionListener(e, "maybe-tab-forward", (event) => {
        this.handleLeftRightMovement(event, widget, 1, getter);
      });
      registerActionListener(e, "maybe-tab-backward", (event) => {
        this.handleLeftRightMovement(event, widget, -1, getter);
      });
      registerActionListener(e, "tab-forward", () => {
        this.selectAdjacentField(widget, 1, getter);
      });
      registerActionListener(e, "tab-backward", () => {
        this.selectAdjacentField(widget, -1, getter);
      });
    }
    registerActionListener(widget.coordinate, "commit", () => {
      this.updatePosition();
    });
    registerActionListener(widget.nameElement, "commit", () => {
      this.updateNames();
    });
    registerActionListener(widget.scaleElement, "commit", () => {
      this.updateScales();
    });
    registerActionListener(widget.coordinate, "delete-backward", (event) => {
      event.stopPropagation();
      const coordinate = widget.coordinate;
      if (coordinate.selectionStart === coordinate.selectionEnd && coordinate.selectionStart === 0) {
        event.preventDefault();
        this.selectAdjacentCoordinate(widget, -1);
      }
    });
    return widget;
  }
  forceUpdateDimensions() {
    let coordinateSpace = this.position.coordinateSpace.value;
    if (!coordinateSpace.valid) {
      coordinateSpace = emptyInvalidCoordinateSpace;
    }
    this.coordinateSpace = coordinateSpace;
    const dimensionWidgets = this.dimensionWidgets, dimensionWidgetList = this.dimensionWidgetList;
    dimensionWidgetList.length = 0;
    var _coordinateSpace = coordinateSpace;
    const names = _coordinateSpace.names, ids = _coordinateSpace.ids, scales = _coordinateSpace.scales, units = _coordinateSpace.units;
    updateChildren(this.dimensionContainer, ids.map((id, i) => {
      let widget = dimensionWidgets.get(id);
      if (widget === void 0) {
        widget = this.newDimension(coordinateSpace, i);
        dimensionWidgets.set(id, widget);
      } else {
        widget.coordinateSpace = coordinateSpace;
      }
      const name2 = names[i];
      widget.nameElement.value = name2;
      delete widget.nameElement.dataset.isValid;
      updateInputFieldWidth$1(widget.nameElement);
      const coordinateArray = getCoordinateArray(coordinateSpace, i);
      if (coordinateArray === void 0) {
        widget.container.dataset.coordinateArray = "none";
      } else if (coordinateArray === null) {
        widget.container.dataset.coordinateArray = "invalid";
      } else {
        widget.container.dataset.coordinateArray = "valid";
      }
      widget.scaleContainer.title = "Drag to reorder, double click to change scale";
      if (coordinateArray === null) {
        widget.scaleContainer.title += ".  Coordinate array disabled.  To use the coordinate array, remove the unit/scale.";
      }
      var _formatScaleWithUnit = formatScaleWithUnit(scales[i], units[i]);
      const scale2 = _formatScaleWithUnit.scale, prefix = _formatScaleWithUnit.prefix, unit = _formatScaleWithUnit.unit;
      const scaleString = `${scale2}${prefix}${unit}`;
      widget.scaleElement.value = scaleString;
      delete widget.scaleElement.dataset.isValid;
      updateScaleElementStyle(widget.scaleElement);
      dimensionWidgetList.push(widget);
      return widget.container;
    }));
    for (const _ref2 of dimensionWidgets) {
      var _ref3 = _slicedToArray(_ref2, 2);
      const id = _ref3[0];
      const widget = _ref3[1];
      if (widget.coordinateSpace !== coordinateSpace) {
        this.closeDropdown(widget);
        dimensionWidgets.delete(id);
      }
    }
  }
  updateDimensions() {
    const coordinateSpace = this.position.coordinateSpace.value;
    if (coordinateSpace === this.coordinateSpace) return;
    this.forceUpdateDimensions();
  }
  selectAdjacentField(widget, dir, fieldGetter) {
    const dimensionWidgetList = this.dimensionWidgetList;
    let axisIndex = dimensionWidgetList.indexOf(widget);
    if (axisIndex === -1) return;
    while (true) {
      axisIndex += dir;
      if (axisIndex < 0 || axisIndex >= dimensionWidgetList.length) {
        return false;
      }
      const newWidget = dimensionWidgetList[axisIndex];
      const field = fieldGetter(newWidget);
      if (field.style.display === "none") continue;
      field.disabled = false;
      field.focus();
      field.selectionStart = 0;
      field.selectionEnd = field.value.length;
      field.selectionDirection = dir === 1 ? "forward" : "backward";
      return true;
    }
  }
  selectAdjacentCoordinate(widget, dir) {
    return this.selectAdjacentField(widget, dir, (w) => w.coordinate);
  }
  handleLeftRightMovement(event, widget, dir, getter) {
    event.stopPropagation();
    const element = getter(widget);
    if (element.selectionStart !== element.selectionEnd || element.selectionStart !== (dir === 1 ? element.value.length : 0)) {
      return;
    }
    if (this.selectAdjacentField(widget, dir, getter)) {
      event.preventDefault();
    }
  }
  updateNameValidity() {
    const dimensionWidgetList = this.dimensionWidgetList;
    const names = dimensionWidgetList.map((w) => w.nameElement.value);
    const rank = names.length;
    const isValid = this.combiner.getRenameValidity(names);
    for (let i = 0; i < rank; ++i) {
      dimensionWidgetList[i].nameElement.dataset.isValid = isValid[i] === false ? "false" : "true";
    }
  }
  updateScaleValidity(widget) {
    const isValid = parseScale(widget.scaleElement.value) !== void 0;
    widget.scaleElement.dataset.isValid = isValid.toString();
  }
  adjustDimension(widget, adjustment) {
    const axisIndex = this.dimensionWidgetList.indexOf(widget);
    if (axisIndex === -1) return;
    this.updatePosition();
    const position = this.position;
    if (!position.valid) {
      return;
    }
    const coordinateSpace = position.coordinateSpace.value;
    const bounds = coordinateSpace.bounds;
    const voxelCoordinates = Float32Array.from(position.value);
    let newValue = Math.floor(voxelCoordinates[axisIndex] + adjustment);
    if (adjustment > 0) {
      const bound = bounds.upperBounds[axisIndex];
      if (_Number$isFinite(bound)) {
        newValue = Math.min(newValue, Math.ceil(bound - 1));
      }
    } else {
      const bound = bounds.lowerBounds[axisIndex];
      if (_Number$isFinite(bound)) {
        newValue = Math.max(newValue, Math.floor(bound));
      }
    }
    voxelCoordinates[axisIndex] = newValue + 0.5;
    this.position.value = voxelCoordinates;
    this.updateView();
  }
  updatePosition() {
    const dimensionWidgetList = this.dimensionWidgetList;
    const position = this.position;
    const voxelCoordinates = position.value;
    if (voxelCoordinates === void 0) return;
    const rank = dimensionWidgetList.length;
    for (let i = 0; i < rank; ++i) {
      const widget = dimensionWidgetList[i];
      widget.modified = false;
      const value = Number(widget.coordinate.value);
      if (_Number$isFinite(value)) {
        voxelCoordinates[i] = value + (_Number$isInteger(value) ? 0.5 : 0);
      }
    }
    position.value = voxelCoordinates;
  }
  updateNames() {
    const dimensionWidgetList = this.dimensionWidgetList;
    const coordinateSpace = this.position.coordinateSpace;
    const existing = coordinateSpace.value;
    const names = dimensionWidgetList.map((x) => x.nameElement.value);
    if (this.combiner.getRenameValidity(names).includes(false)) return false;
    const existingNames = existing.names;
    if (arraysEqual(existingNames, names)) return false;
    const timestamps = existing.timestamps.map((t, i) => existingNames[i] === names[i] ? t : Date.now());
    const newSpace = _Object$assign(_Object$assign({}, existing), { names, timestamps });
    coordinateSpace.value = newSpace;
    return true;
  }
  updateScales() {
    const dimensionWidgetList = this.dimensionWidgetList;
    const coordinateSpace = this.position.coordinateSpace;
    const existing = coordinateSpace.value;
    const scalesAndUnits = dimensionWidgetList.map((x) => parseScale(x.scaleElement.value));
    if (scalesAndUnits.includes(void 0)) {
      return false;
    }
    const newScales = Float64Array.from(scalesAndUnits, (x) => x.scale);
    const newUnits = _Array$from(scalesAndUnits, (x) => x.unit);
    const scales = existing.scales, units = existing.units;
    if (arraysEqual(scales, newScales) && arraysEqual(units, newUnits)) return false;
    const timestamps = existing.timestamps.map((t, i) => newScales[i] === scales[i] && newUnits[i] === units[i] ? t : Date.now());
    const newSpace = makeCoordinateSpace({
      valid: existing.valid,
      rank: existing.rank,
      scales: newScales,
      units: newUnits,
      timestamps,
      ids: existing.ids,
      names: existing.names,
      boundingBoxes: existing.boundingBoxes,
      coordinateArrays: existing.coordinateArrays
    });
    coordinateSpace.value = newSpace;
    return true;
  }
  getPositionText() {
    const position = this.position;
    if (position.valid) {
      return position.value.map((x) => Math.floor(x)).join(", ");
    } else {
      return "";
    }
  }
  updateView() {
    this.updateDimensions();
    const voxelCoordinates = this.position.value, dimensionWidgetList = this.dimensionWidgetList;
    const rank = dimensionWidgetList.length;
    if (voxelCoordinates === void 0) {
      return;
    }
    const coordinateSpace = this.coordinateSpace;
    for (let i = 0; i < rank; ++i) {
      const widget = dimensionWidgetList[i];
      const inputElement = widget.coordinate;
      const newCoord = Math.floor(voxelCoordinates[i]);
      const newValue = newCoord.toString();
      updateCoordinateFieldWidth(inputElement, newValue);
      inputElement.value = newValue;
      const coordinateArray = getCoordinateArray(coordinateSpace, i);
      let label = "";
      if (coordinateArray != null) {
        const coordinates = coordinateArray.coordinates;
        const index2 = binarySearch(coordinates, newCoord, (a, b) => a - b);
        if (index2 !== coordinates.length) {
          label = coordinateArray.labels[index2];
        }
      }
      const labelElement = widget.coordinateLabel;
      labelElement.textContent = label;
    }
  }
  disposed() {
    this.closeDropdown();
    removeFromParent(this.element);
    super.disposed();
  }
}
class MousePositionWidget extends RefCounted {
  constructor(element, mouseState, coordinateSpace) {
    super();
    this.element = element;
    this.mouseState = mouseState;
    this.coordinateSpace = coordinateSpace;
    this.tempPosition = create$3();
    element.className = "neuroglancer-mouse-position-widget";
    const updateViewFunction = this.registerCancellable(animationFrameDebounce(() => this.updateView()));
    this.registerDisposer(mouseState.changed.add(updateViewFunction));
    this.registerDisposer(coordinateSpace.changed.add(updateViewFunction));
  }
  updateView() {
    let text = "";
    const mouseState = this.mouseState, coordinateSpace = this.coordinateSpace.value;
    if (mouseState.active && coordinateSpace !== void 0) {
      const p = mouseState.position;
      const rank = coordinateSpace.rank, names = coordinateSpace.names;
      for (let i = 0; i < rank; ++i) {
        if (i !== 0) text += "  ";
        text += `${names[i]} ${Math.floor(p[i])}`;
      }
    }
    this.element.textContent = text;
  }
  disposed() {
    removeFromParent(this.element);
    super.disposed();
  }
}
class LayerWidget extends RefCounted {
  constructor(layer, panel) {
    var _a;
    super();
    this.layer = layer;
    this.panel = panel;
    this.element = document.createElement("div");
    this.layerNumberElement = document.createElement("div");
    this.labelElement = document.createElement("div");
    this.visibleProgress = document.createElement("div");
    this.prefetchProgress = document.createElement("div");
    this.labelElementText = document.createTextNode("");
    this.valueElement = document.createElement("div");
    this.maxLength = 0;
    this.prevValueText = "";
    const element = this.element, labelElement = this.labelElement, layerNumberElement = this.layerNumberElement, valueElement = this.valueElement, visibleProgress = this.visibleProgress, prefetchProgress = this.prefetchProgress, labelElementText = this.labelElementText;
    element.className = "neuroglancer-layer-item neuroglancer-noselect";
    element.appendChild(visibleProgress);
    element.appendChild(prefetchProgress);
    labelElement.className = "neuroglancer-layer-item-label";
    labelElement.appendChild(labelElementText);
    visibleProgress.className = "neuroglancer-layer-item-visible-progress";
    prefetchProgress.className = "neuroglancer-layer-item-prefetch-progress";
    layerNumberElement.className = "neuroglancer-layer-item-number";
    valueElement.className = "neuroglancer-layer-item-value";
    const valueContainer = document.createElement("div");
    valueContainer.className = "neuroglancer-layer-item-value-container";
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "neuroglancer-layer-item-button-container";
    const closeElement = makeCloseButton();
    closeElement.title = "Remove layer from this layer group";
    const refreshElement = makeRefreshButton();
    refreshElement.title = "Refresh data";
    this.registerEventListener(refreshElement, "click", (event) => {
      event.stopPropagation();
      const layer2 = this.layer.layer;
      if (layer2 && layer2.dataSources && layer2.dataSources[0].loadState) {
        const loadState = layer2.dataSources[0].loadState;
        if (loadState instanceof LoadedLayerDataSource) {
          const dataSource = loadState.dataSource;
          if (dataSource && dataSource.subsources[0] && dataSource.subsources[0].subsource) {
            const annotation = dataSource.subsources[0].subsource.annotation;
            if (annotation === null || annotation === void 0 ? void 0 : annotation.invalidateCache) {
              annotation.invalidateCache();
            }
          }
        }
      }
    });
    closeElement.addEventListener("click", (event) => {
      if (this.panel.layerManager === this.panel.manager.rootLayers) {
        this.layer.setArchived(true);
      } else {
        if (this.layer.containers.size > 2) {
          this.panel.layerManager.removeManagedLayer(this.layer);
        } else {
          this.layer.setArchived(true);
        }
      }
      event.stopPropagation();
    });
    const deleteElement = makeDeleteButton();
    deleteElement.title = "Delete this layer";
    deleteElement.addEventListener("click", (event) => {
      deleteLayer(this.layer);
      event.stopPropagation();
    });
    element.appendChild(layerNumberElement);
    valueContainer.appendChild(valueElement);
    valueContainer.appendChild(buttonContainer);
    buttonContainer.appendChild(closeElement);
    buttonContainer.appendChild(deleteElement);
    element.appendChild(labelElement);
    if ((_a = layer.layer) === null || _a === void 0 ? void 0 : _a.allowingRefresh) {
      element.appendChild(refreshElement);
    }
    element.appendChild(valueContainer);
    const positionWidget = this.registerDisposer(new PositionWidget(layer.localPosition, layer.localCoordinateSpaceCombiner, { copyButton: false }));
    element.appendChild(positionWidget.element);
    positionWidget.element.addEventListener("click", (event) => {
      event.stopPropagation();
    });
    positionWidget.element.addEventListener("dblclick", (event) => {
      event.stopPropagation();
    });
    element.addEventListener("click", (event) => {
      if (event.ctrlKey) {
        panel.selectedLayer.toggle(layer);
      } else if (event.altKey) {
        layer.pickEnabled = !layer.pickEnabled;
      } else {
        layer.setVisible(!layer.visible);
      }
    });
    element.addEventListener("contextmenu", (event) => {
      panel.selectedLayer.layer = layer;
      panel.selectedLayer.visible = true;
      event.stopPropagation();
      event.preventDefault();
    });
    registerLayerDragHandlers(panel, element, layer, { getLayoutSpec: () => panel.getLayoutSpecForDrag() });
    registerLayerBarDropHandlers(this.panel, element, this.layer);
  }
  update() {
    const layer = this.layer, element = this.element;
    this.labelElementText.textContent = layer.name;
    element.dataset.visible = layer.visible.toString();
    element.dataset.selected = (layer === this.panel.selectedLayer.layer).toString();
    element.dataset.pick = layer.pickEnabled.toString();
    let title = `Click to ${layer.visible ? "hide" : "show"}, control+click to show side panel`;
    if (layer.supportsPickOption) {
      title += `, alt+click to ${layer.pickEnabled ? "disable" : "enable"} spatial object selection`;
    }
    title += `, drag to move, shift+drag to copy`;
    element.title = title;
  }
  disposed() {
    this.element.remove();
    super.disposed();
  }
}
class LayerBar extends RefCounted {
  constructor(display, manager, viewerNavigationState, selectedLayer, getLayoutSpecForDrag, showLayerHoverValues) {
    super();
    this.display = display;
    this.manager = manager;
    this.viewerNavigationState = viewerNavigationState;
    this.selectedLayer = selectedLayer;
    this.getLayoutSpecForDrag = getLayoutSpecForDrag;
    this.showLayerHoverValues = showLayerHoverValues;
    this.layerWidgets = new _Map();
    this.element = document.createElement("div");
    this.layerUpdateNeeded = true;
    this.valueUpdateNeeded = false;
    this.layerWidgetInsertionPoint = document.createElement("div");
    this.positionWidget = this.registerDisposer(new PositionWidget(this.viewerNavigationState.position.value, this.manager.root.coordinateSpaceCombiner));
    this.dragEnterCount = 0;
    this.scheduleUpdate = this.registerCancellable(animationFrameDebounce(() => this.update()));
    this.registerDisposer(selectedLayer);
    const element = this.element;
    element.className = "neuroglancer-layer-panel";
    this.registerDisposer(manager.layerSelectedValues.changed.add(() => {
      this.handleLayerValuesChanged();
    }));
    this.registerDisposer(manager.layerManager.layersChanged.add(() => {
      this.handleLayersChanged();
    }));
    this.registerDisposer(selectedLayer.changed.add(() => {
      this.handleLayersChanged();
    }));
    this.registerDisposer(showLayerHoverValues.changed.add(() => {
      this.handleLayerItemValueChanged();
    }));
    this.element.dataset.showHoverValues = this.showLayerHoverValues.value.toString();
    this.layerWidgetInsertionPoint.style.display = "none";
    this.element.appendChild(this.layerWidgetInsertionPoint);
    let addButton = makeIcon({
      svg: svg_plus,
      title: "Click to add layer, control+click/right click/⌘+click to add local annotation layer."
    });
    addButton.classList.add("neuroglancer-layer-add-button");
    let dropZone = this.dropZone = document.createElement("div");
    dropZone.className = "neuroglancer-layer-panel-drop-zone";
    const addLayer = (event) => {
      if (event.ctrlKey || event.metaKey || event.type === "contextmenu") {
        const layer = makeLayer(this.manager, "annotation", { type: "annotation", "source": "local://annotations" });
        this.manager.add(layer);
        this.selectedLayer.layer = layer;
        this.selectedLayer.visible = true;
      } else {
        this.addLayerMenu();
      }
    };
    this.registerEventListener(addButton, "click", addLayer);
    this.registerEventListener(addButton, "contextmenu", addLayer);
    element.appendChild(addButton);
    element.appendChild(dropZone);
    this.registerDisposer(preventDrag(addButton));
    element.appendChild(this.positionWidget.element);
    const updatePositionWidgetVisibility = () => {
      const linkValue = this.viewerNavigationState.position.link.value;
      this.positionWidget.element.style.display = linkValue === NavigationLinkType.LINKED ? "none" : "";
    };
    this.registerDisposer(this.viewerNavigationState.position.link.changed.add(updatePositionWidgetVisibility));
    updatePositionWidgetVisibility();
    this.update();
    this.updateChunkStatistics();
    registerLayerBarDragLeaveHandler(this);
    registerLayerBarDropHandlers(this, dropZone, void 0);
    this.registerDisposer(display.updateStarted.add(() => this.updateLayers()));
    this.registerDisposer(manager.chunkManager.layerChunkStatisticsUpdated.add(this.registerCancellable(animationFrameDebounce(() => this.updateChunkStatistics()))));
  }
  get layerManager() {
    return this.manager.layerManager;
  }
  disposed() {
    this.layerWidgets.forEach((x) => x.dispose());
    this.layerWidgets = void 0;
    removeFromParent(this.element);
    super.disposed();
  }
  handleLayersChanged() {
    this.layerUpdateNeeded = true;
    this.handleLayerValuesChanged();
  }
  handleLayerValuesChanged() {
    if (!this.valueUpdateNeeded) {
      this.valueUpdateNeeded = true;
      this.scheduleUpdate();
    }
  }
  handleLayerItemValueChanged() {
    this.element.dataset.showHoverValues = this.showLayerHoverValues.value.toString();
  }
  update() {
    this.valueUpdateNeeded = false;
    this.updateLayers();
    if (this.showLayerHoverValues.value === false) {
      return;
    }
    let values2 = this.manager.layerSelectedValues;
    for (let _ref of this.layerWidgets) {
      var _ref2 = _slicedToArray(_ref, 2);
      let layer = _ref2[0];
      let widget = _ref2[1];
      let userLayer = layer.layer;
      let text = "";
      if (userLayer !== null) {
        let state = values2.get(userLayer);
        if (state !== void 0) {
          const value = state.value;
          if (value !== void 0) {
            text = "" + value;
          }
        }
      }
      if (text === widget.prevValueText) continue;
      widget.prevValueText = text;
      if (text.length > widget.maxLength) {
        const length2 = widget.maxLength = text.length;
        widget.valueElement.style.width = `${length2}ch`;
      }
      widget.valueElement.textContent = text;
    }
  }
  updateChunkStatistics() {
    for (const _ref3 of this.layerWidgets) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const layer = _ref4[0];
      const widget = _ref4[1];
      let numVisibleChunksNeeded = 0;
      let numVisibleChunksAvailable = 0;
      let numPrefetchChunksNeeded = 0;
      let numPrefetchChunksAvailable = 0;
      const userLayer = layer.layer;
      if (userLayer !== null) {
        for (const _ref5 of userLayer.renderLayers) {
          const layerChunkProgressInfo = _ref5.layerChunkProgressInfo;
          numVisibleChunksNeeded += layerChunkProgressInfo.numVisibleChunksNeeded;
          numVisibleChunksAvailable += layerChunkProgressInfo.numVisibleChunksAvailable;
          numPrefetchChunksNeeded += layerChunkProgressInfo.numPrefetchChunksNeeded;
          numPrefetchChunksAvailable += layerChunkProgressInfo.numPrefetchChunksAvailable;
        }
      }
      widget.visibleProgress.style.width = `${numVisibleChunksAvailable / Math.max(1, numVisibleChunksNeeded) * 100}%`;
      widget.prefetchProgress.style.width = `${numPrefetchChunksAvailable / Math.max(1, numPrefetchChunksNeeded) * 100}%`;
    }
  }
  updateLayers() {
    var _a;
    if (!this.layerUpdateNeeded) {
      return;
    }
    this.layerUpdateNeeded = false;
    let container = this.element;
    let layers = new _Set();
    let nextChild = this.layerWidgetInsertionPoint.nextElementSibling;
    this.manager.rootLayers.updateNonArchivedLayerIndices();
    for (const layer of this.manager.layerManager.managedLayers) {
      if (layer.archived && !((_a = this.dropLayers) === null || _a === void 0 ? void 0 : _a.layers.has(layer))) continue;
      layers.add(layer);
      let widget = this.layerWidgets.get(layer);
      const layerIndex = layer.nonArchivedLayerIndex;
      if (widget === void 0) {
        widget = new LayerWidget(layer, this);
        this.layerWidgets.set(layer, widget);
      }
      widget.layerNumberElement.textContent = "" + (1 + layerIndex);
      widget.update();
      var _widget = widget;
      let element = _widget.element;
      if (element !== nextChild) {
        container.insertBefore(widget.element, nextChild);
      }
      nextChild = element.nextElementSibling;
    }
    for (let _ref6 of this.layerWidgets) {
      var _ref7 = _slicedToArray(_ref6, 2);
      let layer = _ref7[0];
      let widget = _ref7[1];
      if (!layers.has(layer)) {
        this.layerWidgets.delete(layer);
        widget.dispose();
      }
    }
  }
  addLayerMenu() {
    addNewLayer(this.manager, this.selectedLayer);
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function setupPositionDropHandlers(target, position) {
  const dropDisposer = registerEventListener(target, "drop", (event) => {
    event.preventDefault();
    if (event.dataTransfer.types.indexOf(positionDragType) !== -1) {
      event.stopPropagation();
      const obj = verifyObject(JSON.parse(event.dataTransfer.getData(positionDragType)));
      const dimensions = verifyObjectProperty(obj, "dimensions", dimensionNamesFromJson);
      const positionVec = verifyObjectProperty(obj, "position", (positionObj) => parseArray(positionObj, verifyFiniteFloat));
      if (positionVec.length !== dimensions.length) {
        throw new Error("length mismatch between position and dimensions");
      }
      const rank = positionVec.length;
      const names = position.coordinateSpace.value.names, coordinates = position.value;
      for (let i = 0; i < rank; ++i) {
        const dim = names.indexOf(dimensions[i]);
        if (dim === -1) continue;
        coordinates[dim] = positionVec[i];
      }
      position.changed.dispatch();
    }
  });
  const handleDragOver = (event) => {
    if (event.dataTransfer.types.indexOf(positionDragType) !== -1) {
      event.dataTransfer.dropEffect = "link";
      event.preventDefault();
      event.stopPropagation();
    }
  };
  const dragenterDisposer = registerEventListener(target, "dragenter", handleDragOver);
  const dragoverDisposer = registerEventListener(target, "dragover", handleDragOver);
  return () => {
    dragenterDisposer();
    dragoverDisposer();
    dropDisposer();
  };
}
class EnumSelectWidget extends RefCounted {
  constructor(model) {
    super();
    this.model = model;
    this.element = document.createElement("select");
    this.valueIndexMap = new _Map();
    const element = this.element, valueIndexMap = this.valueIndexMap;
    let index2 = 0;
    for (const key of _Object$keys(model.enumType)) {
      if (isNaN(Number(key))) {
        const option = document.createElement("option");
        option.textContent = option.value = key.toLowerCase();
        element.appendChild(option);
        valueIndexMap.set(model.enumType[key], index2);
        ++index2;
      }
    }
    this.registerDisposer(model.changed.add(() => this.updateView()));
    this.registerEventListener(element, "change", () => this.updateModel());
    this.registerEventListener(element, "wheel", (event) => {
      event.preventDefault();
      event.stopPropagation();
      this.adjustViaWheel(event);
    });
    this.updateView();
  }
  adjustViaWheel(event) {
    const element = this.element;
    let deltaY = event.deltaY;
    if (deltaY > 0) {
      element.selectedIndex = (element.options.length + element.selectedIndex - 1) % element.options.length;
      this.updateModel();
    } else if (deltaY < 0) {
      element.selectedIndex = (element.options.length + element.selectedIndex + 1) % element.options.length;
      this.updateModel();
    }
  }
  updateView() {
    const element = this.element;
    element.selectedIndex = this.valueIndexMap.get(this.model.value);
  }
  updateModel() {
    this.model.restoreState(this.element.value);
  }
}
const viewerDragType = "neuroglancer-layer-group-viewer";
function hasViewerDrag(event) {
  return event.dataTransfer.types.indexOf(viewerDragType) !== -1;
}
let dragSource;
function getCompatibleViewerDragSource(manager) {
  if (dragSource && dragSource.viewer.layerSpecification.rootLayers === manager.rootLayers) {
    return dragSource.viewer;
  } else {
    return void 0;
  }
}
function getViewerDropEffect(event, manager) {
  const source = getCompatibleViewerDragSource(manager);
  let defaultDropEffect;
  let moveAllowed = false;
  if (source === void 0 || source.layerSpecification === source.layerSpecification.root) {
    defaultDropEffect = "copy";
  } else {
    moveAllowed = true;
    defaultDropEffect = "move";
  }
  return getDropEffectFromModifiers(event, defaultDropEffect, moveAllowed);
}
class LinkedViewerNavigationState extends RefCounted {
  constructor(parent) {
    super();
    this.relativeDisplayScales = new LinkedRelativeDisplayScales(parent.navigationState.pose.relativeDisplayScales.addRef());
    this.displayDimensions = new LinkedDisplayDimensions(parent.navigationState.pose.displayDimensions.addRef());
    this.position = new LinkedPosition(parent.navigationState.position.addRef());
    this.crossSectionOrientation = new LinkedOrientationState(parent.navigationState.pose.orientation.addRef());
    this.displayDimensionRenderInfo = this.registerDisposer(new WatchableDisplayDimensionRenderInfo(this.relativeDisplayScales.value, this.displayDimensions.value));
    this.crossSectionScale = new LinkedZoomState(parent.navigationState.zoomFactor.addRef(), this.displayDimensionRenderInfo.addRef());
    this.crossSectionDepthRange = new LinkedDepthRange(parent.navigationState.depthRange.addRef(), this.displayDimensionRenderInfo);
    this.projectionDepthRange = new LinkedDepthRange(parent.perspectiveNavigationState.depthRange.addRef(), this.displayDimensionRenderInfo);
    this.navigationState = this.registerDisposer(new NavigationState(new DisplayPose(this.position.value, this.displayDimensionRenderInfo.addRef(), this.crossSectionOrientation.value), this.crossSectionScale.value, this.crossSectionDepthRange.value));
    this.projectionOrientation = new LinkedOrientationState(parent.perspectiveNavigationState.pose.orientation.addRef());
    this.projectionScale = new LinkedZoomState(parent.perspectiveNavigationState.zoomFactor.addRef(), this.displayDimensionRenderInfo.addRef());
    this.projectionNavigationState = this.registerDisposer(new NavigationState(new DisplayPose(this.position.value.addRef(), this.displayDimensionRenderInfo.addRef(), this.projectionOrientation.value), this.projectionScale.value, this.projectionDepthRange.value));
  }
  copyToParent() {
    for (const x of [this.relativeDisplayScales, this.displayDimensions, this.position, this.crossSectionOrientation, this.crossSectionScale, this.projectionOrientation, this.projectionScale]) {
      x.copyToPeer();
    }
  }
  register(state) {
    state.add("dimensionRenderScales", this.relativeDisplayScales);
    state.add("displayDimensions", this.displayDimensions);
    state.add("position", linkedStateLegacyJsonView(this.position));
    state.add("crossSectionOrientation", this.crossSectionOrientation);
    state.add("crossSectionScale", this.crossSectionScale);
    state.add("crossSectionDepth", this.crossSectionDepthRange);
    state.add("projectionOrientation", this.projectionOrientation);
    state.add("projectionScale", this.projectionScale);
    state.add("projectionDepth", this.projectionDepthRange);
  }
}
function makeViewerMenu(parent, viewer) {
  const contextMenu = new ContextMenu(parent);
  const menu = contextMenu.element;
  menu.classList.add("neuroglancer-layer-group-viewer-context-menu");
  const closeButton = document.createElement("button");
  closeButton.textContent = "Remove layer group";
  menu.appendChild(closeButton);
  contextMenu.registerEventListener(closeButton, "click", () => {
    viewer.layerSpecification.layerManager.clear();
  });
  const viewerNavigationState = viewer.viewerNavigationState;
  for (const _ref of [["Render scale factors", viewerNavigationState.relativeDisplayScales.link], ["Render dimensions", viewerNavigationState.displayDimensions.link], ["Position", viewerNavigationState.position.link], ["Cross-section orientation", viewerNavigationState.crossSectionOrientation.link], ["Cross-section zoom", viewerNavigationState.crossSectionScale.link], ["Cross-section depth range", viewerNavigationState.crossSectionDepthRange.link], ["3-D projection orientation", viewerNavigationState.projectionOrientation.link], ["3-D projection zoom", viewerNavigationState.projectionScale.link], ["3-D projection depth range", viewerNavigationState.projectionDepthRange.link]]) {
    var _ref2 = _slicedToArray(_ref, 2);
    const name2 = _ref2[0];
    const model = _ref2[1];
    const widget = contextMenu.registerDisposer(new EnumSelectWidget(model));
    const label = document.createElement("label");
    label.style.display = "flex";
    label.style.flexDirection = "row";
    label.style.whiteSpace = "nowrap";
    label.textContent = name2;
    label.appendChild(widget.element);
    menu.appendChild(label);
  }
  return contextMenu;
}
class LayerGroupViewer extends RefCounted {
  constructor(element, viewerState, options = {}) {
    super();
    this.element = element;
    this.viewerState = viewerState;
    this.state = new CompoundTrackable();
    this.options = _Object$assign({ showLayerPanel: new TrackableBoolean(true), showViewerMenu: false, showLayerHoverValues: new TrackableBoolean(true) }, options);
    this.layerSpecification = this.registerDisposer(viewerState.layerSpecification);
    this.viewerNavigationState = this.registerDisposer(new LinkedViewerNavigationState(viewerState));
    this.viewerNavigationState.register(this.state);
    if (!(this.layerSpecification instanceof LayerSubsetSpecification)) {
      this.state.add("layers", {
        changed: this.layerSpecification.changed,
        toJSON: () => this.layerSpecification.layerManager.managedLayers.map((x) => x.name),
        reset: () => {
          throw new Error("not implemented");
        },
        restoreState: () => {
          throw new Error("not implemented");
        }
      });
    } else {
      this.state.add("layers", this.layerSpecification);
    }
    element.classList.add("neuroglancer-layer-group-viewer");
    this.registerDisposer(new AutomaticallyFocusedElement(element));
    this.layout = this.registerDisposer(new DataPanelLayoutContainer(this, "xy"));
    this.state.add("layout", this.layout);
    this.registerActionBindings();
    this.registerDisposer(this.layerManager.useDirectly());
    this.registerDisposer(setupPositionDropHandlers(element, this.navigationState.position));
    this.registerDisposer(this.options.showLayerPanel.changed.add(this.registerCancellable(debounce(() => this.updateUI(), 0))));
    this.makeUI();
  }
  get perspectiveNavigationState() {
    return this.viewerNavigationState.projectionNavigationState;
  }
  get navigationState() {
    return this.viewerNavigationState.navigationState;
  }
  get selectionDetailsState() {
    return this.layerSpecification.root.selectionState;
  }
  // FIXME: don't make viewerState a property, just make these things properties directly
  get display() {
    return this.viewerState.display;
  }
  get selectedLayer() {
    return this.viewerState.selectedLayer;
  }
  get layerManager() {
    return this.layerSpecification.layerManager;
  }
  get chunkManager() {
    return this.layerSpecification.chunkManager;
  }
  get mouseState() {
    return this.viewerState.mouseState;
  }
  get showAxisLines() {
    return this.viewerState.showAxisLines;
  }
  get wireFrame() {
    return this.viewerState.wireFrame;
  }
  get showScaleBar() {
    return this.viewerState.showScaleBar;
  }
  get showPerspectiveSliceViews() {
    return this.viewerState.showPerspectiveSliceViews;
  }
  get inputEventBindings() {
    return this.viewerState.inputEventBindings;
  }
  get visibility() {
    return this.viewerState.visibility;
  }
  get visibleLayerRoles() {
    return this.viewerState.visibleLayerRoles;
  }
  get crossSectionBackgroundColor() {
    return this.viewerState.crossSectionBackgroundColor;
  }
  get perspectiveViewBackgroundColor() {
    return this.viewerState.perspectiveViewBackgroundColor;
  }
  get scaleBarOptions() {
    return this.viewerState.scaleBarOptions;
  }
  get changed() {
    return this.state.changed;
  }
  bindAction(action, handler) {
    this.registerDisposer(registerActionListener(this.element, action, handler));
  }
  registerActionBindings() {
    this.bindAction("add-layer", () => {
      if (this.layerPanel) {
        this.layerPanel.addLayerMenu();
      }
    });
    this.bindAction("t-", () => {
      this.navigationState.pose.translateNonDisplayDimension(0, -1);
    });
    this.bindAction("t+", () => {
      this.navigationState.pose.translateNonDisplayDimension(0, 1);
    });
  }
  toJSON() {
    return _Object$assign({ "type": "viewer" }, this.state.toJSON());
  }
  reset() {
    this.state.reset();
  }
  restoreState(obj) {
    this.state.restoreState(obj);
    optionallyRestoreFromJsonMember(obj, "crossSectionZoom", linkedStateLegacyJsonView(this.viewerNavigationState.crossSectionScale));
    optionallyRestoreFromJsonMember(obj, "perspectiveZoom", linkedStateLegacyJsonView(this.viewerNavigationState.projectionScale));
    optionallyRestoreFromJsonMember(obj, "perspectiveOrientation", this.viewerNavigationState.projectionOrientation);
  }
  makeUI() {
    this.element.style.flex = "1";
    this.element.style.display = "flex";
    this.element.style.flexDirection = "column";
    this.element.appendChild(this.layout.element);
    this.updateUI();
  }
  updateUI() {
    const options = this.options;
    const showLayerPanel = options.showLayerPanel.value;
    if (this.layerPanel !== void 0 && !showLayerPanel) {
      this.layerPanel.dispose();
      this.layerPanel = void 0;
      return;
    }
    if (showLayerPanel && this.layerPanel === void 0) {
      const layerPanel = this.layerPanel = new LayerBar(this.display, this.layerSpecification, this.viewerNavigationState, this.viewerState.selectedLayer.addRef(), () => this.layout.toJSON(), this.options.showLayerHoverValues);
      if (options.showViewerMenu) {
        layerPanel.registerDisposer(makeViewerMenu(layerPanel.element, this));
        layerPanel.element.title = "Right click for options, drag to move/copy layer group.";
      } else {
        layerPanel.element.title = "Drag to move/copy layer group.";
      }
      if (typeof NEUROGLANCER_SHOW_LAYER_BAR_EXTRA_BUTTONS !== "undefined" && NEUROGLANCER_SHOW_LAYER_BAR_EXTRA_BUTTONS === true) {
        {
          const button = document.createElement("button");
          button.textContent = "Clear segments";
          button.title = `De-select all objects ("x")`;
          button.addEventListener("click", (event) => {
            dispatchEventAction(event, event, { action: "clear-segments" });
          });
          layerPanel.element.appendChild(button);
        }
        for (const layout of ["3d", "xy", "xz", "yz"]) {
          const button = document.createElement("button");
          button.textContent = layout;
          button.title = `Switch to ${layout} layout`;
          button.addEventListener("click", () => {
            let newLayout;
            if (this.layout.name === layout) {
              if (layout !== "3d") {
                newLayout = `${layout}-3d`;
              } else {
                newLayout = "4panel";
              }
            } else {
              newLayout = layout;
            }
            this.layout.name = newLayout;
          });
          layerPanel.element.appendChild(button);
        }
      }
      layerPanel.element.draggable = true;
      const layerPanelElement = layerPanel.element;
      layerPanelElement.addEventListener("dragstart", (event) => {
        pushDragStatus(layerPanel.element, "drag", "Drag layer group to the left/top/right/bottom edge of a layer group, or to another layer bar/panel (including in another Neuroglancer window)");
        startLayerDrag(event, {
          manager: this.layerSpecification,
          layers: this.layerManager.managedLayers,
          layoutSpec: this.layout.toJSON()
        });
        const disposer = () => {
          if (dragSource && dragSource.viewer === this) {
            dragSource = void 0;
          }
          this.unregisterDisposer(disposer);
        };
        dragSource = { viewer: this, disposer };
        this.registerDisposer(disposer);
        const dragData = this.toJSON();
        delete dragData["layers"];
        event.dataTransfer.setData(viewerDragType, _JSON$stringify(dragData));
        layerPanel.element.style.backgroundColor = "black";
        setTimeout(() => {
          layerPanel.element.style.backgroundColor = "";
        }, 0);
      });
      layerPanel.element.addEventListener("dragend", () => {
        popDragStatus(layerPanelElement, "drag");
        endLayerDrag();
        if (dragSource !== void 0 && dragSource.viewer === this) {
          dragSource.disposer();
        }
      });
      this.element.insertBefore(layerPanelElement, this.element.firstChild);
    }
  }
  disposed() {
    removeChildren(this.element);
    const layerPanel = this.layerPanel;
    if (layerPanel !== void 0) {
      layerPanel.dispose();
      this.layerPanel = void 0;
    }
    super.disposed();
  }
}
const layoutComponentContainerSymbol = _Symbol("layoutComponentContainer");
class LayoutComponentContainer extends RefCounted {
  constructor(viewer, spec, parent) {
    super();
    this.viewer = viewer;
    this.parent = parent;
    this.changed = new NullarySignal();
    this.element = document.createElement("div");
    const element = this.element;
    element.style.display = "flex";
    element.style.flex = "1";
    element.style.position = "relative";
    element.style.alignItems = "stretch";
    element[layoutComponentContainerSymbol] = this;
    this.setSpecification(spec);
    const dropZones = [];
    const makeDropZone = (name2) => {
      const dropZone = document.createElement("div");
      dropZone.className = "neuroglancer-layout-split-drop-zone";
      let direction;
      dropZone.style[name2] = "0";
      switch (name2) {
        case "left":
        case "right":
          direction = "row";
          dropZone.style.width = "10px";
          dropZone.style.height = "100%";
          break;
        case "top":
        case "bottom":
          direction = "column";
          dropZone.style.height = "10px";
          dropZone.style.width = "100%";
          break;
      }
      dropZone.style.display = "none";
      dropZones.push({ element: dropZone, direction, orientation: name2 });
      element.appendChild(dropZone);
      setupDropZone(dropZone, this.viewer.layerSpecification, () => this.split(name2).newContainer.component, direction === "row" ? "column" : "row");
    };
    makeDropZone("left");
    makeDropZone("right");
    makeDropZone("top");
    makeDropZone("bottom");
    let dropZonesVisible = false;
    element.addEventListener("dragenter", (event) => {
      if (dropZonesVisible) {
        return;
      }
      if (getLayerDragInfo(event) === void 0) {
        return;
      }
      dropZonesVisible = true;
      for (const _ref of dropZones) {
        const dropZone = _ref.element;
        const direction = _ref.direction;
        const orientation = _ref.orientation;
        if (parent !== void 0 && direction === parent.direction) {
          if ((orientation === "left" || orientation === "top") && parent.get(0) !== this || (orientation === "bottom" || orientation === "right") && parent.get(parent.length - 1) !== this) {
            continue;
          }
        }
        const component = this.component;
        if (component instanceof StackLayoutComponent && component.direction === direction) {
          continue;
        }
        dropZone.style.display = "block";
      }
    }, true);
    element.addEventListener(
      "drop",
      (_event) => {
        if (!dropZonesVisible) {
          return;
        }
        dropZonesVisible = false;
        for (const _ref2 of dropZones) {
          const dropZone = _ref2.element;
          dropZone.style.display = "none";
        }
      },
      /*capture=*/
      true
    );
    element.addEventListener("dragleave", (event) => {
      const relatedTarget = event.relatedTarget;
      if (!dropZonesVisible) {
        return;
      }
      if (relatedTarget instanceof HTMLElement && this.element.contains(relatedTarget)) {
        return;
      }
      dropZonesVisible = false;
      for (const _ref3 of dropZones) {
        const dropZone = _ref3.element;
        dropZone.style.display = "none";
      }
    }, true);
  }
  unsetComponent() {
    const oldComponent = this.componentValue;
    if (oldComponent !== void 0) {
      oldComponent.changed.remove(this.changed.dispatch);
      this.element.removeChild(oldComponent.element);
      oldComponent.dispose();
    }
  }
  get component() {
    return this.componentValue;
  }
  setComponent(component) {
    this.unsetComponent();
    this.componentValue = component;
    component.changed.add(this.changed.dispatch);
    this.element.appendChild(component.element);
    if (component instanceof LayerGroupViewer) {
      const layerManager = component.layerManager;
      const scheduleMaybeDelete = component.registerCancellable(debounce(() => {
        if (layerManager.managedLayers.length === 0) {
          this.dispose();
        }
      }, 0));
      component.registerDisposer(layerManager.layersChanged.add(() => {
        if (layerManager.managedLayers.length === 0) {
          scheduleMaybeDelete();
        }
      }));
      scheduleMaybeDelete();
    } else if (component instanceof StackLayoutComponent) {
      const scheduleMaybeDelete = component.registerCancellable(debounce(() => {
        const length2 = component.length;
        if (length2 === 0 && this.parent !== void 0) {
          this.dispose();
        } else if (length2 === 1) {
          const childComponent = component.get(0).component;
          let spec;
          if (this.parent === void 0 && childComponent instanceof LayerGroupViewer) {
            spec = childComponent.layout.specification.toJSON();
            childComponent.viewerNavigationState.copyToParent();
            const childManagedLayers = childComponent.layerManager.managedLayers;
            const layersToKeep = new _Set(childManagedLayers);
            const layerSpecification = childComponent.layerSpecification;
            layerSpecification.rootLayers.filter((layer) => layersToKeep.has(layer) || layer.archived);
            const childLayerIndices = [];
            const rootManagedLayers = layerSpecification.rootLayers.managedLayers;
            for (let i = 0, count = rootManagedLayers.length; i < count; ++i) {
              if (layersToKeep.has(rootManagedLayers[i])) {
                childLayerIndices.push(i);
              }
            }
            for (let i = 0, count = childManagedLayers.length; i < count; ++i) {
              rootManagedLayers[childLayerIndices[i]] = childManagedLayers[i];
            }
            layerSpecification.rootLayers.layersChanged.dispatch();
          } else {
            spec = childComponent.toJSON();
          }
          this.setSpecification(spec);
        }
      }, 0));
      component.registerDisposer(component.changed.add(() => {
        if (component.length < 2) {
          scheduleMaybeDelete();
        }
      }));
      scheduleMaybeDelete();
    }
    this.changed.dispatch();
  }
  toJSON() {
    return this.component.toJSON();
  }
  setSpecification(spec) {
    this.setComponent(makeComponent(this, spec));
  }
  static getFromElement(element) {
    return element[layoutComponentContainerSymbol];
  }
  disposed() {
    this.unsetComponent();
    this.componentValue = void 0;
    super.disposed();
  }
  split(side) {
    const newComponentSpec = {
      type: "viewer"
    };
    const parent = this.parent;
    if (parent !== void 0) {
      if (side === "left" && parent.direction === "row" || side === "top" && parent.direction === "column") {
        return { newContainer: parent.insertChild(newComponentSpec, this), existingContainer: this };
      } else if (side === "right" && parent.direction === "row" || side === "bottom" && parent.direction === "column") {
        return { newContainer: parent.insertChild(newComponentSpec), existingContainer: this };
      }
    }
    let existingComponentSpec;
    const existingComponent = this.component;
    if (existingComponent instanceof SingletonLayerGroupViewer) {
      existingComponentSpec = existingComponent.layerGroupViewer.toJSON();
    } else {
      existingComponentSpec = existingComponent.toJSON();
    }
    let spec;
    let newIndex;
    const direction = side === "left" || side === "right" ? "row" : "column";
    switch (side) {
      case "left":
      case "top":
        spec = { type: direction, children: [newComponentSpec, existingComponentSpec] };
        newIndex = 0;
        break;
      case "right":
      case "bottom":
        spec = { type: direction, children: [existingComponentSpec, newComponentSpec] };
        newIndex = 1;
        break;
    }
    this.setSpecification(spec);
    const stackComponent = this.component;
    return {
      newContainer: stackComponent.get(newIndex),
      existingContainer: stackComponent.get(1 - newIndex)
    };
  }
}
function getCommonViewerState(viewer) {
  return {
    mouseState: viewer.mouseState,
    showAxisLines: viewer.showAxisLines,
    wireFrame: viewer.wireFrame,
    showScaleBar: viewer.showScaleBar,
    scaleBarOptions: viewer.scaleBarOptions,
    showPerspectiveSliceViews: viewer.showPerspectiveSliceViews,
    inputEventBindings: viewer.inputEventBindings,
    visibility: viewer.visibility,
    selectedLayer: viewer.selectedLayer,
    visibleLayerRoles: viewer.visibleLayerRoles,
    navigationState: viewer.navigationState.addRef(),
    perspectiveNavigationState: viewer.perspectiveNavigationState.addRef(),
    crossSectionBackgroundColor: viewer.crossSectionBackgroundColor,
    perspectiveViewBackgroundColor: viewer.perspectiveViewBackgroundColor
  };
}
class SingletonLayerGroupViewer extends RefCounted {
  constructor(element, layout, viewer) {
    super();
    this.element = element;
    this.layerGroupViewer = this.registerDisposer(new LayerGroupViewer(element, _Object$assign({ display: viewer.display, layerSpecification: viewer.layerSpecification.addRef() }, getCommonViewerState(viewer)), {
      showLayerPanel: viewer.uiControlVisibility.showLayerPanel,
      showViewerMenu: false,
      showLayerHoverValues: viewer.uiControlVisibility.showLayerHoverValues
    }));
    this.layerGroupViewer.layout.restoreState(layout);
  }
  toJSON() {
    return this.layerGroupViewer.layout.specification.toJSON();
  }
  get changed() {
    return this.layerGroupViewer.layout.changed;
  }
}
function setupDropZone(dropZone, manager, makeLayerGroupViewer, direction) {
  dropZone.addEventListener("dragenter", (event) => {
    const dragInfo = getLayerDragInfo(event);
    if (dragInfo === void 0) {
      return;
    }
    dropZone.classList.add("neuroglancer-drag-over");
  });
  dropZone.addEventListener("dragleave", () => {
    popDragStatus(dropZone, "drop");
    dropZone.classList.remove("neuroglancer-drag-over");
  });
  dropZone.addEventListener("dragover", (event) => {
    const allowDrag = (info, message) => {
      if (info.dropEffectMessage) message += ` (${info.dropEffectMessage})`;
      pushDragStatus(dropZone, "drop", message);
      event.stopPropagation();
      event.preventDefault();
    };
    if (hasViewerDrag(event)) {
      const info = getViewerDropEffect(event, manager);
      setDropEffect(event, info.dropEffect);
      allowDrag(info, `Drop to ${info.dropEffect} layer group as new ${direction}`);
      return;
    }
    if (getLayerDragInfo(event) !== void 0) {
      const info = updateLayerDropEffect(
        event,
        manager,
        /*targetIsLayerListPanel=*/
        false,
        /*newTarget=*/
        true
      );
      allowDrag(info, `Drop to ${info.dropEffect} layer as new ${direction}`);
      return;
    }
  });
  dropZone.addEventListener("drop", (event) => {
    dropZone.classList.remove("neuroglancer-drag-over");
    popDragStatus(dropZone, "drop");
    let dropLayers;
    let layoutSpec;
    if (hasViewerDrag(event)) {
      event.stopPropagation();
      try {
        layoutSpec = JSON.parse(event.dataTransfer.getData(viewerDragType));
      } catch (e) {
        return;
      }
      dropLayers = getDropLayers(event, manager, { forceCopy: false, newTarget: true });
      if (dropLayers === void 0) return;
    } else {
      dropLayers = getDropLayers(event, manager, { forceCopy: getDropEffect() === "copy", newTarget: true });
      if (dropLayers === void 0) return;
      layoutSpec = dropLayers.layoutSpec;
    }
    if (!dropLayers.initializeExternalLayers(event)) {
      if (!dropLayers.moveSupported) {
        for (const layer of dropLayers.layers.keys()) {
          layer.dispose();
        }
      }
      return;
    }
    event.preventDefault();
    const dropEffect = event.dataTransfer.dropEffect = getDropEffect();
    endLayerDrag(dropEffect);
    const layerGroupViewer = makeLayerGroupViewer();
    dropLayers.updateArchiveStates(event);
    for (const newLayer of dropLayers.layers.keys()) {
      layerGroupViewer.layerSpecification.add(newLayer);
    }
    try {
      layerGroupViewer.restoreState(layoutSpec);
    } catch (_a) {
      layerGroupViewer.layout.reset();
    }
  });
}
class StackLayoutComponent extends RefCounted {
  constructor(element, direction, children, container) {
    super();
    this.element = element;
    this.direction = direction;
    this.container = container;
    this.changed = new NullarySignal();
    element.classList.add("neuroglancer-stack-layout");
    element.classList.add(`neuroglancer-stack-layout-${direction}`);
    element.style.display = "flex";
    element.style.flexDirection = direction;
    element.appendChild(this.makeDropPlaceholder(this));
    for (const childSpec of children) {
      this.insertChild(childSpec);
    }
  }
  get length() {
    return (this.element.childElementCount - 1) / 2;
  }
  makeDropPlaceholder(refCounted) {
    const dropZone = document.createElement("div");
    dropZone.className = "neuroglancer-stack-layout-drop-placeholder";
    setupDropZone(dropZone, this.viewer.layerSpecification, () => {
      const nextElement = dropZone.nextElementSibling;
      let nextChild;
      if (nextElement !== null) {
        nextChild = LayoutComponentContainer.getFromElement(nextElement);
      }
      const newChild = this.insertChild({ type: "viewer", layers: [] }, nextChild);
      return newChild.component;
    }, this.direction === "row" ? "column" : "row");
    refCounted.registerDisposer(() => {
      removeFromParent(dropZone);
    });
    return dropZone;
  }
  get viewer() {
    return this.container.viewer;
  }
  get(index2) {
    return LayoutComponentContainer.getFromElement(this.element.children[index2 * 2 + 1]);
  }
  insertChild(spec, before) {
    const child = new LayoutComponentContainer(this.viewer, spec, this);
    const dropZone = this.makeDropPlaceholder(child);
    child.element.classList.add("neuroglancer-stack-layout-child");
    child.registerDisposer(child.changed.add(this.changed.dispatch));
    child.registerDisposer(() => {
      this.element.removeChild(child.element);
      this.changed.dispatch();
    });
    const beforeElement = before !== void 0 ? before.element : null;
    this.element.insertBefore(child.element, beforeElement);
    this.element.insertBefore(dropZone, beforeElement);
    this.changed.dispatch();
    return child;
  }
  disposed() {
    this.clear();
    super.disposed();
  }
  clear() {
    while (this.length !== 0) {
      this.get(0).dispose();
    }
  }
  *[_Symbol$iterator]() {
    const length2 = this.length;
    for (let i = 0; i < length2; ++i) {
      yield this.get(i);
    }
  }
  toJSON() {
    return {
      type: this.direction,
      children: _Array$from(this).map((x) => x.toJSON())
    };
  }
}
function makeComponent(container, spec) {
  const element = document.createElement("div");
  element.style.flex = "1";
  element.style.width = "0px";
  if (typeof spec === "string") {
    if (container.parent !== void 0) {
      throw new Error(`Invalid layout component specification: ${_JSON$stringify(spec)}`);
    }
    return new SingletonLayerGroupViewer(element, spec, container.viewer);
  }
  verifyObject(spec);
  const componentType = verifyObjectProperty(spec, "type", verifyString);
  switch (componentType) {
    case "row":
    case "column": {
      return new StackLayoutComponent(element, componentType, verifyObjectProperty(spec, "children", (x) => {
        const children = parseArray(x, (y) => y);
        if (container.parent === void 0 && children.length === 0) {
          throw new Error("Stack layout requires at least one child.");
        }
        return children;
      }), container);
    }
    case "viewer": {
      const viewer = container.viewer;
      const layerSpecification = new LayerSubsetSpecification(viewer.layerSpecification.addRef());
      const layerGroupViewer = new LayerGroupViewer(element, _Object$assign({ display: viewer.display, layerSpecification }, getCommonViewerState(viewer)), {
        showLayerPanel: viewer.uiControlVisibility.showLayerPanel,
        showViewerMenu: true,
        showLayerHoverValues: viewer.uiControlVisibility.showLayerHoverValues
      });
      try {
        layerGroupViewer.restoreState(spec);
      } catch (e) {
        layerGroupViewer.dispose();
        throw e;
      }
      return layerGroupViewer;
    }
    default: {
      return new SingletonLayerGroupViewer(element, spec, container.viewer);
    }
  }
}
class RootLayoutContainer extends RefCounted {
  constructor(viewer, defaultSpecification) {
    super();
    this.viewer = viewer;
    this.defaultSpecification = defaultSpecification;
    this.container = this.registerDisposer(new LayoutComponentContainer(this.viewer, this.defaultSpecification, void 0));
  }
  get changed() {
    return this.container.changed;
  }
  get element() {
    return this.container.element;
  }
  reset() {
    this.container.setSpecification(this.defaultSpecification);
  }
  restoreState(obj) {
    this.container.setSpecification(obj);
  }
  disposed() {
    super.disposed();
  }
  toJSON() {
    return this.container.toJSON();
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let overlaysOpen = 0;
const defaultEventMap = EventActionMap.fromObject({
  "escape": { action: "close" }
});
class Overlay extends RefCounted {
  constructor() {
    super();
    this.keyMap = new EventActionMap();
    this.keyMap.addParent(defaultEventMap, Number.NEGATIVE_INFINITY);
    ++overlaysOpen;
    let container = this.container = document.createElement("div");
    container.className = "overlay";
    let content = this.content = document.createElement("div");
    this.registerDisposer(new AutomaticallyFocusedElement(content));
    content.className = "overlay-content";
    container.appendChild(content);
    document.body.appendChild(container);
    this.registerDisposer(new KeyboardEventBinder(this.container, this.keyMap));
    this.registerEventListener(container, "action:close", () => {
      this.dispose();
    });
    content.focus();
  }
  disposed() {
    --overlaysOpen;
    document.body.removeChild(this.container);
    super.disposed();
  }
}
const svg_eye_crossed = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-labelledby="eyeCrossedIconTitle"><title id="eyeCrossedIconTitle">Hidden (crossed eye)</title><path d="M22 12C22 12 19 18 12 18C5 18 2 12 2 12C2 12 5 6 12 6C19 6 22 12 22 12Z"></path><circle cx="12" cy="12" r="3"></circle><path d="M3 21L20 4"></path></svg>';
const svg_eye = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-labelledby="eyeIconTitle"><title id="eyeIconTitle">Visible (eye)</title><path d="M22 12C22 12 19 18 12 18C5 18 2 12 2 12C2 12 5 6 12 6C19 6 22 12 22 12Z"></path><circle cx="12" cy="12" r="3"></circle></svg>';
const svg_cursor = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="cursorIconTitle"><title id="cursorIconTitle">Cursor</title><polygon points="7 20 7 4 19 16 12 16 7 21"></polygon></svg>';
const layerNameInputEventMap = EventActionMap.fromObject({
  "escape": { action: "cancel" }
});
class LayerNameWidget extends RefCounted {
  constructor(layer) {
    super();
    this.layer = layer;
    this.element = document.createElement("input");
    const element = this.element;
    element.classList.add("neuroglancer-layer-side-panel-name");
    element.spellcheck = false;
    element.autocomplete = "off";
    const keyboardHandler = this.registerDisposer(new KeyboardEventBinder(element, layerNameInputEventMap));
    keyboardHandler.allShortcutsAreGlobal = true;
    registerActionListener(element, "cancel", (event) => {
      this.updateView();
      element.blur();
      event.stopPropagation();
      event.preventDefault();
    });
    element.title = "Rename layer";
    this.registerDisposer(layer.layerChanged.add(() => this.updateView()));
    element.addEventListener("change", () => this.updateModel());
    element.addEventListener("blur", () => this.updateModel());
    this.updateView();
  }
  updateView() {
    this.element.value = this.layer.name;
  }
  updateModel() {
    changeLayerName(this.layer, this.element.value);
  }
}
class LayerTypeWidget extends RefCounted {
  constructor(layer) {
    super();
    this.layer = layer;
    this.element = document.createElement("select");
    this.measureElement = document.createElement("div");
    const element = this.element, measureElement = this.measureElement;
    element.classList.add("neuroglancer-layer-side-panel-type");
    measureElement.classList.add("neuroglancer-layer-side-panel-type-measure");
    element.title = "Change layer type";
    document.body.appendChild(measureElement);
    for (const _ref of layerTypes) {
      var _ref2 = _slicedToArray(_ref, 2);
      const layerType = _ref2[0];
      const layerConstructor = _ref2[1];
      if (layerConstructor.type !== layerType) continue;
      const option = document.createElement("option");
      option.textContent = layerConstructor.typeAbbreviation;
      option.value = layerType;
      element.appendChild(option);
    }
    element.addEventListener("change", () => {
      const newType = element.value;
      const layerConstructor = layerTypes.get(newType);
      changeLayerType(this.layer.managedLayer, layerConstructor);
    });
    this.updateView();
  }
  updateView() {
    const selectedName = this.layer.type;
    const element = this.element, measureElement = this.measureElement;
    measureElement.textContent = this.layer.constructor.typeAbbreviation;
    element.value = selectedName;
    element.style.width = `${measureElement.offsetWidth}px`;
  }
  disposed() {
    this.measureElement.remove();
  }
}
class LayerSidePanel extends SidePanel {
  constructor(sidePanelManager, panelState) {
    super(sidePanelManager, panelState.location);
    this.panelState = panelState;
    const layer = this.layer = panelState.layer;
    const element = this.element;
    var _addTitleBar = this.addTitleBar({});
    const titleBar = _addTitleBar.titleBar;
    titleBar.classList.add("neuroglancer-layer-side-panel-title");
    titleBar.appendChild(this.registerDisposer(new LayerTypeWidget(layer)).element);
    titleBar.appendChild(this.registerDisposer(new LayerNameWidget(layer.managedLayer)).element);
    this.registerDisposer(observeWatchable((visible) => {
      element.dataset.neuroglancerLayerVisible = visible.toString();
    }, {
      get value() {
        return layer.managedLayer.visible;
      },
      changed: layer.managedLayer.layerChanged
    }));
    const pickButton = this.registerDisposer(new CheckboxIcon({
      get value() {
        return layer.managedLayer.pickEnabled;
      },
      set value(value) {
        layer.managedLayer.pickEnabled = value;
      },
      changed: layer.managedLayer.layerChanged
    }, {
      svg: svg_cursor,
      enableTitle: "Spatial object selection: disabled",
      disableTitle: "Spatial object selection: enabled"
    }));
    this.registerDisposer(new ElementVisibilityFromTrackableBoolean({
      get value() {
        return layer.managedLayer.supportsPickOption;
      },
      changed: layer.managedLayer.layerChanged
    }, pickButton.element));
    titleBar.appendChild(pickButton.element);
    const pinWatchable = {
      get value() {
        return panelState !== layer.panels.panels[0];
      },
      set value(value) {
        if (value) {
          panelState.pin();
        } else {
          panelState.unpin();
        }
      },
      changed: layer.manager.root.layerManager.layersChanged
    };
    titleBar.appendChild(this.registerDisposer(new CheckboxIcon(pinWatchable, {
      // Note: \ufe0e forces text display, as otherwise the pin icon
      // may as an emoji with color.
      text: "📌︎",
      enableTitle: "Pin panel to this layer",
      disableTitle: "Unpin panel to this layer"
    })).element);
    this.registerDisposer(observeWatchable((pinned) => {
      element.dataset.neuroglancerLayerPanelPinned = pinned.toString();
    }, pinWatchable));
    titleBar.appendChild(makeDeleteButton({
      title: "Delete layer",
      onClick: () => {
        deleteLayer(this.layer.managedLayer);
      }
    }));
    this.tabView = new TabView({
      makeTab: (id) => layer.tabs.options.get(id).getter(),
      selectedTab: panelState.selectedTab,
      tabs: this.registerDisposer(new CachedWatchableValue({
        get value() {
          return panelState.tabs.map((id) => ({
            id,
            label: layer.tabs.options.get(id).label
          }));
        },
        changed: panelState.tabsChanged
      })),
      handleTabElement: (id, element2) => {
        element2.draggable = true;
        element2.addEventListener("dragstart", (event) => {
          event.stopPropagation();
          event.dataTransfer.setData("neuroglancer-side-panel", "");
          let message = "Drag tab to dock as new panel to the left/right/top/bottom of another panel";
          const hasOtherPanel = panelState.panels.panels.find((p) => p !== panelState && p.location.visible);
          if (hasOtherPanel) {
            message += `, or move tab to other ${_JSON$stringify(layer.managedLayer.name)} panel`;
          }
          pushDragStatus(element2, "drag", message);
          this.sidePanelManager.startDrag({
            dropAsNewPanel: (location2) => {
              this.panelState.splitOffTab(id, _Object$assign(_Object$assign({}, LAYER_SIDE_PANEL_DEFAULT_LOCATION), location2));
            },
            canDropAsTabs: (target) => {
              if (target instanceof LayerSidePanel && target.layer === this.layer && target !== this) {
                return 1;
              }
              return 0;
            },
            dropAsTab: (target) => {
              this.panelState.moveTabTo(id, target.panelState);
            }
          }, event);
        });
        element2.addEventListener("dragend", (event) => {
          popDragStatus(element2, "drag");
          this.sidePanelManager.endDrag();
        });
      }
    }, this.visibility);
    this.tabView.element.style.flex = "1";
    this.tabView.element.classList.add("neuroglancer-layer-side-panel-tab-view");
    this.tabView.element.style.position = "relative";
    this.tabView.element.appendChild(this.makeTabDropZone());
    this.addBody(this.tabView.element);
    this.registerDisposer(panelState.tabsChanged.add(() => {
      if (panelState.tabs.length === 0) {
        this.location.visible = false;
      }
    }));
  }
  makeDragSource() {
    return _Object$assign(_Object$assign({}, super.makeDragSource()), { canDropAsTabs: (target) => {
      if (target instanceof LayerSidePanel && target.layer === this.layer && target !== this) {
        return this.panelState.tabs.length;
      }
      return 0;
    }, dropAsTab: (target) => {
      this.panelState.mergeInto(target.panelState);
    } });
  }
  makeTabDropZone() {
    const element = document.createElement("div");
    element.className = "neuroglancer-side-panel-drop-zone";
    element.style.position = "absolute";
    element.style.left = "20px";
    element.style.right = "20px";
    element.style.bottom = "20px";
    element.style.top = "20px";
    element.addEventListener("dragenter", (event) => {
      var _a;
      const dragSource2 = this.sidePanelManager.dragSource;
      const numTabs = (_a = dragSource2 === null || dragSource2 === void 0 ? void 0 : dragSource2.canDropAsTabs) === null || _a === void 0 ? void 0 : _a.call(dragSource2, this);
      if (!numTabs) return;
      element.classList.add(DRAG_OVER_CLASSNAME);
      pushDragStatus(element, "drop", `Move ${numTabs} ${numTabs === 1 ? "tab" : "tabs"} to this panel`);
      event.preventDefault();
    });
    element.addEventListener("dragleave", () => {
      popDragStatus(element, "drop");
      element.classList.remove(DRAG_OVER_CLASSNAME);
    });
    element.addEventListener("dragover", (event) => {
      var _a;
      const dragSource2 = this.sidePanelManager.dragSource;
      if (!((_a = dragSource2 === null || dragSource2 === void 0 ? void 0 : dragSource2.canDropAsTabs) === null || _a === void 0 ? void 0 : _a.call(dragSource2, this))) return;
      event.preventDefault();
    });
    element.addEventListener("drop", (event) => {
      var _a;
      popDragStatus(element, "drop");
      const dragSource2 = this.sidePanelManager.dragSource;
      if (!((_a = dragSource2 === null || dragSource2 === void 0 ? void 0 : dragSource2.canDropAsTabs) === null || _a === void 0 ? void 0 : _a.call(dragSource2, this))) return;
      element.classList.remove(DRAG_OVER_CLASSNAME);
      dragSource2.dropAsTab(this);
      event.preventDefault();
      event.stopPropagation();
    });
    return element;
  }
}
class LayerSidePanelManager extends RefCounted {
  constructor(sidePanelManager, selectedLayerState) {
    super();
    this.sidePanelManager = sidePanelManager;
    this.selectedLayerState = selectedLayerState;
    this.layerSidePanels = new _Map();
    this.generation = 0;
    this.layersNeedUpdate = true;
    const handleUpdate = () => {
      this.layersNeedUpdate = true;
      this.sidePanelManager.display.scheduleRedraw();
    };
    this.registerDisposer(selectedLayerState.changed.add(handleUpdate));
    this.registerDisposer(selectedLayerState.layerManager.layersChanged.add(handleUpdate));
    this.registerDisposer(sidePanelManager.beforeRender.add(() => this.update()));
  }
  getSelectedUserLayer() {
    var _a, _b;
    return (_b = (_a = this.selectedLayerState.layer) === null || _a === void 0 ? void 0 : _a.layer) !== null && _b !== void 0 ? _b : void 0;
  }
  update() {
    var _a;
    if (!this.layersNeedUpdate) return;
    const layerManager = this.selectedLayerState.layerManager;
    let generation = ++this.generation;
    this.layersNeedUpdate = false;
    const layerSidePanels = this.layerSidePanels;
    const ensurePanel = (panelState) => {
      let existing = layerSidePanels.get(panelState);
      if (existing === void 0) {
        existing = {
          generation,
          unregister: this.sidePanelManager.registerPanel({
            location: panelState.location,
            makePanel: () => new LayerSidePanel(this.sidePanelManager, panelState)
          })
        };
        layerSidePanels.set(panelState, existing);
      } else {
        existing.generation = generation;
      }
    };
    {
      const layer = this.getSelectedUserLayer();
      const location2 = this.selectedLayerState.location;
      if (layer === void 0 || !location2.visible) {
        if (this.placeholderSelectedLayerPanel === void 0) {
          this.placeholderSelectedLayerPanel = this.sidePanelManager.registerPanel({ location: location2, makePanel: () => new SidePanel(this.sidePanelManager, location2) });
        }
      } else {
        (_a = this.placeholderSelectedLayerPanel) === null || _a === void 0 ? void 0 : _a.call(this);
        this.placeholderSelectedLayerPanel = void 0;
        const panelState = layer.panels.panels[0];
        panelState.location.value = location2.value;
        ensurePanel(panelState);
      }
    }
    for (const layer of layerManager.managedLayers) {
      const userLayer = layer.layer;
      if (userLayer === null) continue;
      const panels = userLayer.panels.panels;
      for (let i = 1, length2 = panels.length; i < length2; ++i) {
        ensurePanel(panels[i]);
      }
    }
    for (const _ref3 of layerSidePanels) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const panelState = _ref4[0];
      const existing = _ref4[1];
      if (existing.generation === generation) continue;
      existing.unregister();
      layerSidePanels.delete(panelState);
    }
  }
  disposed() {
    var _a;
    (_a = this.placeholderSelectedLayerPanel) === null || _a === void 0 ? void 0 : _a.call(this);
    for (const _ref5 of this.layerSidePanels.values()) {
      const unregister = _ref5.unregister;
      unregister();
    }
  }
}
const DEFAULT_LAYER_LIST_PANEL_LOCATION = _Object$assign(_Object$assign({}, DEFAULT_SIDE_PANEL_LOCATION), { side: "left", row: 0 });
class LayerListPanelState {
  constructor() {
    this.location = new TrackableSidePanelLocation(DEFAULT_LAYER_LIST_PANEL_LOCATION);
  }
  get changed() {
    return this.location.changed;
  }
  restoreState(obj) {
    if (obj === void 0) return;
    this.location.restoreState(obj);
  }
  reset() {
    this.location.reset();
  }
  toJSON() {
    return emptyToUndefined(this.location.toJSON());
  }
}
class LayerVisibilityWidget extends RefCounted {
  constructor(layer) {
    super();
    this.layer = layer;
    this.element = document.createElement("div");
    const element = this.element;
    const hideIcon = makeIcon({
      svg: svg_eye,
      title: "Hide layer",
      onClick: () => {
        this.layer.setVisible(false);
      }
    });
    const showIcon = makeIcon({
      svg: svg_eye_crossed,
      title: "Show layer",
      onClick: () => {
        this.layer.setVisible(true);
      }
    });
    element.appendChild(showIcon);
    element.appendChild(hideIcon);
    const updateView = () => {
      const visible = this.layer.visible;
      hideIcon.style.display = visible ? "" : "none";
      showIcon.style.display = !visible ? "" : "none";
    };
    updateView();
    this.registerDisposer(layer.layerChanged.add(updateView));
  }
}
function makeSelectedLayerSidePanelCheckboxIcon(layer) {
  const selectedLayer = layer.manager.root.selectedLayer;
  const icon = new CheckboxIcon({
    get value() {
      return selectedLayer.layer === layer && selectedLayer.visible;
    },
    set value(value) {
      if (value) {
        selectedLayer.layer = layer;
        selectedLayer.visible = true;
      } else {
        selectedLayer.visible = false;
      }
    },
    changed: selectedLayer.changed
  }, {
    backgroundScheme: "dark",
    enableTitle: "Show layer side panel",
    disableTitle: "Hide layer side panel",
    svg: svg_controls_alt
  });
  icon.element.classList.add("neuroglancer-layer-list-panel-item-controls");
  return icon;
}
class LayerListItem extends RefCounted {
  constructor(panel, layer) {
    super();
    this.panel = panel;
    this.layer = layer;
    this.element = document.createElement("div");
    this.numberElement = document.createElement("div");
    this.generation = -1;
    const element = this.element, numberElement = this.numberElement;
    element.classList.add("neuroglancer-layer-list-panel-item");
    numberElement.classList.add("neuroglancer-layer-list-panel-item-number");
    element.appendChild(this.registerDisposer(new TrackableBooleanCheckbox({
      get value() {
        return !layer.archived;
      },
      set value(value) {
        layer.setArchived(!value);
      },
      changed: layer.layerChanged
    }, {
      enableTitle: "Archive layer (disable and remove from layer groups)",
      disableTitle: "Unarchive layer (enable and add to all layer groups)"
    })).element);
    element.appendChild(numberElement);
    element.appendChild(this.registerDisposer(new LayerVisibilityWidget(layer)).element);
    element.appendChild(this.registerDisposer(new LayerNameWidget(layer)).element);
    element.appendChild(this.registerDisposer(makeSelectedLayerSidePanelCheckboxIcon(layer)).element);
    const deleteButton = makeDeleteButton({
      title: "Delete layer",
      onClick: () => {
        deleteLayer(this.layer);
      }
    });
    deleteButton.classList.add("neuroglancer-layer-list-panel-item-delete");
    element.appendChild(deleteButton);
    registerLayerDragHandlers(panel, element, layer, { isLayerListPanel: true, getLayoutSpec: () => void 0 });
    registerLayerBarDropHandlers(
      panel,
      element,
      layer,
      /*allowArchived=*/
      true
    );
    element.addEventListener("click", (event) => {
      if (event.ctrlKey) {
        panel.selectedLayer.toggle(layer);
        event.preventDefault();
      } else if (event.altKey) {
        layer.pickEnabled = !layer.pickEnabled;
        event.preventDefault();
      }
    });
    element.addEventListener("contextmenu", (event) => {
      panel.selectedLayer.toggle(layer);
      event.stopPropagation();
      event.preventDefault();
    });
  }
}
class LayerListPanel extends SidePanel {
  constructor(sidePanelManager, manager, state) {
    super(sidePanelManager, state.location);
    this.manager = manager;
    this.state = state;
    this.items = new _Map();
    this.itemContainer = document.createElement("div");
    this.layerDropZone = document.createElement("div");
    this.dragEnterCount = 0;
    this.generation = -1;
    const itemContainer = this.itemContainer, layerDropZone = this.layerDropZone;
    var _addTitleBar = this.addTitleBar({ title: "" });
    const titleElement = _addTitleBar.titleElement;
    this.titleElement = titleElement;
    itemContainer.classList.add("neuroglancer-layer-list-panel-items");
    this.addBody(itemContainer);
    layerDropZone.style.flex = "1";
    const debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.render()));
    this.visibility.changed.add(debouncedUpdateView);
    this.registerDisposer(this.layerManager.layersChanged.add(debouncedUpdateView));
    this.registerDisposer(this.selectedLayer.changed.add(debouncedUpdateView));
    registerLayerBarDragLeaveHandler(this);
    registerLayerBarDropHandlers(
      this,
      layerDropZone,
      void 0,
      /*allowArchived=*/
      true
    );
    this.render();
  }
  get layerManager() {
    return this.manager.layerManager;
  }
  get selectedLayer() {
    return this.manager.selectedLayer;
  }
  render() {
    const self2 = this;
    const selectedLayer = this.selectedLayer.layer;
    const generation = ++this.generation;
    let numVisible = 0;
    let numHidden = 0;
    let numArchived = 0;
    this.layerManager.updateNonArchivedLayerIndices();
    function* getItems() {
      const items = self2.items;
      let numNonArchivedLayers = 0;
      for (const layer of self2.layerManager.managedLayers) {
        if (!layer.archived) ++numNonArchivedLayers;
      }
      const numberElementWidth = `${(numNonArchivedLayers + 1).toString().length}ch`;
      for (const layer of self2.layerManager.managedLayers) {
        if (layer.visible) {
          ++numVisible;
        } else if (!layer.archived) {
          ++numHidden;
        } else {
          ++numArchived;
        }
        let item = items.get(layer);
        if (item === void 0) {
          item = self2.registerDisposer(new LayerListItem(self2, layer));
          items.set(layer, item);
          item.generation = generation;
        } else {
          item.generation = generation;
        }
        const nonArchivedLayerIndex = layer.nonArchivedLayerIndex;
        item.numberElement.style.width = numberElementWidth;
        if (nonArchivedLayerIndex === -1) {
          item.numberElement.style.visibility = "hidden";
        } else {
          item.numberElement.style.visibility = "";
          item.numberElement.textContent = `${nonArchivedLayerIndex + 1}`;
        }
        item.element.dataset.selected = (layer === selectedLayer).toString();
        item.element.dataset.archived = layer.archived.toString();
        yield item.element;
      }
      for (const _ref of items) {
        var _ref2 = _slicedToArray(_ref, 2);
        const userLayer = _ref2[0];
        const item = _ref2[1];
        if (generation !== item.generation) {
          items.delete(userLayer);
          self2.unregisterDisposer(item);
          item.dispose();
        }
      }
      yield self2.layerDropZone;
    }
    updateChildren(this.itemContainer, getItems());
    let title = "Layers";
    if (numVisible || numHidden || numArchived) {
      title += " (";
      let sep = "";
      if (numVisible + numHidden) {
        title += `${numVisible}/${numHidden + numVisible} visible`;
        sep = ", ";
      }
      if (numArchived) {
        title += `${sep}${numArchived} archived`;
      }
      title += ")";
    }
    this.titleElement.textContent = title;
  }
}
class LayerArchiveCountWidget extends RefCounted {
  constructor(layerManager) {
    super();
    this.layerManager = layerManager;
    this.element = document.createElement("div");
    const debouncedRender = this.registerCancellable(animationFrameDebounce(() => this.render()));
    this.registerDisposer(layerManager.layersChanged.add(debouncedRender));
    this.render();
  }
  render() {
    let numArchived = 0;
    const managedLayers = this.layerManager.managedLayers;
    for (const layer of managedLayers) {
      if (layer.archived) ++numArchived;
    }
    const element = this.element;
    if (numArchived !== 0) {
      const numLayers = managedLayers.length;
      element.textContent = `${numLayers - numArchived}/${numLayers}`;
    } else {
      element.textContent = "";
    }
  }
}
var javascript = { exports: {} };
var codemirror$1 = { exports: {} };
var codemirror = codemirror$1.exports;
var hasRequiredCodemirror;
function requireCodemirror() {
  if (hasRequiredCodemirror) return codemirror$1.exports;
  hasRequiredCodemirror = 1;
  (function(module, exports) {
    (function(global, factory) {
      module.exports = factory();
    })(codemirror, function() {
      var userAgent = navigator.userAgent;
      var platform = navigator.platform;
      var gecko = /gecko\/\d/i.test(userAgent);
      var ie_upto10 = /MSIE \d/.test(userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
      var edge = /Edge\/(\d+)/.exec(userAgent);
      var ie = ie_upto10 || ie_11up || edge;
      var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
      var webkit = !edge && /WebKit\//.test(userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
      var chrome = !edge && /Chrome\/(\d+)/.exec(userAgent);
      var chrome_version = chrome && +chrome[1];
      var presto = /Opera\//.test(userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
      var phantom = /PhantomJS/.test(userAgent);
      var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
      var android = /Android/.test(userAgent);
      var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
      var mac = ios || /Mac/.test(platform);
      var chromeOS = /\bCrOS\b/.test(userAgent);
      var windows = /win/i.test(platform);
      var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
      if (presto_version) {
        presto_version = Number(presto_version[1]);
      }
      if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
      }
      var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
      var captureRightClick = gecko || ie && ie_version >= 9;
      function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
      }
      var rmClass = function(node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);
        if (match) {
          var after = current.slice(match.index + match[0].length);
          node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
      };
      function removeChildren2(e) {
        for (var count = e.childNodes.length; count > 0; --count) {
          e.removeChild(e.firstChild);
        }
        return e;
      }
      function removeChildrenAndAdd(parent, e) {
        return removeChildren2(parent).appendChild(e);
      }
      function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className) {
          e.className = className;
        }
        if (style) {
          e.style.cssText = style;
        }
        if (typeof content == "string") {
          e.appendChild(document.createTextNode(content));
        } else if (content) {
          for (var i2 = 0; i2 < content.length; ++i2) {
            e.appendChild(content[i2]);
          }
        }
        return e;
      }
      function eltP(tag, content, className, style) {
        var e = elt(tag, content, className, style);
        e.setAttribute("role", "presentation");
        return e;
      }
      var range;
      if (document.createRange) {
        range = function(node, start, end, endNode) {
          var r = document.createRange();
          r.setEnd(endNode || node, end);
          r.setStart(node, start);
          return r;
        };
      } else {
        range = function(node, start, end) {
          var r = document.body.createTextRange();
          try {
            r.moveToElementText(node.parentNode);
          } catch (e) {
            return r;
          }
          r.collapse(true);
          r.moveEnd("character", end);
          r.moveStart("character", start);
          return r;
        };
      }
      function contains(parent, child) {
        if (child.nodeType == 3) {
          child = child.parentNode;
        }
        if (parent.contains) {
          return parent.contains(child);
        }
        do {
          if (child.nodeType == 11) {
            child = child.host;
          }
          if (child == parent) {
            return true;
          }
        } while (child = child.parentNode);
      }
      function activeElt(rootNode2) {
        var doc2 = rootNode2.ownerDocument || rootNode2;
        var activeElement;
        try {
          activeElement = rootNode2.activeElement;
        } catch (e) {
          activeElement = doc2.body || null;
        }
        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
        return activeElement;
      }
      function addClass(node, cls) {
        var current = node.className;
        if (!classTest(cls).test(current)) {
          node.className += (current ? " " : "") + cls;
        }
      }
      function joinClasses(a, b) {
        var as = a.split(" ");
        for (var i2 = 0; i2 < as.length; i2++) {
          if (as[i2] && !classTest(as[i2]).test(b)) {
            b += " " + as[i2];
          }
        }
        return b;
      }
      var selectInput = function(node) {
        node.select();
      };
      if (ios) {
        selectInput = function(node) {
          node.selectionStart = 0;
          node.selectionEnd = node.value.length;
        };
      } else if (ie) {
        selectInput = function(node) {
          try {
            node.select();
          } catch (_e) {
          }
        };
      }
      function doc(cm) {
        return cm.display.wrapper.ownerDocument;
      }
      function root(cm) {
        return rootNode(cm.display.wrapper);
      }
      function rootNode(element) {
        return element.getRootNode ? element.getRootNode() : element.ownerDocument;
      }
      function win(cm) {
        return doc(cm).defaultView;
      }
      function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
          return f.apply(null, args);
        };
      }
      function copyObj(obj, target, overwrite) {
        if (!target) {
          target = {};
        }
        for (var prop2 in obj) {
          if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
            target[prop2] = obj[prop2];
          }
        }
        return target;
      }
      function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1) {
            end = string.length;
          }
        }
        for (var i2 = startIndex || 0, n = startValue || 0; ; ) {
          var nextTab = string.indexOf("	", i2);
          if (nextTab < 0 || nextTab >= end) {
            return n + (end - i2);
          }
          n += nextTab - i2;
          n += tabSize - n % tabSize;
          i2 = nextTab + 1;
        }
      }
      var Delayed = function() {
        this.id = null;
        this.f = null;
        this.time = 0;
        this.handler = bind(this.onTimeout, this);
      };
      Delayed.prototype.onTimeout = function(self2) {
        self2.id = 0;
        if (self2.time <= +/* @__PURE__ */ new Date()) {
          self2.f();
        } else {
          setTimeout(self2.handler, self2.time - +/* @__PURE__ */ new Date());
        }
      };
      Delayed.prototype.set = function(ms, f) {
        this.f = f;
        var time = +/* @__PURE__ */ new Date() + ms;
        if (!this.id || time < this.time) {
          clearTimeout(this.id);
          this.id = setTimeout(this.handler, ms);
          this.time = time;
        }
      };
      function indexOf(array, elt2) {
        for (var i2 = 0; i2 < array.length; ++i2) {
          if (array[i2] == elt2) {
            return i2;
          }
        }
        return -1;
      }
      var scrollerGap = 50;
      var Pass = { toString: function() {
        return "CodeMirror.Pass";
      } };
      var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
      function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0; ; ) {
          var nextTab = string.indexOf("	", pos);
          if (nextTab == -1) {
            nextTab = string.length;
          }
          var skipped = nextTab - pos;
          if (nextTab == string.length || col + skipped >= goal) {
            return pos + Math.min(skipped, goal - col);
          }
          col += nextTab - pos;
          col += tabSize - col % tabSize;
          pos = nextTab + 1;
          if (col >= goal) {
            return pos;
          }
        }
      }
      var spaceStrs = [""];
      function spaceStr(n) {
        while (spaceStrs.length <= n) {
          spaceStrs.push(lst(spaceStrs) + " ");
        }
        return spaceStrs[n];
      }
      function lst(arr) {
        return arr[arr.length - 1];
      }
      function map2(array, f) {
        var out = [];
        for (var i2 = 0; i2 < array.length; i2++) {
          out[i2] = f(array[i2], i2);
        }
        return out;
      }
      function insertSorted(array, value, score) {
        var pos = 0, priority = score(value);
        while (pos < array.length && score(array[pos]) <= priority) {
          pos++;
        }
        array.splice(pos, 0, value);
      }
      function nothing() {
      }
      function createObj(base, props) {
        var inst;
        if (Object.create) {
          inst = Object.create(base);
        } else {
          nothing.prototype = base;
          inst = new nothing();
        }
        if (props) {
          copyObj(props, inst);
        }
        return inst;
      }
      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      function isWordCharBasic(ch) {
        return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
      }
      function isWordChar(ch, helper) {
        if (!helper) {
          return isWordCharBasic(ch);
        }
        if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
          return true;
        }
        return helper.test(ch);
      }
      function isEmpty(obj) {
        for (var n in obj) {
          if (obj.hasOwnProperty(n) && obj[n]) {
            return false;
          }
        }
        return true;
      }
      var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
      function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
      }
      function skipExtendingChars(str, pos, dir) {
        while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
          pos += dir;
        }
        return pos;
      }
      function findFirst(pred, from2, to) {
        var dir = from2 > to ? -1 : 1;
        for (; ; ) {
          if (from2 == to) {
            return from2;
          }
          var midF = (from2 + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
          if (mid == from2) {
            return pred(mid) ? from2 : to;
          }
          if (pred(mid)) {
            to = mid;
          } else {
            from2 = mid + dir;
          }
        }
      }
      function iterateBidiSections(order, from2, to, f) {
        if (!order) {
          return f(from2, to, "ltr", 0);
        }
        var found = false;
        for (var i2 = 0; i2 < order.length; ++i2) {
          var part = order[i2];
          if (part.from < to && part.to > from2 || from2 == to && part.to == from2) {
            f(Math.max(part.from, from2), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
            found = true;
          }
        }
        if (!found) {
          f(from2, to, "ltr");
        }
      }
      var bidiOther = null;
      function getBidiPartAt(order, ch, sticky) {
        var found;
        bidiOther = null;
        for (var i2 = 0; i2 < order.length; ++i2) {
          var cur = order[i2];
          if (cur.from < ch && cur.to > ch) {
            return i2;
          }
          if (cur.to == ch) {
            if (cur.from != cur.to && sticky == "before") {
              found = i2;
            } else {
              bidiOther = i2;
            }
          }
          if (cur.from == ch) {
            if (cur.from != cur.to && sticky != "before") {
              found = i2;
            } else {
              bidiOther = i2;
            }
          }
        }
        return found != null ? found : bidiOther;
      }
      var bidiOrdering = /* @__PURE__ */ function() {
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
        var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
        function charType(code) {
          if (code <= 247) {
            return lowTypes.charAt(code);
          } else if (1424 <= code && code <= 1524) {
            return "R";
          } else if (1536 <= code && code <= 1785) {
            return arabicTypes.charAt(code - 1536);
          } else if (1774 <= code && code <= 2220) {
            return "r";
          } else if (8192 <= code && code <= 8203) {
            return "w";
          } else if (code == 8204) {
            return "b";
          } else {
            return "L";
          }
        }
        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
        function BidiSpan(level, from2, to) {
          this.level = level;
          this.from = from2;
          this.to = to;
        }
        return function(str, direction) {
          var outerType = direction == "ltr" ? "L" : "R";
          if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
            return false;
          }
          var len2 = str.length, types = [];
          for (var i2 = 0; i2 < len2; ++i2) {
            types.push(charType(str.charCodeAt(i2)));
          }
          for (var i$12 = 0, prev = outerType; i$12 < len2; ++i$12) {
            var type = types[i$12];
            if (type == "m") {
              types[i$12] = prev;
            } else {
              prev = type;
            }
          }
          for (var i$22 = 0, cur = outerType; i$22 < len2; ++i$22) {
            var type$1 = types[i$22];
            if (type$1 == "1" && cur == "r") {
              types[i$22] = "n";
            } else if (isStrong.test(type$1)) {
              cur = type$1;
              if (type$1 == "r") {
                types[i$22] = "R";
              }
            }
          }
          for (var i$3 = 1, prev$1 = types[0]; i$3 < len2 - 1; ++i$3) {
            var type$2 = types[i$3];
            if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
              types[i$3] = "1";
            } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
              types[i$3] = prev$1;
            }
            prev$1 = type$2;
          }
          for (var i$4 = 0; i$4 < len2; ++i$4) {
            var type$3 = types[i$4];
            if (type$3 == ",") {
              types[i$4] = "N";
            } else if (type$3 == "%") {
              var end = void 0;
              for (end = i$4 + 1; end < len2 && types[end] == "%"; ++end) {
              }
              var replace = i$4 && types[i$4 - 1] == "!" || end < len2 && types[end] == "1" ? "1" : "N";
              for (var j = i$4; j < end; ++j) {
                types[j] = replace;
              }
              i$4 = end - 1;
            }
          }
          for (var i$5 = 0, cur$1 = outerType; i$5 < len2; ++i$5) {
            var type$4 = types[i$5];
            if (cur$1 == "L" && type$4 == "1") {
              types[i$5] = "L";
            } else if (isStrong.test(type$4)) {
              cur$1 = type$4;
            }
          }
          for (var i$6 = 0; i$6 < len2; ++i$6) {
            if (isNeutral.test(types[i$6])) {
              var end$1 = void 0;
              for (end$1 = i$6 + 1; end$1 < len2 && isNeutral.test(types[end$1]); ++end$1) {
              }
              var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
              var after = (end$1 < len2 ? types[end$1] : outerType) == "L";
              var replace$1 = before == after ? before ? "L" : "R" : outerType;
              for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                types[j$1] = replace$1;
              }
              i$6 = end$1 - 1;
            }
          }
          var order = [], m;
          for (var i$7 = 0; i$7 < len2; ) {
            if (countsAsLeft.test(types[i$7])) {
              var start = i$7;
              for (++i$7; i$7 < len2 && countsAsLeft.test(types[i$7]); ++i$7) {
              }
              order.push(new BidiSpan(0, start, i$7));
            } else {
              var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
              for (++i$7; i$7 < len2 && types[i$7] != "L"; ++i$7) {
              }
              for (var j$2 = pos; j$2 < i$7; ) {
                if (countsAsNum.test(types[j$2])) {
                  if (pos < j$2) {
                    order.splice(at, 0, new BidiSpan(1, pos, j$2));
                    at += isRTL;
                  }
                  var nstart = j$2;
                  for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {
                  }
                  order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                  at += isRTL;
                  pos = j$2;
                } else {
                  ++j$2;
                }
              }
              if (pos < i$7) {
                order.splice(at, 0, new BidiSpan(1, pos, i$7));
              }
            }
          }
          if (direction == "ltr") {
            if (order[0].level == 1 && (m = str.match(/^\s+/))) {
              order[0].from = m[0].length;
              order.unshift(new BidiSpan(0, 0, m[0].length));
            }
            if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
              lst(order).to -= m[0].length;
              order.push(new BidiSpan(0, len2 - m[0].length, len2));
            }
          }
          return direction == "rtl" ? order.reverse() : order;
        };
      }();
      function getOrder(line, direction) {
        var order = line.order;
        if (order == null) {
          order = line.order = bidiOrdering(line.text, direction);
        }
        return order;
      }
      var noHandlers = [];
      var on = function(emitter, type, f) {
        if (emitter.addEventListener) {
          emitter.addEventListener(type, f, false);
        } else if (emitter.attachEvent) {
          emitter.attachEvent("on" + type, f);
        } else {
          var map3 = emitter._handlers || (emitter._handlers = {});
          map3[type] = (map3[type] || noHandlers).concat(f);
        }
      };
      function getHandlers(emitter, type) {
        return emitter._handlers && emitter._handlers[type] || noHandlers;
      }
      function off(emitter, type, f) {
        if (emitter.removeEventListener) {
          emitter.removeEventListener(type, f, false);
        } else if (emitter.detachEvent) {
          emitter.detachEvent("on" + type, f);
        } else {
          var map3 = emitter._handlers, arr = map3 && map3[type];
          if (arr) {
            var index2 = indexOf(arr, f);
            if (index2 > -1) {
              map3[type] = arr.slice(0, index2).concat(arr.slice(index2 + 1));
            }
          }
        }
      }
      function signal(emitter, type) {
        var handlers2 = getHandlers(emitter, type);
        if (!handlers2.length) {
          return;
        }
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i2 = 0; i2 < handlers2.length; ++i2) {
          handlers2[i2].apply(null, args);
        }
      }
      function signalDOMEvent(cm, e, override) {
        if (typeof e == "string") {
          e = { type: e, preventDefault: function() {
            this.defaultPrevented = true;
          } };
        }
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
      }
      function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr) {
          return;
        }
        var set2 = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for (var i2 = 0; i2 < arr.length; ++i2) {
          if (indexOf(set2, arr[i2]) == -1) {
            set2.push(arr[i2]);
          }
        }
      }
      function hasHandler(emitter, type) {
        return getHandlers(emitter, type).length > 0;
      }
      function eventMixin(ctor) {
        ctor.prototype.on = function(type, f) {
          on(this, type, f);
        };
        ctor.prototype.off = function(type, f) {
          off(this, type, f);
        };
      }
      function e_preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
      }
      function e_stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else {
          e.cancelBubble = true;
        }
      }
      function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
      }
      function e_stop(e) {
        e_preventDefault(e);
        e_stopPropagation(e);
      }
      function e_target(e) {
        return e.target || e.srcElement;
      }
      function e_button(e) {
        var b = e.which;
        if (b == null) {
          if (e.button & 1) {
            b = 1;
          } else if (e.button & 2) {
            b = 3;
          } else if (e.button & 4) {
            b = 2;
          }
        }
        if (mac && e.ctrlKey && b == 1) {
          b = 3;
        }
        return b;
      }
      var dragAndDrop = function() {
        if (ie && ie_version < 9) {
          return false;
        }
        var div = elt("div");
        return "draggable" in div || "dragDrop" in div;
      }();
      var zwspSupported;
      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "​");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
          if (measure.firstChild.offsetHeight != 0) {
            zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
          }
        }
        var node = zwspSupported ? elt("span", "​") : elt("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
        node.setAttribute("cm-text", "");
        return node;
      }
      var badBidiRects;
      function hasBadBidiRects(measure) {
        if (badBidiRects != null) {
          return badBidiRects;
        }
        var txt = removeChildrenAndAdd(measure, document.createTextNode("AخA"));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        removeChildren2(measure);
        if (!r0 || r0.left == r0.right) {
          return false;
        }
        return badBidiRects = r1.right - r0.right < 3;
      }
      var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string) {
        var pos = 0, result = [], l = string.length;
        while (pos <= l) {
          var nl = string.indexOf("\n", pos);
          if (nl == -1) {
            nl = string.length;
          }
          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");
          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }
        return result;
      } : function(string) {
        return string.split(/\r\n?|\n/);
      };
      var hasSelection = window.getSelection ? function(te) {
        try {
          return te.selectionStart != te.selectionEnd;
        } catch (e) {
          return false;
        }
      } : function(te) {
        var range2;
        try {
          range2 = te.ownerDocument.selection.createRange();
        } catch (e) {
        }
        if (!range2 || range2.parentElement() != te) {
          return false;
        }
        return range2.compareEndPoints("StartToEnd", range2) != 0;
      };
      var hasCopyEvent = function() {
        var e = elt("div");
        if ("oncopy" in e) {
          return true;
        }
        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == "function";
      }();
      var badZoomedRects = null;
      function hasBadZoomedRects(measure) {
        if (badZoomedRects != null) {
          return badZoomedRects;
        }
        var node = removeChildrenAndAdd(measure, elt("span", "x"));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
      }
      var modes = {}, mimeModes = {};
      function defineMode(name2, mode) {
        if (arguments.length > 2) {
          mode.dependencies = Array.prototype.slice.call(arguments, 2);
        }
        modes[name2] = mode;
      }
      function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
      }
      function resolveMode(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];
          if (typeof found == "string") {
            found = { name: found };
          }
          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return resolveMode("application/xml");
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
          return resolveMode("application/json");
        }
        if (typeof spec == "string") {
          return { name: spec };
        } else {
          return spec || { name: "null" };
        }
      }
      function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) {
          return getMode(options, "text/plain");
        }
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];
          for (var prop2 in exts) {
            if (!exts.hasOwnProperty(prop2)) {
              continue;
            }
            if (modeObj.hasOwnProperty(prop2)) {
              modeObj["_" + prop2] = modeObj[prop2];
            }
            modeObj[prop2] = exts[prop2];
          }
        }
        modeObj.name = spec.name;
        if (spec.helperType) {
          modeObj.helperType = spec.helperType;
        }
        if (spec.modeProps) {
          for (var prop$1 in spec.modeProps) {
            modeObj[prop$1] = spec.modeProps[prop$1];
          }
        }
        return modeObj;
      }
      var modeExtensions = {};
      function extendMode(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts);
      }
      function copyState(mode, state) {
        if (state === true) {
          return state;
        }
        if (mode.copyState) {
          return mode.copyState(state);
        }
        var nstate = {};
        for (var n in state) {
          var val = state[n];
          if (val instanceof Array) {
            val = val.concat([]);
          }
          nstate[n] = val;
        }
        return nstate;
      }
      function innerMode(mode, state) {
        var info;
        while (mode.innerMode) {
          info = mode.innerMode(state);
          if (!info || info.mode == mode) {
            break;
          }
          state = info.state;
          mode = info.mode;
        }
        return info || { mode, state };
      }
      function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
      }
      var StringStream = function(string, tabSize, lineOracle) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
        this.lineOracle = lineOracle;
      };
      StringStream.prototype.eol = function() {
        return this.pos >= this.string.length;
      };
      StringStream.prototype.sol = function() {
        return this.pos == this.lineStart;
      };
      StringStream.prototype.peek = function() {
        return this.string.charAt(this.pos) || void 0;
      };
      StringStream.prototype.next = function() {
        if (this.pos < this.string.length) {
          return this.string.charAt(this.pos++);
        }
      };
      StringStream.prototype.eat = function(match) {
        var ch = this.string.charAt(this.pos);
        var ok;
        if (typeof match == "string") {
          ok = ch == match;
        } else {
          ok = ch && (match.test ? match.test(ch) : match(ch));
        }
        if (ok) {
          ++this.pos;
          return ch;
        }
      };
      StringStream.prototype.eatWhile = function(match) {
        var start = this.pos;
        while (this.eat(match)) {
        }
        return this.pos > start;
      };
      StringStream.prototype.eatSpace = function() {
        var start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
          ++this.pos;
        }
        return this.pos > start;
      };
      StringStream.prototype.skipToEnd = function() {
        this.pos = this.string.length;
      };
      StringStream.prototype.skipTo = function(ch) {
        var found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
          this.pos = found;
          return true;
        }
      };
      StringStream.prototype.backUp = function(n) {
        this.pos -= n;
      };
      StringStream.prototype.column = function() {
        if (this.lastColumnPos < this.start) {
          this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
          this.lastColumnPos = this.start;
        }
        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      };
      StringStream.prototype.indentation = function() {
        return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      };
      StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
          var cased = function(str) {
            return caseInsensitive ? str.toLowerCase() : str;
          };
          var substr = this.string.substr(this.pos, pattern.length);
          if (cased(substr) == cased(pattern)) {
            if (consume !== false) {
              this.pos += pattern.length;
            }
            return true;
          }
        } else {
          var match = this.string.slice(this.pos).match(pattern);
          if (match && match.index > 0) {
            return null;
          }
          if (match && consume !== false) {
            this.pos += match[0].length;
          }
          return match;
        }
      };
      StringStream.prototype.current = function() {
        return this.string.slice(this.start, this.pos);
      };
      StringStream.prototype.hideFirstChars = function(n, inner) {
        this.lineStart += n;
        try {
          return inner();
        } finally {
          this.lineStart -= n;
        }
      };
      StringStream.prototype.lookAhead = function(n) {
        var oracle = this.lineOracle;
        return oracle && oracle.lookAhead(n);
      };
      StringStream.prototype.baseToken = function() {
        var oracle = this.lineOracle;
        return oracle && oracle.baseToken(this.pos);
      };
      function getLine(doc2, n) {
        n -= doc2.first;
        if (n < 0 || n >= doc2.size) {
          throw new Error("There is no line " + (n + doc2.first) + " in the document.");
        }
        var chunk = doc2;
        while (!chunk.lines) {
          for (var i2 = 0; ; ++i2) {
            var child = chunk.children[i2], sz = child.chunkSize();
            if (n < sz) {
              chunk = child;
              break;
            }
            n -= sz;
          }
        }
        return chunk.lines[n];
      }
      function getBetween(doc2, start, end) {
        var out = [], n = start.line;
        doc2.iter(start.line, end.line + 1, function(line) {
          var text = line.text;
          if (n == end.line) {
            text = text.slice(0, end.ch);
          }
          if (n == start.line) {
            text = text.slice(start.ch);
          }
          out.push(text);
          ++n;
        });
        return out;
      }
      function getLines(doc2, from2, to) {
        var out = [];
        doc2.iter(from2, to, function(line) {
          out.push(line.text);
        });
        return out;
      }
      function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff) {
          for (var n = line; n; n = n.parent) {
            n.height += diff;
          }
        }
      }
      function lineNo(line) {
        if (line.parent == null) {
          return null;
        }
        var cur = line.parent, no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i2 = 0; ; ++i2) {
            if (chunk.children[i2] == cur) {
              break;
            }
            no += chunk.children[i2].chunkSize();
          }
        }
        return no + cur.first;
      }
      function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
          for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
            var child = chunk.children[i$12], ch = child.height;
            if (h < ch) {
              chunk = child;
              continue outer;
            }
            h -= ch;
            n += child.chunkSize();
          }
          return n;
        } while (!chunk.lines);
        var i2 = 0;
        for (; i2 < chunk.lines.length; ++i2) {
          var line = chunk.lines[i2], lh = line.height;
          if (h < lh) {
            break;
          }
          h -= lh;
        }
        return n + i2;
      }
      function isLine(doc2, l) {
        return l >= doc2.first && l < doc2.first + doc2.size;
      }
      function lineNumberFor(options, i2) {
        return String(options.lineNumberFormatter(i2 + options.firstLineNumber));
      }
      function Pos(line, ch, sticky) {
        if (sticky === void 0) sticky = null;
        if (!(this instanceof Pos)) {
          return new Pos(line, ch, sticky);
        }
        this.line = line;
        this.ch = ch;
        this.sticky = sticky;
      }
      function cmp(a, b) {
        return a.line - b.line || a.ch - b.ch;
      }
      function equalCursorPos(a, b) {
        return a.sticky == b.sticky && cmp(a, b) == 0;
      }
      function copyPos(x) {
        return Pos(x.line, x.ch);
      }
      function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
      }
      function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
      }
      function clipLine(doc2, n) {
        return Math.max(doc2.first, Math.min(n, doc2.first + doc2.size - 1));
      }
      function clipPos(doc2, pos) {
        if (pos.line < doc2.first) {
          return Pos(doc2.first, 0);
        }
        var last = doc2.first + doc2.size - 1;
        if (pos.line > last) {
          return Pos(last, getLine(doc2, last).text.length);
        }
        return clipToLen(pos, getLine(doc2, pos.line).text.length);
      }
      function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen) {
          return Pos(pos.line, linelen);
        } else if (ch < 0) {
          return Pos(pos.line, 0);
        } else {
          return pos;
        }
      }
      function clipPosArray(doc2, array) {
        var out = [];
        for (var i2 = 0; i2 < array.length; i2++) {
          out[i2] = clipPos(doc2, array[i2]);
        }
        return out;
      }
      var SavedContext = function(state, lookAhead) {
        this.state = state;
        this.lookAhead = lookAhead;
      };
      var Context = function(doc2, state, line, lookAhead) {
        this.state = state;
        this.doc = doc2;
        this.line = line;
        this.maxLookAhead = lookAhead || 0;
        this.baseTokens = null;
        this.baseTokenPos = 1;
      };
      Context.prototype.lookAhead = function(n) {
        var line = this.doc.getLine(this.line + n);
        if (line != null && n > this.maxLookAhead) {
          this.maxLookAhead = n;
        }
        return line;
      };
      Context.prototype.baseToken = function(n) {
        if (!this.baseTokens) {
          return null;
        }
        while (this.baseTokens[this.baseTokenPos] <= n) {
          this.baseTokenPos += 2;
        }
        var type = this.baseTokens[this.baseTokenPos + 1];
        return {
          type: type && type.replace(/( |^)overlay .*/, ""),
          size: this.baseTokens[this.baseTokenPos] - n
        };
      };
      Context.prototype.nextLine = function() {
        this.line++;
        if (this.maxLookAhead > 0) {
          this.maxLookAhead--;
        }
      };
      Context.fromSaved = function(doc2, saved, line) {
        if (saved instanceof SavedContext) {
          return new Context(doc2, copyState(doc2.mode, saved.state), line, saved.lookAhead);
        } else {
          return new Context(doc2, copyState(doc2.mode, saved), line);
        }
      };
      Context.prototype.save = function(copy2) {
        var state = copy2 !== false ? copyState(this.doc.mode, this.state) : this.state;
        return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
      };
      function highlightLine(cm, line, context, forceToEnd) {
        var st = [cm.state.modeGen], lineClasses = {};
        runMode(
          cm,
          line.text,
          cm.doc.mode,
          context,
          function(end, style) {
            return st.push(end, style);
          },
          lineClasses,
          forceToEnd
        );
        var state = context.state;
        var loop = function(o2) {
          context.baseTokens = st;
          var overlay = cm.state.overlays[o2], i2 = 1, at = 0;
          context.state = true;
          runMode(cm, line.text, overlay.mode, context, function(end, style) {
            var start = i2;
            while (at < end) {
              var i_end = st[i2];
              if (i_end > end) {
                st.splice(i2, 1, end, st[i2 + 1], i_end);
              }
              i2 += 2;
              at = Math.min(end, i_end);
            }
            if (!style) {
              return;
            }
            if (overlay.opaque) {
              st.splice(start, i2 - start, end, "overlay " + style);
              i2 = start + 2;
            } else {
              for (; start < i2; start += 2) {
                var cur = st[start + 1];
                st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
              }
            }
          }, lineClasses);
          context.state = state;
          context.baseTokens = null;
          context.baseTokenPos = 1;
        };
        for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);
        return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
      }
      function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
          var context = getContextBefore(cm, lineNo(line));
          var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
          var result = highlightLine(cm, line, context);
          if (resetState) {
            context.state = resetState;
          }
          line.stateAfter = context.save(!resetState);
          line.styles = result.styles;
          if (result.classes) {
            line.styleClasses = result.classes;
          } else if (line.styleClasses) {
            line.styleClasses = null;
          }
          if (updateFrontier === cm.doc.highlightFrontier) {
            cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
          }
        }
        return line.styles;
      }
      function getContextBefore(cm, n, precise) {
        var doc2 = cm.doc, display = cm.display;
        if (!doc2.mode.startState) {
          return new Context(doc2, true, n);
        }
        var start = findStartLine(cm, n, precise);
        var saved = start > doc2.first && getLine(doc2, start - 1).stateAfter;
        var context = saved ? Context.fromSaved(doc2, saved, start) : new Context(doc2, startState(doc2.mode), start);
        doc2.iter(start, n, function(line) {
          processLine(cm, line.text, context);
          var pos = context.line;
          line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
          context.nextLine();
        });
        if (precise) {
          doc2.modeFrontier = context.line;
        }
        return context;
      }
      function processLine(cm, text, context, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize, context);
        stream.start = stream.pos = startAt || 0;
        if (text == "") {
          callBlankLine(mode, context.state);
        }
        while (!stream.eol()) {
          readToken(mode, stream, context.state);
          stream.start = stream.pos;
        }
      }
      function callBlankLine(mode, state) {
        if (mode.blankLine) {
          return mode.blankLine(state);
        }
        if (!mode.innerMode) {
          return;
        }
        var inner = innerMode(mode, state);
        if (inner.mode.blankLine) {
          return inner.mode.blankLine(inner.state);
        }
      }
      function readToken(mode, stream, state, inner) {
        for (var i2 = 0; i2 < 10; i2++) {
          if (inner) {
            inner[0] = innerMode(mode, state).mode;
          }
          var style = mode.token(stream, state);
          if (stream.pos > stream.start) {
            return style;
          }
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.");
      }
      var Token = function(stream, type, state) {
        this.start = stream.start;
        this.end = stream.pos;
        this.string = stream.current();
        this.type = type || null;
        this.state = state;
      };
      function takeToken(cm, pos, precise, asArray) {
        var doc2 = cm.doc, mode = doc2.mode, style;
        pos = clipPos(doc2, pos);
        var line = getLine(doc2, pos.line), context = getContextBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
        if (asArray) {
          tokens = [];
        }
        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
          stream.start = stream.pos;
          style = readToken(mode, stream, context.state);
          if (asArray) {
            tokens.push(new Token(stream, style, copyState(doc2.mode, context.state)));
          }
        }
        return asArray ? tokens : new Token(stream, style, context.state);
      }
      function extractLineClasses(type, output) {
        if (type) {
          for (; ; ) {
            var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!lineClass) {
              break;
            }
            type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
            var prop2 = lineClass[1] ? "bgClass" : "textClass";
            if (output[prop2] == null) {
              output[prop2] = lineClass[2];
            } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
              output[prop2] += " " + lineClass[2];
            }
          }
        }
        return type;
      }
      function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null) {
          flattenSpans = cm.options.flattenSpans;
        }
        var curStart = 0, curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize, context), style;
        var inner = cm.options.addModeClass && [null];
        if (text == "") {
          extractLineClasses(callBlankLine(mode, context.state), lineClasses);
        }
        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;
            if (forceToEnd) {
              processLine(cm, text, context, stream.pos);
            }
            stream.pos = text.length;
            style = null;
          } else {
            style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
          }
          if (inner) {
            var mName = inner[0].name;
            if (mName) {
              style = "m-" + (style ? mName + " " + style : mName);
            }
          }
          if (!flattenSpans || curStyle != style) {
            while (curStart < stream.start) {
              curStart = Math.min(stream.start, curStart + 5e3);
              f(curStart, curStyle);
            }
            curStyle = style;
          }
          stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
          var pos = Math.min(stream.pos, curStart + 5e3);
          f(pos, curStyle);
          curStart = pos;
        }
      }
      function findStartLine(cm, n, precise) {
        var minindent, minline, doc2 = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
        for (var search = n; search > lim; --search) {
          if (search <= doc2.first) {
            return doc2.first;
          }
          var line = getLine(doc2, search - 1), after = line.stateAfter;
          if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc2.modeFrontier)) {
            return search;
          }
          var indented = countColumn(line.text, null, cm.options.tabSize);
          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }
        return minline;
      }
      function retreatFrontier(doc2, n) {
        doc2.modeFrontier = Math.min(doc2.modeFrontier, n);
        if (doc2.highlightFrontier < n - 10) {
          return;
        }
        var start = doc2.first;
        for (var line = n - 1; line > start; line--) {
          var saved = getLine(doc2, line).stateAfter;
          if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
            start = line + 1;
            break;
          }
        }
        doc2.highlightFrontier = Math.min(doc2.highlightFrontier, start);
      }
      var sawReadOnlySpans = false, sawCollapsedSpans = false;
      function seeReadOnlySpans() {
        sawReadOnlySpans = true;
      }
      function seeCollapsedSpans() {
        sawCollapsedSpans = true;
      }
      function MarkedSpan(marker, from2, to) {
        this.marker = marker;
        this.from = from2;
        this.to = to;
      }
      function getMarkedSpanFor(spans, marker) {
        if (spans) {
          for (var i2 = 0; i2 < spans.length; ++i2) {
            var span = spans[i2];
            if (span.marker == marker) {
              return span;
            }
          }
        }
      }
      function removeMarkedSpan(spans, span) {
        var r;
        for (var i2 = 0; i2 < spans.length; ++i2) {
          if (spans[i2] != span) {
            (r || (r = [])).push(spans[i2]);
          }
        }
        return r;
      }
      function addMarkedSpan(line, span, op) {
        var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));
        if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
          line.markedSpans.push(span);
        } else {
          line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
          if (inThisOp) {
            inThisOp.add(line.markedSpans);
          }
        }
        span.marker.attachLine(line);
      }
      function markedSpansBefore(old, startCh, isInsert) {
        var nw;
        if (old) {
          for (var i2 = 0; i2 < old.length; ++i2) {
            var span = old[i2], marker = span.marker;
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
            if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
            }
          }
        }
        return nw;
      }
      function markedSpansAfter(old, endCh, isInsert) {
        var nw;
        if (old) {
          for (var i2 = 0; i2 < old.length; ++i2) {
            var span = old[i2], marker = span.marker;
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
            if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
              (nw || (nw = [])).push(new MarkedSpan(
                marker,
                startsBefore ? null : span.from - endCh,
                span.to == null ? null : span.to - endCh
              ));
            }
          }
        }
        return nw;
      }
      function stretchSpansOverChange(doc2, change) {
        if (change.full) {
          return null;
        }
        var oldFirst = isLine(doc2, change.from.line) && getLine(doc2, change.from.line).markedSpans;
        var oldLast = isLine(doc2, change.to.line) && getLine(doc2, change.to.line).markedSpans;
        if (!oldFirst && !oldLast) {
          return null;
        }
        var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);
        var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
          for (var i2 = 0; i2 < first.length; ++i2) {
            var span = first[i2];
            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);
              if (!found) {
                span.to = startCh;
              } else if (sameLine) {
                span.to = found.to == null ? null : found.to + offset;
              }
            }
          }
        }
        if (last) {
          for (var i$12 = 0; i$12 < last.length; ++i$12) {
            var span$1 = last[i$12];
            if (span$1.to != null) {
              span$1.to += offset;
            }
            if (span$1.from == null) {
              var found$1 = getMarkedSpanFor(first, span$1.marker);
              if (!found$1) {
                span$1.from = offset;
                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            } else {
              span$1.from += offset;
              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          }
        }
        if (first) {
          first = clearEmptySpans(first);
        }
        if (last && last != first) {
          last = clearEmptySpans(last);
        }
        var newMarkers = [first];
        if (!sameLine) {
          var gap = change.text.length - 2, gapMarkers;
          if (gap > 0 && first) {
            for (var i$22 = 0; i$22 < first.length; ++i$22) {
              if (first[i$22].to == null) {
                (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
              }
            }
          }
          for (var i$3 = 0; i$3 < gap; ++i$3) {
            newMarkers.push(gapMarkers);
          }
          newMarkers.push(last);
        }
        return newMarkers;
      }
      function clearEmptySpans(spans) {
        for (var i2 = 0; i2 < spans.length; ++i2) {
          var span = spans[i2];
          if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
            spans.splice(i2--, 1);
          }
        }
        if (!spans.length) {
          return null;
        }
        return spans;
      }
      function removeReadOnlyRanges(doc2, from2, to) {
        var markers = null;
        doc2.iter(from2.line, to.line + 1, function(line) {
          if (line.markedSpans) {
            for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
              var mark = line.markedSpans[i3].marker;
              if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
                (markers || (markers = [])).push(mark);
              }
            }
          }
        });
        if (!markers) {
          return null;
        }
        var parts = [{ from: from2, to }];
        for (var i2 = 0; i2 < markers.length; ++i2) {
          var mk = markers[i2], m = mk.find(0);
          for (var j = 0; j < parts.length; ++j) {
            var p = parts[j];
            if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
              continue;
            }
            var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
            if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
              newParts.push({ from: p.from, to: m.from });
            }
            if (dto > 0 || !mk.inclusiveRight && !dto) {
              newParts.push({ from: m.to, to: p.to });
            }
            parts.splice.apply(parts, newParts);
            j += newParts.length - 3;
          }
        }
        return parts;
      }
      function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans) {
          return;
        }
        for (var i2 = 0; i2 < spans.length; ++i2) {
          spans[i2].marker.detachLine(line);
        }
        line.markedSpans = null;
      }
      function attachMarkedSpans(line, spans) {
        if (!spans) {
          return;
        }
        for (var i2 = 0; i2 < spans.length; ++i2) {
          spans[i2].marker.attachLine(line);
        }
        line.markedSpans = spans;
      }
      function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
      }
      function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
      }
      function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (lenDiff != 0) {
          return lenDiff;
        }
        var aPos = a.find(), bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp) {
          return -fromCmp;
        }
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        if (toCmp) {
          return toCmp;
        }
        return b.id - a.id;
      }
      function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps) {
          for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
            sp = sps[i2];
            if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }
        return found;
      }
      function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
      }
      function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
      }
      function collapsedSpanAround(line, ch) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps) {
          for (var i2 = 0; i2 < sps.length; ++i2) {
            var sp = sps[i2];
            if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }
        return found;
      }
      function conflictingCollapsedRange(doc2, lineNo2, from2, to, marker) {
        var line = getLine(doc2, lineNo2);
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) {
          for (var i2 = 0; i2 < sps.length; ++i2) {
            var sp = sps[i2];
            if (!sp.marker.collapsed) {
              continue;
            }
            var found = sp.marker.find(0);
            var fromCmp = cmp(found.from, from2) || extraLeft(sp.marker) - extraLeft(marker);
            var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
            if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
              continue;
            }
            if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from2) >= 0 : cmp(found.to, from2) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
              return true;
            }
          }
        }
      }
      function visualLine(line) {
        var merged;
        while (merged = collapsedSpanAtStart(line)) {
          line = merged.find(-1, true).line;
        }
        return line;
      }
      function visualLineEnd(line) {
        var merged;
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }
        return line;
      }
      function visualLineContinued(line) {
        var merged, lines;
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          (lines || (lines = [])).push(line);
        }
        return lines;
      }
      function visualLineNo(doc2, lineN) {
        var line = getLine(doc2, lineN), vis = visualLine(line);
        if (line == vis) {
          return lineN;
        }
        return lineNo(vis);
      }
      function visualLineEndNo(doc2, lineN) {
        if (lineN > doc2.lastLine()) {
          return lineN;
        }
        var line = getLine(doc2, lineN), merged;
        if (!lineIsHidden(doc2, line)) {
          return lineN;
        }
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }
        return lineNo(line) + 1;
      }
      function lineIsHidden(doc2, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) {
          for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
            sp = sps[i2];
            if (!sp.marker.collapsed) {
              continue;
            }
            if (sp.from == null) {
              return true;
            }
            if (sp.marker.widgetNode) {
              continue;
            }
            if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc2, line, sp)) {
              return true;
            }
          }
        }
      }
      function lineIsHiddenInner(doc2, line, span) {
        if (span.to == null) {
          var end = span.marker.find(1, true);
          return lineIsHiddenInner(doc2, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length) {
          return true;
        }
        for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
          sp = line.markedSpans[i2];
          if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc2, line, sp)) {
            return true;
          }
        }
      }
      function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0, chunk = lineObj.parent;
        for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
          var line = chunk.lines[i2];
          if (line == lineObj) {
            break;
          } else {
            h += line.height;
          }
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
          for (var i$12 = 0; i$12 < p.children.length; ++i$12) {
            var cur = p.children[i$12];
            if (cur == chunk) {
              break;
            } else {
              h += cur.height;
            }
          }
        }
        return h;
      }
      function lineLength(line) {
        if (line.height == 0) {
          return 0;
        }
        var len2 = line.text.length, merged, cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find(0, true);
          cur = found.from.line;
          len2 += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
          var found$1 = merged.find(0, true);
          len2 -= cur.text.length - found$1.from.ch;
          cur = found$1.to.line;
          len2 += cur.text.length - found$1.to.ch;
        }
        return len2;
      }
      function findMaxLine(cm) {
        var d = cm.display, doc2 = cm.doc;
        d.maxLine = getLine(doc2, doc2.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc2.iter(function(line) {
          var len2 = lineLength(line);
          if (len2 > d.maxLineLength) {
            d.maxLineLength = len2;
            d.maxLine = line;
          }
        });
      }
      var Line = function(text, markedSpans, estimateHeight2) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight2 ? estimateHeight2(this) : 1;
      };
      Line.prototype.lineNo = function() {
        return lineNo(this);
      };
      eventMixin(Line);
      function updateLine(line, text, markedSpans, estimateHeight2) {
        line.text = text;
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        if (line.styles) {
          line.styles = null;
        }
        if (line.order != null) {
          line.order = null;
        }
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
        if (estHeight != line.height) {
          updateLineHeight(line, estHeight);
        }
      }
      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      }
      var styleToClassCache = {}, styleToClassCacheWithMode = {};
      function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style)) {
          return null;
        }
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
      }
      function buildLineContent(cm, lineView) {
        var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
        var builder = {
          pre: eltP("pre", [content], "CodeMirror-line"),
          content,
          col: 0,
          pos: 0,
          cm,
          trailingSpace: false,
          splitSpaces: cm.getOption("lineWrapping")
        };
        lineView.measure = {};
        for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
          var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;
          builder.pos = 0;
          builder.addToken = buildToken;
          if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
            builder.addToken = buildTokenBadBidi(builder.addToken, order);
          }
          builder.map = [];
          var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
          insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
          if (line.styleClasses) {
            if (line.styleClasses.bgClass) {
              builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
            }
            if (line.styleClasses.textClass) {
              builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
            }
          }
          if (builder.map.length == 0) {
            builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
          }
          if (i2 == 0) {
            lineView.measure.map = builder.map;
            lineView.measure.cache = {};
          } else {
            (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
            (lineView.measure.caches || (lineView.measure.caches = [])).push({});
          }
        }
        if (webkit) {
          var last = builder.content.lastChild;
          if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
            builder.content.className = "cm-tab-wrap-hack";
          }
        }
        signal(cm, "renderLine", cm, lineView.line, builder.pre);
        if (builder.pre.className) {
          builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
        }
        return builder;
      }
      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "•", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        token.setAttribute("aria-label", token.title);
        return token;
      }
      function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
        if (!text) {
          return;
        }
        var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
        var special = builder.cm.state.specialChars, mustWrap = false;
        var content;
        if (!special.test(text)) {
          builder.col += text.length;
          content = document.createTextNode(displayText);
          builder.map.push(builder.pos, builder.pos + text.length, content);
          if (ie && ie_version < 9) {
            mustWrap = true;
          }
          builder.pos += text.length;
        } else {
          content = document.createDocumentFragment();
          var pos = 0;
          while (true) {
            special.lastIndex = pos;
            var m = special.exec(text);
            var skipped = m ? m.index - pos : text.length - pos;
            if (skipped) {
              var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt]));
              } else {
                content.appendChild(txt);
              }
              builder.map.push(builder.pos, builder.pos + skipped, txt);
              builder.col += skipped;
              builder.pos += skipped;
            }
            if (!m) {
              break;
            }
            pos += skipped + 1;
            var txt$1 = void 0;
            if (m[0] == "	") {
              var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
              txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              txt$1.setAttribute("role", "presentation");
              txt$1.setAttribute("cm-text", "	");
              builder.col += tabWidth;
            } else if (m[0] == "\r" || m[0] == "\n") {
              txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "␍" : "␤", "cm-invalidchar"));
              txt$1.setAttribute("cm-text", m[0]);
              builder.col += 1;
            } else {
              txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
              txt$1.setAttribute("cm-text", m[0]);
              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt$1]));
              } else {
                content.appendChild(txt$1);
              }
              builder.col += 1;
            }
            builder.map.push(builder.pos, builder.pos + 1, txt$1);
            builder.pos++;
          }
        }
        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
        if (style || startStyle || endStyle || mustWrap || css || attributes) {
          var fullStyle = style || "";
          if (startStyle) {
            fullStyle += startStyle;
          }
          if (endStyle) {
            fullStyle += endStyle;
          }
          var token = elt("span", [content], fullStyle, css);
          if (attributes) {
            for (var attr in attributes) {
              if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                token.setAttribute(attr, attributes[attr]);
              }
            }
          }
          return builder.content.appendChild(token);
        }
        builder.content.appendChild(content);
      }
      function splitSpaces(text, trailingBefore) {
        if (text.length > 1 && !/  /.test(text)) {
          return text;
        }
        var spaceBefore = trailingBefore, result = "";
        for (var i2 = 0; i2 < text.length; i2++) {
          var ch = text.charAt(i2);
          if (ch == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32)) {
            ch = " ";
          }
          result += ch;
          spaceBefore = ch == " ";
        }
        return result;
      }
      function buildTokenBadBidi(inner, order) {
        return function(builder, text, style, startStyle, endStyle, css, attributes) {
          style = style ? style + " cm-force-border" : "cm-force-border";
          var start = builder.pos, end = start + text.length;
          for (; ; ) {
            var part = void 0;
            for (var i2 = 0; i2 < order.length; i2++) {
              part = order[i2];
              if (part.to > start && part.from <= start) {
                break;
              }
            }
            if (part.to >= end) {
              return inner(builder, text, style, startStyle, endStyle, css, attributes);
            }
            inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
            startStyle = null;
            text = text.slice(part.to - start);
            start = part.to;
          }
        };
      }
      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        if (widget) {
          builder.map.push(builder.pos, builder.pos + size, widget);
        }
        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
          if (!widget) {
            widget = builder.content.appendChild(document.createElement("span"));
          }
          widget.setAttribute("cm-marker", marker.id);
        }
        if (widget) {
          builder.cm.display.input.setUneditable(widget);
          builder.content.appendChild(widget);
        }
        builder.pos += size;
        builder.trailingSpace = false;
      }
      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans, allText = line.text, at = 0;
        if (!spans) {
          for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {
            builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle(styles[i$12 + 1], builder.cm.options));
          }
          return;
        }
        var len2 = allText.length, pos = 0, i2 = 1, text = "", style, css;
        var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
        for (; ; ) {
          if (nextChange == pos) {
            spanStyle = spanEndStyle = spanStartStyle = css = "";
            attributes = null;
            collapsed = null;
            nextChange = Infinity;
            var foundBookmarks = [], endStyles = void 0;
            for (var j = 0; j < spans.length; ++j) {
              var sp = spans[j], m = sp.marker;
              if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                foundBookmarks.push(m);
              } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                  nextChange = sp.to;
                  spanEndStyle = "";
                }
                if (m.className) {
                  spanStyle += " " + m.className;
                }
                if (m.css) {
                  css = (css ? css + ";" : "") + m.css;
                }
                if (m.startStyle && sp.from == pos) {
                  spanStartStyle += " " + m.startStyle;
                }
                if (m.endStyle && sp.to == nextChange) {
                  (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
                }
                if (m.title) {
                  (attributes || (attributes = {})).title = m.title;
                }
                if (m.attributes) {
                  for (var attr in m.attributes) {
                    (attributes || (attributes = {}))[attr] = m.attributes[attr];
                  }
                }
                if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
                  collapsed = sp;
                }
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
            }
            if (endStyles) {
              for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                if (endStyles[j$1 + 1] == nextChange) {
                  spanEndStyle += " " + endStyles[j$1];
                }
              }
            }
            if (!collapsed || collapsed.from == pos) {
              for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
              }
            }
            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(
                builder,
                (collapsed.to == null ? len2 + 1 : collapsed.to) - pos,
                collapsed.marker,
                collapsed.from == null
              );
              if (collapsed.to == null) {
                return;
              }
              if (collapsed.to == pos) {
                collapsed = false;
              }
            }
          }
          if (pos >= len2) {
            break;
          }
          var upto = Math.min(len2, nextChange);
          while (true) {
            if (text) {
              var end = pos + text.length;
              if (!collapsed) {
                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                builder.addToken(
                  builder,
                  tokenText,
                  style ? style + spanStyle : spanStyle,
                  spanStartStyle,
                  pos + tokenText.length == nextChange ? spanEndStyle : "",
                  css,
                  attributes
                );
              }
              if (end >= upto) {
                text = text.slice(upto - pos);
                pos = upto;
                break;
              }
              pos = end;
              spanStartStyle = "";
            }
            text = allText.slice(at, at = styles[i2++]);
            style = interpretTokenStyle(styles[i2++], builder.cm.options);
          }
        }
      }
      function LineView(doc2, line, lineN) {
        this.line = line;
        this.rest = visualLineContinued(line);
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc2, line);
      }
      function buildViewArray(cm, from2, to) {
        var array = [], nextPos;
        for (var pos = from2; pos < to; pos = nextPos) {
          var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
          nextPos = pos + view.size;
          array.push(view);
        }
        return array;
      }
      var operationGroup = null;
      function pushOperation(op) {
        if (operationGroup) {
          operationGroup.ops.push(op);
        } else {
          op.ownsGroup = operationGroup = {
            ops: [op],
            delayedCallbacks: []
          };
        }
      }
      function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks, i2 = 0;
        do {
          for (; i2 < callbacks.length; i2++) {
            callbacks[i2].call(null);
          }
          for (var j = 0; j < group.ops.length; j++) {
            var op = group.ops[j];
            if (op.cursorActivityHandlers) {
              while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
              }
            }
          }
        } while (i2 < callbacks.length);
      }
      function finishOperation(op, endCb) {
        var group = op.ownsGroup;
        if (!group) {
          return;
        }
        try {
          fireCallbacksForOps(group);
        } finally {
          operationGroup = null;
          endCb(group);
        }
      }
      var orphanDelayedCallbacks = null;
      function signalLater(emitter, type) {
        var arr = getHandlers(emitter, type);
        if (!arr.length) {
          return;
        }
        var args = Array.prototype.slice.call(arguments, 2), list;
        if (operationGroup) {
          list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
          list = orphanDelayedCallbacks;
        } else {
          list = orphanDelayedCallbacks = [];
          setTimeout(fireOrphanDelayed, 0);
        }
        var loop = function(i3) {
          list.push(function() {
            return arr[i3].apply(null, args);
          });
        };
        for (var i2 = 0; i2 < arr.length; ++i2)
          loop(i2);
      }
      function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i2 = 0; i2 < delayed.length; ++i2) {
          delayed[i2]();
        }
      }
      function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
          var type = lineView.changes[j];
          if (type == "text") {
            updateLineText(cm, lineView);
          } else if (type == "gutter") {
            updateLineGutter(cm, lineView, lineN, dims);
          } else if (type == "class") {
            updateLineClasses(cm, lineView);
          } else if (type == "widget") {
            updateLineWidgets(cm, lineView, dims);
          }
        }
        lineView.changes = null;
      }
      function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
          lineView.node = elt("div", null, null, "position: relative");
          if (lineView.text.parentNode) {
            lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
          }
          lineView.node.appendChild(lineView.text);
          if (ie && ie_version < 8) {
            lineView.node.style.zIndex = 2;
          }
        }
        return lineView.node;
      }
      function updateLineBackground(cm, lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls) {
          cls += " CodeMirror-linebackground";
        }
        if (lineView.background) {
          if (cls) {
            lineView.background.className = cls;
          } else {
            lineView.background.parentNode.removeChild(lineView.background);
            lineView.background = null;
          }
        } else if (cls) {
          var wrap = ensureLineWrapped(lineView);
          lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
          cm.display.input.setUneditable(lineView.background);
        }
      }
      function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
          cm.display.externalMeasured = null;
          lineView.measure = ext.measure;
          return ext.built;
        }
        return buildLineContent(cm, lineView);
      }
      function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node) {
          lineView.node = built.pre;
        }
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
          lineView.bgClass = built.bgClass;
          lineView.textClass = built.textClass;
          updateLineClasses(cm, lineView);
        } else if (cls) {
          lineView.text.className = cls;
        }
      }
      function updateLineClasses(cm, lineView) {
        updateLineBackground(cm, lineView);
        if (lineView.line.wrapClass) {
          ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        } else if (lineView.node != lineView.text) {
          lineView.node.className = "";
        }
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
      }
      function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
          lineView.node.removeChild(lineView.gutter);
          lineView.gutter = null;
        }
        if (lineView.gutterBackground) {
          lineView.node.removeChild(lineView.gutterBackground);
          lineView.gutterBackground = null;
        }
        if (lineView.line.gutterClass) {
          var wrap = ensureLineWrapped(lineView);
          lineView.gutterBackground = elt(
            "div",
            null,
            "CodeMirror-gutter-background " + lineView.line.gutterClass,
            "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"
          );
          cm.display.input.setUneditable(lineView.gutterBackground);
          wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
          var wrap$1 = ensureLineWrapped(lineView);
          var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
          gutterWrap.setAttribute("aria-hidden", "true");
          cm.display.input.setUneditable(gutterWrap);
          wrap$1.insertBefore(gutterWrap, lineView.text);
          if (lineView.line.gutterClass) {
            gutterWrap.className += " " + lineView.line.gutterClass;
          }
          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
            lineView.lineNumber = gutterWrap.appendChild(
              elt(
                "div",
                lineNumberFor(cm.options, lineN),
                "CodeMirror-linenumber CodeMirror-gutter-elt",
                "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"
              )
            );
          }
          if (markers) {
            for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
              var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
              if (found) {
                gutterWrap.appendChild(elt(
                  "div",
                  [found],
                  "CodeMirror-gutter-elt",
                  "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"
                ));
              }
            }
          }
        }
      }
      function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable) {
          lineView.alignable = null;
        }
        var isWidget = classTest("CodeMirror-linewidget");
        for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
          next = node.nextSibling;
          if (isWidget.test(node.className)) {
            lineView.node.removeChild(node);
          }
        }
        insertLineWidgets(cm, lineView, dims);
      }
      function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass) {
          lineView.bgClass = built.bgClass;
        }
        if (built.textClass) {
          lineView.textClass = built.textClass;
        }
        updateLineClasses(cm, lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
      }
      function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
        if (lineView.rest) {
          for (var i2 = 0; i2 < lineView.rest.length; i2++) {
            insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
          }
        }
      }
      function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets) {
          return;
        }
        var wrap = ensureLineWrapped(lineView);
        for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
          var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
          if (!widget.handleMouseEvents) {
            node.setAttribute("cm-ignore-events", "true");
          }
          positionLineWidget(widget, node, lineView, dims);
          cm.display.input.setUneditable(node);
          if (allowAbove && widget.above) {
            wrap.insertBefore(node, lineView.gutter || lineView.text);
          } else {
            wrap.appendChild(node);
          }
          signalLater(widget, "redraw");
        }
      }
      function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
          (lineView.alignable || (lineView.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";
          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }
          node.style.width = width + "px";
        }
        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";
          if (!widget.noHScroll) {
            node.style.marginLeft = -dims.gutterTotalWidth + "px";
          }
        }
      }
      function widgetHeight(widget) {
        if (widget.height != null) {
          return widget.height;
        }
        var cm = widget.doc.cm;
        if (!cm) {
          return 0;
        }
        if (!contains(document.body, widget.node)) {
          var parentStyle = "position: relative;";
          if (widget.coverGutter) {
            parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
          }
          if (widget.noHScroll) {
            parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
          }
          removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
        }
        return widget.height = widget.node.parentNode.offsetHeight;
      }
      function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
          if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
            return true;
          }
        }
      }
      function paddingTop(display) {
        return display.lineSpace.offsetTop;
      }
      function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
      }
      function paddingH(display) {
        if (display.cachedPaddingH) {
          return display.cachedPaddingH;
        }
        var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
        if (!isNaN(data.left) && !isNaN(data.right)) {
          display.cachedPaddingH = data;
        }
        return data;
      }
      function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
      }
      function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
      }
      function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
      }
      function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
          var heights = lineView.measure.heights = [];
          if (wrapping) {
            lineView.measure.width = curWidth;
            var rects = lineView.text.firstChild.getClientRects();
            for (var i2 = 0; i2 < rects.length - 1; i2++) {
              var cur = rects[i2], next = rects[i2 + 1];
              if (Math.abs(cur.bottom - next.bottom) > 2) {
                heights.push((cur.bottom + next.top) / 2 - rect.top);
              }
            }
          }
          heights.push(rect.bottom - rect.top);
        }
      }
      function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line) {
          return { map: lineView.measure.map, cache: lineView.measure.cache };
        }
        if (lineView.rest) {
          for (var i2 = 0; i2 < lineView.rest.length; i2++) {
            if (lineView.rest[i2] == line) {
              return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
            }
          }
          for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
            if (lineNo(lineView.rest[i$12]) > lineN) {
              return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
            }
          }
        }
      }
      function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
      }
      function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
      }
      function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
          return cm.display.view[findViewIndex(cm, lineN)];
        }
        var ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
          return ext;
        }
      }
      function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);
        if (view && !view.text) {
          view = null;
        } else if (view && view.changes) {
          updateLineForChanges(cm, view, lineN, getDimensions(cm));
          cm.curOp.forceUpdate = true;
        }
        if (!view) {
          view = updateExternalMeasurement(cm, line);
        }
        var info = mapFromLineView(view, line, lineN);
        return {
          line,
          view,
          rect: null,
          map: info.map,
          cache: info.cache,
          before: info.before,
          hasHeights: false
        };
      }
      function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before) {
          ch = -1;
        }
        var key = ch + (bias || ""), found;
        if (prepared.cache.hasOwnProperty(key)) {
          found = prepared.cache[key];
        } else {
          if (!prepared.rect) {
            prepared.rect = prepared.view.text.getBoundingClientRect();
          }
          if (!prepared.hasHeights) {
            ensureLineHeights(cm, prepared.view, prepared.rect);
            prepared.hasHeights = true;
          }
          found = measureCharInner(cm, prepared, ch, bias);
          if (!found.bogus) {
            prepared.cache[key] = found;
          }
        }
        return {
          left: found.left,
          right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom
        };
      }
      var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
      function nodeAndOffsetInLineMap(map3, ch, bias) {
        var node, start, end, collapse, mStart, mEnd;
        for (var i2 = 0; i2 < map3.length; i2 += 3) {
          mStart = map3[i2];
          mEnd = map3[i2 + 1];
          if (ch < mStart) {
            start = 0;
            end = 1;
            collapse = "left";
          } else if (ch < mEnd) {
            start = ch - mStart;
            end = start + 1;
          } else if (i2 == map3.length - 3 || ch == mEnd && map3[i2 + 3] > ch) {
            end = mEnd - mStart;
            start = end - 1;
            if (ch >= mEnd) {
              collapse = "right";
            }
          }
          if (start != null) {
            node = map3[i2 + 2];
            if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
              collapse = bias;
            }
            if (bias == "left" && start == 0) {
              while (i2 && map3[i2 - 2] == map3[i2 - 3] && map3[i2 - 1].insertLeft) {
                node = map3[(i2 -= 3) + 2];
                collapse = "left";
              }
            }
            if (bias == "right" && start == mEnd - mStart) {
              while (i2 < map3.length - 3 && map3[i2 + 3] == map3[i2 + 4] && !map3[i2 + 5].insertLeft) {
                node = map3[(i2 += 3) + 2];
                collapse = "right";
              }
            }
            break;
          }
        }
        return { node, start, end, collapse, coverStart: mStart, coverEnd: mEnd };
      }
      function getUsefulRect(rects, bias) {
        var rect = nullRect;
        if (bias == "left") {
          for (var i2 = 0; i2 < rects.length; i2++) {
            if ((rect = rects[i2]).left != rect.right) {
              break;
            }
          }
        } else {
          for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
            if ((rect = rects[i$12]).left != rect.right) {
              break;
            }
          }
        }
        return rect;
      }
      function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
        var rect;
        if (node.nodeType == 3) {
          for (var i$12 = 0; i$12 < 4; i$12++) {
            while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
              --start;
            }
            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
              ++end;
            }
            if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
              rect = node.parentNode.getBoundingClientRect();
            } else {
              rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
            }
            if (rect.left || rect.right || start == 0) {
              break;
            }
            end = start;
            start = start - 1;
            collapse = "right";
          }
          if (ie && ie_version < 11) {
            rect = maybeUpdateRectForZooming(cm.display.measure, rect);
          }
        } else {
          if (start > 0) {
            collapse = bias = "right";
          }
          var rects;
          if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          } else {
            rect = node.getBoundingClientRect();
          }
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
          var rSpan = node.parentNode.getClientRects()[0];
          if (rSpan) {
            rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
          } else {
            rect = nullRect;
          }
        }
        var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        var i2 = 0;
        for (; i2 < heights.length - 1; i2++) {
          if (mid < heights[i2]) {
            break;
          }
        }
        var top = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
        var result = {
          left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
          right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
          top,
          bottom: bot
        };
        if (!rect.left && !rect.right) {
          result.bogus = true;
        }
        if (!cm.options.singleCursorHeightPerLine) {
          result.rtop = rtop;
          result.rbottom = rbot;
        }
        return result;
      }
      function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
          return rect;
        }
        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: rect.left * scaleX,
          right: rect.right * scaleX,
          top: rect.top * scaleY,
          bottom: rect.bottom * scaleY
        };
      }
      function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
          lineView.measure.cache = {};
          lineView.measure.heights = null;
          if (lineView.rest) {
            for (var i2 = 0; i2 < lineView.rest.length; i2++) {
              lineView.measure.caches[i2] = {};
            }
          }
        }
      }
      function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren2(cm.display.lineMeasure);
        for (var i2 = 0; i2 < cm.display.view.length; i2++) {
          clearLineMeasurementCacheFor(cm.display.view[i2]);
        }
      }
      function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping) {
          cm.display.maxLineChanged = true;
        }
        cm.display.lineNumChars = null;
      }
      function pageScrollX(doc2) {
        if (chrome && android) {
          return -(doc2.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc2.body).marginLeft));
        }
        return doc2.defaultView.pageXOffset || (doc2.documentElement || doc2.body).scrollLeft;
      }
      function pageScrollY(doc2) {
        if (chrome && android) {
          return -(doc2.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc2.body).marginTop));
        }
        return doc2.defaultView.pageYOffset || (doc2.documentElement || doc2.body).scrollTop;
      }
      function widgetTopHeight(lineObj) {
        var ref = visualLine(lineObj);
        var widgets = ref.widgets;
        var height = 0;
        if (widgets) {
          for (var i2 = 0; i2 < widgets.length; ++i2) {
            if (widgets[i2].above) {
              height += widgetHeight(widgets[i2]);
            }
          }
        }
        return height;
      }
      function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        if (!includeWidgets) {
          var height = widgetTopHeight(lineObj);
          rect.top += height;
          rect.bottom += height;
        }
        if (context == "line") {
          return rect;
        }
        if (!context) {
          context = "local";
        }
        var yOff = heightAtLine(lineObj);
        if (context == "local") {
          yOff += paddingTop(cm.display);
        } else {
          yOff -= cm.display.viewOffset;
        }
        if (context == "page" || context == "window") {
          var lOff = cm.display.lineSpace.getBoundingClientRect();
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY(doc(cm)));
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX(doc(cm)));
          rect.left += xOff;
          rect.right += xOff;
        }
        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
      }
      function fromCoordSystem(cm, coords, context) {
        if (context == "div") {
          return coords;
        }
        var left = coords.left, top = coords.top;
        if (context == "page") {
          left -= pageScrollX(doc(cm));
          top -= pageScrollY(doc(cm));
        } else if (context == "local" || !context) {
          var localBox = cm.display.sizer.getBoundingClientRect();
          left += localBox.left;
          top += localBox.top;
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
      }
      function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj) {
          lineObj = getLine(cm.doc, pos.line);
        }
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
      }
      function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }
        function get(ch2, right) {
          var m = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);
          if (right) {
            m.left = m.right;
          } else {
            m.right = m.left;
          }
          return intoCoordSystem(cm, lineObj, m, context);
        }
        var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
        if (ch >= lineObj.text.length) {
          ch = lineObj.text.length;
          sticky = "before";
        } else if (ch <= 0) {
          ch = 0;
          sticky = "after";
        }
        if (!order) {
          return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
        }
        function getBidi(ch2, partPos2, invert2) {
          var part = order[partPos2], right = part.level == 1;
          return get(invert2 ? ch2 - 1 : ch2, right != invert2);
        }
        var partPos = getBidiPartAt(order, ch, sticky);
        var other = bidiOther;
        var val = getBidi(ch, partPos, sticky == "before");
        if (other != null) {
          val.other = getBidi(ch, other, sticky != "before");
        }
        return val;
      }
      function estimateCoords(cm, pos) {
        var left = 0;
        pos = clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping) {
          left = charWidth(cm.display) * pos.ch;
        }
        var lineObj = getLine(cm.doc, pos.line);
        var top = heightAtLine(lineObj) + paddingTop(cm.display);
        return { left, right: left, top, bottom: top + lineObj.height };
      }
      function PosWithInfo(line, ch, sticky, outside, xRel) {
        var pos = Pos(line, ch, sticky);
        pos.xRel = xRel;
        if (outside) {
          pos.outside = outside;
        }
        return pos;
      }
      function coordsChar(cm, x, y) {
        var doc2 = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0) {
          return PosWithInfo(doc2.first, 0, null, -1, -1);
        }
        var lineN = lineAtHeight(doc2, y), last = doc2.first + doc2.size - 1;
        if (lineN > last) {
          return PosWithInfo(doc2.first + doc2.size - 1, getLine(doc2, last).text.length, null, 1, 1);
        }
        if (x < 0) {
          x = 0;
        }
        var lineObj = getLine(doc2, lineN);
        for (; ; ) {
          var found = coordsCharInner(cm, lineObj, lineN, x, y);
          var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
          if (!collapsed) {
            return found;
          }
          var rangeEnd = collapsed.find(1);
          if (rangeEnd.line == lineN) {
            return rangeEnd;
          }
          lineObj = getLine(doc2, lineN = rangeEnd.line);
        }
      }
      function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
        y -= widgetTopHeight(lineObj);
        var end = lineObj.text.length;
        var begin = findFirst(function(ch) {
          return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
        }, end, 0);
        end = findFirst(function(ch) {
          return measureCharPrepared(cm, preparedMeasure, ch).top > y;
        }, begin, end);
        return { begin, end };
      }
      function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }
        var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
      }
      function boxIsAfter(box2, x, y, left) {
        return box2.bottom <= y ? false : box2.top > y ? true : (left ? box2.left : box2.right) > x;
      }
      function coordsCharInner(cm, lineObj, lineNo2, x, y) {
        y -= heightAtLine(lineObj);
        var preparedMeasure = prepareMeasureForLine(cm, lineObj);
        var widgetHeight2 = widgetTopHeight(lineObj);
        var begin = 0, end = lineObj.text.length, ltr = true;
        var order = getOrder(lineObj, cm.doc.direction);
        if (order) {
          var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y);
          ltr = part.level != 1;
          begin = ltr ? part.from : part.to - 1;
          end = ltr ? part.to : part.from - 1;
        }
        var chAround = null, boxAround = null;
        var ch = findFirst(function(ch2) {
          var box2 = measureCharPrepared(cm, preparedMeasure, ch2);
          box2.top += widgetHeight2;
          box2.bottom += widgetHeight2;
          if (!boxIsAfter(box2, x, y, false)) {
            return false;
          }
          if (box2.top <= y && box2.left <= x) {
            chAround = ch2;
            boxAround = box2;
          }
          return true;
        }, begin, end);
        var baseX, sticky, outside = false;
        if (boxAround) {
          var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
          ch = chAround + (atStart ? 0 : 1);
          sticky = atStart ? "after" : "before";
          baseX = atLeft ? boxAround.left : boxAround.right;
        } else {
          if (!ltr && (ch == end || ch == begin)) {
            ch++;
          }
          sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
          var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
          baseX = coords.left;
          outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
        }
        ch = skipExtendingChars(lineObj.text, ch, 1);
        return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);
      }
      function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y) {
        var index2 = findFirst(function(i2) {
          var part2 = order[i2], ltr2 = part2.level != 1;
          return boxIsAfter(cursorCoords(
            cm,
            Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"),
            "line",
            lineObj,
            preparedMeasure
          ), x, y, true);
        }, 0, order.length - 1);
        var part = order[index2];
        if (index2 > 0) {
          var ltr = part.level != 1;
          var start = cursorCoords(
            cm,
            Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"),
            "line",
            lineObj,
            preparedMeasure
          );
          if (boxIsAfter(start, x, y, true) && start.top > y) {
            part = order[index2 - 1];
          }
        }
        return part;
      }
      function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
        var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
        var begin = ref.begin;
        var end = ref.end;
        if (/\s/.test(lineObj.text.charAt(end - 1))) {
          end--;
        }
        var part = null, closestDist = null;
        for (var i2 = 0; i2 < order.length; i2++) {
          var p = order[i2];
          if (p.from >= end || p.to <= begin) {
            continue;
          }
          var ltr = p.level != 1;
          var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
          var dist = endX < x ? x - endX + 1e9 : endX - x;
          if (!part || closestDist > dist) {
            part = p;
            closestDist = dist;
          }
        }
        if (!part) {
          part = order[order.length - 1];
        }
        if (part.from < begin) {
          part = { from: begin, to: part.to, level: part.level };
        }
        if (part.to > end) {
          part = { from: part.from, to: end, level: part.level };
        }
        return part;
      }
      var measureText;
      function textHeight(display) {
        if (display.cachedTextHeight != null) {
          return display.cachedTextHeight;
        }
        if (measureText == null) {
          measureText = elt("pre", null, "CodeMirror-line-like");
          for (var i2 = 0; i2 < 49; ++i2) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }
          measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3) {
          display.cachedTextHeight = height;
        }
        removeChildren2(display.measure);
        return height || 1;
      }
      function charWidth(display) {
        if (display.cachedCharWidth != null) {
          return display.cachedCharWidth;
        }
        var anchor = elt("span", "xxxxxxxxxx");
        var pre = elt("pre", [anchor], "CodeMirror-line-like");
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
        if (width > 2) {
          display.cachedCharWidth = width;
        }
        return width || 10;
      }
      function getDimensions(cm) {
        var d = cm.display, left = {}, width = {};
        var gutterLeft = d.gutters.clientLeft;
        for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
          var id = cm.display.gutterSpecs[i2].className;
          left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
          width[id] = n.clientWidth;
        }
        return {
          fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth
        };
      }
      function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
      }
      function estimateHeight(cm) {
        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function(line) {
          if (lineIsHidden(cm.doc, line)) {
            return 0;
          }
          var widgetsHeight = 0;
          if (line.widgets) {
            for (var i2 = 0; i2 < line.widgets.length; i2++) {
              if (line.widgets[i2].height) {
                widgetsHeight += line.widgets[i2].height;
              }
            }
          }
          if (wrapping) {
            return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
          } else {
            return widgetsHeight + th;
          }
        };
      }
      function estimateLineHeights(cm) {
        var doc2 = cm.doc, est = estimateHeight(cm);
        doc2.iter(function(line) {
          var estHeight = est(line);
          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        });
      }
      function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
          return null;
        }
        var x, y, space = display.lineSpace.getBoundingClientRect();
        try {
          x = e.clientX - space.left;
          y = e.clientY - space.top;
        } catch (e$1) {
          return null;
        }
        var coords = coordsChar(cm, x, y), line;
        if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
          var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
          coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
      }
      function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo) {
          return null;
        }
        n -= cm.display.viewFrom;
        if (n < 0) {
          return null;
        }
        var view = cm.display.view;
        for (var i2 = 0; i2 < view.length; i2++) {
          n -= view[i2].size;
          if (n < 0) {
            return i2;
          }
        }
      }
      function regChange(cm, from2, to, lendiff) {
        if (from2 == null) {
          from2 = cm.doc.first;
        }
        if (to == null) {
          to = cm.doc.first + cm.doc.size;
        }
        if (!lendiff) {
          lendiff = 0;
        }
        var display = cm.display;
        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from2)) {
          display.updateLineNumbers = from2;
        }
        cm.curOp.viewChanged = true;
        if (from2 >= display.viewTo) {
          if (sawCollapsedSpans && visualLineNo(cm.doc, from2) < display.viewTo) {
            resetView(cm);
          }
        } else if (to <= display.viewFrom) {
          if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
            resetView(cm);
          } else {
            display.viewFrom += lendiff;
            display.viewTo += lendiff;
          }
        } else if (from2 <= display.viewFrom && to >= display.viewTo) {
          resetView(cm);
        } else if (from2 <= display.viewFrom) {
          var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cut) {
            display.view = display.view.slice(cut.index);
            display.viewFrom = cut.lineN;
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        } else if (to >= display.viewTo) {
          var cut$1 = viewCuttingPoint(cm, from2, from2, -1);
          if (cut$1) {
            display.view = display.view.slice(0, cut$1.index);
            display.viewTo = cut$1.lineN;
          } else {
            resetView(cm);
          }
        } else {
          var cutTop = viewCuttingPoint(cm, from2, from2, -1);
          var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cutTop && cutBot) {
            display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        }
        var ext = display.externalMeasured;
        if (ext) {
          if (to < ext.lineN) {
            ext.lineN += lendiff;
          } else if (from2 < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
        }
      }
      function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        var display = cm.display, ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }
        if (line < display.viewFrom || line >= display.viewTo) {
          return;
        }
        var lineView = display.view[findViewIndex(cm, line)];
        if (lineView.node == null) {
          return;
        }
        var arr = lineView.changes || (lineView.changes = []);
        if (indexOf(arr, type) == -1) {
          arr.push(type);
        }
      }
      function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
      }
      function viewCuttingPoint(cm, oldN, newN, dir) {
        var index2 = findViewIndex(cm, oldN), diff, view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
          return { index: index2, lineN: newN };
        }
        var n = cm.display.viewFrom;
        for (var i2 = 0; i2 < index2; i2++) {
          n += view[i2].size;
        }
        if (n != oldN) {
          if (dir > 0) {
            if (index2 == view.length - 1) {
              return null;
            }
            diff = n + view[index2].size - oldN;
            index2++;
          } else {
            diff = n - oldN;
          }
          oldN += diff;
          newN += diff;
        }
        while (visualLineNo(cm.doc, newN) != newN) {
          if (index2 == (dir < 0 ? 0 : view.length - 1)) {
            return null;
          }
          newN += dir * view[index2 - (dir < 0 ? 1 : 0)].size;
          index2 += dir;
        }
        return { index: index2, lineN: newN };
      }
      function adjustView(cm, from2, to) {
        var display = cm.display, view = display.view;
        if (view.length == 0 || from2 >= display.viewTo || to <= display.viewFrom) {
          display.view = buildViewArray(cm, from2, to);
          display.viewFrom = from2;
        } else {
          if (display.viewFrom > from2) {
            display.view = buildViewArray(cm, from2, display.viewFrom).concat(display.view);
          } else if (display.viewFrom < from2) {
            display.view = display.view.slice(findViewIndex(cm, from2));
          }
          display.viewFrom = from2;
          if (display.viewTo < to) {
            display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
          } else if (display.viewTo > to) {
            display.view = display.view.slice(0, findViewIndex(cm, to));
          }
        }
        display.viewTo = to;
      }
      function countDirtyView(cm) {
        var view = cm.display.view, dirty = 0;
        for (var i2 = 0; i2 < view.length; i2++) {
          var lineView = view[i2];
          if (!lineView.hidden && (!lineView.node || lineView.changes)) {
            ++dirty;
          }
        }
        return dirty;
      }
      function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
      }
      function prepareSelection(cm, primary) {
        if (primary === void 0) primary = true;
        var doc2 = cm.doc, result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();
        var customCursor = cm.options.$customCursor;
        if (customCursor) {
          primary = true;
        }
        for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
          if (!primary && i2 == doc2.sel.primIndex) {
            continue;
          }
          var range2 = doc2.sel.ranges[i2];
          if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
            continue;
          }
          var collapsed = range2.empty();
          if (customCursor) {
            var head = customCursor(cm, range2);
            if (head) {
              drawSelectionCursor(cm, head, curFragment);
            }
          } else if (collapsed || cm.options.showCursorWhenSelecting) {
            drawSelectionCursor(cm, range2.head, curFragment);
          }
          if (!collapsed) {
            drawSelectionRange(cm, range2, selFragment);
          }
        }
        return result;
      }
      function drawSelectionCursor(cm, head, output) {
        var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
        var cursor = output.appendChild(elt("div", " ", "CodeMirror-cursor"));
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
        if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
          var charPos = charCoords(cm, head, "div", null, null);
          var width = charPos.right - charPos.left;
          cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
        }
        if (pos.other) {
          var otherCursor = output.appendChild(elt("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
          otherCursor.style.display = "";
          otherCursor.style.left = pos.other.left + "px";
          otherCursor.style.top = pos.other.top + "px";
          otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
        }
      }
      function cmpCoords(a, b) {
        return a.top - b.top || a.left - b.left;
      }
      function drawSelectionRange(cm, range2, output) {
        var display = cm.display, doc2 = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display), leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        var docLTR = doc2.direction == "ltr";
        function add2(left, top, width, bottom) {
          if (top < 0) {
            top = 0;
          }
          top = Math.round(top);
          bottom = Math.round(bottom);
          fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
        }
        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine(doc2, line);
          var lineLen = lineObj.text.length;
          var start, end;
          function coords(ch, bias) {
            return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
          }
          function wrapX(pos, dir, side) {
            var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
            var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
            var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
            return coords(ch, prop2)[prop2];
          }
          var order = getOrder(lineObj, doc2.direction);
          iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from2, to, dir, i2) {
            var ltr = dir == "ltr";
            var fromPos = coords(from2, ltr ? "left" : "right");
            var toPos = coords(to - 1, ltr ? "right" : "left");
            var openStart = fromArg == null && from2 == 0, openEnd = toArg == null && to == lineLen;
            var first = i2 == 0, last = !order || i2 == order.length - 1;
            if (toPos.top - fromPos.top <= 3) {
              var openLeft = (docLTR ? openStart : openEnd) && first;
              var openRight = (docLTR ? openEnd : openStart) && last;
              var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
              var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
              add2(left, fromPos.top, right - left, fromPos.bottom);
            } else {
              var topLeft, topRight, botLeft, botRight;
              if (ltr) {
                topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                topRight = docLTR ? rightSide : wrapX(from2, dir, "before");
                botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                botRight = docLTR && openEnd && last ? rightSide : toPos.right;
              } else {
                topLeft = !docLTR ? leftSide : wrapX(from2, dir, "before");
                topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
              }
              add2(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
              if (fromPos.bottom < toPos.top) {
                add2(leftSide, fromPos.bottom, null, toPos.top);
              }
              add2(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
            }
            if (!start || cmpCoords(fromPos, start) < 0) {
              start = fromPos;
            }
            if (cmpCoords(toPos, start) < 0) {
              start = toPos;
            }
            if (!end || cmpCoords(fromPos, end) < 0) {
              end = fromPos;
            }
            if (cmpCoords(toPos, end) < 0) {
              end = toPos;
            }
          });
          return { start, end };
        }
        var sFrom = range2.from(), sTo = range2.to();
        if (sFrom.line == sTo.line) {
          drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
          var fromLine = getLine(doc2, sFrom.line), toLine = getLine(doc2, sTo.line);
          var singleVLine = visualLine(fromLine) == visualLine(toLine);
          var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
          var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add2(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add2(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add2(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }
          if (leftEnd.bottom < rightStart.top) {
            add2(leftSide, leftEnd.bottom, null, rightStart.top);
          }
        }
        output.appendChild(fragment);
      }
      function restartBlink(cm) {
        if (!cm.state.focused) {
          return;
        }
        var display = cm.display;
        clearInterval(display.blinker);
        var on2 = true;
        display.cursorDiv.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0) {
          display.blinker = setInterval(function() {
            if (!cm.hasFocus()) {
              onBlur(cm);
            }
            display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
          }, cm.options.cursorBlinkRate);
        } else if (cm.options.cursorBlinkRate < 0) {
          display.cursorDiv.style.visibility = "hidden";
        }
      }
      function ensureFocus(cm) {
        if (!cm.hasFocus()) {
          cm.display.input.focus();
          if (!cm.state.focused) {
            onFocus(cm);
          }
        }
      }
      function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function() {
          if (cm.state.delayingBlurEvent) {
            cm.state.delayingBlurEvent = false;
            if (cm.state.focused) {
              onBlur(cm);
            }
          }
        }, 100);
      }
      function onFocus(cm, e) {
        if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
          cm.state.delayingBlurEvent = false;
        }
        if (cm.options.readOnly == "nocursor") {
          return;
        }
        if (!cm.state.focused) {
          signal(cm, "focus", cm, e);
          cm.state.focused = true;
          addClass(cm.display.wrapper, "CodeMirror-focused");
          if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
            cm.display.input.reset();
            if (webkit) {
              setTimeout(function() {
                return cm.display.input.reset(true);
              }, 20);
            }
          }
          cm.display.input.receivedFocus();
        }
        restartBlink(cm);
      }
      function onBlur(cm, e) {
        if (cm.state.delayingBlurEvent) {
          return;
        }
        if (cm.state.focused) {
          signal(cm, "blur", cm, e);
          cm.state.focused = false;
          rmClass(cm.display.wrapper, "CodeMirror-focused");
        }
        clearInterval(cm.display.blinker);
        setTimeout(function() {
          if (!cm.state.focused) {
            cm.display.shift = false;
          }
        }, 150);
      }
      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
        var oldHeight = display.lineDiv.getBoundingClientRect().top;
        var mustScroll = 0;
        for (var i2 = 0; i2 < display.view.length; i2++) {
          var cur = display.view[i2], wrapping = cm.options.lineWrapping;
          var height = void 0, width = 0;
          if (cur.hidden) {
            continue;
          }
          oldHeight += cur.line.height;
          if (ie && ie_version < 8) {
            var bot = cur.node.offsetTop + cur.node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box2 = cur.node.getBoundingClientRect();
            height = box2.bottom - box2.top;
            if (!wrapping && cur.text.firstChild) {
              width = cur.text.firstChild.getBoundingClientRect().right - box2.left - 1;
            }
          }
          var diff = cur.line.height - height;
          if (diff > 5e-3 || diff < -5e-3) {
            if (oldHeight < viewTop) {
              mustScroll -= diff;
            }
            updateLineHeight(cur.line, height);
            updateWidgetHeight(cur.line);
            if (cur.rest) {
              for (var j = 0; j < cur.rest.length; j++) {
                updateWidgetHeight(cur.rest[j]);
              }
            }
          }
          if (width > cm.display.sizerWidth) {
            var chWidth = Math.ceil(width / charWidth(cm.display));
            if (chWidth > cm.display.maxLineLength) {
              cm.display.maxLineLength = chWidth;
              cm.display.maxLine = cur.line;
              cm.display.maxLineChanged = true;
            }
          }
        }
        if (Math.abs(mustScroll) > 2) {
          display.scroller.scrollTop += mustScroll;
        }
      }
      function updateWidgetHeight(line) {
        if (line.widgets) {
          for (var i2 = 0; i2 < line.widgets.length; ++i2) {
            var w = line.widgets[i2], parent = w.node.parentNode;
            if (parent) {
              w.height = parent.offsetHeight;
            }
          }
        }
      }
      function visibleLines(display, doc2, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
        var from2 = lineAtHeight(doc2, top), to = lineAtHeight(doc2, bottom);
        if (viewport && viewport.ensure) {
          var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
          if (ensureFrom < from2) {
            from2 = ensureFrom;
            to = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureFrom)) + display.wrapper.clientHeight);
          } else if (Math.min(ensureTo, doc2.lastLine()) >= to) {
            from2 = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureTo)) - display.wrapper.clientHeight);
            to = ensureTo;
          }
        }
        return { from: from2, to: Math.max(to, from2 + 1) };
      }
      function maybeScrollWindow(cm, rect) {
        if (signalDOMEvent(cm, "scrollCursorIntoView")) {
          return;
        }
        var display = cm.display, box2 = display.sizer.getBoundingClientRect(), doScroll = null;
        var doc2 = display.wrapper.ownerDocument;
        if (rect.top + box2.top < 0) {
          doScroll = true;
        } else if (rect.bottom + box2.top > (doc2.defaultView.innerHeight || doc2.documentElement.clientHeight)) {
          doScroll = false;
        }
        if (doScroll != null && !phantom) {
          var scrollNode = elt("div", "​", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
          cm.display.lineSpace.appendChild(scrollNode);
          scrollNode.scrollIntoView(doScroll);
          cm.display.lineSpace.removeChild(scrollNode);
        }
      }
      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null) {
          margin = 0;
        }
        var rect;
        if (!cm.options.lineWrapping && pos == end) {
          end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
          pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
        }
        for (var limit = 0; limit < 5; limit++) {
          var changed = false;
          var coords = cursorCoords(cm, pos);
          var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
          rect = {
            left: Math.min(coords.left, endCoords.left),
            top: Math.min(coords.top, endCoords.top) - margin,
            right: Math.max(coords.left, endCoords.left),
            bottom: Math.max(coords.bottom, endCoords.bottom) + margin
          };
          var scrollPos = calculateScrollPos(cm, rect);
          var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);
            if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
              changed = true;
            }
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
              changed = true;
            }
          }
          if (!changed) {
            break;
          }
        }
        return rect;
      }
      function scrollIntoView(cm, rect) {
        var scrollPos = calculateScrollPos(cm, rect);
        if (scrollPos.scrollTop != null) {
          updateScrollTop(cm, scrollPos.scrollTop);
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
        }
      }
      function calculateScrollPos(cm, rect) {
        var display = cm.display, snapMargin = textHeight(cm.display);
        if (rect.top < 0) {
          rect.top = 0;
        }
        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen2 = displayHeight(cm), result = {};
        if (rect.bottom - rect.top > screen2) {
          rect.bottom = rect.top + screen2;
        }
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
        if (rect.top < screentop) {
          result.scrollTop = atTop ? 0 : rect.top;
        } else if (rect.bottom > screentop + screen2) {
          var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
          if (newTop != screentop) {
            result.scrollTop = newTop;
          }
        }
        var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
        var screenw = displayWidth(cm) - display.gutters.offsetWidth;
        var tooWide = rect.right - rect.left > screenw;
        if (tooWide) {
          rect.right = rect.left + screenw;
        }
        if (rect.left < 10) {
          result.scrollLeft = 0;
        } else if (rect.left < screenleft) {
          result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
        } else if (rect.right > screenw + screenleft - 3) {
          result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
        }
        return result;
      }
      function addToScrollTop(cm, top) {
        if (top == null) {
          return;
        }
        resolveScrollToPos(cm);
        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
      }
      function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor();
        cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
      }
      function scrollToCoords(cm, x, y) {
        if (x != null || y != null) {
          resolveScrollToPos(cm);
        }
        if (x != null) {
          cm.curOp.scrollLeft = x;
        }
        if (y != null) {
          cm.curOp.scrollTop = y;
        }
      }
      function scrollToRange(cm, range2) {
        resolveScrollToPos(cm);
        cm.curOp.scrollToPos = range2;
      }
      function resolveScrollToPos(cm) {
        var range2 = cm.curOp.scrollToPos;
        if (range2) {
          cm.curOp.scrollToPos = null;
          var from2 = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
          scrollToCoordsRange(cm, from2, to, range2.margin);
        }
      }
      function scrollToCoordsRange(cm, from2, to, margin) {
        var sPos = calculateScrollPos(cm, {
          left: Math.min(from2.left, to.left),
          top: Math.min(from2.top, to.top) - margin,
          right: Math.max(from2.right, to.right),
          bottom: Math.max(from2.bottom, to.bottom) + margin
        });
        scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
      }
      function updateScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2) {
          return;
        }
        if (!gecko) {
          updateDisplaySimple(cm, { top: val });
        }
        setScrollTop(cm, val, true);
        if (gecko) {
          updateDisplaySimple(cm);
        }
        startWorker(cm, 100);
      }
      function setScrollTop(cm, val, forceScroll) {
        val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
        if (cm.display.scroller.scrollTop == val && !forceScroll) {
          return;
        }
        cm.doc.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);
        if (cm.display.scroller.scrollTop != val) {
          cm.display.scroller.scrollTop = val;
        }
      }
      function setScrollLeft(cm, val, isScroller, forceScroll) {
        val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
        if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
          return;
        }
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val) {
          cm.display.scroller.scrollLeft = val;
        }
        cm.display.scrollbars.setScrollLeft(val);
      }
      function measureForScrollbars(cm) {
        var d = cm.display, gutterW = d.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
          clientHeight: d.scroller.clientHeight,
          viewHeight: d.wrapper.clientHeight,
          scrollWidth: d.scroller.scrollWidth,
          clientWidth: d.scroller.clientWidth,
          viewWidth: d.wrapper.clientWidth,
          barLeft: cm.options.fixedGutter ? gutterW : 0,
          docHeight: docH,
          scrollHeight: docH + scrollGap(cm) + d.barHeight,
          nativeBarWidth: d.nativeBarWidth,
          gutterWidth: gutterW
        };
      }
      var NativeScrollbars = function(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
        var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        vert.tabIndex = horiz.tabIndex = -1;
        place(vert);
        place(horiz);
        on(vert, "scroll", function() {
          if (vert.clientHeight) {
            scroll(vert.scrollTop, "vertical");
          }
        });
        on(horiz, "scroll", function() {
          if (horiz.clientWidth) {
            scroll(horiz.scrollLeft, "horizontal");
          }
        });
        this.checkedZeroWidth = false;
        if (ie && ie_version < 8) {
          this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
        }
      };
      NativeScrollbars.prototype.update = function(measure) {
        var needsH = measure.scrollWidth > measure.clientWidth + 1;
        var needsV = measure.scrollHeight > measure.clientHeight + 1;
        var sWidth = measure.nativeBarWidth;
        if (needsV) {
          this.vert.style.display = "block";
          this.vert.style.bottom = needsH ? sWidth + "px" : "0";
          var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
          this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
        } else {
          this.vert.scrollTop = 0;
          this.vert.style.display = "";
          this.vert.firstChild.style.height = "0";
        }
        if (needsH) {
          this.horiz.style.display = "block";
          this.horiz.style.right = needsV ? sWidth + "px" : "0";
          this.horiz.style.left = measure.barLeft + "px";
          var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
          this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
        } else {
          this.horiz.style.display = "";
          this.horiz.firstChild.style.width = "0";
        }
        if (!this.checkedZeroWidth && measure.clientHeight > 0) {
          if (sWidth == 0) {
            this.zeroWidthHack();
          }
          this.checkedZeroWidth = true;
        }
        return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
      };
      NativeScrollbars.prototype.setScrollLeft = function(pos) {
        if (this.horiz.scrollLeft != pos) {
          this.horiz.scrollLeft = pos;
        }
        if (this.disableHoriz) {
          this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
        }
      };
      NativeScrollbars.prototype.setScrollTop = function(pos) {
        if (this.vert.scrollTop != pos) {
          this.vert.scrollTop = pos;
        }
        if (this.disableVert) {
          this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
        }
      };
      NativeScrollbars.prototype.zeroWidthHack = function() {
        var w = mac && !mac_geMountainLion ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = w;
        this.horiz.style.visibility = this.vert.style.visibility = "hidden";
        this.disableHoriz = new Delayed();
        this.disableVert = new Delayed();
      };
      NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
        bar.style.visibility = "";
        function maybeDisable() {
          var box2 = bar.getBoundingClientRect();
          var elt2 = type == "vert" ? document.elementFromPoint(box2.right - 1, (box2.top + box2.bottom) / 2) : document.elementFromPoint((box2.right + box2.left) / 2, box2.bottom - 1);
          if (elt2 != bar) {
            bar.style.visibility = "hidden";
          } else {
            delay.set(1e3, maybeDisable);
          }
        }
        delay.set(1e3, maybeDisable);
      };
      NativeScrollbars.prototype.clear = function() {
        var parent = this.horiz.parentNode;
        parent.removeChild(this.horiz);
        parent.removeChild(this.vert);
      };
      var NullScrollbars = function() {
      };
      NullScrollbars.prototype.update = function() {
        return { bottom: 0, right: 0 };
      };
      NullScrollbars.prototype.setScrollLeft = function() {
      };
      NullScrollbars.prototype.setScrollTop = function() {
      };
      NullScrollbars.prototype.clear = function() {
      };
      function updateScrollbars(cm, measure) {
        if (!measure) {
          measure = measureForScrollbars(cm);
        }
        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
          if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
            updateHeightsInViewport(cm);
          }
          updateScrollbarsInner(cm, measureForScrollbars(cm));
          startWidth = cm.display.barWidth;
          startHeight = cm.display.barHeight;
        }
      }
      function updateScrollbarsInner(cm, measure) {
        var d = cm.display;
        var sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
        d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
        if (sizes.right && sizes.bottom) {
          d.scrollbarFiller.style.display = "block";
          d.scrollbarFiller.style.height = sizes.bottom + "px";
          d.scrollbarFiller.style.width = sizes.right + "px";
        } else {
          d.scrollbarFiller.style.display = "";
        }
        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d.gutterFiller.style.display = "block";
          d.gutterFiller.style.height = sizes.bottom + "px";
          d.gutterFiller.style.width = measure.gutterWidth + "px";
        } else {
          d.gutterFiller.style.display = "";
        }
      }
      var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
      function initScrollbars(cm) {
        if (cm.display.scrollbars) {
          cm.display.scrollbars.clear();
          if (cm.display.scrollbars.addClass) {
            rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }
        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
          cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
          on(node, "mousedown", function() {
            if (cm.state.focused) {
              setTimeout(function() {
                return cm.display.input.focus();
              }, 0);
            }
          });
          node.setAttribute("cm-not-content", "true");
        }, function(pos, axis) {
          if (axis == "horizontal") {
            setScrollLeft(cm, pos);
          } else {
            updateScrollTop(cm, pos);
          }
        }, cm);
        if (cm.display.scrollbars.addClass) {
          addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      }
      var nextOpId = 0;
      function startOperation(cm) {
        cm.curOp = {
          cm,
          viewChanged: false,
          // Flag that indicates that lines might need to be redrawn
          startHeight: cm.doc.height,
          // Used to detect need to update scrollbar
          forceUpdate: false,
          // Used to force a redraw
          updateInput: 0,
          // Whether to reset the input textarea
          typing: false,
          // Whether this reset should be careful to leave existing text (for compositing)
          changeObjs: null,
          // Accumulated changes, for firing change events
          cursorActivityHandlers: null,
          // Set of handlers to fire cursorActivity on
          cursorActivityCalled: 0,
          // Tracks which cursorActivity handlers have been called already
          selectionChanged: false,
          // Whether the selection needs to be redrawn
          updateMaxLine: false,
          // Set when the widest line needs to be determined anew
          scrollLeft: null,
          scrollTop: null,
          // Intermediate scroll position, not pushed to DOM yet
          scrollToPos: null,
          // Used to scroll to a specific position
          focus: false,
          id: ++nextOpId,
          // Unique ID
          markArrays: null
          // Used by addMarkedSpan
        };
        pushOperation(cm.curOp);
      }
      function endOperation(cm) {
        var op = cm.curOp;
        if (op) {
          finishOperation(op, function(group) {
            for (var i2 = 0; i2 < group.ops.length; i2++) {
              group.ops[i2].cm.curOp = null;
            }
            endOperations(group);
          });
        }
      }
      function endOperations(group) {
        var ops = group.ops;
        for (var i2 = 0; i2 < ops.length; i2++) {
          endOperation_R1(ops[i2]);
        }
        for (var i$12 = 0; i$12 < ops.length; i$12++) {
          endOperation_W1(ops[i$12]);
        }
        for (var i$22 = 0; i$22 < ops.length; i$22++) {
          endOperation_R2(ops[i$22]);
        }
        for (var i$3 = 0; i$3 < ops.length; i$3++) {
          endOperation_W2(ops[i$3]);
        }
        for (var i$4 = 0; i$4 < ops.length; i$4++) {
          endOperation_finish(ops[i$4]);
        }
      }
      function endOperation_R1(op) {
        var cm = op.cm, display = cm.display;
        maybeClipScrollbars(cm);
        if (op.updateMaxLine) {
          findMaxLine(cm);
        }
        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
      }
      function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
      }
      function endOperation_R2(op) {
        var cm = op.cm, display = cm.display;
        if (op.updatedDisplay) {
          updateHeightsInViewport(cm);
        }
        op.barMeasure = measureForScrollbars(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping) {
          op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
          cm.display.sizerWidth = op.adjustWidthTo;
          op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
          op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }
        if (op.updatedDisplay || op.selectionChanged) {
          op.preparedSelection = display.input.prepareSelection();
        }
      }
      function endOperation_W2(op) {
        var cm = op.cm;
        if (op.adjustWidthTo != null) {
          cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
          if (op.maxScrollLeft < cm.doc.scrollLeft) {
            setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
          }
          cm.display.maxLineChanged = false;
        }
        var takeFocus = op.focus && op.focus == activeElt(root(cm));
        if (op.preparedSelection) {
          cm.display.input.showSelection(op.preparedSelection, takeFocus);
        }
        if (op.updatedDisplay || op.startHeight != cm.doc.height) {
          updateScrollbars(cm, op.barMeasure);
        }
        if (op.updatedDisplay) {
          setDocumentHeight(cm, op.barMeasure);
        }
        if (op.selectionChanged) {
          restartBlink(cm);
        }
        if (cm.state.focused && op.updateInput) {
          cm.display.input.reset(op.typing);
        }
        if (takeFocus) {
          ensureFocus(op.cm);
        }
      }
      function endOperation_finish(op) {
        var cm = op.cm, display = cm.display, doc2 = cm.doc;
        if (op.updatedDisplay) {
          postUpdateDisplay(cm, op.update);
        }
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
          display.wheelStartX = display.wheelStartY = null;
        }
        if (op.scrollTop != null) {
          setScrollTop(cm, op.scrollTop, op.forceScroll);
        }
        if (op.scrollLeft != null) {
          setScrollLeft(cm, op.scrollLeft, true, true);
        }
        if (op.scrollToPos) {
          var rect = scrollPosIntoView(
            cm,
            clipPos(doc2, op.scrollToPos.from),
            clipPos(doc2, op.scrollToPos.to),
            op.scrollToPos.margin
          );
          maybeScrollWindow(cm, rect);
        }
        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
        if (hidden) {
          for (var i2 = 0; i2 < hidden.length; ++i2) {
            if (!hidden[i2].lines.length) {
              signal(hidden[i2], "hide");
            }
          }
        }
        if (unhidden) {
          for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
            if (unhidden[i$12].lines.length) {
              signal(unhidden[i$12], "unhide");
            }
          }
        }
        if (display.wrapper.offsetHeight) {
          doc2.scrollTop = cm.display.scroller.scrollTop;
        }
        if (op.changeObjs) {
          signal(cm, "changes", cm, op.changeObjs);
        }
        if (op.update) {
          op.update.finish();
        }
      }
      function runInOp(cm, f) {
        if (cm.curOp) {
          return f();
        }
        startOperation(cm);
        try {
          return f();
        } finally {
          endOperation(cm);
        }
      }
      function operation(cm, f) {
        return function() {
          if (cm.curOp) {
            return f.apply(cm, arguments);
          }
          startOperation(cm);
          try {
            return f.apply(cm, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function methodOp(f) {
        return function() {
          if (this.curOp) {
            return f.apply(this, arguments);
          }
          startOperation(this);
          try {
            return f.apply(this, arguments);
          } finally {
            endOperation(this);
          }
        };
      }
      function docMethodOp(f) {
        return function() {
          var cm = this.cm;
          if (!cm || cm.curOp) {
            return f.apply(this, arguments);
          }
          startOperation(cm);
          try {
            return f.apply(this, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function startWorker(cm, time) {
        if (cm.doc.highlightFrontier < cm.display.viewTo) {
          cm.state.highlight.set(time, bind(highlightWorker, cm));
        }
      }
      function highlightWorker(cm) {
        var doc2 = cm.doc;
        if (doc2.highlightFrontier >= cm.display.viewTo) {
          return;
        }
        var end = +/* @__PURE__ */ new Date() + cm.options.workTime;
        var context = getContextBefore(cm, doc2.highlightFrontier);
        var changedLines = [];
        doc2.iter(context.line, Math.min(doc2.first + doc2.size, cm.display.viewTo + 500), function(line) {
          if (context.line >= cm.display.viewFrom) {
            var oldStyles = line.styles;
            var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc2.mode, context.state) : null;
            var highlighted = highlightLine(cm, line, context, true);
            if (resetState) {
              context.state = resetState;
            }
            line.styles = highlighted.styles;
            var oldCls = line.styleClasses, newCls = highlighted.classes;
            if (newCls) {
              line.styleClasses = newCls;
            } else if (oldCls) {
              line.styleClasses = null;
            }
            var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
            for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
              ischange = oldStyles[i2] != line.styles[i2];
            }
            if (ischange) {
              changedLines.push(context.line);
            }
            line.stateAfter = context.save();
            context.nextLine();
          } else {
            if (line.text.length <= cm.options.maxHighlightLength) {
              processLine(cm, line.text, context);
            }
            line.stateAfter = context.line % 5 == 0 ? context.save() : null;
            context.nextLine();
          }
          if (+/* @__PURE__ */ new Date() > end) {
            startWorker(cm, cm.options.workDelay);
            return true;
          }
        });
        doc2.highlightFrontier = context.line;
        doc2.modeFrontier = Math.max(doc2.modeFrontier, context.line);
        if (changedLines.length) {
          runInOp(cm, function() {
            for (var i2 = 0; i2 < changedLines.length; i2++) {
              regLineChange(cm, changedLines[i2], "text");
            }
          });
        }
      }
      var DisplayUpdate = function(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport;
        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
      };
      DisplayUpdate.prototype.signal = function(emitter, type) {
        if (hasHandler(emitter, type)) {
          this.events.push(arguments);
        }
      };
      DisplayUpdate.prototype.finish = function() {
        for (var i2 = 0; i2 < this.events.length; i2++) {
          signal.apply(null, this.events[i2]);
        }
      };
      function maybeClipScrollbars(cm) {
        var display = cm.display;
        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
          display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
          display.heightForcer.style.height = scrollGap(cm) + "px";
          display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
          display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
          display.scrollbarsClipped = true;
        }
      }
      function selectionSnapshot(cm) {
        if (cm.hasFocus()) {
          return null;
        }
        var active = activeElt(root(cm));
        if (!active || !contains(cm.display.lineDiv, active)) {
          return null;
        }
        var result = { activeElt: active };
        if (window.getSelection) {
          var sel = win(cm).getSelection();
          if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
            result.anchorNode = sel.anchorNode;
            result.anchorOffset = sel.anchorOffset;
            result.focusNode = sel.focusNode;
            result.focusOffset = sel.focusOffset;
          }
        }
        return result;
      }
      function restoreSelection(snapshot) {
        if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(rootNode(snapshot.activeElt))) {
          return;
        }
        snapshot.activeElt.focus();
        if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
          var doc2 = snapshot.activeElt.ownerDocument;
          var sel = doc2.defaultView.getSelection(), range2 = doc2.createRange();
          range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
          range2.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range2);
          sel.extend(snapshot.focusNode, snapshot.focusOffset);
        }
      }
      function updateDisplayIfNeeded(cm, update) {
        var display = cm.display, doc2 = cm.doc;
        if (update.editorIsHidden) {
          resetView(cm);
          return false;
        }
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
          return false;
        }
        if (maybeUpdateLineNumberWidth(cm)) {
          resetView(cm);
          update.dims = getDimensions(cm);
        }
        var end = doc2.first + doc2.size;
        var from2 = Math.max(update.visible.from - cm.options.viewportMargin, doc2.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from2 && from2 - display.viewFrom < 20) {
          from2 = Math.max(doc2.first, display.viewFrom);
        }
        if (display.viewTo > to && display.viewTo - to < 20) {
          to = Math.min(end, display.viewTo);
        }
        if (sawCollapsedSpans) {
          from2 = visualLineNo(cm.doc, from2);
          to = visualLineEndNo(cm.doc, to);
        }
        var different = from2 != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from2, to);
        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
          return false;
        }
        var selSnapshot = selectionSnapshot(cm);
        if (toUpdate > 4) {
          display.lineDiv.style.display = "none";
        }
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4) {
          display.lineDiv.style.display = "";
        }
        display.renderedView = display.view;
        restoreSelection(selSnapshot);
        removeChildren2(display.cursorDiv);
        removeChildren2(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;
        if (different) {
          display.lastWrapHeight = update.wrapperHeight;
          display.lastWrapWidth = update.wrapperWidth;
          startWorker(cm, 400);
        }
        display.updateLineNumbers = null;
        return true;
      }
      function postUpdateDisplay(cm, update) {
        var viewport = update.viewport;
        for (var first = true; ; first = false) {
          if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
            if (viewport && viewport.top != null) {
              viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
            }
            update.visible = visibleLines(cm.display, cm.doc, viewport);
            if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
              break;
            }
          } else if (first) {
            update.visible = visibleLines(cm.display, cm.doc, viewport);
          }
          if (!updateDisplayIfNeeded(cm, update)) {
            break;
          }
          updateHeightsInViewport(cm);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.force = false;
        }
        update.signal(cm, "update", cm);
        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
          update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
          cm.display.reportedViewFrom = cm.display.viewFrom;
          cm.display.reportedViewTo = cm.display.viewTo;
        }
      }
      function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
          updateHeightsInViewport(cm);
          postUpdateDisplay(cm, update);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.finish();
        }
      }
      function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display, lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv, cur = container.firstChild;
        function rm(node2) {
          var next = node2.nextSibling;
          if (webkit && mac && cm.display.currentWheelTarget == node2) {
            node2.style.display = "none";
          } else {
            node2.parentNode.removeChild(node2);
          }
          return next;
        }
        var view = display.view, lineN = display.viewFrom;
        for (var i2 = 0; i2 < view.length; i2++) {
          var lineView = view[i2];
          if (lineView.hidden) ;
          else if (!lineView.node || lineView.node.parentNode != container) {
            var node = buildLineElement(cm, lineView, lineN, dims);
            container.insertBefore(node, cur);
          } else {
            while (cur != lineView.node) {
              cur = rm(cur);
            }
            var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
            if (lineView.changes) {
              if (indexOf(lineView.changes, "gutter") > -1) {
                updateNumber = false;
              }
              updateLineForChanges(cm, lineView, lineN, dims);
            }
            if (updateNumber) {
              removeChildren2(lineView.lineNumber);
              lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
            }
            cur = lineView.node.nextSibling;
          }
          lineN += lineView.size;
        }
        while (cur) {
          cur = rm(cur);
        }
      }
      function updateGutterSpace(display) {
        var width = display.gutters.offsetWidth;
        display.sizer.style.marginLeft = width + "px";
        signalLater(display, "gutterChanged", display);
      }
      function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        cm.display.heightForcer.style.top = measure.docHeight + "px";
        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
      }
      function alignHorizontally(cm) {
        var display = cm.display, view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
          return;
        }
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth, left = comp + "px";
        for (var i2 = 0; i2 < view.length; i2++) {
          if (!view[i2].hidden) {
            if (cm.options.fixedGutter) {
              if (view[i2].gutter) {
                view[i2].gutter.style.left = left;
              }
              if (view[i2].gutterBackground) {
                view[i2].gutterBackground.style.left = left;
              }
            }
            var align = view[i2].alignable;
            if (align) {
              for (var j = 0; j < align.length; j++) {
                align[j].style.left = left;
              }
            }
          }
        }
        if (cm.options.fixedGutter) {
          display.gutters.style.left = comp + gutterW + "px";
        }
      }
      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) {
          return false;
        }
        var doc2 = cm.doc, last = lineNumberFor(cm.options, doc2.first + doc2.size - 1), display = cm.display;
        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt(
            "div",
            [elt("div", last)],
            "CodeMirror-linenumber CodeMirror-gutter-elt"
          ));
          var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          updateGutterSpace(cm.display);
          return true;
        }
        return false;
      }
      function getGutters(gutters, lineNumbers) {
        var result = [], sawLineNumbers = false;
        for (var i2 = 0; i2 < gutters.length; i2++) {
          var name2 = gutters[i2], style = null;
          if (typeof name2 != "string") {
            style = name2.style;
            name2 = name2.className;
          }
          if (name2 == "CodeMirror-linenumbers") {
            if (!lineNumbers) {
              continue;
            } else {
              sawLineNumbers = true;
            }
          }
          result.push({ className: name2, style });
        }
        if (lineNumbers && !sawLineNumbers) {
          result.push({ className: "CodeMirror-linenumbers", style: null });
        }
        return result;
      }
      function renderGutters(display) {
        var gutters = display.gutters, specs = display.gutterSpecs;
        removeChildren2(gutters);
        display.lineGutter = null;
        for (var i2 = 0; i2 < specs.length; ++i2) {
          var ref = specs[i2];
          var className = ref.className;
          var style = ref.style;
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
          if (style) {
            gElt.style.cssText = style;
          }
          if (className == "CodeMirror-linenumbers") {
            display.lineGutter = gElt;
            gElt.style.width = (display.lineNumWidth || 1) + "px";
          }
        }
        gutters.style.display = specs.length ? "" : "none";
        updateGutterSpace(display);
      }
      function updateGutters(cm) {
        renderGutters(cm.display);
        regChange(cm);
        alignHorizontally(cm);
      }
      function Display(place, doc2, input, options) {
        var d = this;
        this.input = input;
        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.scrollbarFiller.setAttribute("cm-not-content", "true");
        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        d.gutterFiller.setAttribute("cm-not-content", "true");
        d.lineDiv = eltP("div", null, "CodeMirror-code");
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        d.cursorDiv = elt("div", null, "CodeMirror-cursors");
        d.measure = elt("div", null, "CodeMirror-measure");
        d.lineMeasure = elt("div", null, "CodeMirror-measure");
        d.lineSpace = eltP(
          "div",
          [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
          null,
          "position: relative; outline: none"
        );
        var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
        d.mover = elt("div", [lines], null, "position: relative");
        d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
        d.sizerWidth = null;
        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null;
        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1");
        d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
        if (chrome && chrome_version >= 105) {
          d.wrapper.style.clipPath = "inset(0px)";
        }
        d.wrapper.setAttribute("translate", "no");
        if (ie && ie_version < 8) {
          d.gutters.style.zIndex = -1;
          d.scroller.style.paddingRight = 0;
        }
        if (!webkit && !(gecko && mobile)) {
          d.scroller.draggable = true;
        }
        if (place) {
          if (place.appendChild) {
            place.appendChild(d.wrapper);
          } else {
            place(d.wrapper);
          }
        }
        d.viewFrom = d.viewTo = doc2.first;
        d.reportedViewFrom = d.reportedViewTo = doc2.first;
        d.view = [];
        d.renderedView = null;
        d.externalMeasured = null;
        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;
        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false;
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        d.alignWidgets = false;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
        d.shift = false;
        d.selForContextMenu = null;
        d.activeTouch = null;
        d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
        renderGutters(d);
        input.init(d);
      }
      var wheelSamples = 0, wheelPixelsPerUnit = null;
      if (ie) {
        wheelPixelsPerUnit = -0.53;
      } else if (gecko) {
        wheelPixelsPerUnit = 15;
      } else if (chrome) {
        wheelPixelsPerUnit = -0.7;
      } else if (safari) {
        wheelPixelsPerUnit = -1 / 3;
      }
      function wheelEventDelta(e) {
        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
          dx = e.detail;
        }
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
          dy = e.detail;
        } else if (dy == null) {
          dy = e.wheelDelta;
        }
        return { x: dx, y: dy };
      }
      function wheelEventPixels(e) {
        var delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
      }
      function onScrollWheel(cm, e) {
        if (chrome && chrome_version == 102) {
          if (cm.display.chromeScrollHack == null) {
            cm.display.sizer.style.pointerEvents = "none";
          } else {
            clearTimeout(cm.display.chromeScrollHack);
          }
          cm.display.chromeScrollHack = setTimeout(function() {
            cm.display.chromeScrollHack = null;
            cm.display.sizer.style.pointerEvents = "";
          }, 100);
        }
        var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
        var pixelsPerUnit = wheelPixelsPerUnit;
        if (e.deltaMode === 0) {
          dx = e.deltaX;
          dy = e.deltaY;
          pixelsPerUnit = 1;
        }
        var display = cm.display, scroll = display.scroller;
        var canScrollX = scroll.scrollWidth > scroll.clientWidth;
        var canScrollY = scroll.scrollHeight > scroll.clientHeight;
        if (!(dx && canScrollX || dy && canScrollY)) {
          return;
        }
        if (dy && mac && webkit) {
          outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i2 = 0; i2 < view.length; i2++) {
              if (view[i2].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
        }
        if (dx && !gecko && !presto && pixelsPerUnit != null) {
          if (dy && canScrollY) {
            updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
          }
          setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
          if (!dy || dy && canScrollY) {
            e_preventDefault(e);
          }
          display.wheelStartX = null;
          return;
        }
        if (dy && pixelsPerUnit != null) {
          var pixels = dy * pixelsPerUnit;
          var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
          if (pixels < 0) {
            top = Math.max(0, top + pixels - 50);
          } else {
            bot = Math.min(cm.doc.height, bot + pixels + 50);
          }
          updateDisplaySimple(cm, { top, bottom: bot });
        }
        if (wheelSamples < 20 && e.deltaMode !== 0) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft;
            display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx;
            display.wheelDY = dy;
            setTimeout(function() {
              if (display.wheelStartX == null) {
                return;
              }
              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
              display.wheelStartX = display.wheelStartY = null;
              if (!sample) {
                return;
              }
              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx;
            display.wheelDY += dy;
          }
        }
      }
      var Selection = function(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
      };
      Selection.prototype.primary = function() {
        return this.ranges[this.primIndex];
      };
      Selection.prototype.equals = function(other) {
        if (other == this) {
          return true;
        }
        if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
          return false;
        }
        for (var i2 = 0; i2 < this.ranges.length; i2++) {
          var here = this.ranges[i2], there = other.ranges[i2];
          if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
            return false;
          }
        }
        return true;
      };
      Selection.prototype.deepCopy = function() {
        var out = [];
        for (var i2 = 0; i2 < this.ranges.length; i2++) {
          out[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
        }
        return new Selection(out, this.primIndex);
      };
      Selection.prototype.somethingSelected = function() {
        for (var i2 = 0; i2 < this.ranges.length; i2++) {
          if (!this.ranges[i2].empty()) {
            return true;
          }
        }
        return false;
      };
      Selection.prototype.contains = function(pos, end) {
        if (!end) {
          end = pos;
        }
        for (var i2 = 0; i2 < this.ranges.length; i2++) {
          var range2 = this.ranges[i2];
          if (cmp(end, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
            return i2;
          }
        }
        return -1;
      };
      var Range = function(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      };
      Range.prototype.from = function() {
        return minPos(this.anchor, this.head);
      };
      Range.prototype.to = function() {
        return maxPos(this.anchor, this.head);
      };
      Range.prototype.empty = function() {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
      };
      function normalizeSelection(cm, ranges, primIndex) {
        var mayTouch = cm && cm.options.selectionsMayTouch;
        var prim = ranges[primIndex];
        ranges.sort(function(a, b) {
          return cmp(a.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);
        for (var i2 = 1; i2 < ranges.length; i2++) {
          var cur = ranges[i2], prev = ranges[i2 - 1];
          var diff = cmp(prev.to(), cur.from());
          if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
            var from2 = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
            var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
            if (i2 <= primIndex) {
              --primIndex;
            }
            ranges.splice(--i2, 2, new Range(inv ? to : from2, inv ? from2 : to));
          }
        }
        return new Selection(ranges, primIndex);
      }
      function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0);
      }
      function changeEnd(change) {
        if (!change.text) {
          return change.to;
        }
        return Pos(
          change.from.line + change.text.length - 1,
          lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0)
        );
      }
      function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0) {
          return pos;
        }
        if (cmp(pos, change.to) <= 0) {
          return changeEnd(change);
        }
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
        if (pos.line == change.to.line) {
          ch += changeEnd(change).ch - change.to.ch;
        }
        return Pos(line, ch);
      }
      function computeSelAfterChange(doc2, change) {
        var out = [];
        for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
          var range2 = doc2.sel.ranges[i2];
          out.push(new Range(
            adjustForChange(range2.anchor, change),
            adjustForChange(range2.head, change)
          ));
        }
        return normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
      }
      function offsetPos(pos, old, nw) {
        if (pos.line == old.line) {
          return Pos(nw.line, pos.ch - old.ch + nw.ch);
        } else {
          return Pos(nw.line + (pos.line - old.line), pos.ch);
        }
      }
      function computeReplacedSel(doc2, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc2.first, 0), newPrev = oldPrev;
        for (var i2 = 0; i2 < changes.length; i2++) {
          var change = changes[i2];
          var from2 = offsetPos(change.from, oldPrev, newPrev);
          var to = offsetPos(changeEnd(change), oldPrev, newPrev);
          oldPrev = change.to;
          newPrev = to;
          if (hint == "around") {
            var range2 = doc2.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;
            out[i2] = new Range(inv ? to : from2, inv ? from2 : to);
          } else {
            out[i2] = new Range(from2, from2);
          }
        }
        return new Selection(out, doc2.sel.primIndex);
      }
      function loadMode(cm) {
        cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
      }
      function resetModeState(cm) {
        cm.doc.iter(function(line) {
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          if (line.styles) {
            line.styles = null;
          }
        });
        cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp) {
          regChange(cm);
        }
      }
      function isWholeLineUpdate(doc2, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc2.cm || doc2.cm.options.wholeLineUpdateBefore);
      }
      function updateDoc(doc2, change, markedSpans, estimateHeight2) {
        function spansFor(n) {
          return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text2, spans) {
          updateLine(line, text2, spans, estimateHeight2);
          signalLater(line, "change", line, change);
        }
        function linesFor(start, end) {
          var result = [];
          for (var i2 = start; i2 < end; ++i2) {
            result.push(new Line(text[i2], spansFor(i2), estimateHeight2));
          }
          return result;
        }
        var from2 = change.from, to = change.to, text = change.text;
        var firstLine = getLine(doc2, from2.line), lastLine = getLine(doc2, to.line);
        var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from2.line;
        if (change.full) {
          doc2.insert(0, linesFor(0, text.length));
          doc2.remove(text.length, doc2.size - text.length);
        } else if (isWholeLineUpdate(doc2, change)) {
          var added = linesFor(0, text.length - 1);
          update(lastLine, lastLine.text, lastSpans);
          if (nlines) {
            doc2.remove(from2.line, nlines);
          }
          if (added.length) {
            doc2.insert(from2.line, added);
          }
        } else if (firstLine == lastLine) {
          if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from2.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            var added$1 = linesFor(1, text.length - 1);
            added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
            update(firstLine, firstLine.text.slice(0, from2.ch) + text[0], spansFor(0));
            doc2.insert(from2.line + 1, added$1);
          }
        } else if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from2.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc2.remove(from2.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from2.ch) + text[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          var added$2 = linesFor(1, text.length - 1);
          if (nlines > 1) {
            doc2.remove(from2.line + 1, nlines - 1);
          }
          doc2.insert(from2.line + 1, added$2);
        }
        signalLater(doc2, "change", doc2, change);
      }
      function linkedDocs(doc2, f, sharedHistOnly) {
        function propagate(doc3, skip, sharedHist) {
          if (doc3.linked) {
            for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
              var rel = doc3.linked[i2];
              if (rel.doc == skip) {
                continue;
              }
              var shared = sharedHist && rel.sharedHist;
              if (sharedHistOnly && !shared) {
                continue;
              }
              f(rel.doc, shared);
              propagate(rel.doc, doc3, shared);
            }
          }
        }
        propagate(doc2, null, true);
      }
      function attachDoc(cm, doc2) {
        if (doc2.cm) {
          throw new Error("This document is already in use.");
        }
        cm.doc = doc2;
        doc2.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        setDirectionClass(cm);
        cm.options.direction = doc2.direction;
        if (!cm.options.lineWrapping) {
          findMaxLine(cm);
        }
        cm.options.mode = doc2.modeOption;
        regChange(cm);
      }
      function setDirectionClass(cm) {
        (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
      }
      function directionChanged(cm) {
        runInOp(cm, function() {
          setDirectionClass(cm);
          regChange(cm);
        });
      }
      function History(prev) {
        this.done = [];
        this.undone = [];
        this.undoDepth = prev ? prev.undoDepth : Infinity;
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
      }
      function historyChangeFromChange(doc2, change) {
        var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc2, change.from, change.to) };
        attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc2, function(doc3) {
          return attachLocalSpans(doc3, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
      }
      function clearSelectionEvents(array) {
        while (array.length) {
          var last = lst(array);
          if (last.ranges) {
            array.pop();
          } else {
            break;
          }
        }
      }
      function lastChangeEvent(hist, force) {
        if (force) {
          clearSelectionEvents(hist.done);
          return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
          return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
          hist.done.pop();
          return lst(hist.done);
        }
      }
      function addChangeToHistory(doc2, change, selAfter, opId) {
        var hist = doc2.history;
        hist.undone.length = 0;
        var time = +/* @__PURE__ */ new Date(), cur;
        var last;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc2.cm ? doc2.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
          last = lst(cur.changes);
          if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
            last.to = changeEnd(change);
          } else {
            cur.changes.push(historyChangeFromChange(doc2, change));
          }
        } else {
          var before = lst(hist.done);
          if (!before || !before.ranges) {
            pushSelectionToHistory(doc2.sel, hist.done);
          }
          cur = {
            changes: [historyChangeFromChange(doc2, change)],
            generation: hist.generation
          };
          hist.done.push(cur);
          while (hist.done.length > hist.undoDepth) {
            hist.done.shift();
            if (!hist.done[0].ranges) {
              hist.done.shift();
            }
          }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;
        if (!last) {
          signal(doc2, "historyAdded");
        }
      }
      function selectionEventCanBeMerged(doc2, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && /* @__PURE__ */ new Date() - doc2.history.lastSelTime <= (doc2.cm ? doc2.cm.options.historyEventDelay : 500);
      }
      function addSelectionToHistory(doc2, sel, opId, options) {
        var hist = doc2.history, origin = options && options.origin;
        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc2, origin, lst(hist.done), sel))) {
          hist.done[hist.done.length - 1] = sel;
        } else {
          pushSelectionToHistory(sel, hist.done);
        }
        hist.lastSelTime = +/* @__PURE__ */ new Date();
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false) {
          clearSelectionEvents(hist.undone);
        }
      }
      function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        if (!(top && top.ranges && top.equals(sel))) {
          dest.push(sel);
        }
      }
      function attachLocalSpans(doc2, change, from2, to) {
        var existing = change["spans_" + doc2.id], n = 0;
        doc2.iter(Math.max(doc2.first, from2), Math.min(doc2.first + doc2.size, to), function(line) {
          if (line.markedSpans) {
            (existing || (existing = change["spans_" + doc2.id] = {}))[n] = line.markedSpans;
          }
          ++n;
        });
      }
      function removeClearedSpans(spans) {
        if (!spans) {
          return null;
        }
        var out;
        for (var i2 = 0; i2 < spans.length; ++i2) {
          if (spans[i2].marker.explicitlyCleared) {
            if (!out) {
              out = spans.slice(0, i2);
            }
          } else if (out) {
            out.push(spans[i2]);
          }
        }
        return !out ? spans : out.length ? out : null;
      }
      function getOldSpans(doc2, change) {
        var found = change["spans_" + doc2.id];
        if (!found) {
          return null;
        }
        var nw = [];
        for (var i2 = 0; i2 < change.text.length; ++i2) {
          nw.push(removeClearedSpans(found[i2]));
        }
        return nw;
      }
      function mergeOldSpans(doc2, change) {
        var old = getOldSpans(doc2, change);
        var stretched = stretchSpansOverChange(doc2, change);
        if (!old) {
          return stretched;
        }
        if (!stretched) {
          return old;
        }
        for (var i2 = 0; i2 < old.length; ++i2) {
          var oldCur = old[i2], stretchCur = stretched[i2];
          if (oldCur && stretchCur) {
            spans: for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k) {
                if (oldCur[k].marker == span.marker) {
                  continue spans;
                }
              }
              oldCur.push(span);
            }
          } else if (stretchCur) {
            old[i2] = stretchCur;
          }
        }
        return old;
      }
      function copyHistoryArray(events, newGroup, instantiateSel) {
        var copy2 = [];
        for (var i2 = 0; i2 < events.length; ++i2) {
          var event = events[i2];
          if (event.ranges) {
            copy2.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
            continue;
          }
          var changes = event.changes, newChanges = [];
          copy2.push({ changes: newChanges });
          for (var j = 0; j < changes.length; ++j) {
            var change = changes[j], m = void 0;
            newChanges.push({ from: change.from, to: change.to, text: change.text });
            if (newGroup) {
              for (var prop2 in change) {
                if (m = prop2.match(/^spans_(\d+)$/)) {
                  if (indexOf(newGroup, Number(m[1])) > -1) {
                    lst(newChanges)[prop2] = change[prop2];
                    delete change[prop2];
                  }
                }
              }
            }
          }
        }
        return copy2;
      }
      function extendRange(range2, head, other, extend) {
        if (extend) {
          var anchor = range2.anchor;
          if (other) {
            var posBefore = cmp(head, anchor) < 0;
            if (posBefore != cmp(other, anchor) < 0) {
              anchor = head;
              head = other;
            } else if (posBefore != cmp(head, other) < 0) {
              head = other;
            }
          }
          return new Range(anchor, head);
        } else {
          return new Range(other || head, head);
        }
      }
      function extendSelection(doc2, head, other, options, extend) {
        if (extend == null) {
          extend = doc2.cm && (doc2.cm.display.shift || doc2.extend);
        }
        setSelection(doc2, new Selection([extendRange(doc2.sel.primary(), head, other, extend)], 0), options);
      }
      function extendSelections(doc2, heads, options) {
        var out = [];
        var extend = doc2.cm && (doc2.cm.display.shift || doc2.extend);
        for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
          out[i2] = extendRange(doc2.sel.ranges[i2], heads[i2], null, extend);
        }
        var newSel = normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
        setSelection(doc2, newSel, options);
      }
      function replaceOneSelection(doc2, i2, range2, options) {
        var ranges = doc2.sel.ranges.slice(0);
        ranges[i2] = range2;
        setSelection(doc2, normalizeSelection(doc2.cm, ranges, doc2.sel.primIndex), options);
      }
      function setSimpleSelection(doc2, anchor, head, options) {
        setSelection(doc2, simpleSelection(anchor, head), options);
      }
      function filterSelectionChange(doc2, sel, options) {
        var obj = {
          ranges: sel.ranges,
          update: function(ranges) {
            this.ranges = [];
            for (var i2 = 0; i2 < ranges.length; i2++) {
              this.ranges[i2] = new Range(
                clipPos(doc2, ranges[i2].anchor),
                clipPos(doc2, ranges[i2].head)
              );
            }
          },
          origin: options && options.origin
        };
        signal(doc2, "beforeSelectionChange", doc2, obj);
        if (doc2.cm) {
          signal(doc2.cm, "beforeSelectionChange", doc2.cm, obj);
        }
        if (obj.ranges != sel.ranges) {
          return normalizeSelection(doc2.cm, obj.ranges, obj.ranges.length - 1);
        } else {
          return sel;
        }
      }
      function setSelectionReplaceHistory(doc2, sel, options) {
        var done = doc2.history.done, last = lst(done);
        if (last && last.ranges) {
          done[done.length - 1] = sel;
          setSelectionNoUndo(doc2, sel, options);
        } else {
          setSelection(doc2, sel, options);
        }
      }
      function setSelection(doc2, sel, options) {
        setSelectionNoUndo(doc2, sel, options);
        addSelectionToHistory(doc2, doc2.sel, doc2.cm ? doc2.cm.curOp.id : NaN, options);
      }
      function setSelectionNoUndo(doc2, sel, options) {
        if (hasHandler(doc2, "beforeSelectionChange") || doc2.cm && hasHandler(doc2.cm, "beforeSelectionChange")) {
          sel = filterSelectionChange(doc2, sel, options);
        }
        var bias = options && options.bias || (cmp(sel.primary().head, doc2.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc2, skipAtomicInSelection(doc2, sel, bias, true));
        if (!(options && options.scroll === false) && doc2.cm && doc2.cm.getOption("readOnly") != "nocursor") {
          ensureCursorVisible(doc2.cm);
        }
      }
      function setSelectionInner(doc2, sel) {
        if (sel.equals(doc2.sel)) {
          return;
        }
        doc2.sel = sel;
        if (doc2.cm) {
          doc2.cm.curOp.updateInput = 1;
          doc2.cm.curOp.selectionChanged = true;
          signalCursorActivity(doc2.cm);
        }
        signalLater(doc2, "cursorActivity", doc2);
      }
      function reCheckSelection(doc2) {
        setSelectionInner(doc2, skipAtomicInSelection(doc2, doc2.sel, null, false));
      }
      function skipAtomicInSelection(doc2, sel, bias, mayClear) {
        var out;
        for (var i2 = 0; i2 < sel.ranges.length; i2++) {
          var range2 = sel.ranges[i2];
          var old = sel.ranges.length == doc2.sel.ranges.length && doc2.sel.ranges[i2];
          var newAnchor = skipAtomic(doc2, range2.anchor, old && old.anchor, bias, mayClear);
          var newHead = range2.head == range2.anchor ? newAnchor : skipAtomic(doc2, range2.head, old && old.head, bias, mayClear);
          if (out || newAnchor != range2.anchor || newHead != range2.head) {
            if (!out) {
              out = sel.ranges.slice(0, i2);
            }
            out[i2] = new Range(newAnchor, newHead);
          }
        }
        return out ? normalizeSelection(doc2.cm, out, sel.primIndex) : sel;
      }
      function skipAtomicInner(doc2, pos, oldPos, dir, mayClear) {
        var line = getLine(doc2, pos.line);
        if (line.markedSpans) {
          for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
            var sp = line.markedSpans[i2], m = sp.marker;
            var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
            var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
            if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
              if (mayClear) {
                signal(m, "beforeCursorEnter");
                if (m.explicitlyCleared) {
                  if (!line.markedSpans) {
                    break;
                  } else {
                    --i2;
                    continue;
                  }
                }
              }
              if (!m.atomic) {
                continue;
              }
              if (oldPos) {
                var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
                if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                  near = movePos(doc2, near, -dir, near && near.line == pos.line ? line : null);
                }
                if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                  return skipAtomicInner(doc2, near, pos, dir, mayClear);
                }
              }
              var far = m.find(dir < 0 ? -1 : 1);
              if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                far = movePos(doc2, far, dir, far.line == pos.line ? line : null);
              }
              return far ? skipAtomicInner(doc2, far, pos, dir, mayClear) : null;
            }
          }
        }
        return pos;
      }
      function skipAtomic(doc2, pos, oldPos, bias, mayClear) {
        var dir = bias || 1;
        var found = skipAtomicInner(doc2, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, dir, true) || skipAtomicInner(doc2, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, -dir, true);
        if (!found) {
          doc2.cantEdit = true;
          return Pos(doc2.first, 0);
        }
        return found;
      }
      function movePos(doc2, pos, dir, line) {
        if (dir < 0 && pos.ch == 0) {
          if (pos.line > doc2.first) {
            return clipPos(doc2, Pos(pos.line - 1));
          } else {
            return null;
          }
        } else if (dir > 0 && pos.ch == (line || getLine(doc2, pos.line)).text.length) {
          if (pos.line < doc2.first + doc2.size - 1) {
            return Pos(pos.line + 1, 0);
          } else {
            return null;
          }
        } else {
          return new Pos(pos.line, pos.ch + dir);
        }
      }
      function selectAll(cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
      }
      function filterChange(doc2, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function() {
            return obj.canceled = true;
          }
        };
        if (update) {
          obj.update = function(from2, to, text, origin) {
            if (from2) {
              obj.from = clipPos(doc2, from2);
            }
            if (to) {
              obj.to = clipPos(doc2, to);
            }
            if (text) {
              obj.text = text;
            }
            if (origin !== void 0) {
              obj.origin = origin;
            }
          };
        }
        signal(doc2, "beforeChange", doc2, obj);
        if (doc2.cm) {
          signal(doc2.cm, "beforeChange", doc2.cm, obj);
        }
        if (obj.canceled) {
          if (doc2.cm) {
            doc2.cm.curOp.updateInput = 2;
          }
          return null;
        }
        return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
      }
      function makeChange(doc2, change, ignoreReadOnly) {
        if (doc2.cm) {
          if (!doc2.cm.curOp) {
            return operation(doc2.cm, makeChange)(doc2, change, ignoreReadOnly);
          }
          if (doc2.cm.state.suppressEdits) {
            return;
          }
        }
        if (hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange")) {
          change = filterChange(doc2, change, true);
          if (!change) {
            return;
          }
        }
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc2, change.from, change.to);
        if (split) {
          for (var i2 = split.length - 1; i2 >= 0; --i2) {
            makeChangeInner(doc2, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
          }
        } else {
          makeChangeInner(doc2, change);
        }
      }
      function makeChangeInner(doc2, change) {
        if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
          return;
        }
        var selAfter = computeSelAfterChange(doc2, change);
        addChangeToHistory(doc2, change, selAfter, doc2.cm ? doc2.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc2, change, selAfter, stretchSpansOverChange(doc2, change));
        var rebased = [];
        linkedDocs(doc2, function(doc3, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
            rebaseHist(doc3.history, change);
            rebased.push(doc3.history);
          }
          makeChangeSingleDoc(doc3, change, null, stretchSpansOverChange(doc3, change));
        });
      }
      function makeChangeFromHistory(doc2, type, allowSelectionOnly) {
        var suppress = doc2.cm && doc2.cm.state.suppressEdits;
        if (suppress && !allowSelectionOnly) {
          return;
        }
        var hist = doc2.history, event, selAfter = doc2.sel;
        var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
        var i2 = 0;
        for (; i2 < source.length; i2++) {
          event = source[i2];
          if (allowSelectionOnly ? event.ranges && !event.equals(doc2.sel) : !event.ranges) {
            break;
          }
        }
        if (i2 == source.length) {
          return;
        }
        hist.lastOrigin = hist.lastSelOrigin = null;
        for (; ; ) {
          event = source.pop();
          if (event.ranges) {
            pushSelectionToHistory(event, dest);
            if (allowSelectionOnly && !event.equals(doc2.sel)) {
              setSelection(doc2, event, { clearRedo: false });
              return;
            }
            selAfter = event;
          } else if (suppress) {
            source.push(event);
            return;
          } else {
            break;
          }
        }
        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({ changes: antiChanges, generation: hist.generation });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter = hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange");
        var loop = function(i3) {
          var change = event.changes[i3];
          change.origin = type;
          if (filter && !filterChange(doc2, change, false)) {
            source.length = 0;
            return {};
          }
          antiChanges.push(historyChangeFromChange(doc2, change));
          var after = i3 ? computeSelAfterChange(doc2, change) : lst(source);
          makeChangeSingleDoc(doc2, change, after, mergeOldSpans(doc2, change));
          if (!i3 && doc2.cm) {
            doc2.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
          }
          var rebased = [];
          linkedDocs(doc2, function(doc3, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
              rebaseHist(doc3.history, change);
              rebased.push(doc3.history);
            }
            makeChangeSingleDoc(doc3, change, null, mergeOldSpans(doc3, change));
          });
        };
        for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {
          var returned = loop(i$12);
          if (returned) return returned.v;
        }
      }
      function shiftDoc(doc2, distance) {
        if (distance == 0) {
          return;
        }
        doc2.first += distance;
        doc2.sel = new Selection(map2(doc2.sel.ranges, function(range2) {
          return new Range(
            Pos(range2.anchor.line + distance, range2.anchor.ch),
            Pos(range2.head.line + distance, range2.head.ch)
          );
        }), doc2.sel.primIndex);
        if (doc2.cm) {
          regChange(doc2.cm, doc2.first, doc2.first - distance, distance);
          for (var d = doc2.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
            regLineChange(doc2.cm, l, "gutter");
          }
        }
      }
      function makeChangeSingleDoc(doc2, change, selAfter, spans) {
        if (doc2.cm && !doc2.cm.curOp) {
          return operation(doc2.cm, makeChangeSingleDoc)(doc2, change, selAfter, spans);
        }
        if (change.to.line < doc2.first) {
          shiftDoc(doc2, change.text.length - 1 - (change.to.line - change.from.line));
          return;
        }
        if (change.from.line > doc2.lastLine()) {
          return;
        }
        if (change.from.line < doc2.first) {
          var shift = change.text.length - 1 - (doc2.first - change.from.line);
          shiftDoc(doc2, shift);
          change = {
            from: Pos(doc2.first, 0),
            to: Pos(change.to.line + shift, change.to.ch),
            text: [lst(change.text)],
            origin: change.origin
          };
        }
        var last = doc2.lastLine();
        if (change.to.line > last) {
          change = {
            from: change.from,
            to: Pos(last, getLine(doc2, last).text.length),
            text: [change.text[0]],
            origin: change.origin
          };
        }
        change.removed = getBetween(doc2, change.from, change.to);
        if (!selAfter) {
          selAfter = computeSelAfterChange(doc2, change);
        }
        if (doc2.cm) {
          makeChangeSingleDocInEditor(doc2.cm, change, spans);
        } else {
          updateDoc(doc2, change, spans);
        }
        setSelectionNoUndo(doc2, selAfter, sel_dontScroll);
        if (doc2.cantEdit && skipAtomic(doc2, Pos(doc2.firstLine(), 0))) {
          doc2.cantEdit = false;
        }
      }
      function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc2 = cm.doc, display = cm.display, from2 = change.from, to = change.to;
        var recomputeMaxLength = false, checkWidthStart = from2.line;
        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(getLine(doc2, from2.line)));
          doc2.iter(checkWidthStart, to.line + 1, function(line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true;
            }
          });
        }
        if (doc2.sel.contains(change.from, change.to) > -1) {
          signalCursorActivity(cm);
        }
        updateDoc(doc2, change, spans, estimateHeight(cm));
        if (!cm.options.lineWrapping) {
          doc2.iter(checkWidthStart, from2.line + change.text.length, function(line) {
            var len2 = lineLength(line);
            if (len2 > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len2;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });
          if (recomputeMaxLength) {
            cm.curOp.updateMaxLine = true;
          }
        }
        retreatFrontier(doc2, from2.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from2.line) - 1;
        if (change.full) {
          regChange(cm);
        } else if (from2.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
          regLineChange(cm, from2.line, "text");
        } else {
          regChange(cm, from2.line, to.line + 1, lendiff);
        }
        var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
          var obj = {
            from: from2,
            to,
            text: change.text,
            removed: change.removed,
            origin: change.origin
          };
          if (changeHandler) {
            signalLater(cm, "change", cm, obj);
          }
          if (changesHandler) {
            (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
          }
        }
        cm.display.selForContextMenu = null;
      }
      function replaceRange(doc2, code, from2, to, origin) {
        var assign;
        if (!to) {
          to = from2;
        }
        if (cmp(to, from2) < 0) {
          assign = [to, from2], from2 = assign[0], to = assign[1];
        }
        if (typeof code == "string") {
          code = doc2.splitLines(code);
        }
        makeChange(doc2, { from: from2, to, text: code, origin });
      }
      function rebaseHistSelSingle(pos, from2, to, diff) {
        if (to < pos.line) {
          pos.line += diff;
        } else if (from2 < pos.line) {
          pos.line = from2;
          pos.ch = 0;
        }
      }
      function rebaseHistArray(array, from2, to, diff) {
        for (var i2 = 0; i2 < array.length; ++i2) {
          var sub2 = array[i2], ok = true;
          if (sub2.ranges) {
            if (!sub2.copied) {
              sub2 = array[i2] = sub2.deepCopy();
              sub2.copied = true;
            }
            for (var j = 0; j < sub2.ranges.length; j++) {
              rebaseHistSelSingle(sub2.ranges[j].anchor, from2, to, diff);
              rebaseHistSelSingle(sub2.ranges[j].head, from2, to, diff);
            }
            continue;
          }
          for (var j$1 = 0; j$1 < sub2.changes.length; ++j$1) {
            var cur = sub2.changes[j$1];
            if (to < cur.from.line) {
              cur.from = Pos(cur.from.line + diff, cur.from.ch);
              cur.to = Pos(cur.to.line + diff, cur.to.ch);
            } else if (from2 <= cur.to.line) {
              ok = false;
              break;
            }
          }
          if (!ok) {
            array.splice(0, i2 + 1);
            i2 = 0;
          }
        }
      }
      function rebaseHist(hist, change) {
        var from2 = change.from.line, to = change.to.line, diff = change.text.length - (to - from2) - 1;
        rebaseHistArray(hist.done, from2, to, diff);
        rebaseHistArray(hist.undone, from2, to, diff);
      }
      function changeLine(doc2, handle, changeType, op) {
        var no = handle, line = handle;
        if (typeof handle == "number") {
          line = getLine(doc2, clipLine(doc2, handle));
        } else {
          no = lineNo(handle);
        }
        if (no == null) {
          return null;
        }
        if (op(line, no) && doc2.cm) {
          regLineChange(doc2.cm, no, changeType);
        }
        return line;
      }
      function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        var height = 0;
        for (var i2 = 0; i2 < lines.length; ++i2) {
          lines[i2].parent = this;
          height += lines[i2].height;
        }
        this.height = height;
      }
      LeafChunk.prototype = {
        chunkSize: function() {
          return this.lines.length;
        },
        // Remove the n lines at offset 'at'.
        removeInner: function(at, n) {
          for (var i2 = at, e = at + n; i2 < e; ++i2) {
            var line = this.lines[i2];
            this.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }
          this.lines.splice(at, n);
        },
        // Helper used to collapse a small branch into a single leaf.
        collapse: function(lines) {
          lines.push.apply(lines, this.lines);
        },
        // Insert the given array of lines at offset 'at', count them as
        // having the given height.
        insertInner: function(at, lines, height) {
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
          for (var i2 = 0; i2 < lines.length; ++i2) {
            lines[i2].parent = this;
          }
        },
        // Used to iterate over a part of the tree.
        iterN: function(at, n, op) {
          for (var e = at + n; at < e; ++at) {
            if (op(this.lines[at])) {
              return true;
            }
          }
        }
      };
      function BranchChunk(children) {
        this.children = children;
        var size = 0, height = 0;
        for (var i2 = 0; i2 < children.length; ++i2) {
          var ch = children[i2];
          size += ch.chunkSize();
          height += ch.height;
          ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
      }
      BranchChunk.prototype = {
        chunkSize: function() {
          return this.size;
        },
        removeInner: function(at, n) {
          this.size -= n;
          for (var i2 = 0; i2 < this.children.length; ++i2) {
            var child = this.children[i2], sz = child.chunkSize();
            if (at < sz) {
              var rm = Math.min(n, sz - at), oldHeight = child.height;
              child.removeInner(at, rm);
              this.height -= oldHeight - child.height;
              if (sz == rm) {
                this.children.splice(i2--, 1);
                child.parent = null;
              }
              if ((n -= rm) == 0) {
                break;
              }
              at = 0;
            } else {
              at -= sz;
            }
          }
          if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },
        collapse: function(lines) {
          for (var i2 = 0; i2 < this.children.length; ++i2) {
            this.children[i2].collapse(lines);
          }
        },
        insertInner: function(at, lines, height) {
          this.size += lines.length;
          this.height += height;
          for (var i2 = 0; i2 < this.children.length; ++i2) {
            var child = this.children[i2], sz = child.chunkSize();
            if (at <= sz) {
              child.insertInner(at, lines, height);
              if (child.lines && child.lines.length > 50) {
                var remaining = child.lines.length % 25 + 25;
                for (var pos = remaining; pos < child.lines.length; ) {
                  var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                  child.height -= leaf.height;
                  this.children.splice(++i2, 0, leaf);
                  leaf.parent = this;
                }
                child.lines = child.lines.slice(0, remaining);
                this.maybeSpill();
              }
              break;
            }
            at -= sz;
          }
        },
        // When a node has grown, check whether it should be split.
        maybeSpill: function() {
          if (this.children.length <= 10) {
            return;
          }
          var me = this;
          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);
            if (!me.parent) {
              var copy2 = new BranchChunk(me.children);
              copy2.parent = me;
              me.children = [copy2, sibling];
              me = copy2;
            } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }
            sibling.parent = me.parent;
          } while (me.children.length > 10);
          me.parent.maybeSpill();
        },
        iterN: function(at, n, op) {
          for (var i2 = 0; i2 < this.children.length; ++i2) {
            var child = this.children[i2], sz = child.chunkSize();
            if (at < sz) {
              var used = Math.min(n, sz - at);
              if (child.iterN(at, used, op)) {
                return true;
              }
              if ((n -= used) == 0) {
                break;
              }
              at = 0;
            } else {
              at -= sz;
            }
          }
        }
      };
      var LineWidget = function(doc2, node, options) {
        if (options) {
          for (var opt in options) {
            if (options.hasOwnProperty(opt)) {
              this[opt] = options[opt];
            }
          }
        }
        this.doc = doc2;
        this.node = node;
      };
      LineWidget.prototype.clear = function() {
        var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
        if (no == null || !ws) {
          return;
        }
        for (var i2 = 0; i2 < ws.length; ++i2) {
          if (ws[i2] == this) {
            ws.splice(i2--, 1);
          }
        }
        if (!ws.length) {
          line.widgets = null;
        }
        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));
        if (cm) {
          runInOp(cm, function() {
            adjustScrollWhenAboveVisible(cm, line, -height);
            regLineChange(cm, no, "widget");
          });
          signalLater(cm, "lineWidgetCleared", cm, this, no);
        }
      };
      LineWidget.prototype.changed = function() {
        var this$1$1 = this;
        var oldH = this.height, cm = this.doc.cm, line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff) {
          return;
        }
        if (!lineIsHidden(this.doc, line)) {
          updateLineHeight(line, line.height + diff);
        }
        if (cm) {
          runInOp(cm, function() {
            cm.curOp.forceUpdate = true;
            adjustScrollWhenAboveVisible(cm, line, diff);
            signalLater(cm, "lineWidgetChanged", cm, this$1$1, lineNo(line));
          });
        }
      };
      eventMixin(LineWidget);
      function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
          addToScrollTop(cm, diff);
        }
      }
      function addLineWidget(doc2, handle, node, options) {
        var widget = new LineWidget(doc2, node, options);
        var cm = doc2.cm;
        if (cm && widget.noHScroll) {
          cm.display.alignWidgets = true;
        }
        changeLine(doc2, handle, "widget", function(line) {
          var widgets = line.widgets || (line.widgets = []);
          if (widget.insertAt == null) {
            widgets.push(widget);
          } else {
            widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
          }
          widget.line = line;
          if (cm && !lineIsHidden(doc2, line)) {
            var aboveVisible = heightAtLine(line) < doc2.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));
            if (aboveVisible) {
              addToScrollTop(cm, widget.height);
            }
            cm.curOp.forceUpdate = true;
          }
          return true;
        });
        if (cm) {
          signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
        }
        return widget;
      }
      var nextMarkerId = 0;
      var TextMarker = function(doc2, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc2;
        this.id = ++nextMarkerId;
      };
      TextMarker.prototype.clear = function() {
        if (this.explicitlyCleared) {
          return;
        }
        var cm = this.doc.cm, withOp = cm && !cm.curOp;
        if (withOp) {
          startOperation(cm);
        }
        if (hasHandler(this, "clear")) {
          var found = this.find();
          if (found) {
            signalLater(this, "clear", found.from, found.to);
          }
        }
        var min2 = null, max = null;
        for (var i2 = 0; i2 < this.lines.length; ++i2) {
          var line = this.lines[i2];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (cm && !this.collapsed) {
            regLineChange(cm, lineNo(line), "text");
          } else if (cm) {
            if (span.to != null) {
              max = lineNo(line);
            }
            if (span.from != null) {
              min2 = lineNo(line);
            }
          }
          line.markedSpans = removeMarkedSpan(line.markedSpans, span);
          if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
            updateLineHeight(line, textHeight(cm.display));
          }
        }
        if (cm && this.collapsed && !cm.options.lineWrapping) {
          for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
            var visual = visualLine(this.lines[i$12]), len2 = lineLength(visual);
            if (len2 > cm.display.maxLineLength) {
              cm.display.maxLine = visual;
              cm.display.maxLineLength = len2;
              cm.display.maxLineChanged = true;
            }
          }
        }
        if (min2 != null && cm && this.collapsed) {
          regChange(cm, min2, max + 1);
        }
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;
          if (cm) {
            reCheckSelection(cm.doc);
          }
        }
        if (cm) {
          signalLater(cm, "markerCleared", cm, this, min2, max);
        }
        if (withOp) {
          endOperation(cm);
        }
        if (this.parent) {
          this.parent.clear();
        }
      };
      TextMarker.prototype.find = function(side, lineObj) {
        if (side == null && this.type == "bookmark") {
          side = 1;
        }
        var from2, to;
        for (var i2 = 0; i2 < this.lines.length; ++i2) {
          var line = this.lines[i2];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (span.from != null) {
            from2 = Pos(lineObj ? line : lineNo(line), span.from);
            if (side == -1) {
              return from2;
            }
          }
          if (span.to != null) {
            to = Pos(lineObj ? line : lineNo(line), span.to);
            if (side == 1) {
              return to;
            }
          }
        }
        return from2 && { from: from2, to };
      };
      TextMarker.prototype.changed = function() {
        var this$1$1 = this;
        var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
        if (!pos || !cm) {
          return;
        }
        runInOp(cm, function() {
          var line = pos.line, lineN = lineNo(pos.line);
          var view = findViewForLine(cm, lineN);
          if (view) {
            clearLineMeasurementCacheFor(view);
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
          }
          cm.curOp.updateMaxLine = true;
          if (!lineIsHidden(widget.doc, line) && widget.height != null) {
            var oldHeight = widget.height;
            widget.height = null;
            var dHeight = widgetHeight(widget) - oldHeight;
            if (dHeight) {
              updateLineHeight(line, line.height + dHeight);
            }
          }
          signalLater(cm, "markerChanged", cm, this$1$1);
        });
      };
      TextMarker.prototype.attachLine = function(line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
            (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
          }
        }
        this.lines.push(line);
      };
      TextMarker.prototype.detachLine = function(line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };
      eventMixin(TextMarker);
      function markText(doc2, from2, to, options, type) {
        if (options && options.shared) {
          return markTextShared(doc2, from2, to, options, type);
        }
        if (doc2.cm && !doc2.cm.curOp) {
          return operation(doc2.cm, markText)(doc2, from2, to, options, type);
        }
        var marker = new TextMarker(doc2, type), diff = cmp(from2, to);
        if (options) {
          copyObj(options, marker, false);
        }
        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
          return marker;
        }
        if (marker.replacedWith) {
          marker.collapsed = true;
          marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
          if (!options.handleMouseEvents) {
            marker.widgetNode.setAttribute("cm-ignore-events", "true");
          }
          if (options.insertLeft) {
            marker.widgetNode.insertLeft = true;
          }
        }
        if (marker.collapsed) {
          if (conflictingCollapsedRange(doc2, from2.line, from2, to, marker) || from2.line != to.line && conflictingCollapsedRange(doc2, to.line, from2, to, marker)) {
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          }
          seeCollapsedSpans();
        }
        if (marker.addToHistory) {
          addChangeToHistory(doc2, { from: from2, to, origin: "markText" }, doc2.sel, NaN);
        }
        var curLine = from2.line, cm = doc2.cm, updateMaxLine;
        doc2.iter(curLine, to.line + 1, function(line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
            updateMaxLine = true;
          }
          if (marker.collapsed && curLine != from2.line) {
            updateLineHeight(line, 0);
          }
          addMarkedSpan(line, new MarkedSpan(
            marker,
            curLine == from2.line ? from2.ch : null,
            curLine == to.line ? to.ch : null
          ), doc2.cm && doc2.cm.curOp);
          ++curLine;
        });
        if (marker.collapsed) {
          doc2.iter(from2.line, to.line + 1, function(line) {
            if (lineIsHidden(doc2, line)) {
              updateLineHeight(line, 0);
            }
          });
        }
        if (marker.clearOnEnter) {
          on(marker, "beforeCursorEnter", function() {
            return marker.clear();
          });
        }
        if (marker.readOnly) {
          seeReadOnlySpans();
          if (doc2.history.done.length || doc2.history.undone.length) {
            doc2.clearHistory();
          }
        }
        if (marker.collapsed) {
          marker.id = ++nextMarkerId;
          marker.atomic = true;
        }
        if (cm) {
          if (updateMaxLine) {
            cm.curOp.updateMaxLine = true;
          }
          if (marker.collapsed) {
            regChange(cm, from2.line, to.line + 1);
          } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
            for (var i2 = from2.line; i2 <= to.line; i2++) {
              regLineChange(cm, i2, "text");
            }
          }
          if (marker.atomic) {
            reCheckSelection(cm.doc);
          }
          signalLater(cm, "markerAdded", cm, marker);
        }
        return marker;
      }
      var SharedTextMarker = function(markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for (var i2 = 0; i2 < markers.length; ++i2) {
          markers[i2].parent = this;
        }
      };
      SharedTextMarker.prototype.clear = function() {
        if (this.explicitlyCleared) {
          return;
        }
        this.explicitlyCleared = true;
        for (var i2 = 0; i2 < this.markers.length; ++i2) {
          this.markers[i2].clear();
        }
        signalLater(this, "clear");
      };
      SharedTextMarker.prototype.find = function(side, lineObj) {
        return this.primary.find(side, lineObj);
      };
      eventMixin(SharedTextMarker);
      function markTextShared(doc2, from2, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc2, from2, to, options, type)], primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc2, function(doc3) {
          if (widget) {
            options.widgetNode = widget.cloneNode(true);
          }
          markers.push(markText(doc3, clipPos(doc3, from2), clipPos(doc3, to), options, type));
          for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
            if (doc3.linked[i2].isParent) {
              return;
            }
          }
          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
      }
      function findSharedMarkers(doc2) {
        return doc2.findMarks(Pos(doc2.first, 0), doc2.clipPos(Pos(doc2.lastLine())), function(m) {
          return m.parent;
        });
      }
      function copySharedMarkers(doc2, markers) {
        for (var i2 = 0; i2 < markers.length; i2++) {
          var marker = markers[i2], pos = marker.find();
          var mFrom = doc2.clipPos(pos.from), mTo = doc2.clipPos(pos.to);
          if (cmp(mFrom, mTo)) {
            var subMark = markText(doc2, mFrom, mTo, marker.primary, marker.primary.type);
            marker.markers.push(subMark);
            subMark.parent = marker;
          }
        }
      }
      function detachSharedMarkers(markers) {
        var loop = function(i3) {
          var marker = markers[i3], linked = [marker.primary.doc];
          linkedDocs(marker.primary.doc, function(d) {
            return linked.push(d);
          });
          for (var j = 0; j < marker.markers.length; j++) {
            var subMarker = marker.markers[j];
            if (indexOf(linked, subMarker.doc) == -1) {
              subMarker.parent = null;
              marker.markers.splice(j--, 1);
            }
          }
        };
        for (var i2 = 0; i2 < markers.length; i2++) loop(i2);
      }
      var nextDocId = 0;
      var Doc = function(text, mode, firstLine, lineSep, direction) {
        if (!(this instanceof Doc)) {
          return new Doc(text, mode, firstLine, lineSep, direction);
        }
        if (firstLine == null) {
          firstLine = 0;
        }
        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.modeFrontier = this.highlightFrontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        this.direction = direction == "rtl" ? "rtl" : "ltr";
        this.extend = false;
        if (typeof text == "string") {
          text = this.splitLines(text);
        }
        updateDoc(this, { from: start, to: start, text });
        setSelection(this, simpleSelection(start), sel_dontScroll);
      };
      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        // Iterate over the document. Supports two forms -- with only one
        // argument, it calls that for each line in the document. With
        // three, it iterates over the range given by the first two (with
        // the second being non-inclusive).
        iter: function(from2, to, op) {
          if (op) {
            this.iterN(from2 - this.first, to - from2, op);
          } else {
            this.iterN(this.first, this.first + this.size, from2);
          }
        },
        // Non-public interface for adding and removing lines.
        insert: function(at, lines) {
          var height = 0;
          for (var i2 = 0; i2 < lines.length; ++i2) {
            height += lines[i2].height;
          }
          this.insertInner(at - this.first, lines, height);
        },
        remove: function(at, n) {
          this.removeInner(at - this.first, n);
        },
        // From here, the methods are part of the public interface. Most
        // are also available from CodeMirror (editor) instances.
        getValue: function(lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);
          if (lineSep === false) {
            return lines;
          }
          return lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function(code) {
          var top = Pos(this.first, 0), last = this.first + this.size - 1;
          makeChange(this, {
            from: top,
            to: Pos(last, getLine(this, last).text.length),
            text: this.splitLines(code),
            origin: "setValue",
            full: true
          }, true);
          if (this.cm) {
            scrollToCoords(this.cm, 0, 0);
          }
          setSelection(this, simpleSelection(top), sel_dontScroll);
        }),
        replaceRange: function(code, from2, to, origin) {
          from2 = clipPos(this, from2);
          to = to ? clipPos(this, to) : from2;
          replaceRange(this, code, from2, to, origin);
        },
        getRange: function(from2, to, lineSep) {
          var lines = getBetween(this, clipPos(this, from2), clipPos(this, to));
          if (lineSep === false) {
            return lines;
          }
          if (lineSep === "") {
            return lines.join("");
          }
          return lines.join(lineSep || this.lineSeparator());
        },
        getLine: function(line) {
          var l = this.getLineHandle(line);
          return l && l.text;
        },
        getLineHandle: function(line) {
          if (isLine(this, line)) {
            return getLine(this, line);
          }
        },
        getLineNumber: function(line) {
          return lineNo(line);
        },
        getLineHandleVisualStart: function(line) {
          if (typeof line == "number") {
            line = getLine(this, line);
          }
          return visualLine(line);
        },
        lineCount: function() {
          return this.size;
        },
        firstLine: function() {
          return this.first;
        },
        lastLine: function() {
          return this.first + this.size - 1;
        },
        clipPos: function(pos) {
          return clipPos(this, pos);
        },
        getCursor: function(start) {
          var range2 = this.sel.primary(), pos;
          if (start == null || start == "head") {
            pos = range2.head;
          } else if (start == "anchor") {
            pos = range2.anchor;
          } else if (start == "end" || start == "to" || start === false) {
            pos = range2.to();
          } else {
            pos = range2.from();
          }
          return pos;
        },
        listSelections: function() {
          return this.sel.ranges;
        },
        somethingSelected: function() {
          return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function(line, ch, options) {
          setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function(anchor, head, options) {
          setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function(head, other, options) {
          extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function(heads, options) {
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function(f, options) {
          var heads = map2(this.sel.ranges, f);
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        setSelections: docMethodOp(function(ranges, primary, options) {
          if (!ranges.length) {
            return;
          }
          var out = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            out[i2] = new Range(
              clipPos(this, ranges[i2].anchor),
              clipPos(this, ranges[i2].head || ranges[i2].anchor)
            );
          }
          if (primary == null) {
            primary = Math.min(ranges.length - 1, this.sel.primIndex);
          }
          setSelection(this, normalizeSelection(this.cm, out, primary), options);
        }),
        addSelection: docMethodOp(function(anchor, head, options) {
          var ranges = this.sel.ranges.slice(0);
          ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
          setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
        }),
        getSelection: function(lineSep) {
          var ranges = this.sel.ranges, lines;
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
            lines = lines ? lines.concat(sel) : sel;
          }
          if (lineSep === false) {
            return lines;
          } else {
            return lines.join(lineSep || this.lineSeparator());
          }
        },
        getSelections: function(lineSep) {
          var parts = [], ranges = this.sel.ranges;
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
            if (lineSep !== false) {
              sel = sel.join(lineSep || this.lineSeparator());
            }
            parts[i2] = sel;
          }
          return parts;
        },
        replaceSelection: function(code, collapse, origin) {
          var dup = [];
          for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
            dup[i2] = code;
          }
          this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function(code, collapse, origin) {
          var changes = [], sel = this.sel;
          for (var i2 = 0; i2 < sel.ranges.length; i2++) {
            var range2 = sel.ranges[i2];
            changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };
          }
          var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
          for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
            makeChange(this, changes[i$12]);
          }
          if (newSel) {
            setSelectionReplaceHistory(this, newSel);
          } else if (this.cm) {
            ensureCursorVisible(this.cm);
          }
        }),
        undo: docMethodOp(function() {
          makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function() {
          makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function() {
          makeChangeFromHistory(this, "undo", true);
        }),
        redoSelection: docMethodOp(function() {
          makeChangeFromHistory(this, "redo", true);
        }),
        setExtending: function(val) {
          this.extend = val;
        },
        getExtending: function() {
          return this.extend;
        },
        historySize: function() {
          var hist = this.history, done = 0, undone = 0;
          for (var i2 = 0; i2 < hist.done.length; i2++) {
            if (!hist.done[i2].ranges) {
              ++done;
            }
          }
          for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
            if (!hist.undone[i$12].ranges) {
              ++undone;
            }
          }
          return { undo: done, redo: undone };
        },
        clearHistory: function() {
          var this$1$1 = this;
          this.history = new History(this.history);
          linkedDocs(this, function(doc2) {
            return doc2.history = this$1$1.history;
          }, true);
        },
        markClean: function() {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function(forceSplit) {
          if (forceSplit) {
            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
          }
          return this.history.generation;
        },
        isClean: function(gen) {
          return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function() {
          return {
            done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)
          };
        },
        setHistory: function(histData) {
          var hist = this.history = new History(this.history);
          hist.done = copyHistoryArray(histData.done.slice(0), null, true);
          hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        setGutterMarker: docMethodOp(function(line, gutterID, value) {
          return changeLine(this, line, "gutter", function(line2) {
            var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
            markers[gutterID] = value;
            if (!value && isEmpty(markers)) {
              line2.gutterMarkers = null;
            }
            return true;
          });
        }),
        clearGutter: docMethodOp(function(gutterID) {
          var this$1$1 = this;
          this.iter(function(line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              changeLine(this$1$1, line, "gutter", function() {
                line.gutterMarkers[gutterID] = null;
                if (isEmpty(line.gutterMarkers)) {
                  line.gutterMarkers = null;
                }
                return true;
              });
            }
          });
        }),
        lineInfo: function(line) {
          var n;
          if (typeof line == "number") {
            if (!isLine(this, line)) {
              return null;
            }
            n = line;
            line = getLine(this, line);
            if (!line) {
              return null;
            }
          } else {
            n = lineNo(line);
            if (n == null) {
              return null;
            }
          }
          return {
            line: n,
            handle: line,
            text: line.text,
            gutterMarkers: line.gutterMarkers,
            textClass: line.textClass,
            bgClass: line.bgClass,
            wrapClass: line.wrapClass,
            widgets: line.widgets
          };
        },
        addLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
            var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            if (!line[prop2]) {
              line[prop2] = cls;
            } else if (classTest(cls).test(line[prop2])) {
              return false;
            } else {
              line[prop2] += " " + cls;
            }
            return true;
          });
        }),
        removeLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
            var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            var cur = line[prop2];
            if (!cur) {
              return false;
            } else if (cls == null) {
              line[prop2] = null;
            } else {
              var found = cur.match(classTest(cls));
              if (!found) {
                return false;
              }
              var end = found.index + found[0].length;
              line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }
            return true;
          });
        }),
        addLineWidget: docMethodOp(function(handle, node, options) {
          return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function(widget) {
          widget.clear();
        },
        markText: function(from2, to, options) {
          return markText(this, clipPos(this, from2), clipPos(this, to), options, options && options.type || "range");
        },
        setBookmark: function(pos, options) {
          var realOpts = {
            replacedWith: options && (options.nodeType == null ? options.widget : options),
            insertLeft: options && options.insertLeft,
            clearWhenEmpty: false,
            shared: options && options.shared,
            handleMouseEvents: options && options.handleMouseEvents
          };
          pos = clipPos(this, pos);
          return markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function(pos) {
          pos = clipPos(this, pos);
          var markers = [], spans = getLine(this, pos.line).markedSpans;
          if (spans) {
            for (var i2 = 0; i2 < spans.length; ++i2) {
              var span = spans[i2];
              if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                markers.push(span.marker.parent || span.marker);
              }
            }
          }
          return markers;
        },
        findMarks: function(from2, to, filter) {
          from2 = clipPos(this, from2);
          to = clipPos(this, to);
          var found = [], lineNo2 = from2.line;
          this.iter(from2.line, to.line + 1, function(line) {
            var spans = line.markedSpans;
            if (spans) {
              for (var i2 = 0; i2 < spans.length; i2++) {
                var span = spans[i2];
                if (!(span.to != null && lineNo2 == from2.line && from2.ch >= span.to || span.from == null && lineNo2 != from2.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                  found.push(span.marker.parent || span.marker);
                }
              }
            }
            ++lineNo2;
          });
          return found;
        },
        getAllMarks: function() {
          var markers = [];
          this.iter(function(line) {
            var sps = line.markedSpans;
            if (sps) {
              for (var i2 = 0; i2 < sps.length; ++i2) {
                if (sps[i2].from != null) {
                  markers.push(sps[i2].marker);
                }
              }
            }
          });
          return markers;
        },
        posFromIndex: function(off2) {
          var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
          this.iter(function(line) {
            var sz = line.text.length + sepSize;
            if (sz > off2) {
              ch = off2;
              return true;
            }
            off2 -= sz;
            ++lineNo2;
          });
          return clipPos(this, Pos(lineNo2, ch));
        },
        indexFromPos: function(coords) {
          coords = clipPos(this, coords);
          var index2 = coords.ch;
          if (coords.line < this.first || coords.ch < 0) {
            return 0;
          }
          var sepSize = this.lineSeparator().length;
          this.iter(this.first, coords.line, function(line) {
            index2 += line.text.length + sepSize;
          });
          return index2;
        },
        copy: function(copyHistory) {
          var doc2 = new Doc(
            getLines(this, this.first, this.first + this.size),
            this.modeOption,
            this.first,
            this.lineSep,
            this.direction
          );
          doc2.scrollTop = this.scrollTop;
          doc2.scrollLeft = this.scrollLeft;
          doc2.sel = this.sel;
          doc2.extend = false;
          if (copyHistory) {
            doc2.history.undoDepth = this.history.undoDepth;
            doc2.setHistory(this.getHistory());
          }
          return doc2;
        },
        linkedDoc: function(options) {
          if (!options) {
            options = {};
          }
          var from2 = this.first, to = this.first + this.size;
          if (options.from != null && options.from > from2) {
            from2 = options.from;
          }
          if (options.to != null && options.to < to) {
            to = options.to;
          }
          var copy2 = new Doc(getLines(this, from2, to), options.mode || this.modeOption, from2, this.lineSep, this.direction);
          if (options.sharedHist) {
            copy2.history = this.history;
          }
          (this.linked || (this.linked = [])).push({ doc: copy2, sharedHist: options.sharedHist });
          copy2.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
          copySharedMarkers(copy2, findSharedMarkers(this));
          return copy2;
        },
        unlinkDoc: function(other) {
          if (other instanceof CodeMirror2) {
            other = other.doc;
          }
          if (this.linked) {
            for (var i2 = 0; i2 < this.linked.length; ++i2) {
              var link = this.linked[i2];
              if (link.doc != other) {
                continue;
              }
              this.linked.splice(i2, 1);
              other.unlinkDoc(this);
              detachSharedMarkers(findSharedMarkers(this));
              break;
            }
          }
          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function(doc2) {
              return splitIds.push(doc2.id);
            }, true);
            other.history = new History(null);
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function(f) {
          linkedDocs(this, f);
        },
        getMode: function() {
          return this.mode;
        },
        getEditor: function() {
          return this.cm;
        },
        splitLines: function(str) {
          if (this.lineSep) {
            return str.split(this.lineSep);
          }
          return splitLinesAuto(str);
        },
        lineSeparator: function() {
          return this.lineSep || "\n";
        },
        setDirection: docMethodOp(function(dir) {
          if (dir != "rtl") {
            dir = "ltr";
          }
          if (dir == this.direction) {
            return;
          }
          this.direction = dir;
          this.iter(function(line) {
            return line.order = null;
          });
          if (this.cm) {
            directionChanged(this.cm);
          }
        })
      });
      Doc.prototype.eachLine = Doc.prototype.iter;
      var lastDrop = 0;
      function onDrop(e) {
        var cm = this;
        clearDragCursor(cm);
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e_preventDefault(e);
        if (ie) {
          lastDrop = +/* @__PURE__ */ new Date();
        }
        var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
        if (!pos || cm.isReadOnly()) {
          return;
        }
        if (files && files.length && window.FileReader && window.File) {
          var n = files.length, text = Array(n), read = 0;
          var markAsReadAndPasteIfAllFilesAreRead = function() {
            if (++read == n) {
              operation(cm, function() {
                pos = clipPos(cm.doc, pos);
                var change = {
                  from: pos,
                  to: pos,
                  text: cm.doc.splitLines(
                    text.filter(function(t) {
                      return t != null;
                    }).join(cm.doc.lineSeparator())
                  ),
                  origin: "paste"
                };
                makeChange(cm.doc, change);
                setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
              })();
            }
          };
          var readTextFromFile = function(file, i3) {
            if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
              markAsReadAndPasteIfAllFilesAreRead();
              return;
            }
            var reader = new FileReader();
            reader.onerror = function() {
              return markAsReadAndPasteIfAllFilesAreRead();
            };
            reader.onload = function() {
              var content = reader.result;
              if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                markAsReadAndPasteIfAllFilesAreRead();
                return;
              }
              text[i3] = content;
              markAsReadAndPasteIfAllFilesAreRead();
            };
            reader.readAsText(file);
          };
          for (var i2 = 0; i2 < files.length; i2++) {
            readTextFromFile(files[i2], i2);
          }
        } else {
          if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
            cm.state.draggingText(e);
            setTimeout(function() {
              return cm.display.input.focus();
            }, 20);
            return;
          }
          try {
            var text$1 = e.dataTransfer.getData("Text");
            if (text$1) {
              var selected;
              if (cm.state.draggingText && !cm.state.draggingText.copy) {
                selected = cm.listSelections();
              }
              setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
              if (selected) {
                for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                  replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
                }
              }
              cm.replaceSelection(text$1, "around", "paste");
              cm.display.input.focus();
            }
          } catch (e$1) {
          }
        }
      }
      function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +/* @__PURE__ */ new Date() - lastDrop < 100)) {
          e_stop(e);
          return;
        }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e.dataTransfer.setData("Text", cm.getSelection());
        e.dataTransfer.effectAllowed = "copyMove";
        if (e.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (presto) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img);
            img._top = img.offsetTop;
          }
          e.dataTransfer.setDragImage(img, 0, 0);
          if (presto) {
            img.parentNode.removeChild(img);
          }
        }
      }
      function onDragOver(cm, e) {
        var pos = posFromMouse(cm, e);
        if (!pos) {
          return;
        }
        var frag = document.createDocumentFragment();
        drawSelectionCursor(cm, pos, frag);
        if (!cm.display.dragCursor) {
          cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
          cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }
        removeChildrenAndAdd(cm.display.dragCursor, frag);
      }
      function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
          cm.display.lineSpace.removeChild(cm.display.dragCursor);
          cm.display.dragCursor = null;
        }
      }
      function forEachCodeMirror(f) {
        if (!document.getElementsByClassName) {
          return;
        }
        var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
        for (var i2 = 0; i2 < byClass.length; i2++) {
          var cm = byClass[i2].CodeMirror;
          if (cm) {
            editors.push(cm);
          }
        }
        if (editors.length) {
          editors[0].operation(function() {
            for (var i3 = 0; i3 < editors.length; i3++) {
              f(editors[i3]);
            }
          });
        }
      }
      var globalsRegistered = false;
      function ensureGlobalHandlers() {
        if (globalsRegistered) {
          return;
        }
        registerGlobalHandlers();
        globalsRegistered = true;
      }
      function registerGlobalHandlers() {
        var resizeTimer;
        on(window, "resize", function() {
          if (resizeTimer == null) {
            resizeTimer = setTimeout(function() {
              resizeTimer = null;
              forEachCodeMirror(onResize);
            }, 100);
          }
        });
        on(window, "blur", function() {
          return forEachCodeMirror(onBlur);
        });
      }
      function onResize(cm) {
        var d = cm.display;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
      }
      var keyNames = {
        3: "Pause",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        145: "ScrollLock",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        224: "Mod",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      };
      for (var i = 0; i < 10; i++) {
        keyNames[i + 48] = keyNames[i + 96] = String(i);
      }
      for (var i$1 = 65; i$1 <= 90; i$1++) {
        keyNames[i$1] = String.fromCharCode(i$1);
      }
      for (var i$2 = 1; i$2 <= 12; i$2++) {
        keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
      }
      var keyMap2 = {};
      keyMap2.basic = {
        "Left": "goCharLeft",
        "Right": "goCharRight",
        "Up": "goLineUp",
        "Down": "goLineDown",
        "End": "goLineEnd",
        "Home": "goLineStartSmart",
        "PageUp": "goPageUp",
        "PageDown": "goPageDown",
        "Delete": "delCharAfter",
        "Backspace": "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab",
        "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent",
        "Insert": "toggleOverwrite",
        "Esc": "singleSelection"
      };
      keyMap2.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        "fallthrough": "basic"
      };
      keyMap2.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
      };
      keyMap2.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        "fallthrough": ["basic", "emacsy"]
      };
      keyMap2["default"] = mac ? keyMap2.macDefault : keyMap2.pcDefault;
      function normalizeKeyName(name2) {
        var parts = name2.split(/-(?!$)/);
        name2 = parts[parts.length - 1];
        var alt, ctrl, shift, cmd;
        for (var i2 = 0; i2 < parts.length - 1; i2++) {
          var mod = parts[i2];
          if (/^(cmd|meta|m)$/i.test(mod)) {
            cmd = true;
          } else if (/^a(lt)?$/i.test(mod)) {
            alt = true;
          } else if (/^(c|ctrl|control)$/i.test(mod)) {
            ctrl = true;
          } else if (/^s(hift)?$/i.test(mod)) {
            shift = true;
          } else {
            throw new Error("Unrecognized modifier name: " + mod);
          }
        }
        if (alt) {
          name2 = "Alt-" + name2;
        }
        if (ctrl) {
          name2 = "Ctrl-" + name2;
        }
        if (cmd) {
          name2 = "Cmd-" + name2;
        }
        if (shift) {
          name2 = "Shift-" + name2;
        }
        return name2;
      }
      function normalizeKeyMap(keymap) {
        var copy2 = {};
        for (var keyname in keymap) {
          if (keymap.hasOwnProperty(keyname)) {
            var value = keymap[keyname];
            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
              continue;
            }
            if (value == "...") {
              delete keymap[keyname];
              continue;
            }
            var keys2 = map2(keyname.split(" "), normalizeKeyName);
            for (var i2 = 0; i2 < keys2.length; i2++) {
              var val = void 0, name2 = void 0;
              if (i2 == keys2.length - 1) {
                name2 = keys2.join(" ");
                val = value;
              } else {
                name2 = keys2.slice(0, i2 + 1).join(" ");
                val = "...";
              }
              var prev = copy2[name2];
              if (!prev) {
                copy2[name2] = val;
              } else if (prev != val) {
                throw new Error("Inconsistent bindings for " + name2);
              }
            }
            delete keymap[keyname];
          }
        }
        for (var prop2 in copy2) {
          keymap[prop2] = copy2[prop2];
        }
        return keymap;
      }
      function lookupKey(key, map3, handle, context) {
        map3 = getKeyMap(map3);
        var found = map3.call ? map3.call(key, context) : map3[key];
        if (found === false) {
          return "nothing";
        }
        if (found === "...") {
          return "multi";
        }
        if (found != null && handle(found)) {
          return "handled";
        }
        if (map3.fallthrough) {
          if (Object.prototype.toString.call(map3.fallthrough) != "[object Array]") {
            return lookupKey(key, map3.fallthrough, handle, context);
          }
          for (var i2 = 0; i2 < map3.fallthrough.length; i2++) {
            var result = lookupKey(key, map3.fallthrough[i2], handle, context);
            if (result) {
              return result;
            }
          }
        }
      }
      function isModifierKey(value) {
        var name2 = typeof value == "string" ? value : keyNames[value.keyCode];
        return name2 == "Ctrl" || name2 == "Alt" || name2 == "Shift" || name2 == "Mod";
      }
      function addModifierNames(name2, event, noShift) {
        var base = name2;
        if (event.altKey && base != "Alt") {
          name2 = "Alt-" + name2;
        }
        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
          name2 = "Ctrl-" + name2;
        }
        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
          name2 = "Cmd-" + name2;
        }
        if (!noShift && event.shiftKey && base != "Shift") {
          name2 = "Shift-" + name2;
        }
        return name2;
      }
      function keyName(event, noShift) {
        if (presto && event.keyCode == 34 && event["char"]) {
          return false;
        }
        var name2 = keyNames[event.keyCode];
        if (name2 == null || event.altGraphKey) {
          return false;
        }
        if (event.keyCode == 3 && event.code) {
          name2 = event.code;
        }
        return addModifierNames(name2, event, noShift);
      }
      function getKeyMap(val) {
        return typeof val == "string" ? keyMap2[val] : val;
      }
      function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges, kill = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var toKill = compute(ranges[i2]);
          while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
            var replaced = kill.pop();
            if (cmp(replaced.from, toKill.from) < 0) {
              toKill.from = replaced.from;
              break;
            }
          }
          kill.push(toKill);
        }
        runInOp(cm, function() {
          for (var i3 = kill.length - 1; i3 >= 0; i3--) {
            replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");
          }
          ensureCursorVisible(cm);
        });
      }
      function moveCharLogically(line, ch, dir) {
        var target = skipExtendingChars(line.text, ch + dir, dir);
        return target < 0 || target > line.text.length ? null : target;
      }
      function moveLogically(line, start, dir) {
        var ch = moveCharLogically(line, start.ch, dir);
        return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
      }
      function endOfLine(visually, cm, lineObj, lineNo2, dir) {
        if (visually) {
          if (cm.doc.direction == "rtl") {
            dir = -dir;
          }
          var order = getOrder(lineObj, cm.doc.direction);
          if (order) {
            var part = dir < 0 ? lst(order) : order[0];
            var moveInStorageOrder = dir < 0 == (part.level == 1);
            var sticky = moveInStorageOrder ? "after" : "before";
            var ch;
            if (part.level > 0 || cm.doc.direction == "rtl") {
              var prep = prepareMeasureForLine(cm, lineObj);
              ch = dir < 0 ? lineObj.text.length - 1 : 0;
              var targetTop = measureCharPrepared(cm, prep, ch).top;
              ch = findFirst(function(ch2) {
                return measureCharPrepared(cm, prep, ch2).top == targetTop;
              }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
              if (sticky == "before") {
                ch = moveCharLogically(lineObj, ch, 1);
              }
            } else {
              ch = dir < 0 ? part.to : part.from;
            }
            return new Pos(lineNo2, ch, sticky);
          }
        }
        return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
      }
      function moveVisually(cm, line, start, dir) {
        var bidi = getOrder(line, cm.doc.direction);
        if (!bidi) {
          return moveLogically(line, start, dir);
        }
        if (start.ch >= line.text.length) {
          start.ch = line.text.length;
          start.sticky = "before";
        } else if (start.ch <= 0) {
          start.ch = 0;
          start.sticky = "after";
        }
        var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
        if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
          return moveLogically(line, start, dir);
        }
        var mv = function(pos, dir2) {
          return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
        };
        var prep;
        var getWrappedLineExtent = function(ch2) {
          if (!cm.options.lineWrapping) {
            return { begin: 0, end: line.text.length };
          }
          prep = prep || prepareMeasureForLine(cm, line);
          return wrappedLineExtentChar(cm, line, prep, ch2);
        };
        var wrappedLineExtent2 = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
        if (cm.doc.direction == "rtl" || part.level == 1) {
          var moveInStorageOrder = part.level == 1 == dir < 0;
          var ch = mv(start, moveInStorageOrder ? 1 : -1);
          if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
            var sticky = moveInStorageOrder ? "before" : "after";
            return new Pos(start.line, ch, sticky);
          }
        }
        var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
          var getRes = function(ch3, moveInStorageOrder3) {
            return moveInStorageOrder3 ? new Pos(start.line, mv(ch3, 1), "before") : new Pos(start.line, ch3, "after");
          };
          for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
            var part2 = bidi[partPos2];
            var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
            var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
            if (part2.from <= ch2 && ch2 < part2.to) {
              return getRes(ch2, moveInStorageOrder2);
            }
            ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
            if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
              return getRes(ch2, moveInStorageOrder2);
            }
          }
        };
        var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
        if (res) {
          return res;
        }
        var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
          res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
          if (res) {
            return res;
          }
        }
        return null;
      }
      var commands = {
        selectAll,
        singleSelection: function(cm) {
          return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            if (range2.empty()) {
              var len2 = getLine(cm.doc, range2.head.line).text.length;
              if (range2.head.ch == len2 && range2.head.line < cm.lastLine()) {
                return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
              } else {
                return { from: range2.head, to: Pos(range2.head.line, len2) };
              }
            } else {
              return { from: range2.from(), to: range2.to() };
            }
          });
        },
        deleteLine: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            return {
              from: Pos(range2.from().line, 0),
              to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            return {
              from: Pos(range2.from().line, 0),
              to: range2.from()
            };
          });
        },
        delWrappedLineLeft: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            var top = cm.charCoords(range2.head, "div").top + 5;
            var leftPos = cm.coordsChar({ left: 0, top }, "div");
            return { from: leftPos, to: range2.from() };
          });
        },
        delWrappedLineRight: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            var top = cm.charCoords(range2.head, "div").top + 5;
            var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
            return { from: range2.from(), to: rightPos };
          });
        },
        undo: function(cm) {
          return cm.undo();
        },
        redo: function(cm) {
          return cm.redo();
        },
        undoSelection: function(cm) {
          return cm.undoSelection();
        },
        redoSelection: function(cm) {
          return cm.redoSelection();
        },
        goDocStart: function(cm) {
          return cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function(cm) {
          return cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function(cm) {
          return cm.extendSelectionsBy(
            function(range2) {
              return lineStart(cm, range2.head.line);
            },
            { origin: "+move", bias: 1 }
          );
        },
        goLineStartSmart: function(cm) {
          return cm.extendSelectionsBy(
            function(range2) {
              return lineStartSmart(cm, range2.head);
            },
            { origin: "+move", bias: 1 }
          );
        },
        goLineEnd: function(cm) {
          return cm.extendSelectionsBy(
            function(range2) {
              return lineEnd(cm, range2.head.line);
            },
            { origin: "+move", bias: -1 }
          );
        },
        goLineRight: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            var top = cm.cursorCoords(range2.head, "div").top + 5;
            return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
          }, sel_move);
        },
        goLineLeft: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            var top = cm.cursorCoords(range2.head, "div").top + 5;
            return cm.coordsChar({ left: 0, top }, "div");
          }, sel_move);
        },
        goLineLeftSmart: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            var top = cm.cursorCoords(range2.head, "div").top + 5;
            var pos = cm.coordsChar({ left: 0, top }, "div");
            if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
              return lineStartSmart(cm, range2.head);
            }
            return pos;
          }, sel_move);
        },
        goLineUp: function(cm) {
          return cm.moveV(-1, "line");
        },
        goLineDown: function(cm) {
          return cm.moveV(1, "line");
        },
        goPageUp: function(cm) {
          return cm.moveV(-1, "page");
        },
        goPageDown: function(cm) {
          return cm.moveV(1, "page");
        },
        goCharLeft: function(cm) {
          return cm.moveH(-1, "char");
        },
        goCharRight: function(cm) {
          return cm.moveH(1, "char");
        },
        goColumnLeft: function(cm) {
          return cm.moveH(-1, "column");
        },
        goColumnRight: function(cm) {
          return cm.moveH(1, "column");
        },
        goWordLeft: function(cm) {
          return cm.moveH(-1, "word");
        },
        goGroupRight: function(cm) {
          return cm.moveH(1, "group");
        },
        goGroupLeft: function(cm) {
          return cm.moveH(-1, "group");
        },
        goWordRight: function(cm) {
          return cm.moveH(1, "word");
        },
        delCharBefore: function(cm) {
          return cm.deleteH(-1, "codepoint");
        },
        delCharAfter: function(cm) {
          return cm.deleteH(1, "char");
        },
        delWordBefore: function(cm) {
          return cm.deleteH(-1, "word");
        },
        delWordAfter: function(cm) {
          return cm.deleteH(1, "word");
        },
        delGroupBefore: function(cm) {
          return cm.deleteH(-1, "group");
        },
        delGroupAfter: function(cm) {
          return cm.deleteH(1, "group");
        },
        indentAuto: function(cm) {
          return cm.indentSelection("smart");
        },
        indentMore: function(cm) {
          return cm.indentSelection("add");
        },
        indentLess: function(cm) {
          return cm.indentSelection("subtract");
        },
        insertTab: function(cm) {
          return cm.replaceSelection("	");
        },
        insertSoftTab: function(cm) {
          var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var pos = ranges[i2].from();
            var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
            spaces.push(spaceStr(tabSize - col % tabSize));
          }
          cm.replaceSelections(spaces);
        },
        defaultTab: function(cm) {
          if (cm.somethingSelected()) {
            cm.indentSelection("add");
          } else {
            cm.execCommand("insertTab");
          }
        },
        // Swap the two chars left and right of each selection's head.
        // Move cursor behind the two swapped characters afterwards.
        //
        // Doesn't consider line feeds a character.
        // Doesn't scan more than one line above to find a character.
        // Doesn't do anything on an empty line.
        // Doesn't do anything with non-empty selections.
        transposeChars: function(cm) {
          return runInOp(cm, function() {
            var ranges = cm.listSelections(), newSel = [];
            for (var i2 = 0; i2 < ranges.length; i2++) {
              if (!ranges[i2].empty()) {
                continue;
              }
              var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
              if (line) {
                if (cur.ch == line.length) {
                  cur = new Pos(cur.line, cur.ch - 1);
                }
                if (cur.ch > 0) {
                  cur = new Pos(cur.line, cur.ch + 1);
                  cm.replaceRange(
                    line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                    Pos(cur.line, cur.ch - 2),
                    cur,
                    "+transpose"
                  );
                } else if (cur.line > cm.doc.first) {
                  var prev = getLine(cm.doc, cur.line - 1).text;
                  if (prev) {
                    cur = new Pos(cur.line, 1);
                    cm.replaceRange(
                      line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1),
                      Pos(cur.line - 1, prev.length - 1),
                      cur,
                      "+transpose"
                    );
                  }
                }
              }
              newSel.push(new Range(cur, cur));
            }
            cm.setSelections(newSel);
          });
        },
        newlineAndIndent: function(cm) {
          return runInOp(cm, function() {
            var sels = cm.listSelections();
            for (var i2 = sels.length - 1; i2 >= 0; i2--) {
              cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
            }
            sels = cm.listSelections();
            for (var i$12 = 0; i$12 < sels.length; i$12++) {
              cm.indentLine(sels[i$12].from().line, null, true);
            }
            ensureCursorVisible(cm);
          });
        },
        openLine: function(cm) {
          return cm.replaceSelection("\n", "start");
        },
        toggleOverwrite: function(cm) {
          return cm.toggleOverwrite();
        }
      };
      function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);
        if (visual != line) {
          lineN = lineNo(visual);
        }
        return endOfLine(true, cm, visual, lineN, 1);
      }
      function lineEnd(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLineEnd(line);
        if (visual != line) {
          lineN = lineNo(visual);
        }
        return endOfLine(true, cm, line, lineN, -1);
      }
      function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line, cm.doc.direction);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
          var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
        }
        return start;
      }
      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];
          if (!bound) {
            return false;
          }
        }
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift, done = false;
        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }
          if (dropShift) {
            cm.display.shift = false;
          }
          done = bound(cm) != Pass;
        } finally {
          cm.display.shift = prevShift;
          cm.state.suppressEdits = false;
        }
        return done;
      }
      function lookupKeyForEditor(cm, name2, handle) {
        for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
          var result = lookupKey(name2, cm.state.keyMaps[i2], handle, cm);
          if (result) {
            return result;
          }
        }
        return cm.options.extraKeys && lookupKey(name2, cm.options.extraKeys, handle, cm) || lookupKey(name2, cm.options.keyMap, handle, cm);
      }
      var stopSeq = new Delayed();
      function dispatchKey(cm, name2, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
          if (isModifierKey(name2)) {
            return "handled";
          }
          if (/\'$/.test(name2)) {
            cm.state.keySeq = null;
          } else {
            stopSeq.set(50, function() {
              if (cm.state.keySeq == seq) {
                cm.state.keySeq = null;
                cm.display.input.reset();
              }
            });
          }
          if (dispatchKeyInner(cm, seq + " " + name2, e, handle)) {
            return true;
          }
        }
        return dispatchKeyInner(cm, name2, e, handle);
      }
      function dispatchKeyInner(cm, name2, e, handle) {
        var result = lookupKeyForEditor(cm, name2, handle);
        if (result == "multi") {
          cm.state.keySeq = name2;
        }
        if (result == "handled") {
          signalLater(cm, "keyHandled", cm, name2, e);
        }
        if (result == "handled" || result == "multi") {
          e_preventDefault(e);
          restartBlink(cm);
        }
        return !!result;
      }
      function handleKeyBinding(cm, e) {
        var name2 = keyName(e, true);
        if (!name2) {
          return false;
        }
        if (e.shiftKey && !cm.state.keySeq) {
          return dispatchKey(cm, "Shift-" + name2, e, function(b) {
            return doHandleBinding(cm, b, true);
          }) || dispatchKey(cm, name2, e, function(b) {
            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
              return doHandleBinding(cm, b);
            }
          });
        } else {
          return dispatchKey(cm, name2, e, function(b) {
            return doHandleBinding(cm, b);
          });
        }
      }
      function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function(b) {
          return doHandleBinding(cm, b, true);
        });
      }
      var lastStoppedKey = null;
      function onKeyDown(e) {
        var cm = this;
        if (e.target && e.target != cm.display.input.getField()) {
          return;
        }
        cm.curOp.focus = activeElt(root(cm));
        if (signalDOMEvent(cm, e)) {
          return;
        }
        if (ie && ie_version < 11 && e.keyCode == 27) {
          e.returnValue = false;
        }
        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);
        if (presto) {
          lastStoppedKey = handled ? code : null;
          if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
            cm.replaceSelection("", null, "cut");
          }
        }
        if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
          document.execCommand("cut");
        }
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
          showCrossHair(cm);
        }
      }
      function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair");
        function up(e) {
          if (e.keyCode == 18 || !e.altKey) {
            rmClass(lineDiv, "CodeMirror-crosshair");
            off(document, "keyup", up);
            off(document, "mouseover", up);
          }
        }
        on(document, "keyup", up);
        on(document, "mouseover", up);
      }
      function onKeyUp(e) {
        if (e.keyCode == 16) {
          this.doc.sel.shift = false;
        }
        signalDOMEvent(this, e);
      }
      function onKeyPress(e) {
        var cm = this;
        if (e.target && e.target != cm.display.input.getField()) {
          return;
        }
        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
          return;
        }
        var keyCode = e.keyCode, charCode = e.charCode;
        if (presto && keyCode == lastStoppedKey) {
          lastStoppedKey = null;
          e_preventDefault(e);
          return;
        }
        if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
          return;
        }
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (ch == "\b") {
          return;
        }
        if (handleCharBinding(cm, e, ch)) {
          return;
        }
        cm.display.input.onKeyPress(e);
      }
      var DOUBLECLICK_DELAY = 400;
      var PastClick = function(time, pos, button) {
        this.time = time;
        this.pos = pos;
        this.button = button;
      };
      PastClick.prototype.compare = function(time, pos, button) {
        return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
      };
      var lastClick, lastDoubleClick;
      function clickRepeat(pos, button) {
        var now = +/* @__PURE__ */ new Date();
        if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
          lastClick = lastDoubleClick = null;
          return "triple";
        } else if (lastClick && lastClick.compare(now, pos, button)) {
          lastDoubleClick = new PastClick(now, pos, button);
          lastClick = null;
          return "double";
        } else {
          lastClick = new PastClick(now, pos, button);
          lastDoubleClick = null;
          return "single";
        }
      }
      function onMouseDown(e) {
        var cm = this, display = cm.display;
        if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
          return;
        }
        display.input.ensurePolled();
        display.shift = e.shiftKey;
        if (eventInWidget(display, e)) {
          if (!webkit) {
            display.scroller.draggable = false;
            setTimeout(function() {
              return display.scroller.draggable = true;
            }, 100);
          }
          return;
        }
        if (clickInGutter(cm, e)) {
          return;
        }
        var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
        win(cm).focus();
        if (button == 1 && cm.state.selectingText) {
          cm.state.selectingText(e);
        }
        if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
          return;
        }
        if (button == 1) {
          if (pos) {
            leftButtonDown(cm, pos, repeat, e);
          } else if (e_target(e) == display.scroller) {
            e_preventDefault(e);
          }
        } else if (button == 2) {
          if (pos) {
            extendSelection(cm.doc, pos);
          }
          setTimeout(function() {
            return display.input.focus();
          }, 20);
        } else if (button == 3) {
          if (captureRightClick) {
            cm.display.input.onContextMenu(e);
          } else {
            delayBlurEvent(cm);
          }
        }
      }
      function handleMappedButton(cm, button, pos, repeat, event) {
        var name2 = "Click";
        if (repeat == "double") {
          name2 = "Double" + name2;
        } else if (repeat == "triple") {
          name2 = "Triple" + name2;
        }
        name2 = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name2;
        return dispatchKey(cm, addModifierNames(name2, event), event, function(bound) {
          if (typeof bound == "string") {
            bound = commands[bound];
          }
          if (!bound) {
            return false;
          }
          var done = false;
          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true;
            }
            done = bound(cm, pos) != Pass;
          } finally {
            cm.state.suppressEdits = false;
          }
          return done;
        });
      }
      function configureMouse(cm, repeat, event) {
        var option = cm.getOption("configureMouse");
        var value = option ? option(cm, repeat, event) : {};
        if (value.unit == null) {
          var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
          value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
        }
        if (value.extend == null || cm.doc.extend) {
          value.extend = cm.doc.extend || event.shiftKey;
        }
        if (value.addNew == null) {
          value.addNew = mac ? event.metaKey : event.ctrlKey;
        }
        if (value.moveOnDrag == null) {
          value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
        }
        return value;
      }
      function leftButtonDown(cm, pos, repeat, event) {
        if (ie) {
          setTimeout(bind(ensureFocus, cm), 0);
        } else {
          cm.curOp.focus = activeElt(root(cm));
        }
        var behavior = configureMouse(cm, repeat, event);
        var sel = cm.doc.sel, contained;
        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
          leftButtonStartDrag(cm, event, pos, behavior);
        } else {
          leftButtonSelect(cm, event, pos, behavior);
        }
      }
      function leftButtonStartDrag(cm, event, pos, behavior) {
        var display = cm.display, moved = false;
        var dragEnd = operation(cm, function(e) {
          if (webkit) {
            display.scroller.draggable = false;
          }
          cm.state.draggingText = false;
          if (cm.state.delayingBlurEvent) {
            if (cm.hasFocus()) {
              cm.state.delayingBlurEvent = false;
            } else {
              delayBlurEvent(cm);
            }
          }
          off(display.wrapper.ownerDocument, "mouseup", dragEnd);
          off(display.wrapper.ownerDocument, "mousemove", mouseMove);
          off(display.scroller, "dragstart", dragStart);
          off(display.scroller, "drop", dragEnd);
          if (!moved) {
            e_preventDefault(e);
            if (!behavior.addNew) {
              extendSelection(cm.doc, pos, null, null, behavior.extend);
            }
            if (webkit && !safari || ie && ie_version == 9) {
              setTimeout(function() {
                display.wrapper.ownerDocument.body.focus({ preventScroll: true });
                display.input.focus();
              }, 20);
            } else {
              display.input.focus();
            }
          }
        });
        var mouseMove = function(e2) {
          moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
        };
        var dragStart = function() {
          return moved = true;
        };
        if (webkit) {
          display.scroller.draggable = true;
        }
        cm.state.draggingText = dragEnd;
        dragEnd.copy = !behavior.moveOnDrag;
        on(display.wrapper.ownerDocument, "mouseup", dragEnd);
        on(display.wrapper.ownerDocument, "mousemove", mouseMove);
        on(display.scroller, "dragstart", dragStart);
        on(display.scroller, "drop", dragEnd);
        cm.state.delayingBlurEvent = true;
        setTimeout(function() {
          return display.input.focus();
        }, 20);
        if (display.scroller.dragDrop) {
          display.scroller.dragDrop();
        }
      }
      function rangeForUnit(cm, pos, unit) {
        if (unit == "char") {
          return new Range(pos, pos);
        }
        if (unit == "word") {
          return cm.findWordAt(pos);
        }
        if (unit == "line") {
          return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        }
        var result = unit(cm, pos);
        return new Range(result.from, result.to);
      }
      function leftButtonSelect(cm, event, start, behavior) {
        if (ie) {
          delayBlurEvent(cm);
        }
        var display = cm.display, doc2 = cm.doc;
        e_preventDefault(event);
        var ourRange, ourIndex, startSel = doc2.sel, ranges = startSel.ranges;
        if (behavior.addNew && !behavior.extend) {
          ourIndex = doc2.sel.contains(start);
          if (ourIndex > -1) {
            ourRange = ranges[ourIndex];
          } else {
            ourRange = new Range(start, start);
          }
        } else {
          ourRange = doc2.sel.primary();
          ourIndex = doc2.sel.primIndex;
        }
        if (behavior.unit == "rectangle") {
          if (!behavior.addNew) {
            ourRange = new Range(start, start);
          }
          start = posFromMouse(cm, event, true, true);
          ourIndex = -1;
        } else {
          var range2 = rangeForUnit(cm, start, behavior.unit);
          if (behavior.extend) {
            ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
          } else {
            ourRange = range2;
          }
        }
        if (!behavior.addNew) {
          ourIndex = 0;
          setSelection(doc2, new Selection([ourRange], 0), sel_mouse);
          startSel = doc2.sel;
        } else if (ourIndex == -1) {
          ourIndex = ranges.length;
          setSelection(
            doc2,
            normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
            { scroll: false, origin: "*mouse" }
          );
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
          setSelection(
            doc2,
            normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
            { scroll: false, origin: "*mouse" }
          );
          startSel = doc2.sel;
        } else {
          replaceOneSelection(doc2, ourIndex, ourRange, sel_mouse);
        }
        var lastPos = start;
        function extendTo(pos) {
          if (cmp(lastPos, pos) == 0) {
            return;
          }
          lastPos = pos;
          if (behavior.unit == "rectangle") {
            var ranges2 = [], tabSize = cm.options.tabSize;
            var startCol = countColumn(getLine(doc2, start.line).text, start.ch, tabSize);
            var posCol = countColumn(getLine(doc2, pos.line).text, pos.ch, tabSize);
            var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
            for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
              var text = getLine(doc2, line).text, leftPos = findColumn(text, left, tabSize);
              if (left == right) {
                ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
              } else if (text.length > leftPos) {
                ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
              }
            }
            if (!ranges2.length) {
              ranges2.push(new Range(start, start));
            }
            setSelection(
              doc2,
              normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex),
              { origin: "*mouse", scroll: false }
            );
            cm.scrollIntoView(pos);
          } else {
            var oldRange = ourRange;
            var range3 = rangeForUnit(cm, pos, behavior.unit);
            var anchor = oldRange.anchor, head;
            if (cmp(range3.anchor, anchor) > 0) {
              head = range3.head;
              anchor = minPos(oldRange.from(), range3.anchor);
            } else {
              head = range3.anchor;
              anchor = maxPos(oldRange.to(), range3.head);
            }
            var ranges$1 = startSel.ranges.slice(0);
            ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc2, anchor), head));
            setSelection(doc2, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
          }
        }
        var editorSize = display.wrapper.getBoundingClientRect();
        var counter = 0;
        function extend(e) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
          if (!cur) {
            return;
          }
          if (cmp(cur, lastPos) != 0) {
            cm.curOp.focus = activeElt(root(cm));
            extendTo(cur);
            var visible = visibleLines(display, doc2);
            if (cur.line >= visible.to || cur.line < visible.from) {
              setTimeout(operation(cm, function() {
                if (counter == curCount) {
                  extend(e);
                }
              }), 150);
            }
          } else {
            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
            if (outside) {
              setTimeout(operation(cm, function() {
                if (counter != curCount) {
                  return;
                }
                display.scroller.scrollTop += outside;
                extend(e);
              }), 50);
            }
          }
        }
        function done(e) {
          cm.state.selectingText = false;
          counter = Infinity;
          if (e) {
            e_preventDefault(e);
            display.input.focus();
          }
          off(display.wrapper.ownerDocument, "mousemove", move);
          off(display.wrapper.ownerDocument, "mouseup", up);
          doc2.history.lastSelOrigin = null;
        }
        var move = operation(cm, function(e) {
          if (e.buttons === 0 || !e_button(e)) {
            done(e);
          } else {
            extend(e);
          }
        });
        var up = operation(cm, done);
        cm.state.selectingText = up;
        on(display.wrapper.ownerDocument, "mousemove", move);
        on(display.wrapper.ownerDocument, "mouseup", up);
      }
      function bidiSimplify(cm, range2) {
        var anchor = range2.anchor;
        var head = range2.head;
        var anchorLine = getLine(cm.doc, anchor.line);
        if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
          return range2;
        }
        var order = getOrder(anchorLine);
        if (!order) {
          return range2;
        }
        var index2 = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index2];
        if (part.from != anchor.ch && part.to != anchor.ch) {
          return range2;
        }
        var boundary = index2 + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
        if (boundary == 0 || boundary == order.length) {
          return range2;
        }
        var leftSide;
        if (head.line != anchor.line) {
          leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
        } else {
          var headIndex = getBidiPartAt(order, head.ch, head.sticky);
          var dir = headIndex - index2 || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
          if (headIndex == boundary - 1 || headIndex == boundary) {
            leftSide = dir < 0;
          } else {
            leftSide = dir > 0;
          }
        }
        var usePart = order[boundary + (leftSide ? -1 : 0)];
        var from2 = leftSide == (usePart.level == 1);
        var ch = from2 ? usePart.from : usePart.to, sticky = from2 ? "after" : "before";
        return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
      }
      function gutterEvent(cm, e, type, prevent) {
        var mX, mY;
        if (e.touches) {
          mX = e.touches[0].clientX;
          mY = e.touches[0].clientY;
        } else {
          try {
            mX = e.clientX;
            mY = e.clientY;
          } catch (e$1) {
            return false;
          }
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
          return false;
        }
        if (prevent) {
          e_preventDefault(e);
        }
        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type)) {
          return e_defaultPrevented(e);
        }
        mY -= lineBox.top - display.viewOffset;
        for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
          var g = display.gutters.childNodes[i2];
          if (g && g.getBoundingClientRect().right >= mX) {
            var line = lineAtHeight(cm.doc, mY);
            var gutter = cm.display.gutterSpecs[i2];
            signal(cm, type, cm, line, gutter.className, e);
            return e_defaultPrevented(e);
          }
        }
      }
      function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true);
      }
      function onContextMenu(cm, e) {
        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
          return;
        }
        if (signalDOMEvent(cm, e, "contextmenu")) {
          return;
        }
        if (!captureRightClick) {
          cm.display.input.onContextMenu(e);
        }
      }
      function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu")) {
          return false;
        }
        return gutterEvent(cm, e, "gutterContextMenu", false);
      }
      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }
      var Init = { toString: function() {
        return "CodeMirror.Init";
      } };
      var defaults = {};
      var optionHandlers = {};
      function defineOptions(CodeMirror3) {
        var optionHandlers2 = CodeMirror3.optionHandlers;
        function option(name2, deflt, handle, notOnInit) {
          CodeMirror3.defaults[name2] = deflt;
          if (handle) {
            optionHandlers2[name2] = notOnInit ? function(cm, val, old) {
              if (old != Init) {
                handle(cm, val, old);
              }
            } : handle;
          }
        }
        CodeMirror3.defineOption = option;
        CodeMirror3.Init = Init;
        option("value", "", function(cm, val) {
          return cm.setValue(val);
        }, true);
        option("mode", null, function(cm, val) {
          cm.doc.modeOption = val;
          loadMode(cm);
        }, true);
        option("indentUnit", 2, loadMode, true);
        option("indentWithTabs", false);
        option("smartIndent", true);
        option("tabSize", 4, function(cm) {
          resetModeState(cm);
          clearCaches(cm);
          regChange(cm);
        }, true);
        option("lineSeparator", null, function(cm, val) {
          cm.doc.lineSep = val;
          if (!val) {
            return;
          }
          var newBreaks = [], lineNo2 = cm.doc.first;
          cm.doc.iter(function(line) {
            for (var pos = 0; ; ) {
              var found = line.text.indexOf(val, pos);
              if (found == -1) {
                break;
              }
              pos = found + val.length;
              newBreaks.push(Pos(lineNo2, found));
            }
            lineNo2++;
          });
          for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
            replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
          }
        });
        option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
          cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
          if (old != Init) {
            cm.refresh();
          }
        });
        option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
          return cm.refresh();
        }, true);
        option("electricChars", true);
        option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
          throw new Error("inputStyle can not (yet) be changed in a running editor");
        }, true);
        option("spellcheck", false, function(cm, val) {
          return cm.getInputField().spellcheck = val;
        }, true);
        option("autocorrect", false, function(cm, val) {
          return cm.getInputField().autocorrect = val;
        }, true);
        option("autocapitalize", false, function(cm, val) {
          return cm.getInputField().autocapitalize = val;
        }, true);
        option("rtlMoveVisually", !windows);
        option("wholeLineUpdateBefore", true);
        option("theme", "default", function(cm) {
          themeChanged(cm);
          updateGutters(cm);
        }, true);
        option("keyMap", "default", function(cm, val, old) {
          var next = getKeyMap(val);
          var prev = old != Init && getKeyMap(old);
          if (prev && prev.detach) {
            prev.detach(cm, next);
          }
          if (next.attach) {
            next.attach(cm, prev || null);
          }
        });
        option("extraKeys", null);
        option("configureMouse", null);
        option("lineWrapping", false, wrappingChanged, true);
        option("gutters", [], function(cm, val) {
          cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
          updateGutters(cm);
        }, true);
        option("fixedGutter", true, function(cm, val) {
          cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
          cm.refresh();
        }, true);
        option("coverGutterNextToScrollbar", false, function(cm) {
          return updateScrollbars(cm);
        }, true);
        option("scrollbarStyle", "native", function(cm) {
          initScrollbars(cm);
          updateScrollbars(cm);
          cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
          cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, true);
        option("lineNumbers", false, function(cm, val) {
          cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
          updateGutters(cm);
        }, true);
        option("firstLineNumber", 1, updateGutters, true);
        option("lineNumberFormatter", function(integer) {
          return integer;
        }, updateGutters, true);
        option("showCursorWhenSelecting", false, updateSelection, true);
        option("resetSelectionOnContextMenu", true);
        option("lineWiseCopyCut", true);
        option("pasteLinesPerSelection", true);
        option("selectionsMayTouch", false);
        option("readOnly", false, function(cm, val) {
          if (val == "nocursor") {
            onBlur(cm);
            cm.display.input.blur();
          }
          cm.display.input.readOnlyChanged(val);
        });
        option("screenReaderLabel", null, function(cm, val) {
          val = val === "" ? null : val;
          cm.display.input.screenReaderLabelChanged(val);
        });
        option("disableInput", false, function(cm, val) {
          if (!val) {
            cm.display.input.reset();
          }
        }, true);
        option("dragDrop", true, dragDropChanged);
        option("allowDropFileTypes", null);
        option("cursorBlinkRate", 530);
        option("cursorScrollMargin", 0);
        option("cursorHeight", 1, updateSelection, true);
        option("singleCursorHeightPerLine", true, updateSelection, true);
        option("workTime", 100);
        option("workDelay", 100);
        option("flattenSpans", true, resetModeState, true);
        option("addModeClass", false, resetModeState, true);
        option("pollInterval", 100);
        option("undoDepth", 200, function(cm, val) {
          return cm.doc.history.undoDepth = val;
        });
        option("historyEventDelay", 1250);
        option("viewportMargin", 10, function(cm) {
          return cm.refresh();
        }, true);
        option("maxHighlightLength", 1e4, resetModeState, true);
        option("moveInputWithCursor", true, function(cm, val) {
          if (!val) {
            cm.display.input.resetPosition();
          }
        });
        option("tabindex", null, function(cm, val) {
          return cm.display.input.getField().tabIndex = val || "";
        });
        option("autofocus", null);
        option("direction", "ltr", function(cm, val) {
          return cm.doc.setDirection(val);
        }, true);
        option("phrases", null);
      }
      function dragDropChanged(cm, value, old) {
        var wasOn = old && old != Init;
        if (!value != !wasOn) {
          var funcs = cm.display.dragFunctions;
          var toggle = value ? on : off;
          toggle(cm.display.scroller, "dragstart", funcs.start);
          toggle(cm.display.scroller, "dragenter", funcs.enter);
          toggle(cm.display.scroller, "dragover", funcs.over);
          toggle(cm.display.scroller, "dragleave", funcs.leave);
          toggle(cm.display.scroller, "drop", funcs.drop);
        }
      }
      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          addClass(cm.display.wrapper, "CodeMirror-wrap");
          cm.display.sizer.style.minWidth = "";
          cm.display.sizerWidth = null;
        } else {
          rmClass(cm.display.wrapper, "CodeMirror-wrap");
          findMaxLine(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function() {
          return updateScrollbars(cm);
        }, 100);
      }
      function CodeMirror2(place, options) {
        var this$1$1 = this;
        if (!(this instanceof CodeMirror2)) {
          return new CodeMirror2(place, options);
        }
        this.options = options = options ? copyObj(options) : {};
        copyObj(defaults, options, false);
        var doc2 = options.value;
        if (typeof doc2 == "string") {
          doc2 = new Doc(doc2, options.mode, null, options.lineSeparator, options.direction);
        } else if (options.mode) {
          doc2.modeOption = options.mode;
        }
        this.doc = doc2;
        var input = new CodeMirror2.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc2, input, options);
        display.wrapper.CodeMirror = this;
        themeChanged(this);
        if (options.lineWrapping) {
          this.display.wrapper.className += " CodeMirror-wrap";
        }
        initScrollbars(this);
        this.state = {
          keyMaps: [],
          // stores maps added by addKeyMap
          overlays: [],
          // highlighting overlays, as added by addOverlay
          modeGen: 0,
          // bumped when mode/overlay changes, used to invalidate highlighting info
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false,
          // used to disable editing during key handlers when in readOnly mode
          pasteIncoming: -1,
          cutIncoming: -1,
          // help recognize paste/cut edits in input.poll
          selectingText: false,
          draggingText: false,
          highlight: new Delayed(),
          // stores highlight worker timeout
          keySeq: null,
          // Unfinished key sequence
          specialChars: null
        };
        if (options.autofocus && !mobile) {
          display.input.focus();
        }
        if (ie && ie_version < 11) {
          setTimeout(function() {
            return this$1$1.display.input.reset(true);
          }, 20);
        }
        registerEventHandlers(this);
        ensureGlobalHandlers();
        startOperation(this);
        this.curOp.forceUpdate = true;
        attachDoc(this, doc2);
        if (options.autofocus && !mobile || this.hasFocus()) {
          setTimeout(function() {
            if (this$1$1.hasFocus() && !this$1$1.state.focused) {
              onFocus(this$1$1);
            }
          }, 20);
        } else {
          onBlur(this);
        }
        for (var opt in optionHandlers) {
          if (optionHandlers.hasOwnProperty(opt)) {
            optionHandlers[opt](this, options[opt], Init);
          }
        }
        maybeUpdateLineNumberWidth(this);
        if (options.finishInit) {
          options.finishInit(this);
        }
        for (var i2 = 0; i2 < initHooks.length; ++i2) {
          initHooks[i2](this);
        }
        endOperation(this);
        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
          display.lineDiv.style.textRendering = "auto";
        }
      }
      CodeMirror2.defaults = defaults;
      CodeMirror2.optionHandlers = optionHandlers;
      function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown));
        if (ie && ie_version < 11) {
          on(d.scroller, "dblclick", operation(cm, function(e) {
            if (signalDOMEvent(cm, e)) {
              return;
            }
            var pos = posFromMouse(cm, e);
            if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
              return;
            }
            e_preventDefault(e);
            var word = cm.findWordAt(pos);
            extendSelection(cm.doc, word.anchor, word.head);
          }));
        } else {
          on(d.scroller, "dblclick", function(e) {
            return signalDOMEvent(cm, e) || e_preventDefault(e);
          });
        }
        on(d.scroller, "contextmenu", function(e) {
          return onContextMenu(cm, e);
        });
        on(d.input.getField(), "contextmenu", function(e) {
          if (!d.scroller.contains(e.target)) {
            onContextMenu(cm, e);
          }
        });
        var touchFinished, prevTouch = { end: 0 };
        function finishTouch() {
          if (d.activeTouch) {
            touchFinished = setTimeout(function() {
              return d.activeTouch = null;
            }, 1e3);
            prevTouch = d.activeTouch;
            prevTouch.end = +/* @__PURE__ */ new Date();
          }
        }
        function isMouseLikeTouchEvent(e) {
          if (e.touches.length != 1) {
            return false;
          }
          var touch = e.touches[0];
          return touch.radiusX <= 1 && touch.radiusY <= 1;
        }
        function farAway(touch, other) {
          if (other.left == null) {
            return true;
          }
          var dx = other.left - touch.left, dy = other.top - touch.top;
          return dx * dx + dy * dy > 20 * 20;
        }
        on(d.scroller, "touchstart", function(e) {
          if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
            d.input.ensurePolled();
            clearTimeout(touchFinished);
            var now = +/* @__PURE__ */ new Date();
            d.activeTouch = {
              start: now,
              moved: false,
              prev: now - prevTouch.end <= 300 ? prevTouch : null
            };
            if (e.touches.length == 1) {
              d.activeTouch.left = e.touches[0].pageX;
              d.activeTouch.top = e.touches[0].pageY;
            }
          }
        });
        on(d.scroller, "touchmove", function() {
          if (d.activeTouch) {
            d.activeTouch.moved = true;
          }
        });
        on(d.scroller, "touchend", function(e) {
          var touch = d.activeTouch;
          if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && /* @__PURE__ */ new Date() - touch.start < 300) {
            var pos = cm.coordsChar(d.activeTouch, "page"), range2;
            if (!touch.prev || farAway(touch, touch.prev)) {
              range2 = new Range(pos, pos);
            } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
              range2 = cm.findWordAt(pos);
            } else {
              range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
            }
            cm.setSelection(range2.anchor, range2.head);
            cm.focus();
            e_preventDefault(e);
          }
          finishTouch();
        });
        on(d.scroller, "touchcancel", finishTouch);
        on(d.scroller, "scroll", function() {
          if (d.scroller.clientHeight) {
            updateScrollTop(cm, d.scroller.scrollTop);
            setScrollLeft(cm, d.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        });
        on(d.scroller, "mousewheel", function(e) {
          return onScrollWheel(cm, e);
        });
        on(d.scroller, "DOMMouseScroll", function(e) {
          return onScrollWheel(cm, e);
        });
        on(d.wrapper, "scroll", function() {
          return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });
        d.dragFunctions = {
          enter: function(e) {
            if (!signalDOMEvent(cm, e)) {
              e_stop(e);
            }
          },
          over: function(e) {
            if (!signalDOMEvent(cm, e)) {
              onDragOver(cm, e);
              e_stop(e);
            }
          },
          start: function(e) {
            return onDragStart(cm, e);
          },
          drop: operation(cm, onDrop),
          leave: function(e) {
            if (!signalDOMEvent(cm, e)) {
              clearDragCursor(cm);
            }
          }
        };
        var inp = d.input.getField();
        on(inp, "keyup", function(e) {
          return onKeyUp.call(cm, e);
        });
        on(inp, "keydown", operation(cm, onKeyDown));
        on(inp, "keypress", operation(cm, onKeyPress));
        on(inp, "focus", function(e) {
          return onFocus(cm, e);
        });
        on(inp, "blur", function(e) {
          return onBlur(cm, e);
        });
      }
      var initHooks = [];
      CodeMirror2.defineInitHook = function(f) {
        return initHooks.push(f);
      };
      function indentLine(cm, n, how, aggressive) {
        var doc2 = cm.doc, state;
        if (how == null) {
          how = "add";
        }
        if (how == "smart") {
          if (!doc2.mode.indent) {
            how = "prev";
          } else {
            state = getContextBefore(cm, n).state;
          }
        }
        var tabSize = cm.options.tabSize;
        var line = getLine(doc2, n), curSpace = countColumn(line.text, null, tabSize);
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        var curSpaceString = line.text.match(/^\s*/)[0], indentation;
        if (!aggressive && !/\S/.test(line.text)) {
          indentation = 0;
          how = "not";
        } else if (how == "smart") {
          indentation = doc2.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
          if (indentation == Pass || indentation > 150) {
            if (!aggressive) {
              return;
            }
            how = "prev";
          }
        }
        if (how == "prev") {
          if (n > doc2.first) {
            indentation = countColumn(getLine(doc2, n - 1).text, null, tabSize);
          } else {
            indentation = 0;
          }
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);
        var indentString = "", pos = 0;
        if (cm.options.indentWithTabs) {
          for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
            pos += tabSize;
            indentString += "	";
          }
        }
        if (pos < indentation) {
          indentString += spaceStr(indentation - pos);
        }
        if (indentString != curSpaceString) {
          replaceRange(doc2, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
          line.stateAfter = null;
          return true;
        } else {
          for (var i$12 = 0; i$12 < doc2.sel.ranges.length; i$12++) {
            var range2 = doc2.sel.ranges[i$12];
            if (range2.head.line == n && range2.head.ch < curSpaceString.length) {
              var pos$1 = Pos(n, curSpaceString.length);
              replaceOneSelection(doc2, i$12, new Range(pos$1, pos$1));
              break;
            }
          }
        }
      }
      var lastCopied = null;
      function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
      }
      function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc2 = cm.doc;
        cm.display.shift = false;
        if (!sel) {
          sel = doc2.sel;
        }
        var recent = +/* @__PURE__ */ new Date() - 200;
        var paste = origin == "paste" || cm.state.pasteIncoming > recent;
        var textLines = splitLinesAuto(inserted), multiPaste = null;
        if (paste && sel.ranges.length > 1) {
          if (lastCopied && lastCopied.text.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.text.length == 0) {
              multiPaste = [];
              for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
                multiPaste.push(doc2.splitLines(lastCopied.text[i2]));
              }
            }
          } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
            multiPaste = map2(textLines, function(l) {
              return [l];
            });
          }
        }
        var updateInput = cm.curOp.updateInput;
        for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
          var range2 = sel.ranges[i$12];
          var from2 = range2.from(), to = range2.to();
          if (range2.empty()) {
            if (deleted && deleted > 0) {
              from2 = Pos(from2.line, from2.ch - deleted);
            } else if (cm.state.overwrite && !paste) {
              to = Pos(to.line, Math.min(getLine(doc2, to.line).text.length, to.ch + lst(textLines).length));
            } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
              from2 = to = Pos(from2.line, 0);
            }
          }
          var changeEvent = {
            from: from2,
            to,
            text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
            origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
          };
          makeChange(cm.doc, changeEvent);
          signalLater(cm, "inputRead", cm, changeEvent);
        }
        if (inserted && !paste) {
          triggerElectric(cm, inserted);
        }
        ensureCursorVisible(cm);
        if (cm.curOp.updateInput < 2) {
          cm.curOp.updateInput = updateInput;
        }
        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = -1;
      }
      function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("Text");
        if (pasted) {
          e.preventDefault();
          if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {
            runInOp(cm, function() {
              return applyTextInput(cm, pasted, 0, null, "paste");
            });
          }
          return true;
        }
      }
      function triggerElectric(cm, inserted) {
        if (!cm.options.electricChars || !cm.options.smartIndent) {
          return;
        }
        var sel = cm.doc.sel;
        for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
          var range2 = sel.ranges[i2];
          if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {
            continue;
          }
          var mode = cm.getModeAt(range2.head);
          var indented = false;
          if (mode.electricChars) {
            for (var j = 0; j < mode.electricChars.length; j++) {
              if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                indented = indentLine(cm, range2.head.line, "smart");
                break;
              }
            }
          } else if (mode.electricInput) {
            if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
              indented = indentLine(cm, range2.head.line, "smart");
            }
          }
          if (indented) {
            signalLater(cm, "electricInput", cm, range2.head.line);
          }
        }
      }
      function copyableRanges(cm) {
        var text = [], ranges = [];
        for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
          var line = cm.doc.sel.ranges[i2].head.line;
          var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
          ranges.push(lineRange);
          text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return { text, ranges };
      }
      function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
        field.setAttribute("autocorrect", autocorrect ? "on" : "off");
        field.setAttribute("autocapitalize", autocapitalize ? "on" : "off");
        field.setAttribute("spellcheck", !!spellcheck);
      }
      function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
        var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        if (webkit) {
          te.style.width = "1000px";
        } else {
          te.setAttribute("wrap", "off");
        }
        if (ios) {
          te.style.border = "1px solid black";
        }
        return div;
      }
      function addEditorMethods(CodeMirror3) {
        var optionHandlers2 = CodeMirror3.optionHandlers;
        var helpers = CodeMirror3.helpers = {};
        CodeMirror3.prototype = {
          constructor: CodeMirror3,
          focus: function() {
            win(this).focus();
            this.display.input.focus();
          },
          setOption: function(option, value) {
            var options = this.options, old = options[option];
            if (options[option] == value && option != "mode") {
              return;
            }
            options[option] = value;
            if (optionHandlers2.hasOwnProperty(option)) {
              operation(this, optionHandlers2[option])(this, value, old);
            }
            signal(this, "optionChange", this, option);
          },
          getOption: function(option) {
            return this.options[option];
          },
          getDoc: function() {
            return this.doc;
          },
          addKeyMap: function(map3, bottom) {
            this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map3));
          },
          removeKeyMap: function(map3) {
            var maps = this.state.keyMaps;
            for (var i2 = 0; i2 < maps.length; ++i2) {
              if (maps[i2] == map3 || maps[i2].name == map3) {
                maps.splice(i2, 1);
                return true;
              }
            }
          },
          addOverlay: methodOp(function(spec, options) {
            var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
            if (mode.startState) {
              throw new Error("Overlays may not be stateful.");
            }
            insertSorted(
              this.state.overlays,
              {
                mode,
                modeSpec: spec,
                opaque: options && options.opaque,
                priority: options && options.priority || 0
              },
              function(overlay) {
                return overlay.priority;
              }
            );
            this.state.modeGen++;
            regChange(this);
          }),
          removeOverlay: methodOp(function(spec) {
            var overlays = this.state.overlays;
            for (var i2 = 0; i2 < overlays.length; ++i2) {
              var cur = overlays[i2].modeSpec;
              if (cur == spec || typeof spec == "string" && cur.name == spec) {
                overlays.splice(i2, 1);
                this.state.modeGen++;
                regChange(this);
                return;
              }
            }
          }),
          indentLine: methodOp(function(n, dir, aggressive) {
            if (typeof dir != "string" && typeof dir != "number") {
              if (dir == null) {
                dir = this.options.smartIndent ? "smart" : "prev";
              } else {
                dir = dir ? "add" : "subtract";
              }
            }
            if (isLine(this.doc, n)) {
              indentLine(this, n, dir, aggressive);
            }
          }),
          indentSelection: methodOp(function(how) {
            var ranges = this.doc.sel.ranges, end = -1;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var range2 = ranges[i2];
              if (!range2.empty()) {
                var from2 = range2.from(), to = range2.to();
                var start = Math.max(end, from2.line);
                end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                for (var j = start; j < end; ++j) {
                  indentLine(this, j, how);
                }
                var newRanges = this.doc.sel.ranges;
                if (from2.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
                  replaceOneSelection(this.doc, i2, new Range(from2, newRanges[i2].to()), sel_dontScroll);
                }
              } else if (range2.head.line > end) {
                indentLine(this, range2.head.line, how, true);
                end = range2.head.line;
                if (i2 == this.doc.sel.primIndex) {
                  ensureCursorVisible(this);
                }
              }
            }
          }),
          // Fetch the parser token for a given character. Useful for hacks
          // that want to inspect the mode state (say, for completion).
          getTokenAt: function(pos, precise) {
            return takeToken(this, pos, precise);
          },
          getLineTokens: function(line, precise) {
            return takeToken(this, Pos(line), precise, true);
          },
          getTokenTypeAt: function(pos) {
            pos = clipPos(this.doc, pos);
            var styles = getLineStyles(this, getLine(this.doc, pos.line));
            var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
            var type;
            if (ch == 0) {
              type = styles[2];
            } else {
              for (; ; ) {
                var mid = before + after >> 1;
                if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                  after = mid;
                } else if (styles[mid * 2 + 1] < ch) {
                  before = mid + 1;
                } else {
                  type = styles[mid * 2 + 2];
                  break;
                }
              }
            }
            var cut = type ? type.indexOf("overlay ") : -1;
            return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
          },
          getModeAt: function(pos) {
            var mode = this.doc.mode;
            if (!mode.innerMode) {
              return mode;
            }
            return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
          },
          getHelper: function(pos, type) {
            return this.getHelpers(pos, type)[0];
          },
          getHelpers: function(pos, type) {
            var found = [];
            if (!helpers.hasOwnProperty(type)) {
              return found;
            }
            var help = helpers[type], mode = this.getModeAt(pos);
            if (typeof mode[type] == "string") {
              if (help[mode[type]]) {
                found.push(help[mode[type]]);
              }
            } else if (mode[type]) {
              for (var i2 = 0; i2 < mode[type].length; i2++) {
                var val = help[mode[type][i2]];
                if (val) {
                  found.push(val);
                }
              }
            } else if (mode.helperType && help[mode.helperType]) {
              found.push(help[mode.helperType]);
            } else if (help[mode.name]) {
              found.push(help[mode.name]);
            }
            for (var i$12 = 0; i$12 < help._global.length; i$12++) {
              var cur = help._global[i$12];
              if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
                found.push(cur.val);
              }
            }
            return found;
          },
          getStateAfter: function(line, precise) {
            var doc2 = this.doc;
            line = clipLine(doc2, line == null ? doc2.first + doc2.size - 1 : line);
            return getContextBefore(this, line + 1, precise).state;
          },
          cursorCoords: function(start, mode) {
            var pos, range2 = this.doc.sel.primary();
            if (start == null) {
              pos = range2.head;
            } else if (typeof start == "object") {
              pos = clipPos(this.doc, start);
            } else {
              pos = start ? range2.from() : range2.to();
            }
            return cursorCoords(this, pos, mode || "page");
          },
          charCoords: function(pos, mode) {
            return charCoords(this, clipPos(this.doc, pos), mode || "page");
          },
          coordsChar: function(coords, mode) {
            coords = fromCoordSystem(this, coords, mode || "page");
            return coordsChar(this, coords.left, coords.top);
          },
          lineAtHeight: function(height, mode) {
            height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
            return lineAtHeight(this.doc, height + this.display.viewOffset);
          },
          heightAtLine: function(line, mode, includeWidgets) {
            var end = false, lineObj;
            if (typeof line == "number") {
              var last = this.doc.first + this.doc.size - 1;
              if (line < this.doc.first) {
                line = this.doc.first;
              } else if (line > last) {
                line = last;
                end = true;
              }
              lineObj = getLine(this.doc, line);
            } else {
              lineObj = line;
            }
            return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
          },
          defaultTextHeight: function() {
            return textHeight(this.display);
          },
          defaultCharWidth: function() {
            return charWidth(this.display);
          },
          getViewport: function() {
            return { from: this.display.viewFrom, to: this.display.viewTo };
          },
          addWidget: function(pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = cursorCoords(this, clipPos(this.doc, pos));
            var top = pos.bottom, left = pos.left;
            node.style.position = "absolute";
            node.setAttribute("cm-ignore-events", "true");
            this.display.input.setUneditable(node);
            display.sizer.appendChild(node);
            if (vert == "over") {
              top = pos.top;
            } else if (vert == "above" || vert == "near") {
              var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
              if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                top = pos.top - node.offsetHeight;
              } else if (pos.bottom + node.offsetHeight <= vspace) {
                top = pos.bottom;
              }
              if (left + node.offsetWidth > hspace) {
                left = hspace - node.offsetWidth;
              }
            }
            node.style.top = top + "px";
            node.style.left = node.style.right = "";
            if (horiz == "right") {
              left = display.sizer.clientWidth - node.offsetWidth;
              node.style.right = "0px";
            } else {
              if (horiz == "left") {
                left = 0;
              } else if (horiz == "middle") {
                left = (display.sizer.clientWidth - node.offsetWidth) / 2;
              }
              node.style.left = left + "px";
            }
            if (scroll) {
              scrollIntoView(this, { left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });
            }
          },
          triggerOnKeyDown: methodOp(onKeyDown),
          triggerOnKeyPress: methodOp(onKeyPress),
          triggerOnKeyUp: onKeyUp,
          triggerOnMouseDown: methodOp(onMouseDown),
          execCommand: function(cmd) {
            if (commands.hasOwnProperty(cmd)) {
              return commands[cmd].call(null, this);
            }
          },
          triggerElectric: methodOp(function(text) {
            triggerElectric(this, text);
          }),
          findPosH: function(from2, amount, unit, visually) {
            var dir = 1;
            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }
            var cur = clipPos(this.doc, from2);
            for (var i2 = 0; i2 < amount; ++i2) {
              cur = findPosH(this.doc, cur, dir, unit, visually);
              if (cur.hitSide) {
                break;
              }
            }
            return cur;
          },
          moveH: methodOp(function(dir, unit) {
            var this$1$1 = this;
            this.extendSelectionsBy(function(range2) {
              if (this$1$1.display.shift || this$1$1.doc.extend || range2.empty()) {
                return findPosH(this$1$1.doc, range2.head, dir, unit, this$1$1.options.rtlMoveVisually);
              } else {
                return dir < 0 ? range2.from() : range2.to();
              }
            }, sel_move);
          }),
          deleteH: methodOp(function(dir, unit) {
            var sel = this.doc.sel, doc2 = this.doc;
            if (sel.somethingSelected()) {
              doc2.replaceSelection("", null, "+delete");
            } else {
              deleteNearSelection(this, function(range2) {
                var other = findPosH(doc2, range2.head, dir, unit, false);
                return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
              });
            }
          }),
          findPosV: function(from2, amount, unit, goalColumn) {
            var dir = 1, x = goalColumn;
            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }
            var cur = clipPos(this.doc, from2);
            for (var i2 = 0; i2 < amount; ++i2) {
              var coords = cursorCoords(this, cur, "div");
              if (x == null) {
                x = coords.left;
              } else {
                coords.left = x;
              }
              cur = findPosV(this, coords, dir, unit);
              if (cur.hitSide) {
                break;
              }
            }
            return cur;
          },
          moveV: methodOp(function(dir, unit) {
            var this$1$1 = this;
            var doc2 = this.doc, goals = [];
            var collapse = !this.display.shift && !doc2.extend && doc2.sel.somethingSelected();
            doc2.extendSelectionsBy(function(range2) {
              if (collapse) {
                return dir < 0 ? range2.from() : range2.to();
              }
              var headPos = cursorCoords(this$1$1, range2.head, "div");
              if (range2.goalColumn != null) {
                headPos.left = range2.goalColumn;
              }
              goals.push(headPos.left);
              var pos = findPosV(this$1$1, headPos, dir, unit);
              if (unit == "page" && range2 == doc2.sel.primary()) {
                addToScrollTop(this$1$1, charCoords(this$1$1, pos, "div").top - headPos.top);
              }
              return pos;
            }, sel_move);
            if (goals.length) {
              for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
                doc2.sel.ranges[i2].goalColumn = goals[i2];
              }
            }
          }),
          // Find the word at the given position (as returned by coordsChar).
          findWordAt: function(pos) {
            var doc2 = this.doc, line = getLine(doc2, pos.line).text;
            var start = pos.ch, end = pos.ch;
            if (line) {
              var helper = this.getHelper(pos, "wordChars");
              if ((pos.sticky == "before" || end == line.length) && start) {
                --start;
              } else {
                ++end;
              }
              var startChar = line.charAt(start);
              var check = isWordChar(startChar, helper) ? function(ch) {
                return isWordChar(ch, helper);
              } : /\s/.test(startChar) ? function(ch) {
                return /\s/.test(ch);
              } : function(ch) {
                return !/\s/.test(ch) && !isWordChar(ch);
              };
              while (start > 0 && check(line.charAt(start - 1))) {
                --start;
              }
              while (end < line.length && check(line.charAt(end))) {
                ++end;
              }
            }
            return new Range(Pos(pos.line, start), Pos(pos.line, end));
          },
          toggleOverwrite: function(value) {
            if (value != null && value == this.state.overwrite) {
              return;
            }
            if (this.state.overwrite = !this.state.overwrite) {
              addClass(this.display.cursorDiv, "CodeMirror-overwrite");
            } else {
              rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
            }
            signal(this, "overwriteToggle", this, this.state.overwrite);
          },
          hasFocus: function() {
            return this.display.input.getField() == activeElt(root(this));
          },
          isReadOnly: function() {
            return !!(this.options.readOnly || this.doc.cantEdit);
          },
          scrollTo: methodOp(function(x, y) {
            scrollToCoords(this, x, y);
          }),
          getScrollInfo: function() {
            var scroller = this.display.scroller;
            return {
              left: scroller.scrollLeft,
              top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this),
              clientWidth: displayWidth(this)
            };
          },
          scrollIntoView: methodOp(function(range2, margin) {
            if (range2 == null) {
              range2 = { from: this.doc.sel.primary().head, to: null };
              if (margin == null) {
                margin = this.options.cursorScrollMargin;
              }
            } else if (typeof range2 == "number") {
              range2 = { from: Pos(range2, 0), to: null };
            } else if (range2.from == null) {
              range2 = { from: range2, to: null };
            }
            if (!range2.to) {
              range2.to = range2.from;
            }
            range2.margin = margin || 0;
            if (range2.from.line != null) {
              scrollToRange(this, range2);
            } else {
              scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
            }
          }),
          setSize: methodOp(function(width, height) {
            var this$1$1 = this;
            var interpret = function(val) {
              return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
            };
            if (width != null) {
              this.display.wrapper.style.width = interpret(width);
            }
            if (height != null) {
              this.display.wrapper.style.height = interpret(height);
            }
            if (this.options.lineWrapping) {
              clearLineMeasurementCache(this);
            }
            var lineNo2 = this.display.viewFrom;
            this.doc.iter(lineNo2, this.display.viewTo, function(line) {
              if (line.widgets) {
                for (var i2 = 0; i2 < line.widgets.length; i2++) {
                  if (line.widgets[i2].noHScroll) {
                    regLineChange(this$1$1, lineNo2, "widget");
                    break;
                  }
                }
              }
              ++lineNo2;
            });
            this.curOp.forceUpdate = true;
            signal(this, "refresh", this);
          }),
          operation: function(f) {
            return runInOp(this, f);
          },
          startOperation: function() {
            return startOperation(this);
          },
          endOperation: function() {
            return endOperation(this);
          },
          refresh: methodOp(function() {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this);
            this.curOp.forceUpdate = true;
            clearCaches(this);
            scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
            updateGutterSpace(this.display);
            if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
              estimateLineHeights(this);
            }
            signal(this, "refresh", this);
          }),
          swapDoc: methodOp(function(doc2) {
            var old = this.doc;
            old.cm = null;
            if (this.state.selectingText) {
              this.state.selectingText();
            }
            attachDoc(this, doc2);
            clearCaches(this);
            this.display.input.reset();
            scrollToCoords(this, doc2.scrollLeft, doc2.scrollTop);
            this.curOp.forceScroll = true;
            signalLater(this, "swapDoc", this, old);
            return old;
          }),
          phrase: function(phraseText) {
            var phrases = this.options.phrases;
            return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
          },
          getInputField: function() {
            return this.display.input.getField();
          },
          getWrapperElement: function() {
            return this.display.wrapper;
          },
          getScrollerElement: function() {
            return this.display.scroller;
          },
          getGutterElement: function() {
            return this.display.gutters;
          }
        };
        eventMixin(CodeMirror3);
        CodeMirror3.registerHelper = function(type, name2, value) {
          if (!helpers.hasOwnProperty(type)) {
            helpers[type] = CodeMirror3[type] = { _global: [] };
          }
          helpers[type][name2] = value;
        };
        CodeMirror3.registerGlobalHelper = function(type, name2, predicate, value) {
          CodeMirror3.registerHelper(type, name2, value);
          helpers[type]._global.push({ pred: predicate, val: value });
        };
      }
      function findPosH(doc2, pos, dir, unit, visually) {
        var oldPos = pos;
        var origDir = dir;
        var lineObj = getLine(doc2, pos.line);
        var lineDir = visually && doc2.direction == "rtl" ? -dir : dir;
        function findNextLine() {
          var l = pos.line + lineDir;
          if (l < doc2.first || l >= doc2.first + doc2.size) {
            return false;
          }
          pos = new Pos(l, pos.ch, pos.sticky);
          return lineObj = getLine(doc2, l);
        }
        function moveOnce(boundToLine) {
          var next;
          if (unit == "codepoint") {
            var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
            if (isNaN(ch)) {
              next = null;
            } else {
              var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
              next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
            }
          } else if (visually) {
            next = moveVisually(doc2.cm, lineObj, pos, dir);
          } else {
            next = moveLogically(lineObj, pos, dir);
          }
          if (next == null) {
            if (!boundToLine && findNextLine()) {
              pos = endOfLine(visually, doc2.cm, lineObj, pos.line, lineDir);
            } else {
              return false;
            }
          } else {
            pos = next;
          }
          return true;
        }
        if (unit == "char" || unit == "codepoint") {
          moveOnce();
        } else if (unit == "column") {
          moveOnce(true);
        } else if (unit == "word" || unit == "group") {
          var sawType = null, group = unit == "group";
          var helper = doc2.cm && doc2.cm.getHelper(pos, "wordChars");
          for (var first = true; ; first = false) {
            if (dir < 0 && !moveOnce(!first)) {
              break;
            }
            var cur = lineObj.text.charAt(pos.ch) || "\n";
            var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
            if (group && !first && !type) {
              type = "s";
            }
            if (sawType && sawType != type) {
              if (dir < 0) {
                dir = 1;
                moveOnce();
                pos.sticky = "after";
              }
              break;
            }
            if (type) {
              sawType = type;
            }
            if (dir > 0 && !moveOnce(!first)) {
              break;
            }
          }
        }
        var result = skipAtomic(doc2, pos, oldPos, origDir, true);
        if (equalCursorPos(oldPos, result)) {
          result.hitSide = true;
        }
        return result;
      }
      function findPosV(cm, pos, dir, unit) {
        var doc2 = cm.doc, x = pos.left, y;
        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc2(cm).documentElement.clientHeight);
          var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
          y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
        } else if (unit == "line") {
          y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        var target;
        for (; ; ) {
          target = coordsChar(cm, x, y);
          if (!target.outside) {
            break;
          }
          if (dir < 0 ? y <= 0 : y >= doc2.height) {
            target.hitSide = true;
            break;
          }
          y += dir * 5;
        }
        return target;
      }
      var ContentEditableInput = function(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.composing = null;
        this.gracePeriod = false;
        this.readDOMTimeout = null;
      };
      ContentEditableInput.prototype.init = function(display) {
        var this$1$1 = this;
        var input = this, cm = input.cm;
        var div = input.div = display.lineDiv;
        div.contentEditable = true;
        disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
        function belongsToInput(e) {
          for (var t = e.target; t; t = t.parentNode) {
            if (t == div) {
              return true;
            }
            if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
              break;
            }
          }
          return false;
        }
        on(div, "paste", function(e) {
          if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
            return;
          }
          if (ie_version <= 11) {
            setTimeout(operation(cm, function() {
              return this$1$1.updateFromDOM();
            }), 20);
          }
        });
        on(div, "compositionstart", function(e) {
          this$1$1.composing = { data: e.data, done: false };
        });
        on(div, "compositionupdate", function(e) {
          if (!this$1$1.composing) {
            this$1$1.composing = { data: e.data, done: false };
          }
        });
        on(div, "compositionend", function(e) {
          if (this$1$1.composing) {
            if (e.data != this$1$1.composing.data) {
              this$1$1.readFromDOMSoon();
            }
            this$1$1.composing.done = true;
          }
        });
        on(div, "touchstart", function() {
          return input.forceCompositionEnd();
        });
        on(div, "input", function() {
          if (!this$1$1.composing) {
            this$1$1.readFromDOMSoon();
          }
        });
        function onCopyCut(e) {
          if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
            return;
          }
          if (cm.somethingSelected()) {
            setLastCopied({ lineWise: false, text: cm.getSelections() });
            if (e.type == "cut") {
              cm.replaceSelection("", null, "cut");
            }
          } else if (!cm.options.lineWiseCopyCut) {
            return;
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({ lineWise: true, text: ranges.text });
            if (e.type == "cut") {
              cm.operation(function() {
                cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                cm.replaceSelection("", null, "cut");
              });
            }
          }
          if (e.clipboardData) {
            e.clipboardData.clearData();
            var content = lastCopied.text.join("\n");
            e.clipboardData.setData("Text", content);
            if (e.clipboardData.getData("Text") == content) {
              e.preventDefault();
              return;
            }
          }
          var kludge = hiddenTextarea(), te = kludge.firstChild;
          disableBrowserMagic(te);
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.text.join("\n");
          var hadFocus = activeElt(rootNode(div));
          selectInput(te);
          setTimeout(function() {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
            if (hadFocus == div) {
              input.showPrimarySelection();
            }
          }, 50);
        }
        on(div, "copy", onCopyCut);
        on(div, "cut", onCopyCut);
      };
      ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
        if (label) {
          this.div.setAttribute("aria-label", label);
        } else {
          this.div.removeAttribute("aria-label");
        }
      };
      ContentEditableInput.prototype.prepareSelection = function() {
        var result = prepareSelection(this.cm, false);
        result.focus = activeElt(rootNode(this.div)) == this.div;
        return result;
      };
      ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
        if (!info || !this.cm.display.view.length) {
          return;
        }
        if (info.focus || takeFocus) {
          this.showPrimarySelection();
        }
        this.showMultipleSelections(info);
      };
      ContentEditableInput.prototype.getSelection = function() {
        return this.cm.display.wrapper.ownerDocument.getSelection();
      };
      ContentEditableInput.prototype.showPrimarySelection = function() {
        var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
        var from2 = prim.from(), to = prim.to();
        if (cm.display.viewTo == cm.display.viewFrom || from2.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
          sel.removeAllRanges();
          return;
        }
        var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from2) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
          return;
        }
        var view = cm.display.view;
        var start = from2.line >= cm.display.viewFrom && posToDOM(cm, from2) || { node: view[0].measure.map[2], offset: 0 };
        var end = to.line < cm.display.viewTo && posToDOM(cm, to);
        if (!end) {
          var measure = view[view.length - 1].measure;
          var map3 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
          end = { node: map3[map3.length - 1], offset: map3[map3.length - 2] - map3[map3.length - 3] };
        }
        if (!start || !end) {
          sel.removeAllRanges();
          return;
        }
        var old = sel.rangeCount && sel.getRangeAt(0), rng;
        try {
          rng = range(start.node, start.offset, end.offset, end.node);
        } catch (e) {
        }
        if (rng) {
          if (!gecko && cm.state.focused) {
            sel.collapse(start.node, start.offset);
            if (!rng.collapsed) {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
          } else {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
          if (old && sel.anchorNode == null) {
            sel.addRange(old);
          } else if (gecko) {
            this.startGracePeriod();
          }
        }
        this.rememberSelection();
      };
      ContentEditableInput.prototype.startGracePeriod = function() {
        var this$1$1 = this;
        clearTimeout(this.gracePeriod);
        this.gracePeriod = setTimeout(function() {
          this$1$1.gracePeriod = false;
          if (this$1$1.selectionChanged()) {
            this$1$1.cm.operation(function() {
              return this$1$1.cm.curOp.selectionChanged = true;
            });
          }
        }, 20);
      };
      ContentEditableInput.prototype.showMultipleSelections = function(info) {
        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
        removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
      };
      ContentEditableInput.prototype.rememberSelection = function() {
        var sel = this.getSelection();
        this.lastAnchorNode = sel.anchorNode;
        this.lastAnchorOffset = sel.anchorOffset;
        this.lastFocusNode = sel.focusNode;
        this.lastFocusOffset = sel.focusOffset;
      };
      ContentEditableInput.prototype.selectionInEditor = function() {
        var sel = this.getSelection();
        if (!sel.rangeCount) {
          return false;
        }
        var node = sel.getRangeAt(0).commonAncestorContainer;
        return contains(this.div, node);
      };
      ContentEditableInput.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor") {
          if (!this.selectionInEditor() || activeElt(rootNode(this.div)) != this.div) {
            this.showSelection(this.prepareSelection(), true);
          }
          this.div.focus();
        }
      };
      ContentEditableInput.prototype.blur = function() {
        this.div.blur();
      };
      ContentEditableInput.prototype.getField = function() {
        return this.div;
      };
      ContentEditableInput.prototype.supportsTouch = function() {
        return true;
      };
      ContentEditableInput.prototype.receivedFocus = function() {
        var this$1$1 = this;
        var input = this;
        if (this.selectionInEditor()) {
          setTimeout(function() {
            return this$1$1.pollSelection();
          }, 20);
        } else {
          runInOp(this.cm, function() {
            return input.cm.curOp.selectionChanged = true;
          });
        }
        function poll() {
          if (input.cm.state.focused) {
            input.pollSelection();
            input.polling.set(input.cm.options.pollInterval, poll);
          }
        }
        this.polling.set(this.cm.options.pollInterval, poll);
      };
      ContentEditableInput.prototype.selectionChanged = function() {
        var sel = this.getSelection();
        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
      };
      ContentEditableInput.prototype.pollSelection = function() {
        if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
          return;
        }
        var sel = this.getSelection(), cm = this.cm;
        if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
          this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
          this.blur();
          this.focus();
          return;
        }
        if (this.composing) {
          return;
        }
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) {
          runInOp(cm, function() {
            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
            if (anchor.bad || head.bad) {
              cm.curOp.selectionChanged = true;
            }
          });
        }
      };
      ContentEditableInput.prototype.pollContent = function() {
        if (this.readDOMTimeout != null) {
          clearTimeout(this.readDOMTimeout);
          this.readDOMTimeout = null;
        }
        var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
        var from2 = sel.from(), to = sel.to();
        if (from2.ch == 0 && from2.line > cm.firstLine()) {
          from2 = Pos(from2.line - 1, getLine(cm.doc, from2.line - 1).length);
        }
        if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
          to = Pos(to.line + 1, 0);
        }
        if (from2.line < display.viewFrom || to.line > display.viewTo - 1) {
          return false;
        }
        var fromIndex, fromLine, fromNode;
        if (from2.line == display.viewFrom || (fromIndex = findViewIndex(cm, from2.line)) == 0) {
          fromLine = lineNo(display.view[0].line);
          fromNode = display.view[0].node;
        } else {
          fromLine = lineNo(display.view[fromIndex].line);
          fromNode = display.view[fromIndex - 1].node.nextSibling;
        }
        var toIndex = findViewIndex(cm, to.line);
        var toLine, toNode;
        if (toIndex == display.view.length - 1) {
          toLine = display.viewTo - 1;
          toNode = display.lineDiv.lastChild;
        } else {
          toLine = lineNo(display.view[toIndex + 1].line) - 1;
          toNode = display.view[toIndex + 1].node.previousSibling;
        }
        if (!fromNode) {
          return false;
        }
        var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
        var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
        while (newText.length > 1 && oldText.length > 1) {
          if (lst(newText) == lst(oldText)) {
            newText.pop();
            oldText.pop();
            toLine--;
          } else if (newText[0] == oldText[0]) {
            newText.shift();
            oldText.shift();
            fromLine++;
          } else {
            break;
          }
        }
        var cutFront = 0, cutEnd = 0;
        var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
        while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
          ++cutFront;
        }
        var newBot = lst(newText), oldBot = lst(oldText);
        var maxCutEnd = Math.min(
          newBot.length - (newText.length == 1 ? cutFront : 0),
          oldBot.length - (oldText.length == 1 ? cutFront : 0)
        );
        while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          ++cutEnd;
        }
        if (newText.length == 1 && oldText.length == 1 && fromLine == from2.line) {
          while (cutFront && cutFront > from2.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            cutFront--;
            cutEnd++;
          }
        }
        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
        newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
        var chFrom = Pos(fromLine, cutFront);
        var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
        if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
          replaceRange(cm.doc, newText, chFrom, chTo, "+input");
          return true;
        }
      };
      ContentEditableInput.prototype.ensurePolled = function() {
        this.forceCompositionEnd();
      };
      ContentEditableInput.prototype.reset = function() {
        this.forceCompositionEnd();
      };
      ContentEditableInput.prototype.forceCompositionEnd = function() {
        if (!this.composing) {
          return;
        }
        clearTimeout(this.readDOMTimeout);
        this.composing = null;
        this.updateFromDOM();
        this.div.blur();
        this.div.focus();
      };
      ContentEditableInput.prototype.readFromDOMSoon = function() {
        var this$1$1 = this;
        if (this.readDOMTimeout != null) {
          return;
        }
        this.readDOMTimeout = setTimeout(function() {
          this$1$1.readDOMTimeout = null;
          if (this$1$1.composing) {
            if (this$1$1.composing.done) {
              this$1$1.composing = null;
            } else {
              return;
            }
          }
          this$1$1.updateFromDOM();
        }, 80);
      };
      ContentEditableInput.prototype.updateFromDOM = function() {
        var this$1$1 = this;
        if (this.cm.isReadOnly() || !this.pollContent()) {
          runInOp(this.cm, function() {
            return regChange(this$1$1.cm);
          });
        }
      };
      ContentEditableInput.prototype.setUneditable = function(node) {
        node.contentEditable = "false";
      };
      ContentEditableInput.prototype.onKeyPress = function(e) {
        if (e.charCode == 0 || this.composing) {
          return;
        }
        e.preventDefault();
        if (!this.cm.isReadOnly()) {
          operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
        }
      };
      ContentEditableInput.prototype.readOnlyChanged = function(val) {
        this.div.contentEditable = String(val != "nocursor");
      };
      ContentEditableInput.prototype.onContextMenu = function() {
      };
      ContentEditableInput.prototype.resetPosition = function() {
      };
      ContentEditableInput.prototype.needsContentAttribute = true;
      function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);
        if (!view || view.hidden) {
          return null;
        }
        var line = getLine(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);
        var order = getOrder(line, cm.doc.direction), side = "left";
        if (order) {
          var partPos = getBidiPartAt(order, pos.ch);
          side = partPos % 2 ? "right" : "left";
        }
        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == "right" ? result.end : result.start;
        return result;
      }
      function isInGutter(node) {
        for (var scan = node; scan; scan = scan.parentNode) {
          if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
            return true;
          }
        }
        return false;
      }
      function badPos(pos, bad) {
        if (bad) {
          pos.bad = true;
        }
        return pos;
      }
      function domTextBetween(cm, from2, to, fromLine, toLine) {
        var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
        function recognizeMarker(id) {
          return function(marker) {
            return marker.id == id;
          };
        }
        function close() {
          if (closing) {
            text += lineSep;
            if (extraLinebreak) {
              text += lineSep;
            }
            closing = extraLinebreak = false;
          }
        }
        function addText(str) {
          if (str) {
            close();
            text += str;
          }
        }
        function walk(node) {
          if (node.nodeType == 1) {
            var cmText = node.getAttribute("cm-text");
            if (cmText) {
              addText(cmText);
              return;
            }
            var markerID = node.getAttribute("cm-marker"), range2;
            if (markerID) {
              var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
              if (found.length && (range2 = found[0].find(0))) {
                addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
              }
              return;
            }
            if (node.getAttribute("contenteditable") == "false") {
              return;
            }
            var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
            if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
              return;
            }
            if (isBlock) {
              close();
            }
            for (var i2 = 0; i2 < node.childNodes.length; i2++) {
              walk(node.childNodes[i2]);
            }
            if (/^(pre|p)$/i.test(node.nodeName)) {
              extraLinebreak = true;
            }
            if (isBlock) {
              closing = true;
            }
          } else if (node.nodeType == 3) {
            addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
          }
        }
        for (; ; ) {
          walk(from2);
          if (from2 == to) {
            break;
          }
          from2 = from2.nextSibling;
          extraLinebreak = false;
        }
        return text;
      }
      function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
          lineNode = cm.display.lineDiv.childNodes[offset];
          if (!lineNode) {
            return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
          }
          node = null;
          offset = 0;
        } else {
          for (lineNode = node; ; lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv) {
              return null;
            }
            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
              break;
            }
          }
        }
        for (var i2 = 0; i2 < cm.display.view.length; i2++) {
          var lineView = cm.display.view[i2];
          if (lineView.node == lineNode) {
            return locateNodeInLineView(lineView, node, offset);
          }
        }
      }
      function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild, bad = false;
        if (!node || !contains(wrapper, node)) {
          return badPos(Pos(lineNo(lineView.line), 0), true);
        }
        if (node == wrapper) {
          bad = true;
          node = wrapper.childNodes[offset];
          offset = 0;
          if (!node) {
            var line = lineView.rest ? lst(lineView.rest) : lineView.line;
            return badPos(Pos(lineNo(line), line.text.length), bad);
          }
        }
        var textNode = node.nodeType == 3 ? node : null, topNode = node;
        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
          textNode = node.firstChild;
          if (offset) {
            offset = textNode.nodeValue.length;
          }
        }
        while (topNode.parentNode != wrapper) {
          topNode = topNode.parentNode;
        }
        var measure = lineView.measure, maps = measure.maps;
        function find(textNode2, topNode2, offset2) {
          for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
            var map3 = i2 < 0 ? measure.map : maps[i2];
            for (var j = 0; j < map3.length; j += 3) {
              var curNode = map3[j + 2];
              if (curNode == textNode2 || curNode == topNode2) {
                var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
                var ch = map3[j] + offset2;
                if (offset2 < 0 || curNode != textNode2) {
                  ch = map3[j + (offset2 ? 1 : 0)];
                }
                return Pos(line2, ch);
              }
            }
          }
        }
        var found = find(textNode, topNode, offset);
        if (found) {
          return badPos(found, bad);
        }
        for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
          found = find(after, after.firstChild, 0);
          if (found) {
            return badPos(Pos(found.line, found.ch - dist), bad);
          } else {
            dist += after.textContent.length;
          }
        }
        for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
          found = find(before, before.firstChild, -1);
          if (found) {
            return badPos(Pos(found.line, found.ch + dist$1), bad);
          } else {
            dist$1 += before.textContent.length;
          }
        }
      }
      var TextareaInput = function(cm) {
        this.cm = cm;
        this.prevInput = "";
        this.pollingFast = false;
        this.polling = new Delayed();
        this.hasSelection = false;
        this.composing = null;
        this.resetting = false;
      };
      TextareaInput.prototype.init = function(display) {
        var this$1$1 = this;
        var input = this, cm = this.cm;
        this.createField(display);
        var te = this.textarea;
        display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
        if (ios) {
          te.style.width = "0px";
        }
        on(te, "input", function() {
          if (ie && ie_version >= 9 && this$1$1.hasSelection) {
            this$1$1.hasSelection = null;
          }
          input.poll();
        });
        on(te, "paste", function(e) {
          if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
            return;
          }
          cm.state.pasteIncoming = +/* @__PURE__ */ new Date();
          input.fastPoll();
        });
        function prepareCopyCut(e) {
          if (signalDOMEvent(cm, e)) {
            return;
          }
          if (cm.somethingSelected()) {
            setLastCopied({ lineWise: false, text: cm.getSelections() });
          } else if (!cm.options.lineWiseCopyCut) {
            return;
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({ lineWise: true, text: ranges.text });
            if (e.type == "cut") {
              cm.setSelections(ranges.ranges, null, sel_dontScroll);
            } else {
              input.prevInput = "";
              te.value = ranges.text.join("\n");
              selectInput(te);
            }
          }
          if (e.type == "cut") {
            cm.state.cutIncoming = +/* @__PURE__ */ new Date();
          }
        }
        on(te, "cut", prepareCopyCut);
        on(te, "copy", prepareCopyCut);
        on(display.scroller, "paste", function(e) {
          if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
            return;
          }
          if (!te.dispatchEvent) {
            cm.state.pasteIncoming = +/* @__PURE__ */ new Date();
            input.focus();
            return;
          }
          var event = new Event("paste");
          event.clipboardData = e.clipboardData;
          te.dispatchEvent(event);
        });
        on(display.lineSpace, "selectstart", function(e) {
          if (!eventInWidget(display, e)) {
            e_preventDefault(e);
          }
        });
        on(te, "compositionstart", function() {
          var start = cm.getCursor("from");
          if (input.composing) {
            input.composing.range.clear();
          }
          input.composing = {
            start,
            range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })
          };
        });
        on(te, "compositionend", function() {
          if (input.composing) {
            input.poll();
            input.composing.range.clear();
            input.composing = null;
          }
        });
      };
      TextareaInput.prototype.createField = function(_display) {
        this.wrapper = hiddenTextarea();
        this.textarea = this.wrapper.firstChild;
        var opts = this.cm.options;
        disableBrowserMagic(this.textarea, opts.spellcheck, opts.autocorrect, opts.autocapitalize);
      };
      TextareaInput.prototype.screenReaderLabelChanged = function(label) {
        if (label) {
          this.textarea.setAttribute("aria-label", label);
        } else {
          this.textarea.removeAttribute("aria-label");
        }
      };
      TextareaInput.prototype.prepareSelection = function() {
        var cm = this.cm, display = cm.display, doc2 = cm.doc;
        var result = prepareSelection(cm);
        if (cm.options.moveInputWithCursor) {
          var headPos = cursorCoords(cm, doc2.sel.primary().head, "div");
          var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
          result.teTop = Math.max(0, Math.min(
            display.wrapper.clientHeight - 10,
            headPos.top + lineOff.top - wrapOff.top
          ));
          result.teLeft = Math.max(0, Math.min(
            display.wrapper.clientWidth - 10,
            headPos.left + lineOff.left - wrapOff.left
          ));
        }
        return result;
      };
      TextareaInput.prototype.showSelection = function(drawn) {
        var cm = this.cm, display = cm.display;
        removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
        removeChildrenAndAdd(display.selectionDiv, drawn.selection);
        if (drawn.teTop != null) {
          this.wrapper.style.top = drawn.teTop + "px";
          this.wrapper.style.left = drawn.teLeft + "px";
        }
      };
      TextareaInput.prototype.reset = function(typing) {
        if (this.contextMenuPending || this.composing && typing) {
          return;
        }
        var cm = this.cm;
        this.resetting = true;
        if (cm.somethingSelected()) {
          this.prevInput = "";
          var content = cm.getSelection();
          this.textarea.value = content;
          if (cm.state.focused) {
            selectInput(this.textarea);
          }
          if (ie && ie_version >= 9) {
            this.hasSelection = content;
          }
        } else if (!typing) {
          this.prevInput = this.textarea.value = "";
          if (ie && ie_version >= 9) {
            this.hasSelection = null;
          }
        }
        this.resetting = false;
      };
      TextareaInput.prototype.getField = function() {
        return this.textarea;
      };
      TextareaInput.prototype.supportsTouch = function() {
        return false;
      };
      TextareaInput.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt(rootNode(this.textarea)) != this.textarea)) {
          try {
            this.textarea.focus();
          } catch (e) {
          }
        }
      };
      TextareaInput.prototype.blur = function() {
        this.textarea.blur();
      };
      TextareaInput.prototype.resetPosition = function() {
        this.wrapper.style.top = this.wrapper.style.left = 0;
      };
      TextareaInput.prototype.receivedFocus = function() {
        this.slowPoll();
      };
      TextareaInput.prototype.slowPoll = function() {
        var this$1$1 = this;
        if (this.pollingFast) {
          return;
        }
        this.polling.set(this.cm.options.pollInterval, function() {
          this$1$1.poll();
          if (this$1$1.cm.state.focused) {
            this$1$1.slowPoll();
          }
        });
      };
      TextareaInput.prototype.fastPoll = function() {
        var missed = false, input = this;
        input.pollingFast = true;
        function p() {
          var changed = input.poll();
          if (!changed && !missed) {
            missed = true;
            input.polling.set(60, p);
          } else {
            input.pollingFast = false;
            input.slowPoll();
          }
        }
        input.polling.set(20, p);
      };
      TextareaInput.prototype.poll = function() {
        var this$1$1 = this;
        var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
        if (this.contextMenuPending || this.resetting || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
          return false;
        }
        var text = input.value;
        if (text == prevInput && !cm.somethingSelected()) {
          return false;
        }
        if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
          cm.display.input.reset();
          return false;
        }
        if (cm.doc.sel == cm.display.selForContextMenu) {
          var first = text.charCodeAt(0);
          if (first == 8203 && !prevInput) {
            prevInput = "​";
          }
          if (first == 8666) {
            this.reset();
            return this.cm.execCommand("undo");
          }
        }
        var same = 0, l = Math.min(prevInput.length, text.length);
        while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
          ++same;
        }
        runInOp(cm, function() {
          applyTextInput(
            cm,
            text.slice(same),
            prevInput.length - same,
            null,
            this$1$1.composing ? "*compose" : null
          );
          if (text.length > 1e3 || text.indexOf("\n") > -1) {
            input.value = this$1$1.prevInput = "";
          } else {
            this$1$1.prevInput = text;
          }
          if (this$1$1.composing) {
            this$1$1.composing.range.clear();
            this$1$1.composing.range = cm.markText(
              this$1$1.composing.start,
              cm.getCursor("to"),
              { className: "CodeMirror-composing" }
            );
          }
        });
        return true;
      };
      TextareaInput.prototype.ensurePolled = function() {
        if (this.pollingFast && this.poll()) {
          this.pollingFast = false;
        }
      };
      TextareaInput.prototype.onKeyPress = function() {
        if (ie && ie_version >= 9) {
          this.hasSelection = null;
        }
        this.fastPoll();
      };
      TextareaInput.prototype.onContextMenu = function(e) {
        var input = this, cm = input.cm, display = cm.display, te = input.textarea;
        if (input.contextMenuPending) {
          input.contextMenuPending();
        }
        var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
        if (!pos || presto) {
          return;
        }
        var reset = cm.options.resetSelectionOnContextMenu;
        if (reset && cm.doc.sel.contains(pos) == -1) {
          operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
        }
        var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
        var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
        input.wrapper.style.cssText = "position: static";
        te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
        var oldScrollY;
        if (webkit) {
          oldScrollY = te.ownerDocument.defaultView.scrollY;
        }
        display.input.focus();
        if (webkit) {
          te.ownerDocument.defaultView.scrollTo(null, oldScrollY);
        }
        display.input.reset();
        if (!cm.somethingSelected()) {
          te.value = input.prevInput = " ";
        }
        input.contextMenuPending = rehide;
        display.selForContextMenu = cm.doc.sel;
        clearTimeout(display.detectingSelectAll);
        function prepareSelectAllHack() {
          if (te.selectionStart != null) {
            var selected = cm.somethingSelected();
            var extval = "​" + (selected ? te.value : "");
            te.value = "⇚";
            te.value = extval;
            input.prevInput = selected ? "" : "​";
            te.selectionStart = 1;
            te.selectionEnd = extval.length;
            display.selForContextMenu = cm.doc.sel;
          }
        }
        function rehide() {
          if (input.contextMenuPending != rehide) {
            return;
          }
          input.contextMenuPending = false;
          input.wrapper.style.cssText = oldWrapperCSS;
          te.style.cssText = oldCSS;
          if (ie && ie_version < 9) {
            display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
          }
          if (te.selectionStart != null) {
            if (!ie || ie && ie_version < 9) {
              prepareSelectAllHack();
            }
            var i2 = 0, poll = function() {
              if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "​") {
                operation(cm, selectAll)(cm);
              } else if (i2++ < 10) {
                display.detectingSelectAll = setTimeout(poll, 500);
              } else {
                display.selForContextMenu = null;
                display.input.reset();
              }
            };
            display.detectingSelectAll = setTimeout(poll, 200);
          }
        }
        if (ie && ie_version >= 9) {
          prepareSelectAllHack();
        }
        if (captureRightClick) {
          e_stop(e);
          var mouseup = function() {
            off(window, "mouseup", mouseup);
            setTimeout(rehide, 20);
          };
          on(window, "mouseup", mouseup);
        } else {
          setTimeout(rehide, 50);
        }
      };
      TextareaInput.prototype.readOnlyChanged = function(val) {
        if (!val) {
          this.reset();
        }
        this.textarea.disabled = val == "nocursor";
        this.textarea.readOnly = !!val;
      };
      TextareaInput.prototype.setUneditable = function() {
      };
      TextareaInput.prototype.needsContentAttribute = false;
      function fromTextArea(textarea, options) {
        options = options ? copyObj(options) : {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabIndex) {
          options.tabindex = textarea.tabIndex;
        }
        if (!options.placeholder && textarea.placeholder) {
          options.placeholder = textarea.placeholder;
        }
        if (options.autofocus == null) {
          var hasFocus = activeElt(rootNode(textarea));
          options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }
        function save() {
          textarea.value = cm.getValue();
        }
        var realSubmit;
        if (textarea.form) {
          on(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form;
            realSubmit = form.submit;
            try {
              var wrappedSubmit = form.submit = function() {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch (e) {
            }
          }
        }
        options.finishInit = function(cm2) {
          cm2.save = save;
          cm2.getTextArea = function() {
            return textarea;
          };
          cm2.toTextArea = function() {
            cm2.toTextArea = isNaN;
            save();
            textarea.parentNode.removeChild(cm2.getWrapperElement());
            textarea.style.display = "";
            if (textarea.form) {
              off(textarea.form, "submit", save);
              if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                textarea.form.submit = realSubmit;
              }
            }
          };
        };
        textarea.style.display = "none";
        var cm = CodeMirror2(
          function(node) {
            return textarea.parentNode.insertBefore(node, textarea.nextSibling);
          },
          options
        );
        return cm;
      }
      function addLegacyProps(CodeMirror3) {
        CodeMirror3.off = off;
        CodeMirror3.on = on;
        CodeMirror3.wheelEventPixels = wheelEventPixels;
        CodeMirror3.Doc = Doc;
        CodeMirror3.splitLines = splitLinesAuto;
        CodeMirror3.countColumn = countColumn;
        CodeMirror3.findColumn = findColumn;
        CodeMirror3.isWordChar = isWordCharBasic;
        CodeMirror3.Pass = Pass;
        CodeMirror3.signal = signal;
        CodeMirror3.Line = Line;
        CodeMirror3.changeEnd = changeEnd;
        CodeMirror3.scrollbarModel = scrollbarModel;
        CodeMirror3.Pos = Pos;
        CodeMirror3.cmpPos = cmp;
        CodeMirror3.modes = modes;
        CodeMirror3.mimeModes = mimeModes;
        CodeMirror3.resolveMode = resolveMode;
        CodeMirror3.getMode = getMode;
        CodeMirror3.modeExtensions = modeExtensions;
        CodeMirror3.extendMode = extendMode;
        CodeMirror3.copyState = copyState;
        CodeMirror3.startState = startState;
        CodeMirror3.innerMode = innerMode;
        CodeMirror3.commands = commands;
        CodeMirror3.keyMap = keyMap2;
        CodeMirror3.keyName = keyName;
        CodeMirror3.isModifierKey = isModifierKey;
        CodeMirror3.lookupKey = lookupKey;
        CodeMirror3.normalizeKeyMap = normalizeKeyMap;
        CodeMirror3.StringStream = StringStream;
        CodeMirror3.SharedTextMarker = SharedTextMarker;
        CodeMirror3.TextMarker = TextMarker;
        CodeMirror3.LineWidget = LineWidget;
        CodeMirror3.e_preventDefault = e_preventDefault;
        CodeMirror3.e_stopPropagation = e_stopPropagation;
        CodeMirror3.e_stop = e_stop;
        CodeMirror3.addClass = addClass;
        CodeMirror3.contains = contains;
        CodeMirror3.rmClass = rmClass;
        CodeMirror3.keyNames = keyNames;
      }
      defineOptions(CodeMirror2);
      addEditorMethods(CodeMirror2);
      var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
      for (var prop in Doc.prototype) {
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
          CodeMirror2.prototype[prop] = /* @__PURE__ */ function(method) {
            return function() {
              return method.apply(this.doc, arguments);
            };
          }(Doc.prototype[prop]);
        }
      }
      eventMixin(Doc);
      CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
      CodeMirror2.defineMode = function(name2) {
        if (!CodeMirror2.defaults.mode && name2 != "null") {
          CodeMirror2.defaults.mode = name2;
        }
        defineMode.apply(this, arguments);
      };
      CodeMirror2.defineMIME = defineMIME;
      CodeMirror2.defineMode("null", function() {
        return { token: function(stream) {
          return stream.skipToEnd();
        } };
      });
      CodeMirror2.defineMIME("text/plain", "null");
      CodeMirror2.defineExtension = function(name2, func) {
        CodeMirror2.prototype[name2] = func;
      };
      CodeMirror2.defineDocExtension = function(name2, func) {
        Doc.prototype[name2] = func;
      };
      CodeMirror2.fromTextArea = fromTextArea;
      addLegacyProps(CodeMirror2);
      CodeMirror2.version = "5.65.18";
      return CodeMirror2;
    });
  })(codemirror$1);
  return codemirror$1.exports;
}
var hasRequiredJavascript;
function requireJavascript() {
  if (hasRequiredJavascript) return javascript.exports;
  hasRequiredJavascript = 1;
  (function(module, exports) {
    (function(mod) {
      mod(requireCodemirror());
    })(function(CodeMirror2) {
      CodeMirror2.defineMode("javascript", function(config, parserConfig) {
        var indentUnit = config.indentUnit;
        var statementIndent = parserConfig.statementIndent;
        var jsonldMode = parserConfig.jsonld;
        var jsonMode = parserConfig.json || jsonldMode;
        var trackScope = parserConfig.trackScope !== false;
        var isTS = parserConfig.typescript;
        var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
        var keywords = function() {
          function kw(type2) {
            return { type: type2, style: "keyword" };
          }
          var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
          var operator = kw("operator"), atom = { type: "atom", style: "atom" };
          return {
            "if": kw("if"),
            "while": A,
            "with": A,
            "else": B,
            "do": B,
            "try": B,
            "finally": B,
            "return": D,
            "break": D,
            "continue": D,
            "new": kw("new"),
            "delete": C,
            "void": C,
            "throw": C,
            "debugger": kw("debugger"),
            "var": kw("var"),
            "const": kw("var"),
            "let": kw("var"),
            "function": kw("function"),
            "catch": kw("catch"),
            "for": kw("for"),
            "switch": kw("switch"),
            "case": kw("case"),
            "default": kw("default"),
            "in": operator,
            "typeof": operator,
            "instanceof": operator,
            "true": atom,
            "false": atom,
            "null": atom,
            "undefined": atom,
            "NaN": atom,
            "Infinity": atom,
            "this": kw("this"),
            "class": kw("class"),
            "super": kw("atom"),
            "yield": C,
            "export": kw("export"),
            "import": kw("import"),
            "extends": C,
            "await": C
          };
        }();
        var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
        var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
        function readRegexp(stream) {
          var escaped = false, next, inSet = false;
          while ((next = stream.next()) != null) {
            if (!escaped) {
              if (next == "/" && !inSet) return;
              if (next == "[") inSet = true;
              else if (inSet && next == "]") inSet = false;
            }
            escaped = !escaped && next == "\\";
          }
        }
        var type, content;
        function ret(tp, style, cont2) {
          type = tp;
          content = cont2;
          return style;
        }
        function tokenBase(stream, state) {
          var ch = stream.next();
          if (ch == '"' || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
            return ret("number", "number");
          } else if (ch == "." && stream.match("..")) {
            return ret("spread", "meta");
          } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
            return ret(ch);
          } else if (ch == "=" && stream.eat(">")) {
            return ret("=>", "operator");
          } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
            return ret("number", "number");
          } else if (/\d/.test(ch)) {
            stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
            return ret("number", "number");
          } else if (ch == "/") {
            if (stream.eat("*")) {
              state.tokenize = tokenComment;
              return tokenComment(stream, state);
            } else if (stream.eat("/")) {
              stream.skipToEnd();
              return ret("comment", "comment");
            } else if (expressionAllowed(stream, state, 1)) {
              readRegexp(stream);
              stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
              return ret("regexp", "string-2");
            } else {
              stream.eat("=");
              return ret("operator", "operator", stream.current());
            }
          } else if (ch == "`") {
            state.tokenize = tokenQuasi;
            return tokenQuasi(stream, state);
          } else if (ch == "#" && stream.peek() == "!") {
            stream.skipToEnd();
            return ret("meta", "meta");
          } else if (ch == "#" && stream.eatWhile(wordRE)) {
            return ret("variable", "property");
          } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (isOperatorChar.test(ch)) {
            if (ch != ">" || !state.lexical || state.lexical.type != ">") {
              if (stream.eat("=")) {
                if (ch == "!" || ch == "=") stream.eat("=");
              } else if (/[<>*+\-|&?]/.test(ch)) {
                stream.eat(ch);
                if (ch == ">") stream.eat(ch);
              }
            }
            if (ch == "?" && stream.eat(".")) return ret(".");
            return ret("operator", "operator", stream.current());
          } else if (wordRE.test(ch)) {
            stream.eatWhile(wordRE);
            var word = stream.current();
            if (state.lastType != ".") {
              if (keywords.propertyIsEnumerable(word)) {
                var kw = keywords[word];
                return ret(kw.type, kw.style, word);
              }
              if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
                return ret("async", "keyword", word);
            }
            return ret("variable", "variable", word);
          }
        }
        function tokenString(quote) {
          return function(stream, state) {
            var escaped = false, next;
            if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
              state.tokenize = tokenBase;
              return ret("jsonld-keyword", "meta");
            }
            while ((next = stream.next()) != null) {
              if (next == quote && !escaped) break;
              escaped = !escaped && next == "\\";
            }
            if (!escaped) state.tokenize = tokenBase;
            return ret("string", "string");
          };
        }
        function tokenComment(stream, state) {
          var maybeEnd = false, ch;
          while (ch = stream.next()) {
            if (ch == "/" && maybeEnd) {
              state.tokenize = tokenBase;
              break;
            }
            maybeEnd = ch == "*";
          }
          return ret("comment", "comment");
        }
        function tokenQuasi(stream, state) {
          var escaped = false, next;
          while ((next = stream.next()) != null) {
            if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
              state.tokenize = tokenBase;
              break;
            }
            escaped = !escaped && next == "\\";
          }
          return ret("quasi", "string-2", stream.current());
        }
        var brackets = "([{}])";
        function findFatArrow(stream, state) {
          if (state.fatArrowAt) state.fatArrowAt = null;
          var arrow = stream.string.indexOf("=>", stream.start);
          if (arrow < 0) return;
          if (isTS) {
            var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
            if (m) arrow = m.index;
          }
          var depth = 0, sawSomething = false;
          for (var pos = arrow - 1; pos >= 0; --pos) {
            var ch = stream.string.charAt(pos);
            var bracket = brackets.indexOf(ch);
            if (bracket >= 0 && bracket < 3) {
              if (!depth) {
                ++pos;
                break;
              }
              if (--depth == 0) {
                if (ch == "(") sawSomething = true;
                break;
              }
            } else if (bracket >= 3 && bracket < 6) {
              ++depth;
            } else if (wordRE.test(ch)) {
              sawSomething = true;
            } else if (/["'\/`]/.test(ch)) {
              for (; ; --pos) {
                if (pos == 0) return;
                var next = stream.string.charAt(pos - 1);
                if (next == ch && stream.string.charAt(pos - 2) != "\\") {
                  pos--;
                  break;
                }
              }
            } else if (sawSomething && !depth) {
              ++pos;
              break;
            }
          }
          if (sawSomething && !depth) state.fatArrowAt = pos;
        }
        var atomicTypes = {
          "atom": true,
          "number": true,
          "variable": true,
          "string": true,
          "regexp": true,
          "this": true,
          "import": true,
          "jsonld-keyword": true
        };
        function JSLexical(indented, column, type2, align, prev, info) {
          this.indented = indented;
          this.column = column;
          this.type = type2;
          this.prev = prev;
          this.info = info;
          if (align != null) this.align = align;
        }
        function inScope(state, varname) {
          if (!trackScope) return false;
          for (var v = state.localVars; v; v = v.next)
            if (v.name == varname) return true;
          for (var cx2 = state.context; cx2; cx2 = cx2.prev) {
            for (var v = cx2.vars; v; v = v.next)
              if (v.name == varname) return true;
          }
        }
        function parseJS(state, style, type2, content2, stream) {
          var cc = state.cc;
          cx.state = state;
          cx.stream = stream;
          cx.marked = null, cx.cc = cc;
          cx.style = style;
          if (!state.lexical.hasOwnProperty("align"))
            state.lexical.align = true;
          while (true) {
            var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
            if (combinator(type2, content2)) {
              while (cc.length && cc[cc.length - 1].lex)
                cc.pop()();
              if (cx.marked) return cx.marked;
              if (type2 == "variable" && inScope(state, content2)) return "variable-2";
              return style;
            }
          }
        }
        var cx = { state: null, marked: null, cc: null };
        function pass() {
          for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
        }
        function cont() {
          pass.apply(null, arguments);
          return true;
        }
        function inList(name2, list) {
          for (var v = list; v; v = v.next) if (v.name == name2) return true;
          return false;
        }
        function register(varname) {
          var state = cx.state;
          cx.marked = "def";
          if (!trackScope) return;
          if (state.context) {
            if (state.lexical.info == "var" && state.context && state.context.block) {
              var newContext = registerVarScoped(varname, state.context);
              if (newContext != null) {
                state.context = newContext;
                return;
              }
            } else if (!inList(varname, state.localVars)) {
              state.localVars = new Var(varname, state.localVars);
              return;
            }
          }
          if (parserConfig.globalVars && !inList(varname, state.globalVars))
            state.globalVars = new Var(varname, state.globalVars);
        }
        function registerVarScoped(varname, context) {
          if (!context) {
            return null;
          } else if (context.block) {
            var inner = registerVarScoped(varname, context.prev);
            if (!inner) return null;
            if (inner == context.prev) return context;
            return new Context(inner, context.vars, true);
          } else if (inList(varname, context.vars)) {
            return context;
          } else {
            return new Context(context.prev, new Var(varname, context.vars), false);
          }
        }
        function isModifier(name2) {
          return name2 == "public" || name2 == "private" || name2 == "protected" || name2 == "abstract" || name2 == "readonly";
        }
        function Context(prev, vars, block2) {
          this.prev = prev;
          this.vars = vars;
          this.block = block2;
        }
        function Var(name2, next) {
          this.name = name2;
          this.next = next;
        }
        var defaultVars = new Var("this", new Var("arguments", null));
        function pushcontext() {
          cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
          cx.state.localVars = defaultVars;
        }
        function pushblockcontext() {
          cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
          cx.state.localVars = null;
        }
        pushcontext.lex = pushblockcontext.lex = true;
        function popcontext() {
          cx.state.localVars = cx.state.context.vars;
          cx.state.context = cx.state.context.prev;
        }
        popcontext.lex = true;
        function pushlex(type2, info) {
          var result = function() {
            var state = cx.state, indent = state.indented;
            if (state.lexical.type == "stat") indent = state.lexical.indented;
            else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
              indent = outer.indented;
            state.lexical = new JSLexical(indent, cx.stream.column(), type2, null, state.lexical, info);
          };
          result.lex = true;
          return result;
        }
        function poplex() {
          var state = cx.state;
          if (state.lexical.prev) {
            if (state.lexical.type == ")")
              state.indented = state.lexical.indented;
            state.lexical = state.lexical.prev;
          }
        }
        poplex.lex = true;
        function expect(wanted) {
          function exp(type2) {
            if (type2 == wanted) return cont();
            else if (wanted == ";" || type2 == "}" || type2 == ")" || type2 == "]") return pass();
            else return cont(exp);
          }
          return exp;
        }
        function statement(type2, value) {
          if (type2 == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
          if (type2 == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
          if (type2 == "keyword b") return cont(pushlex("form"), statement, poplex);
          if (type2 == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
          if (type2 == "debugger") return cont(expect(";"));
          if (type2 == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
          if (type2 == ";") return cont();
          if (type2 == "if") {
            if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
              cx.state.cc.pop()();
            return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
          }
          if (type2 == "function") return cont(functiondef);
          if (type2 == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
          if (type2 == "class" || isTS && value == "interface") {
            cx.marked = "keyword";
            return cont(pushlex("form", type2 == "class" ? type2 : value), className, poplex);
          }
          if (type2 == "variable") {
            if (isTS && value == "declare") {
              cx.marked = "keyword";
              return cont(statement);
            } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
              cx.marked = "keyword";
              if (value == "enum") return cont(enumdef);
              else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
              else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
            } else if (isTS && value == "namespace") {
              cx.marked = "keyword";
              return cont(pushlex("form"), expression, statement, poplex);
            } else if (isTS && value == "abstract") {
              cx.marked = "keyword";
              return cont(statement);
            } else {
              return cont(pushlex("stat"), maybelabel);
            }
          }
          if (type2 == "switch") return cont(
            pushlex("form"),
            parenExpr,
            expect("{"),
            pushlex("}", "switch"),
            pushblockcontext,
            block,
            poplex,
            poplex,
            popcontext
          );
          if (type2 == "case") return cont(expression, expect(":"));
          if (type2 == "default") return cont(expect(":"));
          if (type2 == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
          if (type2 == "export") return cont(pushlex("stat"), afterExport, poplex);
          if (type2 == "import") return cont(pushlex("stat"), afterImport, poplex);
          if (type2 == "async") return cont(statement);
          if (value == "@") return cont(expression, statement);
          return pass(pushlex("stat"), expression, expect(";"), poplex);
        }
        function maybeCatchBinding(type2) {
          if (type2 == "(") return cont(funarg, expect(")"));
        }
        function expression(type2, value) {
          return expressionInner(type2, value, false);
        }
        function expressionNoComma(type2, value) {
          return expressionInner(type2, value, true);
        }
        function parenExpr(type2) {
          if (type2 != "(") return pass();
          return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
        }
        function expressionInner(type2, value, noComma) {
          if (cx.state.fatArrowAt == cx.stream.start) {
            var body = noComma ? arrowBodyNoComma : arrowBody;
            if (type2 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
            else if (type2 == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
          }
          var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
          if (atomicTypes.hasOwnProperty(type2)) return cont(maybeop);
          if (type2 == "function") return cont(functiondef, maybeop);
          if (type2 == "class" || isTS && value == "interface") {
            cx.marked = "keyword";
            return cont(pushlex("form"), classExpression, poplex);
          }
          if (type2 == "keyword c" || type2 == "async") return cont(noComma ? expressionNoComma : expression);
          if (type2 == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
          if (type2 == "operator" || type2 == "spread") return cont(noComma ? expressionNoComma : expression);
          if (type2 == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
          if (type2 == "{") return contCommasep(objprop, "}", null, maybeop);
          if (type2 == "quasi") return pass(quasi, maybeop);
          if (type2 == "new") return cont(maybeTarget(noComma));
          return cont();
        }
        function maybeexpression(type2) {
          if (type2.match(/[;\}\)\],]/)) return pass();
          return pass(expression);
        }
        function maybeoperatorComma(type2, value) {
          if (type2 == ",") return cont(maybeexpression);
          return maybeoperatorNoComma(type2, value, false);
        }
        function maybeoperatorNoComma(type2, value, noComma) {
          var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
          var expr = noComma == false ? expression : expressionNoComma;
          if (type2 == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
          if (type2 == "operator") {
            if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
            if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
              return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
            if (value == "?") return cont(expression, expect(":"), expr);
            return cont(expr);
          }
          if (type2 == "quasi") {
            return pass(quasi, me);
          }
          if (type2 == ";") return;
          if (type2 == "(") return contCommasep(expressionNoComma, ")", "call", me);
          if (type2 == ".") return cont(property, me);
          if (type2 == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
          if (isTS && value == "as") {
            cx.marked = "keyword";
            return cont(typeexpr, me);
          }
          if (type2 == "regexp") {
            cx.state.lastType = cx.marked = "operator";
            cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
            return cont(expr);
          }
        }
        function quasi(type2, value) {
          if (type2 != "quasi") return pass();
          if (value.slice(value.length - 2) != "${") return cont(quasi);
          return cont(maybeexpression, continueQuasi);
        }
        function continueQuasi(type2) {
          if (type2 == "}") {
            cx.marked = "string-2";
            cx.state.tokenize = tokenQuasi;
            return cont(quasi);
          }
        }
        function arrowBody(type2) {
          findFatArrow(cx.stream, cx.state);
          return pass(type2 == "{" ? statement : expression);
        }
        function arrowBodyNoComma(type2) {
          findFatArrow(cx.stream, cx.state);
          return pass(type2 == "{" ? statement : expressionNoComma);
        }
        function maybeTarget(noComma) {
          return function(type2) {
            if (type2 == ".") return cont(noComma ? targetNoComma : target);
            else if (type2 == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
            else return pass(noComma ? expressionNoComma : expression);
          };
        }
        function target(_, value) {
          if (value == "target") {
            cx.marked = "keyword";
            return cont(maybeoperatorComma);
          }
        }
        function targetNoComma(_, value) {
          if (value == "target") {
            cx.marked = "keyword";
            return cont(maybeoperatorNoComma);
          }
        }
        function maybelabel(type2) {
          if (type2 == ":") return cont(poplex, statement);
          return pass(maybeoperatorComma, expect(";"), poplex);
        }
        function property(type2) {
          if (type2 == "variable") {
            cx.marked = "property";
            return cont();
          }
        }
        function objprop(type2, value) {
          if (type2 == "async") {
            cx.marked = "property";
            return cont(objprop);
          } else if (type2 == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            if (value == "get" || value == "set") return cont(getterSetter);
            var m;
            if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
              cx.state.fatArrowAt = cx.stream.pos + m[0].length;
            return cont(afterprop);
          } else if (type2 == "number" || type2 == "string") {
            cx.marked = jsonldMode ? "property" : cx.style + " property";
            return cont(afterprop);
          } else if (type2 == "jsonld-keyword") {
            return cont(afterprop);
          } else if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(objprop);
          } else if (type2 == "[") {
            return cont(expression, maybetype, expect("]"), afterprop);
          } else if (type2 == "spread") {
            return cont(expressionNoComma, afterprop);
          } else if (value == "*") {
            cx.marked = "keyword";
            return cont(objprop);
          } else if (type2 == ":") {
            return pass(afterprop);
          }
        }
        function getterSetter(type2) {
          if (type2 != "variable") return pass(afterprop);
          cx.marked = "property";
          return cont(functiondef);
        }
        function afterprop(type2) {
          if (type2 == ":") return cont(expressionNoComma);
          if (type2 == "(") return pass(functiondef);
        }
        function commasep(what, end, sep) {
          function proceed(type2, value) {
            if (sep ? sep.indexOf(type2) > -1 : type2 == ",") {
              var lex = cx.state.lexical;
              if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
              return cont(function(type3, value2) {
                if (type3 == end || value2 == end) return pass();
                return pass(what);
              }, proceed);
            }
            if (type2 == end || value == end) return cont();
            if (sep && sep.indexOf(";") > -1) return pass(what);
            return cont(expect(end));
          }
          return function(type2, value) {
            if (type2 == end || value == end) return cont();
            return pass(what, proceed);
          };
        }
        function contCommasep(what, end, info) {
          for (var i = 3; i < arguments.length; i++)
            cx.cc.push(arguments[i]);
          return cont(pushlex(end, info), commasep(what, end), poplex);
        }
        function block(type2) {
          if (type2 == "}") return cont();
          return pass(statement, block);
        }
        function maybetype(type2, value) {
          if (isTS) {
            if (type2 == ":") return cont(typeexpr);
            if (value == "?") return cont(maybetype);
          }
        }
        function maybetypeOrIn(type2, value) {
          if (isTS && (type2 == ":" || value == "in")) return cont(typeexpr);
        }
        function mayberettype(type2) {
          if (isTS && type2 == ":") {
            if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr);
            else return cont(typeexpr);
          }
        }
        function isKW(_, value) {
          if (value == "is") {
            cx.marked = "keyword";
            return cont();
          }
        }
        function typeexpr(type2, value) {
          if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
            cx.marked = "keyword";
            return cont(value == "typeof" ? expressionNoComma : typeexpr);
          }
          if (type2 == "variable" || value == "void") {
            cx.marked = "type";
            return cont(afterType);
          }
          if (value == "|" || value == "&") return cont(typeexpr);
          if (type2 == "string" || type2 == "number" || type2 == "atom") return cont(afterType);
          if (type2 == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
          if (type2 == "{") return cont(pushlex("}"), typeprops, poplex, afterType);
          if (type2 == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType);
          if (type2 == "<") return cont(commasep(typeexpr, ">"), typeexpr);
          if (type2 == "quasi") {
            return pass(quasiType, afterType);
          }
        }
        function maybeReturnType(type2) {
          if (type2 == "=>") return cont(typeexpr);
        }
        function typeprops(type2) {
          if (type2.match(/[\}\)\]]/)) return cont();
          if (type2 == "," || type2 == ";") return cont(typeprops);
          return pass(typeprop, typeprops);
        }
        function typeprop(type2, value) {
          if (type2 == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            return cont(typeprop);
          } else if (value == "?" || type2 == "number" || type2 == "string") {
            return cont(typeprop);
          } else if (type2 == ":") {
            return cont(typeexpr);
          } else if (type2 == "[") {
            return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
          } else if (type2 == "(") {
            return pass(functiondecl, typeprop);
          } else if (!type2.match(/[;\}\)\],]/)) {
            return cont();
          }
        }
        function quasiType(type2, value) {
          if (type2 != "quasi") return pass();
          if (value.slice(value.length - 2) != "${") return cont(quasiType);
          return cont(typeexpr, continueQuasiType);
        }
        function continueQuasiType(type2) {
          if (type2 == "}") {
            cx.marked = "string-2";
            cx.state.tokenize = tokenQuasi;
            return cont(quasiType);
          }
        }
        function typearg(type2, value) {
          if (type2 == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg);
          if (type2 == ":") return cont(typeexpr);
          if (type2 == "spread") return cont(typearg);
          return pass(typeexpr);
        }
        function afterType(type2, value) {
          if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
          if (value == "|" || type2 == "." || value == "&") return cont(typeexpr);
          if (type2 == "[") return cont(typeexpr, expect("]"), afterType);
          if (value == "extends" || value == "implements") {
            cx.marked = "keyword";
            return cont(typeexpr);
          }
          if (value == "?") return cont(typeexpr, expect(":"), typeexpr);
        }
        function maybeTypeArgs(_, value) {
          if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
        }
        function typeparam() {
          return pass(typeexpr, maybeTypeDefault);
        }
        function maybeTypeDefault(_, value) {
          if (value == "=") return cont(typeexpr);
        }
        function vardef(_, value) {
          if (value == "enum") {
            cx.marked = "keyword";
            return cont(enumdef);
          }
          return pass(pattern, maybetype, maybeAssign, vardefCont);
        }
        function pattern(type2, value) {
          if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(pattern);
          }
          if (type2 == "variable") {
            register(value);
            return cont();
          }
          if (type2 == "spread") return cont(pattern);
          if (type2 == "[") return contCommasep(eltpattern, "]");
          if (type2 == "{") return contCommasep(proppattern, "}");
        }
        function proppattern(type2, value) {
          if (type2 == "variable" && !cx.stream.match(/^\s*:/, false)) {
            register(value);
            return cont(maybeAssign);
          }
          if (type2 == "variable") cx.marked = "property";
          if (type2 == "spread") return cont(pattern);
          if (type2 == "}") return pass();
          if (type2 == "[") return cont(expression, expect("]"), expect(":"), proppattern);
          return cont(expect(":"), pattern, maybeAssign);
        }
        function eltpattern() {
          return pass(pattern, maybeAssign);
        }
        function maybeAssign(_type, value) {
          if (value == "=") return cont(expressionNoComma);
        }
        function vardefCont(type2) {
          if (type2 == ",") return cont(vardef);
        }
        function maybeelse(type2, value) {
          if (type2 == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
        }
        function forspec(type2, value) {
          if (value == "await") return cont(forspec);
          if (type2 == "(") return cont(pushlex(")"), forspec1, poplex);
        }
        function forspec1(type2) {
          if (type2 == "var") return cont(vardef, forspec2);
          if (type2 == "variable") return cont(forspec2);
          return pass(forspec2);
        }
        function forspec2(type2, value) {
          if (type2 == ")") return cont();
          if (type2 == ";") return cont(forspec2);
          if (value == "in" || value == "of") {
            cx.marked = "keyword";
            return cont(expression, forspec2);
          }
          return pass(expression, forspec2);
        }
        function functiondef(type2, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(functiondef);
          }
          if (type2 == "variable") {
            register(value);
            return cont(functiondef);
          }
          if (type2 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
          if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
        }
        function functiondecl(type2, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(functiondecl);
          }
          if (type2 == "variable") {
            register(value);
            return cont(functiondecl);
          }
          if (type2 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
          if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
        }
        function typename(type2, value) {
          if (type2 == "keyword" || type2 == "variable") {
            cx.marked = "type";
            return cont(typename);
          } else if (value == "<") {
            return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
          }
        }
        function funarg(type2, value) {
          if (value == "@") cont(expression, funarg);
          if (type2 == "spread") return cont(funarg);
          if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(funarg);
          }
          if (isTS && type2 == "this") return cont(maybetype, maybeAssign);
          return pass(pattern, maybetype, maybeAssign);
        }
        function classExpression(type2, value) {
          if (type2 == "variable") return className(type2, value);
          return classNameAfter(type2, value);
        }
        function className(type2, value) {
          if (type2 == "variable") {
            register(value);
            return cont(classNameAfter);
          }
        }
        function classNameAfter(type2, value) {
          if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
          if (value == "extends" || value == "implements" || isTS && type2 == ",") {
            if (value == "implements") cx.marked = "keyword";
            return cont(isTS ? typeexpr : expression, classNameAfter);
          }
          if (type2 == "{") return cont(pushlex("}"), classBody, poplex);
        }
        function classBody(type2, value) {
          if (type2 == "async" || type2 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+#?[\w$\xa1-\uffff]/, false)) {
            cx.marked = "keyword";
            return cont(classBody);
          }
          if (type2 == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            return cont(classfield, classBody);
          }
          if (type2 == "number" || type2 == "string") return cont(classfield, classBody);
          if (type2 == "[")
            return cont(expression, maybetype, expect("]"), classfield, classBody);
          if (value == "*") {
            cx.marked = "keyword";
            return cont(classBody);
          }
          if (isTS && type2 == "(") return pass(functiondecl, classBody);
          if (type2 == ";" || type2 == ",") return cont(classBody);
          if (type2 == "}") return cont();
          if (value == "@") return cont(expression, classBody);
        }
        function classfield(type2, value) {
          if (value == "!") return cont(classfield);
          if (value == "?") return cont(classfield);
          if (type2 == ":") return cont(typeexpr, maybeAssign);
          if (value == "=") return cont(expressionNoComma);
          var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
          return pass(isInterface ? functiondecl : functiondef);
        }
        function afterExport(type2, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(maybeFrom, expect(";"));
          }
          if (value == "default") {
            cx.marked = "keyword";
            return cont(expression, expect(";"));
          }
          if (type2 == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
          return pass(statement);
        }
        function exportField(type2, value) {
          if (value == "as") {
            cx.marked = "keyword";
            return cont(expect("variable"));
          }
          if (type2 == "variable") return pass(expressionNoComma, exportField);
        }
        function afterImport(type2) {
          if (type2 == "string") return cont();
          if (type2 == "(") return pass(expression);
          if (type2 == ".") return pass(maybeoperatorComma);
          return pass(importSpec, maybeMoreImports, maybeFrom);
        }
        function importSpec(type2, value) {
          if (type2 == "{") return contCommasep(importSpec, "}");
          if (type2 == "variable") register(value);
          if (value == "*") cx.marked = "keyword";
          return cont(maybeAs);
        }
        function maybeMoreImports(type2) {
          if (type2 == ",") return cont(importSpec, maybeMoreImports);
        }
        function maybeAs(_type, value) {
          if (value == "as") {
            cx.marked = "keyword";
            return cont(importSpec);
          }
        }
        function maybeFrom(_type, value) {
          if (value == "from") {
            cx.marked = "keyword";
            return cont(expression);
          }
        }
        function arrayLiteral(type2) {
          if (type2 == "]") return cont();
          return pass(commasep(expressionNoComma, "]"));
        }
        function enumdef() {
          return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
        }
        function enummember() {
          return pass(pattern, maybeAssign);
        }
        function isContinuedStatement(state, textAfter) {
          return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
        }
        function expressionAllowed(stream, state, backUp) {
          return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
        }
        return {
          startState: function(basecolumn) {
            var state = {
              tokenize: tokenBase,
              lastType: "sof",
              cc: [],
              lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
              localVars: parserConfig.localVars,
              context: parserConfig.localVars && new Context(null, null, false),
              indented: basecolumn || 0
            };
            if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
              state.globalVars = parserConfig.globalVars;
            return state;
          },
          token: function(stream, state) {
            if (stream.sol()) {
              if (!state.lexical.hasOwnProperty("align"))
                state.lexical.align = false;
              state.indented = stream.indentation();
              findFatArrow(stream, state);
            }
            if (state.tokenize != tokenComment && stream.eatSpace()) return null;
            var style = state.tokenize(stream, state);
            if (type == "comment") return style;
            state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
            return parseJS(state, style, type, content, stream);
          },
          indent: function(state, textAfter) {
            if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror2.Pass;
            if (state.tokenize != tokenBase) return 0;
            var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;
            if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
              var c = state.cc[i];
              if (c == poplex) lexical = lexical.prev;
              else if (c != maybeelse && c != popcontext) break;
            }
            while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)))
              lexical = lexical.prev;
            if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
              lexical = lexical.prev;
            var type2 = lexical.type, closing = firstChar == type2;
            if (type2 == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
            else if (type2 == "form" && firstChar == "{") return lexical.indented;
            else if (type2 == "form") return lexical.indented + indentUnit;
            else if (type2 == "stat")
              return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
            else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
              return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
            else if (lexical.align) return lexical.column + (closing ? 0 : 1);
            else return lexical.indented + (closing ? 0 : indentUnit);
          },
          electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
          blockCommentStart: jsonMode ? null : "/*",
          blockCommentEnd: jsonMode ? null : "*/",
          blockCommentContinue: jsonMode ? null : " * ",
          lineComment: jsonMode ? null : "//",
          fold: "brace",
          closeBrackets: "()[]{}''\"\"``",
          helperType: jsonMode ? "json" : "javascript",
          jsonldMode,
          jsonMode,
          expressionAllowed,
          skipExpression: function(state) {
            parseJS(state, "atom", "atom", "true", new CodeMirror2.StringStream("", 2, null));
          }
        };
      });
      CodeMirror2.registerHelper("wordChars", "javascript", /[\w$]/);
      CodeMirror2.defineMIME("text/javascript", "javascript");
      CodeMirror2.defineMIME("text/ecmascript", "javascript");
      CodeMirror2.defineMIME("application/javascript", "javascript");
      CodeMirror2.defineMIME("application/x-javascript", "javascript");
      CodeMirror2.defineMIME("application/ecmascript", "javascript");
      CodeMirror2.defineMIME("application/json", { name: "javascript", json: true });
      CodeMirror2.defineMIME("application/x-json", { name: "javascript", json: true });
      CodeMirror2.defineMIME("application/manifest+json", { name: "javascript", json: true });
      CodeMirror2.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
      CodeMirror2.defineMIME("text/typescript", { name: "javascript", typescript: true });
      CodeMirror2.defineMIME("application/typescript", { name: "javascript", typescript: true });
    });
  })();
  return javascript.exports;
}
requireJavascript();
var foldcode = { exports: {} };
var hasRequiredFoldcode;
function requireFoldcode() {
  if (hasRequiredFoldcode) return foldcode.exports;
  hasRequiredFoldcode = 1;
  (function(module, exports) {
    (function(mod) {
      mod(requireCodemirror());
    })(function(CodeMirror2) {
      function doFold(cm, pos, options, force) {
        if (options && options.call) {
          var finder = options;
          options = null;
        } else {
          var finder = getOption(cm, options, "rangeFinder");
        }
        if (typeof pos == "number") pos = CodeMirror2.Pos(pos, 0);
        var minSize = getOption(cm, options, "minFoldSize");
        function getRange(allowFolded) {
          var range2 = finder(cm, pos);
          if (!range2 || range2.to.line - range2.from.line < minSize) return null;
          if (force === "fold") return range2;
          var marks = cm.findMarksAt(range2.from);
          for (var i = 0; i < marks.length; ++i) {
            if (marks[i].__isFold) {
              if (!allowFolded) return null;
              range2.cleared = true;
              marks[i].clear();
            }
          }
          return range2;
        }
        var range = getRange(true);
        if (getOption(cm, options, "scanUp")) while (!range && pos.line > cm.firstLine()) {
          pos = CodeMirror2.Pos(pos.line - 1, 0);
          range = getRange(false);
        }
        if (!range || range.cleared || force === "unfold") return;
        var myWidget = makeWidget(cm, options, range);
        CodeMirror2.on(myWidget, "mousedown", function(e) {
          myRange.clear();
          CodeMirror2.e_preventDefault(e);
        });
        var myRange = cm.markText(range.from, range.to, {
          replacedWith: myWidget,
          clearOnEnter: getOption(cm, options, "clearOnEnter"),
          __isFold: true
        });
        myRange.on("clear", function(from2, to) {
          CodeMirror2.signal(cm, "unfold", cm, from2, to);
        });
        CodeMirror2.signal(cm, "fold", cm, range.from, range.to);
      }
      function makeWidget(cm, options, range) {
        var widget = getOption(cm, options, "widget");
        if (typeof widget == "function") {
          widget = widget(range.from, range.to);
        }
        if (typeof widget == "string") {
          var text = document.createTextNode(widget);
          widget = document.createElement("span");
          widget.appendChild(text);
          widget.className = "CodeMirror-foldmarker";
        } else if (widget) {
          widget = widget.cloneNode(true);
        }
        return widget;
      }
      CodeMirror2.newFoldFunction = function(rangeFinder, widget) {
        return function(cm, pos) {
          doFold(cm, pos, { rangeFinder, widget });
        };
      };
      CodeMirror2.defineExtension("foldCode", function(pos, options, force) {
        doFold(this, pos, options, force);
      });
      CodeMirror2.defineExtension("isFolded", function(pos) {
        var marks = this.findMarksAt(pos);
        for (var i = 0; i < marks.length; ++i)
          if (marks[i].__isFold) return true;
      });
      CodeMirror2.commands.toggleFold = function(cm) {
        cm.foldCode(cm.getCursor());
      };
      CodeMirror2.commands.fold = function(cm) {
        cm.foldCode(cm.getCursor(), null, "fold");
      };
      CodeMirror2.commands.unfold = function(cm) {
        cm.foldCode(cm.getCursor(), { scanUp: false }, "unfold");
      };
      CodeMirror2.commands.foldAll = function(cm) {
        cm.operation(function() {
          for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
            cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "fold");
        });
      };
      CodeMirror2.commands.unfoldAll = function(cm) {
        cm.operation(function() {
          for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
            cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "unfold");
        });
      };
      CodeMirror2.registerHelper("fold", "combine", function() {
        var funcs = Array.prototype.slice.call(arguments, 0);
        return function(cm, start) {
          for (var i = 0; i < funcs.length; ++i) {
            var found = funcs[i](cm, start);
            if (found) return found;
          }
        };
      });
      CodeMirror2.registerHelper("fold", "auto", function(cm, start) {
        var helpers = cm.getHelpers(start, "fold");
        for (var i = 0; i < helpers.length; i++) {
          var cur = helpers[i](cm, start);
          if (cur) return cur;
        }
      });
      var defaultOptions = {
        rangeFinder: CodeMirror2.fold.auto,
        widget: "↔",
        minFoldSize: 0,
        scanUp: false,
        clearOnEnter: true
      };
      CodeMirror2.defineOption("foldOptions", null);
      function getOption(cm, options, name2) {
        if (options && options[name2] !== void 0)
          return options[name2];
        var editorOptions = cm.options.foldOptions;
        if (editorOptions && editorOptions[name2] !== void 0)
          return editorOptions[name2];
        return defaultOptions[name2];
      }
      CodeMirror2.defineExtension("foldOption", function(options, name2) {
        return getOption(this, options, name2);
      });
    });
  })();
  return foldcode.exports;
}
requireFoldcode();
var foldgutter = { exports: {} };
var hasRequiredFoldgutter;
function requireFoldgutter() {
  if (hasRequiredFoldgutter) return foldgutter.exports;
  hasRequiredFoldgutter = 1;
  (function(module, exports) {
    (function(mod) {
      mod(requireCodemirror(), requireFoldcode());
    })(function(CodeMirror2) {
      CodeMirror2.defineOption("foldGutter", false, function(cm, val, old) {
        if (old && old != CodeMirror2.Init) {
          cm.clearGutter(cm.state.foldGutter.options.gutter);
          cm.state.foldGutter = null;
          cm.off("gutterClick", onGutterClick);
          cm.off("changes", onChange);
          cm.off("viewportChange", onViewportChange);
          cm.off("fold", onFold);
          cm.off("unfold", onFold);
          cm.off("swapDoc", onChange);
          cm.off("optionChange", optionChange);
        }
        if (val) {
          cm.state.foldGutter = new State(parseOptions(val));
          updateInViewport(cm);
          cm.on("gutterClick", onGutterClick);
          cm.on("changes", onChange);
          cm.on("viewportChange", onViewportChange);
          cm.on("fold", onFold);
          cm.on("unfold", onFold);
          cm.on("swapDoc", onChange);
          cm.on("optionChange", optionChange);
        }
      });
      var Pos = CodeMirror2.Pos;
      function State(options) {
        this.options = options;
        this.from = this.to = 0;
      }
      function parseOptions(opts) {
        if (opts === true) opts = {};
        if (opts.gutter == null) opts.gutter = "CodeMirror-foldgutter";
        if (opts.indicatorOpen == null) opts.indicatorOpen = "CodeMirror-foldgutter-open";
        if (opts.indicatorFolded == null) opts.indicatorFolded = "CodeMirror-foldgutter-folded";
        return opts;
      }
      function isFolded(cm, line) {
        var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
        for (var i = 0; i < marks.length; ++i) {
          if (marks[i].__isFold) {
            var fromPos = marks[i].find(-1);
            if (fromPos && fromPos.line === line)
              return marks[i];
          }
        }
      }
      function marker(spec) {
        if (typeof spec == "string") {
          var elt = document.createElement("div");
          elt.className = spec + " CodeMirror-guttermarker-subtle";
          return elt;
        } else {
          return spec.cloneNode(true);
        }
      }
      function updateFoldInfo(cm, from2, to) {
        var opts = cm.state.foldGutter.options, cur = from2 - 1;
        var minSize = cm.foldOption(opts, "minFoldSize");
        var func = cm.foldOption(opts, "rangeFinder");
        var clsFolded = typeof opts.indicatorFolded == "string" && classTest(opts.indicatorFolded);
        var clsOpen = typeof opts.indicatorOpen == "string" && classTest(opts.indicatorOpen);
        cm.eachLine(from2, to, function(line) {
          ++cur;
          var mark = null;
          var old = line.gutterMarkers;
          if (old) old = old[opts.gutter];
          if (isFolded(cm, cur)) {
            if (clsFolded && old && clsFolded.test(old.className)) return;
            mark = marker(opts.indicatorFolded);
          } else {
            var pos = Pos(cur, 0);
            var range = func && func(cm, pos);
            if (range && range.to.line - range.from.line >= minSize) {
              if (clsOpen && old && clsOpen.test(old.className)) return;
              mark = marker(opts.indicatorOpen);
            }
          }
          if (!mark && !old) return;
          cm.setGutterMarker(line, opts.gutter, mark);
        });
      }
      function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
      }
      function updateInViewport(cm) {
        var vp = cm.getViewport(), state = cm.state.foldGutter;
        if (!state) return;
        cm.operation(function() {
          updateFoldInfo(cm, vp.from, vp.to);
        });
        state.from = vp.from;
        state.to = vp.to;
      }
      function onGutterClick(cm, line, gutter) {
        var state = cm.state.foldGutter;
        if (!state) return;
        var opts = state.options;
        if (gutter != opts.gutter) return;
        var folded = isFolded(cm, line);
        if (folded) folded.clear();
        else cm.foldCode(Pos(line, 0), opts);
      }
      function optionChange(cm, option) {
        if (option == "mode") onChange(cm);
      }
      function onChange(cm) {
        var state = cm.state.foldGutter;
        if (!state) return;
        var opts = state.options;
        state.from = state.to = 0;
        clearTimeout(state.changeUpdate);
        state.changeUpdate = setTimeout(function() {
          updateInViewport(cm);
        }, opts.foldOnChangeTimeSpan || 600);
      }
      function onViewportChange(cm) {
        var state = cm.state.foldGutter;
        if (!state) return;
        var opts = state.options;
        clearTimeout(state.changeUpdate);
        state.changeUpdate = setTimeout(function() {
          var vp = cm.getViewport();
          if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
            updateInViewport(cm);
          } else {
            cm.operation(function() {
              if (vp.from < state.from) {
                updateFoldInfo(cm, vp.from, state.from);
                state.from = vp.from;
              }
              if (vp.to > state.to) {
                updateFoldInfo(cm, state.to, vp.to);
                state.to = vp.to;
              }
            });
          }
        }, opts.updateViewportTimeSpan || 400);
      }
      function onFold(cm, from2) {
        var state = cm.state.foldGutter;
        if (!state) return;
        var line = from2.line;
        if (line >= state.from && line < state.to)
          updateFoldInfo(cm, line, line + 1);
      }
    });
  })();
  return foldgutter.exports;
}
requireFoldgutter();
var braceFold = { exports: {} };
var hasRequiredBraceFold;
function requireBraceFold() {
  if (hasRequiredBraceFold) return braceFold.exports;
  hasRequiredBraceFold = 1;
  (function(module, exports) {
    (function(mod) {
      mod(requireCodemirror());
    })(function(CodeMirror2) {
      function bracketFolding(pairs) {
        return function(cm, start) {
          var line = start.line, lineText = cm.getLine(line);
          function findOpening(pair) {
            var tokenType;
            for (var at = start.ch, pass = 0; ; ) {
              var found2 = at <= 0 ? -1 : lineText.lastIndexOf(pair[0], at - 1);
              if (found2 == -1) {
                if (pass == 1) break;
                pass = 1;
                at = lineText.length;
                continue;
              }
              if (pass == 1 && found2 < start.ch) break;
              tokenType = cm.getTokenTypeAt(CodeMirror2.Pos(line, found2 + 1));
              if (!/^(comment|string)/.test(tokenType)) return { ch: found2 + 1, tokenType, pair };
              at = found2 - 1;
            }
          }
          function findRange(found2) {
            var count = 1, lastLine = cm.lastLine(), end, startCh = found2.ch, endCh;
            outer: for (var i2 = line; i2 <= lastLine; ++i2) {
              var text = cm.getLine(i2), pos = i2 == line ? startCh : 0;
              for (; ; ) {
                var nextOpen = text.indexOf(found2.pair[0], pos), nextClose = text.indexOf(found2.pair[1], pos);
                if (nextOpen < 0) nextOpen = text.length;
                if (nextClose < 0) nextClose = text.length;
                pos = Math.min(nextOpen, nextClose);
                if (pos == text.length) break;
                if (cm.getTokenTypeAt(CodeMirror2.Pos(i2, pos + 1)) == found2.tokenType) {
                  if (pos == nextOpen) ++count;
                  else if (!--count) {
                    end = i2;
                    endCh = pos;
                    break outer;
                  }
                }
                ++pos;
              }
            }
            if (end == null || line == end) return null;
            return {
              from: CodeMirror2.Pos(line, startCh),
              to: CodeMirror2.Pos(end, endCh)
            };
          }
          var found = [];
          for (var i = 0; i < pairs.length; i++) {
            var open2 = findOpening(pairs[i]);
            if (open2) found.push(open2);
          }
          found.sort(function(a, b) {
            return a.ch - b.ch;
          });
          for (var i = 0; i < found.length; i++) {
            var range = findRange(found[i]);
            if (range) return range;
          }
          return null;
        };
      }
      CodeMirror2.registerHelper("fold", "brace", bracketFolding([["{", "}"], ["[", "]"]]));
      CodeMirror2.registerHelper("fold", "brace-paren", bracketFolding([["{", "}"], ["[", "]"], ["(", ")"]]));
      CodeMirror2.registerHelper("fold", "import", function(cm, start) {
        function hasImport(line) {
          if (line < cm.firstLine() || line > cm.lastLine()) return null;
          var start2 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
          if (!/\S/.test(start2.string)) start2 = cm.getTokenAt(CodeMirror2.Pos(line, start2.end + 1));
          if (start2.type != "keyword" || start2.string != "import") return null;
          for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
            var text = cm.getLine(i), semi = text.indexOf(";");
            if (semi != -1) return { startCh: start2.end, end: CodeMirror2.Pos(i, semi) };
          }
        }
        var startLine = start.line, has = hasImport(startLine), prev;
        if (!has || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1)
          return null;
        for (var end = has.end; ; ) {
          var next = hasImport(end.line + 1);
          if (next == null) break;
          end = next.end;
        }
        return { from: cm.clipPos(CodeMirror2.Pos(startLine, has.startCh + 1)), to: end };
      });
      CodeMirror2.registerHelper("fold", "include", function(cm, start) {
        function hasInclude(line) {
          if (line < cm.firstLine() || line > cm.lastLine()) return null;
          var start2 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
          if (!/\S/.test(start2.string)) start2 = cm.getTokenAt(CodeMirror2.Pos(line, start2.end + 1));
          if (start2.type == "meta" && start2.string.slice(0, 8) == "#include") return start2.start + 8;
        }
        var startLine = start.line, has = hasInclude(startLine);
        if (has == null || hasInclude(startLine - 1) != null) return null;
        for (var end = startLine; ; ) {
          var next = hasInclude(end + 1);
          if (next == null) break;
          ++end;
        }
        return {
          from: CodeMirror2.Pos(startLine, has + 1),
          to: cm.clipPos(CodeMirror2.Pos(end))
        };
      });
    });
  })();
  return braceFold.exports;
}
requireBraceFold();
var codemirrorExports = requireCodemirror();
const CodeMirror = /* @__PURE__ */ getDefaultExportFromCjs(codemirrorExports);
const valueUpdateDelay = 100;
class StateEditorDialog extends Overlay {
  constructor(viewer) {
    super();
    this.viewer = viewer;
    this.parsedValue = null;
    this.debouncedValueUpdater = debounce(() => {
      const value = this.textEditor.getValue();
      try {
        const json2 = JSON.parse(value);
        this.parsedValue = json2;
        this.applyButton.disabled = false;
        this.textEditor.setOption("lint", void 0);
      } catch (parseError) {
        this.parsedValue = null;
        this.applyButton.disabled = true;
        let line = 0, column = 0, message = "Unknown parse error";
        if (parseError instanceof Error) {
          const m = parseError.message.match(/^((?:.|\n)*) in JSON at position ([0-9]+)$/);
          if (m !== null) {
            message = m[1];
            const offset = parseInt(m[2], 10);
            const prefix = value.substring(0, offset);
            const lines = prefix.split("\n");
            line = lines.length - 1;
            column = lines[lines.length - 1].length;
          } else {
            message = parseError.message;
          }
        }
        this.textEditor.setOption("lint", {
          getAnnotations: () => {
            return [{
              message,
              severity: "error",
              from: CodeMirror.Pos(line, column)
            }];
          }
        });
      }
    }, valueUpdateDelay);
    this.content.classList.add("neuroglancer-state-editor");
    const buttonApply = this.applyButton = document.createElement("button");
    buttonApply.textContent = "Apply changes";
    this.content.appendChild(buttonApply);
    buttonApply.addEventListener("click", () => this.applyChanges());
    buttonApply.disabled = true;
    const buttonClose = this.closeButton = document.createElement("button");
    buttonClose.classList.add("close-button");
    buttonClose.textContent = "Close";
    this.content.appendChild(buttonClose);
    buttonClose.addEventListener("click", () => this.dispose());
    const downloadButton = this.downloadButton = document.createElement("button");
    downloadButton.textContent = "Download";
    downloadButton.title = "Download state as a JSON file";
    this.content.appendChild(downloadButton);
    downloadButton.addEventListener("click", () => this.downloadState());
    this.textEditor = CodeMirror((_element) => {
    }, {
      value: "",
      mode: { "name": "javascript", json: true },
      foldGutter: true,
      gutters: ["CodeMirror-lint-markers", "CodeMirror-foldgutter"]
    });
    this.updateView();
    this.textEditor.on("change", () => {
      this.debouncedValueUpdater();
    });
    this.content.appendChild(this.textEditor.getWrapperElement());
    this.textEditor.refresh();
  }
  downloadState() {
    const downloadLink = document.createElement("a");
    const blob = new Blob([this.getJson()], { type: "text/json" });
    const blobUrl = URL.createObjectURL(blob);
    downloadLink.href = blobUrl;
    downloadLink.download = "state.json";
    downloadLink.click();
    document.body.removeChild(downloadLink);
  }
  applyChanges() {
    if (this.parsedValue !== null) {
      this.viewer.state.reset();
      this.viewer.state.restoreState(this.parsedValue);
    }
    this.applyButton.disabled = true;
  }
  updateView() {
    this.textEditor.setValue(this.getJson());
    this.textEditor.execCommand("foldAll");
    this.textEditor.execCommand("unfold");
  }
  getJson() {
    return _JSON$stringify(getCachedJson(this.viewer.state).value, null, "  ");
  }
}
var toArray = {};
var hasRequiredToArray;
function requireToArray() {
  if (hasRequiredToArray) return toArray;
  hasRequiredToArray = 1;
  toArray.__esModule = true;
  var _from = requireFrom();
  var _from2 = _interopRequireDefault(_from);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  toArray.default = function(arr) {
    return Array.isArray(arr) ? arr : (0, _from2.default)(arr);
  };
  return toArray;
}
var toArrayExports = requireToArray();
const _toArray = /* @__PURE__ */ getDefaultExportFromCjs(toArrayExports);
const DEFAULT_STATISTICS_PANEL_LOCATION = {
  side: "bottom",
  size: 100,
  minSize: 50,
  row: 0,
  col: 0,
  flex: 1,
  visible: false
};
class StatisticsDisplayState {
  constructor() {
    this.location = new TrackableSidePanelLocation(DEFAULT_STATISTICS_PANEL_LOCATION);
  }
  get changed() {
    return this.location.changed;
  }
  restoreState(obj) {
    this.location.restoreState(obj);
  }
  reset() {
    this.location.reset();
  }
  toJSON() {
    return emptyToUndefined(this.location.toJSON());
  }
}
function getProperties(obj) {
  const map2 = new _Map();
  function handleObject(o, prefix) {
    if (typeof o !== "object") {
      map2.set(prefix, "" + o);
      return;
    }
    for (const key of _Object$keys(o)) {
      handleObject(o[key], prefix + "." + key);
    }
  }
  handleObject(obj, "");
  return map2;
}
function getDistinguishingProperties(properties) {
  const selected = new _Set();
  selected.add(".type");
  const allProps = new _Set();
  function areDistinguished(i, j) {
    for (const prop of selected) {
      if (properties[i].get(prop) !== properties[j].get(prop)) {
        return true;
      }
    }
    return false;
  }
  for (let i = 0, n = properties.length; i < n; ++i) {
    for (const prop of properties[i].keys()) {
      allProps.add(prop);
    }
    let matches = [];
    for (let j = 0; j < i; ++j) {
      if (!areDistinguished(i, j)) {
        matches.push(j);
      }
    }
    while (matches.length > 0) {
      let bestReducedMatches = matches;
      let bestProp = void 0;
      for (const prop of allProps) {
        if (selected.has(prop)) continue;
        const reducedMatches = [];
        for (const j of matches) {
          if (properties[j].get(prop) === properties[i].get(prop)) {
            reducedMatches.push(j);
          }
        }
        if (reducedMatches.length < bestReducedMatches.length) {
          bestReducedMatches = reducedMatches;
          bestProp = prop;
        }
        if (reducedMatches.length === 0) break;
      }
      if (bestProp === void 0) break;
      matches = bestReducedMatches;
      selected.add(bestProp);
    }
  }
  return _Array$from(selected);
}
function getNameFromProps(properties, selected) {
  const result = {};
  for (const prop of selected) {
    const value = properties.get(prop);
    if (value === void 0) continue;
    if (prop === "") return value;
    result[prop] = value;
  }
  return _JSON$stringify(result);
}
function getChunkSourceIdentifier(source) {
  return _Object$assign({ type: source.RPC_TYPE_ID }, source.key || {});
}
function getFormattedNames(objects) {
  const properties = objects.map(getProperties);
  const selectedProps = getDistinguishingProperties(properties);
  return properties.map((p) => getNameFromProps(p, selectedProps));
}
const requestDataInterval = 1e3;
const columnSpecifications = [{
  label: "Visible chunks/T",
  key: "visibleChunksTotal",
  getter: (statistics) => {
    let sum = 0;
    for (let state = 0; state < numChunkStates; ++state) {
      sum += statistics[getChunkStateStatisticIndex(state, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks];
    }
    return sum;
  }
}, {
  label: "Visible chunks/D",
  key: "visibleChunksDownloading",
  getter: (statistics) => {
    return statistics[getChunkStateStatisticIndex(ChunkState.DOWNLOADING, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks];
  }
}, {
  label: "Visible chunks/M",
  key: "visibleChunksSystemMemory",
  getter: (statistics) => {
    return statistics[getChunkStateStatisticIndex(ChunkState.SYSTEM_MEMORY, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks] + statistics[getChunkStateStatisticIndex(ChunkState.SYSTEM_MEMORY_WORKER, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks];
  }
}, {
  label: "Visible chunks/G",
  key: "visibleChunksGpuMemory",
  getter: (statistics) => {
    return statistics[getChunkStateStatisticIndex(ChunkState.GPU_MEMORY, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks];
  }
}, {
  label: "Visible chunks/F",
  key: "visibleChunksFailed",
  getter: (statistics) => {
    return statistics[getChunkStateStatisticIndex(ChunkState.FAILED, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks];
  }
}, {
  label: "Visible memory",
  key: "visibleGpuMemory",
  getter: (statistics) => {
    return statistics[getChunkStateStatisticIndex(ChunkState.GPU_MEMORY, ChunkPriorityTier.VISIBLE) * numChunkMemoryStatistics + ChunkMemoryStatistics.gpuMemoryBytes];
  }
}, {
  label: "Download latency",
  key: "downloadLatency",
  getter: (statistics) => {
    return statistics[getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalTime)] / statistics[getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalChunks)];
  }
}];
class StatisticsPanel extends SidePanel {
  constructor(sidePanelManager, chunkQueueManager, displayState) {
    super(sidePanelManager, displayState.location);
    this.chunkQueueManager = chunkQueueManager;
    this.displayState = displayState;
    this.data = void 0;
    this.requestDataTimerId = -1;
    this.dataRequested = false;
    this.body = document.createElement("div");
    this.debouncedUpdateView = this.registerCancellable(debounce(() => this.updateView(), 0));
    const body = this.body;
    body.classList.add("neuroglancer-statistics-panel-body");
    this.addTitleBar({ title: "Chunk statistics" });
    this.addBody(body);
    this.requestData();
  }
  disposed() {
    window.clearTimeout(this.requestDataTimerId);
    super.disposed();
  }
  requestData() {
    if (this.dataRequested) return;
    const chunkQueueManager = this.chunkQueueManager;
    this.dataRequested = true;
    chunkQueueManager.getStatistics().then((data) => {
      this.dataRequested = false;
      this.data = data;
      this.debouncedUpdateView();
      this.requestDataTimerId = window.setTimeout(() => {
        this.requestDataTimerId = -1;
        this.requestData();
      }, requestDataInterval);
    });
  }
  updateView() {
    const data = this.data;
    if (data === void 0) return;
    const table = document.createElement("table");
    const rows = [];
    for (const _ref of data) {
      var _ref2 = _slicedToArray(_ref, 2);
      const source = _ref2[0];
      const statistics = _ref2[1];
      const row = [source];
      for (const _ref3 of columnSpecifications) {
        const getter = _ref3.getter;
        row.push(getter(statistics));
      }
      rows.push(row);
    }
    const formattedNames = getFormattedNames(rows.map((x) => getChunkSourceIdentifier(x[0])));
    const sourceFormattedNames = new _Map();
    formattedNames.forEach((name2, i) => {
      sourceFormattedNames.set(rows[i][0], name2);
    });
    {
      const thead = document.createElement("thead");
      let tr = document.createElement("tr");
      thead.appendChild(tr);
      const addHeaderColumn = (label) => {
        const td = document.createElement("td");
        td.textContent = label;
        tr.appendChild(td);
      };
      addHeaderColumn("Name");
      let prevPrefix = void 0;
      for (const _ref4 of columnSpecifications) {
        const column = _ref4.label;
        const sepIndex = column.indexOf("/");
        let prefix = column;
        if (sepIndex !== -1) {
          prefix = column.substring(0, sepIndex);
          if (prefix === prevPrefix) {
            ++tr.lastElementChild.colSpan;
            continue;
          }
          prevPrefix = prefix;
        }
        addHeaderColumn(prefix);
      }
      tr = document.createElement("tr");
      thead.appendChild(tr);
      {
        const td = document.createElement("td");
        tr.appendChild(td);
      }
      for (const _ref5 of columnSpecifications) {
        const column = _ref5.label;
        const sepIndex = column.indexOf("/");
        let suffix = "";
        if (sepIndex !== -1) {
          suffix = column.substring(sepIndex + 1);
        }
        const td = document.createElement("td");
        td.textContent = suffix;
        tr.appendChild(td);
      }
      table.appendChild(thead);
    }
    const tbody = document.createElement("tbody");
    for (const _ref6 of rows) {
      var _ref7 = _toArray(_ref6);
      const source = _ref7[0];
      const values2 = _ref7.slice(1);
      const tr = document.createElement("tr");
      const addColumn = (label) => {
        const td = document.createElement("td");
        td.textContent = label;
        tr.appendChild(td);
      };
      addColumn(sourceFormattedNames.get(source));
      for (const value of values2) {
        addColumn("" + value);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    removeChildren(this.body);
    this.body.appendChild(table);
  }
}
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ColorWidget extends RefCounted {
  constructor(model, getDefaultColor = () => fromValues$1(1, 0, 0)) {
    super();
    this.model = model;
    this.getDefaultColor = getDefaultColor;
    this.element = document.createElement("input");
    const element = this.element;
    element.classList.add("neuroglancer-color-widget");
    element.type = "color";
    element.addEventListener("change", () => this.updateModel());
    element.addEventListener("input", () => this.updateModel());
    element.addEventListener("wheel", (event) => {
      event.stopPropagation();
      event.preventDefault();
      this.adjustHueViaWheel(event);
    });
    this.registerDisposer(model.changed.add(() => this.updateView()));
    this.updateView();
  }
  getRGB() {
    var _a;
    return (_a = this.model.value) !== null && _a !== void 0 ? _a : this.getDefaultColor();
  }
  updateView() {
    this.element.value = serializeColor(this.getRGB());
  }
  updateModel() {
    this.model.value = parseRGBColorSpecification(this.element.value);
  }
  adjustHueViaWheel(event) {
    const rgb = this.getRGB();
    const temp = create$3();
    rgbToHsv(temp, rgb[0], rgb[1], rgb[2]);
    const deltaY = event.deltaY;
    let hue = Math.round(temp[0] * 256);
    hue += deltaY > 0 ? 1 : deltaY < 0 ? -1 : 0;
    hue = (hue + 256) % 256;
    temp[0] = hue / 256;
    hsvToRgb(temp, temp[0], temp[1], temp[2]);
    this.model.value = temp;
  }
}
class NumberInputWidget extends RefCounted {
  constructor(model, options = {}) {
    super();
    this.model = model;
    this.element = document.createElement("label");
    this.inputElement = document.createElement("input");
    let validator = options.validator, label = options.label;
    const element = this.element, inputElement = this.inputElement;
    if (validator === void 0) {
      if (model instanceof TrackableValue) {
        validator = model.validator;
      } else {
        validator = (x) => x;
      }
    }
    this.validator = validator;
    if (label !== void 0) {
      element.textContent = label;
    }
    element.appendChild(inputElement);
    element.className = "neuroglancer-number-input";
    inputElement.type = "text";
    this.registerDisposer(this.model.changed.add(() => this.updateView()));
    this.registerEventListener(inputElement, "change", () => this.updateModel());
    this.updateView();
  }
  updateView() {
    this.inputElement.value = "" + this.model.value;
  }
  updateModel() {
    let value = parseFloat(this.inputElement.value.trim());
    if (_Number$isNaN(value)) {
      this.updateView();
      return;
    }
    try {
      value = this.validator(value);
      this.model.value = value;
    } catch (_a) {
      this.updateView();
    }
  }
  disposed() {
    removeFromParent(this.element);
    super.disposed();
  }
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TextInputWidget extends RefCounted {
  constructor(model) {
    super();
    this.model = model;
    this.element = document.createElement("input");
    this.registerDisposer(model.changed.add(() => this.updateView()));
    const element = this.element;
    element.type = "text";
    this.registerEventListener(element, "change", () => this.updateModel());
    this.updateView();
  }
  disposed() {
    removeFromParent(this.element);
  }
  updateView() {
    var _a;
    this.element.value = ((_a = this.model.value) !== null && _a !== void 0 ? _a : "") + "";
  }
  updateModel() {
    try {
      this.model.restoreState(this.element.value);
    } catch (_a) {
    }
    this.updateView();
  }
}
const DEFAULT_SETTINGS_PANEL_LOCATION = _Object$assign(_Object$assign({}, DEFAULT_SIDE_PANEL_LOCATION), { side: "left", row: 2 });
class ViewerSettingsPanelState {
  constructor() {
    this.location = new TrackableSidePanelLocation(DEFAULT_SETTINGS_PANEL_LOCATION);
  }
  get changed() {
    return this.location.changed;
  }
  toJSON() {
    return emptyToUndefined(this.location.toJSON());
  }
  reset() {
    this.location.reset();
  }
  restoreState(obj) {
    this.location.restoreState(obj);
  }
}
class ViewerSettingsPanel extends SidePanel {
  constructor(sidePanelManager, state, viewer) {
    super(sidePanelManager, state.location);
    this.addTitleBar({ title: "Settings" });
    const body = document.createElement("div");
    body.classList.add("neuroglancer-settings-body");
    let scroll = document.createElement("div");
    scroll.classList.add("neuroglancer-settings-scroll-container");
    body.appendChild(scroll);
    this.addBody(body);
    {
      const titleWidget = this.registerDisposer(new TextInputWidget(viewer.title));
      titleWidget.element.placeholder = "Title";
      titleWidget.element.classList.add("neuroglancer-settings-title");
      scroll.appendChild(titleWidget.element);
    }
    const addLimitWidget = (label, limit) => {
      const widget = this.registerDisposer(new NumberInputWidget(limit, { label }));
      widget.element.classList.add("neuroglancer-settings-limit-widget");
      scroll.appendChild(widget.element);
    };
    addLimitWidget("GPU memory limit", viewer.chunkQueueManager.capacities.gpuMemory.sizeLimit);
    addLimitWidget("System memory limit", viewer.chunkQueueManager.capacities.systemMemory.sizeLimit);
    addLimitWidget("Concurrent chunk requests", viewer.chunkQueueManager.capacities.download.itemLimit);
    const addCheckbox = (label, value) => {
      const labelElement = document.createElement("label");
      labelElement.textContent = label;
      const checkbox = this.registerDisposer(new TrackableBooleanCheckbox(value));
      labelElement.appendChild(checkbox.element);
      scroll.appendChild(labelElement);
    };
    addCheckbox("Show axis lines", viewer.showAxisLines);
    addCheckbox("Show scale bar", viewer.showScaleBar);
    addCheckbox("Show cross sections in 3-d", viewer.showPerspectiveSliceViews);
    addCheckbox("Show default annotations", viewer.showDefaultAnnotations);
    addCheckbox("Show chunk statistics", viewer.statisticsDisplayState.location.watchableVisible);
    addCheckbox("Wire frame rendering", viewer.wireFrame);
    addCheckbox("Enable prefetching", viewer.chunkQueueManager.enablePrefetch);
    const addColor = (label, value) => {
      const labelElement = document.createElement("label");
      labelElement.textContent = label;
      const widget = this.registerDisposer(new ColorWidget(value));
      labelElement.appendChild(widget.element);
      scroll.appendChild(labelElement);
    };
    addColor("Cross-section background", viewer.crossSectionBackgroundColor);
    addColor("Projection background", viewer.perspectiveViewBackgroundColor);
  }
}
class AnnotationToolStatusWidget extends RefCounted {
  constructor(selectedLayer, toolBinder) {
    super();
    this.selectedLayer = selectedLayer;
    this.toolBinder = toolBinder;
    this.element = document.createElement("div");
    this.viewContext = void 0;
    this.updateView = this.registerCancellable(animationFrameDebounce(() => {
      let viewContext = this.viewContext;
      if (viewContext !== void 0) {
        this.unregisterDisposer(viewContext);
        viewContext.dispose();
      }
      this.viewContext = viewContext = this.registerDisposer(new RefCounted());
      removeChildren(this.element);
      const selectedTool = this.selectedTool;
      if (selectedTool !== void 0) {
        this.element.appendChild(this.makeWidget(viewContext, selectedTool));
      }
      const bindings = _Array$from(this.toolBinder.bindings);
      bindings.sort(([a], [b]) => defaultStringCompare(a, b));
      for (const _ref of bindings) {
        var _ref2 = _slicedToArray(_ref, 2);
        const tool = _ref2[1];
        this.element.appendChild(this.makeWidget(viewContext, tool));
      }
    }));
    const element = this.element;
    element.className = "neuroglancer-annotation-tool-status";
    this.registerDisposer(selectedLayer.changed.add(() => this.selectedLayerChanged()));
    this.registerDisposer(toolBinder.changed.add(this.updateView));
    this.registerDisposer(this.selectedLayer.layerManager.layersChanged.add(this.updateView));
    this.selectedLayerChanged();
  }
  get selectedTool() {
    const layer = this.selectedLayer.layer;
    if (layer === void 0) {
      return void 0;
    }
    const userLayer = layer.layer;
    if (userLayer === null) {
      return void 0;
    }
    return userLayer.tool.value;
  }
  selectedLayerChanged() {
    let unbindPreviousLayer = this.unbindPreviousLayer;
    if (unbindPreviousLayer !== void 0) {
      unbindPreviousLayer();
    }
    const layer = this.selectedLayer.layer;
    if (layer !== void 0) {
      this.unbindPreviousLayer = layer.specificationChanged.add(() => {
        this.updateView();
      });
    }
    this.updateView();
  }
  disposed() {
    const unbindPreviousLayer = this.unbindPreviousLayer;
    if (unbindPreviousLayer !== void 0) {
      unbindPreviousLayer();
    }
    this.unbindPreviousLayer = void 0;
  }
  makeWidget(context, tool) {
    const element = document.createElement("div");
    element.title = "dblclick → unbind";
    if (tool instanceof Tool) {
      element.title += `, click → bind key`;
    }
    element.className = "neuroglancer-annotation-tool-status-widget";
    const layerNumberElement = document.createElement("div");
    layerNumberElement.className = "neuroglancer-annotation-tool-status-widget-layer-number";
    const managedLayer = tool.layer.managedLayer;
    managedLayer.manager.rootLayers.updateNonArchivedLayerIndices();
    const index2 = managedLayer.nonArchivedLayerIndex;
    layerNumberElement.textContent = (index2 + 1).toString();
    const descriptionElement = document.createElement("div");
    descriptionElement.className = "neuroglancer-annotation-tool-status-widget-description";
    descriptionElement.textContent = tool.description;
    element.addEventListener("dblclick", () => {
      if (tool instanceof LegacyTool) {
        tool.layer.tool.value = void 0;
      } else {
        this.toolBinder.set(tool.keyBinding, void 0);
      }
    });
    if (tool instanceof Tool) {
      const keyElement = document.createElement("div");
      keyElement.className = "neuroglancer-annotation-tool-status-widget-key";
      keyElement.textContent = tool.keyBinding;
      element.appendChild(keyElement);
      addToolKeyBindHandlers(context, element, (key) => tool.layer.toolBinder.set(key, tool.addRef()));
    }
    element.appendChild(layerNumberElement);
    element.appendChild(descriptionElement);
    return element;
  }
}
function encodeFragment(fragment) {
  return encodeURI(fragment).replace(/[!'()*;,]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
class UrlHashBinding extends RefCounted {
  constructor(root, credentialsManager, options = {}) {
    super();
    this.root = root;
    this.credentialsManager = credentialsManager;
    this.parseError = new WatchableValue(void 0);
    var _options$updateDelayM = options.updateDelayMilliseconds;
    const updateDelayMilliseconds = _options$updateDelayM === void 0 ? 200 : _options$updateDelayM;
    var _options$defaultFragm = options.defaultFragment;
    const defaultFragment = _options$defaultFragm === void 0 ? "{}" : _options$defaultFragm;
    this.registerEventListener(window, "hashchange", () => this.updateFromUrlHash());
    const throttledSetUrlHash = debounce(() => this.setUrlHash(), updateDelayMilliseconds);
    this.registerDisposer(root.changed.add(throttledSetUrlHash));
    this.registerDisposer(() => throttledSetUrlHash.cancel());
    this.defaultFragment = defaultFragment;
  }
  /**
   * Sets the URL hash to match the current state.
   */
  setUrlHash() {
    const cacheState = getCachedJson(this.root);
    const generation = cacheState.generation;
    if (generation !== this.prevStateGeneration) {
      this.prevStateGeneration = cacheState.generation;
      let stateString = encodeFragment(_JSON$stringify(cacheState.value));
      if (stateString !== this.prevStateString) {
        this.prevStateString = stateString;
        if (decodeURIComponent(stateString) === "{}") {
          history.replaceState(null, "", "#");
        } else {
          history.replaceState(null, "", "#!" + stateString);
        }
      }
    }
  }
  /**
   * Sets the current state to match the URL hash.  If it is desired to initialize the state based
   * on the URL hash, then this should be called immediately after construction.
   */
  updateFromUrlHash() {
    try {
      let s = location.href.replace(/^[^#]+/, "");
      if (s === "" || s === "#" || s === "#!") {
        s = "#!" + this.defaultFragment;
      }
      if (s.match(/^#!([a-z][a-z\d+-.]*):\/\//)) {
        const url = s.substring(2);
        var _parseSpecialUrl = parseSpecialUrl(url, this.credentialsManager);
        const parsedUrl = _parseSpecialUrl.url, credentialsProvider = _parseSpecialUrl.credentialsProvider;
        StatusMessage.forPromise(cancellableFetchSpecialOk(credentialsProvider, parsedUrl, {}, responseJson).then((json2) => {
          verifyObject(json2);
          this.root.reset();
          this.root.restoreState(json2);
        }), { initialMessage: `Loading state from ${url}`, errorPrefix: `Error loading state:` });
      } else if (s.startsWith("#!+")) {
        s = s.slice(3);
        s = decodeURIComponent(s);
        let state = urlSafeParse(s);
        verifyObject(state);
        this.root.restoreState(state);
        this.prevStateString = void 0;
      } else if (s.startsWith("#!")) {
        s = s.slice(2);
        s = decodeURIComponent(s);
        if (s === this.prevStateString) {
          return;
        }
        this.prevStateString = s;
        this.root.reset();
        let state = urlSafeParse(s);
        verifyObject(state);
        this.root.restoreState(state);
      } else {
        throw new Error(`URL hash is expected to be of the form "#!{...}" or "#!+{...}".`);
      }
      this.parseError.value = void 0;
    } catch (parseError) {
      this.parseError.value = parseError;
    }
  }
}
const url_hash_binding = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  UrlHashBinding,
  encodeFragment
}, Symbol.toStringTag, { value: "Module" }));
class DataManagementContext extends RefCounted {
  constructor(gl, frameNumberCounter, bundleRoot = "") {
    super();
    this.gl = gl;
    this.frameNumberCounter = frameNumberCounter;
    const chunk_worker_url = bundleRoot + "chunk_worker.bundle.js";
    this.worker = typeof bundleRoot === "string" ? new Worker(chunk_worker_url) : bundleRoot;
    this.chunkQueueManager = this.registerDisposer(new ChunkQueueManager(new RPC(this.worker), this.gl, this.frameNumberCounter, {
      gpuMemory: new CapacitySpecification({ defaultItemLimit: 1e6, defaultSizeLimit: 1e9 }),
      systemMemory: new CapacitySpecification({ defaultItemLimit: 1e7, defaultSizeLimit: 2e9 }),
      download: new CapacitySpecification({ defaultItemLimit: 100, defaultSizeLimit: Number.POSITIVE_INFINITY }),
      compute: new CapacitySpecification({ defaultItemLimit: 128, defaultSizeLimit: 5e8 })
    }));
    this.chunkQueueManager.registerDisposer(() => this.worker.terminate());
    this.chunkManager = this.registerDisposer(new ChunkManager(this.chunkQueueManager));
  }
  get rpc() {
    return this.chunkQueueManager.rpc;
  }
}
const VIEWER_TOP_ROW_CONFIG_OPTIONS = ["showHelpButton", "showSettingsButton", "showEditStateButton", "showLayerListPanelButton", "showSelectionPanelButton", "showLayerSidePanelButton", "showLocation", "showAnnotationToolStatus"];
const VIEWER_UI_CONTROL_CONFIG_OPTIONS = [...VIEWER_TOP_ROW_CONFIG_OPTIONS, "showLayerPanel", "showLayerHoverValues"];
const VIEWER_UI_CONFIG_OPTIONS = [...VIEWER_UI_CONTROL_CONFIG_OPTIONS, "showUIControls", "showPanelBorders"];
function makeViewerUIConfiguration() {
  return Object.fromEntries(VIEWER_UI_CONFIG_OPTIONS.map((key) => [key, new TrackableBoolean(true)]));
}
function setViewerUiConfiguration(config, options) {
  for (const key of VIEWER_UI_CONFIG_OPTIONS) {
    const value = options[key];
    if (value !== void 0) {
      config[key].value = value;
    }
  }
}
const defaultViewerOptions = "undefined" !== typeof NEUROGLANCER_OVERRIDE_DEFAULT_VIEWER_OPTIONS ? NEUROGLANCER_OVERRIDE_DEFAULT_VIEWER_OPTIONS : {
  showLayerDialog: true,
  resetStateWhenEmpty: true
};
class TrackableViewerState extends CompoundTrackable {
  constructor(viewer) {
    super();
    this.viewer = viewer;
    this.add("title", viewer.title);
    this.add("dimensions", viewer.coordinateSpace);
    this.add("relativeDisplayScales", viewer.relativeDisplayScales);
    this.add("displayDimensions", viewer.displayDimensions);
    this.add("position", viewer.position);
    this.add("crossSectionOrientation", viewer.crossSectionOrientation);
    this.add("crossSectionScale", viewer.crossSectionScale);
    this.add("crossSectionDepth", viewer.crossSectionDepthRange);
    this.add("projectionOrientation", viewer.projectionOrientation);
    this.add("projectionScale", viewer.projectionScale);
    this.add("projectionDepth", viewer.projectionDepthRange);
    this.add("layers", viewer.layerSpecification);
    this.add("showAxisLines", viewer.showAxisLines);
    this.add("wireFrame", viewer.wireFrame);
    this.add("showScaleBar", viewer.showScaleBar);
    this.add("showDefaultAnnotations", viewer.showDefaultAnnotations);
    this.add("showSlices", viewer.showPerspectiveSliceViews);
    this.add("gpuMemoryLimit", viewer.dataContext.chunkQueueManager.capacities.gpuMemory.sizeLimit);
    this.add("prefetch", viewer.dataContext.chunkQueueManager.enablePrefetch);
    this.add("systemMemoryLimit", viewer.dataContext.chunkQueueManager.capacities.systemMemory.sizeLimit);
    this.add("concurrentDownloads", viewer.dataContext.chunkQueueManager.capacities.download.itemLimit);
    this.add("selectedLayer", viewer.selectedLayer);
    this.add("crossSectionBackgroundColor", viewer.crossSectionBackgroundColor);
    this.add("projectionBackgroundColor", viewer.perspectiveViewBackgroundColor);
    this.add("layout", viewer.layout);
    this.add("statistics", viewer.statisticsDisplayState);
    this.add("helpPanel", viewer.helpPanelState);
    this.add("settingsPanel", viewer.settingsPanelState);
    this.add("selection", viewer.selectionDetailsState);
    this.add("layerListPanel", viewer.layerListPanelState);
    this.add("partialViewport", viewer.partialViewport);
    this.add("selectedStateServer", viewer.selectedStateServer);
  }
  restoreState(obj) {
    const viewer = this.viewer;
    super.restoreState(obj);
    verifyOptionalObjectProperty(obj, "navigation", (navObj) => {
      verifyObject(navObj);
      verifyOptionalObjectProperty(navObj, "pose", (poseObj) => {
        verifyObject(poseObj);
        verifyOptionalObjectProperty(poseObj, "position", (positionObj) => {
          verifyObject(positionObj);
          optionallyRestoreFromJsonMember(positionObj, "voxelCoordinates", viewer.position);
          verifyOptionalObjectProperty(positionObj, "voxelSize", (voxelSizeObj) => {
            const voxelSize = parseFixedLengthArray(new Float64Array(3), voxelSizeObj, verifyFinitePositiveFloat);
            for (let i = 0; i < 3; ++i) {
              voxelSize[i] *= 1e-9;
            }
            viewer.coordinateSpace.value = makeCoordinateSpace({
              valid: false,
              names: ["x", "y", "z"],
              units: ["m", "m", "m"],
              scales: voxelSize
            });
          });
        });
        optionallyRestoreFromJsonMember(poseObj, "orientation", viewer.crossSectionOrientation);
      });
      optionallyRestoreFromJsonMember(navObj, "zoomFactor", viewer.crossSectionScale.legacyJsonView);
    });
    optionallyRestoreFromJsonMember(obj, "perspectiveOrientation", viewer.projectionOrientation);
    optionallyRestoreFromJsonMember(obj, "perspectiveZoom", viewer.projectionScale.legacyJsonView);
    optionallyRestoreFromJsonMember(obj, "perspectiveViewBackgroundColor", viewer.perspectiveViewBackgroundColor);
  }
}
const globalViewerConfig = {
  expectingExternalUI: false
};
class Viewer extends RefCounted {
  constructor(display, options = {}) {
    super();
    this.display = display;
    this.title = new TrackableValue(void 0, verifyString);
    this.coordinateSpace = new TrackableCoordinateSpace();
    this.position = this.registerDisposer(new Position(this.coordinateSpace));
    this.relativeDisplayScales = this.registerDisposer(new TrackableRelativeDisplayScales(this.coordinateSpace));
    this.displayDimensions = this.registerDisposer(new TrackableDisplayDimensions(this.coordinateSpace));
    this.displayDimensionRenderInfo = this.registerDisposer(new WatchableDisplayDimensionRenderInfo(this.relativeDisplayScales.addRef(), this.displayDimensions.addRef()));
    this.crossSectionOrientation = this.registerDisposer(new OrientationState());
    this.crossSectionScale = this.registerDisposer(new TrackableCrossSectionZoom(this.displayDimensionRenderInfo.addRef()));
    this.projectionOrientation = this.registerDisposer(new OrientationState());
    this.crossSectionDepthRange = this.registerDisposer(new TrackableDepthRange(-10, this.displayDimensionRenderInfo));
    this.projectionDepthRange = this.registerDisposer(new TrackableDepthRange(-50, this.displayDimensionRenderInfo));
    this.projectionScale = this.registerDisposer(new TrackableProjectionZoom(this.displayDimensionRenderInfo.addRef()));
    this.navigationState = this.registerDisposer(new NavigationState(new DisplayPose(this.position.addRef(), this.displayDimensionRenderInfo.addRef(), this.crossSectionOrientation.addRef()), this.crossSectionScale.addRef(), this.crossSectionDepthRange.addRef()));
    this.perspectiveNavigationState = this.registerDisposer(new NavigationState(new DisplayPose(this.position.addRef(), this.displayDimensionRenderInfo.addRef(), this.projectionOrientation.addRef()), this.projectionScale.addRef(), this.projectionDepthRange.addRef()));
    this.mouseState = new MouseSelectionState();
    this.layerManager = this.registerDisposer(new LayerManager());
    this.selectedLayer = this.registerDisposer(new SelectedLayerState(this.layerManager.addRef()));
    this.showAxisLines = new TrackableBoolean(true, true);
    this.wireFrame = new TrackableBoolean(false, false);
    this.showScaleBar = new TrackableBoolean(true, true);
    this.showPerspectiveSliceViews = new TrackableBoolean(true, true);
    this.visibleLayerRoles = allRenderLayerRoles();
    this.showDefaultAnnotations = new TrackableBoolean(true, true);
    this.crossSectionBackgroundColor = new TrackableRGB(fromValues$1(0.5, 0.5, 0.5));
    this.perspectiveViewBackgroundColor = new TrackableRGB(fromValues$1(0, 0, 0));
    this.scaleBarOptions = new TrackableScaleBarOptions();
    this.partialViewport = new TrackableWindowedViewport();
    this.statisticsDisplayState = new StatisticsDisplayState();
    this.helpPanelState = new HelpPanelState();
    this.settingsPanelState = new ViewerSettingsPanelState();
    this.layerSelectedValues = this.registerDisposer(new LayerSelectedValues(this.layerManager, this.mouseState));
    this.selectionDetailsState = this.registerDisposer(new TrackableDataSelectionState(this.coordinateSpace, this.layerSelectedValues));
    this.selectedStateServer = new TrackableValue("", verifyString);
    this.layerListPanelState = new LayerListPanelState();
    this.resetInitiated = new NullarySignal();
    this.makeUrlFromState = (state) => {
      if (!globalViewerConfig.expectingExternalUI) {
        return window.location.toString();
      } else {
        return "/#!" + encodeFragment(_JSON$stringify(state));
      }
    };
    this.uiControlVisibility = {};
    this.visible = true;
    this.toolInputEventMapBinder = (inputEventMap2, context) => {
      context.registerDisposer(this.inputEventBindings.sliceView.addParent(inputEventMap2, Number.POSITIVE_INFINITY));
      context.registerDisposer(this.inputEventBindings.perspectiveView.addParent(inputEventMap2, Number.POSITIVE_INFINITY));
    };
    this.toolBinder = this.registerDisposer(new ToolBinder(this.toolInputEventMapBinder));
    var _options$dataContext = options.dataContext;
    const dataContext = _options$dataContext === void 0 ? new DataManagementContext(display.gl, display, options.bundleRoot) : _options$dataContext;
    var _options$visibility = options.visibility;
    const visibility = _options$visibility === void 0 ? new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE) : _options$visibility;
    var _options$inputEventBi = options.inputEventBindings;
    const inputEventBindings = _options$inputEventBi === void 0 ? {
      global: new EventActionMap(),
      sliceView: new EventActionMap(),
      perspectiveView: new EventActionMap()
    } : _options$inputEventBi;
    var _options$element = options.element;
    const element = _options$element === void 0 ? display.makeCanvasOverlayElement() : _options$element;
    var _options$dataSourcePr = options.dataSourceProvider;
    const dataSourceProvider = _options$dataSourcePr === void 0 ? getDefaultDataSourceProvider({ credentialsManager: defaultCredentialsManager }) : _options$dataSourcePr;
    var _options$uiConfigurat = options.uiConfiguration;
    const uiConfiguration = _options$uiConfigurat === void 0 ? makeViewerUIConfiguration() : _options$uiConfigurat;
    this.visibility = visibility;
    this.inputEventBindings = inputEventBindings;
    this.element = element;
    this.dataSourceProvider = dataSourceProvider;
    this.uiConfiguration = uiConfiguration;
    this.registerDisposer(observeWatchable((value) => {
      this.display.applyWindowedViewportToElement(element, value);
    }, this.partialViewport));
    this.registerDisposer(() => removeFromParent(this.element));
    this.dataContext = this.registerDisposer(dataContext);
    setViewerUiConfiguration(uiConfiguration, options);
    const optionsWithDefaults = _Object$assign(_Object$assign({}, defaultViewerOptions), options);
    const resetStateWhenEmpty = optionsWithDefaults.resetStateWhenEmpty, showLayerDialog = optionsWithDefaults.showLayerDialog;
    for (const key of VIEWER_UI_CONTROL_CONFIG_OPTIONS) {
      this.uiControlVisibility[key] = this.makeUiControlVisibilityState(key);
    }
    this.registerDisposer(this.uiConfiguration.showPanelBorders.changed.add(() => {
      this.updateShowBorders();
    }));
    this.showLayerDialog = showLayerDialog;
    this.resetStateWhenEmpty = resetStateWhenEmpty;
    this.layerSpecification = new TopLevelLayerListSpecification(this.display, this.dataSourceProvider, this.layerManager, this.chunkManager, this.selectionDetailsState, this.selectedLayer, this.navigationState.coordinateSpace, this.navigationState.pose.position, this.toolBinder);
    this.registerDisposer(display.updateStarted.add(() => {
      this.onUpdateDisplay();
    }));
    this.showDefaultAnnotations.changed.add(() => {
      if (this.showDefaultAnnotations.value) {
        this.visibleLayerRoles.add(RenderLayerRole.DEFAULT_ANNOTATION);
      } else {
        this.visibleLayerRoles.delete(RenderLayerRole.DEFAULT_ANNOTATION);
      }
    });
    this.registerDisposer(this.navigationState.changed.add(() => {
      this.handleNavigationStateChanged();
    }));
    const maybeResetState = this.registerCancellable(debounce(() => {
      if (!this.wasDisposed && this.layerManager.managedLayers.length === 0 && this.resetStateWhenEmpty) {
        this.navigationState.reset();
        this.perspectiveNavigationState.pose.orientation.reset();
        this.perspectiveNavigationState.zoomFactor.reset();
        this.resetInitiated.dispatch();
        if (!overlaysOpen && this.showLayerDialog && this.visibility.visible) {
          addNewLayer(this.layerSpecification, this.selectedLayer);
        }
      }
    }));
    this.layerManager.layersChanged.add(maybeResetState);
    maybeResetState();
    this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(() => {
      this.layerSelectedValues.handleLayerChange();
    }));
    this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(() => {
      if (this.visible) {
        display.scheduleRedraw();
      }
    }));
    this.makeUI();
    this.updateShowBorders();
    this.registerActionListeners();
    this.registerEventActionBindings();
    this.registerDisposer(setupPositionDropHandlers(element, this.navigationState.position));
    this.state = new TrackableViewerState(this);
  }
  get chunkManager() {
    return this.dataContext.chunkManager;
  }
  get chunkQueueManager() {
    return this.dataContext.chunkQueueManager;
  }
  get expectingExternalUI() {
    return globalViewerConfig.expectingExternalUI;
  }
  set expectingExternalUI(on) {
    globalViewerConfig.expectingExternalUI = on;
  }
  makeUiControlVisibilityState(key) {
    const showUIControls = this.uiConfiguration.showUIControls;
    const option = this.uiConfiguration[key];
    return this.registerDisposer(makeDerivedWatchableValue((a, b) => a && b, showUIControls, option));
  }
  get inputEventMap() {
    return this.inputEventBindings.global;
  }
  updateShowBorders() {
    const element = this.element;
    const className = "neuroglancer-show-panel-borders";
    if (this.uiConfiguration.showPanelBorders.value) {
      element.classList.add(className);
    } else {
      element.classList.remove(className);
    }
  }
  makeUI() {
    const gridContainer = this.element;
    gridContainer.classList.add("neuroglancer-viewer");
    gridContainer.classList.add("neuroglancer-noselect");
    gridContainer.style.display = "flex";
    gridContainer.style.flexDirection = "column";
    const topRow = document.createElement("div");
    topRow.classList.add("neuroglancer-viewer-top-row");
    topRow.style.display = "flex";
    topRow.style.flexDirection = "row";
    topRow.style.alignItems = "stretch";
    const positionWidget = this.registerDisposer(new PositionWidget(this.navigationState.position, this.layerSpecification.coordinateSpaceCombiner));
    this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showLocation, positionWidget.element));
    topRow.appendChild(positionWidget.element);
    const mousePositionWidget = this.registerDisposer(new MousePositionWidget(document.createElement("div"), this.mouseState, this.navigationState.coordinateSpace));
    mousePositionWidget.element.style.flex = "1";
    mousePositionWidget.element.style.alignSelf = "center";
    this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showLocation, mousePositionWidget.element));
    topRow.appendChild(mousePositionWidget.element);
    if (typeof NEUROGLANCER_CREDIT_LINK !== "undefined") {
      let creditInfo = NEUROGLANCER_CREDIT_LINK;
      if (!Array.isArray(creditInfo)) {
        creditInfo = [creditInfo];
      }
      for (const _ref of creditInfo) {
        const url = _ref.url;
        const text = _ref.text;
        const creditLink = document.createElement("a");
        creditLink.style.marginRight = "5px";
        creditLink.href = url;
        creditLink.textContent = text;
        creditLink.style.fontFamily = "sans-serif";
        creditLink.style.color = "yellow";
        creditLink.target = "_blank";
        topRow.appendChild(creditLink);
      }
    }
    const annotationToolStatus = this.registerDisposer(new AnnotationToolStatusWidget(this.selectedLayer, this.toolBinder));
    topRow.appendChild(annotationToolStatus.element);
    this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showAnnotationToolStatus, annotationToolStatus.element));
    if (stateShareEnabled) {
      const stateShare = this.registerDisposer(new StateShare(this));
      topRow.appendChild(stateShare.element);
    }
    {
      const layerListPanelState = this.layerListPanelState;
      const button = this.registerDisposer(new CheckboxIcon(layerListPanelState.location.watchableVisible, {
        svg: svg_layers,
        backgroundScheme: "dark",
        enableTitle: "Show layer list panel",
        disableTitle: "Hide layer list panel"
      }));
      button.element.insertAdjacentElement("afterbegin", this.registerDisposer(new LayerArchiveCountWidget(this.layerManager)).element);
      this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showLayerListPanelButton, button.element));
      topRow.appendChild(button.element);
    }
    {
      const selectionDetailsState = this.selectionDetailsState;
      const button = this.registerDisposer(new CheckboxIcon(selectionDetailsState.location.watchableVisible, {
        svg: svg_list,
        backgroundScheme: "dark",
        enableTitle: "Show selection details panel",
        disableTitle: "Hide selection details panel"
      }));
      this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showSelectionPanelButton, button.element));
      topRow.appendChild(button.element);
    }
    {
      const selectedLayer = this.selectedLayer;
      const button = this.registerDisposer(new CheckboxIcon({
        get value() {
          return selectedLayer.visible;
        },
        set value(visible) {
          selectedLayer.visible = visible;
        },
        changed: selectedLayer.location.locationChanged
      }, {
        svg: svg_controls_alt,
        backgroundScheme: "dark",
        enableTitle: "Show layer side panel",
        disableTitle: "Hide layer side panel"
      }));
      this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showLayerSidePanelButton, button.element));
      topRow.appendChild(button.element);
    }
    {
      const button = makeIcon({ text: "{}", title: "Edit JSON state" });
      this.registerEventListener(button, "click", () => {
        this.editJsonState();
      });
      this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showEditStateButton, button));
      topRow.appendChild(button);
    }
    {
      const button = makeCopyButton({
        title: "Copy view URL to clipboard",
        onClick: () => {
          const result = setClipboard(this.makeUrlFromState(this.state.toJSON()));
          StatusMessage.showTemporaryMessage(result ? "URL copied to clipboard" : "Failed to copy URL to clipboard");
        }
      });
      topRow.appendChild(button);
    }
    {
      const helpPanelState = this.helpPanelState;
      const button = this.registerDisposer(new CheckboxIcon(helpPanelState.location.watchableVisible, {
        text: "?",
        backgroundScheme: "dark",
        enableTitle: "Show help panel",
        disableTitle: "Hide help panel"
      }));
      this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showHelpButton, button.element));
      topRow.appendChild(button.element);
    }
    {
      const settingsPanelState = this.settingsPanelState;
      const button = this.registerDisposer(new CheckboxIcon(settingsPanelState.location.watchableVisible, {
        svg: svg_settings,
        backgroundScheme: "dark",
        enableTitle: "Show settings panel",
        disableTitle: "Hide settings panel"
      }));
      this.registerDisposer(new ElementVisibilityFromTrackableBoolean(this.uiControlVisibility.showSettingsButton, button.element));
      topRow.appendChild(button.element);
    }
    this.registerDisposer(new ElementVisibilityFromTrackableBoolean(makeDerivedWatchableValue((...values2) => values2.reduce((a, b) => a || b, false), ...VIEWER_TOP_ROW_CONFIG_OPTIONS.map((key) => this.uiControlVisibility[key])), topRow));
    gridContainer.appendChild(topRow);
    this.layout = this.registerDisposer(new RootLayoutContainer(this, "4panel"));
    this.sidePanelManager = this.registerDisposer(new SidePanelManager(this.display, this.layout.element, this.visibility));
    this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.layerListPanelState.location,
      makePanel: () => new LayerListPanel(this.sidePanelManager, this.layerSpecification, this.layerListPanelState)
    }));
    this.registerDisposer(new LayerSidePanelManager(this.sidePanelManager, this.selectedLayer.addRef()));
    this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.selectionDetailsState.location,
      makePanel: () => new SelectionDetailsPanel(this.sidePanelManager, this.selectionDetailsState, this.layerSpecification, this.selectedLayer)
    }));
    gridContainer.appendChild(this.sidePanelManager.element);
    this.closeSelectionTab = () => {
      for (const panel of this.sidePanelManager.registeredPanels) {
        if (panel.panel instanceof SelectionDetailsPanel) {
          panel.panel.close();
        }
      }
    };
    this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.statisticsDisplayState.location,
      makePanel: () => new StatisticsPanel(this.sidePanelManager, this.chunkQueueManager, this.statisticsDisplayState)
    }));
    this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.helpPanelState.location,
      makePanel: () => {
        const inputEventBindings = this.inputEventBindings;
        return new InputEventBindingHelpDialog(this.sidePanelManager, this.helpPanelState, [["Global", inputEventBindings.global], ["Cross section view", inputEventBindings.sliceView], ["3-D projection view", inputEventBindings.perspectiveView]], this.layerManager, this.toolBinder);
      }
    }));
    this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.settingsPanelState.location,
      makePanel: () => new ViewerSettingsPanel(this.sidePanelManager, this.settingsPanelState, this)
    }));
    const updateVisibility = () => {
      const shouldBeVisible = this.visibility.visible;
      if (shouldBeVisible !== this.visible) {
        gridContainer.style.visibility = shouldBeVisible ? "inherit" : "hidden";
        this.visible = shouldBeVisible;
      }
    };
    updateVisibility();
    this.registerDisposer(this.visibility.changed.add(updateVisibility));
  }
  /**
   * Called once by the constructor to set up event handlers.
   */
  registerEventActionBindings() {
    const element = this.element;
    this.registerDisposer(new KeyboardEventBinder(element, this.inputEventMap));
    this.registerDisposer(new AutomaticallyFocusedElement(element));
  }
  bindAction(action, handler) {
    this.registerDisposer(registerActionListener(this.element, action, handler));
  }
  bindCallback(action, callback) {
    const handler = () => {
      callback(this);
    };
    this.registerDisposer(registerActionListener(this.element, action, handler));
  }
  /**
   * Called once by the constructor to register the action listeners.
   */
  registerActionListeners() {
    for (const action of ["recolor", "clear-segments"]) {
      this.bindAction(action, () => {
        this.layerManager.invokeAction(action);
        this.closeSelectionTab && this.closeSelectionTab();
      });
    }
    for (const action of ["select"]) {
      this.bindAction(action, () => {
        this.mouseState.updateUnconditionally();
        this.layerManager.invokeAction(action);
      });
    }
    for (const action of ["copy-segment-id", "add-copy-segment-id"]) {
      this.bindAction(action, () => {
        this.mouseState.updateUnconditionally();
        this.layerManager.invokeAction(action, this.selectedLayer.layer);
      });
    }
    this.bindAction("help", () => this.toggleHelpPanel());
    for (let i = 1; i <= 9; ++i) {
      this.bindAction(`toggle-layer-${i}`, () => {
        const layer = this.layerManager.getLayerByNonArchivedIndex(i - 1);
        if (layer !== void 0) {
          layer.setVisible(!layer.visible);
        }
      });
      this.bindAction(`toggle-pick-layer-${i}`, () => {
        const layer = this.layerManager.getLayerByNonArchivedIndex(i - 1);
        if (layer !== void 0) {
          layer.pickEnabled = !layer.pickEnabled;
        }
      });
      this.bindAction(`select-layer-${i}`, () => {
        const layer = this.layerManager.getLayerByNonArchivedIndex(i - 1);
        if (layer !== void 0) {
          this.selectedLayer.layer = layer;
          this.selectedLayer.visible = true;
        }
      });
    }
    for (let i = 0; i < 26; ++i) {
      const uppercase = String.fromCharCode(65 + i);
      this.bindAction(`tool-${uppercase}`, () => {
        this.activateTool(uppercase);
      });
    }
    this.bindAction("annotate", () => {
      const selectedLayer = this.selectedLayer.layer;
      if (selectedLayer === void 0) {
        StatusMessage.showTemporaryMessage("The annotate command requires a layer to be selected.");
        return;
      }
      const userLayer = selectedLayer.layer;
      if (userLayer === null || userLayer.tool.value === void 0) {
        StatusMessage.showTemporaryMessage(`The selected layer (${_JSON$stringify(selectedLayer.name)}) does not have an active annotation tool.`);
        return;
      }
      userLayer.tool.value.trigger(this.mouseState);
    });
    this.bindAction("toggle-axis-lines", () => this.showAxisLines.toggle());
    this.bindAction("toggle-scale-bar", () => this.showScaleBar.toggle());
    this.bindAction("toggle-default-annotations", () => this.showDefaultAnnotations.toggle());
    this.bindAction("toggle-show-slices", () => this.showPerspectiveSliceViews.toggle());
    this.bindAction("toggle-show-statistics", () => this.showStatistics());
  }
  toggleHelpPanel() {
    this.helpPanelState.location.visible = !this.helpPanelState.location.visible;
  }
  activateTool(uppercase) {
    this.toolBinder.activate(uppercase);
  }
  editJsonState() {
    new StateEditorDialog(this);
  }
  copyJsonStateToUrl() {
    setClipboard(this.makeUrlFromState(this.state.toJSON()));
  }
  showStatistics(value = void 0) {
    if (value === void 0) {
      value = !this.statisticsDisplayState.location.visible;
    }
    this.statisticsDisplayState.location.visible = value;
  }
  get gl() {
    return this.display.gl;
  }
  onUpdateDisplay() {
    if (this.visible) {
      this.dataContext.chunkQueueManager.chunkUpdateDeadline = null;
    }
  }
  handleNavigationStateChanged() {
    if (this.visible) {
      let chunkQueueManager = this.dataContext.chunkQueueManager;
      if (chunkQueueManager.chunkUpdateDeadline === null) {
        chunkQueueManager.chunkUpdateDeadline = Date.now() + 10;
      }
    }
  }
}
const TOOL_JSON_KEY = "tool";
const TOOL_BINDINGS_JSON_KEY = "toolBindings";
const LOCAL_POSITION_JSON_KEY = "localPosition";
const LOCAL_COORDINATE_SPACE_JSON_KEY = "localDimensions";
const SOURCE_JSON_KEY = "source";
const TRANSFORM_JSON_KEY = "transform";
const PICK_JSON_KEY = "pick";
class LayerActionContext {
  constructor() {
    this.callbacks = [];
  }
  defer(callback) {
    this.callbacks.push(callback);
  }
}
class UserLayer extends RefCounted {
  constructor(managedLayer) {
    super();
    this.managedLayer = managedLayer;
    this.pick = new TrackableBoolean(true, true);
    this.layersChanged = new NullarySignal();
    this.readyStateChanged = new NullarySignal();
    this.specificationChanged = new NullarySignal();
    this.renderLayers = new Array();
    this.loadingCounter = 1;
    this.tabs = this.registerDisposer(new TabSpecification());
    this.panels = new UserLayerSidePanelsState(this);
    this.tool = this.registerDisposer(new SelectedLegacyTool(this));
    this.toolBinder = new LayerToolBinder(this);
    this.dataSourcesChanged = new NullarySignal();
    this.dataSources = [];
    this.allowingRefresh = false;
    this.localCoordinateSpaceCombiner.includeDimensionPredicate = isLocalOrChannelDimension;
    this.tabs.changed.add(this.specificationChanged.dispatch);
    this.panels.specificationChanged.add(this.specificationChanged.dispatch);
    this.tool.changed.add(this.specificationChanged.dispatch);
    this.toolBinder.changed.add(this.specificationChanged.dispatch);
    this.localPosition.changed.add(this.specificationChanged.dispatch);
    this.pick.changed.add(this.specificationChanged.dispatch);
    this.pick.changed.add(this.layersChanged.dispatch);
    this.dataSourcesChanged.add(this.specificationChanged.dispatch);
    this.dataSourcesChanged.add(() => this.updateDataSubsourceActivations());
    this.tabs.add("source", {
      label: "Source",
      order: -100,
      getter: () => new LayerDataSourcesTab(this)
    });
  }
  get localPosition() {
    return this.managedLayer.localPosition;
  }
  get localCoordinateSpaceCombiner() {
    return this.managedLayer.localCoordinateSpaceCombiner;
  }
  get localCoordinateSpace() {
    return this.managedLayer.localCoordinateSpace;
  }
  get type() {
    return this.constructor.type;
  }
  initializeSelectionState(state) {
    state.generation = -1;
    state.localPositionValid = false;
    state.localPosition = kEmptyFloat32Vec;
    state.localCoordinateSpace = void 0;
    state.annotationId = void 0;
    state.annotationType = void 0;
    state.annotationBuffer = void 0;
    state.annotationIndex = void 0;
    state.annotationCount = void 0;
    state.annotationSourceIndex = void 0;
    state.annotationSubsource = void 0;
    state.annotationPartIndex = void 0;
    state.value = void 0;
  }
  resetSelectionState(state) {
    state.localPositionValid = false;
    state.annotationId = void 0;
    state.value = void 0;
  }
  selectionStateFromJson(state, json2) {
    const localCoordinateSpace = state.localCoordinateSpace = this.localCoordinateSpace.value;
    const rank = localCoordinateSpace.rank;
    if (rank !== 0) {
      const localPosition = verifyOptionalObjectProperty(json2, LOCAL_POSITION_JSON_KEY, (positionObj) => parseFixedLengthArray(new Float32Array(rank), positionObj, verifyFiniteFloat));
      if (localPosition === void 0) {
        state.localPositionValid = false;
      } else {
        state.localPositionValid = true;
        state.localPosition = localPosition;
      }
    }
    const annotationId = state.annotationId = verifyOptionalObjectProperty(json2, "annotationId", verifyString);
    if (annotationId !== void 0) {
      state.annotationSourceIndex = verifyOptionalObjectProperty(json2, "annotationSource", verifyInt, 0);
      state.annotationPartIndex = verifyOptionalObjectProperty(json2, "annotationPart", verifyInt);
      state.annotationSubsource = verifyOptionalObjectProperty(json2, "annotationSubsource", verifyString);
    }
    state.value = json2.value;
  }
  // Derived classes should override.
  displaySelectionState(state, parent, context) {
    return false;
  }
  selectionStateToJson(state, forPython) {
    const json2 = {};
    if (state.localPositionValid) {
      const localPosition = state.localPosition;
      if (localPosition.length > 0) {
        json2.localPosition = _Array$from(localPosition);
      }
    }
    if (state.annotationId !== void 0) {
      json2.annotationId = state.annotationId;
      json2.annotationPart = state.annotationPartIndex;
      json2.annotationSource = state.annotationSourceIndex;
      json2.annotationSubsource = state.annotationSubsource;
    }
    if (state.value != null) {
      json2.value = state.value;
    }
    return json2;
  }
  captureSelectionState(state, mouseState) {
    state.localCoordinateSpace = this.localCoordinateSpace.value;
    const curLocalPosition = this.localPosition.value;
    let localPosition = state.localPosition;
    if (localPosition.length !== curLocalPosition.length) {
      state.localPosition = curLocalPosition.slice();
    } else {
      localPosition.set(curLocalPosition);
    }
    state.localPositionValid = true;
    state.value = this.getValueAt(mouseState.position, mouseState);
  }
  copySelectionState(dest, source) {
    dest.generation = source.generation;
    dest.localPositionValid = source.localPositionValid;
    dest.localCoordinateSpace = source.localCoordinateSpace;
    const curLocalPosition = source.localPosition;
    let localPosition = dest.localPosition;
    if (localPosition.length !== curLocalPosition.length) {
      dest.localPosition = curLocalPosition.slice();
    } else {
      dest.localPosition.set(curLocalPosition);
    }
    dest.annotationId = source.annotationId;
    dest.annotationType = source.annotationType;
    dest.annotationBuffer = source.annotationBuffer;
    dest.annotationIndex = source.annotationIndex;
    dest.annotationCount = source.annotationCount;
    dest.annotationSourceIndex = source.annotationSourceIndex;
    dest.annotationSubsource = source.annotationSubsource;
    dest.annotationPartIndex = source.annotationPartIndex;
    dest.value = source.value;
  }
  get isReady() {
    return this.loadingCounter === 0;
  }
  get manager() {
    return this.managedLayer.manager;
  }
  canAddDataSource() {
    return true;
  }
  addDataSource(spec) {
    const layerDataSource = new LayerDataSource(this, spec);
    this.dataSources.push(layerDataSource);
    this.dataSourcesChanged.dispatch();
    return layerDataSource;
  }
  // Should be overridden by derived classes.
  activateDataSubsources(subsources) {
  }
  updateDataSubsourceActivations() {
    function* getDataSubsources() {
      for (const dataSource of this.dataSources) {
        const loadState = dataSource.loadState;
        if (loadState === void 0 || loadState.error !== void 0) continue;
        for (const subsource of loadState.subsources) {
          if (subsource.enabled) {
            yield subsource;
          } else {
            const activated = subsource.activated;
            subsource.messages.clearMessages();
            if (activated !== void 0) {
              activated.dispose();
              subsource.activated = void 0;
              loadState.activatedSubsourcesChanged.dispatch();
            }
          }
        }
      }
    }
    this.activateDataSubsources(getDataSubsources.call(this));
  }
  decrementLoadingCounter() {
    if (--this.loadingCounter === 0) {
      this.readyStateChanged.dispatch();
    }
  }
  markLoading() {
    const localRetainer = this.localCoordinateSpaceCombiner.retain();
    const globalRetainer = this.manager.root.coordinateSpaceCombiner.retain();
    if (++this.loadingCounter === 1) {
      this.readyStateChanged.dispatch();
    }
    const disposer = () => {
      localRetainer();
      globalRetainer();
      this.decrementLoadingCounter();
    };
    return disposer;
  }
  addCoordinateSpace(coordinateSpace) {
    const globalBinding = this.manager.root.coordinateSpaceCombiner.bind(coordinateSpace);
    const localBinding = this.localCoordinateSpaceCombiner.bind(coordinateSpace);
    return () => {
      globalBinding();
      localBinding();
    };
  }
  initializationDone() {
    const selectionState = this.selectionState = {};
    this.initializeSelectionState(selectionState);
    this.decrementLoadingCounter();
  }
  getLegacyDataSourceSpecifications(sourceSpec, layerSpec, legacyTransform, explicitSpecs) {
    if (sourceSpec === void 0) return [];
    return [layerDataSourceSpecificationFromJson(sourceSpec, legacyTransform)];
  }
  getDataSourceSpecifications(layerSpec) {
    let legacySpec = void 0;
    let specs = verifyObjectProperty(layerSpec, SOURCE_JSON_KEY, (sourcesObj) => {
      if (Array.isArray(sourcesObj)) {
        return sourcesObj.map((source) => layerDataSourceSpecificationFromJson(source));
      } else if (typeof sourcesObj === "object") {
        return [layerDataSourceSpecificationFromJson(sourcesObj)];
      } else {
        legacySpec = sourcesObj;
        return [];
      }
    });
    const legacyTransform = verifyObjectProperty(layerSpec, TRANSFORM_JSON_KEY, coordinateTransformSpecificationFromLegacyJson);
    specs.push(...this.getLegacyDataSourceSpecifications(legacySpec, layerSpec, legacyTransform, specs));
    specs = specs.filter((spec) => spec.url);
    if (specs.length === 0) {
      specs.push(makeEmptyDataSourceSpecification());
    }
    return specs;
  }
  restoreState(specification) {
    this.tool.restoreState(specification[TOOL_JSON_KEY]);
    this.toolBinder.restoreState(specification[TOOL_BINDINGS_JSON_KEY]);
    this.panels.restoreState(specification);
    this.localCoordinateSpace.restoreState(specification[LOCAL_COORDINATE_SPACE_JSON_KEY]);
    this.localPosition.restoreState(specification[LOCAL_POSITION_JSON_KEY]);
    if (this.constructor.supportsPickOption) {
      this.pick.restoreState(specification[PICK_JSON_KEY]);
    }
    for (const spec of this.getDataSourceSpecifications(specification)) {
      this.addDataSource(spec);
    }
  }
  addRenderLayer(layer) {
    this.renderLayers.push(layer);
    const layersChanged = this.layersChanged;
    layer.layerChanged.add(layersChanged.dispatch);
    layer.userLayer = this;
    layersChanged.dispatch();
    return () => this.removeRenderLayer(layer);
  }
  removeRenderLayer(layer) {
    const renderLayers = this.renderLayers, layersChanged = this.layersChanged;
    const index2 = renderLayers.indexOf(layer);
    if (index2 === -1) {
      throw new Error("Attempted to remove invalid RenderLayer");
    }
    renderLayers.splice(index2, 1);
    layer.layerChanged.remove(layersChanged.dispatch);
    layer.userLayer = void 0;
    layer.dispose();
    layersChanged.dispatch();
  }
  disposed() {
    const layersChanged = this.layersChanged;
    invokeDisposers(this.dataSources);
    for (const layer of this.renderLayers) {
      layer.layerChanged.remove(layersChanged.dispatch);
      layer.dispose();
    }
    this.renderLayers.length = 0;
    super.disposed();
  }
  getValueAt(position, pickState) {
    let result;
    let renderLayers = this.renderLayers;
    let pickedRenderLayer = pickState.pickedRenderLayer;
    if (pickedRenderLayer !== null && renderLayers.indexOf(pickedRenderLayer) !== -1) {
      result = pickedRenderLayer.transformPickedValue(pickState);
      result = this.transformPickedValue(result);
      if (result != null) return result;
    }
    for (let layer of renderLayers) {
      result = layer.getValueAt(position);
      if (result != null) {
        break;
      }
    }
    return this.transformPickedValue(result);
  }
  transformPickedValue(value) {
    return value;
  }
  toJSON() {
    return _Object$assign({ type: this.type, [SOURCE_JSON_KEY]: dataSourcesToJson(this.dataSources), [TOOL_JSON_KEY]: this.tool.toJSON(), [TOOL_BINDINGS_JSON_KEY]: this.toolBinder.toJSON(), [LOCAL_COORDINATE_SPACE_JSON_KEY]: this.localCoordinateSpace.toJSON(), [LOCAL_POSITION_JSON_KEY]: this.localPosition.toJSON(), [PICK_JSON_KEY]: this.pick.toJSON() }, this.panels.toJSON());
  }
  // Derived classes should override.
  handleAction(_action, _context) {
  }
  selectedValueToJson(value) {
    return value;
  }
  selectedValueFromJson(json2) {
    return json2;
  }
  setLayerPosition(modelTransform, layerPosition) {
    const globalPosition = this.manager.root.globalPosition;
    const localPosition = this.localPosition;
    if (modelTransform) {
      gatherUpdate(globalPosition.value, layerPosition, modelTransform.globalToRenderLayerDimensions);
      gatherUpdate(localPosition.value, layerPosition, modelTransform.localToRenderLayerDimensions);
    } else {
      globalPosition.value.set(layerPosition);
    }
    localPosition.changed.dispatch();
    globalPosition.changed.dispatch();
  }
}
UserLayer.supportsPickOption = false;
function dataSourcesToJson(sources) {
  if (sources.length === 0) return void 0;
  if (sources.length === 1) return sources[0].toJSON();
  return sources.map((x) => x.toJSON());
}
class ManagedUserLayer extends RefCounted {
  /**
   * If layer is not null, tranfers ownership of a reference.
   */
  constructor(name2, manager) {
    super();
    this.manager = manager;
    this.localCoordinateSpace = new TrackableCoordinateSpace();
    this.localCoordinateSpaceCombiner = new CoordinateSpaceCombiner(this.localCoordinateSpace, isLocalDimension);
    this.localPosition = this.registerDisposer(new Position(this.localCoordinateSpace));
    this.nonArchivedLayerIndex = -1;
    this.readyStateChanged = new NullarySignal();
    this.layerChanged = new NullarySignal();
    this.specificationChanged = new NullarySignal();
    this.containers = new _Set();
    this.layer_ = null;
    this.visible = true;
    this.archived = false;
    this.name_ = name2;
  }
  get layer() {
    return this.layer_;
  }
  /**
   * If layer is not null, tranfers ownership of a reference.
   */
  set layer(layer) {
    let oldLayer = this.layer_;
    if (oldLayer != null) {
      this.unregisterUserLayer();
      oldLayer.dispose();
    }
    this.layer_ = layer;
    if (layer != null) {
      const removers = [layer.layersChanged.add(this.layerChanged.dispatch), layer.readyStateChanged.add(this.readyStateChanged.dispatch), layer.specificationChanged.add(this.specificationChanged.dispatch)];
      this.unregisterUserLayer = () => {
        removers.forEach((x) => x());
      };
      this.readyStateChanged.dispatch();
      this.layerChanged.dispatch();
    }
  }
  isReady() {
    const layer = this.layer;
    return layer !== null && layer.isReady;
  }
  get name() {
    return this.name_;
  }
  set name(value) {
    if (value !== this.name_) {
      this.name_ = value;
      this.layerChanged.dispatch();
    }
  }
  get supportsPickOption() {
    const userLayer = this.layer;
    return userLayer !== null && userLayer.constructor.supportsPickOption;
  }
  get pickEnabled() {
    const userLayer = this.layer;
    return userLayer !== null && userLayer.constructor.supportsPickOption && userLayer.pick.value;
  }
  set pickEnabled(value) {
    const userLayer = this.layer;
    if (userLayer !== null && userLayer.constructor.supportsPickOption) {
      userLayer.pick.value = value;
    }
  }
  toJSON() {
    let userLayer = this.layer;
    if (userLayer === null) {
      return void 0;
    }
    let layerSpec = userLayer.toJSON();
    layerSpec.name = this.name;
    if (!this.visible) {
      if (this.archived) {
        layerSpec["archived"] = true;
      } else {
        layerSpec["visible"] = false;
      }
    }
    return layerSpec;
  }
  setVisible(value) {
    if (value === this.visible) return;
    if (value && this.archived) {
      this.visible = true;
      this.setArchived(false);
      return;
    }
    this.visible = value;
    this.layerChanged.dispatch();
  }
  setArchived(value) {
    if (this.archived === value) return;
    if (value === true) {
      this.visible = false;
      this.archived = true;
      for (const _ref of this.manager.root.subsets) {
        const layerManager = _ref.layerManager;
        if (!layerManager.has(this)) continue;
        layerManager.removeManagedLayer(this);
      }
    } else {
      for (const _ref2 of this.manager.root.subsets) {
        const layerManager = _ref2.layerManager;
        if (layerManager.has(this)) continue;
        layerManager.addManagedLayer(this.addRef());
      }
      this.archived = false;
    }
    this.layerChanged.dispatch();
  }
  disposed() {
    this.layer = null;
    super.disposed();
  }
}
class LayerManager extends RefCounted {
  constructor() {
    super();
    this.managedLayers = new Array();
    this.layerSet = new _Set();
    this.layersChanged = new NullarySignal();
    this.readyStateChanged = new NullarySignal();
    this.specificationChanged = new NullarySignal();
    this.boundPositions = new _WeakSet();
    this.numDirectUsers = 0;
    this.nonArchivedLayerIndexGeneration = -1;
    this.renderLayerToManagedLayerMapGeneration = -1;
    this.renderLayerToManagedLayerMap_ = new _Map();
    this.scheduleRemoveLayersWithSingleRef = this.registerCancellable(debounce(() => this.removeLayersWithSingleRef(), 0));
    this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef);
  }
  updateNonArchivedLayerIndices() {
    const generation = this.layersChanged.count;
    if (generation === this.nonArchivedLayerIndexGeneration) return;
    this.nonArchivedLayerIndexGeneration = generation;
    let index2 = 0;
    for (const layer of this.managedLayers) {
      if (!layer.archived) {
        layer.nonArchivedLayerIndex = index2++;
      }
    }
    for (const layer of this.managedLayers) {
      if (layer.archived) {
        layer.nonArchivedLayerIndex = index2++;
      }
    }
  }
  getLayerByNonArchivedIndex(index2) {
    let i = 0;
    for (const layer of this.managedLayers) {
      if (!layer.archived) {
        if (i === index2) return layer;
        ++i;
      }
    }
    return void 0;
  }
  get renderLayerToManagedLayerMap() {
    const generation = this.layersChanged.count;
    const map2 = this.renderLayerToManagedLayerMap_;
    if (this.renderLayerToManagedLayerMapGeneration !== generation) {
      this.renderLayerToManagedLayerMapGeneration = generation;
      map2.clear();
      for (const managedLayer of this.managedLayers) {
        const userLayer = managedLayer.layer;
        if (userLayer !== null) {
          for (const renderLayer of userLayer.renderLayers) {
            map2.set(renderLayer, managedLayer);
          }
        }
      }
    }
    return map2;
  }
  filter(predicate) {
    let changed = false;
    this.managedLayers = this.managedLayers.filter((layer) => {
      if (!predicate(layer)) {
        this.unbindManagedLayer(layer);
        this.layerSet.delete(layer);
        changed = true;
        return false;
      }
      return true;
    });
    if (changed) {
      this.layersChanged.dispatch();
    }
  }
  removeLayersWithSingleRef() {
    if (this.numDirectUsers > 0) {
      return;
    }
    this.filter((layer) => layer.refCount !== 1 || layer.archived);
  }
  updateSignalBindings(layer, callback) {
    callback(layer.layerChanged, this.layersChanged.dispatch);
    callback(layer.readyStateChanged, this.readyStateChanged.dispatch);
    callback(layer.specificationChanged, this.specificationChanged.dispatch);
  }
  useDirectly() {
    if (++this.numDirectUsers === 1) {
      this.layersChanged.remove(this.scheduleRemoveLayersWithSingleRef);
    }
    return () => {
      if (--this.numDirectUsers === 0) {
        this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef);
        this.scheduleRemoveLayersWithSingleRef();
      }
    };
  }
  /**
   * Assumes ownership of an existing reference to managedLayer.
   */
  addManagedLayer(managedLayer, index2) {
    this.updateSignalBindings(managedLayer, addSignalBinding);
    this.layerSet.add(managedLayer);
    managedLayer.containers.add(this);
    if (index2 === void 0) {
      index2 = this.managedLayers.length;
    }
    this.managedLayers.splice(index2, 0, managedLayer);
    this.layersChanged.dispatch();
    this.readyStateChanged.dispatch();
    return managedLayer;
  }
  *readyRenderLayers() {
    for (let managedUserLayer of this.managedLayers) {
      if (!managedUserLayer.visible || !managedUserLayer.layer) {
        continue;
      }
      yield* managedUserLayer.layer.renderLayers;
    }
  }
  unbindManagedLayer(managedLayer) {
    this.updateSignalBindings(managedLayer, removeSignalBinding);
    managedLayer.containers.delete(this);
    managedLayer.manager.rootLayers.layersChanged.dispatch();
    managedLayer.dispose();
  }
  clear() {
    for (let managedLayer of this.managedLayers) {
      this.unbindManagedLayer(managedLayer);
    }
    this.managedLayers.length = 0;
    this.layerSet.clear();
    this.layersChanged.dispatch();
  }
  remove(index2) {
    const layer = this.managedLayers[index2];
    this.unbindManagedLayer(layer);
    this.managedLayers.splice(index2, 1);
    this.layerSet.delete(layer);
    this.layersChanged.dispatch();
  }
  removeManagedLayer(managedLayer) {
    let index2 = this.managedLayers.indexOf(managedLayer);
    if (index2 === -1) {
      throw new Error(`Internal error: invalid managed layer.`);
    }
    this.remove(index2);
  }
  reorderManagedLayer(oldIndex, newIndex) {
    const numLayers = this.managedLayers.length;
    if (oldIndex === newIndex || oldIndex < 0 || oldIndex >= numLayers || newIndex < 0 || newIndex >= numLayers) {
      return;
    }
    var _managedLayers$splice = this.managedLayers.splice(oldIndex, 1), _managedLayers$splice2 = _slicedToArray(_managedLayers$splice, 1);
    let oldLayer = _managedLayers$splice2[0];
    this.managedLayers.splice(newIndex, 0, oldLayer);
    this.layersChanged.dispatch();
  }
  disposed() {
    this.clear();
    super.disposed();
  }
  getLayerByName(name2) {
    return this.managedLayers.find((x) => x.name === name2);
  }
  getUniqueLayerName(name2) {
    let suggestedName = name2;
    let suffix = 0;
    while (this.getLayerByName(suggestedName) !== void 0) {
      suggestedName = name2 + ++suffix;
    }
    return suggestedName;
  }
  has(layer) {
    return this.layerSet.has(layer);
  }
  get renderLayers() {
    let layerManager = this;
    return {
      *[_Symbol$iterator]() {
        for (let managedLayer of layerManager.managedLayers) {
          if (managedLayer.layer === null) {
            continue;
          }
          for (let renderLayer of managedLayer.layer.renderLayers) {
            yield renderLayer;
          }
        }
      }
    };
  }
  get visibleRenderLayers() {
    let layerManager = this;
    return {
      *[_Symbol$iterator]() {
        for (let managedLayer of layerManager.managedLayers) {
          if (managedLayer.layer === null || !managedLayer.visible) {
            continue;
          }
          for (let renderLayer of managedLayer.layer.renderLayers) {
            yield renderLayer;
          }
        }
      }
    };
  }
  invokeAction(action, appliedLayer) {
    const context = new LayerActionContext();
    for (let managedLayer of this.managedLayers) {
      if (managedLayer.layer === null || !managedLayer.visible) {
        continue;
      }
      if (appliedLayer !== void 0 && managedLayer !== appliedLayer) {
        continue;
      }
      let userLayer = managedLayer.layer;
      userLayer.handleAction(action, context);
      for (let renderLayer of userLayer.renderLayers) {
        renderLayer.handleAction(action);
      }
    }
    for (const callback of context.callbacks) {
      callback();
    }
  }
}
class MouseSelectionState {
  constructor() {
    this.changed = new NullarySignal();
    this.coordinateSpace = emptyInvalidCoordinateSpace;
    this.position = kEmptyFloat32Vec;
    this.unsnappedPosition = kEmptyFloat32Vec;
    this.active = false;
    this.displayDimensions = void 0;
    this.pickedRenderLayer = null;
    this.pickedValue = new Uint64(0, 0);
    this.pickedOffset = 0;
    this.pickedAnnotationLayer = void 0;
    this.pickedAnnotationId = void 0;
    this.pickedAnnotationBuffer = void 0;
    this.pickedAnnotationBufferBaseOffset = void 0;
    this.pickedAnnotationIndex = void 0;
    this.pickedAnnotationCount = void 0;
    this.pickedAnnotationType = void 0;
    this.forcerFunction = void 0;
  }
  removeForcer(forcer) {
    if (forcer === this.forcerFunction) {
      this.forcerFunction = void 0;
      this.setActive(false);
    }
  }
  setForcer(forcer) {
    this.forcerFunction = forcer;
    if (forcer === void 0) {
      this.setActive(false);
    }
  }
  updateUnconditionally() {
    const forcerFunction = this.forcerFunction;
    if (forcerFunction === void 0) {
      return false;
    }
    forcerFunction();
    return this.active;
  }
  setActive(value) {
    if (this.active !== value || value === true) {
      this.active = value;
      this.changed.dispatch();
    }
  }
}
class LayerSelectedValues extends RefCounted {
  constructor(layerManager, mouseState) {
    super();
    this.layerManager = layerManager;
    this.mouseState = mouseState;
    this.changed = new NullarySignal();
    this.needsUpdate = true;
    this.registerDisposer(mouseState.changed.add(() => {
      this.handleChange();
    }));
    this.registerDisposer(layerManager.layersChanged.add(() => {
      this.handleLayerChange();
    }));
  }
  /**
   * This should be called when the layer data may have changed, due to the set of managed layers
   * changing or new data having been received.
   */
  handleLayerChange() {
    if (this.mouseState.active) {
      this.handleChange();
    }
  }
  handleChange() {
    this.needsUpdate = true;
    this.changed.dispatch();
  }
  update() {
    if (!this.needsUpdate) {
      return;
    }
    this.needsUpdate = false;
    let mouseState = this.mouseState;
    const generation = this.changed.count;
    if (mouseState.active) {
      for (const layer of this.layerManager.managedLayers) {
        const userLayer = layer.layer;
        if (layer.visible && userLayer !== null) {
          const selectionState = userLayer.selectionState;
          if (selectionState) {
            userLayer.resetSelectionState(selectionState);
            selectionState.generation = generation;
            userLayer.captureSelectionState(selectionState, mouseState);
          }
        }
      }
    }
  }
  get(userLayer) {
    this.update();
    const selectionState = userLayer.selectionState;
    if (selectionState && selectionState.generation !== this.changed.count) return void 0;
    return selectionState;
  }
  toJSON() {
    this.update();
    const result = {};
    for (const layer of this.layerManager.managedLayers) {
      const userLayer = layer.layer;
      if (userLayer) {
        const state = this.get(userLayer);
        if (state !== void 0) {
          result[layer.name] = userLayer.selectionStateToJson(state, true);
        }
      }
    }
    return result;
  }
}
const maxSelectionHistorySize = 10;
const DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION = _Object$assign(_Object$assign({}, DEFAULT_SIDE_PANEL_LOCATION), { minSize: 150, row: 1 });
const DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION_VISIBLE = _Object$assign(_Object$assign({}, DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION), { visible: true });
class TrackableDataSelectionState extends RefCounted {
  constructor(coordinateSpace, layerSelectedValues) {
    super();
    this.coordinateSpace = coordinateSpace;
    this.layerSelectedValues = layerSelectedValues;
    this.changed = new NullarySignal();
    this.history = [];
    this.historyIndex = 0;
    this.location = new TrackableSidePanelLocation(DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION);
    this.pin = new WatchableValue(true);
    this.registerDisposer(registerNested((context, pin) => {
      if (pin) return;
      this.capture(true);
      context.registerDisposer(layerSelectedValues.changed.add(context.registerCancellable(throttle(() => this.capture(true), 100, { leading: true, trailing: true }))));
    }, this.pin));
    this.pin.changed.add(this.changed.dispatch);
    this.location.changed.add(this.changed.dispatch);
  }
  get value() {
    return this.value_;
  }
  goBack() {
    const curIndex = this.pin.value ? this.historyIndex : this.history.length;
    if (curIndex > 0) {
      this.historyIndex = curIndex - 1;
      this.value_ = this.history[curIndex - 1];
      this.pin.value = true;
      this.changed.dispatch();
    }
  }
  canGoBack() {
    const curIndex = this.pin.value ? this.historyIndex : this.history.length;
    return curIndex > 0;
  }
  canGoForward() {
    if (!this.pin.value) return false;
    const curIndex = this.historyIndex;
    return curIndex + 1 < this.history.length;
  }
  goForward() {
    if (!this.pin.value) return;
    const curIndex = this.historyIndex;
    if (curIndex + 1 < this.history.length) {
      this.historyIndex = curIndex + 1;
      this.value_ = this.history[curIndex + 1];
      this.changed.dispatch();
    }
  }
  set value(value) {
    if (value !== this.value_) {
      this.value_ = value;
      if (value !== void 0 && this.pin.value) {
        const history2 = this.history;
        history2.length = Math.min(history2.length, this.historyIndex + 1);
        history2.push(value);
        if (history2.length > maxSelectionHistorySize) {
          history2.splice(0, history2.length - maxSelectionHistorySize);
        }
        this.historyIndex = history2.length - 1;
      }
      this.changed.dispatch();
    }
  }
  captureSingleLayerState(userLayer, capture, pin = true, forceShowingPanel = true) {
    if (pin === false && (!this.location.visible || this.pin.value)) return;
    const state = {};
    userLayer.initializeSelectionState(state);
    if (capture(state)) {
      if (forceShowingPanel) {
        this.location.visible = true;
      }
      if (pin === true) {
        this.pin.value = true;
      } else if (pin === "toggle") {
        this.pin.value = !this.pin.value;
      }
      this.value = {
        layers: [{ layer: userLayer, state }],
        coordinateSpace: this.coordinateSpace.value,
        position: void 0
      };
    }
  }
  reset() {
    this.location.reset();
    this.pin.value = false;
    this.value = void 0;
  }
  toJSON() {
    const value = this.value;
    let obj;
    if (this.location.visible) {
      obj = this.location.toJSON(_Object$assign(_Object$assign({}, DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION_VISIBLE), { visible: !globalViewerConfig.expectingExternalUI }));
      if (this.pin.value && value !== void 0) {
        const layersJson = {};
        for (const layerData of value.layers) {
          const layer = layerData.layer;
          let data = layer.selectionStateToJson(layerData.state, false);
          if (_Object$keys(data).length === 0) data = void 0;
          layersJson[layerData.layer.managedLayer.name] = data;
        }
        if (value.position !== void 0) {
          obj.position = _Array$from(value.position);
        }
        obj.layers = layersJson;
      }
    } else {
      obj = this.location.toJSON(DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION);
      obj = emptyToUndefined(obj);
      if (obj !== void 0) {
        obj.visible = false;
      }
    }
    return obj;
  }
  select(panelOn = true) {
    const pin = this.pin;
    if (panelOn) {
      this.location.visible = true;
    }
    pin.value = !pin.value;
    if (pin.value) {
      this.capture();
    }
  }
  capture(canRetain = false) {
    const newValue = capturePersistentViewerSelectionState(this.layerSelectedValues);
    if (canRetain && newValue === void 0) return;
    this.value = newValue;
  }
  restoreState(obj) {
    if (obj === void 0) {
      this.pin.value = true;
      this.value = void 0;
      return;
    }
    if (obj === null) {
      this.pin.value = false;
      this.location.visible = true;
      this.value = void 0;
      return;
    }
    verifyObject(obj);
    this.location.restoreState(obj, _Object$assign(_Object$assign({}, DATA_SELECTION_STATE_DEFAULT_PANEL_LOCATION_VISIBLE), { visible: !globalViewerConfig.expectingExternalUI }));
    const coordinateSpace = this.coordinateSpace.value;
    const position = coordinateSpace.rank > 0 ? verifyOptionalObjectProperty(obj, "position", (positionObj) => parseFixedLengthArray(new Float32Array(coordinateSpace.rank), positionObj, verifyFiniteFloat)) : void 0;
    const layers = [];
    verifyOptionalObjectProperty(obj, "layers", (layersObj) => {
      verifyObject(layersObj);
      const layerManager = this.layerSelectedValues.layerManager;
      for (const _ref3 of _Object$entries(layersObj)) {
        var _ref4 = _slicedToArray(_ref3, 2);
        const name2 = _ref4[0];
        const entry = _ref4[1];
        const managedLayer = layerManager.getLayerByName(name2);
        if (managedLayer === void 0) return;
        const layer = managedLayer.layer;
        if (layer === null) return;
        verifyObject(entry);
        const state = {};
        layer.initializeSelectionState(state);
        layer.selectionStateFromJson(state, entry);
        layers.push({ layer, state });
      }
    });
    this.pin.value = layers.length > 0 || position !== void 0;
    this.value = { position, coordinateSpace, layers };
  }
}
function capturePersistentViewerSelectionState(layerSelectedValues) {
  const mouseState = layerSelectedValues.mouseState;
  if (!mouseState.active) return void 0;
  const layers = [];
  for (const layer of layerSelectedValues.layerManager.managedLayers) {
    const userLayer = layer.layer;
    if (userLayer === null) continue;
    const state = layerSelectedValues.get(userLayer);
    if (state === void 0) continue;
    const stateCopy = {};
    userLayer.initializeSelectionState(stateCopy);
    userLayer.copySelectionState(stateCopy, state);
    layers.push({
      layer: userLayer,
      state: stateCopy
    });
  }
  return {
    position: mouseState.position.slice(),
    coordinateSpace: mouseState.coordinateSpace,
    layers
  };
}
class VisibleLayerInfo extends RefCounted {
  constructor(view) {
    super();
    this.view = view;
    this.messages = new MessageList();
    this.seenGeneration = -1;
    this.state = void 0;
  }
}
let visibleLayerInfoGeneration = 0;
class VisibleRenderLayerTracker extends RefCounted {
  constructor(layerManager, renderLayerType, view, roles, layerAdded, visibility) {
    super();
    this.layerManager = layerManager;
    this.renderLayerType = renderLayerType;
    this.view = view;
    this.roles = roles;
    this.layerAdded = layerAdded;
    this.visibility = visibility;
    this.visibleLayers_ = new _Map();
    this.debouncedUpdateVisibleLayers = this.registerCancellable(debounce(() => this.updateVisibleLayers(), 0));
    this.registerDisposer(layerManager.layersChanged.add(this.debouncedUpdateVisibleLayers));
    this.registerDisposer(roles.changed.add(this.debouncedUpdateVisibleLayers));
    this.updateVisibleLayers();
  }
  disposed() {
    this.visibleLayers.forEach((attachment) => attachment.dispose());
    this.visibleLayers.clear();
    super.disposed();
  }
  updateVisibleLayers() {
    const curGeneration = ++visibleLayerInfoGeneration;
    const visibleLayers = this.visibleLayers_, renderLayerType = this.renderLayerType, layerAdded = this.layerAdded, roles = this.roles;
    for (let renderLayer of this.layerManager.readyRenderLayers()) {
      if (renderLayer instanceof renderLayerType && roles.has(renderLayer.role)) {
        let typedLayer = renderLayer;
        let info = visibleLayers.get(typedLayer);
        if (info === void 0) {
          info = new VisibleLayerInfo(this.view);
          info.registerDisposer(typedLayer.messages.addChild(info.messages));
          info.registerDisposer(typedLayer.addRef());
          info.registerDisposer(typedLayer.visibility.add(this.visibility));
          visibleLayers.set(typedLayer, info);
          layerAdded(typedLayer, info);
          typedLayer.attach(info);
        }
        info.seenGeneration = curGeneration;
      }
    }
    for (const _ref5 of visibleLayers) {
      var _ref6 = _slicedToArray(_ref5, 2);
      const renderLayer = _ref6[0];
      const info = _ref6[1];
      if (info.seenGeneration !== curGeneration) {
        visibleLayers.delete(renderLayer);
        info.dispose();
      }
    }
  }
  get visibleLayers() {
    this.debouncedUpdateVisibleLayers.flush();
    return this.visibleLayers_;
  }
}
function makeRenderedPanelVisibleLayerTracker(layerManager, renderLayerType, roles, panel, layerAdded) {
  return panel.registerDisposer(new VisibleRenderLayerTracker(layerManager, renderLayerType, panel, roles, (layer, info) => {
    info.registerDisposer(layer.redrawNeeded.add(() => panel.scheduleRedraw()));
    const backend = layer.backend;
    if (backend) {
      backend.rpc.invoke(RENDERED_VIEW_ADD_LAYER_RPC_ID, { layer: backend.rpcId, view: panel.rpcId });
      info.registerDisposer(() => backend.rpc.invoke(RENDERED_VIEW_REMOVE_LAYER_RPC_ID, { layer: backend.rpcId, view: panel.rpcId }));
    }
    panel.scheduleRedraw();
    info.registerDisposer(() => panel.scheduleRedraw());
  }, panel.visibility));
}
class SelectedLayerState extends RefCounted {
  constructor(layerManager) {
    super();
    this.layerManager = layerManager;
    this.changed = new NullarySignal();
    this.location = new TrackableSidePanelLocation(SELECTED_LAYER_SIDE_PANEL_DEFAULT_LOCATION);
    this.registerDisposer(layerManager);
    this.location.changed.add(() => {
      var _a, _b;
      this.changed.dispatch();
      const userLayer = (_b = (_a = this.layer) === null || _a === void 0 ? void 0 : _a.layer) !== null && _b !== void 0 ? _b : void 0;
      if (userLayer !== void 0) {
        const curLocation = this.location.value;
        if (curLocation.visible) {
          const panel = userLayer.panels.panels[0];
          if (panel.location.value !== curLocation) {
            panel.location.value = curLocation;
            panel.location.locationChanged.dispatch();
          }
        }
      }
    });
  }
  get layer() {
    return this.layer_;
  }
  get visible() {
    return this.location.visible;
  }
  toggle(layer) {
    if (this.layer === layer && this.visible) {
      this.visible = false;
    } else {
      this.layer = layer;
      this.visible = true;
    }
  }
  set visible(value) {
    let existingLayer = this.layer_;
    if (value === true && existingLayer === void 0) {
      const managedLayers = this.layerManager.managedLayers;
      if (managedLayers.length > 0) {
        existingLayer = this.layer = managedLayers[0];
      } else {
        value = false;
      }
    }
    if (value === true && existingLayer !== void 0) {
      const userLayer = existingLayer.layer;
      if (userLayer === null || userLayer.panels.panels[0].tabs.length === 0) {
        value = false;
      }
    }
    if (this.visible !== value) {
      this.location.visible = value;
      if (!value && existingLayer !== void 0) {
        this.maybeDeleteNewLayer(existingLayer);
      }
      this.changed.dispatch();
    }
  }
  maybeDeleteNewLayer(existingLayer) {
    if (existingLayer.wasDisposed) return;
    const userLayer = existingLayer.layer;
    if (userLayer !== null && userLayer instanceof NewUserLayer) {
      if (!userLayer.dataSources.some((x) => x.spec.url.length !== 0)) {
        deleteLayer(existingLayer);
      }
    }
  }
  set layer(layer) {
    if (layer === this.layer_) {
      return;
    }
    const existingLayer = this.layer_;
    if (existingLayer !== void 0) {
      this.existingLayerDisposer();
      this.existingLayerDisposer = void 0;
      this.maybeDeleteNewLayer(existingLayer);
    }
    this.layer_ = layer;
    if (layer !== void 0) {
      const layerDisposed = () => {
        this.layer_ = void 0;
        this.visible = false;
        this.existingLayerDisposer = void 0;
        this.changed.dispatch();
      };
      layer.registerDisposer(layerDisposed);
      const layerChangedDisposer = layer.specificationChanged.add(() => {
        this.changed.dispatch();
      });
      this.existingLayerDisposer = () => {
        const userLayer = layer.layer;
        if (userLayer !== null) {
          const tool = userLayer.tool.value;
          if (tool !== void 0) {
            tool.deactivate();
          }
        }
        layer.unregisterDisposer(layerDisposed);
        layerChangedDisposer();
      };
    } else {
      this.location.visible = false;
    }
    this.changed.dispatch();
  }
  toJSON() {
    const obj = this.location.toJSON();
    if (this.layer !== void 0) {
      obj.layer = this.layer.name;
    }
    return emptyToUndefined(obj);
  }
  restoreState(obj) {
    if (obj === void 0) {
      this.reset();
      return;
    }
    verifyObject(obj);
    this.location.restoreState(obj);
    const layerName = verifyObjectProperty(obj, "layer", verifyOptionalString);
    const layer = layerName !== void 0 ? this.layerManager.getLayerByName(layerName) : void 0;
    if (layer === void 0) {
      this.visible = false;
    }
    this.layer = layer;
  }
  reset() {
    this.location.reset();
    this.layer = void 0;
  }
}
class LayerReference extends RefCounted {
  constructor(layerManager, filter) {
    super();
    this.layerManager = layerManager;
    this.filter = filter;
    this.changed = new NullarySignal();
    this.validate = debounce(() => {
      const layerName_ = this.layerName_;
      if (layerName_ !== void 0) {
        const layer = this.layerManager.getLayerByName(layerName_);
        if (layer !== void 0 && this.filter(layer)) {
          this.layer_ = layer;
          this.changed.dispatch();
        } else {
          this.layer_ = void 0;
          this.layerName_ = void 0;
          this.changed.dispatch();
        }
      }
    }, 0);
    this.registerDisposer(layerManager);
    this.registerDisposer(layerManager.specificationChanged.add(() => {
      const layer_ = this.layer_;
      if (layer_ !== void 0) {
        if (!this.layerManager.layerSet.has(layer_) || !this.filter(layer_)) {
          this.layer_ = void 0;
          this.layerName_ = void 0;
          this.changed.dispatch();
        } else {
          const name2 = layer_.name;
          if (name2 !== this.layerName_) {
            this.layerName_ = name2;
            this.changed.dispatch();
          }
        }
      }
    }));
  }
  get layer() {
    return this.layer_;
  }
  get layerName() {
    return this.layerName_;
  }
  set layer(value) {
    if (this.layer_ === value) {
      return;
    }
    if (value !== void 0 && this.layerManager.layerSet.has(value) && this.filter(value)) {
      this.layer_ = value;
      this.layerName_ = value.name;
    } else {
      this.layer_ = void 0;
      this.layerName_ = void 0;
    }
    this.changed.dispatch();
  }
  set layerName(value) {
    if (value === this.layerName_) {
      return;
    }
    this.layer_ = void 0;
    this.layerName_ = value;
    this.changed.dispatch();
    this.validate();
  }
  restoreState(obj) {
    const layerName = verifyOptionalString(obj);
    this.layerName = layerName;
  }
  toJSON() {
    const layer_ = this.layer_;
    if (layer_ !== void 0) {
      return layer_.name;
    }
    return this.layerName_;
  }
  reset() {
    this.layerName_ = void 0;
    this.layer_ = void 0;
    this.changed.dispatch();
  }
}
class LinkedLayerGroup extends RefCounted {
  constructor(layerManager, layer, predicate, getGroup) {
    super();
    this.layerManager = layerManager;
    this.layer = layer;
    this.predicate = predicate;
    this.getGroup = getGroup;
    this.linkedLayers_ = new _Set();
    this.changed = new NullarySignal();
    this.linkedLayersChanged = new NullarySignal();
    this.root_ = layer;
    const self2 = this;
    this.root = {
      get value() {
        return self2.root_;
      },
      changed: self2.changed
    };
  }
  get linkedLayers() {
    return this.linkedLayers_;
  }
  get rootGroup() {
    return this.getGroup(this.root.value);
  }
  reset() {
    this.isolate();
  }
  restoreState(obj) {
    if (obj === void 0) return;
    const name2 = verifyString(obj);
    this.linkByName(name2);
  }
  toJSON() {
    const root = this.root.value;
    if (root === this.layer) return void 0;
    return root.managedLayer.name;
  }
  isolate(notifyChanged = true) {
    const getGroup = this.getGroup, layer = this.layer, root = this.root_;
    if (root === layer) {
      const linkedLayers_ = this.linkedLayers_;
      if (linkedLayers_.size !== 0) {
        for (const otherLayer of linkedLayers_) {
          const otherGroup = getGroup(otherLayer);
          otherGroup.root_ = otherLayer;
          otherGroup.changed.dispatch();
        }
        linkedLayers_.clear();
        this.linkedLayersChanged.dispatch();
      }
      return;
    }
    const rootGroup = getGroup(root);
    rootGroup.linkedLayers_.delete(layer);
    rootGroup.linkedLayersChanged.dispatch();
    this.root_ = layer;
    if (notifyChanged) {
      this.changed.dispatch();
    }
  }
  linkByName(otherLayerName) {
    const layer = this.layer;
    const managedLayer = layer.managedLayer;
    const layerManager = this.layerManager;
    const otherLayer = layerManager.getLayerByName(otherLayerName);
    if (otherLayer === void 0) return;
    if (otherLayer === managedLayer) return;
    const otherUserLayer = otherLayer.layer;
    if (otherUserLayer === null) return;
    if (!this.predicate(otherUserLayer)) return;
    this.linkToLayer(otherUserLayer);
  }
  linkToLayer(otherUserLayer) {
    if (otherUserLayer === this.layer) return;
    if (this.root_ === otherUserLayer) return;
    if (this.root_ !== this.layer) {
      this.isolate(
        /*notifyChanged=*/
        false
      );
    }
    const getGroup = this.getGroup;
    const newRoot = getGroup(otherUserLayer).root_;
    if (newRoot === this.layer) return;
    const rootGroup = getGroup(newRoot);
    rootGroup.linkedLayers_.add(this.layer);
    rootGroup.linkedLayersChanged.dispatch();
    this.root_ = newRoot;
    this.changed.dispatch();
  }
  disposed() {
    this.isolate(
      /*notifyChanged=*/
      false
    );
  }
}
function initializeLayerFromSpecNoRestoreState(managedLayer, spec) {
  const layerType = verifyOptionalObjectProperty(spec, "type", verifyString, "auto");
  managedLayer.archived = verifyOptionalObjectProperty(spec, "archived", verifyBoolean, false);
  if (!managedLayer.archived) {
    managedLayer.visible = verifyOptionalObjectProperty(spec, "visible", verifyBoolean, true);
  } else {
    managedLayer.visible = false;
  }
  const layerConstructor = layerTypes.get(layerType) || NewUserLayer;
  managedLayer.layer = new layerConstructor(managedLayer);
  return spec;
}
function completeUserLayerInitialization(managedLayer, spec) {
  try {
    const userLayer = managedLayer.layer;
    if (userLayer === null) return;
    userLayer.restoreState(spec);
    userLayer.initializationDone();
  } catch (e) {
    deleteLayer(managedLayer);
    throw e;
  }
}
function initializeLayerFromSpec(managedLayer, spec) {
  try {
    verifyObject(spec);
    initializeLayerFromSpecNoRestoreState(managedLayer, spec);
    completeUserLayerInitialization(managedLayer, spec);
  } catch (e) {
    deleteLayer(managedLayer);
    throw e;
  }
}
function initializeLayerFromSpecShowErrorStatus(managedLayer, spec) {
  try {
    initializeLayerFromSpec(managedLayer, spec);
  } catch (e) {
    const msg = new StatusMessage();
    msg.setErrorMessage(e instanceof Error ? e.message : "" + e);
  }
}
function makeLayer(manager, name2, spec) {
  const managedLayer = new ManagedUserLayer(name2, manager);
  initializeLayerFromSpec(managedLayer, spec);
  return managedLayer;
}
class LayerListSpecification extends RefCounted {
  constructor() {
    super(...arguments);
    this.changed = new NullarySignal();
  }
}
class TopLevelLayerListSpecification extends LayerListSpecification {
  constructor(display, dataSourceProviderRegistry, layerManager, chunkManager, selectionState, selectedLayer, coordinateSpace, globalPosition, toolBinder) {
    super();
    this.display = display;
    this.dataSourceProviderRegistry = dataSourceProviderRegistry;
    this.layerManager = layerManager;
    this.chunkManager = chunkManager;
    this.selectionState = selectionState;
    this.selectedLayer = selectedLayer;
    this.coordinateSpace = coordinateSpace;
    this.globalPosition = globalPosition;
    this.toolBinder = toolBinder;
    this.coordinateSpaceCombiner = new CoordinateSpaceCombiner(this.coordinateSpace, isGlobalDimension);
    this.subsets = new _Set();
    this.layerSelectedValues = this.selectionState.layerSelectedValues;
    this.registerDisposer(layerManager.layersChanged.add(this.changed.dispatch));
    this.registerDisposer(layerManager.specificationChanged.add(this.changed.dispatch));
  }
  get rpc() {
    return this.chunkManager.rpc;
  }
  get root() {
    return this;
  }
  reset() {
    this.layerManager.clear();
  }
  restoreState(x) {
    this.layerManager.clear();
    let layerSpecs;
    if (!Array.isArray(x)) {
      verifyObject(x);
      layerSpecs = _Object$entries(x).map(([name2, layerSpec]) => {
        if (typeof layerSpec === "string") {
          return { name: name2, source: layerSpec };
        } else {
          verifyObject(layerSpec);
          return _Object$assign(_Object$assign({}, layerSpec), { name: name2 });
        }
      });
    } else {
      layerSpecs = x;
    }
    const layersToRestore = [];
    for (const layerSpec of layerSpecs) {
      verifyObject(layerSpec);
      const name2 = this.layerManager.getUniqueLayerName(verifyObjectProperty(layerSpec, "name", verifyString));
      const managedLayer = new ManagedUserLayer(name2, this);
      try {
        initializeLayerFromSpecNoRestoreState(managedLayer, layerSpec);
        this.layerManager.addManagedLayer(managedLayer);
        layersToRestore.push({ managedLayer, spec: layerSpec });
      } catch (e) {
        managedLayer.dispose();
        const msg = new StatusMessage();
        msg.setErrorMessage(`Error creating layer ${_JSON$stringify(name2)}: ` + (e instanceof Error) ? e.message : "" + e);
      }
    }
    for (const _ref7 of layersToRestore) {
      const managedLayer = _ref7.managedLayer;
      const spec = _ref7.spec;
      try {
        completeUserLayerInitialization(managedLayer, spec);
      } catch (e) {
        const msg = new StatusMessage();
        msg.setErrorMessage(`Error creating layer ${_JSON$stringify(name)}: ` + (e instanceof Error) ? e.message : "" + e);
      }
    }
  }
  add(layer, index2) {
    if (this.layerManager.managedLayers.indexOf(layer) === -1) {
      layer.name = this.layerManager.getUniqueLayerName(layer.name);
    }
    this.layerManager.addManagedLayer(layer, index2);
  }
  toJSON() {
    const result = [];
    let numResults = 0;
    for (let managedLayer of this.layerManager.managedLayers) {
      const layerJson = managedLayer.toJSON();
      if (layerJson != null) {
        result.push(layerJson);
        ++numResults;
      }
    }
    if (numResults === 0) {
      return void 0;
    }
    return result;
  }
  get rootLayers() {
    return this.layerManager;
  }
}
class LayerSubsetSpecification extends LayerListSpecification {
  constructor(master) {
    super();
    this.master = master;
    this.changed = new NullarySignal();
    this.layerManager = this.registerDisposer(new LayerManager());
    this.registerDisposer(master);
    const layerManager = this.layerManager;
    this.registerDisposer(layerManager.layersChanged.add(this.changed.dispatch));
    this.registerDisposer(layerManager.specificationChanged.add(this.changed.dispatch));
    master.subsets.add(this);
  }
  get rpc() {
    return this.master.rpc;
  }
  get dataSourceProviderRegistry() {
    return this.master.dataSourceProviderRegistry;
  }
  get chunkManager() {
    return this.master.chunkManager;
  }
  get layerSelectedValues() {
    return this.master.layerSelectedValues;
  }
  get root() {
    return this.master;
  }
  disposed() {
    super.disposed();
    this.master.subsets.delete(this);
  }
  reset() {
    this.layerManager.clear();
  }
  restoreState(x) {
    const masterLayerManager = this.master.layerManager;
    const layers = [];
    for (const name2 of new _Set(parseArray(x, verifyString))) {
      const layer = masterLayerManager.getLayerByName(name2);
      if (layer === void 0) {
        throw new Error(`Undefined layer referenced in subset specification: ${_JSON$stringify(name2)}`);
      }
      if (layer.archived) continue;
      layers.push(layer);
    }
    this.layerManager.clear();
    for (const layer of layers) {
      this.layerManager.addManagedLayer(layer.addRef());
    }
  }
  toJSON() {
    return this.layerManager.managedLayers.map((x) => x.name);
  }
  add(layer, index2) {
    if (this.master.layerManager.managedLayers.indexOf(layer) === -1) {
      layer.name = this.master.layerManager.getUniqueLayerName(layer.name);
      this.master.layerManager.addManagedLayer(layer.addRef());
    }
    this.layerManager.addManagedLayer(layer, index2);
  }
  get rootLayers() {
    return this.master.rootLayers;
  }
}
const layerTypes = new _Map();
const volumeLayerTypes = new _Map();
const layerTypeDetectors = [(subsource) => {
  const volume = subsource.volume;
  if (volume === void 0) return void 0;
  const layerConstructor = volumeLayerTypes.get(volume.volumeType);
  if (layerConstructor === void 0) return void 0;
  return { layerConstructor, priority: 0 };
}];
function registerLayerType(layerConstructor, name2 = layerConstructor.type) {
  layerTypes.set(name2, layerConstructor);
}
function registerLayerTypeDetector(detector) {
  layerTypeDetectors.push(detector);
}
function registerVolumeLayerType(volumeType, layerConstructor) {
  volumeLayerTypes.set(volumeType, layerConstructor);
}
function changeLayerType(managedLayer, layerConstructor) {
  const userLayer = managedLayer.layer;
  if (userLayer === null) return;
  const spec = userLayer.toJSON();
  const newUserLayer = new layerConstructor(managedLayer);
  newUserLayer.restoreState(spec);
  newUserLayer.initializationDone();
  managedLayer.layer = newUserLayer;
}
function changeLayerName(managedLayer, newName) {
  if (newName !== managedLayer.name) {
    newName = managedLayer.manager.root.layerManager.getUniqueLayerName(newName);
    managedLayer.name = newName;
    managedLayer.layerChanged.dispatch();
    return true;
  }
  return false;
}
function deleteLayer(managedLayer) {
  if (managedLayer.wasDisposed) return;
  for (const layerManager of managedLayer.containers) {
    layerManager.removeManagedLayer(managedLayer);
  }
}
function getMaxPriorityGuess(a, b) {
  if (a === void 0) return b;
  if (b === void 0) return a;
  return a.priority < b.priority ? b : a;
}
function detectLayerTypeFromDataSubsource(subsource) {
  let bestGuess;
  for (const detector of layerTypeDetectors) {
    bestGuess = getMaxPriorityGuess(bestGuess, detector(subsource));
  }
  const volume = subsource.volume;
  if (volume !== void 0) {
    const layerConstructor = volumeLayerTypes.get(volume.volumeType);
    if (layerConstructor !== void 0) {
      bestGuess = getMaxPriorityGuess(bestGuess, { layerConstructor, priority: 0 });
    }
  }
  return bestGuess;
}
function detectLayerTypeFromSubsources(subsources) {
  let guess;
  for (const loadedSubsource of subsources) {
    const subsourceEntry = loadedSubsource.subsourceEntry;
    const subsource = subsourceEntry.subsource;
    guess = getMaxPriorityGuess(guess, detectLayerTypeFromDataSubsource(subsource));
  }
  return guess;
}
class NewUserLayer extends UserLayer {
  activateDataSubsources(subsources) {
    var _a;
    this.detectedLayerConstructor = (_a = detectLayerTypeFromSubsources(subsources)) === null || _a === void 0 ? void 0 : _a.layerConstructor;
  }
}
NewUserLayer.type = "new";
NewUserLayer.typeAbbreviation = "new";
class AutoUserLayer extends UserLayer {
  activateDataSubsources(subsources) {
    var _a;
    const layerConstructor = (_a = detectLayerTypeFromSubsources(subsources)) === null || _a === void 0 ? void 0 : _a.layerConstructor;
    if (layerConstructor !== void 0) {
      changeLayerType(this.managedLayer, layerConstructor);
    }
  }
}
AutoUserLayer.type = "auto";
AutoUserLayer.typeAbbreviation = "auto";
function addNewLayer(manager, selectedLayer) {
  const layer = makeLayer(manager, "new layer", { type: "new" });
  manager.add(layer);
  selectedLayer.layer = layer;
  selectedLayer.visible = true;
}
registerLayerType(NewUserLayer);
registerLayerType(AutoUserLayer);
function murmurHash3_x86_32Mix(h, k) {
  k = _Math$imul(k, 3432918353) >>> 0;
  k = (k << 15 | k >>> 17) >>> 0;
  k = _Math$imul(k, 461845907) >>> 0;
  h ^= k;
  h = (h << 13 | h >>> 19) >>> 0;
  h = _Math$imul(h, 5) + 3864292196 >>> 0;
  return h;
}
function murmurHash3_x86_32Finalize(h, len2) {
  h ^= len2;
  h ^= h >>> 16;
  h = _Math$imul(h, 2246822507) >>> 0;
  h ^= h >>> 13;
  h *= 3266489909;
  h ^= h >>> 16;
  return h >>> 0;
}
function murmurHash3_x86_32Hash64Bits(seed, low, high) {
  let h = seed;
  h = murmurHash3_x86_32Mix(h, low);
  h = murmurHash3_x86_32Mix(h, high);
  return murmurHash3_x86_32Finalize(h, 8);
}
class IndexedSegmentPropertySource extends ChunkSource {
  constructor(chunkManager, options) {
    super(chunkManager, options);
    this.properties = options.properties;
  }
  static encodeOptions(options) {
    return { properties: options.properties };
  }
}
function insertIntoLinearChainingTable(table, hashCode, value) {
  const mask = table.length - 1;
  while (true) {
    hashCode = hashCode & mask;
    if (table[hashCode] === 0) {
      table[hashCode] = value;
      return;
    }
    ++hashCode;
  }
}
function makeIndicesArray(size, maxValue) {
  if (maxValue <= 255) {
    return new Uint8Array(size);
  }
  if (maxValue <= 65535) {
    return new Uint16Array(size);
  }
  return new Uint32Array(size);
}
function makeUint64PermutationHashMap(values2) {
  const numEntries = values2.length / 2;
  const hashCodeBits = Math.ceil(_Math$log$1(numEntries)) + 1;
  const size = 2 ** hashCodeBits;
  const table = makeIndicesArray(size, numEntries + 1);
  for (let i = 0; i < numEntries; ++i) {
    const low = values2[2 * i];
    const high = values2[2 * i + 1];
    insertIntoLinearChainingTable(table, murmurHash3_x86_32Hash64Bits(
      /*seed=*/
      0,
      low,
      high
    ), i + 1);
  }
  return table;
}
function queryUint64PermutationHashMap(table, values2, low, high) {
  let hashCode = murmurHash3_x86_32Hash64Bits(
    /*seed=*/
    0,
    low,
    high
  );
  const mask = table.length - 1;
  while (true) {
    hashCode = hashCode & mask;
    let index2 = table[hashCode];
    if (index2 === 0) return -1;
    --index2;
    if (values2[2 * index2] === low && values2[2 * index2 + 1] === high) {
      return index2;
    }
    ++hashCode;
  }
}
class SegmentPropertyMap {
  constructor(options) {
    this.inlineProperties = options.inlineProperties;
  }
}
class PreprocessedSegmentPropertyMap {
  constructor(segmentPropertyMap) {
    var _a;
    this.segmentPropertyMap = segmentPropertyMap;
    const inlineProperties = segmentPropertyMap.inlineProperties;
    if (inlineProperties !== void 0) {
      this.inlineIdToIndex = makeUint64PermutationHashMap(inlineProperties.ids);
    }
    this.tags = inlineProperties === null || inlineProperties === void 0 ? void 0 : inlineProperties.properties.find((p) => p.type === "tags");
    this.labels = inlineProperties === null || inlineProperties === void 0 ? void 0 : inlineProperties.properties.find((p) => p.type === "label");
    this.numericalProperties = (_a = inlineProperties === null || inlineProperties === void 0 ? void 0 : inlineProperties.properties.filter((p) => p.type === "number")) !== null && _a !== void 0 ? _a : [];
  }
  getSegmentInlineIndex(id) {
    const inlineIdToIndex = this.inlineIdToIndex;
    if (inlineIdToIndex === void 0) return -1;
    return queryUint64PermutationHashMap(inlineIdToIndex, this.segmentPropertyMap.inlineProperties.ids, id.low, id.high);
  }
  getSegmentLabel(id) {
    const index2 = this.getSegmentInlineIndex(id);
    if (index2 === -1) return void 0;
    const labels = this.labels, tagsProperty = this.tags;
    let label = "";
    if (labels !== void 0) {
      label = labels.values[index2];
    }
    if (tagsProperty !== void 0) {
      const tags = tagsProperty.tags, values2 = tagsProperty.values;
      let tagIndices = values2[index2];
      for (let i = 0, length2 = tagIndices.length; i < length2; ++i) {
        const tag = tags[tagIndices.charCodeAt(i)];
        if (label.length > 0) {
          label += " ";
        }
        label += "#";
        label += tag;
      }
    }
    if (label.length === 0) return void 0;
    return label;
  }
}
function remapArray(input, output, toMerged) {
  for (let i = 0, length2 = toMerged.length; i < length2; ++i) {
    output[toMerged[i]] = input[i];
  }
}
function isIdArraySorted(ids) {
  const n = ids.length;
  if (n === 0) return true;
  let prevLow = ids[0], prevHigh = ids[1];
  for (let i = 0; i < n; i += 2) {
    const low = ids[i], high = ids[i + 1];
    if ((high - prevHigh || low - prevLow) <= 0) return false;
    prevLow = low;
    prevHigh = high;
  }
  return true;
}
function normalizeInlineSegmentPropertyMap(inlineProperties) {
  const ids = inlineProperties.ids;
  if (isIdArraySorted(ids)) {
    return inlineProperties;
  }
  const length2 = ids.length / 2;
  const permutation = makeIndicesArray(length2, length2 - 1);
  for (let i = 0; i < length2; ++i) {
    permutation[i] = i;
  }
  permutation.sort((a, b) => {
    const aLow = ids[a * 2], aHigh = ids[a * 2 + 1];
    const bLow = ids[b * 2], bHigh = ids[b * 2 + 1];
    return aHigh - bHigh || aLow - bLow;
  });
  const newIds = new Uint32Array(length2 * 2);
  for (let newIndex = 0; newIndex < length2; ++newIndex) {
    const oldIndex = permutation[newIndex];
    newIds[newIndex * 2] = ids[oldIndex * 2];
    newIds[newIndex * 2 + 1] = ids[oldIndex * 2 + 1];
  }
  const properties = inlineProperties.properties.map((property) => {
    const values2 = property.values;
    const newValues = new values2.constructor(length2);
    for (let i = 0; i < length2; ++i) {
      newValues[i] = values2[permutation[i]];
    }
    return _Object$assign(_Object$assign({}, property), { values: newValues });
  });
  return { ids: newIds, properties };
}
function remapStringProperty(property, numMerged, toMerged) {
  const values2 = new Array(numMerged);
  values2.fill("");
  remapArray(property.values, values2, toMerged);
  return _Object$assign(_Object$assign({}, property), { values: values2 });
}
function remapNumericalProperty(property, numMerged, toMerged) {
  const values2 = new Float32Array(numMerged);
  values2.fill(Number.NaN);
  remapArray(property.values, values2, toMerged);
  return _Object$assign(_Object$assign({}, property), { values: values2 });
}
function remapProperty(property, numMerged, toMerged) {
  const type = property.type;
  if (type === "label" || type === "description" || type === "string" || type === "tags") {
    return remapStringProperty(property, numMerged, toMerged);
  }
  return remapNumericalProperty(property, numMerged, toMerged);
}
function mergeInlinePropertyMaps(a, b) {
  if (a === void 0) return b;
  if (b === void 0) return a;
  let numUnique = 0;
  const aCount = a.ids.length / 2;
  const bCount = b.ids.length / 2;
  const aToMerged = new Uint32Array(aCount), bToMerged = new Uint32Array(bCount);
  const aIds = a.ids, bIds = b.ids;
  mergeSequences(aCount, bCount, (a2, b2) => {
    const aHigh = aIds[2 * a2 + 1];
    const aLow = aIds[2 * a2];
    const bHigh = bIds[2 * b2 + 1];
    const bLow = bIds[2 * b2];
    return aHigh - bHigh || aLow - bLow;
  }, (a2) => {
    aToMerged[a2] = numUnique;
    ++numUnique;
  }, (b2) => {
    bToMerged[b2] = numUnique;
    ++numUnique;
  }, (a2, b2) => {
    aToMerged[a2] = numUnique;
    bToMerged[b2] = numUnique;
    ++numUnique;
  });
  let ids;
  if (numUnique === aCount) {
    ids = aIds;
  } else if (numUnique === bCount) {
    ids = bIds;
  } else {
    ids = new Uint32Array(numUnique * 2);
    for (let a2 = 0; a2 < aCount; ++a2) {
      const i = aToMerged[a2];
      ids[2 * i] = aIds[2 * a2];
      ids[2 * i + 1] = aIds[2 * a2 + 1];
    }
    for (let b2 = 0; b2 < bCount; ++b2) {
      const i = bToMerged[b2];
      ids[2 * i] = bIds[2 * b2];
      ids[2 * i + 1] = bIds[2 * b2 + 1];
    }
  }
  const properties = [];
  if (numUnique === aCount) {
    properties.push(...a.properties);
  } else {
    for (const property of a.properties) {
      properties.push(remapProperty(property, numUnique, aToMerged));
    }
  }
  if (numUnique === bCount) {
    properties.push(...b.properties);
  } else {
    for (const property of b.properties) {
      properties.push(remapProperty(property, numUnique, bToMerged));
    }
  }
  return { ids, properties };
}
function mergePropertyMaps(a, b) {
  return new SegmentPropertyMap({
    inlineProperties: mergeInlinePropertyMaps(a.inlineProperties, b.inlineProperties)
  });
}
function mergeSegmentPropertyMaps(maps) {
  while (true) {
    if (maps.length === 0) return void 0;
    if (maps.length === 1) return maps[0];
    const merged = [];
    for (let i = 0, length2 = maps.length; i < length2; i += 2) {
      if (i + 1 === length2) {
        merged.push(maps[i]);
      } else {
        merged.push(mergePropertyMaps(maps[i], maps[i + 1]));
      }
    }
    maps = merged;
  }
}
function getPreprocessedSegmentPropertyMap(chunkManager, maps) {
  return chunkManager.memoize.getUncounted({ id: "getPreprocessedSegmentPropertyMap", maps: maps.map((m) => getObjectId(m)) }, () => {
    const merged = mergeSegmentPropertyMaps(maps);
    if (merged === void 0) return void 0;
    return new PreprocessedSegmentPropertyMap(merged);
  });
}
const idPattern = /^[,\s]*[0-9]+(?:[,\s]+[0-9]+)*[,\s]*$/;
function parseSegmentQuery(db, queryString) {
  var _a;
  if (queryString.match(idPattern) !== null) {
    const parts = queryString.split(/[\s,]+/);
    const ids = [];
    const idSet = new _Set();
    for (let i = 0, n = parts.length; i < n; ++i) {
      const part = parts[i];
      if (part === "") continue;
      const id = new Uint64();
      if (!id.tryParseString(part)) {
        continue;
      }
      const idString = id.toString();
      if (idSet.has(idString)) continue;
      idSet.add(idString);
      ids.push(id);
    }
    ids.sort(Uint64.compare);
    return { ids };
  }
  const parsed = {
    regexp: void 0,
    prefix: void 0,
    includeTags: [],
    excludeTags: [],
    numericalConstraints: [],
    sortBy: [],
    includeColumns: []
  };
  const properties = (_a = db === null || db === void 0 ? void 0 : db.segmentPropertyMap.inlineProperties) === null || _a === void 0 ? void 0 : _a.properties;
  const tags = db === null || db === void 0 ? void 0 : db.tags;
  const tagNames = (tags === null || tags === void 0 ? void 0 : tags.tags) || [];
  const lowerCaseTags = tagNames.map((x) => x.toLowerCase());
  const labels = db === null || db === void 0 ? void 0 : db.labels;
  const errors = [];
  let nextStartIndex;
  for (let startIndex = 0; startIndex < queryString.length; startIndex = nextStartIndex) {
    let endIndex = queryString.indexOf(" ", startIndex);
    let word;
    if (endIndex === -1) {
      nextStartIndex = endIndex = queryString.length;
    } else {
      nextStartIndex = endIndex + 1;
    }
    word = queryString.substring(startIndex, endIndex);
    if (word.length === 0) continue;
    const checkTag = (tag, begin) => {
      const lowerCaseTag = tag.toLowerCase();
      const tagIndex = lowerCaseTags.indexOf(lowerCaseTag);
      if (tagIndex === -1) {
        errors.push({ begin, end: endIndex, message: `Invalid tag: ${tag}` });
        return void 0;
      }
      tag = tagNames[tagIndex];
      if (parsed.includeTags.includes(tag) || parsed.excludeTags.includes(tag)) {
        errors.push({ begin, end: endIndex, message: `Duplicate tag: ${tag}` });
        return void 0;
      }
      return tag;
    };
    if (word.startsWith("#")) {
      const tag = checkTag(word.substring(1), startIndex + 1);
      if (tag !== void 0) {
        parsed.includeTags.push(tag);
      }
      continue;
    }
    if (word.startsWith("-#")) {
      const tag = checkTag(word.substring(2), startIndex + 2);
      if (tag !== void 0) {
        parsed.excludeTags.push(tag);
      }
      continue;
    }
    if (word.startsWith("<") || word.startsWith(">")) {
      let fieldId = word.substring(1).toLowerCase();
      if (fieldId !== "id" && fieldId !== "label") {
        const property = properties === null || properties === void 0 ? void 0 : properties.find((p) => p.id.toLowerCase() === fieldId && (p.type === "number" || p.type === "label" || p.type === "string"));
        if (property === void 0) {
          errors.push({ begin: startIndex + 1, end: endIndex, message: `Invalid field: ${fieldId}` });
          continue;
        }
        fieldId = property.id;
      }
      if (parsed.sortBy.find((x) => x.fieldId === fieldId) !== void 0) {
        errors.push({ begin: startIndex + 1, end: endIndex, message: `Duplicate sort field: ${fieldId}` });
        continue;
      }
      parsed.sortBy.push({ order: word[0], fieldId });
      continue;
    }
    if (word.startsWith("|")) {
      let fieldId = word.substring(1).toLowerCase();
      if (fieldId === "id" || fieldId === "label") continue;
      const property = properties === null || properties === void 0 ? void 0 : properties.find((p) => p.id.toLowerCase() === fieldId && (p.type === "number" || p.type === "string"));
      if (property === void 0) {
        errors.push({ begin: startIndex + 1, end: endIndex, message: `Invalid field: ${fieldId}` });
        continue;
      }
      fieldId = property.id;
      if (parsed.sortBy.find((x) => x.fieldId === fieldId) || parsed.includeColumns.find((x) => x === fieldId)) {
        continue;
      }
      parsed.includeColumns.push(fieldId);
      continue;
    }
    if (word.startsWith("/")) {
      if (parsed.regexp !== void 0) {
        errors.push({ begin: startIndex, end: endIndex, message: "Only one regular expression allowed" });
        continue;
      }
      if (parsed.prefix !== void 0) {
        errors.push({
          begin: startIndex,
          end: endIndex,
          message: "Prefix cannot be combined with regular expression"
        });
        continue;
      }
      if (labels === void 0) {
        errors.push({ begin: startIndex, end: endIndex, message: "No label property" });
        continue;
      }
      try {
        parsed.regexp = new RegExp(word.substring(1));
      } catch (e) {
        errors.push({ begin: startIndex, end: endIndex, message: "Invalid regular expression syntax" });
      }
      continue;
    }
    const constraintMatch = word.match(/^([a-zA-Z][a-zA-Z0-9_]*)(<|<=|=|>=|>)([0-9.].*)$/);
    if (constraintMatch !== null) {
      let fieldId = constraintMatch[1].toLowerCase();
      const op = constraintMatch[2];
      const property = db === null || db === void 0 ? void 0 : db.numericalProperties.find((p) => p.id.toLowerCase() === fieldId);
      if (property === void 0) {
        errors.push({
          begin: startIndex,
          end: startIndex + fieldId.length,
          message: `Invalid numerical field: ${fieldId}`
        });
        continue;
      }
      fieldId = property.id;
      let value;
      try {
        value = parseDataTypeValue(property.dataType, constraintMatch[3]);
      } catch (e) {
        errors.push({
          begin: startIndex + constraintMatch[1].length + constraintMatch[2].length,
          end: endIndex,
          message: e.message
        });
        continue;
      }
      let constraint = parsed.numericalConstraints.find((c) => c.fieldId === fieldId);
      if (constraint === void 0) {
        constraint = { fieldId, bounds: property.bounds };
        parsed.numericalConstraints.push(constraint);
      }
      const origMin = clampToInterval(property.bounds, constraint.bounds[0]), origMax = clampToInterval(property.bounds, constraint.bounds[1]);
      let newMax = origMax, newMin = origMin;
      switch (op) {
        case "<":
          newMax = dataTypeValueNextAfter(property.dataType, value, -1);
          break;
        case "<=":
          newMax = value;
          break;
        case "=":
          newMax = newMin = value;
          break;
        case ">=":
          newMin = value;
          break;
        case ">":
          newMin = dataTypeValueNextAfter(property.dataType, value, 1);
          break;
      }
      newMin = dataTypeCompare(origMin, newMin) > 0 ? origMin : newMin;
      newMax = dataTypeCompare(origMax, newMax) < 0 ? origMax : newMax;
      if (dataTypeCompare(newMin, newMax) > 0) {
        errors.push({ begin: startIndex, end: endIndex, message: "Constraint would not match any values" });
        continue;
      }
      constraint.bounds = [newMin, newMax];
      continue;
    }
    if (parsed.regexp !== void 0) {
      errors.push({
        begin: startIndex,
        end: endIndex,
        message: "Prefix cannot be combined with regular expression"
      });
      continue;
    }
    if (labels === void 0) {
      errors.push({ begin: startIndex, end: endIndex, message: "No label property" });
      continue;
    }
    if (parsed.prefix !== void 0) {
      parsed.prefix += ` ${word}`;
    } else {
      parsed.prefix = word;
    }
  }
  if (errors.length > 0) {
    return { errors };
  }
  if (parsed.sortBy.length === 0) {
    parsed.sortBy.push({ fieldId: getDefaultSortField(db), order: "<" });
  }
  return parsed;
}
function regexpEscapeCharCode(code) {
  return "\\u" + code.toString(16).padStart(4, "0");
}
function executeSegmentQuery(db, query) {
  var _a;
  if (query.errors !== void 0) {
    return { query, total: -1, count: 0, errors: query.errors };
  }
  if (query.ids !== void 0) {
    const ids = query.ids;
    return { query, total: -1, explicitIds: ids, count: ids.length };
  }
  const inlineProperties = (_a = db === null || db === void 0 ? void 0 : db.segmentPropertyMap) === null || _a === void 0 ? void 0 : _a.inlineProperties;
  if (inlineProperties === void 0) {
    return {
      query,
      count: 0,
      total: -1
    };
  }
  const properties = inlineProperties === null || inlineProperties === void 0 ? void 0 : inlineProperties.properties;
  const totalIds = inlineProperties.ids.length / 2;
  let indices = makeIndicesArray(totalIds, totalIds);
  for (let i = 0; i < totalIds; ++i) {
    indices[i] = i;
  }
  const filterIndices = (predicate) => {
    let length2 = indices.length;
    let outIndex = 0;
    for (let i = 0; i < length2; ++i) {
      const index2 = indices[i];
      if (predicate(index2)) {
        indices[outIndex] = index2;
        ++outIndex;
      }
    }
    indices = indices.subarray(0, outIndex);
  };
  if (query.regexp !== void 0 || query.prefix !== void 0) {
    const values2 = db.labels.values;
    const regexp = query.regexp, prefix = query.prefix;
    if (regexp !== void 0) {
      filterIndices((index2) => values2[index2].match(regexp) !== null);
    }
    if (prefix !== void 0) {
      filterIndices((index2) => values2[index2].startsWith(prefix));
    }
  }
  const includeTags = query.includeTags, excludeTags = query.excludeTags;
  const tagsProperty = db.tags;
  if (includeTags.length > 0 || excludeTags.length > 0) {
    const values2 = tagsProperty.values, tags = tagsProperty.tags;
    const allTags = [];
    for (const tag of includeTags) {
      allTags.push([tags.indexOf(tag), 1]);
    }
    for (const tag of excludeTags) {
      allTags.push([tags.indexOf(tag), 0]);
    }
    allTags.sort((a, b) => a[0] - b[0]);
    let pattern = "^";
    let prevTagIndex = 0;
    const addSkipPattern = (endCode) => {
      if (endCode < prevTagIndex) return;
      pattern += `[${regexpEscapeCharCode(prevTagIndex)}-${regexpEscapeCharCode(endCode)}]*`;
    };
    for (const _ref of allTags) {
      var _ref2 = _slicedToArray(_ref, 2);
      const tagIndex = _ref2[0];
      const sign2 = _ref2[1];
      addSkipPattern(tagIndex - 1);
      if (sign2) {
        pattern += regexpEscapeCharCode(tagIndex);
      }
      prevTagIndex = tagIndex + 1;
    }
    addSkipPattern(65535);
    pattern += "$";
    const regexp = new RegExp(pattern);
    filterIndices((index2) => values2[index2].match(regexp) !== null);
  }
  let intermediateIndicesMask;
  let intermediateIndices;
  const numericalConstraints = query.numericalConstraints;
  if (numericalConstraints.length > 0) {
    const numericalProperties = db.numericalProperties;
    const numNumericalConstraints = numericalConstraints.length;
    const fullMask = 2 ** numNumericalConstraints - 1;
    intermediateIndicesMask = makeIndicesArray(indices.length, fullMask);
    for (let constraintIndex = 0; constraintIndex < numNumericalConstraints; ++constraintIndex) {
      const constraint = numericalConstraints[constraintIndex];
      const property = numericalProperties.find((p) => p.id === constraint.fieldId);
      const values2 = property.values;
      const bit = 2 ** constraintIndex;
      var _constraint$bounds = _slicedToArray(constraint.bounds, 2);
      const min2 = _constraint$bounds[0], max = _constraint$bounds[1];
      for (let i = 0, n = indices.length; i < n; ++i) {
        const value = values2[indices[i]];
        intermediateIndicesMask[i] |= bit * (value >= min2 && value <= max);
      }
    }
    intermediateIndices = indices;
    indices = intermediateIndices.slice();
    let length2 = indices.length;
    let outIndex = 0;
    for (let i = 0; i < length2; ++i) {
      if (intermediateIndicesMask[i] === fullMask) {
        indices[outIndex] = indices[i];
        ++outIndex;
      }
    }
    indices = indices.subarray(0, outIndex);
  }
  let tagStatistics = [];
  if (tagsProperty !== void 0) {
    const tagStatisticsInQuery = [];
    const tags = tagsProperty.tags, values2 = tagsProperty.values;
    const tagCounts = new Uint32Array(tags.length);
    for (let i = 0, n = indices.length; i < n; ++i) {
      const value = values2[indices[i]];
      for (let j = 0, m = value.length; j < m; ++j) {
        ++tagCounts[value.charCodeAt(j)];
      }
    }
    for (let tagIndex = 0, numTags = tags.length; tagIndex < numTags; ++tagIndex) {
      const count = tagCounts[tagIndex];
      const tag = tags[tagIndex];
      const tagCount = { tag, tagIndex, count: tagCounts[tagIndex] };
      if (query.includeTags.includes(tag) || query.excludeTags.includes(tag)) {
        tagStatisticsInQuery.push(tagCount);
      } else if (count > 0) {
        tagStatistics.push(tagCount);
      }
    }
    tagStatisticsInQuery.push(...tagStatistics);
    tagStatistics = tagStatisticsInQuery;
  }
  const sortByProperty = (property, orderCoeff) => {
    if (property.type !== "number") {
      const values2 = property.values;
      indices.sort((a, b) => defaultStringCompare(values2[a], values2[b]) * orderCoeff);
    } else {
      const values2 = property.values;
      indices.sort((a, b) => (values2[a] - values2[b]) * orderCoeff);
    }
  };
  const sortByLabel = (orderCoeff) => {
    if (tagsProperty !== void 0) {
      sortByProperty(tagsProperty, orderCoeff);
    }
    const labelsProperty = db === null || db === void 0 ? void 0 : db.labels;
    if (labelsProperty !== void 0) {
      sortByProperty(labelsProperty, orderCoeff);
    }
  };
  const sortBy = query.sortBy;
  for (let i = sortBy.length - 1; i >= 0; --i) {
    var _sortBy$i = sortBy[i];
    const fieldId = _sortBy$i.fieldId, order = _sortBy$i.order;
    const orderCoeff = order === "<" ? 1 : -1;
    if (fieldId === "id") {
      if (i + 1 === sortBy.length) {
        if (order === "<") {
          continue;
        } else {
          indices.reverse();
          continue;
        }
      }
      indices.sort((a, b) => orderCoeff * (a - b));
      continue;
    } else if (fieldId === "label") {
      sortByLabel(orderCoeff);
    } else {
      sortByProperty(properties.find((p) => p.id === fieldId), orderCoeff);
    }
  }
  return {
    query,
    intermediateIndices,
    intermediateIndicesMask,
    indices,
    tags: tagStatistics,
    count: indices.length,
    total: totalIds
  };
}
function updatePropertyHistogram(queryResult, property, bounds) {
  const numBins = 256;
  const values2 = property.values;
  var _bounds = _slicedToArray(bounds, 2);
  const min2 = _bounds[0], max = _bounds[1];
  const multiplier = max <= min2 ? 0 : numBins / (max - min2);
  const histogram = new Uint32Array(numBins + 2);
  const numericalConstraints = queryResult.query.numericalConstraints;
  const constraintIndex = numericalConstraints.findIndex((c) => c.fieldId === property.id);
  if (constraintIndex === -1) {
    const indices = queryResult.indices;
    for (let i = 0, n = indices.length; i < n; ++i) {
      const value = values2[indices[i]];
      if (!isNaN(value)) {
        ++histogram[Math.min(numBins - 1, Math.max(-1, (value - min2) * multiplier)) + 1 >>> 0];
      }
    }
  } else {
    const intermediateIndices = queryResult.intermediateIndices;
    const intermediateIndicesMask = queryResult.intermediateIndicesMask;
    const requiredBits = 2 ** numericalConstraints.length - 1 - 2 ** constraintIndex;
    for (let i = 0, n = intermediateIndices.length; i < n; ++i) {
      const mask = intermediateIndicesMask[i];
      if ((mask & requiredBits) == requiredBits) {
        const value = values2[intermediateIndices[i]];
        if (!isNaN(value)) {
          ++histogram[Math.min(numBins - 1, Math.max(-1, (value - min2) * multiplier)) + 1 >>> 0];
        }
      }
    }
  }
  return { queryResult, histogram, window: bounds };
}
function updatePropertyHistograms(db, queryResult, propertyHistograms, bounds) {
  if (db === void 0) {
    propertyHistograms.length = 0;
    bounds.length = 0;
    return;
  }
  const numericalProperties = db.numericalProperties;
  const numProperties = numericalProperties.length;
  const indices = queryResult === null || queryResult === void 0 ? void 0 : queryResult.indices;
  if (indices === void 0) {
    propertyHistograms.length = 0;
    return;
  }
  for (let i = 0; i < numProperties; ++i) {
    const propertyHistogram = propertyHistograms[i];
    const propertyBounds = bounds[i];
    const property = numericalProperties[i];
    if (propertyHistogram !== void 0 && propertyHistogram.queryResult === queryResult && dataTypeIntervalEqual(property.dataType, propertyHistogram.window, propertyBounds)) {
      continue;
    }
    propertyHistograms[i] = updatePropertyHistogram(queryResult, property, propertyBounds);
  }
}
function getDefaultSortField(db) {
  return (db === null || db === void 0 ? void 0 : db.tags) || (db === null || db === void 0 ? void 0 : db.labels) ? "label" : "id";
}
function unparseSegmentQuery(db, query) {
  var _query = query;
  const ids = _query.ids;
  if (ids !== void 0) {
    return ids.map((x) => x.toString()).join(", ");
  }
  let queryString = "";
  query = query;
  var _query2 = query;
  const prefix = _query2.prefix, regexp = _query2.regexp;
  if (prefix !== void 0) {
    queryString = prefix;
  } else if (regexp !== void 0) {
    queryString = `/${regexp}`;
  }
  for (const tag of query.includeTags) {
    if (queryString.length > 0) queryString += " ";
    queryString += `#${tag}`;
  }
  for (const tag of query.excludeTags) {
    if (queryString.length > 0) queryString += " ";
    queryString += `-#${tag}`;
  }
  for (const constraint of query.numericalConstraints) {
    const fieldId = constraint.fieldId, bounds = constraint.bounds;
    var _bounds2 = _slicedToArray(bounds, 2);
    const min2 = _bounds2[0], max = _bounds2[1];
    const property = db.numericalProperties.find((p) => p.id === fieldId);
    if (dataTypeIntervalEqual(property.dataType, property.bounds, bounds)) {
      continue;
    }
    if (dataTypeCompare(min2, max) === 0) {
      if (queryString.length > 0) queryString += " ";
      queryString += `${fieldId}=${min2}`;
      continue;
    }
    if (dataTypeCompare(min2, property.bounds[0]) > 0) {
      if (queryString.length > 0) queryString += " ";
      const beforeMin = dataTypeValueNextAfter(property.dataType, min2, -1);
      const minString = min2.toString();
      const beforeMinString = beforeMin.toString();
      if (property.dataType !== DataType.FLOAT32 || minString.length <= beforeMinString.length) {
        queryString += `${fieldId}>=${minString}`;
      } else {
        queryString += `${fieldId}>${beforeMinString}`;
      }
    }
    if (dataTypeCompare(max, property.bounds[1]) < 0) {
      if (queryString.length > 0) queryString += " ";
      const afterMax = dataTypeValueNextAfter(property.dataType, max, 1);
      const maxString = max.toString();
      const afterMaxString = afterMax.toString();
      if (property.dataType !== DataType.FLOAT32 || maxString.length <= afterMaxString.length) {
        queryString += `${fieldId}<=${maxString}`;
      } else {
        queryString += `${fieldId}<${afterMaxString}`;
      }
    }
  }
  var _query3 = query;
  let sortBy = _query3.sortBy;
  if (sortBy.length === 1) {
    const s = sortBy[0];
    if (s.order === "<" && s.fieldId === getDefaultSortField(db)) {
      sortBy = [];
    }
  }
  for (const s of sortBy) {
    if (queryString.length > 0) queryString += " ";
    queryString += `${s.order}${s.fieldId}`;
  }
  for (const fieldId of query.includeColumns) {
    if (queryString.length > 0) queryString += " ";
    queryString += `|${fieldId}`;
  }
  return queryString;
}
const tempUint64$1 = new Uint64();
function forEachQueryResultSegmentId(db, queryResult, callback) {
  if (queryResult === void 0) return;
  const explicitIds = queryResult.explicitIds;
  if (explicitIds !== void 0) {
    explicitIds.forEach(callback);
    return;
  }
  const indices = queryResult.indices;
  if (indices !== void 0) {
    var _ref3 = db === null || db === void 0 ? void 0 : db.segmentPropertyMap.inlineProperties;
    const ids = _ref3.ids;
    for (let i = 0, count = indices.length; i < count; ++i) {
      const propIndex = indices[i];
      tempUint64$1.low = ids[propIndex * 2];
      tempUint64$1.high = ids[propIndex * 2 + 1];
      callback(tempUint64$1, i);
    }
  }
}
function findQueryResultIntersectionSize(db, queryResult, segmentSet) {
  if (segmentSet.size === 0) return 0;
  let count = 0;
  forEachQueryResultSegmentId(db, queryResult, (id) => {
    if (segmentSet.has(id)) ++count;
  });
  return count;
}
function changeTagConstraintInSegmentQuery(query, tag, include, value) {
  const includeTags = query.includeTags.filter((x) => x !== tag);
  const excludeTags = query.excludeTags.filter((x) => x !== tag);
  if (value === true) {
    (include ? includeTags : excludeTags).push(tag);
  }
  return _Object$assign(_Object$assign({}, query), { includeTags, excludeTags });
}
function isQueryUnconstrained(query) {
  if (query.ids !== void 0) return false;
  if (query.errors !== void 0) return true;
  if (query.numericalConstraints.length > 0) return false;
  if (query.includeTags.length > 0) return false;
  if (query.excludeTags.length > 0) return false;
  if (query.prefix) return false;
  if (query.regexp) return false;
  return true;
}
function queryIncludesColumn(query, fieldId) {
  if (query === void 0) return false;
  if (query.ids !== void 0) return false;
  if (query.errors !== void 0) return false;
  const sortBy = query.sortBy, includeColumns = query.includeColumns;
  return sortBy.find((x) => x.fieldId === fieldId) !== void 0 || includeColumns.includes(fieldId);
}
const rankSymbol = _Symbol("disjoint_sets:rank");
const parentSymbol = _Symbol("disjoint_sets:parent");
const nextSymbol = _Symbol("disjoint_sets:next");
const prevSymbol = _Symbol("disjoint_sets:prev");
function findRepresentative(v) {
  let old = v;
  let ancestor = v[parentSymbol];
  while (ancestor !== v) {
    v = ancestor;
    ancestor = v[parentSymbol];
  }
  v = old[parentSymbol];
  while (ancestor !== v) {
    old[parentSymbol] = ancestor;
    old = v;
    v = old[parentSymbol];
  }
  return ancestor;
}
function linkUnequalSetRepresentatives(i, j) {
  let iRank = i[rankSymbol];
  let jRank = j[rankSymbol];
  if (iRank > jRank) {
    j[parentSymbol] = i;
    return i;
  }
  i[parentSymbol] = j;
  if (iRank === jRank) {
    j[rankSymbol] = jRank + 1;
  }
  return j;
}
function spliceCircularLists(i, j) {
  let iPrev = i[prevSymbol];
  let jPrev = j[prevSymbol];
  j[prevSymbol] = iPrev;
  iPrev[nextSymbol] = j;
  i[prevSymbol] = jPrev;
  jPrev[nextSymbol] = i;
}
function* setElementIterator(i) {
  let j = i;
  do {
    yield j;
    j = j[nextSymbol];
  } while (j !== i);
}
function initializeElement(v) {
  v[parentSymbol] = v;
  v[rankSymbol] = 0;
  v[nextSymbol] = v[prevSymbol] = v;
}
const minSymbol = _Symbol("disjoint_sets:min");
function isRootElement(v) {
  return v[parentSymbol] === v;
}
class DisjointUint64Sets {
  constructor() {
    this.map = new _Map();
    this.visibleSegmentEquivalencePolicy = new WatchableValue(VisibleSegmentEquivalencePolicy.MIN_REPRESENTATIVE);
    this.generation = 0;
  }
  has(x) {
    let key = x.toString();
    let element = this.map.get(key);
    return element !== void 0;
  }
  get(x) {
    let key = x.toString();
    let element = this.map.get(key);
    if (element === void 0) {
      return x;
    }
    return findRepresentative(element)[minSymbol];
  }
  isMinElement(x) {
    let y = this.get(x);
    return y === x || Uint64.equal(y, x);
  }
  makeSet(x) {
    let key = x.toString();
    let map2 = this.map;
    let element = map2.get(key);
    if (element === void 0) {
      element = x.clone();
      initializeElement(element);
      element[minSymbol] = element;
      map2.set(key, element);
      return element;
    }
    return findRepresentative(element);
  }
  /**
   * Union the sets containing `a` and `b`.
   * @returns `false` if `a` and `b` are already in the same set, otherwise `true`.
   */
  link(a, b) {
    a = this.makeSet(a);
    b = this.makeSet(b);
    if (a === b) {
      return false;
    }
    this.generation++;
    let newNode = linkUnequalSetRepresentatives(a, b);
    spliceCircularLists(a, b);
    let aMin = a[minSymbol];
    let bMin = b[minSymbol];
    const isMax = (this.visibleSegmentEquivalencePolicy.value & VisibleSegmentEquivalencePolicy.MAX_REPRESENTATIVE) !== 0;
    newNode[minSymbol] = Uint64.less(aMin, bMin) === isMax ? bMin : aMin;
    return true;
  }
  linkAll(ids) {
    for (let i = 1, length2 = ids.length; i < length2; ++i) {
      this.link(ids[0], ids[i]);
    }
  }
  /**
   * Unlinks all members of the specified set.
   */
  deleteSet(x) {
    const map2 = this.map;
    let changed = false;
    for (const y of this.setElements(x)) {
      map2.delete(y.toString());
      changed = true;
    }
    return changed;
  }
  *setElements(a) {
    let key = a.toString();
    let element = this.map.get(key);
    if (element === void 0) {
      yield a;
    } else {
      yield* setElementIterator(element);
    }
  }
  clear() {
    let map2 = this.map;
    if (map2.size === 0) {
      return false;
    }
    ++this.generation;
    map2.clear();
    return true;
  }
  get size() {
    return this.map.size;
  }
  *mappings(temp = new Array(2)) {
    for (let element of this.map.values()) {
      temp[0] = element;
      temp[1] = findRepresentative(element)[minSymbol];
      yield temp;
    }
  }
  *roots() {
    for (let element of this.map.values()) {
      if (isRootElement(element)) {
        yield element;
      }
    }
  }
  [_Symbol$iterator]() {
    return this.mappings();
  }
  /**
   * Returns an array of arrays of strings, where the arrays contained in the outer array correspond
   * to the disjoint sets, and the strings are the base-10 string representations of the members of
   * each set.  The members are sorted in numerical order, and the sets are sorted in numerical
   * order of their smallest elements.
   */
  toJSON() {
    let sets = new Array();
    for (let element of this.map.values()) {
      if (isRootElement(element)) {
        let members = new Array();
        for (let member of setElementIterator(element)) {
          members.push(member);
        }
        members.sort(Uint64.compare);
        sets.push(members);
      }
    }
    sets.sort((a, b) => Uint64.compare(a[0], b[0]));
    return sets.map((set2) => set2.map((element) => element.toString()));
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
var SharedDisjointUint64Sets_1;
const RPC_TYPE_ID = "DisjointUint64Sets";
const ADD_METHOD_ID = "DisjointUint64Sets.add";
const CLEAR_METHOD_ID = "DisjointUint64Sets.clear";
const HIGH_BIT_REPRESENTATIVE_CHANGED_ID = "DisjointUint64Sets.highBitRepresentativeChanged";
const DELETE_SET_METHOD_ID = "DisjointUint64Sets.deleteSet";
let SharedDisjointUint64Sets = SharedDisjointUint64Sets_1 = class SharedDisjointUint64Sets2 extends SharedObjectCounterpart {
  constructor() {
    super(...arguments);
    this.disjointSets = new DisjointUint64Sets();
    this.changed = new NullarySignal();
  }
  /**
   * For compatibility with `WatchableValueInterface`.
   */
  get value() {
    return this;
  }
  static makeWithCounterpart(rpc, highBitRepresentative) {
    let obj = new this();
    obj.disjointSets.visibleSegmentEquivalencePolicy = highBitRepresentative;
    obj.registerDisposer(highBitRepresentative.changed.add(() => {
      updateHighBitRepresentative(obj);
    }));
    obj.initializeCounterpart(rpc);
    if (highBitRepresentative.value) {
      updateHighBitRepresentative(obj);
    }
    return obj;
  }
  disposed() {
    this.disjointSets = void 0;
    this.changed = void 0;
    super.disposed();
  }
  link(a, b) {
    if (this.disjointSets.link(a, b)) {
      let rpc = this.rpc;
      if (rpc) {
        rpc.invoke(ADD_METHOD_ID, { "id": this.rpcId, "al": a.low, "ah": a.high, "bl": b.low, "bh": b.high });
      }
      this.changed.dispatch();
      return true;
    }
    return false;
  }
  linkAll(ids) {
    for (let i = 1, length2 = ids.length; i < length2; ++i) {
      this.link(ids[0], ids[i]);
    }
  }
  has(x) {
    return this.disjointSets.has(x);
  }
  get(x) {
    return this.disjointSets.get(x);
  }
  clear() {
    if (this.disjointSets.clear()) {
      let rpc = this.rpc;
      if (rpc) {
        rpc.invoke(CLEAR_METHOD_ID, { "id": this.rpcId });
      }
      this.changed.dispatch();
    }
  }
  setElements(a) {
    return this.disjointSets.setElements(a);
  }
  deleteSet(x) {
    if (this.disjointSets.deleteSet(x)) {
      let rpc = this.rpc;
      if (rpc) {
        rpc.invoke(DELETE_SET_METHOD_ID, { "id": this.rpcId, "l": x.low, "h": x.high });
      }
      this.changed.dispatch();
    }
  }
  get size() {
    return this.disjointSets.size;
  }
  toJSON() {
    return this.disjointSets.toJSON();
  }
  /**
   * Restores the state from a JSON representation.
   */
  restoreState(obj) {
    if (obj !== void 0) {
      let ids = [new Uint64(), new Uint64()];
      parseArray(obj, (z) => {
        parseArray(z, (s, index2) => {
          ids[index2 % 2].parseString(String(s), 10);
          if (index2 !== 0) {
            this.link(ids[0], ids[1]);
          }
        });
      });
    }
  }
  assignFrom(other) {
    this.clear();
    if (other instanceof SharedDisjointUint64Sets_1) {
      other = other.disjointSets;
    }
    for (const _ref of other) {
      var _ref2 = _slicedToArray(_ref, 2);
      const a = _ref2[0];
      const b = _ref2[1];
      this.link(a, b);
    }
  }
};
SharedDisjointUint64Sets = SharedDisjointUint64Sets_1 = __decorate$4([registerSharedObject(RPC_TYPE_ID)], SharedDisjointUint64Sets);
const tempA = new Uint64();
const tempB = new Uint64();
registerRPC(ADD_METHOD_ID, function(x) {
  let obj = this.get(x["id"]);
  tempA.low = x["al"];
  tempA.high = x["ah"];
  tempB.low = x["bl"];
  tempB.high = x["bh"];
  if (obj.disjointSets.link(tempA, tempB)) {
    obj.changed.dispatch();
  }
});
registerRPC(CLEAR_METHOD_ID, function(x) {
  let obj = this.get(x["id"]);
  if (obj.disjointSets.clear()) {
    obj.changed.dispatch();
  }
});
function updateHighBitRepresentative(obj) {
  obj.rpc.invoke(HIGH_BIT_REPRESENTATIVE_CHANGED_ID, { "id": obj.rpcId, "value": obj.disjointSets.visibleSegmentEquivalencePolicy.value });
}
registerRPC(HIGH_BIT_REPRESENTATIVE_CHANGED_ID, function(x) {
  let obj = this.get(x["id"]);
  obj.disjointSets.visibleSegmentEquivalencePolicy.value = x["value"];
});
registerRPC(DELETE_SET_METHOD_ID, function(x) {
  let obj = this.get(x["id"]);
  tempA.low = x["l"];
  tempA.high = x["h"];
  if (obj.disjointSets.deleteSet(tempA)) {
    obj.changed.dispatch();
  }
});
class LocalSegmentationGraphSource extends SegmentationGraphSource {
  constructor() {
    super(...arguments);
    this.spanningTreeEdges = new _Map();
    this.equivalences = new SharedDisjointUint64Sets();
    this.connections = new _Set();
    this.changed = new Signal();
  }
  link(a, b) {
    this.equivalences.link(a, b);
    for (const connection of this.connections) {
      connection.segmentsState.segmentEquivalences.link(a, b);
    }
  }
  linkAll(ids) {
    this.equivalences.linkAll(ids);
    for (const connection of this.connections) {
      connection.segmentsState.segmentEquivalences.linkAll(ids);
    }
  }
  deleteSet(a) {
    this.equivalences.deleteSet(a);
    for (const connection of this.connections) {
      connection.segmentsState.segmentEquivalences.deleteSet(a);
    }
  }
  normalizeAll() {
    for (const connection of this.connections) {
      normalizeSegmentSet(connection.segmentsState.visibleSegments, connection.segmentsState.segmentEquivalences.disjointSets);
    }
  }
  addSpanningTreeEdge(a, b) {
    const aString = a.toString(), bString = b.toString();
    const spanningTreeEdges = this.spanningTreeEdges;
    let aEdges = spanningTreeEdges.get(aString);
    if (aEdges === void 0) {
      aEdges = new _Set();
      spanningTreeEdges.set(aString, aEdges);
    }
    let bEdges = spanningTreeEdges.get(bString);
    if (bEdges === void 0) {
      bEdges = new _Set();
      spanningTreeEdges.set(bString, bEdges);
    }
    aEdges.add(bString);
    bEdges.add(aString);
  }
  removeSpanningTreeEdge(a, b) {
    const aString = a.toString(), bString = b.toString();
    const spanningTreeEdges = this.spanningTreeEdges;
    const aEdges = spanningTreeEdges.get(aString);
    const bEdges = spanningTreeEdges.get(bString);
    aEdges.delete(bString);
    if (aEdges.size === 0) {
      spanningTreeEdges.delete(aString);
    }
    bEdges.delete(aString);
    if (bEdges.size === 0) {
      spanningTreeEdges.delete(bString);
    }
  }
  *getSpanningTreeNeighbors(a) {
    const b = new Uint64();
    const neighbors = this.spanningTreeEdges.get(a.toString());
    if (neighbors === void 0) return;
    for (const neighborString of neighbors) {
      b.parseString(neighborString);
      yield b;
    }
  }
  restoreState(obj) {
    const equivalences = this.equivalences, spanningTreeEdges = this.spanningTreeEdges;
    equivalences.clear();
    spanningTreeEdges.clear();
    if (obj === void 0) {
      return;
    }
    const ids = [new Uint64(), new Uint64()];
    parseArray(obj, (groupObj) => {
      parseArray(groupObj, (s, index2) => {
        ids[index2 % 2].parseString(String(s), 10);
        if (index2 !== 0) {
          if (equivalences.link(ids[0], ids[1])) {
            this.addSpanningTreeEdge(ids[0], ids[1]);
          }
        }
      });
    });
  }
  toJSON() {
    const spanningTreeEdges = this.spanningTreeEdges;
    if (spanningTreeEdges.size === 0) return void 0;
    const sets = new Array();
    for (let _ref of spanningTreeEdges) {
      var _ref2 = _slicedToArray(_ref, 2);
      let idString = _ref2[0];
      let neighbors = _ref2[1];
      const a = Uint64.parseString(idString);
      for (const neighborString of neighbors) {
        const b = Uint64.parseString(neighborString);
        if (Uint64.compare(a, b) > 0) continue;
        sets.push([a, b]);
      }
    }
    sets.sort((a, b) => Uint64.compare(a[0], b[0]) || Uint64.compare(a[1], b[1]));
    return sets.map((set2) => set2.map((element) => element.toString()));
  }
  get visibleSegmentEquivalencePolicy() {
    return VisibleSegmentEquivalencePolicy.MIN_REPRESENTATIVE;
  }
  async merge(a, b) {
    const equivalences = this.equivalences;
    if (Uint64.equal(equivalences.get(a), equivalences.get(b))) {
      return a;
    }
    this.addSpanningTreeEdge(a, b);
    this.link(a, b);
    this.normalizeAll();
    this.changed.dispatch();
    return equivalences.get(a);
  }
  async split(a, b) {
    const result = this.computeSplit(a, b);
    if (result === void 0) {
      throw new Error("Segments are already split");
    }
    const includeBaseSegments = result.includeBaseSegments, includeRepresentative = result.includeRepresentative, excludeBaseSegments = result.excludeBaseSegments, excludeRepresentative = result.excludeRepresentative;
    const equivalences = this.equivalences;
    this.deleteSet(a);
    this.linkAll(includeBaseSegments);
    this.linkAll(excludeBaseSegments);
    const removeSplitEdges = (segments, expectedRoot) => {
      for (const id of segments) {
        for (const neighbor of this.getSpanningTreeNeighbors(id)) {
          if (!Uint64.equal(equivalences.get(neighbor), expectedRoot)) {
            this.removeSpanningTreeEdge(id, neighbor);
          }
        }
      }
    };
    const includeRoot = equivalences.get(a);
    const excludeRoot = equivalences.get(b);
    removeSplitEdges(includeBaseSegments, includeRoot);
    removeSplitEdges(excludeBaseSegments, excludeRoot);
    for (const connection of this.connections) {
      const visibleSegments = connection.segmentsState.visibleSegments;
      if (visibleSegments.has(excludeRepresentative)) {
        visibleSegments.delete(excludeRepresentative);
        visibleSegments.add(includeRepresentative);
      }
    }
    this.normalizeAll();
    this.changed.dispatch();
    return { include: includeRoot, exclude: excludeRoot };
  }
  trackSegment(id, callback) {
    return () => {
    };
  }
  computeSplit(include, exclude) {
    const equivalences = this.equivalences;
    const root = equivalences.get(include);
    if (!Uint64.equal(root, equivalences.get(exclude))) {
      return void 0;
    }
    const ds = new DisjointUint64Sets();
    for (const baseSegment of equivalences.setElements(root)) {
      if (Uint64.equal(baseSegment, exclude)) continue;
      for (const neighbor of this.getSpanningTreeNeighbors(baseSegment)) {
        if (Uint64.equal(neighbor, exclude)) continue;
        ds.link(baseSegment, neighbor);
      }
    }
    const includeSegments = [];
    const excludeSegments = [];
    const includeRoot = ds.get(include);
    let includeRep = include;
    let excludeRep = exclude;
    for (const baseSegment of equivalences.setElements(root)) {
      if (Uint64.equal(ds.get(baseSegment), includeRoot)) {
        includeSegments.push(baseSegment);
        if (Uint64.compare(baseSegment, includeRep) < 0) includeRep = baseSegment;
      } else {
        excludeSegments.push(baseSegment);
        if (Uint64.compare(baseSegment, excludeRep) < 0) excludeRep = baseSegment;
      }
    }
    includeSegments.sort(Uint64.compare);
    excludeSegments.sort(Uint64.compare);
    return {
      includeBaseSegments: includeSegments,
      includeRepresentative: includeRep,
      excludeBaseSegments: excludeSegments,
      excludeRepresentative: excludeRep
    };
  }
  connect(segmentsState) {
    const connection = new LocalSegmentationGraphSourceConnection(this, segmentsState);
    segmentsState.segmentEquivalences.assignFrom(this.equivalences);
    normalizeSegmentSet(segmentsState.visibleSegments, segmentsState.segmentEquivalences.disjointSets);
    connection.registerDisposer(segmentsState.visibleSegments.changed.add(connection.registerCancellable(debounce(() => normalizeSegmentSet(segmentsState.visibleSegments, segmentsState.segmentEquivalences.disjointSets), 0))));
    this.connections.add(connection);
    connection.registerDisposer(() => {
      this.connections.delete(connection);
    });
    return connection;
  }
}
function normalizeSegmentSet(segmentSet, equivalences) {
  const add2 = [];
  for (const id of segmentSet.unsafeKeys()) {
    const rootId = equivalences.get(id);
    if (!Uint64.equal(id, rootId)) {
      add2.push(rootId);
      segmentSet.delete(id);
    }
  }
  for (const id of add2) {
    segmentSet.add(id);
  }
}
class LocalSegmentationGraphSourceConnection extends SegmentationGraphSourceConnection {
  computeSplit(include, exclude) {
    return this.graph.computeSplit(include, exclude);
  }
}
var VolumeType;
(function(VolumeType2) {
  VolumeType2[VolumeType2["UNKNOWN"] = 0] = "UNKNOWN";
  VolumeType2[VolumeType2["IMAGE"] = 1] = "IMAGE";
  VolumeType2[VolumeType2["SEGMENTATION"] = 2] = "SEGMENTATION";
})(VolumeType || (VolumeType = {}));
function makeVolumeChunkSpecification(options) {
  const rank = options.rank, dataType = options.dataType, compressedSegmentationBlockSize = options.compressedSegmentationBlockSize;
  var _options$baseVoxelOff = options.baseVoxelOffset;
  const baseVoxelOffset = _options$baseVoxelOff === void 0 ? new Float32Array(rank) : _options$baseVoxelOff;
  return _Object$assign(_Object$assign({}, makeSliceViewChunkSpecification(options)), {
    compressedSegmentationBlockSize,
    baseVoxelOffset,
    dataType
  });
}
function shouldTranscodeToCompressedSegmentation(options) {
  if (options.compressedSegmentationBlockSize !== void 0) return false;
  if (options.volumeType !== VolumeType.SEGMENTATION && !options.volumeSourceOptions.discreteValues) {
    return false;
  }
  switch (options.dataType) {
    case DataType.UINT32:
    case DataType.UINT64:
      break;
    default:
      return false;
  }
  switch (options.rank) {
    case 3:
      return true;
    case 4: {
      const chunkDataSize = options.chunkDataSize;
      if (chunkDataSize[3] !== 1) return false;
      return true;
    }
    default:
      return false;
  }
}
function makeVolumeChunkSpecificationWithDefaultCompression(options) {
  let rank = options.rank, lowerVoxelBound = options.lowerVoxelBound, upperVoxelBound = options.upperVoxelBound;
  if (!shouldTranscodeToCompressedSegmentation(options)) {
    return makeVolumeChunkSpecification(options);
  }
  var _options$volumeSource = options.volumeSourceOptions;
  let displayRank = _options$volumeSource.displayRank, multiscaleToViewTransform = _options$volumeSource.multiscaleToViewTransform, chunkToMultiscaleTransform = options.chunkToMultiscaleTransform, chunkToViewTransform = options.chunkToViewTransform;
  if (chunkToViewTransform === void 0) {
    chunkToViewTransform = multiply(
      new Float32Array(rank * displayRank),
      displayRank,
      //
      multiscaleToViewTransform,
      displayRank,
      //
      chunkToMultiscaleTransform,
      rank + 1,
      //
      displayRank,
      rank,
      rank
    );
  }
  const maxCompressedSegmentationBlockSize = options.maxCompressedSegmentationBlockSize, chunkDataSize = options.chunkDataSize;
  return makeVolumeChunkSpecification(_Object$assign(_Object$assign({}, options), { compressedSegmentationBlockSize: Float32Array.from(getNearIsotropicBlockSize({
    rank,
    chunkToViewTransform,
    displayRank,
    lowerVoxelBound,
    upperVoxelBound,
    maxVoxelsPerChunkLog2: 9,
    maxBlockSize: maxCompressedSegmentationBlockSize === void 0 ? chunkDataSize : min(new Uint32Array(rank), chunkDataSize, maxCompressedSegmentationBlockSize)
  })) }));
}
function makeDefaultVolumeChunkSpecifications(options) {
  const rank = options.rank;
  var _options$volumeSource2 = options.volumeSourceOptions;
  const displayRank = _options$volumeSource2.displayRank, multiscaleToViewTransform = _options$volumeSource2.multiscaleToViewTransform, modelChannelDimensionIndices = _options$volumeSource2.modelChannelDimensionIndices, chunkToMultiscaleTransform = options.chunkToMultiscaleTransform;
  const chunkToViewTransform = multiply(
    new Float32Array(displayRank * rank),
    displayRank,
    //
    multiscaleToViewTransform,
    displayRank,
    //
    chunkToMultiscaleTransform,
    rank + 1,
    //
    displayRank,
    rank,
    rank
  );
  let minBlockSize = options.minBlockSize;
  if (minBlockSize === void 0) {
    minBlockSize = new Uint32Array(rank);
    minBlockSize.fill(1);
  } else {
    minBlockSize = new Uint32Array(minBlockSize);
  }
  const lowerVoxelBound = options.lowerVoxelBound, upperVoxelBound = options.upperVoxelBound;
  if (modelChannelDimensionIndices.length !== 0) {
    for (const chunkDim of getDependentTransformInputDimensions(chunkToMultiscaleTransform, rank, modelChannelDimensionIndices)) {
      let size = upperVoxelBound[chunkDim];
      if (lowerVoxelBound !== void 0) {
        size -= lowerVoxelBound[chunkDim];
      }
      minBlockSize[chunkDim] = size;
    }
  }
  var _options$chunkDataSiz = options.chunkDataSizes;
  const chunkDataSizes = _options$chunkDataSiz === void 0 ? getChunkDataSizes(_Object$assign(_Object$assign({}, options), {
    minBlockSize,
    chunkToViewTransform,
    displayRank
  })) : _options$chunkDataSiz;
  return chunkDataSizes.map((chunkDataSize) => makeVolumeChunkSpecificationWithDefaultCompression(_Object$assign(_Object$assign({}, options), { chunkDataSize, chunkToViewTransform })));
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tempVec3$1 = create$3();
const tempVec3b = create$3();
const LAMBDA_EPSILON = 1e-3;
const ORTHOGONAL_EPSILON = 1e-3;
function findFrontVertexIndex(planeNormal) {
  let frontVertexIndex = 0;
  for (var axis_i = 0; axis_i < 3; ++axis_i) {
    if (planeNormal[axis_i] < 0) {
      frontVertexIndex += 1 << axis_i;
    }
  }
  return frontVertexIndex;
}
const vertexBasePositions = new Float32Array([0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1]);
const boundingBoxCrossSectionVertexIndices = (() => {
  const vertexUncorrectedToCorrected = [0, 1, 2, 4, 5, 3, 6, 7];
  const vertexCorrectedToUncorrected = [0, 1, 2, 5, 3, 4, 6, 7];
  const vertexBaseIndices = [0, 1, 1, 4, 4, 7, 4, 7, 1, 5, 0, 1, 1, 4, 4, 7, 0, 2, 2, 5, 5, 7, 5, 7, 2, 6, 0, 2, 2, 5, 5, 7, 0, 3, 3, 6, 6, 7, 6, 7, 3, 4, 0, 3, 3, 6, 6, 7];
  const vertexPermutation = [0, 1, 2, 3, 4, 5, 6, 7, 1, 4, 5, 0, 3, 7, 2, 6, 2, 6, 0, 5, 7, 3, 1, 4, 3, 0, 6, 4, 1, 2, 7, 5, 4, 3, 7, 1, 0, 6, 5, 2, 5, 2, 1, 7, 6, 0, 4, 3, 6, 7, 3, 2, 5, 4, 0, 1, 7, 5, 4, 6, 2, 1, 3, 0];
  const vertexIndices = new Int32Array(8 * 8 * 6);
  for (let p = 0; p < 8; ++p) {
    for (let i = 0; i < vertexBaseIndices.length; ++i) {
      const vertexPermutationIndex = vertexCorrectedToUncorrected[p] * 8 + vertexBaseIndices[i];
      vertexIndices[p * 8 * 6 + i] = vertexUncorrectedToCorrected[vertexPermutation[vertexPermutationIndex]];
    }
  }
  return vertexIndices;
})();
function defineBoundingBoxCrossSectionShader(builder) {
  builder.addUniform("highp vec3", "uPlaneNormal");
  builder.addUniform("highp float", "uPlaneDistance");
  builder.addUniform("highp ivec2", "uVertexIndex", 24);
  builder.addUniform("highp vec3", "uVertexBasePosition", 8);
  builder.addInitializer((shader) => {
    shader.gl.uniform3fv(shader.uniform("uVertexBasePosition"), vertexBasePositions);
  });
  builder.addVertexCode(`
vec3 getBoundingBoxPlaneIntersectionVertexPosition(vec3 chunkSize, vec3 boxLower, vec3 lowerClipBound, vec3 upperClipBound, int vertexIndex, float planeDistance) {
  for (int e = 0; e < 4; ++e) {
    highp ivec2 vidx = uVertexIndex[vertexIndex*4 + e];
    highp vec3 v1 = max(lowerClipBound, min(upperClipBound, chunkSize * uVertexBasePosition[vidx.x] + boxLower));
    highp vec3 v2 = max(lowerClipBound, min(upperClipBound, chunkSize * uVertexBasePosition[vidx.y] + boxLower));
    highp vec3 vDir = v2 - v1;
    highp float denom = dot(vDir, uPlaneNormal);
    if (abs(denom) > ${ORTHOGONAL_EPSILON}) {
      highp float lambda = (planeDistance - dot(v1, uPlaneNormal)) / denom;
      if ((lambda >= -${LAMBDA_EPSILON}) && (lambda <= (1.0 + ${LAMBDA_EPSILON}))) {
        lambda = clamp(lambda, 0.0, 1.0);
        highp vec3 position = v1 + lambda * vDir;
        return position;
      }
    }
  }
  return vec3(0, 0, 0);
}
vec3 getBoundingBoxPlaneIntersectionVertexPosition(vec3 chunkSize, vec3 boxLower, vec3 lowerClipBound, vec3 upperClipBound, int vertexIndex) {
  return getBoundingBoxPlaneIntersectionVertexPosition(chunkSize, boxLower, lowerClipBound, upperClipBound, vertexIndex, uPlaneDistance);
}
`);
}
function setBoundingBoxCrossSectionShaderPlane(shader, planeNormal, planeDistanceToOrigin) {
  const gl = shader.gl;
  gl.uniform3fv(shader.uniform("uPlaneNormal"), planeNormal);
  gl.uniform1f(shader.uniform("uPlaneDistance"), planeDistanceToOrigin);
  const frontVertexIndex = findFrontVertexIndex(planeNormal);
  gl.uniform2iv(shader.uniform("uVertexIndex"), boundingBoxCrossSectionVertexIndices.subarray(frontVertexIndex * 48, (frontVertexIndex + 1) * 48));
}
function setBoundingBoxCrossSectionShaderViewportPlane(shader, viewportNormalInGlobalCoordinates, viewportCenterPosition, modelMatrix, invModelMatrix) {
  const localPlaneNormal = transformVectorByMat4Transpose(tempVec3$1, viewportNormalInGlobalCoordinates, modelMatrix);
  normalize$2(localPlaneNormal, localPlaneNormal);
  const planeDistanceToOrigin = dot(transformMat4(tempVec3b, viewportCenterPosition, invModelMatrix), localPlaneNormal);
  setBoundingBoxCrossSectionShaderPlane(shader, localPlaneNormal, planeDistanceToOrigin);
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CHUNK_POSITION_EPSILON = 1e-3;
const tempMat4$3 = create$4();
function defineVolumeShader(builder, wireFrame) {
  defineVertexId(builder);
  defineBoundingBoxCrossSectionShader(builder);
  builder.addUniform("highp vec3", "uTranslation");
  builder.addUniform("highp mat4", "uProjectionMatrix");
  builder.addUniform("highp vec3", "uChunkDataSize");
  builder.addUniform("highp vec3", "uLowerClipBound");
  builder.addUniform("highp vec3", "uUpperClipBound");
  if (wireFrame) {
    defineLineShader(builder);
    builder.setVertexMain(`
int vertexIndex1 = gl_VertexID / ${VERTICES_PER_LINE};
int vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;
vec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex1);
vec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex2);
emitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),
         uProjectionMatrix * vec4(vertexPosition2, 1.0),
         2.0);
`);
    builder.setFragmentMain(`
emit(vec4(1.0, 1.0, 1.0, getLineAlpha()));
`);
    return;
  }
  builder.addVarying("highp vec3", "vChunkPosition");
  builder.setVertexMain(`
vec3 position = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, gl_VertexID);
gl_Position = uProjectionMatrix * vec4(position, 1.0);
gl_Position.z = 0.0;
vChunkPosition = (position - uTranslation) +
    ${CHUNK_POSITION_EPSILON} * abs(uPlaneNormal);
`);
}
function initializeShader(shader, projectionParameters, wireFrame) {
  if (wireFrame) {
    initializeLineShader(
      shader,
      projectionParameters,
      /*featherWidthInPixels=*/
      1
    );
  }
}
function beginSource(gl, shader, sliceView, dataToDeviceMatrix, tsource, chunkLayout) {
  const projectionParameters = sliceView.projectionParameters.value;
  const centerDataPosition = projectionParameters.centerDataPosition;
  setBoundingBoxCrossSectionShaderViewportPlane(shader, projectionParameters.viewportNormalInGlobalCoordinates, centerDataPosition, chunkLayout.transform, chunkLayout.invTransform);
  gl.uniformMatrix4fv(shader.uniform("uProjectionMatrix"), false, multiply$3(tempMat4$3, dataToDeviceMatrix, chunkLayout.transform));
  gl.uniform3fv(shader.uniform("uLowerClipBound"), tsource.lowerClipDisplayBound);
  gl.uniform3fv(shader.uniform("uUpperClipBound"), tsource.upperClipDisplayBound);
}
function setupChunkDataSize(gl, shader, chunkDataSize) {
  gl.uniform3fv(shader.uniform("uChunkDataSize"), chunkDataSize);
}
function drawChunk(gl, shader, chunkPosition, wireFrame) {
  gl.uniform3fv(shader.uniform("uTranslation"), chunkPosition);
  if (wireFrame) {
    drawLines(shader.gl, 6, 1);
  } else {
    gl.drawArrays(gl.TRIANGLE_FAN, 0, 6);
  }
}
function medianOf3(a, b, c) {
  return a > b ? c > a ? a : b > c ? b : c : c > b ? b : a > c ? a : c;
}
class SliceViewVolumeRenderLayer extends SliceViewRenderLayer {
  constructor(multiscaleSource, options) {
    var _options$shaderError = options.shaderError;
    const shaderError = _options$shaderError === void 0 ? makeWatchableShaderError() : _options$shaderError, shaderParameters = options.shaderParameters;
    super(multiscaleSource.chunkManager, multiscaleSource, options);
    const gl = this.gl;
    this.vertexIdHelper = this.registerDisposer(VertexIdHelper.get(gl));
    this.shaderParameters = shaderParameters;
    const channelCoordinateSpace = options.channelCoordinateSpace;
    this.channelCoordinateSpace = channelCoordinateSpace === void 0 ? constantWatchableValue(emptyInvalidCoordinateSpace) : channelCoordinateSpace;
    this.registerDisposer(shaderParameters.changed.add(this.redrawNeeded.dispatch));
    const extraParameters = this.registerDisposer(makeCachedDerivedWatchableValue((space, dataHistogramChannelSpecifications) => ({ numChannelDimensions: space.rank, dataHistogramChannelSpecifications }), [this.channelCoordinateSpace, this.dataHistogramSpecifications.channels]));
    this.shaderGetter = parameterizedContextDependentShaderGetter(this, gl, {
      memoizeKey: `volume/RenderLayer:${getObjectId(this.constructor)}`,
      fallbackParameters: options.fallbackShaderParameters,
      parameters: shaderParameters,
      encodeParameters: options.encodeShaderParameters,
      shaderError,
      extraParameters,
      defineShader: (builder, context, parameters, extraParameters2) => {
        const chunkFormat = context.chunkFormat, dataHistogramsEnabled = context.dataHistogramsEnabled;
        const dataHistogramChannelSpecifications = extraParameters2.dataHistogramChannelSpecifications, numChannelDimensions = extraParameters2.numChannelDimensions;
        defineVolumeShader(builder, chunkFormat === null);
        builder.addOutputBuffer("vec4", "v4f_fragData0", 0);
        builder.addFragmentCode(`
void emit(vec4 color) {
  v4f_fragData0 = color;
}
`);
        if (chunkFormat === null) {
          return;
        }
        defineChunkDataShaderAccess(builder, chunkFormat, numChannelDimensions, `vChunkPosition`);
        const numHistograms = dataHistogramChannelSpecifications.length;
        if (dataHistogramsEnabled && numHistograms > 0) {
          let histogramCollectionCode = "";
          const dataType = chunkFormat.dataType;
          for (let i = 0; i < numHistograms; ++i) {
            const channel = dataHistogramChannelSpecifications[i].channel;
            const outputName = `out_histogram${i}`;
            builder.addOutputBuffer("vec4", outputName, 1 + i);
            const getDataValueExpr = `getDataValue(${channel.join(",")})`;
            const invlerpName = `invlerpForHistogram${i}`;
            builder.addFragmentCode(defineInvlerpShaderFunction(
              builder,
              invlerpName,
              dataType,
              /*clamp=*/
              false
            ));
            builder.addFragmentCode(`
float getHistogramValue${i}() {
  return invlerpForHistogram${i}(${getDataValueExpr});
}
`);
            histogramCollectionCode += `{
float x = getHistogramValue${i}();
if (x < 0.0) x = 0.0;
else if (x > 1.0) x = 1.0;
else x = (1.0 + x * 253.0) / 255.0;
${outputName} = vec4(x, x, x, 1.0);
}`;
          }
          builder.addFragmentCode(`void userMain();
void main() {
  ${histogramCollectionCode}
  userMain();
}
#define main userMain
`);
        }
        this.defineShader(builder, parameters);
      },
      getContextKey: (context) => {
        var _a;
        return `${(_a = context.chunkFormat) === null || _a === void 0 ? void 0 : _a.shaderKey}/${context.dataHistogramsEnabled}`;
      }
    });
    this.tempChunkPosition = new Float32Array(multiscaleSource.rank);
    this.initializeCounterpart();
  }
  get dataType() {
    return this.multiscaleSource.dataType;
  }
  getValueAt(globalPosition) {
    let tempChunkPosition = this.tempChunkPosition;
    for (const _ref of this.visibleSourcesList) {
      const source = _ref.source;
      const chunkTransform = _ref.chunkTransform;
      if (!getChunkPositionFromCombinedGlobalLocalPositions(tempChunkPosition, globalPosition, this.localPosition.value, chunkTransform.layerRank, chunkTransform.combinedGlobalLocalToChunkTransform)) {
        continue;
      }
      const result = source.getValueAt(tempChunkPosition, chunkTransform);
      if (result != null) {
        return result;
      }
    }
    return null;
  }
  beginChunkFormat(sliceView, chunkFormat, projectionParameters) {
    const gl = this.gl;
    const dataHistogramsEnabled = this.dataHistogramSpecifications.visibility.visible;
    const shaderResult = this.shaderGetter({ chunkFormat, dataHistogramsEnabled });
    const shader = shaderResult.shader, parameters = shaderResult.parameters, fallback = shaderResult.fallback;
    if (shader !== null) {
      shader.bind();
      initializeShader(shader, projectionParameters, chunkFormat === null);
      if (chunkFormat !== null) {
        if (dataHistogramsEnabled) {
          const dataHistogramChannelSpecifications = shaderResult.extraParameters.dataHistogramChannelSpecifications;
          const numHistograms = dataHistogramChannelSpecifications.length;
          const bounds = this.dataHistogramSpecifications.bounds.value;
          for (let i = 0; i < numHistograms; ++i) {
            enableLerpShaderFunction(shader, `invlerpForHistogram${i}`, chunkFormat.dataType, bounds[i]);
          }
        }
        this.initializeShader(sliceView, shader, parameters, fallback);
        chunkFormat.beginDrawing(gl, shader);
      }
    }
    return shaderResult;
  }
  endSlice(sliceView, shader, parameters) {
  }
  draw(renderContext) {
    const sliceView = renderContext.sliceView;
    const layerInfo = sliceView.visibleLayers.get(this);
    const visibleSources = layerInfo.visibleSources;
    if (visibleSources.length === 0) {
      return;
    }
    const projectionParameters = renderContext.projectionParameters, wireFrame = renderContext.wireFrame;
    const gl = this.gl;
    this.vertexIdHelper.enable();
    const chunkPosition = create$3();
    const renderScaleHistogram = this.renderScaleHistogram;
    if (renderScaleHistogram !== void 0) {
      renderScaleHistogram.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
    }
    let shaderResult;
    let shader = null;
    let prevChunkFormat;
    const chunkDataDisplaySize = create$3();
    const endShader = () => {
      if (shader === null) return;
      if (prevChunkFormat !== null) {
        prevChunkFormat.endDrawing(gl, shader);
      }
      this.endSlice(sliceView, shader, shaderResult.parameters);
    };
    let newSource = true;
    for (const transformedSource of visibleSources) {
      const chunkLayout = getNormalizedChunkLayout(projectionParameters, transformedSource.chunkLayout);
      const channelToChunkDimensionIndices = transformedSource.chunkTransform.channelToChunkDimensionIndices;
      const source = transformedSource.source;
      const fixedPositionWithinChunk = transformedSource.fixedPositionWithinChunk, chunkDisplayDimensionIndices = transformedSource.chunkDisplayDimensionIndices;
      for (const chunkDim of chunkDisplayDimensionIndices) {
        fixedPositionWithinChunk[chunkDim] = 0;
      }
      const chunkFormat = wireFrame ? null : source.chunkFormat;
      if (chunkFormat !== prevChunkFormat) {
        prevChunkFormat = chunkFormat;
        endShader();
        shaderResult = this.beginChunkFormat(sliceView, chunkFormat, projectionParameters);
        shader = shaderResult.shader;
      }
      if (shader === null) continue;
      const chunks = source.chunks;
      chunkDataDisplaySize.fill(1);
      let originalChunkSize = chunkLayout.size;
      let chunkDataSize;
      const chunkRank = source.spec.rank;
      beginSource(gl, shader, sliceView, projectionParameters.viewProjectionMat, transformedSource, chunkLayout);
      if (chunkFormat !== null) {
        chunkFormat.beginSource(gl, shader);
      }
      newSource = true;
      let presentCount = 0, notPresentCount = 0;
      sliceView.forEachVisibleChunk(transformedSource, chunkLayout, (key) => {
        let chunk = chunks.get(key);
        if (chunk && chunk.state === ChunkState.GPU_MEMORY) {
          let newChunkDataSize = chunk.chunkDataSize;
          if (newChunkDataSize !== chunkDataSize) {
            chunkDataSize = newChunkDataSize;
            for (let i = 0; i < 3; ++i) {
              const chunkDim = chunkDisplayDimensionIndices[i];
              chunkDataDisplaySize[i] = chunkDim === -1 || chunkDim >= chunkRank ? 1 : chunkDataSize[chunkDim];
            }
            setupChunkDataSize(gl, shader, chunkDataDisplaySize);
          }
          const chunkGridPosition = chunk.chunkGridPosition;
          for (let i = 0; i < 3; ++i) {
            const chunkDim = chunkDisplayDimensionIndices[i];
            chunkPosition[i] = chunkDim === -1 || chunkDim >= chunkRank ? 0 : originalChunkSize[i] * chunkGridPosition[chunkDim];
          }
          if (chunkFormat !== null) {
            chunkFormat.bindChunk(gl, shader, chunk, fixedPositionWithinChunk, chunkDisplayDimensionIndices, channelToChunkDimensionIndices, newSource);
          }
          newSource = false;
          drawChunk(gl, shader, chunkPosition, wireFrame);
          ++presentCount;
        } else {
          ++notPresentCount;
        }
      });
      if ((presentCount !== 0 || notPresentCount !== 0) && renderScaleHistogram !== void 0) {
        const effectiveVoxelSize = transformedSource.effectiveVoxelSize;
        const medianVoxelSize = medianOf3(effectiveVoxelSize[0], effectiveVoxelSize[1], effectiveVoxelSize[2]);
        renderScaleHistogram.add(medianVoxelSize, medianVoxelSize / projectionParameters.pixelSize, presentCount, notPresentCount);
      }
    }
    endShader();
    this.vertexIdHelper.disable();
    if (!renderContext.wireFrame) {
      const dataHistogramCount = this.getDataHistogramCount();
      if (dataHistogramCount > 0) {
        sliceView.computeHistograms(dataHistogramCount, this.dataHistogramSpecifications);
      }
    }
  }
}
class EquivalencesHashMap {
  constructor(disjointSets) {
    this.disjointSets = disjointSets;
    this.generation = Number.NaN;
    this.hashMap = new HashMapUint64();
  }
  update() {
    let disjointSets = this.disjointSets;
    const generation = disjointSets.generation;
    if (this.generation !== generation) {
      this.generation = generation;
      let hashMap = this.hashMap;
      hashMap.clear();
      for (let _ref of disjointSets.mappings()) {
        var _ref2 = _slicedToArray(_ref, 2);
        let objectId = _ref2[0];
        let minObjectId = _ref2[1];
        hashMap.set(objectId, minObjectId);
      }
    }
  }
}
class SegmentationRenderLayer extends SliceViewVolumeRenderLayer {
  constructor(multiscaleSource, displayState) {
    super(multiscaleSource, {
      shaderParameters: new AggregateWatchableValue((refCounted) => ({
        hasEquivalences: refCounted.registerDisposer(makeCachedDerivedWatchableValue((x) => x.size !== 0, [displayState.segmentationGroupState.value.segmentEquivalences])),
        hasSegmentStatedColors: refCounted.registerDisposer(makeCachedDerivedWatchableValue((x) => x.size !== 0, [displayState.segmentStatedColors])),
        hasSegmentDefaultColor: refCounted.registerDisposer(makeCachedDerivedWatchableValue((x) => x !== void 0, [displayState.segmentDefaultColor])),
        hideSegmentZero: displayState.hideSegmentZero,
        baseSegmentColoring: displayState.baseSegmentColoring
      })),
      transform: displayState.transform,
      renderScaleHistogram: displayState.renderScaleHistogram,
      renderScaleTarget: displayState.renderScaleTarget,
      localPosition: displayState.localPosition
    });
    this.displayState = displayState;
    this.segmentationGroupState = this.displayState.segmentationGroupState.value;
    this.segmentColorShaderManager = new SegmentColorShaderManager("segmentColorHash");
    this.segmentStatedColorShaderManager = new SegmentStatedColorShaderManager("segmentStatedColor");
    this.hashTableManager = new HashSetShaderManager("visibleSegments");
    this.gpuHashTable = this.registerDisposer(GPUHashTable.get(this.gl, this.segmentationGroupState.visibleSegments.hashTable));
    this.gpuTemporaryHashTable = GPUHashTable.get(this.gl, this.segmentationGroupState.temporaryVisibleSegments.hashTable);
    this.equivalencesShaderManager = new HashMapShaderManager("equivalences");
    this.equivalencesHashMap = new EquivalencesHashMap(this.segmentationGroupState.segmentEquivalences.disjointSets);
    this.temporaryEquivalencesHashMap = new EquivalencesHashMap(this.segmentationGroupState.temporarySegmentEquivalences.disjointSets);
    this.gpuEquivalencesHashTable = this.registerDisposer(GPUHashTable.get(this.gl, this.equivalencesHashMap.hashMap));
    this.gpuTemporaryEquivalencesHashTable = this.registerDisposer(GPUHashTable.get(this.gl, this.temporaryEquivalencesHashMap.hashMap));
    this.registerDisposer(this.shaderParameters);
    registerRedrawWhenSegmentationDisplayStateChanged(displayState, this);
    this.registerDisposer(displayState.selectedAlpha.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(displayState.notSelectedAlpha.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(displayState.ignoreNullVisibleSet.changed.add(this.redrawNeeded.dispatch));
  }
  disposed() {
    var _a;
    (_a = this.gpuSegmentStatedColorHashTable) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  getSources(options) {
    return this.multiscaleSource.getSources(_Object$assign(_Object$assign({}, options), { discreteValues: true }));
  }
  defineShader(builder, parameters) {
    this.hashTableManager.defineShader(builder);
    let getUint64Code = `
uint64_t getUint64DataValue() {
  uint64_t x = toUint64(getDataValue());
`;
    getUint64Code += `return x;
}
`;
    builder.addFragmentCode(getUint64Code);
    if (parameters.hasEquivalences) {
      this.equivalencesShaderManager.defineShader(builder);
      builder.addFragmentCode(`
uint64_t getMappedObjectId(uint64_t value) {
  uint64_t mappedValue;
  if (${this.equivalencesShaderManager.getFunctionName}(value, mappedValue)) {
    return mappedValue;
  }
  return value;
}
`);
    } else {
      builder.addFragmentCode(`
uint64_t getMappedObjectId(uint64_t value) {
  return value;
}
`);
    }
    builder.addUniform("highp uvec2", "uSelectedSegment");
    builder.addUniform("highp uint", "uShowAllSegments");
    builder.addUniform("highp float", "uSelectedAlpha");
    builder.addUniform("highp float", "uNotSelectedAlpha");
    builder.addUniform("highp float", "uSaturation");
    let fragmentMain = `
  uint64_t baseValue = getUint64DataValue();
  uint64_t value = getMappedObjectId(baseValue);
  uint64_t valueForColor = ${parameters.baseSegmentColoring ? "baseValue" : "value"};

  float alpha = uSelectedAlpha;
  float saturation = uSaturation;
`;
    if (parameters.hideSegmentZero) {
      fragmentMain += `
  if (value.value[0] == 0u && value.value[1] == 0u) {
    emit(vec4(vec4(0, 0, 0, 0)));
    return;
  }
`;
    }
    fragmentMain += `
  bool has = uShowAllSegments != 0u ? true : ${this.hashTableManager.hasFunctionName}(value);
  if (uSelectedSegment == value.value) {
    float adjustment = has ? 0.5 : 0.75;
    if (saturation > adjustment) {
      saturation -= adjustment;
    } else {
      saturation += adjustment;
    }
  } else if (!has) {
    alpha = uNotSelectedAlpha;
  }
`;
    let getMappedIdColor = `vec3 getMappedIdColor(uint64_t value) {
`;
    if (parameters.hasSegmentStatedColors) {
      this.segmentStatedColorShaderManager.defineShader(builder);
      getMappedIdColor += `
  vec3 rgb;
  if (${this.segmentStatedColorShaderManager.getFunctionName}(value, rgb)) {
    return rgb;
  }
`;
    }
    if (parameters.hasSegmentDefaultColor) {
      builder.addUniform("highp vec3", "uSegmentDefaultColor");
      getMappedIdColor += `  return uSegmentDefaultColor;
`;
    } else {
      this.segmentColorShaderManager.defineShader(builder);
      getMappedIdColor += `  return segmentColorHash(value);
`;
    }
    getMappedIdColor += `
}
`;
    builder.addFragmentCode(getMappedIdColor);
    fragmentMain += `
  vec3 rgb = getMappedIdColor(valueForColor);
  emit(vec4(mix(vec3(1.0,1.0,1.0), rgb, saturation), alpha));
`;
    builder.setFragmentMain(fragmentMain);
  }
  initializeShader(_sliceView, shader, parameters) {
    const gl = this.gl;
    const displayState = this.displayState, segmentationGroupState = this.segmentationGroupState;
    const segmentSelectionState = this.displayState.segmentSelectionState;
    var _displayState = this.displayState;
    const segmentDefaultColor = _displayState.segmentDefaultColor.value, segmentColorHash = _displayState.segmentColorHash.value;
    const visibleSegments = getVisibleSegments(segmentationGroupState);
    const ignoreNullSegmentSet = this.displayState.ignoreNullVisibleSet.value;
    let selectedSegmentLow = 0, selectedSegmentHigh = 0;
    if (segmentSelectionState.hasSelectedSegment) {
      let seg = segmentSelectionState.selectedSegment;
      selectedSegmentLow = seg.low;
      selectedSegmentHigh = seg.high;
    }
    gl.uniform1f(shader.uniform("uSelectedAlpha"), displayState.selectedAlpha.value);
    gl.uniform1f(shader.uniform("uSaturation"), displayState.saturation.value);
    gl.uniform1f(shader.uniform("uNotSelectedAlpha"), displayState.notSelectedAlpha.value);
    gl.uniform2ui(shader.uniform("uSelectedSegment"), selectedSegmentLow, selectedSegmentHigh);
    gl.uniform1ui(shader.uniform("uShowAllSegments"), visibleSegments.hashTable.size || !ignoreNullSegmentSet ? 0 : 1);
    this.hashTableManager.enable(gl, shader, segmentationGroupState.useTemporaryVisibleSegments.value ? this.gpuTemporaryHashTable : this.gpuHashTable);
    if (parameters.hasEquivalences) {
      const useTemp = segmentationGroupState.useTemporarySegmentEquivalences.value;
      (useTemp ? this.temporaryEquivalencesHashMap : this.equivalencesHashMap).update();
      this.equivalencesShaderManager.enable(gl, shader, useTemp ? this.gpuTemporaryEquivalencesHashTable : this.gpuEquivalencesHashTable);
    }
    if (segmentDefaultColor === void 0) {
      this.segmentColorShaderManager.enable(gl, shader, segmentColorHash);
    } else {
      gl.uniform3fv(shader.uniform("uSegmentDefaultColor"), segmentDefaultColor);
    }
    if (parameters.hasSegmentStatedColors) {
      const segmentStatedColors = this.displayState.segmentStatedColors.value;
      let gpuSegmentStatedColorHashTable = this.gpuSegmentStatedColorHashTable;
      if (gpuSegmentStatedColorHashTable === void 0 || gpuSegmentStatedColorHashTable.hashTable !== segmentStatedColors.hashTable) {
        gpuSegmentStatedColorHashTable === null || gpuSegmentStatedColorHashTable === void 0 ? void 0 : gpuSegmentStatedColorHashTable.dispose();
        this.gpuSegmentStatedColorHashTable = gpuSegmentStatedColorHashTable = GPUHashTable.get(gl, segmentStatedColors.hashTable);
      }
      this.segmentStatedColorShaderManager.enable(gl, shader, gpuSegmentStatedColorHashTable);
    }
  }
  endSlice(sliceView, shader, parameters) {
    const gl = this.gl;
    this.hashTableManager.disable(gl, shader);
    if (parameters.hasEquivalences) {
      this.equivalencesShaderManager.disable(gl, shader);
    }
    if (parameters.hasSegmentStatedColors) {
      this.segmentStatedColorShaderManager.disable(gl, shader);
    }
    super.endSlice(sliceView, shader, parameters);
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function trackableAlphaValue(initialValue = 0.5) {
  return new TrackableValue(initialValue, verifyFloat01);
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EDGES_PER_BOX = 12;
const CORNERS_PER_BOX = 8;
const FACES_PER_BOX = 6;
const glsl_getBoxFaceVertexPosition = `
vec3 getBoxFaceVertexPosition(int vertexIndex) {
  const vec3 vertexPositions[] = vec3[](
  // Front face
  vec3(0.0, 0.0,  1.0), // 0
  vec3(1.0, 0.0,  1.0), // 1
  vec3(1.0,  1.0,  1.0), // 2
  vec3(0.0,  1.0,  1.0), // 3

  // Back face
  vec3(0.0, 0.0, 0.0), // 4
  vec3(0.0,  1.0, 0.0), // 5
  vec3(1.0,  1.0, 0.0), // 6
  vec3(1.0, 0.0, 0.0), // 7

  // Top face
  vec3(0.0,  1.0, 0.0), // 8
  vec3(0.0,  1.0,  1.0), // 9
  vec3(1.0,  1.0,  1.0), // 10
  vec3(1.0,  1.0, 0.0), // 11

  // Bottom face
  vec3(0.0, 0.0, 0.0), // 12
  vec3( 1.0, 0.0, 0.0), // 13
  vec3( 1.0, 0.0,  1.0), // 14
  vec3(0.0, 0.0,  1.0), // 15

  // Right face
  vec3( 1.0, 0.0, 0.0), // 16
  vec3( 1.0,  1.0, 0.0), // 17
  vec3( 1.0,  1.0,  1.0), // 18
  vec3( 1.0, 0.0,  1.0), // 19

  // Left face
  vec3(0.0, 0.0, 0.0), // 20
  vec3(0.0, 0.0,  1.0), // 21
  vec3(0.0,  1.0,  1.0), // 22
  vec3(0.0,  1.0, 0.0) // 23
  );
  const int indices[] = int[](
    0,  1,  2,      0,  2,  3,    // front
    4,  5,  6,      4,  6,  7,    // back
    8,  9,  10,     8,  10, 11,   // top
    12, 13, 14,     12, 14, 15,   // bottom
    16, 17, 18,     16, 18, 19,   // right
    20, 21, 22,     20, 22, 23   // left
  );
  return vertexPositions[indices[vertexIndex]];
}
`;
function drawBoxes(gl, boxesPerInstance, numInstances) {
  gl.drawArraysInstanced(WebGL2RenderingContext.TRIANGLES, 0, 6 * FACES_PER_BOX * boxesPerInstance, numInstances);
}
const FULL_OBJECT_PICK_OFFSET$2 = 0;
const CORNERS_PICK_OFFSET = FULL_OBJECT_PICK_OFFSET$2 + 1;
const EDGES_PICK_OFFSET = CORNERS_PICK_OFFSET + CORNERS_PER_BOX;
const FACES_PICK_OFFSET = EDGES_PICK_OFFSET + EDGES_PER_BOX;
const PICK_IDS_PER_INSTANCE$2 = FACES_PICK_OFFSET + 6;
const edgeBoxCornerOffsetData = Float32Array.from([
  // a1
  0,
  0,
  0,
  // b1
  0,
  0,
  1,
  // c1
  EDGES_PICK_OFFSET + 0,
  // a2
  1,
  0,
  0,
  // b2
  1,
  0,
  1,
  // c2
  EDGES_PICK_OFFSET + 1,
  // a3
  0,
  1,
  0,
  // b3
  0,
  1,
  1,
  // c3
  EDGES_PICK_OFFSET + 2,
  // a4
  1,
  1,
  0,
  // b4
  1,
  1,
  1,
  // c4
  EDGES_PICK_OFFSET + 3,
  // a5
  0,
  0,
  0,
  // b5
  0,
  1,
  0,
  // c5
  EDGES_PICK_OFFSET + 4,
  // a6
  0,
  0,
  1,
  // b6
  0,
  1,
  1,
  // c6
  EDGES_PICK_OFFSET + 5,
  // a7
  1,
  0,
  0,
  // b7
  1,
  1,
  0,
  // c7
  EDGES_PICK_OFFSET + 6,
  // a8
  1,
  0,
  1,
  // b8
  1,
  1,
  1,
  // c8
  EDGES_PICK_OFFSET + 7,
  // a9
  0,
  0,
  0,
  // b9
  1,
  0,
  0,
  // c9
  EDGES_PICK_OFFSET + 8,
  // a10
  0,
  0,
  1,
  // b10
  1,
  0,
  1,
  // c10
  EDGES_PICK_OFFSET + 9,
  // a11
  0,
  1,
  0,
  // b11
  1,
  1,
  0,
  // c11
  EDGES_PICK_OFFSET + 10,
  // a12
  0,
  1,
  1,
  // b12
  1,
  1,
  1,
  // c12
  EDGES_PICK_OFFSET + 11
]);
const tempInvModelViewProjectionMatrix = create$4();
const tempWorldBounds = new Float32Array(6);
let RenderHelper$4 = class RenderHelper2 extends AnnotationRenderHelper {
  constructor() {
    super(...arguments);
    this.vertexIdHelper = this.registerDisposer(VertexIdHelper.get(this.gl));
  }
  defineShader(builder) {
    defineVertexId(builder);
    const rank = this.rank;
    defineVectorArrayVertexShaderInput(
      builder,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "Bounds",
      rank,
      2
    );
    builder.addUniform("vec3", "uModelSpaceBoundOffsets", 2);
  }
  enable(shaderGetter, context, callback) {
    invert$1(tempInvModelViewProjectionMatrix, context.modelViewProjectionMatrix);
    getViewFrustrumWorldBounds(tempInvModelViewProjectionMatrix, tempWorldBounds);
    const numChunkDisplayDims = context.chunkDisplayTransform.numChunkDisplayDims;
    for (let i = 0; i < numChunkDisplayDims; ++i) {
      tempWorldBounds[i] = 0;
      tempWorldBounds[i + 3] = 0;
    }
    for (let i = numChunkDisplayDims; i < 3; ++i) {
      const delta = Math.abs(tempWorldBounds[i + 3] - tempWorldBounds[i]);
      tempWorldBounds[i] -= delta;
      tempWorldBounds[i + 3] += delta;
    }
    super.enable(shaderGetter, context, (shader) => {
      const binder = shader.vertexShaderInputBinders["Bounds"];
      binder.enable(1);
      const gl = this.gl;
      gl.uniform3fv(shader.uniform("uModelSpaceBoundOffsets"), tempWorldBounds);
      gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, context.buffer.buffer);
      binder.bind(this.geometryDataStride, context.bufferOffset);
      const vertexIdHelper = this.vertexIdHelper;
      vertexIdHelper.enable();
      callback(shader);
      vertexIdHelper.disable();
      binder.disable();
    });
  }
};
function addBorderNoOpSetters(builder) {
  builder.addVertexCode(`
void setBoundingBoxBorderWidth(float width) {}
void setBoundingBoxBorderColor(vec4 color) {}
`);
}
function addFaceNoOpSetters(builder) {
  builder.addVertexCode(`
void setBoundingBoxFillColor(vec4 color) {}
`);
}
function addBorderSetters(builder) {
  addFaceNoOpSetters(builder);
  builder.addVertexCode(`
float ng_lineWidth;
void setBoundingBoxBorderWidth(float size) {
  ng_lineWidth = size;
}
void setBoundingBoxBorderColor(vec4 color) {
  vColor = color;
}
`);
}
function addFaceSetters(builder) {
  addBorderNoOpSetters(builder);
  builder.addVertexCode(`
void setBoundingBoxFillColor(vec4 color) {
  vColor = color;
}
`);
}
class PerspectiveViewRenderHelper extends RenderHelper$4 {
  constructor() {
    super(...arguments);
    this.edgeBoxCornerOffsetsBuffer = this.registerDisposer(Buffer.fromData(this.gl, tile2dArray(
      edgeBoxCornerOffsetData,
      /*majorDimension=*/
      7,
      /*minorTiles=*/
      1,
      /*majorTiles=*/
      VERTICES_PER_LINE
    )));
    this.edgeShaderGetter = this.getDependentShader("annotation/boundingBox/projection/border", (builder) => {
      const rank = this.rank;
      this.defineShader(builder);
      defineLineShader(builder);
      builder.addAttribute("highp vec3", "aBoxCornerOffset1");
      builder.addAttribute("highp vec4", "aBoxCornerOffset2");
      builder.addVarying("highp float", "vClipCoefficient");
      addBorderSetters(builder);
      builder.setVertexMain(`
float modelPositionA[${rank}] = getBounds0();
float modelPositionB[${rank}] = getBounds1();
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
vec3 endpointA = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset1);
vec3 endpointB = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset2.xyz);
vClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
ng_lineWidth = 1.0;
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(endpointA, 1.0),
         uModelViewProjection * vec4(endpointB, 1.0),
         ng_lineWidth);
${this.setPartIndex(builder, "uint(aBoxCornerOffset2.w)")};
`);
      builder.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, getLineAlpha() * vClipCoefficient));
`);
    });
    this.boxCornerOffsetsBuffer = this.registerDisposer(Buffer.fromData(this.gl, tile2dArray(
      vertexBasePositions,
      /*majorDimension=*/
      3,
      /*minorTiles=*/
      1,
      /*majorTiles=*/
      VERTICES_PER_CIRCLE
    )));
    this.cornerShaderGetter = this.getDependentShader("annotation/boundingBox/projection/corner", (builder) => {
      const rank = this.rank;
      this.defineShader(builder);
      defineCircleShader(builder, this.targetIsSliceView);
      builder.addAttribute("highp vec3", "aBoxCornerOffset");
      builder.addVarying("highp float", "vClipCoefficient");
      addBorderSetters(builder);
      builder.setVertexMain(`
float modelPositionA[${rank}] = getBounds0();
float modelPositionB[${rank}] = getBounds1();
vClipCoefficient = getMaxEndpointSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
vec3 vertexPosition = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset);
emitCircle(uModelViewProjection * vec4(vertexPosition, 1.0), ng_lineWidth, 0.0);
uint cornerIndex = uint(aBoxCornerOffset.x + aBoxCornerOffset.y * 2.0 + aBoxCornerOffset.z * 4.0);
uint cornerPickOffset = ${CORNERS_PICK_OFFSET}u + cornerIndex;
${this.setPartIndex(builder, "cornerPickOffset")};
`);
      builder.setFragmentMain(`
vec4 borderColor = vec4(0.0, 0.0, 0.0, 1.0);
vec4 color = getCircleColor(vColor, borderColor);
color.a *= vClipCoefficient;
emitAnnotation(color);
`);
    });
  }
  drawEdges(context) {
    const gl = this.gl;
    this.enable(this.edgeShaderGetter, context, (shader) => {
      const aBoxCornerOffset1 = shader.attribute("aBoxCornerOffset1");
      const aBoxCornerOffset2 = shader.attribute("aBoxCornerOffset2");
      this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(
        aBoxCornerOffset1,
        /*components=*/
        3,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT,
        /*normalized=*/
        false,
        /*stride=*/
        4 * 7,
        /*offset=*/
        0
      );
      this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(
        aBoxCornerOffset2,
        /*components=*/
        4,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT,
        /*normalized=*/
        false,
        /*stride=*/
        4 * 7,
        /*offset=*/
        4 * 3
      );
      initializeLineShader(
        shader,
        context.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      );
      drawLines(gl, EDGES_PER_BOX, context.count);
      gl.disableVertexAttribArray(aBoxCornerOffset1);
      gl.disableVertexAttribArray(aBoxCornerOffset2);
    });
  }
  drawCorners(context) {
    const gl = this.gl;
    this.enable(this.cornerShaderGetter, context, (shader) => {
      const aBoxCornerOffset = shader.attribute("aBoxCornerOffset");
      this.boxCornerOffsetsBuffer.bindToVertexAttrib(
        aBoxCornerOffset,
        /*components=*/
        3,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT,
        /*normalized=*/
        false
      );
      initializeCircleShader(shader, context.renderContext.projectionParameters, { featherWidthInPixels: 0 });
      drawCircles(shader.gl, CORNERS_PER_BOX, context.count);
      gl.disableVertexAttribArray(aBoxCornerOffset);
    });
  }
  draw(context) {
    this.drawEdges(context);
    this.drawCorners(context);
  }
}
let SliceViewRenderHelper$1 = class SliceViewRenderHelper2 extends RenderHelper$4 {
  constructor() {
    super(...arguments);
    this.faceShaderGetter = this.getDependentShader("annotation/boundingBox/crossSection/face", (builder) => {
      const rank = this.rank;
      super.defineShader(builder);
      defineBoundingBoxCrossSectionShader(builder);
      defineLineShader(builder);
      builder.addVarying("highp float", "vClipCoefficient");
      addBorderSetters(builder);
      builder.setVertexMain(`
float modelPositionA[${rank}] = getBounds0();
float modelPositionB[${rank}] = getBounds1();
for (int i = 0; i < ${rank}; ++i) {
  float a = modelPositionA[i];
  float b = modelPositionB[i];
  modelPositionA[i] = min(a, b);
  modelPositionB[i] = max(a, b);
}
vClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
int vertexIndex1 = gl_VertexID / ${VERTICES_PER_LINE};
int vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;
vec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex1);
vec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex2);
ng_lineWidth = 1.0;
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(vertexPosition1, 1.0),
         uModelViewProjection * vec4(vertexPosition2, 1.0),
         ng_lineWidth);
${this.setPartIndex(builder)};
`);
      builder.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() * vClipCoefficient));
`);
    });
    this.fillShaderGetter = this.getDependentShader("annotation/boundingBox/crossSection/fill", (builder) => {
      const rank = this.rank;
      super.defineShader(builder);
      defineBoundingBoxCrossSectionShader(builder);
      builder.addVarying("highp float", "vClipCoefficient");
      addFaceSetters(builder);
      builder.setVertexMain(`
float modelPositionA[${rank}] = getBounds0();
float modelPositionB[${rank}] = getBounds1();
for (int i = 0; i < ${rank}; ++i) {
  float a = modelPositionA[i];
  float b = modelPositionB[i];
  modelPositionA[i] = min(a, b);
  modelPositionB[i] = max(a, b);
}
vClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
int vertexIndex = gl_VertexID;
vec3 vertexPosition = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex);
gl_Position = uModelViewProjection * vec4(vertexPosition, 1);
${this.invokeUserMain}
${this.setPartIndex(builder)};
`);
      builder.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, vColor.a * vClipCoefficient));
`);
    });
  }
  enableForBoundingBox(shaderGetter, context, callback) {
    super.enable(shaderGetter, context, (shader) => {
      const projectionParameters = context.renderContext.sliceView.projectionParameters.value;
      setBoundingBoxCrossSectionShaderViewportPlane(shader, projectionParameters.viewportNormalInGlobalCoordinates, projectionParameters.centerDataPosition, context.renderSubspaceModelMatrix, context.renderSubspaceInvModelMatrix);
      callback(shader);
    });
  }
  draw(context) {
    if (this.shaderControlState.parseResult.value.code.match(/\bsetBoundingBoxFillColor\b/)) {
      this.enableForBoundingBox(this.fillShaderGetter, context, () => {
        drawArraysInstanced(this.gl, WebGL2RenderingContext.TRIANGLE_FAN, 0, 6, context.count);
      });
    }
    this.enableForBoundingBox(this.faceShaderGetter, context, (shader) => {
      initializeLineShader(
        shader,
        context.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      );
      drawLines(shader.gl, 6, context.count);
    });
  }
};
function snapPositionToCorner(position, corners) {
  const rank = position.length;
  for (let i = 0; i < rank; ++i) {
    const v0 = corners[i], v1 = corners[i + rank];
    const x = position[i];
    position[i] = Math.abs(v0 - x) < Math.abs(v1 - x) ? v0 : v1;
  }
}
registerAnnotationTypeRenderHandler(AnnotationType.AXIS_ALIGNED_BOUNDING_BOX, {
  sliceViewRenderHelper: SliceViewRenderHelper$1,
  perspectiveViewRenderHelper: PerspectiveViewRenderHelper,
  defineShaderNoOpSetters(builder) {
    addFaceNoOpSetters(builder);
    addBorderNoOpSetters(builder);
  },
  pickIdsPerInstance: PICK_IDS_PER_INSTANCE$2,
  snapPosition(position, data, offset, partIndex) {
    const rank = position.length;
    const corners = new Float32Array(data, offset, rank * 2);
    if (partIndex >= CORNERS_PICK_OFFSET && partIndex < EDGES_PICK_OFFSET) {
      snapPositionToCorner(position, corners);
    }
  },
  getRepresentativePoint(out, ann, partIndex) {
    if (partIndex === FULL_OBJECT_PICK_OFFSET$2) {
      out.set(ann.pointA);
    } else if (partIndex >= CORNERS_PICK_OFFSET && partIndex < EDGES_PICK_OFFSET) {
      out.set(ann.pointA);
    } else if (partIndex >= EDGES_PICK_OFFSET && partIndex < FACES_PICK_OFFSET) {
      out.set(ann.pointA);
    } else {
      out.set(ann.pointA);
    }
  },
  updateViaRepresentativePoint(oldAnnotation, position, partIndex) {
    const rank = position.length;
    const pointA = oldAnnotation.pointA, pointB = oldAnnotation.pointB;
    const newPointA = new Float32Array(rank);
    const newPointB = new Float32Array(rank);
    for (let i = 0; i < rank; ++i) {
      const x = newPointA[i] = position[i];
      newPointB[i] = pointB[i] + (x - pointA[i]);
    }
    return _Object$assign(_Object$assign({}, oldAnnotation), { pointA: newPointA, pointB: newPointB });
  }
});
const FULL_OBJECT_PICK_OFFSET$1 = 0;
const ENDPOINTS_PICK_OFFSET$1 = FULL_OBJECT_PICK_OFFSET$1 + 1;
const PICK_IDS_PER_INSTANCE$1 = ENDPOINTS_PICK_OFFSET$1 + 2;
function defineNoOpEndpointMarkerSetters$1(builder) {
  builder.addVertexCode(`
void setEndpointMarkerSize(float startSize, float endSize) {}
void setEndpointMarkerBorderWidth(float startSize, float endSize) {}
void setEndpointMarkerColor(vec4 startColor, vec4 endColor) {}
void setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {}
`);
}
function defineNoOpLineSetters$1(builder) {
  builder.addVertexCode(`
void setLineWidth(float width) {}
void setLineColor(vec4 startColor, vec4 endColor) {}
`);
}
let RenderHelper$3 = class RenderHelper3 extends AnnotationRenderHelper {
  constructor() {
    super(...arguments);
    this.vertexIdHelper = this.registerDisposer(VertexIdHelper.get(this.gl));
    this.edgeShaderGetter = this.getDependentShader("annotation/line/edge", (builder) => {
      const rank = this.rank;
      this.defineShader(builder);
      defineLineShader(builder);
      builder.addVarying(`highp float[${rank}]`, "vModelPosition");
      builder.addVertexCode(`
float ng_LineWidth;
`);
      defineNoOpEndpointMarkerSetters$1(builder);
      builder.addVertexCode(`
void setLineWidth(float width) {
  ng_LineWidth = width;
}
void setLineColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, getLineEndpointCoefficient());
}
`);
      builder.setVertexMain(`
float modelPositionA[${rank}] = getVertexPosition0();
float modelPositionB[${rank}] = getVertexPosition1();
for (int i = 0; i < ${rank}; ++i) {
  vModelPosition[i] = mix(modelPositionA[i], modelPositionB[i], getLineEndpointCoefficient());
}
ng_LineWidth = 1.0;
vColor = vec4(0.0, 0.0, 0.0, 0.0);
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionA), 1.0),
         uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionB), 1.0),
         ng_LineWidth);
${this.setPartIndex(builder)};
`);
      builder.setFragmentMain(`
float clipCoefficient = getSubspaceClipCoefficient(vModelPosition);
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() *
                                ${this.getCrossSectionFadeFactor()} *
                                clipCoefficient));
`);
    });
    this.endpointShaderGetter = this.getDependentShader("annotation/line/endpoint", (builder) => {
      const rank = this.rank;
      this.defineShader(builder);
      defineCircleShader(builder, this.targetIsSliceView);
      builder.addVarying("highp float", "vClipCoefficient");
      builder.addVarying("highp vec4", "vBorderColor");
      defineNoOpLineSetters$1(builder);
      builder.addVertexCode(`
float ng_markerDiameter;
float ng_markerBorderWidth;
int getEndpointIndex() {
  return gl_VertexID / ${VERTICES_PER_CIRCLE};
}
void setEndpointMarkerSize(float startSize, float endSize) {
  ng_markerDiameter = mix(startSize, endSize, float(getEndpointIndex()));
}
void setEndpointMarkerBorderWidth(float startSize, float endSize) {
  ng_markerBorderWidth = mix(startSize, endSize, float(getEndpointIndex()));
}
void setEndpointMarkerColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, float(getEndpointIndex()));
}
void setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {
  vBorderColor = mix(startColor, endColor, float(getEndpointIndex()));
}
`);
      builder.setVertexMain(`
float modelPosition[${rank}] = getVertexPosition0();
float modelPositionB[${rank}] = getVertexPosition1();
for (int i = 0; i < ${rank}; ++i) {
  modelPosition[i] = mix(modelPosition[i], modelPositionB[i], float(getEndpointIndex()));
}
vClipCoefficient = getSubspaceClipCoefficient(modelPosition);
vColor = vec4(0.0, 0.0, 0.0, 0.0);
vBorderColor = vec4(0.0, 0.0, 0.0, 1.0);
ng_markerDiameter = 5.0;
ng_markerBorderWidth = 1.0;
${this.invokeUserMain}
emitCircle(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);
${this.setPartIndex(builder, "uint(getEndpointIndex()) + 1u")};
`);
      builder.setFragmentMain(`
vec4 color = getCircleColor(vColor, vBorderColor);
color.a *= vClipCoefficient;
emitAnnotation(color);
`);
    });
  }
  defineShader(builder) {
    defineVertexId(builder);
    const rank = this.rank;
    defineVectorArrayVertexShaderInput(
      builder,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "VertexPosition",
      rank,
      2
    );
  }
  enable(shaderGetter, context, callback) {
    super.enable(shaderGetter, context, (shader) => {
      const binder = shader.vertexShaderInputBinders["VertexPosition"];
      binder.enable(1);
      this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, context.buffer.buffer);
      binder.bind(this.geometryDataStride, context.bufferOffset);
      const vertexIdHelper = this.vertexIdHelper;
      vertexIdHelper.enable();
      callback(shader);
      vertexIdHelper.disable();
      binder.disable();
    });
  }
  drawEdges(context) {
    this.enable(this.edgeShaderGetter, context, (shader) => {
      initializeLineShader(
        shader,
        context.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      );
      drawLines(shader.gl, 1, context.count);
    });
  }
  drawEndpoints(context) {
    this.enable(this.endpointShaderGetter, context, (shader) => {
      initializeCircleShader(shader, context.renderContext.projectionParameters, { featherWidthInPixels: 0.5 });
      drawCircles(shader.gl, 2, context.count);
    });
  }
  draw(context) {
    this.drawEdges(context);
    this.drawEndpoints(context);
  }
};
function snapPositionToLine$1(position, endpoints) {
  const rank = position.length;
  projectPointToLineSegment(position, endpoints.subarray(0, rank), endpoints.subarray(rank), position);
}
function snapPositionToEndpoint$1(position, endpoints, endpointIndex) {
  const rank = position.length;
  const startOffset = rank * endpointIndex;
  for (let i = 0; i < rank; ++i) {
    position[i] = endpoints[startOffset + i];
  }
}
registerAnnotationTypeRenderHandler(AnnotationType.LINE, {
  sliceViewRenderHelper: RenderHelper$3,
  perspectiveViewRenderHelper: RenderHelper$3,
  defineShaderNoOpSetters(builder) {
    defineNoOpEndpointMarkerSetters$1(builder);
    defineNoOpLineSetters$1(builder);
  },
  pickIdsPerInstance: PICK_IDS_PER_INSTANCE$1,
  snapPosition(position, data, offset, partIndex) {
    const rank = position.length;
    const endpoints = new Float32Array(data, offset, rank * 2);
    if (partIndex === FULL_OBJECT_PICK_OFFSET$1) {
      snapPositionToLine$1(position, endpoints);
    } else {
      snapPositionToEndpoint$1(position, endpoints, partIndex - ENDPOINTS_PICK_OFFSET$1);
    }
  },
  getRepresentativePoint(out, ann, partIndex) {
    out.set(partIndex === FULL_OBJECT_PICK_OFFSET$1 || partIndex === ENDPOINTS_PICK_OFFSET$1 ? ann.pointA : ann.pointB);
  },
  updateViaRepresentativePoint(oldAnnotation, position, partIndex) {
    let baseLine = _Object$assign({}, oldAnnotation);
    const rank = position.length;
    switch (partIndex) {
      case FULL_OBJECT_PICK_OFFSET$1: {
        const pointA = oldAnnotation.pointA, pointB = oldAnnotation.pointB;
        const newPointA = new Float32Array(rank);
        const newPointB = new Float32Array(rank);
        for (let i = 0; i < rank; ++i) {
          const pos = newPointA[i] = position[i];
          newPointB[i] = pointB[i] + (pos - pointA[i]);
        }
        return _Object$assign(_Object$assign({}, oldAnnotation), { pointA: newPointA, pointB: newPointB });
      }
      case FULL_OBJECT_PICK_OFFSET$1 + 1:
        return _Object$assign(_Object$assign({}, oldAnnotation), { pointA: new Float32Array(position) });
      case FULL_OBJECT_PICK_OFFSET$1 + 2:
        return _Object$assign(_Object$assign({}, oldAnnotation), { pointB: new Float32Array(position) });
    }
    return baseLine;
  }
});
let RenderHelper$2 = class RenderHelper4 extends AnnotationRenderHelper {
  constructor() {
    super(...arguments);
    this.shaderGetter3d = this.getDependentShader("annotation/point:3d", (builder) => {
      defineVertexId(builder);
      defineCircleShader(
        builder,
        /*crossSectionFade=*/
        this.targetIsSliceView
      );
      this.defineShaderCommon(builder);
      builder.addVertexMain(`
emitCircle(uModelViewProjection *
           vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);
`);
      builder.setFragmentMain(`
vec4 color = getCircleColor(vColor, vBorderColor);
emitAnnotation(color);
`);
    });
    this.makeShaderGetter2d = (extraDim) => this.getDependentShader(`annotation/point:2d:${extraDim}`, (builder) => {
      defineVertexId(builder);
      defineLineShader(
        builder,
        /*rounded=*/
        true
      );
      this.defineShaderCommon(builder);
      builder.addVertexMain(`
vec3 subspacePositionA = projectModelVectorToSubspace(modelPosition);
vec3 subspacePositionB = subspacePositionA;
vec4 baseProjection = uModelViewProjection * vec4(subspacePositionA, 1.0);
vec4 zCoeffs = uModelViewProjection[${extraDim}];
float minZ = 1e30;
float maxZ = -1e30;
for (int i = 0; i < 3; ++i) {
  // Want: baseProjection[i] + z * zCoeffs[i] = -2.0 * (baseProjection.w - z * zCoeffs.w)
  //  i.e. baseProjection[i] + 2.0 * baseProjection.w < -z * (2.0 * zCoeffs.w + zCoeffs[i])
  //  i.e. baseProjection[i] + 2.0 * baseProjection.w < -z * k1
  float k1 = 2.0 * zCoeffs.w + zCoeffs[i];
  float q1 = -(baseProjection[i] + 2.0 * baseProjection.w) / k1;
  if (k1 != 0.0) {
    minZ = min(minZ, q1);
    maxZ = max(maxZ, q1);
  }
  // Want: baseProjection[i] + z * zCoeffs[i] = 2.0 * (baseProjection.w + z * zCoeffs.w)
  //  i.e. baseProjection[i] - 2.0 * baseProjection.w > z * (2.0 * zCoeffs.w - zCoeffs[i])
  //  i.e. baseProjection[i] - 2.0 * baseProjection.w > z * k2
  float k2 = 2.0 * zCoeffs.w - zCoeffs[i];
  float q2 = (baseProjection[i] - 2.0 * baseProjection.w) / k2;
  if (k2 != 0.0) {
    minZ = min(minZ, q2);
    maxZ = max(maxZ, q2);
  }
}
if (minZ > maxZ) minZ = maxZ = 0.0;
subspacePositionA[${extraDim}] = minZ;
subspacePositionB[${extraDim}] = maxZ;
emitLine(uModelViewProjection, subspacePositionA, subspacePositionB, ng_markerDiameter, ng_markerBorderWidth);
`);
      builder.setFragmentMain(`
vec4 color = getRoundedLineColor(vColor, vBorderColor);
emitAnnotation(vec4(color.rgb, color.a * ${this.getCrossSectionFadeFactor()}));
`);
    });
    this.shaderGetter2d = this.makeShaderGetter2d(2);
    this.shaderGetter1d = this.makeShaderGetter2d(1);
    this.vertexIdHelper = this.registerDisposer(VertexIdHelper.get(this.gl));
  }
  defineShaderCommon(builder) {
    const rank = this.rank;
    defineVectorArrayVertexShaderInput(
      builder,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "VertexPosition",
      rank
    );
    builder.addVarying("highp vec4", "vBorderColor");
    builder.addVertexCode(`
float ng_markerDiameter;
float ng_markerBorderWidth;
void setPointMarkerSize(float size) {
  ng_markerDiameter = size;
}
void setPointMarkerBorderWidth(float size) {
  ng_markerBorderWidth = size;
}
void setPointMarkerColor(vec4 color) {
  vColor = color;
}
void setPointMarkerBorderColor(vec4 color) {
  vBorderColor = color;
}
`);
    builder.addVertexMain(`
ng_markerDiameter = 5.0;
ng_markerBorderWidth = 1.0;
vBorderColor = vec4(0.0, 0.0, 0.0, 1.0);
float modelPosition[${rank}] = getVertexPosition0();
float clipCoefficient = getSubspaceClipCoefficient(modelPosition);
if (clipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
${this.invokeUserMain}
vColor.a *= clipCoefficient;
vBorderColor.a *= clipCoefficient;
${this.setPartIndex(builder)};
`);
  }
  enable(shaderGetter, context, callback) {
    super.enable(shaderGetter, context, (shader) => {
      const binder = shader.vertexShaderInputBinders["VertexPosition"];
      binder.enable(1);
      this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, context.buffer.buffer);
      binder.bind(this.geometryDataStride, context.bufferOffset);
      const vertexIdHelper = this.vertexIdHelper;
      vertexIdHelper.enable();
      callback(shader);
      vertexIdHelper.disable();
      binder.disable();
    });
  }
  draw(context) {
    const numChunkDisplayDims = context.chunkDisplayTransform.numChunkDisplayDims;
    switch (numChunkDisplayDims) {
      case 3:
        this.enable(this.shaderGetter3d, context, (shader) => {
          initializeCircleShader(shader, context.renderContext.projectionParameters, { featherWidthInPixels: 1 });
          drawCircles(shader.gl, 1, context.count);
        });
        break;
      case 2:
      case 1:
        this.enable(numChunkDisplayDims === 2 ? this.shaderGetter2d : this.shaderGetter1d, context, (shader) => {
          initializeLineShader(
            shader,
            context.renderContext.projectionParameters,
            /*featherWidthInPixels=*/
            1
          );
          drawLines(shader.gl, 1, context.count);
        });
        break;
    }
  }
};
registerAnnotationTypeRenderHandler(AnnotationType.POINT, {
  sliceViewRenderHelper: RenderHelper$2,
  perspectiveViewRenderHelper: RenderHelper$2,
  defineShaderNoOpSetters(builder) {
    builder.addVertexCode(`
void setPointMarkerSize(float size) {}
void setPointMarkerBorderWidth(float size) {}
void setPointMarkerColor(vec4 color) {}
void setPointMarkerBorderColor(vec4 color) {}
`);
  },
  pickIdsPerInstance: 1,
  snapPosition(position, data, offset) {
    position.set(new Float32Array(data, offset, position.length));
  },
  getRepresentativePoint(out, ann) {
    out.set(ann.point);
  },
  updateViaRepresentativePoint(oldAnnotation, position) {
    return _Object$assign(_Object$assign({}, oldAnnotation), { point: new Float32Array(position) });
  }
});
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const glsl_EllipseQuadraticForm = `
struct EllipseQuadraticForm {
  highp float A;  // x*x coefficient
  highp float B;  // x*y coefficient
  highp float C;  // y*y coefficient
  highp float D;  // x coefficient
  highp float E;  // y coefficient
  highp float F;  // 1 coefficient
};
`;
const glsl_computeCrossSectionEllipse = [glsl_EllipseQuadraticForm, `
EllipseQuadraticForm computeCrossSectionEllipse(mat3 A, vec3 c) {
  EllipseQuadraticForm p;
  p.A = A[0][0];
  p.B = A[0][1] + A[1][0];
  p.C = A[1][1];
  p.D = -2.0 * c[0] * A[0][0] - c[1] * (A[0][1] + A[1][0]) +
        c[2] * (A[0][2] + A[2][0]);
  p.E = -c[0] * (A[0][1] + A[1][0]) - 2.0 * c[1] * A[1][1] +
        c[2] * (A[1][2] + A[2][1]);
  p.F = c[0] * c[0] * A[0][0] + c[0] * c[1] * (A[0][1] + A[1][0]) -
        c[0] * c[2] * (A[0][2] + A[2][0]) + c[1] * c[1] * A[1][1] -
        c[1] * c[2] * (A[1][2] + A[2][1]) + c[2] * c[2] * A[2][2] - 1.0;
  return p;
}
`];
const glsl_CenterOrientEllipse = `
struct CenterOrientEllipse {
  vec2 k;   // center
  vec2 u1;  // minor axis direction
  vec2 u2;  // major axis direction
  float a;  // semimajor axis
  float b;  // semiminor axis
  bool valid; // indicates if the ellipse is valid
};
`;
const glsl_computeCenterOrientEllipse = [glsl_EllipseQuadraticForm, glsl_CenterOrientEllipse, `
CenterOrientEllipse computeCenterOrientEllipse(EllipseQuadraticForm p) {
  CenterOrientEllipse r;
  float a11 = p.A;
  float a12 = p.B / 2.0;
  float a22 = p.C;
  float b1 = p.D;
  float b2 = p.E;
  float c = p.F;
  float kdenom = 2.0 * (a12 * a12 - a11 * a22);
  float k1 = r.k.x = (a22 * b1 - a12 * b2) / kdenom;
  float k2 = r.k.y = (a11 * b2 - a12 * b1) / kdenom;
  float mu = 1.0 / (a11 * k1 * k1 + 2.0 * a12 * k1 * k2 + a22 * k2 * k2 - c);
  float m11 = mu * a11;
  float m12 = mu * a12;
  float m22 = mu * a22;
  float lambdaTerm1 = m11 + m22;
  float lambdaTerm2 = sqrt((m11 - m22) * (m11 - m22) + 4.0 * m12 * m12);
  float lambda1 = ((lambdaTerm1 + lambdaTerm2) / 2.0);
  float lambda2 = ((lambdaTerm1 - lambdaTerm2) / 2.0);
  r.a = 1.0 / sqrt(lambda1);
  r.b = 1.0 / sqrt(lambda2);
  r.valid = lambda1 > 0.0 && lambda2 > 0.0;
  if (abs(m11 - m22) < 1e-6 && abs(m12) < 1e-6) {
    r.u1 = vec2(1.0, 0.0);
  } else if (m11 >= m22) {
    r.u1 = normalize(vec2(lambda1 - m22, m12));
  } else {
    r.u1 = normalize(vec2(m12, lambda1 - m11));
  }
  r.u2 = vec2(-r.u1.y, r.u1.x);
  return r;
}
`];
const tempMat4$2 = create$4();
let RenderHelper$1 = class RenderHelper5 extends AnnotationRenderHelper {
  defineShader(builder) {
    const rank = this.rank;
    defineVectorArrayVertexShaderInput(
      builder,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "CenterAndRadii",
      rank,
      2
    );
    builder.addVertexCode(`
struct SubspaceParams {
  highp vec3 subspaceCenter;
  highp vec3 subspaceRadii;
  highp float clipCoefficient;
  bool cull;
};
SubspaceParams getSubspaceParams() {
  SubspaceParams params;
  highp float modelCenter[${rank}] = getCenterAndRadii0();
  highp float modelRadii[${rank}] = getCenterAndRadii1();
  float radiusAdjustment = 1.0;
  float clipCoefficient = 1.0;
  for (int i = 0; i < ${rank}; ++i) {
    float r = modelRadii[i];
    float c = modelCenter[i];
    float x = uModelClipBounds[i];
    float clipRadius = uModelClipBounds[i + ${rank}];
    if (r != 0.0 && clipRadius != 0.0) {
      float d = c - x;
      d = d * d;
      radiusAdjustment -= d / (r * r);
    }
    float e = abs(x - clamp(x, c - r, c + r)) * clipRadius;
    clipCoefficient *= max(0.0, 1.0 - e);
  }
  radiusAdjustment = sqrt(max(0.0, radiusAdjustment));
  params.subspaceCenter = projectModelVectorToSubspace(modelCenter);
  params.subspaceRadii = projectModelVectorToSubspace(modelRadii) * radiusAdjustment;
  params.clipCoefficient = clipCoefficient;
  params.cull = clipCoefficient == 0.0 || radiusAdjustment == 0.0;
  return params;
}
void setEllipsoidFillColor(vec4 color) {
  vColor = color;
}
`);
  }
  enable(shaderGetter, context, callback) {
    super.enable(shaderGetter, context, (shader) => {
      const binder = shader.vertexShaderInputBinders["CenterAndRadii"];
      binder.enable(1);
      this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, context.buffer.buffer);
      binder.bind(this.geometryDataStride, context.bufferOffset);
      callback(shader);
      binder.disable();
    });
  }
};
class PerspectiveRenderHelper extends RenderHelper$1 {
  constructor() {
    super(...arguments);
    this.sphereRenderHelper = this.registerDisposer(new SphereRenderHelper(this.gl, 10, 10));
    this.shaderGetter = this.getDependentShader("annotation/ellipsoid/projection", (builder) => {
      this.defineShader(builder);
      this.sphereRenderHelper.defineShader(builder);
      builder.addUniform("highp vec4", "uLightDirection");
      builder.addUniform("highp mat4", "uNormalTransform");
      builder.addVarying("highp float", "vClipCoefficient");
      builder.setVertexMain(`
SubspaceParams params = getSubspaceParams();
if (params.cull) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vClipCoefficient = params.clipCoefficient;
${this.invokeUserMain}
emitSphere(uModelViewProjection, uNormalTransform, params.subspaceCenter, params.subspaceRadii, uLightDirection);
${this.setPartIndex(builder)};
`);
      builder.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb * vLightingFactor, vColor.a * vClipCoefficient));
`);
    });
    this.tempLightVec = new Float32Array(4);
  }
  draw(context) {
    this.enable(this.shaderGetter, context, (shader) => {
      const gl = shader.gl;
      let lightVec = this.tempLightVec;
      var _context$renderContex = context.renderContext;
      let lightDirection = _context$renderContex.lightDirection, ambientLighting = _context$renderContex.ambientLighting, directionalLighting = _context$renderContex.directionalLighting;
      scale$1(lightVec, lightDirection, directionalLighting);
      lightVec[3] = ambientLighting;
      gl.uniform4fv(shader.uniform("uLightDirection"), lightVec);
      gl.uniformMatrix4fv(
        shader.uniform("uNormalTransform"),
        /*transpose=*/
        false,
        transpose(create$4(), context.renderSubspaceInvModelMatrix)
      );
      this.sphereRenderHelper.draw(shader, context.count);
    });
  }
}
class SliceViewRenderHelper3 extends RenderHelper$1 {
  constructor() {
    super(...arguments);
    this.shaderGetter = this.getDependentShader("annotation/ellipsoid/crossSection", (builder) => {
      defineVertexId(builder);
      this.defineShader(builder);
      builder.addUniform("highp mat4", "uViewportToObject");
      builder.addUniform("highp mat4", "uObjectToViewport");
      builder.addUniform("highp mat4", "uViewportToDevice");
      builder.addAttribute("highp vec2", "aCornerOffset");
      builder.addVarying("highp vec2", "vCircleCoord");
      builder.addVarying("highp float", "vClipCoefficient");
      builder.addVertexCode(glsl_computeCrossSectionEllipse);
      builder.addVertexCode(glsl_computeCenterOrientEllipse);
      builder.addVertexCode(glsl_getQuadVertexPosition);
      builder.setVertexMain(`
SubspaceParams params = getSubspaceParams();
if (params.cull) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vClipCoefficient = params.clipCoefficient;
mat3 Aobject = mat3(0.0);
for (int i = 0; i < 3; ++i) {
  float r = max(params.subspaceRadii[i], 1e-3);
  Aobject[i][i] = 1.0 / (r * r);
}
mat3 RviewportToObject = mat3(uViewportToObject);
mat3 Aviewport = transpose(RviewportToObject) * Aobject * RviewportToObject;
vec3 cViewport = (uObjectToViewport * vec4(params.subspaceCenter, 1.0)).xyz;
EllipseQuadraticForm quadraticForm = computeCrossSectionEllipse(Aviewport, cViewport);
vec2 u1, u2;
float a, b;
CenterOrientEllipse centerOrient = computeCenterOrientEllipse(quadraticForm);
vec2 cornerOffset = getQuadVertexPosition(vec2(-1.0, -1.0), vec2(1.0, 1.0));
vec2 viewportCorner = centerOrient.k +
  centerOrient.u1 * cornerOffset.x * centerOrient.a +
  centerOrient.u2 * cornerOffset.y * centerOrient.b;
if (centerOrient.valid) {
  gl_Position = uViewportToDevice * vec4(viewportCorner, 0.0, 1.0);
} else {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
}
vCircleCoord = cornerOffset;
${this.invokeUserMain}
${this.setPartIndex(builder)};
`);
      builder.setFragmentMain(`
if (dot(vCircleCoord, vCircleCoord) > 1.0) {
  discard;
}
emitAnnotation(vec4(vColor.rgb, vColor.a * vClipCoefficient));
`);
    });
    this.vertexIdHelper = this.registerDisposer(VertexIdHelper.get(this.gl));
  }
  draw(context) {
    this.enable(this.shaderGetter, context, (shader) => {
      const gl = shader.gl;
      const projectionParameters = context.renderContext.sliceView.projectionParameters.value;
      const viewportToObject = multiply$3(tempMat4$2, context.renderSubspaceInvModelMatrix, projectionParameters.invViewMatrix);
      gl.uniformMatrix4fv(
        shader.uniform("uViewportToObject"),
        /*transpose=*/
        false,
        viewportToObject
      );
      gl.uniformMatrix4fv(
        shader.uniform("uViewportToDevice"),
        /*transpose=*/
        false,
        projectionParameters.projectionMat
      );
      const objectToViewport = tempMat4$2;
      invert$1(objectToViewport, viewportToObject);
      gl.uniformMatrix4fv(
        shader.uniform("uObjectToViewport"),
        /*transpose=*/
        false,
        objectToViewport
      );
      const vertexIdHelper = this.vertexIdHelper;
      vertexIdHelper.enable();
      drawQuads(gl, 1, context.count);
      vertexIdHelper.disable();
    });
  }
}
registerAnnotationTypeRenderHandler(AnnotationType.ELLIPSOID, {
  sliceViewRenderHelper: SliceViewRenderHelper3,
  perspectiveViewRenderHelper: PerspectiveRenderHelper,
  defineShaderNoOpSetters(builder) {
    builder.addVertexCode(`
void setEllipsoidFillColor(vec4 color) {}
`);
  },
  pickIdsPerInstance: 1,
  snapPosition: () => {
  },
  getRepresentativePoint(position, ann) {
    position.set(ann.center);
  },
  updateViaRepresentativePoint(oldAnnotation, position) {
    return _Object$assign(_Object$assign({}, oldAnnotation), { center: new Float32Array(position) });
  }
});
const FULL_OBJECT_PICK_OFFSET = 0;
const ENDPOINTS_PICK_OFFSET = FULL_OBJECT_PICK_OFFSET + 1;
const PICK_IDS_PER_INSTANCE = ENDPOINTS_PICK_OFFSET + 2;
function defineNoOpEndpointMarkerSetters(builder) {
  builder.addVertexCode(`
 void setAxisEndpointMarkerSize(float startSize, float endSize) {}
 void setAxisEndpointMarkerBorderWidth(float startSize, float endSize) {}
 void setAxisEndpointMarkerColor(vec4 startColor, vec4 endColor) {}
 void setAxisEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {}
 `);
}
function defineNoOpLineSetters(builder) {
  builder.addVertexCode(`
 void setAxisWidth(float width) {}
 void setAxisColor(vec4 startColor, vec4 endColor) {}
 `);
}
function defineNoOpSphereSetters(builder) {
  builder.addVertexCode(`
 void setSphereColor(vec4 color) {}
 `);
}
class RenderHelper6 extends AnnotationRenderHelper {
  constructor() {
    super(...arguments);
    this.sphereShader = this.registerDisposer(new SphereShader(this.gl));
    this.vertexIdHelper = this.registerDisposer(VertexIdHelper.get(this.gl));
    this.edgeShaderGetter = this.getDependentShader("annotation/sphere/axis", (builder) => {
      const rank = this.rank;
      this.defineShader(builder);
      defineLineShader(builder);
      builder.addVarying(`highp float[${rank}]`, "vModelPosition");
      builder.addVertexCode(`
float ng_LineWidth;
`);
      defineNoOpEndpointMarkerSetters(builder);
      defineNoOpSphereSetters(builder);
      builder.addVertexCode(`
void setAxisWidth(float width) {
  ng_LineWidth = width;
}
void setAxisColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, getLineEndpointCoefficient());
}
`);
      builder.setVertexMain(`
float modelPositionA[${rank}] = getVertexPosition0();
float modelPositionB[${rank}] = getVertexPosition1();
for (int i = 0; i < ${rank}; ++i) {
  vModelPosition[i] = mix(modelPositionA[i], modelPositionB[i], getLineEndpointCoefficient());
}
ng_LineWidth = 1.0;
vColor = vec4(0.0, 0.0, 0.0, 0.0);
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionA), 1.0),
         uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionB), 1.0),
         ng_LineWidth);
${this.setPartIndex(builder)};
`);
      builder.setFragmentMain(`
float clipCoefficient = getSubspaceClipCoefficient(vModelPosition);
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() *
                                ${this.getCrossSectionFadeFactor()} *
                                clipCoefficient));
`);
    });
    this.endpointShaderGetter = this.getDependentShader("annotation/sphere/endpoint", (builder) => {
      const rank = this.rank;
      this.defineShader(builder);
      defineCircleShader(builder, this.targetIsSliceView);
      builder.addVarying("highp float", "vClipCoefficient");
      builder.addVarying("highp vec4", "vBorderColor");
      defineNoOpLineSetters(builder);
      defineNoOpSphereSetters(builder);
      builder.addVertexCode(`
float ng_markerDiameter;
float ng_markerBorderWidth;
int getEndpointIndex() {
  return gl_VertexID / ${VERTICES_PER_CIRCLE};
}
void setAxisEndpointMarkerSize(float startSize, float endSize) {
  ng_markerDiameter = mix(startSize, endSize, float(getEndpointIndex()));
}
void setAxisEndpointMarkerBorderWidth(float startSize, float endSize) {
  ng_markerBorderWidth = mix(startSize, endSize, float(getEndpointIndex()));
}
void setAxisEndpointMarkerColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, float(getEndpointIndex()));
}
void setAxisEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {
  vBorderColor = mix(startColor, endColor, float(getEndpointIndex()));
}
`);
      builder.setVertexMain(`
float modelPosition[${rank}] = getVertexPosition0();
float modelPositionB[${rank}] = getVertexPosition1();
for (int i = 0; i < ${rank}; ++i) {
  modelPosition[i] = mix(modelPosition[i], modelPositionB[i], float(getEndpointIndex()));
}
vClipCoefficient = getSubspaceClipCoefficient(modelPosition);
vColor = vec4(0.0, 0.0, 0.0, 0.0);
vBorderColor = vec4(0.0, 0.0, 0.0, 1.0);
ng_markerDiameter = 5.0;
ng_markerBorderWidth = 1.0;
${this.invokeUserMain}
emitCircle(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);
${this.setPartIndex(builder, "uint(getEndpointIndex()) + 1u")};
`);
      builder.setFragmentMain(`
vec4 color = getCircleColor(vColor, vBorderColor);
color.a *= vClipCoefficient;
emitAnnotation(color);
`);
    });
    this.sphereShadeGetter = this.getDependentShader("annotation/sphere/sphere", (builder) => {
      const rank = this.rank;
      this.defineShader(builder);
      this.sphereShader.defineShader(builder);
      builder.addVarying("highp float", "vClipCoefficient");
      defineNoOpLineSetters(builder);
      defineNoOpEndpointMarkerSetters(builder);
      builder.addVertexCode(`
 void setSphereColor(vec4 color) {
   vColor = color;
 }
 `);
      builder.setVertexMain(`
 float modelPosition[${rank}] = getVertexPosition0();
 float modelPositionB[${rank}] = getVertexPosition1();
 float diameter = 0.0;
 for (int i = 0; i < ${rank}; ++i) {
   float dx = modelPosition[i] - modelPositionB[i];
   diameter += dx * dx;
   modelPosition[i] = (modelPosition[i] + modelPositionB[i]) * 0.5;
 }
 float radius = sqrt(diameter) * 0.5;
 if (radius > 0.0) {
   vClipCoefficient = getRadiusAdjustment(vec3(modelPosition[0], modelPosition[1], modelPosition[2]), radius);
 } else {
   vClipCoefficient = 1.0;
 }

 // vClipCoefficient = getSubspaceClipCoefficient(modelPosition);
 vColor = vec4(1.0, 0.0, 0.0, 0.5);
 // vColor = vec4(defaultColor(), 0.5);
 ${this.invokeUserMain}
 // float radius = diameter * 0.5;
 emitSphere(uModelViewProjection, uNormalTransform, projectModelVectorToSubspace(modelPosition), vec3(radius, radius, radius), uLightDirection);
 ${this.setPartIndex(builder)};
 `);
      builder.setFragmentMain(`
     vec4 color = vColor;
     color.a *= vClipCoefficient;
     emitAnnotation(color);
 `);
    });
  }
  defineShader(builder) {
    defineVertexId(builder);
    const rank = this.rank;
    defineVectorArrayVertexShaderInput(
      builder,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "VertexPosition",
      rank,
      2
    );
  }
  enable(shaderGetter, context, callback, usingVertexIdHelper = true) {
    super.enable(shaderGetter, context, (shader) => {
      const binder = shader.vertexShaderInputBinders["VertexPosition"];
      binder.enable(1);
      this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, context.buffer.buffer);
      binder.bind(this.serializedBytesPerAnnotation, context.bufferOffset);
      const vertexIdHelper = this.vertexIdHelper;
      if (usingVertexIdHelper) {
        vertexIdHelper.enable();
      }
      callback(shader);
      if (usingVertexIdHelper) {
        vertexIdHelper.disable();
      }
      binder.disable();
    });
  }
  drawEdges(context) {
    this.enable(this.edgeShaderGetter, context, (shader) => {
      initializeLineShader(
        shader,
        context.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      );
      drawLines(shader.gl, 1, context.count);
    });
  }
  drawEndpoints(context) {
    this.enable(this.endpointShaderGetter, context, (shader) => {
      initializeCircleShader(shader, context.renderContext.projectionParameters, { featherWidthInPixels: 0.5 });
      drawCircles(shader.gl, 2, context.count);
    });
  }
  drawSphere(context) {
    this.enable(this.sphereShadeGetter, context, (shader) => {
      this.sphereShader.draw(shader, context, context.count);
    }, false);
  }
  draw(context) {
    this.drawEdges(context);
    this.drawEndpoints(context);
    this.drawSphere(context);
  }
}
function snapPositionToLine(position, endpoints) {
  const rank = position.length;
  projectPointToLineSegment(position, endpoints.subarray(0, rank), endpoints.subarray(rank), position);
}
function snapPositionToEndpoint(position, endpoints, endpointIndex) {
  const rank = position.length;
  const startOffset = rank * endpointIndex;
  for (let i = 0; i < rank; ++i) {
    position[i] = endpoints[startOffset + i];
  }
}
registerAnnotationTypeRenderHandler(AnnotationType.SPHERE, {
  sliceViewRenderHelper: RenderHelper6,
  perspectiveViewRenderHelper: RenderHelper6,
  defineShaderNoOpSetters(builder) {
    defineNoOpEndpointMarkerSetters(builder);
    defineNoOpLineSetters(builder);
    defineNoOpSphereSetters(builder);
  },
  pickIdsPerInstance: PICK_IDS_PER_INSTANCE,
  snapPosition(position, data, offset, partIndex) {
    const rank = position.length;
    const endpoints = new Float32Array(data, offset, rank * 2);
    if (partIndex === FULL_OBJECT_PICK_OFFSET) {
      snapPositionToLine(position, endpoints);
    } else {
      snapPositionToEndpoint(position, endpoints, partIndex - ENDPOINTS_PICK_OFFSET);
    }
  },
  getRepresentativePoint(out, ann, partIndex) {
    out.set(partIndex === FULL_OBJECT_PICK_OFFSET || partIndex === ENDPOINTS_PICK_OFFSET ? ann.pointA : ann.pointB);
  },
  updateViaRepresentativePoint(oldAnnotation, position, partIndex) {
    let baseLine = _Object$assign({}, oldAnnotation);
    const rank = position.length;
    switch (partIndex) {
      case FULL_OBJECT_PICK_OFFSET: {
        const pointA = oldAnnotation.pointA, pointB = oldAnnotation.pointB;
        const newPointA = new Float32Array(rank);
        const newPointB = new Float32Array(rank);
        for (let i = 0; i < rank; ++i) {
          const pos = newPointA[i] = position[i];
          newPointB[i] = pointB[i] + (pos - pointA[i]);
        }
        return _Object$assign(_Object$assign({}, oldAnnotation), { pointA: newPointA, pointB: newPointB });
      }
      case FULL_OBJECT_PICK_OFFSET + 1:
        return _Object$assign(_Object$assign({}, oldAnnotation), { pointA: new Float32Array(position) });
      case FULL_OBJECT_PICK_OFFSET + 2:
        return _Object$assign(_Object$assign({}, oldAnnotation), { pointB: new Float32Array(position) });
    }
    return baseLine;
  }
});
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tempMat4$1 = create$4();
const tempVec3 = create$3();
function defineShaderCommon(builder) {
  builder.addUniform("highp vec3", "uTranslation");
  builder.addUniform("highp mat4", "uProjectionMatrix");
  builder.addUniform("highp vec3", "uChunkDataSize");
  builder.addUniform("highp vec3", "uLowerClipBound");
  builder.addUniform("highp vec3", "uUpperClipBound");
  builder.setFragmentMain(`
emit(vec4(1.0, 1.0, 1.0, getLineAlpha()), 0u);
`);
}
const projectionViewBoxWireFrameShader = {
  defineShader(builder) {
    defineShaderCommon(builder);
    defineLineShader(builder);
    builder.addVertexCode(`
const vec3[24] boxCornerOffsets = vec3[](
  vec3(0, 0, 0), vec3(0, 0, 1),  // e1
  vec3(1, 0, 0), vec3(1, 0, 1),  // e2
  vec3(0, 1, 0), vec3(0, 1, 1),  // e3
  vec3(1, 1, 0), vec3(1, 1, 1),  // e4
  vec3(0, 0, 0), vec3(0, 1, 0),  // e5
  vec3(0, 0, 1), vec3(0, 1, 1),  // e6
  vec3(1, 0, 0), vec3(1, 1, 0),  // e7
  vec3(1, 0, 1), vec3(1, 1, 1),  // e8
  vec3(0, 0, 0), vec3(1, 0, 0),  // e9
  vec3(0, 0, 1), vec3(1, 0, 1),  // e10
  vec3(0, 1, 0), vec3(1, 1, 0),  // e11
  vec3(0, 1, 1), vec3(1, 1, 1)  // e12
);
`);
    builder.setVertexMain(`
int edgeIndex = gl_VertexID / ${VERTICES_PER_LINE};
vec3 cornerA = max(uLowerClipBound, min(uUpperClipBound, uTranslation));
vec3 cornerB = max(uLowerClipBound, min(uUpperClipBound, uTranslation + uChunkDataSize));
vec3 vertexPosition1 = mix(cornerA, cornerB, boxCornerOffsets[edgeIndex * 2]);
vec3 vertexPosition2 = mix(cornerA, cornerB, boxCornerOffsets[edgeIndex * 2 + 1]);
emitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),
         uProjectionMatrix * vec4(vertexPosition2, 1.0),
         2.0);
`);
  },
  initialize(shader, projectionParameters) {
    initializeLineShader(
      shader,
      projectionParameters,
      /*featherWidthInPixels=*/
      1
    );
  },
  draw(shader, tsource, projectionParameters) {
    const gl = shader.gl;
    const modelViewProjection = tempMat4$1;
    const chunkLayout = tsource.chunkLayout;
    multiply$3(modelViewProjection, projectionParameters.viewProjectionMat, chunkLayout.transform);
    gl.uniformMatrix4fv(
      shader.uniform("uProjectionMatrix"),
      /*transpose=*/
      false,
      modelViewProjection
    );
    gl.uniform3fv(shader.uniform("uChunkDataSize"), chunkLayout.size);
    gl.uniform3fv(shader.uniform("uLowerClipBound"), tsource.lowerClipDisplayBound);
    gl.uniform3fv(shader.uniform("uUpperClipBound"), tsource.upperClipDisplayBound);
    const chunkSize = chunkLayout.size;
    const curPositionInChunks = tsource.curPositionInChunks, chunkDisplayDimensionIndices = tsource.chunkDisplayDimensionIndices;
    const curPosition = tempVec3;
    for (let i = 0; i < 3; ++i) {
      const chunkDim = chunkDisplayDimensionIndices[i];
      curPosition[i] = (chunkDim === -1 ? 0 : curPositionInChunks[chunkDim]) * chunkSize[i];
    }
    gl.uniform3fv(shader.uniform("uTranslation"), curPosition);
    drawLines(gl, EDGES_PER_BOX, 1);
  }
};
const crossSectionBoxWireFrameShader = {
  defineShader(builder) {
    defineBoundingBoxCrossSectionShader(builder);
    defineShaderCommon(builder);
    defineLineShader(builder);
    builder.setVertexMain(`
int vertexIndex1 = gl_VertexID / ${VERTICES_PER_LINE};
int vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;
vec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex1);
vec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex2);
emitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),
         uProjectionMatrix * vec4(vertexPosition2, 1.0),
         2.0);
`);
  },
  initialize(shader, projectionParameters) {
    initializeLineShader(
      shader,
      projectionParameters,
      /*featherWidthInPixels=*/
      1
    );
  },
  draw(shader, tsource, projectionParameters) {
    const gl = shader.gl;
    const modelViewProjection = tempMat4$1;
    const chunkLayout = tsource.chunkLayout;
    multiply$3(modelViewProjection, projectionParameters.viewProjectionMat, chunkLayout.transform);
    gl.uniformMatrix4fv(
      shader.uniform("uProjectionMatrix"),
      /*transpose=*/
      false,
      modelViewProjection
    );
    gl.uniform3fv(shader.uniform("uChunkDataSize"), chunkLayout.size);
    gl.uniform3fv(shader.uniform("uLowerClipBound"), tsource.lowerClipDisplayBound);
    gl.uniform3fv(shader.uniform("uUpperClipBound"), tsource.upperClipDisplayBound);
    const chunkSize = chunkLayout.size;
    const curPositionInChunks = tsource.curPositionInChunks, chunkDisplayDimensionIndices = tsource.chunkDisplayDimensionIndices;
    const curPosition = tempVec3;
    for (let i = 0; i < 3; ++i) {
      const chunkDim = chunkDisplayDimensionIndices[i];
      curPosition[i] = (chunkDim === -1 ? 0 : curPositionInChunks[chunkDim]) * chunkSize[i];
    }
    gl.uniform3fv(shader.uniform("uTranslation"), curPosition);
    setBoundingBoxCrossSectionShaderViewportPlane(shader, projectionParameters.viewportNormalInGlobalCoordinates, projectionParameters.centerDataPosition, chunkLayout.transform, chunkLayout.invTransform);
    drawLines(gl, 6, 1);
  }
};
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
const tempMat = create$4();
function segmentationFilter(segmentationStates) {
  if (segmentationStates === void 0) return void 0;
  return (annotation) => {
    const relatedSegments = annotation.relatedSegments;
    if (relatedSegments === void 0) {
      return false;
    }
    for (let i = 0, count = relatedSegments.length; i < count; ++i) {
      const segmentationState = segmentationStates[i];
      if (segmentationState == null) continue;
      var _segmentationState$se = segmentationState.segmentationGroupState.value;
      const visibleSegments = _segmentationState$se.visibleSegments, segmentEquivalences = _segmentationState$se.segmentEquivalences;
      for (const segment of relatedSegments[i]) {
        if (visibleSegments.has(segmentEquivalences.get(segment))) {
          return true;
        }
      }
    }
    return false;
  };
}
function serializeAnnotationSet(annotationSet, filter) {
  const serializer = new AnnotationSerializer(annotationSet.annotationPropertySerializers);
  for (const annotation of annotationSet) {
    if (filter === void 0 || filter(annotation)) {
      serializer.add(annotation);
    }
  }
  return serializer.serialize();
}
let AnnotationLayerSharedObject = class AnnotationLayerSharedObject2 extends withSharedVisibility(ChunkRenderLayerFrontend) {
  constructor(chunkManager, source, segmentationStates, chunkRenderLayer) {
    super(chunkRenderLayer);
    this.chunkManager = chunkManager;
    this.source = source;
    this.segmentationStates = segmentationStates;
    this.initializeCounterpart(this.chunkManager.rpc, {
      chunkManager: this.chunkManager.rpcId,
      source: source.rpcId,
      segmentationStates: this.serializeDisplayState()
    });
    const update = () => {
      const msg = { id: this.rpcId, segmentationStates: this.serializeDisplayState() };
      this.rpc.invoke(ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID, msg);
    };
    this.registerDisposer(segmentationStates.changed.add(update));
  }
  serializeDisplayState() {
    const segmentationStates = this.segmentationStates.value;
    if (segmentationStates === void 0) return void 0;
    return segmentationStates.map((segmentationState) => {
      if (segmentationState == null) return segmentationState;
      return sendVisibleSegmentsState(segmentationState.segmentationGroupState.value);
    });
  }
};
AnnotationLayerSharedObject = __decorate$3([registerSharedObjectOwner(ANNOTATION_RENDER_LAYER_RPC_ID)], AnnotationLayerSharedObject);
class AnnotationLayer extends RefCounted {
  constructor(chunkManager, state) {
    super();
    this.chunkManager = chunkManager;
    this.state = state;
    this.layerChunkProgressInfo = new LayerChunkProgressInfo();
    this.numPickIds = 0;
    this.generation = -1;
    this.redrawNeeded = new NullarySignal();
    this.serializedAnnotations = void 0;
    this.handleChangeAffectingBuffer = () => {
      this.generation = -1;
      this.redrawNeeded.dispatch();
    };
    this.segmentationStates = this.registerDisposer(makeCachedDerivedWatchableValue((_) => {
      var _state = this.state;
      const displayState2 = _state.displayState, source = _state.source;
      const relationshipStates = displayState2.relationshipStates;
      return displayState2.displayUnfiltered.value ? void 0 : source.relationships.map((relationship) => {
        const state2 = relationshipStates.get(relationship);
        return state2.showMatches.value ? state2.segmentationState.value : void 0;
      });
    }, [this.state.displayState.relationshipStates], (a, b) => {
      if (a === void 0 || b === void 0) {
        return a === b;
      }
      return arraysEqual(a, b);
    }));
    this.registerDisposer(state);
    this.registerDisposer(this.source.changed.add(this.handleChangeAffectingBuffer));
    this.registerDisposer(registerNested((context, segmentationStates) => {
      this.handleChangeAffectingBuffer();
      if (segmentationStates === void 0) return;
      for (const segmentationState of segmentationStates) {
        if (segmentationState == null) continue;
        context.registerDisposer(registerNestedSync((context2, group) => {
          context2.registerDisposer(group.visibleSegments.changed.add(() => this.handleChangeAffectingBuffer()));
          context2.registerDisposer(group.segmentEquivalences.changed.add(() => this.handleChangeAffectingBuffer()));
        }, segmentationState.segmentationGroupState));
      }
    }, this.segmentationStates));
    if (!(this.source instanceof AnnotationSource)) {
      this.sharedObject = this.registerDisposer(new AnnotationLayerSharedObject(chunkManager, this.source, this.segmentationStates, this.layerChunkProgressInfo));
    }
    const displayState = this.state.displayState;
    this.registerDisposer(displayState.color.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(displayState.shader.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(displayState.shaderControls.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(this.hoverState.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(this.transform.changed.add(this.redrawNeeded.dispatch));
  }
  get source() {
    return this.state.source;
  }
  get transform() {
    return this.state.transform;
  }
  get hoverState() {
    return this.state.displayState.hoverState;
  }
  get visibility() {
    const sharedObject = this.sharedObject;
    if (sharedObject === void 0) {
      return void 0;
    }
    return sharedObject.visibility;
  }
  get gl() {
    return this.chunkManager.gl;
  }
  updateBuffer() {
    const source = this.source;
    if (source instanceof AnnotationSource) {
      const generation = source.changed.count;
      if (this.generation !== generation) {
        let buffer = this.buffer;
        if (buffer === void 0) {
          buffer = this.buffer = this.registerDisposer(new Buffer(this.chunkManager.gl));
        }
        this.generation = generation;
        const serializedAnnotations = this.serializedAnnotations = serializeAnnotationSet(source, segmentationFilter(this.segmentationStates.value));
        buffer.setData(this.serializedAnnotations.data);
        this.numPickIds = computeNumPickIds(serializedAnnotations);
      }
    }
  }
}
function getAnnotationProjectionParameters(chunkDisplayTransform) {
  const chunkTransform = chunkDisplayTransform.chunkTransform;
  const unpaddedRank = chunkTransform.modelTransform.unpaddedRank;
  const modelClipBounds = new Float32Array(unpaddedRank * 2);
  const renderSubspaceTransform = new Float32Array(unpaddedRank * 3);
  renderSubspaceTransform.fill(0);
  modelClipBounds.fill(1, unpaddedRank);
  const numChunkDisplayDims = chunkDisplayTransform.numChunkDisplayDims, chunkDisplayDimensionIndices = chunkDisplayTransform.chunkDisplayDimensionIndices;
  for (let i = 0; i < numChunkDisplayDims; ++i) {
    const chunkDim = chunkDisplayDimensionIndices[i];
    modelClipBounds[unpaddedRank + chunkDim] = 0;
    renderSubspaceTransform[chunkDim * 3 + i] = 1;
  }
  return { modelClipBounds, renderSubspaceTransform };
}
function getChunkRenderParameters(chunkTransform, displayDimensionRenderInfo, messages) {
  messages.clearMessages();
  const returnError = (message) => {
    messages.addMessage({ severity: MessageSeverity.error, message });
    return void 0;
  };
  if (chunkTransform.error !== void 0) {
    return returnError(chunkTransform.error);
  }
  const layerRenderDimensionMapping = getLayerDisplayDimensionMapping(chunkTransform.modelTransform, displayDimensionRenderInfo.displayDimensionIndices);
  let chunkDisplayTransform;
  try {
    chunkDisplayTransform = getChunkDisplayTransformParameters(chunkTransform, layerRenderDimensionMapping);
  } catch (e) {
    return returnError(e.message);
  }
  var _getAnnotationProject = getAnnotationProjectionParameters(chunkDisplayTransform);
  const modelClipBounds = _getAnnotationProject.modelClipBounds, renderSubspaceTransform = _getAnnotationProject.renderSubspaceTransform;
  return { chunkTransform, chunkDisplayTransform, modelClipBounds, renderSubspaceTransform };
}
function AnnotationRenderLayer(Base2, renderHelperType) {
  class C extends Base2 {
    constructor(base, renderScaleHistogram) {
      super();
      this.base = base;
      this.renderScaleHistogram = renderScaleHistogram;
      this.curRank = -1;
      this.renderHelpers = [];
      this.isAnnotation = true;
      const baseVisibility = base.visibility;
      if (baseVisibility !== void 0) {
        this.registerDisposer(baseVisibility.add(this.visibility));
      }
      this.registerDisposer(this.renderScaleHistogram.visibility.add(this.visibility));
      this.registerDisposer(() => {
        for (const helper of this.renderHelpers) {
          helper.dispose();
        }
      });
      this.role = base.state.role;
      this.registerDisposer(base.redrawNeeded.add(this.redrawNeeded.dispatch));
      this.handleRankChanged();
    }
    handleRankChanged() {
      const rank = this.base.source.rank;
      if (rank === this.curRank) return;
      this.curRank = rank;
      this.tempChunkPosition = new Float32Array(rank);
      const renderHelpers = this.renderHelpers, gl = this.gl;
      for (const oldHelper of renderHelpers) {
        oldHelper.dispose();
      }
      const properties = this.base.source.properties;
      const displayState = this.base.state.displayState;
      for (const annotationType of annotationTypes) {
        const handler = getAnnotationTypeRenderHandler(annotationType);
        const renderHelperConstructor = handler[renderHelperType];
        const helper = renderHelpers[annotationType] = new renderHelperConstructor(gl, annotationType, rank, properties, displayState.shaderControls, displayState.fallbackShaderControls, displayState.shaderError);
        helper.pickIdsPerInstance = handler.pickIdsPerInstance;
        helper.targetIsSliceView = renderHelperType === "sliceViewRenderHelper";
      }
    }
    attach(attachment) {
      super.attach(attachment);
      this.handleRankChanged();
      const chunkTransform = this.chunkTransform;
      const displayDimensionRenderInfo = attachment.view.displayDimensionRenderInfo.value;
      attachment.state = {
        chunkTransform,
        displayDimensionRenderInfo,
        chunkRenderParameters: getChunkRenderParameters(chunkTransform, displayDimensionRenderInfo, attachment.messages)
      };
    }
    updateAttachmentState(attachment) {
      const state = attachment.state;
      this.handleRankChanged();
      const chunkTransform = this.chunkTransform;
      const displayDimensionRenderInfo = attachment.view.displayDimensionRenderInfo.value;
      if (state !== void 0 && state.chunkTransform === chunkTransform && state.displayDimensionRenderInfo === displayDimensionRenderInfo) {
        return state.chunkRenderParameters;
      }
      state.chunkTransform = chunkTransform;
      state.displayDimensionRenderInfo = displayDimensionRenderInfo;
      const chunkRenderParameters = state.chunkRenderParameters = getChunkRenderParameters(chunkTransform, displayDimensionRenderInfo, attachment.messages);
      return chunkRenderParameters;
    }
    get chunkTransform() {
      return this.base.state.chunkTransform.value;
    }
    updateModelClipBounds(renderContext, state) {
      const modelClipBounds = state.modelClipBounds;
      const rank = this.curRank;
      const chunkTransform = state.chunkTransform;
      getChunkPositionFromCombinedGlobalLocalPositions(modelClipBounds.subarray(0, rank), renderContext.projectionParameters.globalPosition, this.base.state.localPosition.value, chunkTransform.layerRank, chunkTransform.combinedGlobalLocalToChunkTransform);
    }
    get gl() {
      return this.base.chunkManager.gl;
    }
    drawGeometryChunkData(chunk, renderContext, state, drawFraction = 1) {
      if (!chunk.bufferValid) {
        let buffer = chunk.buffer;
        if (buffer === void 0) {
          buffer = chunk.buffer = new Buffer(this.gl);
        }
        const serializedAnnotations = chunk.serializedAnnotations;
        buffer.setData(serializedAnnotations.data);
        chunk.numPickIds = computeNumPickIds(serializedAnnotations);
        chunk.bufferValid = true;
      }
      this.drawGeometry(chunk, renderContext, state, drawFraction);
    }
    drawGeometry(chunk, renderContext, state, drawFraction = 1) {
      const base = this.base;
      const chunkDisplayTransform = state.chunkDisplayTransform;
      const serializedAnnotations = chunk.serializedAnnotations;
      const typeToIdMaps = serializedAnnotations.typeToIdMaps, typeToOffset = serializedAnnotations.typeToOffset;
      let pickId = 0;
      if (renderContext.emitPickID) {
        pickId = renderContext.pickIDs.register(this, chunk.numPickIds, 0, 0, chunk);
      }
      const hoverValue = base.hoverState.value;
      const modelViewProjectionMatrix = multiply$3(tempMat, renderContext.projectionParameters.viewProjectionMat, chunkDisplayTransform.displaySubspaceModelMatrix);
      const context = {
        annotationLayer: base,
        renderContext,
        selectedIndex: 0,
        basePickId: pickId,
        buffer: chunk.buffer,
        bufferOffset: 0,
        count: 0,
        modelViewProjectionMatrix,
        modelClipBounds: state.modelClipBounds,
        subspaceMatrix: state.renderSubspaceTransform,
        renderSubspaceModelMatrix: chunkDisplayTransform.displaySubspaceModelMatrix,
        renderSubspaceInvModelMatrix: chunkDisplayTransform.displaySubspaceInvModelMatrix,
        chunkDisplayTransform
      };
      for (const annotationType of annotationTypes) {
        const idMap = typeToIdMaps[annotationType];
        let count = idMap.size;
        if (count > 0) {
          const handler = getAnnotationTypeRenderHandler(annotationType);
          let selectedIndex = 4294967295;
          if (hoverValue !== void 0) {
            const index2 = idMap.get(hoverValue.id);
            if (index2 !== void 0) {
              selectedIndex = index2 * handler.pickIdsPerInstance;
            }
          }
          count = Math.round(count * drawFraction);
          context.count = count;
          context.bufferOffset = typeToOffset[annotationType];
          context.selectedIndex = selectedIndex;
          this.renderHelpers[annotationType].draw(context);
          context.basePickId += count * handler.pickIdsPerInstance;
        }
      }
    }
    updateMouseState(mouseState, _pickedValue, pickedOffset, data) {
      const chunk = data;
      const serializedAnnotations = chunk.serializedAnnotations;
      const typeToIds = serializedAnnotations.typeToIds, typeToOffset = serializedAnnotations.typeToOffset;
      const rank = this.curRank;
      const chunkTransform = this.chunkTransform;
      if (chunkTransform.error !== void 0) return;
      for (const annotationType of annotationTypes) {
        const ids = typeToIds[annotationType];
        const renderHandler = getAnnotationTypeRenderHandler(annotationType);
        const pickIdsPerInstance = renderHandler.pickIdsPerInstance;
        if (pickedOffset < ids.length * pickIdsPerInstance) {
          const instanceIndex = Math.floor(pickedOffset / pickIdsPerInstance);
          const id = ids[instanceIndex];
          const partIndex = pickedOffset % pickIdsPerInstance;
          mouseState.pickedAnnotationId = id;
          mouseState.pickedAnnotationLayer = this.base.state;
          mouseState.pickedOffset = partIndex;
          mouseState.pickedAnnotationBuffer = serializedAnnotations.data.buffer;
          mouseState.pickedAnnotationType = annotationType;
          mouseState.pickedAnnotationBufferBaseOffset = serializedAnnotations.data.byteOffset + typeToOffset[annotationType];
          mouseState.pickedAnnotationIndex = instanceIndex;
          mouseState.pickedAnnotationCount = ids.length;
          const chunkPosition = this.tempChunkPosition;
          const chunkToLayerTransform = chunkTransform.chunkToLayerTransform, combinedGlobalLocalToChunkTransform = chunkTransform.combinedGlobalLocalToChunkTransform, layerRank = chunkTransform.layerRank;
          const globalToRenderLayerDimensions = chunkTransform.modelTransform.globalToRenderLayerDimensions;
          const mousePosition = mouseState.position;
          if (!getChunkPositionFromCombinedGlobalLocalPositions(chunkPosition, mousePosition, this.base.state.localPosition.value, layerRank, combinedGlobalLocalToChunkTransform)) {
            return;
          }
          const propertySerializer = this.base.source.annotationPropertySerializers[annotationType];
          renderHandler.snapPosition(chunkPosition, mouseState.pickedAnnotationBuffer, mouseState.pickedAnnotationBufferBaseOffset + mouseState.pickedAnnotationIndex * propertySerializer.propertyGroupBytes[0], partIndex);
          const globalRank = globalToRenderLayerDimensions.length;
          for (let globalDim = 0; globalDim < globalRank; ++globalDim) {
            const layerDim = globalToRenderLayerDimensions[globalDim];
            if (layerDim === -1) continue;
            let sum = chunkToLayerTransform[(rank + 1) * rank + layerDim];
            for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
              sum += chunkPosition[chunkDim] * chunkToLayerTransform[chunkDim * (layerRank + 1) + layerDim];
            }
            if (!_Number$isFinite(sum)) {
              continue;
            }
            mousePosition[globalDim] = sum;
          }
          return;
        }
        pickedOffset -= ids.length * pickIdsPerInstance;
      }
    }
    transformPickedValue(pickState) {
      const pickedAnnotationBuffer = pickState.pickedAnnotationBuffer;
      if (pickedAnnotationBuffer === void 0) return void 0;
      const properties = this.base.source.properties;
      if (properties.length === 0) return void 0;
      const pickedAnnotationBufferBaseOffset = pickState.pickedAnnotationBufferBaseOffset, pickedAnnotationType = pickState.pickedAnnotationType, pickedAnnotationIndex = pickState.pickedAnnotationIndex, pickedAnnotationCount = pickState.pickedAnnotationCount;
      const annotationPropertySerializers = this.base.source.annotationPropertySerializers;
      const propertyValues = new Array(properties.length);
      annotationPropertySerializers[pickedAnnotationType].deserialize(
        new DataView(pickedAnnotationBuffer),
        pickedAnnotationBufferBaseOffset,
        pickedAnnotationIndex,
        pickedAnnotationCount,
        /*isLittleEndian=*/
        Endianness.LITTLE === ENDIANNESS,
        propertyValues
      );
      return formatAnnotationPropertyValue(properties[0], propertyValues[0]);
    }
    isReady() {
      const base = this.base;
      const source = base.source;
      if (!(source instanceof MultiscaleAnnotationSource)) {
        return true;
      }
      const segmentationStates = this.base.segmentationStates.value;
      if (segmentationStates === void 0) return true;
      for (let i = 0, count = segmentationStates.length; i < count; ++i) {
        const segmentationState = segmentationStates[i];
        if (segmentationState === null) return false;
        if (segmentationState === void 0) continue;
        const chunks = source.segmentFilteredSources[i].chunks;
        let missing = false;
        forEachVisibleSegment(segmentationState.segmentationGroupState.value, (objectId) => {
          const key = getObjectKey(objectId);
          if (!chunks.has(key)) {
            missing = true;
          }
        });
        if (missing) return false;
      }
      return true;
    }
  }
  return C;
}
const NonSpatiallyIndexedAnnotationRenderLayer = (Base2) => class C extends Base2 {
  constructor() {
    super(...arguments);
    this.layerChunkProgressInfo = this.base.layerChunkProgressInfo;
  }
  draw(renderContext, attachment) {
    const chunkRenderParameters = this.updateAttachmentState(attachment);
    if (this.curRank === 0 || chunkRenderParameters === void 0) return;
    this.updateModelClipBounds(renderContext, chunkRenderParameters);
    const source = this.base.source;
    if (source instanceof AnnotationSource) {
      const base = this.base;
      base.updateBuffer();
      this.drawGeometry(base, renderContext, chunkRenderParameters);
    } else {
      const renderScaleHistogram = this.renderScaleHistogram;
      renderScaleHistogram.begin(this.base.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
      this.drawGeometryChunkData(source.temporary.data, renderContext, chunkRenderParameters);
      const segmentationStates = this.base.segmentationStates.value;
      let presentChunks = 0;
      let notPresentChunks = 0;
      if (segmentationStates !== void 0) {
        for (let i = 0, count = segmentationStates.length; i < count; ++i) {
          const segmentationState = segmentationStates[i];
          if (segmentationState == null) continue;
          const chunks = source.segmentFilteredSources[i].chunks;
          forEachVisibleSegment(segmentationState.segmentationGroupState.value, (objectId) => {
            const key = getObjectKey(objectId);
            const chunk = chunks.get(key);
            if (chunk !== void 0 && chunk.state === ChunkState.GPU_MEMORY) {
              const data = chunk.data;
              if (data === void 0) return;
              this.drawGeometryChunkData(data, renderContext, chunkRenderParameters);
              ++presentChunks;
            } else {
              ++notPresentChunks;
            }
          });
        }
      }
      renderScaleHistogram.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, presentChunks, notPresentChunks);
    }
  }
};
const PerspectiveViewAnnotationLayerBase = AnnotationRenderLayer(PerspectiveViewRenderLayer, "perspectiveViewRenderHelper");
class PerspectiveViewAnnotationLayer extends NonSpatiallyIndexedAnnotationRenderLayer(PerspectiveViewAnnotationLayerBase) {
}
const SpatiallyIndexedAnnotationLayer = (Base2) => {
  class SpatiallyIndexedAnnotationLayer2 extends Base2 {
    constructor(options) {
      super(options.annotationLayer, options.renderScaleHistogram);
      this.wireFrameRenderHelper = this instanceof SliceViewPanelRenderLayer ? crossSectionBoxWireFrameShader : projectionViewBoxWireFrameShader;
      this.wireFrameShaderGetter = parameterizedEmitterDependentShaderGetter(this, this.gl, {
        memoizeKey: `annotation/wireFrameShader:${this instanceof SliceViewPanelRenderLayer}`,
        parameters: constantWatchableValue(void 0),
        defineShader: (builder) => {
          this.wireFrameRenderHelper.defineShader(builder);
        }
      });
      this.renderScaleTarget = options.renderScaleTarget;
      this.registerDisposer(this.renderScaleTarget.changed.add(this.redrawNeeded.dispatch));
      const sharedObject = this.registerDisposer(new ChunkRenderLayerFrontend(this.layerChunkProgressInfo));
      const rpc = this.base.chunkManager.rpc;
      sharedObject.RPC_TYPE_ID = ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID;
      sharedObject.initializeCounterpart(rpc, {
        chunkManager: this.base.chunkManager.rpcId,
        localPosition: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.base.state.localPosition)).rpcId,
        renderScaleTarget: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.renderScaleTarget)).rpcId
      });
      this.backend = sharedObject;
    }
    attach(attachment) {
      super.attach(attachment);
      attachment.state.sources = attachment.registerDisposer(registerNested((context, transform, displayDimensionRenderInfo) => {
        const transformedSources = getVolumetricTransformedSources(displayDimensionRenderInfo, transform, (options) => this.base.state.source.getSources(options), attachment.messages, this);
        for (const scales of transformedSources) {
          for (const tsource of scales) {
            context.registerDisposer(tsource.source);
            _Object$assign(tsource, getAnnotationProjectionParameters(tsource.chunkDisplayTransform));
          }
        }
        attachment.view.flushBackendProjectionParameters();
        this.backend.rpc.invoke(ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, {
          layer: this.backend.rpcId,
          view: attachment.view.rpcId,
          displayDimensionRenderInfo,
          sources: serializeAllTransformedSources(transformedSources)
        });
        this.redrawNeeded.dispatch();
        return transformedSources;
      }, this.base.state.transform, attachment.view.displayDimensionRenderInfo));
    }
    draw(renderContext, attachment) {
      const chunkRenderParameters = this.updateAttachmentState(attachment);
      if (this.curRank === 0 || chunkRenderParameters === void 0) return;
      const transformedSources = attachment.state.sources.value;
      if (transformedSources.length === 0) return;
      this.updateModelClipBounds(renderContext, chunkRenderParameters);
      const renderScaleHistogram = this.renderScaleHistogram;
      renderScaleHistogram.begin(this.base.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
      const projectionParameters = renderContext.projectionParameters;
      let wireFrameShader;
      if (renderContext.wireFrame) {
        var _wireFrameShaderGette = this.wireFrameShaderGetter(renderContext.emitter);
        const shader = _wireFrameShaderGette.shader;
        if (shader === null) return;
        shader.bind();
        this.wireFrameRenderHelper.initialize(shader, projectionParameters);
        wireFrameShader = shader;
      }
      forEachVisibleAnnotationChunk(projectionParameters, this.base.state.localPosition.value, this.renderScaleTarget.value, transformedSources[0], () => {
      }, (tsource, index2, drawFraction, physicalSpacing, pixelSpacing) => {
        const chunk = tsource.source.chunks.get(tsource.curPositionInChunks.join());
        let present;
        if (chunk === void 0 || chunk.state !== ChunkState.GPU_MEMORY) {
          present = 0;
        } else {
          const data = chunk.data;
          if (data === void 0) {
            return;
          }
          if (wireFrameShader !== void 0) {
            this.wireFrameRenderHelper.draw(wireFrameShader, tsource, projectionParameters);
          } else {
            this.drawGeometryChunkData(data, renderContext, chunkRenderParameters, drawFraction);
          }
          present = 1;
        }
        renderScaleHistogram.add(physicalSpacing, pixelSpacing, present, 1 - present);
      });
    }
  }
  return SpatiallyIndexedAnnotationLayer2;
};
const SpatiallyIndexedPerspectiveViewAnnotationLayer = SpatiallyIndexedAnnotationLayer(PerspectiveViewAnnotationLayerBase);
const SpatiallyIndexedSliceViewAnnotationLayer = SpatiallyIndexedAnnotationLayer(AnnotationRenderLayer(SliceViewPanelRenderLayer, "sliceViewRenderHelper"));
const SliceViewAnnotationLayer = NonSpatiallyIndexedAnnotationRenderLayer(AnnotationRenderLayer(SliceViewPanelRenderLayer, "sliceViewRenderHelper"));
class MergedAnnotationStates extends RefCounted {
  constructor() {
    super(...arguments);
    this.changed = new NullarySignal();
    this.isLoadingChanged = new NullarySignal();
    this.states = [];
    this.relationships = [];
    this.loadingCount = 0;
  }
  get value() {
    return this.states;
  }
  get isLoading() {
    return this.loadingCount !== 0;
  }
  markLoading() {
    this.loadingCount++;
    return () => {
      if (--this.loadingCount === 0) {
        this.isLoadingChanged.dispatch();
      }
    };
  }
  sort() {
    this.states.sort((a, b) => {
      let d = a.sourceIndex - b.sourceIndex;
      if (d !== 0) return d;
      return a.subsourceIndex - b.subsourceIndex;
    });
  }
  updateRelationships() {
    const newRelationships = new _Set();
    for (const state of this.states) {
      for (const relationship of state.source.relationships) {
        newRelationships.add(relationship);
      }
    }
    this.relationships = _Array$from(newRelationships);
  }
  add(state) {
    this.states.push(state);
    this.sort();
    this.updateRelationships();
    this.changed.dispatch();
    return () => {
      const index2 = this.states.indexOf(state);
      this.states.splice(index2, 1);
      this.updateRelationships();
      this.changed.dispatch();
    };
  }
}
function getCenterPosition(center, annotation) {
  switch (annotation.type) {
    case AnnotationType.AXIS_ALIGNED_BOUNDING_BOX:
    case AnnotationType.LINE:
    case AnnotationType.SPHERE:
      add(center, annotation.pointA, annotation.pointB);
      scale(center, center, 0.5);
      break;
    case AnnotationType.POINT:
      center.set(annotation.point);
      break;
    case AnnotationType.ELLIPSOID:
      center.set(annotation.center);
      break;
  }
}
function setLayerPosition(layer, chunkTransform, layerPosition) {
  if (chunkTransform.error !== void 0) return;
  layer.setLayerPosition(chunkTransform.modelTransform, layerPosition);
}
function visitTransformedAnnotationGeometry(annotation, chunkTransform, callback) {
  const layerRank = chunkTransform.layerRank;
  const paddedChunkPosition = new Float32Array(layerRank);
  annotationTypeHandlers[annotation.type].visitGeometry(annotation, (chunkPosition, isVector) => {
    paddedChunkPosition.set(chunkPosition);
    const layerPosition = new Float32Array(layerRank);
    (isVector ? transformVector : transformPoint)(layerPosition, chunkTransform.chunkToLayerTransform, layerRank + 1, paddedChunkPosition, layerRank);
    callback(layerPosition, isVector);
  });
}
class AnnotationLayerView extends Tab {
  constructor(layer, displayState) {
    super();
    this.layer = layer;
    this.displayState = displayState;
    this.previousSelectedState = void 0;
    this.previousHoverId = void 0;
    this.previousHoverAnnotationLayerState = void 0;
    this.virtualListSource = {
      length: 0,
      render: (index2) => this.render(index2),
      changed: new Signal()
    };
    this.virtualList = new VirtualList({ source: this.virtualListSource });
    this.listElements = [];
    this.updated = false;
    this.mutableControls = document.createElement("div");
    this.headerRow = document.createElement("div");
    this.attachedAnnotationStates = new _Map();
    this.forceUpdateView = () => {
      this.updated = false;
      this.updateView();
    };
    this.globalDimensionIndices = [];
    this.localDimensionIndices = [];
    this.curCoordinateSpaceGeneration = -1;
    this.prevCoordinateSpaceGeneration = -1;
    this.columnWidths = [];
    this.gridTemplate = "";
    this.selectedAnnotationState = makeCachedLazyDerivedWatchableValue((selectionState, pin) => {
      var _a;
      if (selectionState === void 0) return void 0;
      const layer2 = this.layer;
      const layerSelectionState = (_a = selectionState.layers.find((s) => s.layer === layer2)) === null || _a === void 0 ? void 0 : _a.state;
      if (layerSelectionState === void 0) return void 0;
      const annotationId = layerSelectionState.annotationId;
      if (annotationId === void 0) return void 0;
      const annotationLayerState = this.annotationStates.states.find((x) => x.sourceIndex === layerSelectionState.annotationSourceIndex && (layerSelectionState.annotationSubsource === void 0 || x.subsourceId === layerSelectionState.annotationSubsource));
      if (annotationLayerState === void 0) return void 0;
      return { annotationId, annotationLayerState, pin };
    }, this.layer.manager.root.selectionState, this.layer.manager.root.selectionState.pin);
    this.element.classList.add("neuroglancer-annotation-layer-view");
    this.registerDisposer(this.visibility.changed.add(() => this.updateView()));
    this.registerDisposer(layer.annotationStates.changed.add(() => this.updateAttachedAnnotationLayerStates()));
    this.headerRow.classList.add("neuroglancer-annotation-list-header");
    const toolbox = document.createElement("div");
    toolbox.className = "neuroglancer-annotation-toolbox";
    layer.initializeAnnotationLayerViewTab(this);
    const colorPicker = this.registerDisposer(new ColorWidget(this.displayState.color));
    colorPicker.element.title = "Change annotation display color";
    this.registerDisposer(new ElementVisibilityFromTrackableBoolean(makeCachedLazyDerivedWatchableValue((shader) => shader.match(/\bdefaultColor\b/) !== null, displayState.shaderControls.processedFragmentMain), colorPicker.element));
    toolbox.appendChild(colorPicker.element);
    const mutableControls = this.mutableControls;
    const pointButton = makeIcon({
      text: annotationTypeHandlers[AnnotationType.POINT].icon,
      title: "Annotate point",
      onClick: () => {
        this.layer.tool.value = new PlacePointTool(this.layer, {});
      }
    });
    mutableControls.appendChild(pointButton);
    const boundingBoxButton = makeIcon({
      text: annotationTypeHandlers[AnnotationType.AXIS_ALIGNED_BOUNDING_BOX].icon,
      title: "Annotate bounding box",
      onClick: () => {
        this.layer.tool.value = new PlaceBoundingBoxTool(this.layer, {});
      }
    });
    mutableControls.appendChild(boundingBoxButton);
    const lineButton = makeIcon({
      text: annotationTypeHandlers[AnnotationType.LINE].icon,
      title: "Annotate line",
      onClick: () => {
        this.layer.tool.value = new PlaceLineTool(this.layer, {});
      }
    });
    mutableControls.appendChild(lineButton);
    const sphereButton = makeIcon({
      text: annotationTypeHandlers[AnnotationType.SPHERE].icon,
      title: "Annotate Sphere",
      onClick: () => {
        this.layer.tool.value = new PlaceSphereTool(this.layer, {});
      }
    });
    mutableControls.appendChild(sphereButton);
    const ellipsoidButton = makeIcon({
      text: annotationTypeHandlers[AnnotationType.ELLIPSOID].icon,
      title: "Annotate ellipsoid",
      onClick: () => {
        this.layer.tool.value = new PlaceEllipsoidTool(this.layer, {});
      }
    });
    mutableControls.appendChild(ellipsoidButton);
    toolbox.appendChild(mutableControls);
    this.element.appendChild(toolbox);
    this.element.appendChild(this.headerRow);
    const virtualList = this.virtualList;
    virtualList.element.classList.add("neuroglancer-annotation-list");
    this.element.appendChild(virtualList.element);
    this.virtualList.element.addEventListener("mouseleave", () => {
      this.displayState.hoverState.value = void 0;
    });
    const bindings = getDefaultAnnotationListBindings();
    this.registerDisposer(new MouseEventBinder(this.virtualList.element, bindings));
    this.virtualList.element.title = bindings.describe();
    this.registerDisposer(this.displayState.hoverState.changed.add(() => this.updateHoverView()));
    this.registerDisposer(this.selectedAnnotationState.changed.add(() => this.updateSelectionView()));
    this.registerDisposer(this.layer.localCoordinateSpace.changed.add(() => {
      this.updateCoordinateSpace();
      this.updateView();
    }));
    this.registerDisposer(this.layer.manager.root.coordinateSpace.changed.add(() => {
      this.updateCoordinateSpace();
      this.updateView();
    }));
    this.updateCoordinateSpace();
    this.updateAttachedAnnotationLayerStates();
    this.updateSelectionView();
  }
  get annotationStates() {
    return this.layer.annotationStates;
  }
  updateAttachedAnnotationLayerStates() {
    const states = this.annotationStates.states;
    const attachedAnnotationStates = this.attachedAnnotationStates;
    const newAttachedAnnotationStates = new _Map();
    for (const _ref of attachedAnnotationStates) {
      var _ref2 = _slicedToArray(_ref, 2);
      const state = _ref2[0];
      const info = _ref2[1];
      if (!states.includes(state)) {
        attachedAnnotationStates.delete(state);
        info.refCounted.dispose();
      }
    }
    for (const state of states) {
      const info = attachedAnnotationStates.get(state);
      if (info !== void 0) {
        newAttachedAnnotationStates.set(state, info);
        continue;
      }
      const source = state.source;
      const refCounted = new RefCounted();
      if (source instanceof AnnotationSource || source instanceof MultiscaleAnnotationSource) {
        refCounted.registerDisposer(source.childAdded.add((annotation) => this.addAnnotationElement(annotation, state)));
        refCounted.registerDisposer(source.childUpdated.add((annotation) => this.updateAnnotationElement(annotation, state)));
        refCounted.registerDisposer(source.childDeleted.add((annotationId) => this.deleteAnnotationElement(annotationId, state)));
        refCounted.registerDisposer(source.childRefreshed.add(() => this.clearAnnotationElement(state)));
      }
      refCounted.registerDisposer(state.transform.changed.add(this.forceUpdateView));
      newAttachedAnnotationStates.set(state, { refCounted, annotations: [], idToIndex: new _Map(), listOffset: 0 });
    }
    this.attachedAnnotationStates = newAttachedAnnotationStates;
    attachedAnnotationStates.clear();
    this.updateCoordinateSpace();
    this.forceUpdateView();
  }
  updateCoordinateSpace() {
    const localCoordinateSpace = this.layer.localCoordinateSpace.value;
    const globalCoordinateSpace = this.layer.manager.root.coordinateSpace.value;
    const globalDimensionIndices = [];
    const localDimensionIndices = [];
    for (let globalDim = 0, globalRank = globalCoordinateSpace.rank; globalDim < globalRank; ++globalDim) {
      if (this.annotationStates.states.some((state) => {
        const transform = state.transform.value;
        if (transform.error !== void 0) return false;
        return transform.globalToRenderLayerDimensions[globalDim] !== -1;
      })) {
        globalDimensionIndices.push(globalDim);
      }
    }
    for (let localDim = 0, localRank = localCoordinateSpace.rank; localDim < localRank; ++localDim) {
      if (this.annotationStates.states.some((state) => {
        const transform = state.transform.value;
        if (transform.error !== void 0) return false;
        return transform.localToRenderLayerDimensions[localDim] !== -1;
      })) {
        localDimensionIndices.push(localDim);
      }
    }
    if (!arraysEqual(globalDimensionIndices, this.globalDimensionIndices) || !arraysEqual(localDimensionIndices, this.localDimensionIndices)) {
      this.localDimensionIndices = localDimensionIndices;
      this.globalDimensionIndices = globalDimensionIndices;
      ++this.curCoordinateSpaceGeneration;
    }
  }
  getRenderedAnnotationListElement(state, id, scrollIntoView = false) {
    const attached = this.attachedAnnotationStates.get(state);
    if (attached == void 0) return void 0;
    const index2 = attached.idToIndex.get(id);
    if (index2 === void 0) return void 0;
    const listIndex = attached.listOffset + index2;
    if (scrollIntoView) {
      this.virtualList.scrollItemIntoView(index2);
    }
    return this.virtualList.getItemElement(listIndex);
  }
  clearSelectionClass() {
    const state = this.previousSelectedState;
    if (state === void 0) return;
    this.previousSelectedState = void 0;
    const element = this.getRenderedAnnotationListElement(state.annotationLayerState, state.annotationId);
    if (element !== void 0) {
      element.classList.remove("neuroglancer-annotation-selected");
    }
  }
  clearHoverClass() {
    const previousHoverId = this.previousHoverId, previousHoverAnnotationLayerState = this.previousHoverAnnotationLayerState;
    if (previousHoverAnnotationLayerState !== void 0) {
      this.previousHoverAnnotationLayerState = void 0;
      this.previousHoverId = void 0;
      const element = this.getRenderedAnnotationListElement(previousHoverAnnotationLayerState, previousHoverId);
      if (element !== void 0) {
        element.classList.remove("neuroglancer-annotation-hover");
      }
    }
  }
  updateSelectionView() {
    const selectionState = this.selectedAnnotationState.value;
    const previousSelectedState = this.previousSelectedState;
    if (previousSelectedState === selectionState || previousSelectedState !== void 0 && selectionState !== void 0 && previousSelectedState.annotationId === selectionState.annotationId && previousSelectedState.annotationLayerState === selectionState.annotationLayerState && previousSelectedState.pin === selectionState.pin) {
      return;
    }
    this.clearSelectionClass();
    this.previousSelectedState = selectionState;
    if (selectionState === void 0) return;
    const element = this.getRenderedAnnotationListElement(
      selectionState.annotationLayerState,
      selectionState.annotationId,
      /*scrollIntoView=*/
      selectionState.pin
    );
    if (element !== void 0) {
      element.classList.add("neuroglancer-annotation-selected");
    }
  }
  updateHoverView() {
    const selectedValue = this.displayState.hoverState.value;
    let newHoverId;
    let newAnnotationLayerState;
    if (selectedValue !== void 0) {
      newHoverId = selectedValue.id;
      newAnnotationLayerState = selectedValue.annotationLayerState;
    }
    const previousHoverId = this.previousHoverId, previousHoverAnnotationLayerState = this.previousHoverAnnotationLayerState;
    if (newHoverId === previousHoverId && newAnnotationLayerState === previousHoverAnnotationLayerState) {
      return;
    }
    this.clearHoverClass();
    this.previousHoverId = newHoverId;
    this.previousHoverAnnotationLayerState = newAnnotationLayerState;
    if (newHoverId === void 0) return;
    const element = this.getRenderedAnnotationListElement(newAnnotationLayerState, newHoverId);
    if (element === void 0) return;
    element.classList.add("neuroglancer-annotation-hover");
  }
  render(index2) {
    var _listElements$index = this.listElements[index2];
    const annotation = _listElements$index.annotation, state = _listElements$index.state;
    return this.makeAnnotationListElement(annotation, state);
  }
  setColumnWidth(column, width) {
    width += 2;
    const columnWidths = this.columnWidths;
    if (columnWidths[column] > width) {
      return;
    }
    columnWidths[column] = width;
    this.element.style.setProperty(`--neuroglancer-column-${column}-width`, `${width}ch`);
  }
  updateView() {
    if (!this.visible) {
      return;
    }
    if (this.curCoordinateSpaceGeneration !== this.prevCoordinateSpaceGeneration) {
      this.updated = false;
      const columnWidths = this.columnWidths;
      columnWidths.length = 0;
      const headerRow = this.headerRow;
      const symbolPlaceholder = document.createElement("div");
      symbolPlaceholder.style.gridColumn = `symbol`;
      const deletePlaceholder = document.createElement("div");
      deletePlaceholder.style.gridColumn = `delete`;
      removeChildren(headerRow);
      headerRow.appendChild(symbolPlaceholder);
      let i = 0;
      let gridTemplate = "[symbol] 2ch";
      const addDimension = (coordinateSpace, dimIndex) => {
        const dimWidget = document.createElement("div");
        dimWidget.classList.add("neuroglancer-annotations-view-dimension");
        const name2 = document.createElement("span");
        name2.classList.add("neuroglancer-annotations-view-dimension-name");
        name2.textContent = coordinateSpace.names[dimIndex];
        const scale2 = document.createElement("scale");
        scale2.classList.add("neuroglancer-annotations-view-dimension-scale");
        scale2.textContent = formatScaleWithUnitAsString(coordinateSpace.scales[dimIndex], coordinateSpace.units[dimIndex], { precision: 2 });
        dimWidget.appendChild(name2);
        dimWidget.appendChild(scale2);
        dimWidget.style.gridColumn = `dim ${i + 1}`;
        this.setColumnWidth(i, scale2.textContent.length + name2.textContent.length + 3);
        gridTemplate += ` [dim] var(--neuroglancer-column-${i}-width)`;
        ++i;
        headerRow.appendChild(dimWidget);
      };
      const globalCoordinateSpace = this.layer.manager.root.coordinateSpace.value;
      for (const globalDim of this.globalDimensionIndices) {
        addDimension(globalCoordinateSpace, globalDim);
      }
      const localCoordinateSpace = this.layer.localCoordinateSpace.value;
      for (const localDim of this.localDimensionIndices) {
        addDimension(localCoordinateSpace, localDim);
      }
      headerRow.appendChild(deletePlaceholder);
      gridTemplate += ` [delete] 2ch`;
      this.gridTemplate = gridTemplate;
      headerRow.style.gridTemplateColumns = gridTemplate;
      this.prevCoordinateSpaceGeneration = this.curCoordinateSpaceGeneration;
    }
    if (this.updated) {
      return;
    }
    let isMutable = false;
    const listElements = this.listElements;
    listElements.length = 0;
    for (const _ref3 of this.attachedAnnotationStates) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const state = _ref4[0];
      const info = _ref4[1];
      if (!state.source.readonly) isMutable = true;
      if (state.chunkTransform.value.error !== void 0) continue;
      const source = state.source;
      const annotations = _Array$from(source);
      info.annotations = annotations;
      const idToIndex = info.idToIndex;
      idToIndex.clear();
      for (let i = 0, length2 = annotations.length; i < length2; ++i) {
        idToIndex.set(annotations[i].id, i);
      }
      for (const annotation of annotations) {
        listElements.push({ state, annotation });
      }
    }
    const oldLength = this.virtualListSource.length;
    this.updateListLength();
    this.virtualListSource.changed.dispatch([{ retainCount: 0, deleteCount: oldLength, insertCount: listElements.length }]);
    this.mutableControls.style.display = isMutable ? "contents" : "none";
    this.resetOnUpdate();
  }
  updateListLength() {
    let length2 = 0;
    for (const info of this.attachedAnnotationStates.values()) {
      info.listOffset = length2;
      length2 += info.annotations.length;
    }
    this.virtualListSource.length = length2;
  }
  clearAnnotationElement(state) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const info = this.attachedAnnotationStates.get(state);
    if (info !== void 0) {
      const index2 = info.annotations.length;
      info.annotations = [];
      info.idToIndex.clear();
      this.listElements = [];
      this.updateListLength();
      this.virtualListSource.changed.dispatch([{ retainCount: 0, deleteCount: index2, insertCount: 0 }]);
    }
    this.resetOnUpdate();
  }
  addAnnotationElement(annotation, state) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const info = this.attachedAnnotationStates.get(state);
    if (info !== void 0) {
      const index2 = info.annotations.length;
      info.annotations.push(annotation);
      info.idToIndex.set(annotation.id, index2);
      const spliceStart = info.listOffset + index2;
      this.listElements.splice(spliceStart, 0, { state, annotation });
      this.updateListLength();
      this.virtualListSource.changed.dispatch([{ retainCount: spliceStart, deleteCount: 0, insertCount: 1 }]);
    }
    this.resetOnUpdate();
  }
  updateAnnotationElement(annotation, state) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const info = this.attachedAnnotationStates.get(state);
    if (info !== void 0) {
      const index2 = info.idToIndex.get(annotation.id);
      if (index2 !== void 0) {
        const updateStart = info.listOffset + index2;
        info.annotations[index2] = annotation;
        this.listElements[updateStart].annotation = annotation;
        this.virtualListSource.changed.dispatch([{ retainCount: updateStart, deleteCount: 1, insertCount: 1 }]);
      }
    }
    this.resetOnUpdate();
  }
  deleteAnnotationElement(annotationId, state) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const info = this.attachedAnnotationStates.get(state);
    if (info !== void 0) {
      const idToIndex = info.idToIndex;
      const index2 = idToIndex.get(annotationId);
      if (index2 !== void 0) {
        const spliceStart = info.listOffset + index2;
        const annotations = info.annotations;
        annotations.splice(index2, 1);
        idToIndex.delete(annotationId);
        for (let i = index2, length2 = annotations.length; i < length2; ++i) {
          idToIndex.set(annotations[i].id, i);
        }
        this.listElements.splice(spliceStart, 1);
        this.updateListLength();
        this.virtualListSource.changed.dispatch([{ retainCount: spliceStart, deleteCount: 1, insertCount: 0 }]);
      }
    }
    this.resetOnUpdate();
  }
  resetOnUpdate() {
    this.clearHoverClass();
    this.clearSelectionClass();
    this.updated = true;
    this.updateHoverView();
    this.updateSelectionView();
  }
  makeAnnotationListElement(annotation, state) {
    const chunkTransform = state.chunkTransform.value;
    const element = document.createElement("div");
    element.classList.add("neuroglancer-annotation-list-entry");
    element.style.gridTemplateColumns = this.gridTemplate;
    const icon = document.createElement("div");
    icon.className = "neuroglancer-annotation-icon";
    icon.textContent = annotationTypeHandlers[annotation.type].icon;
    element.appendChild(icon);
    let deleteButton;
    const maybeAddDeleteButton = () => {
      if (state.source.readonly) return;
      if (deleteButton !== void 0) return;
      deleteButton = makeDeleteButton({
        title: "Delete annotation",
        onClick: (event) => {
          event.stopPropagation();
          event.preventDefault();
          const ref = state.source.getReference(annotation.id);
          try {
            state.source.delete(ref);
          } finally {
            ref.dispose();
          }
        }
      });
      deleteButton.classList.add("neuroglancer-annotation-list-entry-delete");
      element.appendChild(deleteButton);
    };
    let numRows = 0;
    visitTransformedAnnotationGeometry(annotation, chunkTransform, (layerPosition, isVector) => {
      ++numRows;
      const position = document.createElement("div");
      position.className = "neuroglancer-annotation-position";
      element.appendChild(position);
      let i = 0;
      const addDims = (viewDimensionIndices, layerDimensionIndices) => {
        for (const viewDim of viewDimensionIndices) {
          const layerDim = layerDimensionIndices[viewDim];
          if (layerDim !== -1) {
            const coord = Math.floor(layerPosition[layerDim]);
            const coordElement = document.createElement("div");
            const text = coord.toString();
            coordElement.textContent = text;
            coordElement.classList.add("neuroglancer-annotation-coordinate");
            coordElement.style.gridColumn = `dim ${i + 1}`;
            this.setColumnWidth(i, text.length);
            position.appendChild(coordElement);
          }
          ++i;
        }
      };
      addDims(this.globalDimensionIndices, chunkTransform.modelTransform.globalToRenderLayerDimensions);
      addDims(this.localDimensionIndices, chunkTransform.modelTransform.localToRenderLayerDimensions);
      maybeAddDeleteButton();
    });
    if (annotation.description) {
      ++numRows;
      const description = document.createElement("div");
      description.classList.add("neuroglancer-annotation-description");
      description.textContent = annotation.description;
      element.appendChild(description);
    }
    icon.style.gridRow = `span ${numRows}`;
    if (deleteButton !== void 0) {
      deleteButton.style.gridRow = `span ${numRows}`;
    }
    element.addEventListener("mouseenter", () => {
      this.displayState.hoverState.value = {
        id: annotation.id,
        partIndex: 0,
        annotationLayerState: state
      };
      this.layer.selectAnnotation(state, annotation.id, false);
    });
    element.addEventListener("action:select-position", (event) => {
      event.stopPropagation();
      this.layer.selectAnnotation(state, annotation.id, "toggle");
    });
    element.addEventListener("action:pin-annotation", (event) => {
      event.stopPropagation();
      this.layer.selectAnnotation(state, annotation.id, true);
    });
    element.addEventListener("action:move-to-annotation", (event) => {
      event.stopPropagation();
      event.preventDefault();
      const layerRank = chunkTransform.layerRank;
      const chunkPosition = new Float32Array(layerRank);
      const layerPosition = new Float32Array(layerRank);
      getCenterPosition(chunkPosition, annotation);
      transformPoint(layerPosition, chunkTransform.chunkToLayerTransform, layerRank + 1, chunkPosition, layerRank);
      setLayerPosition(this.layer, chunkTransform, layerPosition);
    });
    const selectionState = this.selectedAnnotationState.value;
    if (selectionState !== void 0 && selectionState.annotationLayerState === state && selectionState.annotationId === annotation.id) {
      element.classList.add("neuroglancer-annotation-selected");
    }
    return element;
  }
}
class AnnotationTab extends Tab {
  constructor(layer) {
    super();
    this.layer = layer;
    this.layerView = this.registerDisposer(new AnnotationLayerView(this.layer, this.layer.annotationDisplayState));
    const element = this.element;
    element.classList.add("neuroglancer-annotations-tab");
    element.appendChild(this.layerView.element);
  }
}
function getSelectedAssociatedSegments(annotationLayer) {
  let segments = [];
  const relationships = annotationLayer.source.relationships;
  const relationshipStates = annotationLayer.displayState.relationshipStates;
  for (let i = 0, count = relationships.length; i < count; ++i) {
    const segmentationState = relationshipStates.get(relationships[i]).segmentationState.value;
    if (segmentationState != null) {
      if (segmentationState.segmentSelectionState.hasSelectedSegment) {
        segments[i] = [segmentationState.segmentSelectionState.selectedSegment.clone()];
        continue;
      }
    }
    segments[i] = [];
  }
  return segments;
}
class PlaceAnnotationTool extends LegacyTool {
  constructor(layer, options) {
    super(layer);
  }
  get annotationLayer() {
    for (const state of this.layer.annotationStates.states) {
      if (!state.source.readonly) return state;
    }
    return void 0;
  }
}
const ANNOTATE_POINT_TOOL_ID = "annotatePoint";
const ANNOTATE_LINE_TOOL_ID = "annotateLine";
const ANNOTATE_BOUNDING_BOX_TOOL_ID = "annotateBoundingBox";
const ANNOTATE_ELLIPSOID_TOOL_ID = "annotateEllipsoid";
const ANNOTATE_SPHERE_TOOL_ID = "annotateSphere";
class PlacePointTool extends PlaceAnnotationTool {
  constructor() {
    super(...arguments);
    this.sourceSignalUpdated = false;
  }
  trigger(mouseState) {
    const annotationLayer = this.annotationLayer;
    if (annotationLayer === void 0) {
      return;
    }
    if (mouseState.updateUnconditionally()) {
      const point = getMousePositionInAnnotationCoordinates(mouseState, annotationLayer);
      if (point === void 0) return;
      const annotation = {
        id: "",
        description: "",
        relatedSegments: getSelectedAssociatedSegments(annotationLayer),
        point,
        type: AnnotationType.POINT,
        properties: annotationLayer.source.properties.map((x) => x.default)
      };
      const reference = annotationLayer.source.add(
        annotation,
        /*commit=*/
        true
      );
      if (annotationLayer.source instanceof MultiscaleAnnotationSource) {
        if (!this.sourceSignalUpdated) {
          annotationLayer.source.childAdded.add((annotation2) => {
            if (annotation2.source === void 0) {
              this.layer.selectAnnotation(annotationLayer, annotation2.id, true, !globalViewerConfig.expectingExternalUI);
            }
          });
          this.sourceSignalUpdated = true;
        }
      } else {
        this.layer.selectAnnotation(annotationLayer, reference.id, true);
      }
      reference.dispose();
    }
  }
  get description() {
    return `annotate point`;
  }
  toJSON() {
    return ANNOTATE_POINT_TOOL_ID;
  }
}
function getMousePositionInAnnotationCoordinates(mouseState, annotationLayer) {
  const chunkTransform = annotationLayer.chunkTransform.value;
  if (chunkTransform.error !== void 0) return void 0;
  const chunkPosition = new Float32Array(chunkTransform.modelTransform.unpaddedRank);
  if (!getChunkPositionFromCombinedGlobalLocalPositions(chunkPosition, mouseState.unsnappedPosition, annotationLayer.localPosition.value, chunkTransform.layerRank, chunkTransform.combinedGlobalLocalToChunkTransform)) {
    return void 0;
  }
  return chunkPosition;
}
class TwoStepAnnotationTool extends PlaceAnnotationTool {
  trigger(mouseState) {
    const annotationLayer = this.annotationLayer;
    if (annotationLayer === void 0) {
      return;
    }
    if (mouseState.updateUnconditionally()) {
      const updatePointB = () => {
        const state = this.inProgressAnnotation;
        const reference = state.reference;
        const newAnnotation = this.getUpdatedAnnotation(reference.value, mouseState, annotationLayer);
        if (_JSON$stringify(annotationToJson(newAnnotation, annotationLayer.source)) === _JSON$stringify(annotationToJson(reference.value, annotationLayer.source))) {
          return;
        }
        state.annotationLayer.source.update(reference, newAnnotation);
        this.layer.selectAnnotation(annotationLayer, reference.id, true, !globalViewerConfig.expectingExternalUI);
      };
      if (this.inProgressAnnotation === void 0) {
        const reference = annotationLayer.source.add(
          this.getInitialAnnotation(mouseState, annotationLayer),
          /*commit=*/
          false
        );
        this.layer.selectAnnotation(annotationLayer, reference.id, true, !globalViewerConfig.expectingExternalUI);
        const mouseDisposer = mouseState.changed.add(updatePointB);
        const disposer = () => {
          mouseDisposer();
          reference.dispose();
        };
        this.inProgressAnnotation = {
          annotationLayer,
          reference,
          disposer
        };
      } else {
        updatePointB();
        this.inProgressAnnotation.annotationLayer.source.commit(this.inProgressAnnotation.reference);
        this.inProgressAnnotation.disposer();
        this.inProgressAnnotation = void 0;
      }
    }
  }
  disposed() {
    this.deactivate();
    super.disposed();
  }
  deactivate() {
    if (this.inProgressAnnotation !== void 0) {
      this.inProgressAnnotation.annotationLayer.source.delete(this.inProgressAnnotation.reference);
      this.inProgressAnnotation.disposer();
      this.inProgressAnnotation = void 0;
    }
  }
}
class PlaceTwoCornerAnnotationTool extends TwoStepAnnotationTool {
  getInitialAnnotation(mouseState, annotationLayer) {
    const point = getMousePositionInAnnotationCoordinates(mouseState, annotationLayer);
    return {
      id: "",
      type: this.annotationType,
      description: "",
      pointA: point,
      pointB: point,
      properties: annotationLayer.source.properties.map((x) => x.default)
    };
  }
  getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer) {
    const point = getMousePositionInAnnotationCoordinates(mouseState, annotationLayer);
    if (point === void 0) return oldAnnotation;
    return _Object$assign(_Object$assign({}, oldAnnotation), { pointB: point });
  }
}
class PlaceBoundingBoxTool extends PlaceTwoCornerAnnotationTool {
  get description() {
    return `annotate bounding box`;
  }
  getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer) {
    const result = super.getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer);
    const pointA = result.pointA, pointB = result.pointB;
    const rank = pointA.length;
    for (let i = 0; i < rank; ++i) {
      if (pointA[i] === pointB[i]) {
        pointB[i] += 1;
      }
    }
    return result;
  }
  toJSON() {
    return ANNOTATE_BOUNDING_BOX_TOOL_ID;
  }
}
PlaceBoundingBoxTool.prototype.annotationType = AnnotationType.AXIS_ALIGNED_BOUNDING_BOX;
class PlaceLineTool extends PlaceTwoCornerAnnotationTool {
  get description() {
    return `annotate line`;
  }
  getInitialAnnotation(mouseState, annotationLayer) {
    const result = super.getInitialAnnotation(mouseState, annotationLayer);
    this.initialRelationships = result.relatedSegments = getSelectedAssociatedSegments(annotationLayer);
    return result;
  }
  getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer) {
    const result = super.getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer);
    const initialRelationships = this.initialRelationships;
    const newRelationships = getSelectedAssociatedSegments(annotationLayer);
    if (initialRelationships === void 0) {
      result.relatedSegments = newRelationships;
    } else {
      result.relatedSegments = _Array$from(newRelationships, (newSegments, i) => {
        const initialSegments = initialRelationships[i];
        newSegments = newSegments.filter((x) => initialSegments.findIndex((y) => Uint64.equal(x, y)) === -1);
        return [...initialSegments, ...newSegments];
      });
    }
    return result;
  }
  toJSON() {
    return ANNOTATE_LINE_TOOL_ID;
  }
}
PlaceLineTool.prototype.annotationType = AnnotationType.LINE;
class PlaceSphereTool extends PlaceTwoCornerAnnotationTool {
  get description() {
    return `annotate sphere`;
  }
  getInitialAnnotation(mouseState, annotationLayer) {
    const result = super.getInitialAnnotation(mouseState, annotationLayer);
    this.initialRelationships = result.relatedSegments = getSelectedAssociatedSegments(annotationLayer);
    return result;
  }
  getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer) {
    const result = super.getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer);
    const initialRelationships = this.initialRelationships;
    const newRelationships = getSelectedAssociatedSegments(annotationLayer);
    if (initialRelationships === void 0) {
      result.relatedSegments = newRelationships;
    } else {
      result.relatedSegments = _Array$from(newRelationships, (newSegments, i) => {
        const initialSegments = initialRelationships[i];
        newSegments = newSegments.filter((x) => initialSegments.findIndex((y) => Uint64.equal(x, y)) === -1);
        return [...initialSegments, ...newSegments];
      });
    }
    return result;
  }
  toJSON() {
    return ANNOTATE_SPHERE_TOOL_ID;
  }
}
PlaceSphereTool.prototype.annotationType = AnnotationType.SPHERE;
class PlaceEllipsoidTool extends TwoStepAnnotationTool {
  getInitialAnnotation(mouseState, annotationLayer) {
    const point = getMousePositionInAnnotationCoordinates(mouseState, annotationLayer);
    return {
      type: AnnotationType.ELLIPSOID,
      id: "",
      description: "",
      segments: getSelectedAssociatedSegments(annotationLayer),
      center: point,
      radii: fromValues$1(0, 0, 0),
      properties: annotationLayer.source.properties.map((x) => x.default)
    };
  }
  getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer) {
    const radii = getMousePositionInAnnotationCoordinates(mouseState, annotationLayer);
    if (radii === void 0) return oldAnnotation;
    const center = oldAnnotation.center;
    const rank = center.length;
    for (let i = 0; i < rank; ++i) {
      radii[i] = Math.abs(center[i] - radii[i]);
    }
    return _Object$assign(_Object$assign({}, oldAnnotation), { radii });
  }
  get description() {
    return `annotate ellipsoid`;
  }
  toJSON() {
    return ANNOTATE_ELLIPSOID_TOOL_ID;
  }
}
registerLegacyTool(ANNOTATE_POINT_TOOL_ID, (layer, options) => new PlacePointTool(layer, options));
registerLegacyTool(ANNOTATE_BOUNDING_BOX_TOOL_ID, (layer, options) => new PlaceBoundingBoxTool(layer, options));
registerLegacyTool(ANNOTATE_LINE_TOOL_ID, (layer, options) => new PlaceLineTool(layer, options));
registerLegacyTool(ANNOTATE_ELLIPSOID_TOOL_ID, (layer, options) => new PlaceEllipsoidTool(layer, options));
registerLegacyTool(ANNOTATE_SPHERE_TOOL_ID, (layer, options) => new PlaceSphereTool(layer, options));
const newRelatedSegmentKeyMap = EventActionMap.fromObject({
  "enter": { action: "commit" },
  "escape": { action: "cancel" }
});
function makeRelatedSegmentList(listName, segments, segmentationDisplayState, mutate) {
  return new DependentViewWidget(segmentationDisplayState, (segmentationDisplayState2, parent, context) => {
    const listElement = document.createElement("div");
    listElement.classList.add("neuroglancer-related-segment-list");
    if (segmentationDisplayState2 != null) {
      context.registerDisposer(bindSegmentListWidth(segmentationDisplayState2, listElement));
    }
    const headerRow = document.createElement("div");
    headerRow.classList.add("neuroglancer-related-segment-list-header");
    const copyButton = makeCopyButton({
      title: `Copy segment IDs`,
      onClick: () => {
        setClipboard(segments.map((x) => x.toString()).join(", "));
      }
    });
    headerRow.appendChild(copyButton);
    let headerCheckbox;
    if (segmentationDisplayState2 != null) {
      headerCheckbox = document.createElement("input");
      headerCheckbox.type = "checkbox";
      headerCheckbox.addEventListener("change", () => {
        const visibleSegments = segmentationDisplayState2.segmentationGroupState.value.visibleSegments;
        const add2 = segments.some((id) => !visibleSegments.has(id));
        for (const id of segments) {
          visibleSegments.set(id, add2);
        }
      });
      headerRow.appendChild(headerCheckbox);
    }
    if (mutate !== void 0) {
      const deleteButton = makeDeleteButton({
        title: "Remove all IDs",
        onClick: () => {
          mutate([]);
        }
      });
      headerRow.appendChild(deleteButton);
    }
    const titleElement = document.createElement("span");
    titleElement.classList.add("neuroglancer-related-segment-list-title");
    titleElement.textContent = listName;
    headerRow.appendChild(titleElement);
    if (mutate !== void 0) {
      const addButton = makeAddButton({
        title: "Add related segment ID",
        onClick: () => {
          const addContext = new RefCounted();
          const addContextDisposer = context.registerDisposer(disposableOnce(addContext));
          const newRow = document.createElement("div");
          newRow.classList.add("neuroglancer-segment-list-entry");
          newRow.classList.add("neuroglancer-segment-list-entry-new");
          const copyButton2 = makeCopyButton({});
          copyButton2.classList.add("neuroglancer-segment-list-entry-copy");
          newRow.appendChild(copyButton2);
          if (segmentationDisplayState2 != null) {
            const checkbox = document.createElement("input");
            checkbox.classList.add("neuroglancer-segment-list-entry-visible-checkbox");
            checkbox.type = "checkbox";
            newRow.appendChild(checkbox);
          }
          const deleteButton = makeDeleteButton({
            title: "Cancel adding new segment ID",
            onClick: () => {
              addContextDisposer();
            }
          });
          deleteButton.classList.add("neuroglancer-segment-list-entry-delete");
          newRow.appendChild(deleteButton);
          const idElement = document.createElement("input");
          idElement.autocomplete = "off";
          idElement.spellcheck = false;
          idElement.classList.add("neuroglancer-segment-list-entry-id");
          const keyboardEventBinder = addContext.registerDisposer(new KeyboardEventBinder(idElement, newRelatedSegmentKeyMap));
          keyboardEventBinder.allShortcutsAreGlobal = true;
          const validateInput = () => {
            const id = new Uint64();
            if (id.tryParseString(idElement.value)) {
              idElement.dataset.valid = "true";
              return id;
            } else {
              idElement.dataset.valid = "false";
              return void 0;
            }
          };
          validateInput();
          idElement.addEventListener("input", () => {
            validateInput();
          });
          idElement.addEventListener("blur", () => {
            const id = validateInput();
            if (id !== void 0) {
              mutate([...segments, id]);
            }
            addContextDisposer();
          });
          registerActionListener(idElement, "cancel", addContextDisposer);
          registerActionListener(idElement, "commit", () => {
            const id = validateInput();
            if (id !== void 0) {
              mutate([...segments, id]);
            }
            addContextDisposer();
          });
          newRow.appendChild(idElement);
          listElement.appendChild(newRow);
          idElement.focus();
          addContext.registerDisposer(() => {
            idElement.value = "";
            newRow.remove();
          });
        }
      });
      headerRow.appendChild(addButton);
    }
    listElement.appendChild(headerRow);
    const rows = [];
    const segmentWidgetFactory = SegmentWidgetFactory.make(
      segmentationDisplayState2 !== null && segmentationDisplayState2 !== void 0 ? segmentationDisplayState2 : void 0,
      /*includeMapped=*/
      false
    );
    for (const id of segments) {
      const row = segmentWidgetFactory.get(id);
      rows.push(row);
      if (mutate !== void 0) {
        const deleteButton = makeDeleteButton({
          title: "Remove ID",
          onClick: (event) => {
            mutate(segments.filter((x) => !Uint64.equal(x, id)));
            event.stopPropagation();
          }
        });
        deleteButton.classList.add("neuroglancer-segment-list-entry-delete");
        row.children[0].appendChild(deleteButton);
      }
      listElement.appendChild(row);
    }
    if (segmentationDisplayState2 != null) {
      const updateSegments = context.registerCancellable(animationFrameDebounce(() => {
        const visibleSegments = segmentationDisplayState2.segmentationGroupState.value.visibleSegments;
        let numVisible = 0;
        for (const id of segments) {
          if (visibleSegments.has(id)) {
            ++numVisible;
          }
        }
        for (const row of rows) {
          segmentWidgetFactory.update(row);
        }
        headerCheckbox.checked = numVisible === segments.length && numVisible > 0;
        headerCheckbox.indeterminate = numVisible > 0 && numVisible < segments.length;
      }));
      updateSegments();
      updateSegments.flush();
      registerCallbackWhenSegmentationDisplayStateChanged(segmentationDisplayState2, context, updateSegments);
      context.registerDisposer(segmentationDisplayState2.segmentationGroupState.changed.add(updateSegments));
    }
    parent.appendChild(listElement);
  });
}
const ANNOTATION_COLOR_JSON_KEY = "annotationColor";
function UserLayerWithAnnotationsMixin(Base2) {
  class C extends Base2 {
    constructor(...args) {
      super(...args);
      this.annotationStates = this.registerDisposer(new MergedAnnotationStates());
      this.annotationDisplayState = new AnnotationDisplayState();
      this.annotationCrossSectionRenderScaleHistogram = new RenderScaleHistogram();
      this.annotationCrossSectionRenderScaleTarget = trackableRenderScaleTarget(8);
      this.annotationProjectionRenderScaleHistogram = new RenderScaleHistogram();
      this.annotationProjectionRenderScaleTarget = trackableRenderScaleTarget(8);
      this.annotationDisplayState.color.changed.add(this.specificationChanged.dispatch);
      this.annotationDisplayState.shader.changed.add(this.specificationChanged.dispatch);
      this.annotationDisplayState.shaderControls.changed.add(this.specificationChanged.dispatch);
      this.tabs.add("annotations", { label: "Annotations", order: 10, getter: () => new AnnotationTab(this) });
      let annotationStateReadyBinding;
      const updateReadyBinding = () => {
        const isReady = this.isReady;
        if (isReady && annotationStateReadyBinding !== void 0) {
          annotationStateReadyBinding();
          annotationStateReadyBinding = void 0;
        } else if (!isReady && annotationStateReadyBinding === void 0) {
          annotationStateReadyBinding = this.annotationStates.markLoading();
        }
      };
      this.readyStateChanged.add(updateReadyBinding);
      updateReadyBinding();
      const mouseState = this.manager.layerSelectedValues.mouseState;
      this.registerDisposer(mouseState.changed.add(() => {
        if (mouseState.active) {
          const pickedAnnotationLayer = mouseState.pickedAnnotationLayer;
          if (pickedAnnotationLayer !== void 0 && this.annotationStates.states.includes(pickedAnnotationLayer)) {
            const existingValue = this.annotationDisplayState.hoverState.value;
            if (existingValue === void 0 || existingValue.id !== mouseState.pickedAnnotationId || existingValue.partIndex !== mouseState.pickedOffset || existingValue.annotationLayerState !== pickedAnnotationLayer) {
              this.annotationDisplayState.hoverState.value = {
                id: mouseState.pickedAnnotationId,
                partIndex: mouseState.pickedOffset,
                annotationLayerState: pickedAnnotationLayer
              };
            }
            return;
          }
        }
        this.annotationDisplayState.hoverState.value = void 0;
      }));
    }
    initializeAnnotationLayerViewTab(tab) {
    }
    restoreState(specification) {
      super.restoreState(specification);
      this.annotationDisplayState.color.restoreState(specification[ANNOTATION_COLOR_JSON_KEY]);
    }
    captureSelectionState(state, mouseState) {
      super.captureSelectionState(state, mouseState);
      const annotationLayer = mouseState.pickedAnnotationLayer;
      if (annotationLayer === void 0 || !this.annotationStates.states.includes(annotationLayer)) {
        return;
      }
      state.annotationId = mouseState.pickedAnnotationId;
      state.annotationType = mouseState.pickedAnnotationType;
      state.annotationBuffer = new Uint8Array(mouseState.pickedAnnotationBuffer, mouseState.pickedAnnotationBufferBaseOffset);
      state.annotationIndex = mouseState.pickedAnnotationIndex;
      state.annotationCount = mouseState.pickedAnnotationCount;
      state.annotationPartIndex = mouseState.pickedOffset;
      state.annotationSourceIndex = annotationLayer.sourceIndex;
      state.annotationSubsource = annotationLayer.subsourceId;
    }
    displayAnnotationState(state, parent, context) {
      if (state.annotationId === void 0) return false;
      const annotationLayer = this.annotationStates.states.find((x) => x.sourceIndex === state.annotationSourceIndex && (state.annotationSubsource === void 0 || x.subsourceId === state.annotationSubsource));
      if (annotationLayer === void 0) return false;
      if (annotationLayer.source instanceof MultiscaleAnnotationSource) ;
      const reference = context.registerDisposer(annotationLayer.source.getReference(state.annotationId));
      parent.appendChild(context.registerDisposer(new DependentViewWidget(context.registerDisposer(new AggregateWatchableValue(() => ({
        annotation: reference,
        chunkTransform: annotationLayer.chunkTransform
      }))), ({ annotation, chunkTransform }, parent2, context2) => {
        let statusText;
        if (annotation == null) {
          if (state.annotationType !== void 0 && state.annotationBuffer !== void 0) {
            const handler = annotationTypeHandlers[state.annotationType];
            const rank = annotationLayer.source.rank;
            const numGeometryBytes = handler.serializedBytes(rank);
            const baseOffset = state.annotationBuffer.byteOffset;
            const dataView = new DataView(state.annotationBuffer.buffer);
            const isLittleEndian = Endianness.LITTLE === ENDIANNESS;
            const properties = annotationLayer.source.properties;
            const annotationPropertySerializer = new AnnotationPropertySerializer(rank, numGeometryBytes, properties);
            const annotationIndex = state.annotationIndex;
            const annotationCount = state.annotationCount;
            annotation = handler.deserialize(dataView, baseOffset + annotationPropertySerializer.propertyGroupBytes[0] * annotationIndex, isLittleEndian, rank, state.annotationId);
            annotationPropertySerializer.deserialize(dataView, baseOffset, annotationIndex, annotationCount, isLittleEndian, annotation.properties = new Array(properties.length));
            if (annotationLayer.source.hasNonSerializedProperties()) {
              statusText = "Loading...";
            }
          } else {
            statusText = annotation === null ? "Annotation not found" : "Loading...";
          }
        }
        if (annotation != null) {
          const layerRank = chunkTransform.error === void 0 ? chunkTransform.layerRank : 0;
          const positionGrid = document.createElement("div");
          positionGrid.classList.add("neuroglancer-selected-annotation-details-position-grid");
          positionGrid.style.gridTemplateColumns = `[icon] 0fr [copy] 0fr repeat(${layerRank}, [dim] 0fr [coord] 0fr) [move] 0fr [delete] 0fr`;
          parent2.appendChild(positionGrid);
          const handler = annotationTypeHandlers[annotation.type];
          const icon = document.createElement("div");
          icon.className = "neuroglancer-selected-annotation-details-icon";
          icon.textContent = handler.icon;
          positionGrid.appendChild(icon);
          if (layerRank !== 0) {
            const layerDimensionNames = chunkTransform.modelTransform.layerDimensionNames;
            for (let i = 0; i < layerRank; ++i) {
              const dimElement = document.createElement("div");
              dimElement.classList.add("neuroglancer-selected-annotation-details-position-dim");
              dimElement.textContent = layerDimensionNames[i];
              dimElement.style.gridColumn = `dim ${i + 1}`;
              positionGrid.appendChild(dimElement);
            }
            visitTransformedAnnotationGeometry(annotation, chunkTransform, (layerPosition, isVector) => {
              const copyButton = makeCopyButton({
                title: "Copy position",
                onClick: () => {
                  setClipboard(layerPosition.map((x) => Math.floor(x)).join(", "));
                }
              });
              copyButton.style.gridColumn = "copy";
              positionGrid.appendChild(copyButton);
              for (let layerDim = 0; layerDim < layerRank; ++layerDim) {
                const coordElement = document.createElement("div");
                coordElement.classList.add("neuroglancer-selected-annotation-details-position-coord");
                coordElement.style.gridColumn = `coord ${layerDim + 1}`;
                coordElement.textContent = Math.floor(layerPosition[layerDim]).toString();
                positionGrid.appendChild(coordElement);
              }
              if (!isVector) {
                const moveButton = makeMoveToButton({
                  title: "Move to position",
                  onClick: () => {
                    setLayerPosition(this, chunkTransform, layerPosition);
                  }
                });
                moveButton.style.gridColumn = "move";
                positionGrid.appendChild(moveButton);
              }
            });
          }
          if (!annotationLayer.source.readonly) {
            const button = makeDeleteButton({
              title: "Delete annotation",
              onClick: () => {
                annotationLayer.source.delete(reference);
              }
            });
            button.classList.add("neuroglancer-selected-annotation-details-delete");
            positionGrid.appendChild(button);
          }
          var _annotationLayer$sour = annotationLayer.source;
          const relationships = _annotationLayer$sour.relationships, properties = _annotationLayer$sour.properties;
          const sourceReadonly = annotationLayer.source.readonly;
          for (let i = 0, count = properties.length; i < count; ++i) {
            const property = properties[i];
            const label = document.createElement("label");
            label.classList.add("neuroglancer-annotation-property");
            const idElement = document.createElement("span");
            idElement.classList.add("neuroglancer-annotation-property-label");
            idElement.textContent = property.identifier;
            label.appendChild(idElement);
            const description = property.description;
            if (description !== void 0) {
              label.title = description;
            }
            const value = annotation.properties[i];
            const valueElement = document.createElement("span");
            valueElement.classList.add("neuroglancer-annotation-property-value");
            switch (property.type) {
              case "rgb": {
                const colorVec = unpackRGB(value);
                const hex = serializeColor(colorVec);
                valueElement.textContent = hex;
                valueElement.style.backgroundColor = hex;
                valueElement.style.color = useWhiteBackground(colorVec) ? "white" : "black";
                break;
              }
              case "rgba": {
                const colorVec = unpackRGB(value);
                valueElement.textContent = serializeColor(unpackRGBA(value));
                valueElement.style.backgroundColor = serializeColor(unpackRGB(value));
                valueElement.style.color = useWhiteBackground(colorVec) ? "white" : "black";
                break;
              }
              default:
                valueElement.textContent = formatNumericProperty(property, value);
                break;
            }
            label.appendChild(valueElement);
            parent2.appendChild(label);
          }
          var _annotation = annotation;
          const relatedSegments = _annotation.relatedSegments;
          for (let i = 0, count = relationships.length; i < count; ++i) {
            const related = relatedSegments === void 0 ? [] : relatedSegments[i];
            if (related.length === 0 && sourceReadonly) continue;
            const relationshipIndex = i;
            const relationship = relationships[i];
            parent2.appendChild(context2.registerDisposer(makeRelatedSegmentList(relationship, related, annotationLayer.displayState.relationshipStates.get(relationship).segmentationState, sourceReadonly ? void 0 : (newIds) => {
              const annotation2 = reference.value;
              if (annotation2 == null) {
                return;
              }
              let relatedSegments2 = annotation2.relatedSegments;
              if (relatedSegments2 === void 0) {
                relatedSegments2 = annotationLayer.source.relationships.map(() => []);
              } else {
                relatedSegments2 = relatedSegments2.slice();
              }
              relatedSegments2[relationshipIndex] = newIds;
              const newAnnotation = _Object$assign(_Object$assign({}, annotation2), { relatedSegments: relatedSegments2 });
              annotationLayer.source.update(reference, newAnnotation);
              annotationLayer.source.commit(reference);
            })).element);
          }
          let editWidget = null;
          let source = annotationLayer.source;
          if (source instanceof MultiscaleAnnotationSource) {
            if (source.makeEditWidget) {
              editWidget = source.makeEditWidget(reference);
              if (editWidget) {
                editWidget.className = "neuroglancer-annotation-details-description";
                parent2.appendChild(editWidget);
              }
            }
          }
          if ((!annotationLayer.source.readonly || annotation.description) && editWidget === null) {
            if (annotationLayer.source.readonly) {
              const description = document.createElement("div");
              description.className = "neuroglancer-annotation-details-description";
              description.textContent = annotation.description || "";
              parent2.appendChild(description);
            } else {
              const description = document.createElement("textarea");
              description.value = annotation.description || "";
              description.rows = 3;
              description.className = "neuroglancer-annotation-details-description";
              description.placeholder = "Description";
              description.addEventListener("change", () => {
                const x = description.value;
                annotationLayer.source.update(reference, _Object$assign(_Object$assign({}, annotation), { description: x ? x : void 0 }));
                annotationLayer.source.commit(reference);
              });
              parent2.appendChild(description);
            }
          }
        }
        if (statusText !== void 0) {
          const statusMessage = document.createElement("div");
          statusMessage.classList.add("neuroglancer-selection-annotation-status");
          statusMessage.textContent = statusText;
          parent2.appendChild(statusMessage);
        }
      })).element);
      return true;
    }
    displaySelectionState(state, parent, context) {
      let displayed = this.displayAnnotationState(state, parent, context);
      if (super.displaySelectionState(state, parent, context)) displayed = true;
      return displayed;
    }
    addLocalAnnotations(loadedSubsource, source, role) {
      const subsourceEntry = loadedSubsource.subsourceEntry;
      const state = new AnnotationLayerState({
        localPosition: this.localPosition,
        transform: loadedSubsource.getRenderLayerTransform(),
        source,
        displayState: this.annotationDisplayState,
        dataSource: loadedSubsource.loadedDataSource.layerDataSource,
        subsourceIndex: loadedSubsource.subsourceIndex,
        subsourceId: subsourceEntry.id,
        role
      });
      this.addAnnotationLayerState(state, loadedSubsource);
    }
    addStaticAnnotations(loadedSubsource) {
      const subsourceEntry = loadedSubsource.subsourceEntry;
      const staticAnnotations = subsourceEntry.subsource.staticAnnotations;
      if (staticAnnotations === void 0) return false;
      loadedSubsource.activate(() => {
        this.addLocalAnnotations(loadedSubsource, staticAnnotations, RenderLayerRole.DEFAULT_ANNOTATION);
      });
      return true;
    }
    addAnnotationLayerState(state, loadedSubsource) {
      const refCounted = loadedSubsource.activated;
      refCounted.registerDisposer(this.annotationStates.add(state));
      const annotationLayer = new AnnotationLayer(this.manager.chunkManager, state.addRef());
      if (annotationLayer.source instanceof MultiscaleAnnotationSource) {
        const crossSectionRenderLayer = new SpatiallyIndexedSliceViewAnnotationLayer({
          annotationLayer: annotationLayer.addRef(),
          renderScaleTarget: this.annotationCrossSectionRenderScaleTarget,
          renderScaleHistogram: this.annotationCrossSectionRenderScaleHistogram
        });
        refCounted.registerDisposer(loadedSubsource.messages.addChild(crossSectionRenderLayer.messages));
        const projectionRenderLayer = new SpatiallyIndexedPerspectiveViewAnnotationLayer({
          annotationLayer: annotationLayer.addRef(),
          renderScaleTarget: this.annotationProjectionRenderScaleTarget,
          renderScaleHistogram: this.annotationProjectionRenderScaleHistogram
        });
        refCounted.registerDisposer(loadedSubsource.messages.addChild(projectionRenderLayer.messages));
        refCounted.registerDisposer(registerNested((context, value) => {
          if (value) {
            context.registerDisposer(this.addRenderLayer(crossSectionRenderLayer.addRef()));
            context.registerDisposer(this.addRenderLayer(projectionRenderLayer.addRef()));
          }
        }, this.annotationDisplayState.displayUnfiltered));
      }
      {
        const renderLayer = new SliceViewAnnotationLayer(annotationLayer, this.annotationCrossSectionRenderScaleHistogram);
        refCounted.registerDisposer(this.addRenderLayer(renderLayer));
        refCounted.registerDisposer(loadedSubsource.messages.addChild(renderLayer.messages));
      }
      {
        const renderLayer = new PerspectiveViewAnnotationLayer(annotationLayer.addRef(), this.annotationProjectionRenderScaleHistogram);
        refCounted.registerDisposer(this.addRenderLayer(renderLayer));
        refCounted.registerDisposer(loadedSubsource.messages.addChild(renderLayer.messages));
      }
    }
    selectAnnotation(annotationLayer, id, pin, forceShowingPanel = true) {
      this.manager.root.selectionState.captureSingleLayerState(this, (state) => {
        state.annotationId = id;
        state.annotationSourceIndex = annotationLayer.sourceIndex;
        state.annotationSubsource = annotationLayer.subsourceId;
        return true;
      }, pin, forceShowingPanel);
    }
    toJSON() {
      const x = super.toJSON();
      x[ANNOTATION_COLOR_JSON_KEY] = this.annotationDisplayState.color.toJSON();
      return x;
    }
  }
  return C;
}
const inputEventMap$2 = EventActionMap.fromObject({
  "shift?+mousedown0": { action: "set" },
  "shift?+alt+mousedown0": { action: "adjust-window-via-drag" },
  "shift?+wheel": { action: "zoom-via-wheel" }
});
class CdfController extends RefCounted {
  constructor(element, dataType, getModel, setModel) {
    super();
    this.element = element;
    this.dataType = dataType;
    this.getModel = getModel;
    this.setModel = setModel;
    element.title = inputEventMap$2.describe();
    this.registerDisposer(new MouseEventBinder(element, inputEventMap$2));
    registerActionListener(element, "set", (actionEvent) => {
      const mouseEvent = actionEvent.detail;
      const bounds = this.getModel();
      const value = this.getTargetValue(mouseEvent);
      if (value === void 0) return;
      const clampedRange = getClampedInterval(bounds.window, bounds.range);
      const endpoint = getClosestEndpoint(clampedRange, value);
      const setEndpoint = (value2) => {
        const bounds2 = this.getModel();
        this.setModel(getUpdatedRangeAndWindowParameters(bounds2, "range", endpoint, value2));
      };
      setEndpoint(value);
      startRelativeMouseDrag(mouseEvent, (newEvent) => {
        const value2 = this.getTargetValue(newEvent);
        if (value2 === void 0) return;
        setEndpoint(value2);
      });
    });
    registerActionListener(element, "adjust-window-via-drag", (actionEvent) => {
      const mouseEvent = actionEvent.detail;
      const initialRelativeX = this.getTargetFraction(mouseEvent);
      const initialValue = this.getWindowLerp(initialRelativeX);
      const endpointIndex = initialRelativeX < 0.5 ? 0 : 1;
      const setEndpoint = (value) => {
        const bounds = this.getModel();
        this.setModel(getUpdatedRangeAndWindowParameters(bounds, "window", endpointIndex, value));
      };
      startRelativeMouseDrag(mouseEvent, (newEvent) => {
        const window2 = this.getModel().window;
        const relativeX = this.getTargetFraction(newEvent);
        if (endpointIndex === 0) {
          setEndpoint(computeLerp([initialValue, window2[1]], this.dataType, -relativeX / (1 - relativeX)));
        } else {
          setEndpoint(computeLerp([window2[0], initialValue], this.dataType, 1 / relativeX));
        }
      });
    });
    registerActionListener(element, "zoom-via-wheel", (actionEvent) => {
      const wheelEvent = actionEvent.detail;
      const zoomAmount = getWheelZoomAmount(wheelEvent);
      const relativeX = this.getTargetFraction(wheelEvent);
      const dataType2 = this.dataType;
      const bounds = this.getModel();
      const newLower = computeLerp(bounds.window, dataType2, relativeX * (1 - zoomAmount));
      const newUpper = computeLerp(bounds.window, dataType2, (1 - relativeX) * zoomAmount + relativeX);
      this.setModel(_Object$assign(_Object$assign({}, bounds), { window: [newLower, newUpper], range: bounds.range }));
    });
  }
  getTargetFraction(event) {
    const clientRect = this.element.getBoundingClientRect();
    return (event.clientX - clientRect.left) / clientRect.width;
  }
  getWindowLerp(relativeX) {
    return computeLerp(this.getModel().window, this.dataType, relativeX);
  }
  getTargetValue(event) {
    const targetFraction = this.getTargetFraction(event);
    if (!_Number$isFinite(targetFraction)) return void 0;
    return this.getWindowLerp(targetFraction);
  }
}
const histogramSamplerTextureUnit = _Symbol("histogramSamplerTexture");
function getUpdatedRangeAndWindowParameters(existingBounds, boundType, endpointIndex, newEndpoint, fitRangeInWindow = false) {
  const newBounds = _Object$assign({}, existingBounds);
  const existingInterval = existingBounds[boundType];
  newBounds[boundType] = [existingInterval[0], existingInterval[1]];
  newBounds[boundType][endpointIndex] = newEndpoint;
  if (boundType === "window" && dataTypeCompare(newEndpoint, existingInterval[1 - endpointIndex]) * (2 * endpointIndex - 1) < 0) {
    newBounds[boundType][1 - endpointIndex] = newEndpoint;
  }
  if (boundType === "range" && fitRangeInWindow) {
    const newWindowInterval = [existingBounds.window[0], existingBounds.window[1]];
    for (let i = 0; i < 2; ++i) {
      if (dataTypeCompare(newEndpoint, newWindowInterval[i]) * (2 * i - 1) > 0) {
        newWindowInterval[i] = newEndpoint;
      }
    }
    newBounds.window = newWindowInterval;
  }
  return newBounds;
}
const NUM_HISTOGRAM_BINS_IN_RANGE = 254;
const NUM_CDF_LINES = NUM_HISTOGRAM_BINS_IN_RANGE + 1;
class CdfPanel extends IndirectRenderedPanel {
  constructor(parent) {
    super(parent.display, document.createElement("div"), parent.visibility);
    this.parent = parent;
    this.controller = this.registerDisposer(new CdfController(this.element, this.parent.dataType, () => this.parent.trackable.value, (value) => {
      this.parent.trackable.value = value;
    }));
    this.dataValuesBuffer = this.registerDisposer(getMemoizedBuffer(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, () => {
      const array = new Uint8Array(NUM_CDF_LINES * VERTICES_PER_LINE);
      for (let i = 0; i < NUM_CDF_LINES; ++i) {
        for (let j = 0; j < VERTICES_PER_LINE; ++j) {
          array[i * VERTICES_PER_LINE + j] = i;
        }
      }
      return array;
    })).value;
    this.lineShader = this.registerDisposer((() => {
      const builder = new ShaderBuilder(this.gl);
      defineLineShader(builder);
      builder.addTextureSampler("sampler2D", "uHistogramSampler", histogramSamplerTextureUnit);
      builder.addOutputBuffer("vec4", "out_color", 0);
      builder.addAttribute("uint", "aDataValue");
      builder.addUniform("float", "uBoundsFraction");
      builder.addVertexCode(`
float getCount(int i) {
  return texelFetch(uHistogramSampler, ivec2(i, 0), 0).x;
}
vec4 getVertex(float cdf, int i) {
  float x;
  if (i == 0) {
    x = -1.0;
  } else if (i == 255) {
    x = 1.0;
  } else {
    x = float(i) / 254.0 * uBoundsFraction * 2.0 - 1.0;
  }
  return vec4(x, cdf * (2.0 - uLineParams.y) - 1.0 + uLineParams.y * 0.5, 0.0, 1.0);
}
`);
      builder.setVertexMain(`
int lineNumber = int(aDataValue);
int dataValue = lineNumber;
float cumSum = 0.0;
for (int i = 0; i <= dataValue; ++i) {
  cumSum += getCount(i);
}
float total = cumSum + getCount(dataValue + 1);
float cumSumEnd = dataValue == ${NUM_CDF_LINES - 1} ? cumSum : total;
if (dataValue == ${NUM_CDF_LINES - 1}) {
  cumSum + getCount(dataValue + 1);
}
for (int i = dataValue + 2; i < 256; ++i) {
  total += getCount(i);
}
total = max(total, 1.0);
float cdf1 = cumSum / total;
float cdf2 = cumSumEnd / total;
emitLine(getVertex(cdf1, lineNumber), getVertex(cdf2, lineNumber + 1), 1.0);
`);
      builder.setFragmentMain(`
out_color = vec4(0.0, 1.0, 1.0, getLineAlpha());
`);
      return builder.build();
    })());
    this.regionCornersBuffer = getSquareCornersBuffer(this.gl, 0, -1, 1, 1);
    this.regionShader = this.registerDisposer((() => {
      const builder = new ShaderBuilder(this.gl);
      builder.addAttribute("vec2", "aVertexPosition");
      builder.addUniform("vec2", "uBounds");
      builder.addUniform("vec4", "uColor");
      builder.addOutputBuffer("vec4", "out_color", 0);
      builder.setVertexMain(`
gl_Position = vec4(mix(uBounds[0], uBounds[1], aVertexPosition.x) * 2.0 - 1.0, aVertexPosition.y, 0.0, 1.0);
`);
      builder.setFragmentMain(`
out_color = uColor;
`);
      return builder.build();
    })());
    const element = this.element;
    element.classList.add("neuroglancer-invlerp-cdfpanel");
  }
  get drawOrder() {
    return 100;
  }
  drawIndirect() {
    const lineShader = this.lineShader, gl = this.gl, regionShader = this.regionShader;
    var _parent = this.parent;
    const dataType = _parent.dataType, bounds = _parent.trackable.value;
    this.setGLLogicalViewport();
    gl.clearColor(0, 0, 0, 0);
    gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
    gl.enable(WebGL2RenderingContext.BLEND);
    gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
    gl.disable(WebGL2RenderingContext.DEPTH_TEST);
    gl.disable(WebGL2RenderingContext.STENCIL_TEST);
    {
      regionShader.bind();
      gl.uniform4f(regionShader.uniform("uColor"), 0.2, 0.2, 0.2, 1);
      const fraction0 = computeInvlerp(bounds.window, bounds.range[0]), fraction1 = computeInvlerp(bounds.window, bounds.range[1]);
      const effectiveFraction = getIntervalBoundsEffectiveFraction(dataType, bounds.window);
      gl.uniform2f(regionShader.uniform("uBounds"), Math.min(fraction0, fraction1) * effectiveFraction, Math.max(fraction0, fraction1) * effectiveFraction + (1 - effectiveFraction));
      const aVertexPosition = regionShader.attribute("aVertexPosition");
      this.regionCornersBuffer.bindToVertexAttrib(
        aVertexPosition,
        /*componentsPerVertexAttribute=*/
        2,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT
      );
      gl.drawArrays(WebGL2RenderingContext.TRIANGLE_FAN, 0, 4);
      gl.disableVertexAttribArray(aVertexPosition);
    }
    if (this.parent.histogramSpecifications.producerVisibility.visible) {
      const renderViewport = this.renderViewport;
      lineShader.bind();
      initializeLineShader(
        lineShader,
        { width: renderViewport.logicalWidth, height: renderViewport.logicalHeight },
        /*featherWidthInPixels=*/
        1
      );
      const histogramTextureUnit = lineShader.textureUnit(histogramSamplerTextureUnit);
      gl.uniform1f(lineShader.uniform("uBoundsFraction"), getIntervalBoundsEffectiveFraction(dataType, bounds.window));
      gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + histogramTextureUnit);
      gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.parent.texture);
      setRawTextureParameters(gl);
      const aDataValue = lineShader.attribute("aDataValue");
      this.dataValuesBuffer.bindToVertexAttribI(
        aDataValue,
        /*componentsPerVertexAttribute=*/
        1,
        /*attributeType=*/
        WebGL2RenderingContext.UNSIGNED_BYTE
      );
      drawLines(
        gl,
        /*linesPerInstance=*/
        NUM_CDF_LINES,
        /*numInstances=*/
        1
      );
      gl.disableVertexAttribArray(aDataValue);
      gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
    }
    gl.disable(WebGL2RenderingContext.BLEND);
  }
  isReady() {
    return true;
  }
}
function dummyColorLegendShaderModule() {
}
class ColorLegendPanel extends IndirectRenderedPanel {
  constructor(parent) {
    super(parent.display, document.createElement("div"), parent.visibility);
    this.parent = parent;
    this.cornersBuffer = getSquareCornersBuffer(this.gl, -1, -1, 1, 1);
    const element = this.element;
    element.classList.add("neuroglancer-invlerp-legend-panel");
    const shaderOptions = this.shaderOptions = parent.legendShaderOptions;
    this.shaderGetter = parameterizedEmitterDependentShaderGetter(this, this.gl, _Object$assign(_Object$assign({}, shaderOptions), { memoizeKey: { id: `colorLegendShader`, base: shaderOptions.memoizeKey }, defineShader: (builder, parameters, extraParameters) => {
      builder.addOutputBuffer("vec4", "v4f_fragData0", 0);
      builder.addAttribute("vec2", "aVertexPosition");
      builder.addUniform("float", "uLegendOffset");
      builder.addVarying("float", "vLinearPosition");
      builder.setVertexMain(`
gl_Position = vec4(aVertexPosition, 0.0, 1.0);
vLinearPosition = -uLegendOffset + ((aVertexPosition.x + 1.0) * 0.5) * (1.0 + 2.0 * uLegendOffset);
`);
      const dataType = this.parent.dataType;
      const shaderDataType = getShaderType(dataType);
      builder.addFragmentCode(defineLerpShaderFunction(builder, "ng_colorLegendLerp", dataType));
      builder.addFragmentCode(`
void emit(vec4 v) {
  v4f_fragData0 = v;
}
${shaderDataType} getDataValue() {
  return ng_colorLegendLerp(vLinearPosition);
}
${shaderDataType} getDataValue(int dummyChannel) {
  return getDataValue();
}
${shaderDataType} getInterpolatedDataValue() {
  return getDataValue();
}
${shaderDataType} getInterpolatedDataValue(int dummyChannel) {
  return getDataValue();
}
`);
      shaderOptions.defineShader(builder, parameters, extraParameters);
    } }));
  }
  drawIndirect() {
    const shaderResult = this.shaderGetter(dummyColorLegendShaderModule);
    const shader = shaderResult.shader;
    if (shader === null) return;
    this.setGLLogicalViewport();
    const gl = this.gl;
    gl.clearColor(0, 0, 0, 0);
    gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
    shader.bind();
    this.shaderOptions.initializeShader(shaderResult);
    gl.enable(WebGL2RenderingContext.BLEND);
    var _parent2 = this.parent;
    const window2 = _parent2.trackable.value.window, dataType = _parent2.dataType;
    enableLerpShaderFunction(shader, "ng_colorLegendLerp", this.parent.dataType, window2);
    const legendOffset = getIntervalBoundsEffectiveOffset(dataType, window2);
    gl.uniform1f(shader.uniform("uLegendOffset"), _Number$isFinite(legendOffset) ? legendOffset : 0);
    gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
    gl.disable(WebGL2RenderingContext.DEPTH_TEST);
    gl.disable(WebGL2RenderingContext.STENCIL_TEST);
    const aVertexPosition = shader.attribute("aVertexPosition");
    this.cornersBuffer.bindToVertexAttrib(
      aVertexPosition,
      /*componentsPerVertexAttribute=*/
      2,
      /*attributeType=*/
      WebGL2RenderingContext.FLOAT
    );
    gl.drawArrays(WebGL2RenderingContext.TRIANGLE_FAN, 0, 4);
    gl.disableVertexAttribArray(aVertexPosition);
  }
  isReady() {
    return true;
  }
}
function createRangeBoundInput(boundType, endpoint) {
  const e = document.createElement("input");
  e.addEventListener("focus", () => {
    e.select();
  });
  e.classList.add("neuroglancer-invlerp-widget-bound");
  e.classList.add(`neuroglancer-invlerp-widget-${boundType}-bound`);
  e.type = "text";
  e.spellcheck = false;
  e.autocomplete = "off";
  e.title = boundType === "range" ? `Data value that maps to ${endpoint}` : `${endpoint === 0 ? "Lower" : "Upper"} bound for distribution`;
  return e;
}
function createRangeBoundInputs(boundType, dataType, model) {
  const container = document.createElement("div");
  container.classList.add("neuroglancer-invlerp-widget-bounds");
  container.classList.add(`neuroglancer-invlerp-widget-${boundType}-bounds`);
  const inputs = [createRangeBoundInput(boundType, 0), createRangeBoundInput(boundType, 1)];
  for (let endpointIndex = 0; endpointIndex < 2; ++endpointIndex) {
    const input = inputs[endpointIndex];
    input.addEventListener("input", () => {
      updateInputBoundWidth$1(input);
    });
    input.addEventListener("change", () => {
      const existingBounds = model.value;
      const existingInterval = existingBounds[boundType];
      try {
        const value = parseDataTypeValue(dataType, input.value);
        model.value = getUpdatedRangeAndWindowParameters(
          existingBounds,
          boundType,
          endpointIndex,
          value,
          /*fitRangeInWindow=*/
          true
        );
      } catch (_a) {
        updateInputBoundValue$1(input, existingInterval[endpointIndex]);
      }
    });
  }
  let spacers;
  container.appendChild(inputs[0]);
  container.appendChild(inputs[1]);
  if (boundType === "range") {
    spacers = [document.createElement("div"), document.createElement("div"), document.createElement("div")];
    spacers[1].classList.add("neuroglancer-invlerp-widget-range-spacer");
    container.insertBefore(spacers[0], inputs[0]);
    container.insertBefore(spacers[1], inputs[1]);
    container.appendChild(spacers[2]);
  }
  return { container, inputs, spacers };
}
function updateInputBoundWidth$1(inputElement) {
  updateInputFieldWidth$1(inputElement, Math.max(1, inputElement.value.length + 0.1));
}
function updateInputBoundValue$1(inputElement, bound) {
  let boundString;
  if (bound instanceof Uint64 || _Number$isInteger(bound)) {
    boundString = bound.toString();
  } else {
    boundString = bound.toPrecision(6);
  }
  inputElement.value = boundString;
  updateInputBoundWidth$1(inputElement);
}
function invertInvlerpRange(trackable) {
  const bounds = trackable.value;
  const range = bounds.range;
  trackable.value = _Object$assign(_Object$assign({}, bounds), { range: [range[1], range[0]] });
}
function adjustInvlerpContrast(dataType, trackable, scaleFactor) {
  const bounds = trackable.value;
  const newLower = computeLerp(bounds.range, dataType, 0.5 - scaleFactor / 2);
  const newUpper = computeLerp(bounds.range, dataType, 0.5 + scaleFactor / 2);
  trackable.value = _Object$assign(_Object$assign({}, bounds), { range: [newLower, newUpper] });
}
function adjustInvlerpBrightnessContrast(dataType, trackable, baseRange, brightnessAmount, contrastAmount) {
  const scaleFactor = Math.exp(contrastAmount);
  const bounds = trackable.value;
  const newLower = computeLerp(baseRange, dataType, 0.5 - scaleFactor / 2 + brightnessAmount);
  const newUpper = computeLerp(baseRange, dataType, 0.5 + scaleFactor / 2 + brightnessAmount);
  trackable.value = _Object$assign(_Object$assign({}, bounds), { range: [newLower, newUpper] });
}
class InvlerpWidget extends Tab {
  constructor(visibility, display, dataType, trackable, histogramSpecifications, histogramIndex, legendShaderOptions) {
    super(visibility);
    this.display = display;
    this.dataType = dataType;
    this.trackable = trackable;
    this.histogramSpecifications = histogramSpecifications;
    this.histogramIndex = histogramIndex;
    this.legendShaderOptions = legendShaderOptions;
    this.cdfPanel = this.registerDisposer(new CdfPanel(this));
    this.boundElements = {
      range: createRangeBoundInputs("range", this.dataType, this.trackable),
      window: createRangeBoundInputs("window", this.dataType, this.trackable)
    };
    this.registerDisposer(histogramSpecifications.visibility.add(this.visibility));
    const element = this.element, boundElements = this.boundElements;
    if (legendShaderOptions !== void 0) {
      const legendPanel = this.registerDisposer(new ColorLegendPanel(this));
      element.appendChild(legendPanel.element);
    }
    const makeArrow = (svg) => {
      const icon = makeIcon({
        svg,
        title: "Invert range",
        onClick: () => {
          this.invertRange();
        }
      });
      boundElements.range.spacers[1].appendChild(icon);
      return icon;
    };
    this.invertArrows = [makeArrow(svg_arrowRight), makeArrow(svg_arrowLeft)];
    element.appendChild(boundElements.range.container);
    element.appendChild(this.cdfPanel.element);
    element.classList.add("neuroglancer-invlerp-widget");
    element.appendChild(boundElements.window.container);
    this.updateView();
    this.registerDisposer(trackable.changed.add(this.registerCancellable(animationFrameDebounce(() => this.updateView()))));
  }
  get texture() {
    return this.histogramSpecifications.getFramebuffers(this.display.gl)[this.histogramIndex].colorBuffers[0].texture;
  }
  invertRange() {
    invertInvlerpRange(this.trackable);
  }
  updateView() {
    const boundElements = this.boundElements;
    const bounds = this.trackable.value, dataType = this.dataType;
    for (let i = 0; i < 2; ++i) {
      updateInputBoundValue$1(boundElements.range.inputs[i], bounds.range[i]);
      updateInputBoundValue$1(boundElements.window.inputs[i], bounds.window[i]);
    }
    const reversed = dataTypeCompare(bounds.range[0], bounds.range[1]) > 0;
    boundElements.range.container.style.flexDirection = !reversed ? "row" : "row-reverse";
    const clampedRange = getClampedInterval(bounds.window, bounds.range);
    const spacers = boundElements.range.spacers;
    const effectiveFraction = getIntervalBoundsEffectiveFraction(dataType, bounds.window);
    const leftOffset = computeInvlerp(bounds.window, clampedRange[reversed ? 1 : 0]) * effectiveFraction;
    const rightOffset = computeInvlerp(bounds.window, clampedRange[reversed ? 0 : 1]) * effectiveFraction + (1 - effectiveFraction);
    spacers[reversed ? 2 : 0].style.width = `${leftOffset * 100}%`;
    spacers[reversed ? 0 : 2].style.width = `${(1 - rightOffset) * 100}%`;
    const invertArrows = this.invertArrows;
    invertArrows[reversed ? 1 : 0].style.display = "";
    invertArrows[reversed ? 0 : 1].style.display = "none";
  }
}
const ANNOTATE_MERGE_SEGMENTS_TOOL_ID = "mergeSegments";
const ANNOTATE_SPLIT_SEGMENTS_TOOL_ID = "splitSegments";
const MERGE_SEGMENTS_INPUT_EVENT_MAP = EventActionMap.fromObject({
  "at:shift?+mousedown0": { action: "merge-segments" },
  "at:shift?+mousedown2": { action: "set-anchor" }
});
const SPLIT_SEGMENTS_INPUT_EVENT_MAP = EventActionMap.fromObject({
  "at:shift?+mousedown0": { action: "split-segments" },
  "at:shift?+alt+mousedown0": { action: "split-and-select-segments" },
  "at:shift?+mousedown2": { action: "set-anchor" }
});
class MergeSegmentsTool extends Tool {
  constructor(layer) {
    super(layer);
    this.lastAnchorBaseSegment = new WatchableValue(void 0);
    const maybeUpdateLastAnchorBaseSegment = () => {
      const anchorSegment = layer.anchorSegment.value;
      if (anchorSegment === void 0) return;
      const segmentSelectionState = layer.displayState.segmentSelectionState;
      if (!segmentSelectionState.hasSelectedSegment) return;
      const segmentEquivalences = layer.displayState.segmentationGroupState.value.segmentEquivalences;
      const mappedAnchorSegment = segmentEquivalences.get(anchorSegment);
      if (!Uint64.equal(segmentSelectionState.selectedSegment, mappedAnchorSegment)) return;
      const base = segmentSelectionState.baseSelectedSegment;
      const isBase = isBaseSegmentId(base);
      const equivalencePolicy = segmentEquivalences.disjointSets.visibleSegmentEquivalencePolicy.value;
      if (equivalencePolicy & VisibleSegmentEquivalencePolicy.NONREPRESENTATIVE_EXCLUDED && isBase || equivalencePolicy & VisibleSegmentEquivalencePolicy.REPRESENTATIVE_EXCLUDED && !isBase) {
        return;
      }
      this.lastAnchorBaseSegment.value = base.clone();
    };
    this.registerDisposer(layer.displayState.segmentSelectionState.changed.add(maybeUpdateLastAnchorBaseSegment));
    this.registerDisposer(layer.anchorSegment.changed.add(maybeUpdateLastAnchorBaseSegment));
  }
  toJSON() {
    return ANNOTATE_MERGE_SEGMENTS_TOOL_ID;
  }
  activate(activation) {
    const segmentationGroupState = this.layer.displayState.segmentationGroupState.value;
    const getAnchorSegment = () => {
      let anchorSegment = this.layer.anchorSegment.value;
      let baseAnchorSegment = this.lastAnchorBaseSegment.value;
      if (anchorSegment === void 0) {
        return { anchorSegment: void 0, error: "Select anchor segment for merge" };
      }
      const anchorGraphSegment = segmentationGroupState.segmentEquivalences.get(anchorSegment);
      if (!segmentationGroupState.visibleSegments.has(anchorGraphSegment)) {
        return { anchorSegment, error: "Anchor segment must be in visible set" };
      }
      if (baseAnchorSegment === void 0 || !Uint64.equal(segmentationGroupState.segmentEquivalences.get(baseAnchorSegment), anchorGraphSegment)) {
        return {
          anchorSegment,
          error: "Hover over base segment within anchor segment that is closest to merge location"
        };
      }
      return { anchorSegment: baseAnchorSegment, error: void 0 };
    };
    const getMergeRequest = () => {
      var _getAnchorSegment = getAnchorSegment();
      let anchorSegment = _getAnchorSegment.anchorSegment, error = _getAnchorSegment.error;
      if (anchorSegment === void 0 || error !== void 0) {
        return { anchorSegment, error, otherSegment: void 0, anchorSegmentValid: false };
      }
      const displayState = this.layer.displayState;
      const otherSegment = displayState.segmentSelectionState.baseValue;
      if (otherSegment === void 0 || Uint64.equal(displayState.segmentSelectionState.selectedSegment, segmentationGroupState.segmentEquivalences.get(anchorSegment))) {
        return {
          anchorSegment,
          otherSegment: void 0,
          error: "Hover over segment to merge",
          anchorSegmentValid: true
        };
      }
      return { anchorSegment, otherSegment, error: void 0, anchorSegmentValid: true };
    };
    var _makeToolActivationSt = makeToolActivationStatusMessageWithHeader(activation);
    const body = _makeToolActivationSt.body, header = _makeToolActivationSt.header;
    header.textContent = "Merge segments";
    body.classList.add("neuroglancer-merge-segments-status");
    activation.bindInputEventMap(MERGE_SEGMENTS_INPUT_EVENT_MAP);
    activation.registerDisposer(() => {
      resetTemporaryVisibleSegmentsState(segmentationGroupState);
    });
    const updateStatus = () => {
      removeChildren(body);
      const displayState = this.layer.displayState;
      var _getMergeRequest = getMergeRequest();
      let anchorSegment = _getMergeRequest.anchorSegment, otherSegment = _getMergeRequest.otherSegment, anchorSegmentValid = _getMergeRequest.anchorSegmentValid, error = _getMergeRequest.error;
      const makeWidget = (id) => {
        const row = makeSegmentWidget(this.layer.displayState, id);
        row.classList.add("neuroglancer-segment-list-entry-double-line");
        return row;
      };
      if (anchorSegment !== void 0) {
        body.appendChild(makeWidget(augmentSegmentId(displayState, anchorSegment)));
      }
      if (error !== void 0) {
        const msg = document.createElement("span");
        msg.textContent = error;
        body.appendChild(msg);
      }
      if (otherSegment !== void 0) {
        const msg = document.createElement("span");
        msg.textContent = " merge ";
        body.appendChild(msg);
        body.appendChild(makeWidget(augmentSegmentId(displayState, otherSegment)));
      }
      const segmentEquivalences = segmentationGroupState.segmentEquivalences;
      if (!anchorSegmentValid) {
        resetTemporaryVisibleSegmentsState(segmentationGroupState);
        return;
      } else {
        segmentationGroupState.useTemporaryVisibleSegments.value = true;
        const tempVisibleSegments = segmentationGroupState.temporaryVisibleSegments;
        tempVisibleSegments.clear();
        tempVisibleSegments.add(segmentEquivalences.get(anchorSegment));
        if (otherSegment !== void 0) {
          tempVisibleSegments.add(segmentEquivalences.get(otherSegment));
        }
      }
    };
    updateStatus();
    activation.registerDisposer(bindSegmentListWidth(this.layer.displayState, body));
    const debouncedUpdateStatus = activation.registerCancellable(animationFrameDebounce(updateStatus));
    registerCallbackWhenSegmentationDisplayStateChanged(this.layer.displayState, activation, debouncedUpdateStatus);
    activation.registerDisposer(this.layer.anchorSegment.changed.add(debouncedUpdateStatus));
    activation.registerDisposer(this.lastAnchorBaseSegment.changed.add(debouncedUpdateStatus));
    activation.bindAction("merge-segments", (event) => {
      event.stopPropagation();
      (async () => {
        const graph = segmentationGroupState.graph.value;
        if (graph === void 0) return;
        var _getMergeRequest2 = getMergeRequest();
        const anchorSegment = _getMergeRequest2.anchorSegment, otherSegment = _getMergeRequest2.otherSegment, error = _getMergeRequest2.error;
        if (anchorSegment === void 0 || otherSegment === void 0 || error !== void 0) {
          return;
        }
        try {
          await graph.merge(anchorSegment, otherSegment);
          StatusMessage.showTemporaryMessage(`Merge performed`);
        } catch (e) {
          StatusMessage.showTemporaryMessage(`Merge failed: ${e}`);
        }
      })();
    });
    activation.bindAction("set-anchor", (event) => {
      event.stopPropagation();
      const segmentSelectionState = this.layer.displayState.segmentSelectionState;
      const other = segmentSelectionState.baseValue;
      if (other === void 0) return;
      const existingAnchor = this.layer.anchorSegment.value;
      segmentationGroupState.visibleSegments.add(other);
      if (existingAnchor === void 0 || !Uint64.equal(existingAnchor, other)) {
        this.layer.anchorSegment.value = other.clone();
        return;
      }
    });
  }
  get description() {
    return "merge";
  }
}
class SplitSegmentsTool extends Tool {
  toJSON() {
    return ANNOTATE_SPLIT_SEGMENTS_TOOL_ID;
  }
  activate(activation) {
    const segmentationGroupState = this.layer.displayState.segmentationGroupState.value;
    const getAnchorSegment = () => {
      let anchorSegment = this.layer.anchorSegment.value;
      if (anchorSegment === void 0) {
        return { anchorSegment: void 0, error: "Select anchor segment for split" };
      }
      const anchorGraphSegment = segmentationGroupState.segmentEquivalences.get(anchorSegment);
      if (!segmentationGroupState.visibleSegments.has(anchorGraphSegment)) {
        return { anchorSegment, error: "Anchor segment must be in visible set" };
      }
      return { anchorSegment, error: void 0 };
    };
    var _makeToolActivationSt2 = makeToolActivationStatusMessageWithHeader(activation);
    const body = _makeToolActivationSt2.body, header = _makeToolActivationSt2.header;
    header.textContent = "Split segments";
    body.classList.add("neuroglancer-merge-segments-status");
    activation.bindInputEventMap(SPLIT_SEGMENTS_INPUT_EVENT_MAP);
    const getSplitRequest = () => {
      var _getAnchorSegment2 = getAnchorSegment();
      let anchorSegment = _getAnchorSegment2.anchorSegment, error = _getAnchorSegment2.error;
      if (anchorSegment === void 0 || error !== void 0) {
        return { anchorSegment, error, otherSegment: void 0, anchorSegmentValid: false };
      }
      const displayState = this.layer.displayState;
      const otherSegment = displayState.segmentSelectionState.baseValue;
      if (otherSegment === void 0 || !Uint64.equal(displayState.segmentSelectionState.selectedSegment, segmentationGroupState.segmentEquivalences.get(anchorSegment)) || Uint64.equal(otherSegment, anchorSegment)) {
        return {
          anchorSegment,
          otherSegment: void 0,
          anchorSegmentValid: true,
          error: "Hover over base segment to seed split"
        };
      }
      return { anchorSegment, otherSegment, anchorSegmentValid: true, error: void 0 };
    };
    activation.registerDisposer(() => {
      resetTemporaryVisibleSegmentsState(segmentationGroupState);
    });
    const updateStatus = () => {
      removeChildren(body);
      const displayState = this.layer.displayState;
      var _getSplitRequest = getSplitRequest();
      let anchorSegment = _getSplitRequest.anchorSegment, otherSegment = _getSplitRequest.otherSegment, anchorSegmentValid = _getSplitRequest.anchorSegmentValid, error = _getSplitRequest.error;
      let anchorSegmentAugmented;
      let otherSegmentAugmented;
      const updateTemporaryState = () => {
        const segmentEquivalences = segmentationGroupState.segmentEquivalences;
        const graphConnection = this.layer.graphConnection;
        if (!anchorSegmentValid || graphConnection === void 0) {
          resetTemporaryVisibleSegmentsState(segmentationGroupState);
          return;
        } else {
          segmentationGroupState.useTemporaryVisibleSegments.value = true;
          if (otherSegment !== void 0) {
            const splitResult = graphConnection.computeSplit(anchorSegment, otherSegment);
            if (splitResult !== void 0) {
              anchorSegmentAugmented = new Uint64MapEntry(anchorSegment, splitResult.includeRepresentative);
              otherSegmentAugmented = new Uint64MapEntry(otherSegment, splitResult.excludeRepresentative);
              segmentationGroupState.useTemporarySegmentEquivalences.value = true;
              const retainedGraphSegment = splitResult.includeRepresentative;
              const excludedGraphSegment = splitResult.excludeRepresentative;
              const tempEquivalences = segmentationGroupState.temporarySegmentEquivalences;
              tempEquivalences.clear();
              for (const segment of splitResult.includeBaseSegments) {
                tempEquivalences.link(segment, retainedGraphSegment);
              }
              for (const segment of splitResult.excludeBaseSegments) {
                tempEquivalences.link(segment, excludedGraphSegment);
              }
              const tempVisibleSegments2 = segmentationGroupState.temporaryVisibleSegments;
              tempVisibleSegments2.clear();
              tempVisibleSegments2.add(retainedGraphSegment);
              tempVisibleSegments2.add(excludedGraphSegment);
              return;
            }
          }
          segmentationGroupState.useTemporarySegmentEquivalences.value = false;
          const tempVisibleSegments = segmentationGroupState.temporaryVisibleSegments;
          tempVisibleSegments.clear();
          tempVisibleSegments.add(segmentEquivalences.get(anchorSegment));
        }
      };
      updateTemporaryState();
      const makeWidget = (id) => {
        const row = makeSegmentWidget(this.layer.displayState, id);
        row.classList.add("neuroglancer-segment-list-entry-double-line");
        return row;
      };
      if (anchorSegment !== void 0) {
        body.appendChild(makeWidget(anchorSegmentAugmented !== null && anchorSegmentAugmented !== void 0 ? anchorSegmentAugmented : augmentSegmentId(displayState, anchorSegment)));
      }
      if (error !== void 0) {
        const msg = document.createElement("span");
        msg.textContent = error;
        body.appendChild(msg);
      }
      if (otherSegmentAugmented !== void 0) {
        const msg = document.createElement("span");
        msg.textContent = " split ";
        body.appendChild(msg);
        body.appendChild(makeWidget(otherSegmentAugmented));
      }
    };
    activation.registerDisposer(bindSegmentListWidth(this.layer.displayState, body));
    updateStatus();
    const debouncedUpdateStatus = activation.registerCancellable(animationFrameDebounce(updateStatus));
    registerCallbackWhenSegmentationDisplayStateChanged(this.layer.displayState, activation, debouncedUpdateStatus);
    activation.registerDisposer(this.layer.anchorSegment.changed.add(debouncedUpdateStatus));
    const splitSegments = async (select) => {
      const graph = segmentationGroupState.graph.value;
      if (graph === void 0) return;
      var _getSplitRequest2 = getSplitRequest();
      const anchorSegment = _getSplitRequest2.anchorSegment, otherSegment = _getSplitRequest2.otherSegment, error = _getSplitRequest2.error;
      if (anchorSegment === void 0 || otherSegment === void 0 || error !== void 0) {
        return;
      }
      try {
        await graph.split(anchorSegment, otherSegment);
        if (select) {
          segmentationGroupState.visibleSegments.add(segmentationGroupState.segmentEquivalences.get(otherSegment));
        }
        StatusMessage.showTemporaryMessage(`Split performed`);
      } catch (e) {
        StatusMessage.showTemporaryMessage(`Split failed: ${e}`);
      }
    };
    activation.bindAction("split-segments", (event) => {
      event.stopPropagation();
      splitSegments(
        /*select=*/
        false
      );
    });
    activation.bindAction("split-and-select-segments", (event) => {
      event.stopPropagation();
      splitSegments(
        /*select=*/
        true
      );
    });
    activation.bindAction("set-anchor", (event) => {
      event.stopPropagation();
      const segmentSelectionState = this.layer.displayState.segmentSelectionState;
      const other = segmentSelectionState.baseValue;
      if (other === void 0) return;
      segmentationGroupState.visibleSegments.add(other);
      const existingAnchor = this.layer.anchorSegment.value;
      if (existingAnchor === void 0 || !Uint64.equal(existingAnchor, other)) {
        this.layer.anchorSegment.value = other.clone();
        return;
      }
    });
  }
  get description() {
    return `split`;
  }
}
function registerSegmentSplitMergeTools() {
  registerLayerTool(SegmentationUserLayer, ANNOTATE_MERGE_SEGMENTS_TOOL_ID, (layer) => {
    return new MergeSegmentsTool(layer);
  });
  registerLayerTool(SegmentationUserLayer, ANNOTATE_SPLIT_SEGMENTS_TOOL_ID, (layer) => {
    return new SplitSegmentsTool(layer);
  });
}
/**
 * /**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2021 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SELECT_SEGMENTS_TOOLS_ID = "selectSegments";
const selectEvent = "mousedown0";
const SELECT_SEGMENTS_INPUT_EVENT_MAP = EventActionMap.fromObject({
  [`at:alt?+shift?+${selectEvent}`]: "drag-select-segments"
});
var ToolState;
(function(ToolState2) {
  ToolState2[ToolState2["IDLE"] = 0] = "IDLE";
  ToolState2[ToolState2["SELECT"] = 1] = "SELECT";
  ToolState2[ToolState2["DESELECT"] = 2] = "DESELECT";
})(ToolState || (ToolState = {}));
class SelectSegmentsTool extends Tool {
  constructor(layer) {
    super(layer);
  }
  toJSON() {
    return SELECT_SEGMENTS_TOOLS_ID;
  }
  activate(activation) {
    const layer = this.layer;
    var _makeToolActivationSt = makeToolActivationStatusMessageWithHeader(activation);
    const body = _makeToolActivationSt.body, header = _makeToolActivationSt.header;
    let currentState = ToolState.IDLE;
    let painting = false;
    activation.bindInputEventMap(SELECT_SEGMENTS_INPUT_EVENT_MAP);
    const getNewState = () => {
      return globalModifiers.value & 2 ? ToolState.DESELECT : ToolState.SELECT;
    };
    const setCurrentState = (state) => {
      if (currentState !== state) {
        currentState = state;
        painting = false;
        updateStatus();
      }
    };
    const updateStatus = () => {
      removeChildren(body);
      const msg = document.createElement("span");
      switch (currentState) {
        case ToolState.IDLE:
          header.textContent = "Select/Deselect segments";
          msg.textContent = `${selectEvent} to select segments; alt+${selectEvent} to deselect segments.`;
          break;
        case ToolState.SELECT:
        case ToolState.DESELECT:
          header.textContent = `${currentState == ToolState.SELECT ? "Select" : "Deselect"} segments`;
          msg.textContent = `Drag to ${currentState == ToolState.SELECT ? "select" : "deselect"} segments (${layer.displayState.segmentationGroupState.value.visibleSegments.size} selected).`;
      }
      body.appendChild(msg);
    };
    updateStatus();
    const trySelectSegment = () => {
      if (currentState == ToolState.IDLE) {
        return;
      }
      const segmentSelectionState = layer.displayState.segmentSelectionState;
      if (segmentSelectionState.hasSelectedSegment) {
        const segment = segmentSelectionState.selectedSegment;
        const visibleSegments = layer.displayState.segmentationGroupState.value.visibleSegments;
        switch (currentState) {
          case ToolState.SELECT:
            visibleSegments.add(segment);
            break;
          case ToolState.DESELECT:
            visibleSegments.delete(segment);
            break;
        }
      }
    };
    activation.registerDisposer(layer.displayState.segmentSelectionState.changed.add(() => {
      if (painting) {
        trySelectSegment();
      }
    }));
    activation.registerDisposer(layer.displayState.segmentationGroupState.value.visibleSegments.changed.add(updateStatus));
    activation.registerDisposer(globalModifiers.changed.add(() => {
      if (currentState != ToolState.IDLE) {
        setCurrentState(getNewState());
      }
    }));
    const startSelecting = (event, state) => {
      event.stopPropagation();
      setCurrentState(state);
      trySelectSegment();
      const baseScreenX = event.detail.screenX;
      const baseScreenY = event.detail.screenY;
      startRelativeMouseDrag(event.detail, (event2, _deltaX, _deltaY) => {
        if (!painting) {
          const deltaScreenX = event2.screenX - baseScreenX;
          const deltaScreenY = event2.screenY - baseScreenY;
          if (deltaScreenX * deltaScreenX + deltaScreenY * deltaScreenY > 25) {
            trySelectSegment();
            painting = true;
          }
        }
      }, (_event) => {
        painting = false;
        setCurrentState(ToolState.IDLE);
      });
    };
    activation.bindAction("drag-select-segments", (event) => startSelecting(event, getNewState()));
  }
  get description() {
    return "select";
  }
}
function registerSegmentSelectTools() {
  registerLayerTool(SegmentationUserLayer, SELECT_SEGMENTS_TOOLS_ID, (layer) => {
    return new SelectSegmentsTool(layer);
  });
}
const tempUint64 = new Uint64();
class SegmentListSource extends RefCounted {
  constructor(query, segmentPropertyMap, segmentationDisplayState, parentElement) {
    super();
    this.query = query;
    this.segmentPropertyMap = segmentPropertyMap;
    this.segmentationDisplayState = segmentationDisplayState;
    this.parentElement = parentElement;
    this.changed = new Signal();
    this.explicitSegmentsVisible = false;
    this.visibleSegmentsGeneration = -1;
    this.queryResult = new WatchableValue(void 0);
    this.statusText = new WatchableValue("");
    this.selectedMatches = 0;
    this.matchStatusTextPrefix = "";
    this.debouncedUpdate = debounce(() => this.update(), 0);
    this.render = (index2) => {
      const explicitSegments = this.explicitSegments;
      let id;
      let visibleList = false;
      if (explicitSegments !== void 0 && index2 < explicitSegments.length) {
        id = explicitSegments[index2];
        visibleList = this.explicitSegmentsVisible;
      } else {
        if (explicitSegments !== void 0) {
          index2 -= explicitSegments.length;
        }
        id = tempUint64;
        const propIndex = this.queryResult.value.indices[index2];
        const ids = this.segmentPropertyMap.segmentPropertyMap.inlineProperties.ids;
        id.low = ids[propIndex * 2];
        id.high = ids[propIndex * 2 + 1];
      }
      const container = this.segmentWidgetFactory.get(id);
      if (visibleList) {
        container.dataset.visibleList = "true";
      }
      return container;
    };
    this.update();
    this.registerDisposer(segmentationDisplayState.segmentationGroupState.value.visibleSegments.changed.add(this.debouncedUpdate));
    this.registerDisposer(query.changed.add(this.debouncedUpdate));
  }
  get numMatches() {
    var _a, _b;
    return (_b = (_a = this.queryResult.value) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0;
  }
  update() {
    var _a;
    const query = this.query.value;
    const segmentPropertyMap = this.segmentPropertyMap;
    const prevQueryResult = this.queryResult.value;
    let queryResult;
    if (this.prevQuery === query) {
      queryResult = prevQueryResult;
    } else {
      const queryParseResult = parseSegmentQuery(segmentPropertyMap, query);
      queryResult = executeSegmentQuery(segmentPropertyMap, queryParseResult);
    }
    const splices = [];
    let changed = false;
    let matchStatusTextPrefix = "";
    const visibleSegments = this.segmentationDisplayState.segmentationGroupState.value.visibleSegments;
    const visibleSegmentsGeneration = visibleSegments.changed.count;
    const prevVisibleSegmentsGeneration = this.visibleSegmentsGeneration;
    const unconstrained = isQueryUnconstrained(queryResult.query);
    if (unconstrained) {
      if (prevVisibleSegmentsGeneration !== visibleSegmentsGeneration || this.explicitSegments === void 0 || !this.explicitSegmentsVisible) {
        this.visibleSegmentsGeneration = visibleSegmentsGeneration;
        const newSortedVisibleSegments = _Array$from(visibleSegments, (x) => x.clone());
        newSortedVisibleSegments.sort(Uint64.compare);
        const explicitSegments2 = this.explicitSegments;
        if (explicitSegments2 === void 0) {
          this.explicitSegments = newSortedVisibleSegments;
          splices.push({ retainCount: 0, insertCount: newSortedVisibleSegments.length, deleteCount: 0 });
        } else {
          splices.push(...getMergeSplices(explicitSegments2, newSortedVisibleSegments, Uint64.compare));
        }
        this.explicitSegments = newSortedVisibleSegments;
        changed = true;
      } else {
        splices.push({ retainCount: this.explicitSegments.length, deleteCount: 0, insertCount: 0 });
      }
      this.explicitSegmentsVisible = true;
    } else {
      this.visibleSegmentsGeneration = visibleSegmentsGeneration;
      if (this.explicitSegments !== void 0 && this.explicitSegmentsVisible) {
        splices.push({ deleteCount: this.explicitSegments.length, retainCount: 0, insertCount: 0 });
        this.explicitSegments = void 0;
        changed = true;
      }
      this.explicitSegmentsVisible = false;
    }
    var _queryResult = queryResult;
    const explicitIds = _queryResult.explicitIds;
    if (explicitIds !== void 0) {
      this.explicitSegments = explicitIds;
    } else if (!this.explicitSegmentsVisible) {
      this.explicitSegments = void 0;
    }
    if (prevQueryResult !== queryResult) {
      splices.push({
        retainCount: 0,
        deleteCount: (_a = prevQueryResult === null || prevQueryResult === void 0 ? void 0 : prevQueryResult.count) !== null && _a !== void 0 ? _a : 0,
        insertCount: queryResult.count
      });
      changed = true;
      this.queryResult.value = queryResult;
    }
    if (queryResult.explicitIds !== void 0) {
      matchStatusTextPrefix = `${queryResult.count} ids`;
    } else if (unconstrained) {
      matchStatusTextPrefix = `${queryResult.count} listed ids`;
    } else if (queryResult.total > 0) {
      matchStatusTextPrefix = `${queryResult.count}/${queryResult.total} matches`;
    }
    if (prevQueryResult !== queryResult || visibleSegmentsGeneration !== prevVisibleSegmentsGeneration) {
      let statusText = matchStatusTextPrefix;
      let selectedMatches = 0;
      if (segmentPropertyMap !== void 0 && queryResult.count > 0) {
        selectedMatches = findQueryResultIntersectionSize(segmentPropertyMap, queryResult, visibleSegments);
        statusText += ` (${selectedMatches} visible)`;
      }
      this.selectedMatches = selectedMatches;
      this.statusText.value = statusText;
    }
    this.prevQuery = query;
    this.matchStatusTextPrefix = matchStatusTextPrefix;
    const explicitSegments = this.explicitSegments;
    this.length = (this.explicitSegmentsVisible ? explicitSegments.length : 0) + queryResult.count;
    if (changed) {
      this.changed.dispatch(splices);
    }
  }
  updateRendering(element) {
    this.segmentWidgetFactory.update(element);
  }
  updateRenderedItems(list) {
    list.forEachRenderedItem((element) => {
      this.updateRendering(element);
    });
  }
}
const keyMap = EventActionMap.fromObject({
  "enter": { action: "toggle-listed" },
  "shift+enter": { action: "hide-listed" },
  "control+enter": { action: "hide-all" },
  "escape": { action: "cancel" }
});
const selectSegmentConfirmationThreshold = 100;
function updateInputBoundWidth(inputElement) {
  updateInputFieldWidth$1(inputElement, Math.max(1, inputElement.value.length + 0.1));
}
function updateInputBoundValue(inputElement, bound) {
  let boundString;
  if (_Number$isInteger(bound)) {
    boundString = bound.toString();
  } else {
    const sFull = bound.toString();
    const sPrecision = bound.toPrecision(6);
    boundString = sFull.length < sPrecision.length ? sFull : sPrecision;
  }
  inputElement.value = boundString;
  updateInputBoundWidth(inputElement);
}
function createBoundInput(boundType, endpointIndex) {
  const e = document.createElement("input");
  e.addEventListener("focus", () => {
    e.select();
  });
  e.classList.add(`neuroglancer-segment-query-result-numerical-plot-${boundType}-bound`);
  e.classList.add("neuroglancer-segment-query-result-numerical-plot-bound");
  e.type = "text";
  e.spellcheck = false;
  e.autocomplete = "off";
  e.title = (endpointIndex === 0 ? "Lower" : "Upper") + " bound " + (boundType === "range" ? "range" : "for distribution");
  e.addEventListener("input", () => {
    updateInputBoundWidth(e);
  });
  return e;
}
function toggleIncludeColumn(queryResult, setQuery, fieldId) {
  if (queryResult === void 0) return;
  if (queryResult.indices === void 0) return;
  const query = queryResult.query;
  let sortBy = query.sortBy, includeColumns = query.includeColumns;
  const included = queryIncludesColumn(query, fieldId);
  if (included) {
    sortBy = sortBy.filter((x) => x.fieldId !== fieldId);
    includeColumns = includeColumns.filter((x) => x !== fieldId);
  } else {
    includeColumns.push(fieldId);
  }
  setQuery(_Object$assign(_Object$assign({}, query), { sortBy, includeColumns }));
}
function toggleSortOrder(queryResult, setQuery, id) {
  var _a;
  const query = queryResult === null || queryResult === void 0 ? void 0 : queryResult.query;
  const sortBy = query === null || query === void 0 ? void 0 : query.sortBy;
  if (sortBy === void 0) return;
  const includeColumns = query.includeColumns;
  const prevOrder = (_a = sortBy.find((x) => x.fieldId === id)) === null || _a === void 0 ? void 0 : _a.order;
  const newOrder = prevOrder === "<" ? ">" : "<";
  const newIncludeColumns = includeColumns.filter((x) => x !== id);
  for (const s of sortBy) {
    if (s.fieldId !== "id" && s.fieldId !== "label" && s.fieldId !== id) {
      newIncludeColumns.push(s.fieldId);
    }
  }
  setQuery(_Object$assign(_Object$assign({}, query), { sortBy: [{ fieldId: id, order: newOrder }], includeColumns: newIncludeColumns }));
}
function updateColumnSortIcon(queryResult, sortIcon, id) {
  var _a, _b;
  const sortBy = (_a = queryResult === null || queryResult === void 0 ? void 0 : queryResult.query) === null || _a === void 0 ? void 0 : _a.sortBy;
  const order = (_b = sortBy === null || sortBy === void 0 ? void 0 : sortBy.find((s) => s.fieldId === id)) === null || _b === void 0 ? void 0 : _b.order;
  sortIcon.textContent = order === ">" ? "▼" : "▲";
  sortIcon.style.visibility = order === void 0 ? "" : "visible";
  sortIcon.title = `Sort by ${id} in ${order === "<" ? "descending" : "ascending"} order`;
}
class NumericalPropertiesSummary extends RefCounted {
  constructor(segmentPropertyMap, queryResult, setQuery) {
    super();
    this.segmentPropertyMap = segmentPropertyMap;
    this.queryResult = queryResult;
    this.setQuery = setQuery;
    this.propertyHistograms = [];
    this.bounds = {
      window: new WatchableValue([]),
      range: new WatchableValue([])
    };
    this.throttledUpdate = this.registerCancellable(throttle(() => this.updateHistograms(), 100));
    this.debouncedRender = this.registerCancellable(animationFrameDebounce(() => this.updateHistogramRenderings()));
    this.debouncedSetQuery = this.registerCancellable(debounce(() => this.setQueryFromBounds(), 200));
    const properties = segmentPropertyMap === null || segmentPropertyMap === void 0 ? void 0 : segmentPropertyMap.numericalProperties;
    const propertySummaries = [];
    let listElement;
    if (properties !== void 0 && properties.length > 0) {
      listElement = document.createElement("details");
      const summaryElement = document.createElement("summary");
      summaryElement.textContent = `${properties.length} numerical propert${properties.length > 1 ? "ies" : "y"}`;
      listElement.appendChild(summaryElement);
      listElement.classList.add("neuroglancer-segment-query-result-numerical-list");
      const windowBounds = this.bounds.window.value;
      for (let i = 0, numProperties = properties.length; i < numProperties; ++i) {
        const property = properties[i];
        const summary = this.makeNumericalPropertySummary(i, property);
        propertySummaries.push(summary);
        listElement.appendChild(summary.element);
        windowBounds[i] = property.bounds;
      }
    }
    this.listElement = listElement;
    this.properties = propertySummaries;
    this.registerDisposer(this.queryResult.changed.add(() => {
      this.handleNewQueryResult();
    }));
    this.registerDisposer(this.bounds.window.changed.add(this.throttledUpdate));
    this.registerDisposer(this.bounds.window.changed.add(this.debouncedRender));
    this.registerDisposer(this.bounds.range.changed.add(this.debouncedRender));
    this.registerDisposer(this.bounds.range.changed.add(this.debouncedSetQuery));
    this.handleNewQueryResult();
  }
  setQueryFromBounds() {
    const queryResult = this.queryResult.value;
    if (queryResult === void 0) return;
    if (queryResult.indices === void 0) return;
    const query = queryResult.query;
    const numericalConstraints = [];
    const constraintBounds = this.bounds.range.value;
    const properties = this.properties;
    for (let i = 0, numProperties = properties.length; i < numProperties; ++i) {
      const property = properties[i].property;
      numericalConstraints.push({ fieldId: property.id, bounds: constraintBounds[i] });
    }
    this.setQuery(_Object$assign(_Object$assign({}, query), { numericalConstraints }));
  }
  getBounds(propertyIndex) {
    const bounds = this.bounds;
    return { range: bounds.range.value[propertyIndex], window: bounds.window.value[propertyIndex] };
  }
  setBounds(propertyIndex, value) {
    const property = this.properties[propertyIndex].property;
    let newRange = getClampedInterval(property.bounds, value.range);
    if (dataTypeCompare(newRange[0], newRange[1]) > 0) {
      newRange = [newRange[1], newRange[0]];
    }
    const newWindow = getClampedInterval(property.bounds, value.window);
    const oldValue = this.getBounds(propertyIndex);
    const dataType = this.properties[propertyIndex].property.dataType;
    if (!dataTypeIntervalEqual(dataType, newWindow, oldValue.window)) {
      this.bounds.window.value[propertyIndex] = newWindow;
      this.bounds.window.changed.dispatch();
    }
    if (!dataTypeIntervalEqual(dataType, newRange, oldValue.range)) {
      this.bounds.range.value[propertyIndex] = newRange;
      this.bounds.range.changed.dispatch();
    }
  }
  setBound(boundType, endpoint, propertyIndex, value) {
    const property = this.segmentPropertyMap.numericalProperties[propertyIndex];
    const baseBounds = property.bounds;
    value = clampToInterval(baseBounds, value);
    const params = this.getBounds(propertyIndex);
    const newParams = getUpdatedRangeAndWindowParameters(
      params,
      boundType,
      endpoint,
      value,
      /*fitRangeInWindow=*/
      true
    );
    this.setBounds(propertyIndex, newParams);
  }
  handleNewQueryResult() {
    const queryResult = this.queryResult.value;
    const listElement = this.listElement;
    if (listElement === void 0) return;
    if ((queryResult === null || queryResult === void 0 ? void 0 : queryResult.indices) !== void 0) {
      const numericalConstraints = queryResult.query.numericalConstraints;
      const numericalProperties = this.segmentPropertyMap.numericalProperties;
      const constraintBounds = this.bounds.range.value;
      const numConstraints = numericalConstraints.length;
      const numProperties = numericalProperties.length;
      constraintBounds.length = numProperties;
      for (let i = 0; i < numProperties; ++i) {
        constraintBounds[i] = numericalProperties[i].bounds;
      }
      for (let i = 0; i < numConstraints; ++i) {
        const constraint = numericalConstraints[i];
        const propertyIndex = numericalProperties.findIndex((p) => p.id === constraint.fieldId);
        constraintBounds[propertyIndex] = constraint.bounds;
      }
    }
    this.updateHistograms();
    this.throttledUpdate.cancel();
  }
  updateHistograms() {
    const queryResult = this.queryResult.value;
    const listElement = this.listElement;
    if (listElement === void 0) return;
    updatePropertyHistograms(this.segmentPropertyMap, queryResult, this.propertyHistograms, this.bounds.window.value);
    this.updateHistogramRenderings();
  }
  updateHistogramRenderings() {
    this.debouncedRender.cancel();
    const listElement = this.listElement;
    if (listElement === void 0) return;
    const propertyHistograms = this.propertyHistograms;
    if (propertyHistograms.length === 0) {
      listElement.style.display = "none";
      return;
    }
    listElement.style.display = "";
    const properties = this.properties;
    for (let i = 0, n = properties.length; i < n; ++i) {
      this.updateNumericalPropertySummary(i, properties[i], propertyHistograms[i]);
    }
  }
  makeNumericalPropertySummary(propertyIndex, property) {
    const plotContainer = document.createElement("div");
    plotContainer.classList.add("neuroglancer-segment-query-result-numerical-plot-container");
    const plotImg = document.createElement("img");
    plotImg.classList.add("neuroglancer-segment-query-result-numerical-plot");
    const controller = new CdfController(plotImg, property.dataType, () => this.getBounds(propertyIndex), (bounds) => this.setBounds(propertyIndex, bounds));
    const sortIcon = document.createElement("span");
    sortIcon.classList.add("neuroglancer-segment-query-result-numerical-plot-sort");
    const columnCheckbox = document.createElement("input");
    columnCheckbox.type = "checkbox";
    columnCheckbox.addEventListener("click", () => {
      toggleIncludeColumn(this.queryResult.value, this.setQuery, property.id);
    });
    const makeBoundElements = (boundType) => {
      const container = document.createElement("div");
      container.classList.add("neuroglancer-segment-query-result-numerical-plot-bounds");
      container.classList.add(`neuroglancer-segment-query-result-numerical-plot-bounds-${boundType}`);
      const makeBoundElement = (endpointIndex) => {
        const e = createBoundInput(boundType, endpointIndex);
        e.addEventListener("change", () => {
          const existingBounds = this.bounds[boundType].value[propertyIndex];
          if (existingBounds === void 0) return;
          try {
            const value = parseDataTypeValue(property.dataType, e.value);
            this.setBound(boundType, endpointIndex, propertyIndex, value);
            this.bounds[boundType].changed.dispatch();
          } catch (_a) {
          }
          updateInputBoundValue(e, this.bounds[boundType].value[propertyIndex][endpointIndex]);
        });
        return e;
      };
      const inputs = [makeBoundElement(0), makeBoundElement(1)];
      let spacers;
      if (boundType === "range") {
        spacers = [document.createElement("div"), document.createElement("div"), document.createElement("div")];
        spacers[1].classList.add("neuroglancer-segment-query-result-numerical-plot-bound-constraint-spacer");
        spacers[1].appendChild(columnCheckbox);
        const label = document.createElement("span");
        label.classList.add("neuroglancer-segment-query-result-numerical-plot-label");
        label.appendChild(document.createTextNode(property.id));
        label.appendChild(sortIcon);
        label.addEventListener("click", () => {
          toggleSortOrder(this.queryResult.value, this.setQuery, property.id);
        });
        spacers[1].appendChild(label);
        const description = property.description;
        if (description) {
          spacers[1].title = description;
        }
        container.appendChild(spacers[0]);
        container.appendChild(inputs[0]);
        const lessEqual1 = document.createElement("div");
        lessEqual1.textContent = "≤";
        lessEqual1.classList.add("neuroglancer-segment-query-result-numerical-plot-bound-constraint-symbol");
        container.appendChild(lessEqual1);
        container.appendChild(spacers[1]);
        const lessEqual2 = document.createElement("div");
        lessEqual2.textContent = "≤";
        lessEqual2.classList.add("neuroglancer-segment-query-result-numerical-plot-bound-constraint-symbol");
        container.appendChild(lessEqual2);
        container.appendChild(inputs[1]);
        container.appendChild(spacers[2]);
      } else {
        container.appendChild(inputs[0]);
        container.appendChild(inputs[1]);
      }
      return { container, spacers, inputs };
    };
    const boundElements = {
      range: makeBoundElements("range"),
      window: makeBoundElements("window")
    };
    plotContainer.appendChild(boundElements.range.container);
    plotContainer.appendChild(plotImg);
    plotContainer.appendChild(boundElements.window.container);
    return {
      property,
      controller,
      element: plotContainer,
      plotImg,
      boundElements,
      bounds: {
        window: [NaN, NaN],
        range: [NaN, NaN]
      },
      propertyHistogram: void 0,
      columnCheckbox,
      sortIcon
    };
  }
  updateNumericalPropertySummary(propertyIndex, summary, propertyHistogram) {
    const prevWindowBounds = summary.bounds.window;
    const windowBounds = this.bounds.window.value[propertyIndex];
    const prevConstraintBounds = summary.bounds.range;
    const constraintBounds = this.bounds.range.value[propertyIndex];
    const property = summary.property;
    const queryResult = this.queryResult.value;
    const isIncluded = queryIncludesColumn(queryResult === null || queryResult === void 0 ? void 0 : queryResult.query, property.id);
    summary.columnCheckbox.checked = isIncluded;
    summary.columnCheckbox.title = isIncluded ? "Remove column from result table" : "Add column to result table";
    updateColumnSortIcon(queryResult, summary.sortIcon, property.id);
    if (summary.propertyHistogram === propertyHistogram && dataTypeIntervalEqual(property.dataType, prevWindowBounds, windowBounds) && dataTypeIntervalEqual(property.dataType, prevConstraintBounds, constraintBounds)) {
      return;
    }
    const histogram = propertyHistogram.histogram;
    const svgNs = "http://www.w3.org/2000/svg";
    const plotElement = document.createElementNS(svgNs, "svg");
    plotElement.setAttribute("width", `1`);
    plotElement.setAttribute("height", `1`);
    plotElement.setAttribute("preserveAspectRatio", "none");
    const rect = document.createElementNS(svgNs, "rect");
    const constraintStartX = computeInvlerp(windowBounds, constraintBounds[0]);
    const constraintEndX = computeInvlerp(windowBounds, constraintBounds[1]);
    rect.setAttribute("x", `${constraintStartX}`);
    rect.setAttribute("y", "0");
    rect.setAttribute("width", `${constraintEndX - constraintStartX}`);
    rect.setAttribute("height", "1");
    rect.setAttribute("fill", "#4f4f4f");
    plotElement.appendChild(rect);
    const numBins = histogram.length;
    const makeCdfLine = (startBinIndex, endBinIndex, endBinIndexForTotal) => {
      const polyLine = document.createElementNS(svgNs, "polyline");
      let points = "";
      let totalCount = 0;
      for (let i = startBinIndex; i < endBinIndexForTotal; ++i) {
        totalCount += histogram[i];
      }
      if (totalCount === 0) return void 0;
      const startBinX = computeInvlerp(windowBounds, propertyHistogram.window[0]);
      const endBinX = computeInvlerp(windowBounds, propertyHistogram.window[1]);
      const addPoint = (i, height) => {
        const fraction = i / (numBins - 2);
        const x = startBinX * (1 - fraction) + endBinX * fraction;
        points += ` ${x},${1 - height}`;
      };
      if (startBinIndex !== 0) {
        addPoint(startBinIndex, 0);
      }
      let cumSum = 0;
      for (let i = startBinIndex; i < endBinIndex; ++i) {
        const count = histogram[i];
        cumSum += count;
        addPoint(i, cumSum / totalCount);
      }
      polyLine.setAttribute("fill", "none");
      polyLine.setAttribute("stroke-width", "1px");
      polyLine.setAttribute("points", points);
      polyLine.setAttribute("vector-effect", "non-scaling-stroke");
      return polyLine;
    };
    {
      const polyLine = makeCdfLine(0, numBins - 1, numBins);
      if (polyLine !== void 0) {
        polyLine.setAttribute("stroke", "cyan");
        plotElement.appendChild(polyLine);
      }
    }
    if (!dataTypeIntervalEqual(property.dataType, property.bounds, constraintBounds)) {
      const constraintStartBin = Math.floor(Math.max(0, Math.min(1, computeInvlerp(propertyHistogram.window, constraintBounds[0]))) * (numBins - 2));
      const constraintEndBin = Math.ceil(Math.max(0, Math.min(1, computeInvlerp(propertyHistogram.window, constraintBounds[1]))) * (numBins - 2));
      const polyLine = makeCdfLine(constraintStartBin, constraintEndBin, constraintEndBin);
      if (polyLine !== void 0) {
        polyLine.setAttribute("stroke", "white");
        plotElement.appendChild(polyLine);
      }
    }
    const xml = new XMLSerializer().serializeToString(plotElement);
    summary.plotImg.src = `data:image/svg+xml;base64,${btoa(xml)}`;
    summary.propertyHistogram = propertyHistogram;
    for (let endpointIndex = 0; endpointIndex < 2; ++endpointIndex) {
      prevWindowBounds[endpointIndex] = windowBounds[endpointIndex];
      updateInputBoundValue(summary.boundElements.window.inputs[endpointIndex], windowBounds[endpointIndex]);
      prevConstraintBounds[endpointIndex] = constraintBounds[endpointIndex];
      updateInputBoundValue(summary.boundElements.range.inputs[endpointIndex], constraintBounds[endpointIndex]);
    }
    const spacers = summary.boundElements.range.spacers;
    const clampedRange = getClampedInterval(windowBounds, constraintBounds);
    const effectiveFraction = getIntervalBoundsEffectiveFraction(property.dataType, windowBounds);
    const leftOffset = computeInvlerp(windowBounds, clampedRange[0]) * effectiveFraction;
    const rightOffset = computeInvlerp(windowBounds, clampedRange[1]) * effectiveFraction + (1 - effectiveFraction);
    spacers[0].style.width = `${leftOffset * 100}%`;
    spacers[2].style.width = `${(1 - rightOffset) * 100}%`;
  }
}
function renderTagSummary(queryResult, setQuery) {
  const tags = queryResult.tags;
  if (tags === void 0 || tags.length === 0) return void 0;
  const filterQuery = queryResult.query;
  const tagList = document.createElement("div");
  tagList.classList.add("neuroglancer-segment-query-result-tag-list");
  for (const _ref of tags) {
    const tag = _ref.tag;
    const count = _ref.count;
    const tagElement = document.createElement("div");
    tagElement.classList.add("neuroglancer-segment-query-result-tag");
    const tagName = document.createElement("span");
    tagName.classList.add("neuroglancer-segment-query-result-tag-name");
    tagName.textContent = tag;
    tagList.appendChild(tagElement);
    const included = filterQuery.includeTags.includes(tag);
    const excluded = filterQuery.excludeTags.includes(tag);
    let toggleTooltip;
    if (included) {
      toggleTooltip = "Remove tag from required set";
    } else if (excluded) {
      toggleTooltip = "Remove tag from excluded set";
    } else {
      toggleTooltip = "Add tag to required set";
    }
    tagName.addEventListener("click", () => {
      setQuery(changeTagConstraintInSegmentQuery(filterQuery, tag, true, !included && !excluded));
    });
    tagName.title = toggleTooltip;
    const inQuery = included || excluded;
    const addIncludeExcludeButton = (include) => {
      const includeExcludeCount = include ? count : queryResult.count - count;
      const includeElement = document.createElement("div");
      includeElement.classList.add(`neuroglancer-segment-query-result-tag-toggle`);
      includeElement.classList.add(`neuroglancer-segment-query-result-tag-${include ? "include" : "exclude"}`);
      tagElement.appendChild(includeElement);
      if (!inQuery && includeExcludeCount === 0) return;
      const selected = include ? included : excluded;
      includeElement.appendChild(new CheckboxIcon({
        get value() {
          return selected;
        },
        set value(value) {
          setQuery(changeTagConstraintInSegmentQuery(filterQuery, tag, include, value));
        },
        changed: neverSignal
      }, {
        text: include ? "+" : "-",
        enableTitle: `Add tag to ${include ? "required" : "exclusion"} set`,
        disableTitle: `Remove tag from ${include ? "required" : "exclusion"} set`,
        backgroundScheme: "dark"
      }).element);
    };
    addIncludeExcludeButton(true);
    addIncludeExcludeButton(false);
    tagElement.appendChild(tagName);
    const numElement = document.createElement("span");
    numElement.classList.add("neuroglancer-segment-query-result-tag-count");
    if (!inQuery) {
      numElement.textContent = count.toString();
    }
    tagElement.appendChild(numElement);
  }
  return tagList;
}
class SegmentDisplayTab extends Tab {
  constructor(layer) {
    super();
    this.layer = layer;
    const element = this.element;
    element.classList.add("neuroglancer-segment-display-tab");
    element.appendChild(this.registerDisposer(new DependentViewWidget(layer.displayState.segmentationGroupState.value.graph, (graph, parent, context) => {
      if (graph === void 0) return;
      const toolbox2 = document.createElement("div");
      toolbox2.className = "neuroglancer-segmentation-toolbox";
      toolbox2.appendChild(makeToolButton(context, layer, {
        toolJson: ANNOTATE_MERGE_SEGMENTS_TOOL_ID,
        label: "Merge",
        title: "Merge segments"
      }));
      toolbox2.appendChild(makeToolButton(context, layer, {
        toolJson: ANNOTATE_SPLIT_SEGMENTS_TOOL_ID,
        label: "Split",
        title: "Split segments"
      }));
      parent.appendChild(toolbox2);
    })).element);
    const toolbox = document.createElement("div");
    toolbox.className = "neuroglancer-segmentation-toolbox";
    toolbox.appendChild(makeToolButton(this, layer, {
      toolJson: SELECT_SEGMENTS_TOOLS_ID,
      label: "Select",
      title: "Select/Deselect segments"
    }));
    element.appendChild(toolbox);
    const queryElement = document.createElement("input");
    queryElement.classList.add("neuroglancer-segment-list-query");
    queryElement.addEventListener("focus", () => {
      queryElement.select();
    });
    const keyboardHandler = this.registerDisposer(new KeyboardEventBinder(queryElement, keyMap));
    keyboardHandler.allShortcutsAreGlobal = true;
    const segmentQuery = this.layer.displayState.segmentQuery;
    const debouncedUpdateQueryModel = this.registerCancellable(debounce(() => {
      segmentQuery.value = queryElement.value;
    }, 200));
    queryElement.autocomplete = "off";
    queryElement.title = keyMap.describe();
    queryElement.spellcheck = false;
    queryElement.placeholder = "Enter ID, name prefix or /regexp";
    this.registerDisposer(observeWatchable((q) => {
      queryElement.value = q;
    }, segmentQuery));
    this.registerDisposer(observeWatchable((t) => {
      if (Date.now() - t < 100) {
        setTimeout(() => {
          queryElement.focus();
        }, 0);
        this.layer.segmentQueryFocusTime.value = Number.NEGATIVE_INFINITY;
      }
    }, this.layer.segmentQueryFocusTime));
    element.appendChild(queryElement);
    element.appendChild(this.registerDisposer(new DependentViewWidget(
      // segmentLabelMap is guaranteed to change if segmentationGroupState changes.
      layer.displayState.segmentPropertyMap,
      (segmentPropertyMap, parent, context) => {
        const setQuery = (newQuery) => {
          queryElement.focus();
          queryElement.select();
          const value = unparseSegmentQuery(segmentPropertyMap, newQuery);
          document.execCommand("insertText", false, value);
          segmentQuery.value = value;
          queryElement.select();
        };
        const listSource = context.registerDisposer(new SegmentListSource(segmentQuery, segmentPropertyMap, layer.displayState, parent));
        const group = layer.displayState.segmentationGroupState.value;
        const queryErrors = document.createElement("ul");
        queryErrors.classList.add("neuroglancer-segment-query-errors");
        parent.appendChild(queryErrors);
        const queryStatisticsContainer = document.createElement("div");
        queryStatisticsContainer.classList.add("neuroglancer-segment-query-result-statistics");
        const selectionStatusContainer = document.createElement("span");
        const selectionClearButton = document.createElement("input");
        selectionClearButton.type = "checkbox";
        selectionClearButton.checked = true;
        selectionClearButton.title = "Deselect all segment IDs";
        selectionClearButton.addEventListener("change", () => {
          group.visibleSegments.clear();
        });
        const selectionCopyButton = makeCopyButton({
          title: "Copy visible segment IDs",
          onClick: () => {
            const visibleSegments = _Array$from(group.visibleSegments, (x) => x.clone());
            visibleSegments.sort(Uint64.compare);
            setClipboard(visibleSegments.join(", "));
          }
        });
        const selectionStatusMessage = document.createElement("span");
        selectionStatusContainer.appendChild(selectionCopyButton);
        selectionStatusContainer.appendChild(selectionClearButton);
        selectionStatusContainer.appendChild(selectionStatusMessage);
        const matchStatusContainer = document.createElement("span");
        const matchCheckbox = document.createElement("input");
        const matchCopyButton = makeCopyButton({
          onClick: () => {
            debouncedUpdateQueryModel();
            debouncedUpdateQueryModel.flush();
            listSource.debouncedUpdate.flush();
            const queryResult = listSource.queryResult.value;
            if (queryResult === void 0) return;
            const segmentStrings = new Array(queryResult.count);
            forEachQueryResultSegmentId(segmentPropertyMap, queryResult, (id, i) => {
              segmentStrings[i] = id.toString();
            });
            setClipboard(segmentStrings.join(", "));
          }
        });
        matchCheckbox.type = "checkbox";
        const toggleMatches = () => {
          debouncedUpdateQueryModel();
          debouncedUpdateQueryModel.flush();
          listSource.debouncedUpdate.flush();
          const queryResult = listSource.queryResult.value;
          if (queryResult === void 0) return;
          const visibleSegments = group.visibleSegments;
          const selectedMatches = listSource.selectedMatches;
          const shouldSelect = selectedMatches !== queryResult.count;
          if (shouldSelect && queryResult.count - selectedMatches > selectSegmentConfirmationThreshold) {
            if (!hasConfirmed) {
              hasConfirmed = true;
              matchStatusMessage.textContent = `Confirm: show ${queryResult.count - selectedMatches} segments?`;
              return false;
            }
            hasConfirmed = false;
            updateStatus();
          }
          forEachQueryResultSegmentId(segmentPropertyMap, queryResult, (id) => {
            visibleSegments.set(id, shouldSelect);
          });
          return true;
        };
        matchCheckbox.addEventListener("click", (event) => {
          if (!toggleMatches()) event.preventDefault();
        });
        const matchStatusMessage = document.createElement("span");
        matchStatusContainer.appendChild(matchCopyButton);
        matchStatusContainer.appendChild(matchCheckbox);
        matchStatusContainer.appendChild(matchStatusMessage);
        selectionStatusContainer.classList.add("neuroglancer-segment-list-status");
        matchStatusContainer.classList.add("neuroglancer-segment-list-status");
        parent.appendChild(queryStatisticsContainer);
        const queryStatisticsSeparator = document.createElement("div");
        queryStatisticsSeparator.classList.add("neuroglancer-segment-query-result-statistics-separator");
        parent.appendChild(queryStatisticsSeparator);
        parent.appendChild(matchStatusContainer);
        parent.appendChild(selectionStatusContainer);
        let prevNumSelected = -1;
        const updateStatus = () => {
          const numSelected = group.visibleSegments.size;
          if (prevNumSelected !== numSelected) {
            prevNumSelected = numSelected;
            selectionStatusMessage.textContent = `${numSelected} visible in total`;
            selectionClearButton.checked = numSelected > 0;
            selectionClearButton.style.visibility = numSelected ? "visible" : "hidden";
            selectionCopyButton.style.visibility = numSelected ? "visible" : "hidden";
          }
          matchStatusMessage.textContent = listSource.statusText.value;
          const numMatches = listSource.numMatches, selectedMatches = listSource.selectedMatches;
          matchCopyButton.style.visibility = numMatches ? "visible" : "hidden";
          matchCopyButton.title = `Copy ${numMatches} segment ID(s)`;
          matchCheckbox.style.visibility = numMatches ? "visible" : "hidden";
          if (selectedMatches === 0) {
            matchCheckbox.checked = false;
            matchCheckbox.indeterminate = false;
            matchCheckbox.title = `Show ${numMatches} segment ID(s)`;
          } else if (selectedMatches === numMatches) {
            matchCheckbox.checked = true;
            matchCheckbox.indeterminate = false;
            matchCheckbox.title = `Hide ${selectedMatches} segment ID(s)`;
          } else {
            matchCheckbox.checked = true;
            matchCheckbox.indeterminate = true;
            matchCheckbox.title = `Show ${numMatches - selectedMatches} segment ID(s)`;
          }
        };
        updateStatus();
        listSource.statusText.changed.add(updateStatus);
        context.registerDisposer(group.visibleSegments.changed.add(updateStatus));
        let hasConfirmed = false;
        context.registerEventListener(queryElement, "input", () => {
          debouncedUpdateQueryModel();
          if (hasConfirmed) {
            hasConfirmed = false;
            updateStatus();
          }
        });
        context.registerDisposer(registerActionListener(queryElement, "cancel", () => {
          queryElement.focus();
          queryElement.select();
          document.execCommand("delete");
          queryElement.blur();
          queryElement.value = "";
          segmentQuery.value = "";
          hasConfirmed = false;
          updateStatus();
        }));
        context.registerDisposer(registerActionListener(queryElement, "toggle-listed", toggleMatches));
        context.registerDisposer(registerActionListener(queryElement, "hide-all", () => {
          group.visibleSegments.clear();
        }));
        context.registerDisposer(registerActionListener(queryElement, "hide-listed", () => {
          debouncedUpdateQueryModel();
          debouncedUpdateQueryModel.flush();
          listSource.debouncedUpdate.flush();
          const visibleSegments = group.visibleSegments;
          if (segmentQuery.value === "") {
            visibleSegments.clear();
          } else {
            const queryResult = listSource.queryResult.value;
            if (queryResult === void 0) return;
            forEachQueryResultSegmentId(segmentPropertyMap, queryResult, (id) => {
              visibleSegments.delete(id);
            });
          }
        }));
        const list = context.registerDisposer(new VirtualList({ source: listSource, horizontalScroll: true }));
        const updateListItems = context.registerCancellable(animationFrameDebounce(() => {
          listSource.updateRenderedItems(list);
        }));
        const displayState = this.layer.displayState;
        context.registerDisposer(displayState.segmentSelectionState.changed.add(updateListItems));
        context.registerDisposer(group.visibleSegments.changed.add(updateListItems));
        context.registerDisposer(displayState.segmentColorHash.changed.add(updateListItems));
        context.registerDisposer(displayState.segmentStatedColors.changed.add(updateListItems));
        context.registerDisposer(displayState.segmentDefaultColor.changed.add(updateListItems));
        list.element.classList.add("neuroglancer-segment-list");
        context.registerDisposer(layer.bindSegmentListWidth(list.element));
        context.registerDisposer(new MouseEventBinder(list.element, getDefaultSelectBindings()));
        const numericalPropertySummaries = context.registerDisposer(new NumericalPropertiesSummary(segmentPropertyMap, listSource.queryResult, setQuery));
        {
          const listElement = numericalPropertySummaries.listElement;
          if (listElement !== void 0) {
            queryStatisticsContainer.appendChild(listElement);
          }
        }
        let tagSummary = void 0;
        const updateQueryErrors = (queryResult) => {
          const errors = queryResult === null || queryResult === void 0 ? void 0 : queryResult.errors;
          removeChildren(queryErrors);
          if (errors === void 0) return;
          for (const error of errors) {
            const errorElement = document.createElement("li");
            errorElement.textContent = error.message;
            queryErrors.appendChild(errorElement);
          }
        };
        observeWatchable((queryResult) => {
          listSource.segmentWidgetFactory = new SegmentWidgetWithExtraColumnsFactory(listSource.segmentationDisplayState, listSource.parentElement, (property) => queryIncludesColumn(queryResult === null || queryResult === void 0 ? void 0 : queryResult.query, property.id));
          list.scrollToTop();
          removeChildren(list.header);
          if (segmentPropertyMap !== void 0) {
            const header = listSource.segmentWidgetFactory.getHeader();
            header.container.classList.add("neuroglancer-segment-list-header");
            for (const headerLabel of header.propertyLabels) {
              const label = headerLabel.label, sortIcon = headerLabel.sortIcon, id = headerLabel.id;
              label.addEventListener("click", () => {
                toggleSortOrder(listSource.queryResult.value, setQuery, id);
              });
              updateColumnSortIcon(queryResult, sortIcon, id);
            }
            list.header.appendChild(header.container);
          }
          updateQueryErrors(queryResult);
          queryStatisticsSeparator.style.display = "none";
          tagSummary === null || tagSummary === void 0 ? void 0 : tagSummary.remove();
          if (queryResult === void 0) return;
          let query = queryResult.query;
          if (query.errors !== void 0 || query.ids !== void 0) return;
          tagSummary = renderTagSummary(queryResult, setQuery);
          if (tagSummary !== void 0) {
            queryStatisticsContainer.appendChild(tagSummary);
          }
          if (numericalPropertySummaries.properties.length > 0 || tagSummary !== void 0) {
            queryStatisticsSeparator.style.display = "";
          }
        }, listSource.queryResult);
        parent.appendChild(list.element);
      }
    )).element);
  }
}
function makeHelpButton(options = {}) {
  return makeIcon(_Object$assign({ text: "?" }, options));
}
function makeControl(context, layer, options, visibility) {
  const controlContainer = document.createElement("label");
  controlContainer.classList.add("neuroglancer-layer-control-container");
  const labelContainer = document.createElement("div");
  labelContainer.classList.add("neuroglancer-layer-control-label-container");
  const label = document.createElement("div");
  label.classList.add("neuroglancer-layer-control-label");
  labelContainer.appendChild(label);
  const labelTextContainer = document.createElement("div");
  labelTextContainer.classList.add("neuroglancer-layer-control-label-text-container");
  labelTextContainer.appendChild(document.createTextNode(options.label));
  label.appendChild(labelTextContainer);
  if (options.title) {
    label.title = options.title;
  }
  controlContainer.appendChild(labelContainer);
  var _options$makeControl = options.makeControl(layer, context, { labelContainer, labelTextContainer, display: layer.manager.root.display, visibility });
  const control = _options$makeControl.control, controlElement = _options$makeControl.controlElement;
  controlElement.classList.add("neuroglancer-layer-control-control");
  controlContainer.appendChild(controlElement);
  return { controlContainer, label, labelContainer, labelTextContainer, control };
}
class LayerControlTool extends Tool {
  constructor(layer, options) {
    super(layer);
    this.options = options;
  }
  activate(activation) {
    const options = this.options;
    const layer = this.layer;
    const isValid = options.isValid;
    if (isValid !== void 0 && !isValid(layer).value) return;
    var _makeToolActivationSt = makeToolActivationStatusMessageWithHeader(activation);
    const header = _makeToolActivationSt.header, body = _makeToolActivationSt.body;
    var _makeControl = makeControl(activation, layer, options, new WatchableVisibilityPriority(WatchableVisibilityPriority.VISIBLE));
    const controlContainer = _makeControl.controlContainer, control = _makeControl.control, labelContainer = _makeControl.labelContainer;
    header.appendChild(labelContainer);
    body.appendChild(controlContainer);
    options.activateTool(activation, control);
  }
  get description() {
    var _a;
    const options = this.options;
    return (_a = options.toolDescription) !== null && _a !== void 0 ? _a : options.label;
  }
  toJSON() {
    return this.options.toolJson;
  }
}
function makeLayerControlToOptionsTab(context, layer, options, visibility) {
  var _makeControl2 = makeControl(context, layer, options, visibility);
  const controlContainer = _makeControl2.controlContainer, label = _makeControl2.label;
  controlContainer.classList.add("neuroglancer-layer-options-control-container");
  label.prepend(context.registerDisposer(new ToolBindingWidget(layer, options.toolJson)).element);
  return controlContainer;
}
function addLayerControlToOptionsTab(context, layer, visibility, options) {
  const isValid = options.isValid;
  if (isValid === void 0) {
    return makeLayerControlToOptionsTab(context, layer, options, visibility);
  }
  return context.registerDisposer(new DependentViewWidget(isValid(layer), (valid, parent, context2) => {
    if (!valid) return;
    parent.appendChild(makeLayerControlToOptionsTab(context2, layer, options, visibility));
  }, visibility)).element;
}
function registerLayerControl(layerType, options) {
  const toolJson = options.toolJson;
  const toolId = typeof toolJson === "string" ? toolJson : toolJson.type;
  registerLayerTool(layerType, toolId, (layer) => new LayerControlTool(layer, options));
}
class LinkedLayerGroupWidget extends RefCounted {
  constructor(group) {
    super();
    this.group = group;
    this.element = document.createElement("div");
    this.topRow = document.createElement("div");
    this.label = document.createElement("label");
    this.selectElement = document.createElement("select");
    this.linkedLayers = document.createElement("div");
    this.unlinkButton = document.createElement("button");
    const element = this.element, label = this.label, topRow = this.topRow, selectElement = this.selectElement, linkedLayers = this.linkedLayers, unlinkButton = this.unlinkButton;
    topRow.appendChild(label);
    topRow.appendChild(selectElement);
    topRow.appendChild(unlinkButton);
    unlinkButton.textContent = "Unlink";
    unlinkButton.addEventListener("click", () => {
      this.group.isolate();
    });
    element.appendChild(topRow);
    element.appendChild(linkedLayers);
    this.updateView();
    const debouncedUpdateView = debounce(() => this.updateView(), 0);
    this.registerEventListener(selectElement, "change", () => {
      this.updateModel();
      debouncedUpdateView();
    });
    this.registerDisposer(this.group.changed.add(debouncedUpdateView));
    this.registerDisposer(this.group.linkedLayersChanged.add(debouncedUpdateView));
    this.registerDisposer(this.group.layerManager.layersChanged.add(debouncedUpdateView));
  }
  updateModel() {
    const name2 = this.selectElement.value;
    if (name2 === "" && this.group.root.value !== this.group.layer) {
      this.group.isolate();
    } else {
      this.group.linkByName(name2);
    }
  }
  updateView() {
    var _a;
    const selectElement = this.selectElement, group = this.group;
    const predicate = group.predicate;
    removeChildren(selectElement);
    const inGroup = this.group.rootGroup.linkedLayers.size !== 0;
    this.unlinkButton.style.display = inGroup ? "" : "none";
    const linkedLayers = this.linkedLayers;
    const isNonEmptyRoot = group.linkedLayers.size !== 0;
    linkedLayers.style.display = isNonEmptyRoot ? "" : "none";
    this.unlinkButton.textContent = isNonEmptyRoot ? "Unlink all" : "Unlink";
    if (isNonEmptyRoot) {
      this.element.style.display = "";
      selectElement.style.display = "none";
      removeChildren(linkedLayers);
      for (const layer of group.linkedLayers) {
        const element = document.createElement("div");
        element.classList.add("neuroglancer-linked-layer-widget-layer");
        const unlinkIcon = makeCloseButton({
          title: "Unlink layer",
          onClick: () => {
            this.group.getGroup(layer).isolate();
          }
        });
        element.appendChild(unlinkIcon);
        element.appendChild(document.createTextNode(layer.managedLayer.name));
        linkedLayers.appendChild(element);
      }
    } else {
      selectElement.style.display = "";
      const emptyOption = document.createElement("option");
      selectElement.appendChild(emptyOption);
      let numOptions = 0;
      for (const layer of this.group.layerManager.managedLayers) {
        const userLayer = layer.layer;
        if (userLayer === null) continue;
        if (userLayer === group.layer) continue;
        if (predicate(userLayer)) {
          ++numOptions;
          const option = document.createElement("option");
          const name2 = layer.name;
          option.textContent = name2;
          option.value = name2;
          selectElement.appendChild(option);
        }
      }
      selectElement.value = (_a = group.toJSON()) !== null && _a !== void 0 ? _a : "";
      this.element.style.display = numOptions === 0 ? "none" : "";
    }
  }
}
const svg_maximize = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="maximiseIconTitle"><title id="maximiseIconTitle">Maximise View</title><polyline points="21 16 21 21 16 21"></polyline><polyline points="8 21 3 21 3 16"></polyline><polyline points="16 3 21 3 21 8"></polyline><polyline points="3 8 3 3 8 3"></polyline></svg>';
function makeMaximizeButton(options = {}) {
  return makeIcon(_Object$assign({ svg: svg_maximize }, options));
}
var lint = { exports: {} };
var hasRequiredLint;
function requireLint() {
  if (hasRequiredLint) return lint.exports;
  hasRequiredLint = 1;
  (function(module, exports) {
    (function(mod) {
      mod(requireCodemirror());
    })(function(CodeMirror2) {
      var GUTTER_ID = "CodeMirror-lint-markers";
      var LINT_LINE_ID = "CodeMirror-lint-line-";
      function showTooltip(cm, e, content) {
        var tt = document.createElement("div");
        tt.className = "CodeMirror-lint-tooltip cm-s-" + cm.options.theme;
        tt.appendChild(content.cloneNode(true));
        if (cm.state.lint.options.selfContain)
          cm.getWrapperElement().appendChild(tt);
        else
          document.body.appendChild(tt);
        function position(e2) {
          if (!tt.parentNode) return CodeMirror2.off(document, "mousemove", position);
          var top = Math.max(0, e2.clientY - tt.offsetHeight - 5);
          var left = Math.max(0, Math.min(e2.clientX + 5, tt.ownerDocument.defaultView.innerWidth - tt.offsetWidth));
          tt.style.top = top + "px";
          tt.style.left = left + "px";
        }
        CodeMirror2.on(document, "mousemove", position);
        position(e);
        if (tt.style.opacity != null) tt.style.opacity = 1;
        return tt;
      }
      function rm(elt) {
        if (elt.parentNode) elt.parentNode.removeChild(elt);
      }
      function hideTooltip(tt) {
        if (!tt.parentNode) return;
        if (tt.style.opacity == null) rm(tt);
        tt.style.opacity = 0;
        setTimeout(function() {
          rm(tt);
        }, 600);
      }
      function showTooltipFor(cm, e, content, node) {
        var tooltip = showTooltip(cm, e, content);
        function hide() {
          CodeMirror2.off(node, "mouseout", hide);
          if (tooltip) {
            hideTooltip(tooltip);
            tooltip = null;
          }
        }
        var poll = setInterval(function() {
          if (tooltip) for (var n = node; ; n = n.parentNode) {
            if (n && n.nodeType == 11) n = n.host;
            if (n == document.body) return;
            if (!n) {
              hide();
              break;
            }
          }
          if (!tooltip) return clearInterval(poll);
        }, 400);
        CodeMirror2.on(node, "mouseout", hide);
      }
      function LintState(cm, conf, hasGutter) {
        this.marked = [];
        if (conf instanceof Function) conf = { getAnnotations: conf };
        if (!conf || conf === true) conf = {};
        this.options = {};
        this.linterOptions = conf.options || {};
        for (var prop in defaults) this.options[prop] = defaults[prop];
        for (var prop in conf) {
          if (defaults.hasOwnProperty(prop)) {
            if (conf[prop] != null) this.options[prop] = conf[prop];
          } else if (!conf.options) {
            this.linterOptions[prop] = conf[prop];
          }
        }
        this.timeout = null;
        this.hasGutter = hasGutter;
        this.onMouseOver = function(e) {
          onMouseOver(cm, e);
        };
        this.waitingFor = 0;
      }
      var defaults = {
        highlightLines: false,
        tooltips: true,
        delay: 500,
        lintOnChange: true,
        getAnnotations: null,
        async: false,
        selfContain: null,
        formatAnnotation: null,
        onUpdateLinting: null
      };
      function clearMarks(cm) {
        var state = cm.state.lint;
        if (state.hasGutter) cm.clearGutter(GUTTER_ID);
        if (state.options.highlightLines) clearErrorLines(cm);
        for (var i = 0; i < state.marked.length; ++i)
          state.marked[i].clear();
        state.marked.length = 0;
      }
      function clearErrorLines(cm) {
        cm.eachLine(function(line) {
          var has = line.wrapClass && /\bCodeMirror-lint-line-\w+\b/.exec(line.wrapClass);
          if (has) cm.removeLineClass(line, "wrap", has[0]);
        });
      }
      function makeMarker(cm, labels, severity, multiple, tooltips) {
        var marker = document.createElement("div"), inner = marker;
        marker.className = "CodeMirror-lint-marker CodeMirror-lint-marker-" + severity;
        if (multiple) {
          inner = marker.appendChild(document.createElement("div"));
          inner.className = "CodeMirror-lint-marker CodeMirror-lint-marker-multiple";
        }
        if (tooltips != false) CodeMirror2.on(inner, "mouseover", function(e) {
          showTooltipFor(cm, e, labels, inner);
        });
        return marker;
      }
      function getMaxSeverity(a, b) {
        if (a == "error") return a;
        else return b;
      }
      function groupByLine(annotations) {
        var lines = [];
        for (var i = 0; i < annotations.length; ++i) {
          var ann = annotations[i], line = ann.from.line;
          (lines[line] || (lines[line] = [])).push(ann);
        }
        return lines;
      }
      function annotationTooltip(ann) {
        var severity = ann.severity;
        if (!severity) severity = "error";
        var tip = document.createElement("div");
        tip.className = "CodeMirror-lint-message CodeMirror-lint-message-" + severity;
        if (typeof ann.messageHTML != "undefined") {
          tip.innerHTML = ann.messageHTML;
        } else {
          tip.appendChild(document.createTextNode(ann.message));
        }
        return tip;
      }
      function lintAsync(cm, getAnnotations) {
        var state = cm.state.lint;
        var id = ++state.waitingFor;
        function abort() {
          id = -1;
          cm.off("change", abort);
        }
        cm.on("change", abort);
        getAnnotations(cm.getValue(), function(annotations, arg2) {
          cm.off("change", abort);
          if (state.waitingFor != id) return;
          if (arg2 && annotations instanceof CodeMirror2) annotations = arg2;
          cm.operation(function() {
            updateLinting(cm, annotations);
          });
        }, state.linterOptions, cm);
      }
      function startLinting(cm) {
        var state = cm.state.lint;
        if (!state) return;
        var options = state.options;
        var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror2.Pos(0, 0), "lint");
        if (!getAnnotations) return;
        if (options.async || getAnnotations.async) {
          lintAsync(cm, getAnnotations);
        } else {
          var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);
          if (!annotations) return;
          if (annotations.then) annotations.then(function(issues) {
            cm.operation(function() {
              updateLinting(cm, issues);
            });
          });
          else cm.operation(function() {
            updateLinting(cm, annotations);
          });
        }
      }
      function updateLinting(cm, annotationsNotSorted) {
        var state = cm.state.lint;
        if (!state) return;
        var options = state.options;
        clearMarks(cm);
        var annotations = groupByLine(annotationsNotSorted);
        for (var line = 0; line < annotations.length; ++line) {
          var anns = annotations[line];
          if (!anns) continue;
          var maxSeverity = null;
          var tipLabel = state.hasGutter && document.createDocumentFragment();
          for (var i = 0; i < anns.length; ++i) {
            var ann = anns[i];
            var severity = ann.severity;
            if (!severity) severity = "error";
            maxSeverity = getMaxSeverity(maxSeverity, severity);
            if (options.formatAnnotation) ann = options.formatAnnotation(ann);
            if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));
            if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
              className: "CodeMirror-lint-mark CodeMirror-lint-mark-" + severity,
              __annotation: ann
            }));
          }
          if (state.hasGutter)
            cm.setGutterMarker(line, GUTTER_ID, makeMarker(
              cm,
              tipLabel,
              maxSeverity,
              anns.length > 1,
              options.tooltips
            ));
          if (options.highlightLines)
            cm.addLineClass(line, "wrap", LINT_LINE_ID + maxSeverity);
        }
        if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
      }
      function onChange(cm) {
        var state = cm.state.lint;
        if (!state) return;
        clearTimeout(state.timeout);
        state.timeout = setTimeout(function() {
          startLinting(cm);
        }, state.options.delay);
      }
      function popupTooltips(cm, annotations, e) {
        var target = e.target || e.srcElement;
        var tooltip = document.createDocumentFragment();
        for (var i = 0; i < annotations.length; i++) {
          var ann = annotations[i];
          tooltip.appendChild(annotationTooltip(ann));
        }
        showTooltipFor(cm, e, tooltip, target);
      }
      function onMouseOver(cm, e) {
        var target = e.target || e.srcElement;
        if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
        var box2 = target.getBoundingClientRect(), x = (box2.left + box2.right) / 2, y = (box2.top + box2.bottom) / 2;
        var spans = cm.findMarksAt(cm.coordsChar({ left: x, top: y }, "client"));
        var annotations = [];
        for (var i = 0; i < spans.length; ++i) {
          var ann = spans[i].__annotation;
          if (ann) annotations.push(ann);
        }
        if (annotations.length) popupTooltips(cm, annotations, e);
      }
      CodeMirror2.defineOption("lint", false, function(cm, val, old) {
        if (old && old != CodeMirror2.Init) {
          clearMarks(cm);
          if (cm.state.lint.options.lintOnChange !== false)
            cm.off("change", onChange);
          CodeMirror2.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
          clearTimeout(cm.state.lint.timeout);
          delete cm.state.lint;
        }
        if (val) {
          var gutters = cm.getOption("gutters"), hasLintGutter = false;
          for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
          var state = cm.state.lint = new LintState(cm, val, hasLintGutter);
          if (state.options.lintOnChange)
            cm.on("change", onChange);
          if (state.options.tooltips != false && state.options.tooltips != "gutter")
            CodeMirror2.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);
          startLinting(cm);
        }
      });
      CodeMirror2.defineExtension("performLint", function() {
        startLinting(this);
      });
    });
  })();
  return lint.exports;
}
requireLint();
var glsl;
var hasRequiredGlsl;
function requireGlsl() {
  if (hasRequiredGlsl) return glsl;
  hasRequiredGlsl = 1;
  glsl = function(CodeMirror2) {
    CodeMirror2.defineMode("glsl", function(config, parserConfig) {
      var indentUnit = config.indentUnit, keywords = parserConfig.keywords || words(glslKeywords), builtins = parserConfig.builtins || words(glslBuiltins), blockKeywords = parserConfig.blockKeywords || words("case do else for if switch while struct"), atoms = parserConfig.atoms || words("null"), hooks = parserConfig.hooks || {}, multiLineStrings = parserConfig.multiLineStrings;
      var isOperatorChar = /[+\-*&%=<>!?|\/]/;
      var curPunc;
      function tokenBase(stream, state) {
        var ch = stream.next();
        if (hooks[ch]) {
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          curPunc = ch;
          return "bracket";
        }
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (ch == "#") {
          stream.eatWhile(/[\S]+/);
          stream.eatWhile(/[\s]+/);
          stream.eatWhile(/[\S]+/);
          stream.eatWhile(/[\s]+/);
          return "comment";
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        var cur = stream.current();
        if (keywords.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "keyword";
        }
        if (builtins.propertyIsEnumerable(cur)) {
          return "builtin";
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "word";
      }
      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {
              end = true;
              break;
            }
            escaped = !escaped && next == "\\";
          }
          if (end || !(escaped || multiLineStrings))
            state.tokenize = tokenBase;
          return "string";
        };
      }
      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = ch == "*";
        }
        return "comment";
      }
      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }
      function popContext(state) {
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }
      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },
        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta") return style;
          if (ctx.align == null) ctx.align = true;
          if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
          else if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "}") {
            while (ctx.type == "statement") ctx = popContext(state);
            if (ctx.type == "}") ctx = popContext(state);
            while (ctx.type == "statement") ctx = popContext(state);
          } else if (curPunc == ctx.type) popContext(state);
          else if (ctx.type == "}" || ctx.type == "top" || ctx.type == "statement" && curPunc == "newstatement")
            pushContext(state, stream.column(), "statement");
          state.startOfLine = false;
          return style;
        },
        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return 0;
          var firstChar = textAfter && textAfter.charAt(0), ctx = state.context, closing = firstChar == ctx.type;
          if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
          else if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : indentUnit);
        },
        electricChars: "{}"
      };
    });
    function words(str) {
      var obj = {}, words2 = str.split(" ");
      for (var i = 0; i < words2.length; ++i) obj[words2[i]] = true;
      return obj;
    }
    var glslKeywords = "attribute const uniform varying break continue do for while if else in out inout float int void bool true false lowp mediump highp precision invariant discard return mat2 mat3 mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 sampler2D samplerCube struct gl_FragCoord gl_FragColor";
    var glslBuiltins = "radians degrees sin cos tan asin acos atan pow exp log exp2 log2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not dFdx dFdy fwidth texture2D texture2DProj texture2DLod texture2DProjLod textureCube textureCubeLod require export";
    function cppHook(stream, state) {
      if (!state.startOfLine) return false;
      stream.skipToEnd();
      return "meta";
    }
    (function() {
      CodeMirror2.defineMIME("text/x-glsl", {
        name: "glsl",
        keywords: words(glslKeywords),
        builtins: words(glslBuiltins),
        blockKeywords: words("case do else for if switch while struct"),
        atoms: words("null"),
        hooks: { "#": cppHook }
      });
    })();
  };
  return glsl;
}
var glslExports = requireGlsl();
const glslCodeMirror = /* @__PURE__ */ getDefaultExportFromCjs(glslExports);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
glslCodeMirror(CodeMirror);
const SHADER_UPDATE_DELAY = 500;
class ShaderCodeWidget extends RefCounted {
  constructor(state) {
    super();
    this.state = state;
    this.changingValue = false;
    this.debouncedValueUpdater = debounce(() => {
      this.changingValue = true;
      try {
        this.state.fragmentMain.value = this.textEditor.getValue();
      } finally {
        this.changingValue = false;
      }
    }, SHADER_UPDATE_DELAY);
    this.textEditor = CodeMirror((_element) => {
    }, {
      value: this.state.fragmentMain.value,
      mode: "glsl",
      gutters: ["CodeMirror-lint-markers"]
    });
    this.textEditor.on("change", () => {
      this.setValidState(void 0);
      this.debouncedValueUpdater();
    });
    this.registerDisposer(this.state.fragmentMain.changed.add(() => {
      if (!this.changingValue) {
        this.textEditor.setValue(this.state.fragmentMain.value);
      }
    }));
    this.element.classList.add("neuroglancer-shader-code-widget");
    this.registerDisposer(this.state.shaderError.changed.add(() => {
      this.updateErrorState();
    }));
    const shaderControlState = this.state.shaderControlState;
    if (shaderControlState !== void 0) {
      this.registerDisposer(shaderControlState.parseErrors.changed.add(() => {
        this.updateErrorState();
      }));
    }
    this.updateErrorState();
    const intersectionObserver = new IntersectionObserver((entries2) => {
      if (entries2.some((x) => x.isIntersecting)) {
        this.textEditor.refresh();
      }
    }, {
      root: document.body
    });
    intersectionObserver.observe(this.element);
    this.registerDisposer(() => intersectionObserver.disconnect());
  }
  get element() {
    return this.textEditor.getWrapperElement();
  }
  updateErrorState() {
    var _state$sourceStringNu = this.state.sourceStringNumber;
    const sourceStringNumber = _state$sourceStringNu === void 0 ? 1 : _state$sourceStringNu;
    const error = this.state.shaderError.value;
    let controlParseErrors;
    const shaderControlState = this.state.shaderControlState;
    if (shaderControlState !== void 0) {
      controlParseErrors = shaderControlState.parseErrors.value;
    } else {
      controlParseErrors = [];
    }
    if (error === void 0 && controlParseErrors.length === 0) {
      this.setValidState(void 0);
    } else if (error != null || controlParseErrors.length !== 0) {
      this.textEditor.setOption("lint", {
        getAnnotations: () => {
          const annotations = [];
          for (const e of controlParseErrors) {
            annotations.push({
              message: e.message,
              severity: "error",
              from: CodeMirror.Pos(e.line)
            });
          }
          if (error != null) {
            if (error.name === "ShaderCompilationError") {
              for (const e of error.errorMessages) {
                annotations.push({
                  message: e.message,
                  severity: "error",
                  from: CodeMirror.Pos(e.file === sourceStringNumber ? e.line || 0 : 0)
                });
              }
            } else if (error.name === "ShaderLinkError") {
              annotations.push({
                message: error.log,
                severity: "error",
                from: CodeMirror.Pos(0)
              });
            } else {
              annotations.push({
                message: error.message,
                severity: "error",
                from: CodeMirror.Pos(0)
              });
            }
          }
          return annotations;
        }
      });
      this.setValidState(false);
    } else {
      this.textEditor.setOption("lint", void 0);
      this.setValidState(true);
    }
  }
  setValidState(valid) {
    let element = this.element;
    element.classList.remove("invalid-input");
    element.classList.remove("valid-input");
    if (valid === true) {
      element.classList.add("valid-input");
    } else if (valid === false) {
      element.classList.add("invalid-input");
    }
  }
  disposed() {
    this.debouncedValueUpdater.flush();
    this.debouncedValueUpdater = void 0;
    removeFromParent(this.element);
    this.textEditor = void 0;
    super.disposed();
  }
}
const TOOL_INPUT_EVENT_MAP$4 = EventActionMap.fromObject({
  "at:shift+wheel": { action: "adjust-contrast-via-wheel" },
  "at:shift+mousedown0": { action: "adjust-via-drag" },
  "at:shift+mousedown2": { action: "invert-range" }
});
function channelInvlerpLayerControl(getter) {
  return {
    makeControl: (layer, context, options) => {
      var _getter = getter(layer);
      const watchableValue = _getter.watchableValue, channelCoordinateSpaceCombiner = _getter.channelCoordinateSpaceCombiner, dataType = _getter.dataType, defaultChannel = _getter.defaultChannel, histogramSpecifications = _getter.histogramSpecifications, legendShaderOptions = _getter.legendShaderOptions, histogramIndex = _getter.histogramIndex;
      if (channelCoordinateSpaceCombiner !== void 0 && defaultChannel.length !== 0) {
        const position = context.registerDisposer(new Position(channelCoordinateSpaceCombiner.combined));
        const positionWidget = context.registerDisposer(new PositionWidget(position, channelCoordinateSpaceCombiner, { copyButton: false }));
        context.registerDisposer(position.changed.add(() => {
          const value = position.value;
          const newChannel = _Array$from(value, (x) => Math.floor(x));
          const oldParams = watchableValue.value;
          if (!arraysEqual(oldParams.channel, newChannel)) {
            watchableValue.value = _Object$assign(_Object$assign({}, watchableValue.value), { channel: newChannel });
          }
        }));
        const updatePosition = () => {
          const value = position.value;
          const params = watchableValue.value;
          if (!arraysEqual(value, params.channel)) {
            value.set(params.channel);
            position.changed.dispatch();
          }
        };
        updatePosition();
        context.registerDisposer(watchableValue.changed.add(updatePosition));
        options.labelContainer.appendChild(positionWidget.element);
      }
      const control = context.registerDisposer(new InvlerpWidget(options.visibility, options.display, dataType, watchableValue, histogramSpecifications, histogramIndex, defaultChannel.length === 0 ? legendShaderOptions : void 0));
      return { control, controlElement: control.element };
    },
    activateTool: (activation, control) => {
      activation.bindInputEventMap(TOOL_INPUT_EVENT_MAP$4);
      activation.bindAction("adjust-contrast-via-wheel", (event) => {
        event.stopPropagation();
        const zoomAmount = getWheelZoomAmount(event.detail);
        adjustInvlerpContrast(control.dataType, control.trackable, zoomAmount);
      });
      activation.bindAction("adjust-via-drag", (event) => {
        event.stopPropagation();
        let baseScreenX = event.detail.screenX, baseScreenY = event.detail.screenY;
        let baseRange = control.trackable.value.range;
        let prevRange = baseRange;
        let prevScreenX = baseScreenX, prevScreenY = baseScreenY;
        startRelativeMouseDrag(event.detail, (newEvent) => {
          const curRange = control.trackable.value.range;
          const curScreenX = newEvent.screenX, curScreenY = newEvent.screenY;
          if (!dataTypeIntervalEqual(control.dataType, curRange, prevRange)) {
            baseRange = curRange;
            baseScreenX = prevScreenX;
            baseScreenY = prevScreenY;
          }
          adjustInvlerpBrightnessContrast(control.dataType, control.trackable, baseRange, (curScreenY - baseScreenY) * 2 / screen.height, (curScreenX - baseScreenX) * 4 / screen.width);
          prevRange = control.trackable.value.range;
          prevScreenX = curScreenX;
          prevScreenY = curScreenY;
        });
      });
      activation.bindAction("invert-range", (event) => {
        event.stopPropagation();
        invertInvlerpRange(control.trackable);
      });
    }
  };
}
/**
 * @license
 * Copyright 2021 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function checkboxLayerControl(getter) {
  return {
    makeControl: (layer, context) => {
      const value = getter(layer);
      const control = context.registerDisposer(new TrackableBooleanCheckbox(value));
      return { control, controlElement: control.element };
    },
    activateTool: (_activation, control) => {
      control.model.value = !control.model.value;
    }
  };
}
/**
 * @license
 * Copyright 2021 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const TOOL_INPUT_EVENT_MAP$3 = EventActionMap.fromObject({
  "at:shift+wheel": { action: "adjust-hue-via-wheel" }
});
function colorLayerControl(getter) {
  return {
    makeControl: (layer, context) => {
      const value = getter(layer);
      const control = context.registerDisposer(new ColorWidget(value));
      return { control, controlElement: control.element };
    },
    activateTool: (activation, control) => {
      activation.bindInputEventMap(TOOL_INPUT_EVENT_MAP$3);
      activation.bindAction("adjust-via-wheel", (event) => {
        event.stopPropagation();
        event.preventDefault();
        control.adjustHueViaWheel(event.detail);
      });
    }
  };
}
class RangeWidget extends RefCounted {
  constructor(value, { min: min2 = 0, max = 1, step = 0.01 } = {}) {
    super();
    this.value = value;
    this.element = document.createElement("label");
    this.inputElement = document.createElement("input");
    this.numericInputElement = document.createElement("input");
    let element = this.element, inputElement = this.inputElement, numericInputElement = this.numericInputElement;
    element.className = "range-slider";
    const initInputElement = (el) => {
      el.min = "" + min2;
      el.max = "" + max;
      el.step = "" + step;
      el.valueAsNumber = this.value.value;
      this.registerEventListener(el, "change", () => this.inputValueChanged(el));
      this.registerEventListener(el, "input", () => this.inputValueChanged(el));
      this.registerEventListener(el, "wheel", (event) => {
        this.adjustViaWheel(el, event);
      });
    };
    inputElement.type = "range";
    initInputElement(inputElement);
    numericInputElement.type = "number";
    const maxNumberWidth = Math.max(min2.toString().length, max.toString().length, Math.min(max, min2 + step).toString().length, Math.max(min2, max - step).toString().length);
    numericInputElement.style.width = maxNumberWidth + 2 + "ch";
    initInputElement(numericInputElement);
    element.appendChild(inputElement);
    element.appendChild(numericInputElement);
    value.changed.add(() => {
      this.inputElement.valueAsNumber = this.value.value;
      this.numericInputElement.valueAsNumber = this.value.value;
    });
  }
  inputValueChanged(element) {
    this.value.value = element.valueAsNumber;
  }
  adjustViaWheel(element, event) {
    const el = this.inputElement;
    let deltaY = event.deltaY;
    if (deltaY > 0) {
      el.stepUp();
      this.inputValueChanged(element);
    } else if (deltaY < 0) {
      el.stepDown();
      this.inputValueChanged(element);
    }
  }
  disposed() {
    removeFromParent(this.element);
    super.disposed();
  }
}
/**
 * @license
 * Copyright 2021 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const TOOL_INPUT_EVENT_MAP$2 = EventActionMap.fromObject({
  "at:shift+wheel": { action: "adjust-via-wheel" }
});
function rangeLayerControl(getter) {
  return {
    makeControl: (layer, context) => {
      var _getter = getter(layer);
      const value = _getter.value, options = _getter.options;
      const control = context.registerDisposer(new RangeWidget(value, options));
      return { control, controlElement: control.element };
    },
    activateTool: (activation, control) => {
      activation.bindInputEventMap(TOOL_INPUT_EVENT_MAP$2);
      activation.bindAction("adjust-via-wheel", (event) => {
        event.stopPropagation();
        event.preventDefault();
        control.adjustViaWheel(control.inputElement, event.detail);
      });
    }
  };
}
function getShaderLayerControlFactory(layerShaderControls, controlId) {
  const shaderControlState = layerShaderControls.shaderControlState;
  const controlState = shaderControlState.state.get(controlId);
  if (controlState === void 0) return void 0;
  const control = controlState.control;
  switch (control.type) {
    case "slider":
      return rangeLayerControl(() => ({
        value: controlState.trackable,
        options: { min: control.min, max: control.max, step: control.step }
      }));
    case "color":
      return colorLayerControl(() => controlState.trackable);
    case "checkbox":
      return checkboxLayerControl(() => controlState.trackable);
    case "invlerp": {
      let histogramIndex = 0;
      for (const _ref of shaderControlState.state) {
        var _ref2 = _slicedToArray(_ref, 2);
        const otherName = _ref2[0];
        const otherType = _ref2[1].control.type;
        if (otherName === controlId) break;
        if (otherType === "invlerp") ++histogramIndex;
      }
      return channelInvlerpLayerControl(() => ({
        dataType: control.dataType,
        defaultChannel: control.default.channel,
        watchableValue: controlState.trackable,
        channelCoordinateSpaceCombiner: shaderControlState.channelCoordinateSpaceCombiner,
        histogramSpecifications: shaderControlState.histogramSpecifications,
        histogramIndex,
        legendShaderOptions: layerShaderControls.legendShaderOptions
      }));
    }
  }
}
function getShaderLayerControlDefinition(getter, toolId, controlId) {
  return {
    label: controlId,
    toolJson: shaderControlToolJson(controlId, toolId),
    makeControl: (layer, context, options) => {
      const layerShaderControls = getter(layer);
      return getShaderLayerControlFactory(layerShaderControls, controlId).makeControl(layer, context, options);
    },
    activateTool: (activation, control) => {
      const layerShaderControls = getter(activation.tool.layer);
      return getShaderLayerControlFactory(layerShaderControls, controlId).activateTool(activation, control);
    }
  };
}
class ShaderControls extends Tab {
  constructor(state, display, layer, options = {}) {
    super(options.visibility);
    this.state = state;
    this.display = display;
    this.layer = layer;
    this.options = options;
    this.controlDisposer = void 0;
    var _options$toolId = options.toolId;
    const toolId = _options$toolId === void 0 ? SHADER_CONTROL_TOOL_ID : _options$toolId;
    this.toolId = toolId;
    const element = this.element;
    element.style.display = "contents";
    const controls = state.controls;
    this.registerDisposer(controls.changed.add(this.registerCancellable(debounce(() => this.updateControls(), 0))));
    this.updateControls();
  }
  updateControls() {
    const element = this.element;
    if (this.controlDisposer !== void 0) {
      this.controlDisposer.dispose();
      removeChildren(element);
    }
    const controlDisposer = this.controlDisposer = new RefCounted();
    const layerShaderControlsGetter = () => ({
      shaderControlState: this.state,
      legendShaderOptions: this.options.legendShaderOptions
    });
    for (const name2 of this.state.state.keys()) {
      element.appendChild(addLayerControlToOptionsTab(controlDisposer, this.layer, this.visibility, getShaderLayerControlDefinition(layerShaderControlsGetter, this.toolId, name2)));
    }
  }
  disposed() {
    var _a;
    (_a = this.controlDisposer) === null || _a === void 0 ? void 0 : _a.dispose();
    super.disposed();
  }
}
const SHADER_CONTROL_TOOL_ID = "shaderControl";
const CONTROL_JSON_KEY = "control";
function shaderControlToolJson(control, toolId) {
  return { type: toolId, [CONTROL_JSON_KEY]: control };
}
class ShaderControlTool extends LayerControlTool {
  constructor(layer, layerShaderControls, toolId, control) {
    super(layer, getShaderLayerControlDefinition(() => layerShaderControls, toolId, control));
    this.layerShaderControls = layerShaderControls;
    this.control = control;
    this.registerDisposer(layerShaderControls.shaderControlState.controls.changed.add(this.registerCancellable(debounce(() => {
      if (layerShaderControls.shaderControlState.state.get(control) === void 0) {
        this.unbind();
      }
    }))));
  }
  activate(activation) {
    const shaderControlState = this.layerShaderControls.shaderControlState;
    const controlState = shaderControlState.state.get(this.control);
    if (controlState === void 0) return;
    super.activate(activation);
  }
}
function registerLayerShaderControlsTool(layerType, getter, toolId = SHADER_CONTROL_TOOL_ID) {
  registerLayerTool(layerType, toolId, (layer, options) => {
    const control = verifyObjectProperty(options, CONTROL_JSON_KEY, verifyString);
    return new ShaderControlTool(layer, getter(layer), toolId, control);
  });
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function makeSkeletonShaderCodeWidget(layer) {
  return new ShaderCodeWidget({
    fragmentMain: layer.displayState.skeletonRenderingOptions.shader,
    shaderError: layer.displayState.shaderError,
    shaderControlState: layer.displayState.skeletonRenderingOptions.shaderControlState
  });
}
class DisplayOptionsTab extends Tab {
  constructor(layer) {
    super();
    this.layer = layer;
    const element = this.element;
    element.classList.add("neuroglancer-segmentation-rendering-tab");
    {
      const widget = this.registerDisposer(new LinkedLayerGroupWidget(layer.displayState.linkedSegmentationGroup));
      widget.label.textContent = "Linked to: ";
      element.appendChild(widget.element);
    }
    {
      const widget = this.registerDisposer(new LinkedLayerGroupWidget(layer.displayState.linkedSegmentationColorGroup));
      widget.label.textContent = "Colors linked to: ";
      element.appendChild(widget.element);
    }
    for (const control of LAYER_CONTROLS$1) {
      element.appendChild(addLayerControlToOptionsTab(this, layer, this.visibility, control));
    }
    const skeletonControls = this.registerDisposer(new DependentViewWidget(layer.hasSkeletonsLayer, (hasSkeletonsLayer, parent, refCounted) => {
      if (!hasSkeletonsLayer) return;
      let topRow = document.createElement("div");
      topRow.className = "neuroglancer-segmentation-dropdown-skeleton-shader-header";
      let label = document.createElement("div");
      label.style.flex = "1";
      label.textContent = "Skeleton shader:";
      topRow.appendChild(label);
      topRow.appendChild(makeMaximizeButton({
        title: "Show larger editor view",
        onClick: () => {
          new ShaderCodeOverlay$2(this.layer);
        }
      }));
      topRow.appendChild(makeHelpButton({
        title: "Documentation on skeleton rendering",
        href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md"
      }));
      parent.appendChild(topRow);
      const codeWidget = refCounted.registerDisposer(makeSkeletonShaderCodeWidget(this.layer));
      parent.appendChild(codeWidget.element);
      parent.appendChild(refCounted.registerDisposer(new ShaderControls(layer.displayState.skeletonRenderingOptions.shaderControlState, this.layer.manager.root.display, this.layer, {
        visibility: this.visibility,
        toolId: SKELETON_RENDERING_SHADER_CONTROL_TOOL_ID
      })).element);
      codeWidget.textEditor.refresh();
    }, this.visibility));
    element.appendChild(skeletonControls.element);
  }
}
let ShaderCodeOverlay$2 = class ShaderCodeOverlay extends Overlay {
  constructor(layer) {
    super();
    this.layer = layer;
    this.codeWidget = this.registerDisposer(makeSkeletonShaderCodeWidget(this.layer));
    this.content.classList.add("neuroglancer-segmentation-layer-skeleton-shader-overlay");
    this.content.appendChild(this.codeWidget.element);
    this.codeWidget.textEditor.refresh();
  }
};
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
var Uint64Map_1;
let Uint64Map = Uint64Map_1 = class Uint64Map2 extends SharedObjectCounterpart {
  constructor() {
    super(...arguments);
    this.hashTable = new HashMapUint64();
    this.changed = new Signal();
  }
  get value() {
    return this;
  }
  static makeWithCounterpart(rpc) {
    let obj = new Uint64Map_1();
    obj.initializeCounterpart(rpc);
    return obj;
  }
  set_(key, value) {
    return this.hashTable.set(key, value);
  }
  set(key, value) {
    if (this.set_(key, value)) {
      let rpc = this.rpc;
      if (rpc) {
        rpc.invoke("Uint64Map.set", { "id": this.rpcId, "key": key, "value": value });
      }
      this.changed.dispatch(key, true);
    }
  }
  has(key) {
    return this.hashTable.has(key);
  }
  get(key, value) {
    return this.hashTable.get(key, value);
  }
  [_Symbol$iterator]() {
    return this.hashTable.entries();
  }
  unsafeEntries() {
    return this.hashTable.unsafeEntries();
  }
  delete_(key) {
    return this.hashTable.delete(key);
  }
  delete(key) {
    if (this.delete_(key)) {
      let rpc = this.rpc;
      if (rpc) {
        rpc.invoke("Uint64Map.delete", { "id": this.rpcId, "key": key });
      }
      this.changed.dispatch(key, false);
    }
  }
  get size() {
    return this.hashTable.size;
  }
  assignFrom(other) {
    this.clear();
    for (const _ref of other.unsafeEntries()) {
      var _ref2 = _slicedToArray(_ref, 2);
      const key = _ref2[0];
      const value = _ref2[1];
      this.set(key, value);
    }
  }
  clear() {
    if (this.hashTable.clear()) {
      let rpc = this.rpc;
      if (rpc) {
        rpc.invoke("Uint64Map.clear", { "id": this.rpcId });
      }
      this.changed.dispatch(null, false);
    }
  }
  toJSON() {
    let result = {};
    for (let _ref3 of this.hashTable.unsafeEntries()) {
      var _ref4 = _slicedToArray(_ref3, 2);
      let key = _ref4[0];
      let value = _ref4[1];
      result[key.toString()] = value.toString();
    }
    return result;
  }
};
Uint64Map = Uint64Map_1 = __decorate$2([registerSharedObject("Uint64Map")], Uint64Map);
registerRPC("Uint64Map.set", function(x) {
  let obj = this.get(x["id"]);
  if (obj.set_(x["key"], x["value"])) {
    obj.changed.dispatch();
  }
});
registerRPC("Uint64Map.delete", function(x) {
  let obj = this.get(x["id"]);
  if (obj.delete_(x["key"])) {
    obj.changed.dispatch();
  }
});
registerRPC("Uint64Map.clear", function(x) {
  let obj = this.get(x["id"]);
  if (obj.hashTable.clear()) {
    obj.changed.dispatch();
  }
});
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$1 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
var Uint64Set_1;
let Uint64Set = Uint64Set_1 = class Uint64Set2 extends SharedObjectCounterpart {
  constructor() {
    super(...arguments);
    this.hashTable = new HashSetUint64();
    this.changed = new Signal();
  }
  get value() {
    return this;
  }
  static makeWithCounterpart(rpc) {
    let obj = new Uint64Set_1();
    obj.initializeCounterpart(rpc);
    return obj;
  }
  set(x, value) {
    if (!value) {
      this.delete(x);
    } else {
      this.add(x);
    }
  }
  reserve_(x) {
    return this.hashTable.reserve(x);
  }
  reserve(x) {
    if (this.reserve_(x)) {
      let rpc = this.rpc;
      if (rpc) {
        rpc.invoke("Uint64Set.reserve", { "id": this.rpcId, "value": x });
      }
    }
  }
  add_(x) {
    let changed = false;
    for (const v of x) {
      changed = this.hashTable.add(v) || changed;
    }
    return changed;
  }
  add(x) {
    const tmp = Array().concat(x);
    if (this.add_(tmp)) {
      let rpc = this.rpc;
      if (rpc) {
        rpc.invoke("Uint64Set.add", { "id": this.rpcId, "value": tmp });
      }
      this.changed.dispatch(x, true);
    }
  }
  has(x) {
    return this.hashTable.has(x);
  }
  [_Symbol$iterator]() {
    return this.hashTable.keys();
  }
  unsafeKeys() {
    return this.hashTable.unsafeKeys();
  }
  delete_(x) {
    let changed = false;
    for (const v of x) {
      changed = this.hashTable.delete(v) || changed;
    }
    return changed;
  }
  delete(x) {
    const tmp = Array().concat(x);
    if (this.delete_(Array().concat(x))) {
      let rpc = this.rpc;
      if (rpc) {
        rpc.invoke("Uint64Set.delete", { "id": this.rpcId, "value": tmp });
      }
      this.changed.dispatch(x, false);
    }
  }
  get size() {
    return this.hashTable.size;
  }
  clear() {
    if (this.hashTable.clear()) {
      let rpc = this.rpc;
      if (rpc) {
        rpc.invoke("Uint64Set.clear", { "id": this.rpcId });
      }
      this.changed.dispatch(null, false);
    }
  }
  toJSON() {
    let result = new Array();
    for (let id of this.unsafeKeys()) {
      result.push(id.toString());
    }
    result.sort();
    return result;
  }
  assignFrom(other) {
    this.clear();
    for (const key of other.unsafeKeys()) {
      this.add(key);
    }
  }
};
Uint64Set = Uint64Set_1 = __decorate$1([registerSharedObject("Uint64Set")], Uint64Set);
registerRPC("Uint64Set.reserve", function(x) {
  let obj = this.get(x["id"]);
  if (obj.reserve_(x["value"])) {
    obj.changed.dispatch();
  }
});
registerRPC("Uint64Set.add", function(x) {
  let obj = this.get(x["id"]);
  if (obj.add_(x["value"])) {
    obj.changed.dispatch();
  }
});
registerRPC("Uint64Set.delete", function(x) {
  let obj = this.get(x["id"]);
  if (obj.delete_(x["value"])) {
    obj.changed.dispatch();
  }
});
registerRPC("Uint64Set.clear", function(x) {
  let obj = this.get(x["id"]);
  if (obj.hashTable.clear()) {
    obj.changed.dispatch();
  }
});
/**
 * @license
 * Copyright 2021 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const TOOL_INPUT_EVENT_MAP$1 = EventActionMap.fromObject({
  "at:shift+wheel": { action: "adjust-via-wheel" }
});
function enumLayerControl(getter) {
  return {
    makeControl: (layer, context) => {
      const value = getter(layer);
      const control = context.registerDisposer(new EnumSelectWidget(value));
      return { control, controlElement: control.element };
    },
    activateTool: (activation, control) => {
      activation.bindInputEventMap(TOOL_INPUT_EVENT_MAP$1);
      activation.bindAction("adjust-via-wheel", (event) => {
        event.stopPropagation();
        event.preventDefault();
        control.adjustViaWheel(event.detail);
      });
    }
  };
}
const updateInterval = 200;
const inputEventMap$1 = EventActionMap.fromObject({
  "mousedown0": { action: "set" },
  "wheel": { action: "adjust-via-wheel" },
  "dblclick0": { action: "reset" }
});
function formatPixelNumber(x) {
  if (x < 1 || x > 1024) {
    const exponent = _Math$log$1(x) | 0;
    const coeff = x / 2 ** exponent;
    return `${numberToStringFixed(coeff, 1)}p${exponent}`;
  }
  return Math.round(x) + "";
}
class RenderScaleWidget extends RefCounted {
  constructor(histogram, target) {
    super();
    this.histogram = histogram;
    this.target = target;
    this.label = document.createElement("div");
    this.element = document.createElement("div");
    this.canvas = document.createElement("canvas");
    this.legend = document.createElement("div");
    this.legendRenderScale = document.createElement("div");
    this.legendSpatialScale = document.createElement("div");
    this.legendChunks = document.createElement("div");
    this.ctx = this.canvas.getContext("2d");
    this.hoverTarget = new WatchableValue(void 0);
    this.throttledUpdateView = this.registerCancellable(throttle(() => this.debouncedUpdateView(), updateInterval, { leading: true, trailing: true }));
    this.debouncedUpdateView = this.registerCancellable(debounce(() => this.updateView(), 0));
    const canvas = this.canvas, label = this.label, element = this.element, legend = this.legend, legendRenderScale = this.legendRenderScale, legendSpatialScale = this.legendSpatialScale, legendChunks = this.legendChunks;
    label.className = "neuroglancer-render-scale-widget-prompt";
    element.className = "neuroglancer-render-scale-widget";
    element.title = inputEventMap$1.describe();
    legend.className = "neuroglancer-render-scale-widget-legend";
    element.appendChild(label);
    element.appendChild(canvas);
    element.appendChild(legend);
    legendRenderScale.title = "Target resolution of data in screen pixels";
    legendChunks.title = "Number of chunks rendered";
    legend.appendChild(legendRenderScale);
    legend.appendChild(legendChunks);
    legend.appendChild(legendSpatialScale);
    this.registerDisposer(histogram.changed.add(this.throttledUpdateView));
    this.registerDisposer(histogram.visibility.changed.add(this.debouncedUpdateView));
    this.registerDisposer(target.changed.add(this.debouncedUpdateView));
    this.registerDisposer(new MouseEventBinder(canvas, inputEventMap$1));
    this.registerDisposer(target.changed.add(this.debouncedUpdateView));
    this.registerDisposer(this.hoverTarget.changed.add(this.debouncedUpdateView));
    const getTargetValue = (event) => {
      const position = event.offsetX / canvas.width * numRenderScaleHistogramBins;
      return getRenderScaleFromHistogramOffset(position);
    };
    this.registerEventListener(canvas, "pointermove", (event) => {
      this.hoverTarget.value = [getTargetValue(event), event.offsetY];
    });
    this.registerEventListener(canvas, "pointerleave", () => {
      this.hoverTarget.value = void 0;
    });
    this.registerDisposer(registerActionListener(canvas, "set", (actionEvent) => {
      this.target.value = getTargetValue(actionEvent.detail);
    }));
    this.registerDisposer(registerActionListener(canvas, "adjust-via-wheel", (actionEvent) => {
      this.adjustViaWheel(actionEvent.detail);
    }));
    this.registerDisposer(registerActionListener(canvas, "reset", (event) => {
      this.reset();
      event.preventDefault();
    }));
    const resizeObserver = new ResizeObserver(() => this.debouncedUpdateView());
    resizeObserver.observe(canvas);
    this.registerDisposer(() => resizeObserver.disconnect());
    this.updateView();
  }
  adjustViaWheel(event) {
    const deltaY = event.deltaY;
    if (deltaY === 0) {
      return;
    }
    this.hoverTarget.value = void 0;
    this.target.value *= 2 ** _Math$sign(deltaY);
    event.preventDefault();
  }
  reset() {
    this.hoverTarget.value = void 0;
    this.target.reset();
  }
  updateView() {
    const ctx = this.ctx;
    const canvas = this.canvas;
    const width = canvas.width = canvas.offsetWidth;
    const height = canvas.height = canvas.offsetHeight;
    const targetValue = this.target.value;
    const hoverValue = this.hoverTarget.value;
    {
      const legendRenderScale = this.legendRenderScale;
      const value = hoverValue === void 0 ? targetValue : hoverValue[0];
      const valueString = formatPixelNumber(value);
      legendRenderScale.textContent = valueString + " px";
    }
    function binToCanvasX(bin) {
      return bin * width / numRenderScaleHistogramBins;
    }
    ctx.clearRect(0, 0, width, height);
    const histogram = this.histogram;
    const histogramData = histogram.value, spatialScales = histogram.spatialScales;
    if (!histogram.visibility.visible) {
      histogramData.fill(0);
    }
    const sortedSpatialScales = _Array$from(spatialScales.keys());
    sortedSpatialScales.sort();
    const tempColor2 = create$3();
    let maxCount = 1;
    const numRows = spatialScales.size;
    let totalPresent = 0, totalNotPresent = 0;
    for (let bin = 0; bin < numRenderScaleHistogramBins; ++bin) {
      let count = 0;
      for (let row = 0; row < numRows; ++row) {
        const index2 = row * numRenderScaleHistogramBins * 2 + bin;
        const presentCount = histogramData[index2];
        const notPresentCount = histogramData[index2 + numRenderScaleHistogramBins];
        totalPresent += presentCount;
        totalNotPresent += notPresentCount;
        count += presentCount + notPresentCount;
      }
      maxCount = Math.max(count, maxCount);
    }
    const maxBarHeight = height;
    const yScale = maxBarHeight / Math.log(1 + maxCount);
    function countToCanvasY(count) {
      return height - Math.log(1 + count) * yScale;
    }
    let hoverSpatialScale = void 0;
    if (hoverValue !== void 0) {
      const i = Math.floor(getRenderScaleHistogramOffset(hoverValue[0]));
      if (i >= 0 && i < numRenderScaleHistogramBins) {
        let sum = 0;
        const hoverY = hoverValue[1];
        for (let spatialScaleIndex = numRows - 1; spatialScaleIndex >= 0; --spatialScaleIndex) {
          const spatialScale = sortedSpatialScales[spatialScaleIndex];
          const row = spatialScales.get(spatialScale);
          const index2 = 2 * row * numRenderScaleHistogramBins + i;
          const count = histogramData[index2] + histogramData[index2 + numRenderScaleHistogramBins];
          if (count === 0) continue;
          const yStart = Math.round(countToCanvasY(sum));
          sum += count;
          const yEnd = Math.round(countToCanvasY(sum));
          if (yEnd <= hoverY && hoverY <= yStart) {
            hoverSpatialScale = spatialScale;
            break;
          }
        }
      }
    }
    if (hoverSpatialScale !== void 0) {
      totalPresent = 0;
      totalNotPresent = 0;
      const row = spatialScales.get(hoverSpatialScale);
      const baseIndex = 2 * row * numRenderScaleHistogramBins;
      for (let bin = 0; bin < numRenderScaleHistogramBins; ++bin) {
        const index2 = baseIndex + bin;
        totalPresent += histogramData[index2];
        totalNotPresent += histogramData[index2 + numRenderScaleHistogramBins];
      }
      if (_Number$isFinite(hoverSpatialScale)) {
        this.legendSpatialScale.textContent = formatScaleWithUnitAsString(hoverSpatialScale, "m", { precision: 2, elide1: false });
      } else {
        this.legendSpatialScale.textContent = "unknown";
      }
    } else {
      this.legendSpatialScale.textContent = "";
    }
    this.legendChunks.textContent = `${totalPresent}/${totalPresent + totalNotPresent}`;
    const spatialScaleColors = sortedSpatialScales.map((spatialScale) => {
      const saturation = spatialScale === hoverSpatialScale ? 0.5 : 1;
      let hue;
      if (_Number$isFinite(spatialScale)) {
        hue = (_Math$log$1(spatialScale) * 0.1 % 1 + 1) % 1;
      } else {
        hue = 0;
      }
      hsvToRgb(tempColor2, hue, saturation, 1);
      const presentColor = serializeColor(tempColor2);
      hsvToRgb(tempColor2, hue, saturation, 0.5);
      const notPresentColor = serializeColor(tempColor2);
      return [presentColor, notPresentColor];
    });
    for (let i = 0; i < numRenderScaleHistogramBins; ++i) {
      let sum = 0;
      for (let spatialScaleIndex = numRows - 1; spatialScaleIndex >= 0; --spatialScaleIndex) {
        const spatialScale = sortedSpatialScales[spatialScaleIndex];
        const row = spatialScales.get(spatialScale);
        const index2 = row * numRenderScaleHistogramBins * 2 + i;
        const presentCount = histogramData[index2];
        const notPresentCount = histogramData[index2 + numRenderScaleHistogramBins];
        const count = presentCount + notPresentCount;
        if (count === 0) continue;
        const xStart = Math.round(binToCanvasX(i));
        const xEnd = Math.round(binToCanvasX(i + 1));
        const yStart = Math.round(countToCanvasY(sum));
        sum += count;
        const yEnd = Math.round(countToCanvasY(sum));
        const ySplit = (presentCount * yEnd + notPresentCount * yStart) / count;
        ctx.fillStyle = spatialScaleColors[spatialScaleIndex][1];
        ctx.fillRect(xStart, yEnd, xEnd - xStart, ySplit - yEnd);
        ctx.fillStyle = spatialScaleColors[spatialScaleIndex][0];
        ctx.fillRect(xStart, ySplit, xEnd - xStart, yStart - ySplit);
      }
    }
    {
      const value = targetValue;
      ctx.fillStyle = "#fff";
      const startOffset = binToCanvasX(getRenderScaleHistogramOffset(value));
      const lineWidth = 1;
      ctx.fillRect(Math.floor(startOffset), 0, lineWidth, height);
    }
    if (hoverValue !== void 0) {
      const value = hoverValue[0];
      ctx.fillStyle = "#888";
      const startOffset = binToCanvasX(getRenderScaleHistogramOffset(value));
      const lineWidth = 1;
      ctx.fillRect(Math.floor(startOffset), 0, lineWidth, height);
    }
  }
}
const TOOL_INPUT_EVENT_MAP = EventActionMap.fromObject({
  "at:shift+wheel": { action: "adjust-via-wheel" },
  "at:shift+dblclick0": { action: "reset" }
});
function renderScaleLayerControl(getter) {
  return {
    makeControl: (layer, context) => {
      var _getter = getter(layer);
      const histogram = _getter.histogram, target = _getter.target;
      const control = context.registerDisposer(new RenderScaleWidget(histogram, target));
      return { control, controlElement: control.element };
    },
    activateTool: (activation, control) => {
      activation.bindInputEventMap(TOOL_INPUT_EVENT_MAP);
      activation.bindAction("adjust-via-wheel", (event) => {
        event.stopPropagation();
        event.preventDefault();
        control.adjustViaWheel(event.detail);
      });
      activation.bindAction("reset", (event) => {
        event.stopPropagation();
        event.preventDefault();
        control.reset();
      });
    }
  };
}
const svg_rotate = '<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-labelledby="rotateIconTitle"><title id="rotateIconTitle">Rotate</title><path d="M22 12l-3 3-3-3"></path><path d="M2 12l3-3 3 3"></path><path d="M19.016 14v-1.95A7.05 7.05 0 0 0 8 6.22"></path><path d="M16.016 17.845A7.05 7.05 0 0 1 5 12.015V10"></path><path stroke-linecap="round" d="M5 10V9"></path><path stroke-linecap="round" d="M19 15v-1"></path></svg>';
function chooseColorMode(layer, useFixedColor) {
  if (!useFixedColor) {
    layer.displayState.segmentDefaultColor.value = void 0;
  } else {
    layer.displayState.segmentDefaultColor.value = fromValues$1(1, 0, 0);
  }
}
function colorSeedLayerControl() {
  const randomize = (layer) => {
    layer.displayState.segmentationColorGroupState.value.segmentColorHash.randomize();
  };
  return {
    makeControl: (layer, context, { labelTextContainer }) => {
      const checkbox = document.createElement("input");
      checkbox.type = "radio";
      checkbox.addEventListener("change", () => {
        chooseColorMode(layer, !checkbox.checked);
      });
      labelTextContainer.prepend(checkbox);
      const controlElement = document.createElement("div");
      controlElement.classList.add("neuroglancer-segmentation-color-seed-control");
      const widget = context.registerDisposer(new TextInputWidget(layer.displayState.segmentColorHash));
      controlElement.appendChild(widget.element);
      const randomizeButton = makeIcon({
        svg: svg_rotate,
        title: "Randomize",
        onClick: () => randomize(layer)
      });
      controlElement.appendChild(randomizeButton);
      context.registerDisposer(observeWatchable((value) => {
        const isVisible = value === void 0;
        controlElement.style.visibility = isVisible ? "" : "hidden";
        checkbox.checked = isVisible;
      }, layer.displayState.segmentDefaultColor));
      return { controlElement, control: widget };
    },
    activateTool: (activation) => {
      const layer = activation.tool.layer;
      chooseColorMode(layer, false);
      randomize(layer);
    }
  };
}
function fixedColorLayerControl() {
  const options = colorLayerControl((layer) => layer.displayState.segmentDefaultColor);
  return _Object$assign(_Object$assign({}, options), { makeControl: (layer, context, labelElements) => {
    const result = options.makeControl(layer, context, labelElements);
    const controlElement = result.controlElement;
    const checkbox = document.createElement("input");
    checkbox.type = "radio";
    checkbox.addEventListener("change", () => {
      chooseColorMode(layer, checkbox.checked);
      if (checkbox.checked) {
        controlElement.click();
      }
    });
    labelElements.labelTextContainer.prepend(checkbox);
    context.registerDisposer(observeWatchable((value) => {
      const isVisible = value !== void 0;
      controlElement.style.visibility = isVisible ? "" : "hidden";
      checkbox.checked = isVisible;
    }, layer.displayState.segmentDefaultColor));
    return result;
  }, activateTool: (activation, control) => {
    chooseColorMode(activation.tool.layer, true);
    options.activateTool(activation, control);
  } });
}
const SELECTED_ALPHA_JSON_KEY = "selectedAlpha";
const NOT_SELECTED_ALPHA_JSON_KEY = "notSelectedAlpha";
const OBJECT_ALPHA_JSON_KEY = "objectAlpha";
const SATURATION_JSON_KEY = "saturation";
const HIDE_SEGMENT_ZERO_JSON_KEY = "hideSegmentZero";
const BASE_SEGMENT_COLORING_JSON_KEY = "baseSegmentColoring";
const IGNORE_NULL_VISIBLE_SET_JSON_KEY = "ignoreNullVisibleSet";
const MESH_JSON_KEY = "mesh";
const SKELETONS_JSON_KEY = "skeletons";
const SEGMENTS_JSON_KEY = "segments";
const EQUIVALENCES_JSON_KEY = "equivalences";
const COLOR_SEED_JSON_KEY = "colorSeed";
const SEGMENT_STATED_COLORS_JSON_KEY = "segmentColors";
const MESH_RENDER_SCALE_JSON_KEY = "meshRenderScale";
const CROSS_SECTION_RENDER_SCALE_JSON_KEY$2 = "crossSectionRenderScale";
const SKELETON_RENDERING_JSON_KEY = "skeletonRendering";
const SKELETON_SHADER_JSON_KEY = "skeletonShader";
const SEGMENT_QUERY_JSON_KEY = "segmentQuery";
const MESH_SILHOUETTE_RENDERING_JSON_KEY = "meshSilhouetteRendering";
const LINKED_SEGMENTATION_GROUP_JSON_KEY = "linkedSegmentationGroup";
const LINKED_SEGMENTATION_COLOR_GROUP_JSON_KEY = "linkedSegmentationColorGroup";
const SEGMENT_DEFAULT_COLOR_JSON_KEY = "segmentDefaultColor";
const ANCHOR_SEGMENT_JSON_KEY = "anchorSegment";
const SKELETON_RENDERING_SHADER_CONTROL_TOOL_ID = "skeletonShaderControl";
class SegmentationUserLayerGroupState extends RefCounted {
  constructor(layer) {
    super();
    this.layer = layer;
    this.specificationChanged = new Signal();
    this.localGraph = new LocalSegmentationGraphSource();
    this.visibleSegments = this.registerDisposer(Uint64Set.makeWithCounterpart(this.layer.manager.rpc));
    this.segmentPropertyMap = new WatchableValue(void 0);
    this.graph = new WatchableValue(void 0);
    this.segmentEquivalences = this.registerDisposer(SharedDisjointUint64Sets.makeWithCounterpart(this.layer.manager.rpc, this.layer.registerDisposer(makeCachedDerivedWatchableValue((x) => x && x.visibleSegmentEquivalencePolicy || VisibleSegmentEquivalencePolicy.MIN_REPRESENTATIVE, [this.graph]))));
    this.localSegmentEquivalences = false;
    this.maxIdLength = new WatchableValue(1);
    this.hideSegmentZero = new TrackableBoolean(true, true);
    this.segmentQuery = new TrackableValue("", verifyString);
    this.temporaryVisibleSegments = this.layer.registerDisposer(Uint64Set.makeWithCounterpart(this.layer.manager.rpc));
    this.temporarySegmentEquivalences = this.layer.registerDisposer(SharedDisjointUint64Sets.makeWithCounterpart(this.layer.manager.rpc, this.segmentEquivalences.disjointSets.visibleSegmentEquivalencePolicy));
    this.useTemporaryVisibleSegments = this.layer.registerDisposer(SharedWatchableValue.make(this.layer.manager.rpc, false));
    this.useTemporarySegmentEquivalences = this.layer.registerDisposer(SharedWatchableValue.make(this.layer.manager.rpc, false));
    const specificationChanged = this.specificationChanged;
    this.visibleSegments.changed.add(specificationChanged.dispatch);
    this.hideSegmentZero.changed.add(specificationChanged.dispatch);
    this.segmentQuery.changed.add(specificationChanged.dispatch);
  }
  restoreState(specification) {
    verifyOptionalObjectProperty(specification, HIDE_SEGMENT_ZERO_JSON_KEY, (value) => this.hideSegmentZero.restoreState(value));
    verifyOptionalObjectProperty(specification, EQUIVALENCES_JSON_KEY, (value) => {
      this.localGraph.restoreState(value);
    });
    verifyOptionalObjectProperty(specification, SEGMENTS_JSON_KEY, (segmentsValue) => {
      const segmentEquivalences = this.segmentEquivalences, visibleSegments = this.visibleSegments;
      parseArray(segmentsValue, (value) => {
        let id = Uint64.parseString(String(value), 10);
        visibleSegments.add(segmentEquivalences.get(id));
      });
    });
    verifyOptionalObjectProperty(specification, SEGMENT_QUERY_JSON_KEY, (value) => this.segmentQuery.restoreState(value));
  }
  toJSON() {
    const x = {};
    x[HIDE_SEGMENT_ZERO_JSON_KEY] = this.hideSegmentZero.toJSON();
    let visibleSegments = this.visibleSegments;
    if (visibleSegments.size > 0) {
      x[SEGMENTS_JSON_KEY] = visibleSegments.toJSON();
    }
    let segmentEquivalences = this.segmentEquivalences;
    if (this.localSegmentEquivalences && segmentEquivalences.size > 0) {
      x[EQUIVALENCES_JSON_KEY] = segmentEquivalences.toJSON();
    }
    x[SEGMENT_QUERY_JSON_KEY] = this.segmentQuery.toJSON();
    return x;
  }
  assignFrom(other) {
    this.maxIdLength.value = other.maxIdLength.value;
    this.hideSegmentZero.value = other.hideSegmentZero.value;
    this.visibleSegments.assignFrom(other.visibleSegments);
    this.segmentEquivalences.assignFrom(other.segmentEquivalences);
  }
}
class SegmentationUserLayerColorGroupState extends RefCounted {
  constructor(layer) {
    super();
    this.layer = layer;
    this.specificationChanged = new Signal();
    this.segmentColorHash = SegmentColorHash.getDefault();
    this.segmentStatedColors = this.registerDisposer(new Uint64Map());
    this.segmentDefaultColor = new TrackableOptionalRGB();
    const specificationChanged = this.specificationChanged;
    this.segmentColorHash.changed.add(specificationChanged.dispatch);
    this.segmentStatedColors.changed.add(specificationChanged.dispatch);
    this.segmentDefaultColor.changed.add(specificationChanged.dispatch);
  }
  restoreState(specification) {
    verifyOptionalObjectProperty(specification, COLOR_SEED_JSON_KEY, (value) => this.segmentColorHash.restoreState(value));
    verifyOptionalObjectProperty(specification, SEGMENT_DEFAULT_COLOR_JSON_KEY, (value) => this.segmentDefaultColor.restoreState(value));
    verifyOptionalObjectProperty(specification, SEGMENT_STATED_COLORS_JSON_KEY, (y) => {
      let result = verifyObjectAsMap(y, (x) => parseRGBColorSpecification(String(x)));
      for (let _ref of result) {
        var _ref2 = _slicedToArray(_ref, 2);
        let idStr = _ref2[0];
        let colorVec = _ref2[1];
        const id = Uint64.parseString(String(idStr));
        const color2 = new Uint64(packColor(colorVec));
        this.segmentStatedColors.set(id, color2);
      }
    });
  }
  toJSON() {
    const x = {};
    x[COLOR_SEED_JSON_KEY] = this.segmentColorHash.toJSON();
    x[SEGMENT_DEFAULT_COLOR_JSON_KEY] = this.segmentDefaultColor.toJSON();
    const segmentStatedColors = this.segmentStatedColors;
    if (segmentStatedColors.size > 0) {
      const j = x[SEGMENT_STATED_COLORS_JSON_KEY] = {};
      for (const _ref3 of segmentStatedColors.unsafeEntries()) {
        var _ref4 = _slicedToArray(_ref3, 2);
        const key = _ref4[0];
        const value = _ref4[1];
        j[key.toString()] = serializeColor(unpackRGB(value.low));
      }
    }
    return x;
  }
  assignFrom(other) {
    this.segmentColorHash.value = other.segmentColorHash.value;
    this.segmentStatedColors.assignFrom(other.segmentStatedColors);
    this.segmentDefaultColor.value = other.segmentDefaultColor.value;
  }
}
class LinkedSegmentationGroupState extends RefCounted {
  constructor(linkedGroup, propertyName) {
    super();
    this.linkedGroup = linkedGroup;
    this.propertyName = propertyName;
    this.value;
  }
  get changed() {
    return this.linkedGroup.root.changed;
  }
  get value() {
    const root = this.linkedGroup.root.value;
    if (root !== this.curRoot) {
      this.curRoot = root;
      const groupState = root.displayState[this.propertyName];
      if (root === this.linkedGroup.layer) {
        const curGroupState = this.curGroupState;
        if (curGroupState !== void 0) {
          groupState.assignFrom(curGroupState);
          curGroupState.dispose();
        }
      }
      this.curGroupState = groupState.addRef();
    }
    return this.curGroupState;
  }
  disposed() {
    var _a;
    (_a = this.curGroupState) === null || _a === void 0 ? void 0 : _a.dispose();
  }
}
class SegmentationUserLayerDisplayState {
  constructor(layer) {
    this.layer = layer;
    this.segmentSelectionState = new SegmentSelectionState();
    this.selectedAlpha = trackableAlphaValue(0.5);
    this.saturation = trackableAlphaValue(1);
    this.notSelectedAlpha = trackableAlphaValue(0);
    this.silhouetteRendering = new TrackableValue(0, verifyFiniteNonNegativeFloat, 0);
    this.objectAlpha = trackableAlphaValue(1);
    this.ignoreNullVisibleSet = new TrackableBoolean(true, true);
    this.skeletonRenderingOptions = new SkeletonRenderingOptions();
    this.shaderError = makeWatchableShaderError();
    this.renderScaleHistogram = new RenderScaleHistogram();
    this.renderScaleTarget = trackableRenderScaleTarget(1);
    this.selectSegment = this.layer.selectSegment;
    this.transparentPickEnabled = this.layer.pick;
    this.baseSegmentColoring = new TrackableBoolean(false, false);
    this.filterBySegmentLabel = this.layer.filterBySegmentLabel;
    this.moveToSegment = (id) => {
      this.layer.moveToSegment(id);
    };
    this.linkedSegmentationGroup = this.layer.registerDisposer(new LinkedLayerGroup(this.layer.manager.rootLayers, this.layer, (userLayer) => userLayer instanceof SegmentationUserLayer, (userLayer) => userLayer.displayState.linkedSegmentationGroup));
    this.linkedSegmentationColorGroup = this.layer.registerDisposer(new LinkedLayerGroup(this.layer.manager.rootLayers, this.layer, (userLayer) => userLayer instanceof SegmentationUserLayer, (userLayer) => userLayer.displayState.linkedSegmentationColorGroup));
    this.originalSegmentationGroupState = this.layer.registerDisposer(new SegmentationUserLayerGroupState(this.layer));
    this.originalSegmentationColorGroupState = this.layer.registerDisposer(new SegmentationUserLayerColorGroupState(this.layer));
    layer.displayState = this;
    this.segmentationGroupState = this.layer.registerDisposer(new LinkedSegmentationGroupState(this.linkedSegmentationGroup, "originalSegmentationGroupState"));
    this.segmentationColorGroupState = this.layer.registerDisposer(new LinkedSegmentationGroupState(this.linkedSegmentationColorGroup, "originalSegmentationColorGroupState"));
    this.hideSegmentZero = this.layer.registerDisposer(new IndirectWatchableValue(this.segmentationGroupState, (group) => group.hideSegmentZero));
    this.segmentColorHash = this.layer.registerDisposer(new IndirectTrackableValue(this.segmentationColorGroupState, (group) => group.segmentColorHash));
    this.segmentStatedColors = this.layer.registerDisposer(new IndirectTrackableValue(this.segmentationColorGroupState, (group) => group.segmentStatedColors));
    this.segmentDefaultColor = this.layer.registerDisposer(new IndirectTrackableValue(this.segmentationColorGroupState, (group) => group.segmentDefaultColor));
    this.segmentQuery = this.layer.registerDisposer(new IndirectWatchableValue(this.segmentationGroupState, (group) => group.segmentQuery));
    this.segmentPropertyMap = this.layer.registerDisposer(new IndirectWatchableValue(this.segmentationGroupState, (group) => group.segmentPropertyMap));
  }
}
const Base$2 = UserLayerWithAnnotationsMixin(UserLayer);
class SegmentationUserLayer extends Base$2 {
  constructor(managedLayer) {
    super(managedLayer);
    this.sliceViewRenderScaleHistogram = new RenderScaleHistogram();
    this.sliceViewRenderScaleTarget = trackableRenderScaleTarget(1);
    this.segmentQueryFocusTime = new WatchableValue(Number.NEGATIVE_INFINITY);
    this.selectSegment = (id, pin) => {
      this.manager.root.selectionState.captureSingleLayerState(this, (state) => {
        state.value = id.clone();
        return true;
      }, pin);
    };
    this.filterBySegmentLabel = (id) => {
      const augmented = augmentSegmentId(this.displayState, id);
      const label = augmented.label;
      if (!label) return;
      this.filterSegments(label);
    };
    this.filterSegments = (query) => {
      this.displayState.segmentationGroupState.value.segmentQuery.value = query;
      this.segmentQueryFocusTime.value = Date.now();
      this.tabs.value = "segments";
      this.manager.root.selectedLayer.layer = this.managedLayer;
    };
    this.displayState = new SegmentationUserLayerDisplayState(this);
    this.anchorSegment = new TrackableValue(void 0, (x) => x === void 0 ? void 0 : Uint64.parseString(x));
    this.has2dLayer = this.registerDisposer(makeCachedLazyDerivedWatchableValue((layers) => layers.some((x) => x instanceof SegmentationRenderLayer), { changed: this.layersChanged, value: this.renderLayers }));
    this.has3dLayer = this.registerDisposer(makeCachedLazyDerivedWatchableValue((layers) => layers.some((x) => x instanceof MeshLayer || x instanceof MultiscaleMeshLayer || x instanceof PerspectiveViewSkeletonLayer || x instanceof SliceViewPanelSkeletonLayer), { changed: this.layersChanged, value: this.renderLayers }));
    this.hasSkeletonsLayer = this.registerDisposer(makeCachedLazyDerivedWatchableValue((layers) => layers.some((x) => x instanceof PerspectiveViewSkeletonLayer), { changed: this.layersChanged, value: this.renderLayers }));
    this.registerDisposer(registerNestedSync((context, group) => {
      context.registerDisposer(group.specificationChanged.add(this.specificationChanged.dispatch));
      this.specificationChanged.dispatch();
    }, this.displayState.segmentationGroupState));
    this.registerDisposer(registerNestedSync((context, group) => {
      context.registerDisposer(group.specificationChanged.add(this.specificationChanged.dispatch));
      this.specificationChanged.dispatch();
    }, this.displayState.segmentationColorGroupState));
    this.displayState.segmentSelectionState.bindTo(this.manager.layerSelectedValues, this);
    this.displayState.selectedAlpha.changed.add(this.specificationChanged.dispatch);
    this.displayState.saturation.changed.add(this.specificationChanged.dispatch);
    this.displayState.notSelectedAlpha.changed.add(this.specificationChanged.dispatch);
    this.displayState.objectAlpha.changed.add(this.specificationChanged.dispatch);
    this.displayState.baseSegmentColoring.changed.add(this.specificationChanged.dispatch);
    this.displayState.ignoreNullVisibleSet.changed.add(this.specificationChanged.dispatch);
    this.displayState.skeletonRenderingOptions.changed.add(this.specificationChanged.dispatch);
    this.displayState.renderScaleTarget.changed.add(this.specificationChanged.dispatch);
    this.displayState.silhouetteRendering.changed.add(this.specificationChanged.dispatch);
    this.anchorSegment.changed.add(this.specificationChanged.dispatch);
    this.sliceViewRenderScaleTarget.changed.add(this.specificationChanged.dispatch);
    this.displayState.originalSegmentationGroupState.localGraph.changed.add(this.specificationChanged.dispatch);
    this.displayState.linkedSegmentationGroup.changed.add(() => this.updateDataSubsourceActivations());
    this.tabs.add("rendering", { label: "Render", order: -100, getter: () => new DisplayOptionsTab(this) });
    this.tabs.add("segments", { label: "Seg.", order: -50, getter: () => new SegmentDisplayTab(this) });
    this.tabs.default = "rendering";
  }
  bindSegmentListWidth(element) {
    return bindSegmentListWidth(this.displayState, element);
  }
  get volumeOptions() {
    return { volumeType: VolumeType.SEGMENTATION };
  }
  activateDataSubsources(subsources) {
    const updatedSegmentPropertyMaps = [];
    const isGroupRoot = this.displayState.linkedSegmentationGroup.root.value === this;
    let updatedGraph;
    for (const loadedSubsource of subsources) {
      if (this.addStaticAnnotations(loadedSubsource)) continue;
      var _loadedSubsource$subs = loadedSubsource.subsourceEntry.subsource;
      const volume = _loadedSubsource$subs.volume, mesh = _loadedSubsource$subs.mesh, segmentPropertyMap = _loadedSubsource$subs.segmentPropertyMap, segmentationGraph = _loadedSubsource$subs.segmentationGraph, local = _loadedSubsource$subs.local;
      if (volume instanceof MultiscaleVolumeChunkSource$3) {
        switch (volume.dataType) {
          case DataType.FLOAT32:
            loadedSubsource.deactivate("Data type not compatible with segmentation layer");
            continue;
        }
        loadedSubsource.activate(() => loadedSubsource.addRenderLayer(new SegmentationRenderLayer(volume, _Object$assign(_Object$assign({}, this.displayState), { transform: loadedSubsource.getRenderLayerTransform(), renderScaleTarget: this.sliceViewRenderScaleTarget, renderScaleHistogram: this.sliceViewRenderScaleHistogram, localPosition: this.localPosition }))), this.displayState.segmentationGroupState.value);
      } else if (mesh !== void 0) {
        loadedSubsource.activate(() => {
          const displayState = _Object$assign(_Object$assign({}, this.displayState), { transform: loadedSubsource.getRenderLayerTransform() });
          if (mesh instanceof MeshSource) {
            loadedSubsource.addRenderLayer(new MeshLayer(this.manager.chunkManager, mesh, displayState));
          } else if (mesh instanceof MultiscaleMeshSource) {
            loadedSubsource.addRenderLayer(new MultiscaleMeshLayer(this.manager.chunkManager, mesh, displayState));
          } else {
            const base = new SkeletonLayer(this.manager.chunkManager, mesh, displayState);
            loadedSubsource.addRenderLayer(new PerspectiveViewSkeletonLayer(base.addRef()));
            loadedSubsource.addRenderLayer(new SliceViewPanelSkeletonLayer(
              /* transfer ownership */
              base
            ));
          }
        }, this.displayState.segmentationGroupState.value);
      } else if (segmentPropertyMap !== void 0) {
        if (!isGroupRoot) {
          loadedSubsource.deactivate(`Not supported on non-root linked segmentation layers`);
        } else {
          loadedSubsource.activate(() => {
          });
          updatedSegmentPropertyMaps.push(segmentPropertyMap);
        }
      } else if (segmentationGraph !== void 0) {
        if (!isGroupRoot) {
          loadedSubsource.deactivate(`Not supported on non-root linked segmentation layers`);
        } else {
          if (updatedGraph !== void 0) {
            loadedSubsource.deactivate("Only one segmentation graph is supported");
          } else {
            updatedGraph = segmentationGraph;
            loadedSubsource.activate((refCounted) => {
              this.graphConnection = refCounted.registerDisposer(segmentationGraph.connect(this.displayState.segmentationGroupState.value));
              const displayState = _Object$assign(_Object$assign({}, this.displayState), { transform: loadedSubsource.getRenderLayerTransform() });
              const graphRenderLayers = this.graphConnection.createRenderLayers(this.manager.chunkManager, displayState, this.localPosition);
              for (const renderLayer of graphRenderLayers) {
                loadedSubsource.addRenderLayer(renderLayer);
              }
            });
          }
        }
      } else if (local === LocalDataSource.equivalences) {
        if (!isGroupRoot) {
          loadedSubsource.deactivate(`Not supported on non-root linked segmentation layers`);
        } else {
          if (updatedGraph !== void 0) {
            loadedSubsource.deactivate("Only one segmentation graph is supported");
          } else {
            updatedGraph = this.displayState.originalSegmentationGroupState.localGraph;
            loadedSubsource.activate((refCounted) => {
              this.graphConnection = refCounted.registerDisposer(updatedGraph.connect(this.displayState.segmentationGroupState.value));
              refCounted.registerDisposer(() => {
                this.graphConnection = void 0;
              });
            });
          }
        }
      } else {
        loadedSubsource.deactivate("Not compatible with segmentation layer");
      }
    }
    this.displayState.originalSegmentationGroupState.segmentPropertyMap.value = getPreprocessedSegmentPropertyMap(this.manager.chunkManager, updatedSegmentPropertyMaps);
    this.displayState.originalSegmentationGroupState.graph.value = updatedGraph;
  }
  getLegacyDataSourceSpecifications(sourceSpec, layerSpec, legacyTransform, explicitSpecs) {
    const specs = super.getLegacyDataSourceSpecifications(sourceSpec, layerSpec, legacyTransform, explicitSpecs);
    const meshPath = verifyOptionalObjectProperty(layerSpec, MESH_JSON_KEY, (x) => x === null ? null : verifyString(x));
    const skeletonsPath = verifyOptionalObjectProperty(layerSpec, SKELETONS_JSON_KEY, (x) => x === null ? null : verifyString(x));
    if (meshPath !== void 0 || skeletonsPath !== void 0) {
      for (const spec of specs) {
        spec.enableDefaultSubsources = false;
        spec.subsources = new _Map([["default", { enabled: true }], ["bounds", { enabled: true }]]);
      }
    }
    if (meshPath != null) {
      specs.push(layerDataSourceSpecificationFromJson(this.manager.dataSourceProviderRegistry.convertLegacyUrl({ url: meshPath, type: "mesh" })));
    }
    if (skeletonsPath != null) {
      specs.push(layerDataSourceSpecificationFromJson(this.manager.dataSourceProviderRegistry.convertLegacyUrl({ url: skeletonsPath, type: "skeletons" })));
    }
    if (layerSpec[EQUIVALENCES_JSON_KEY] !== void 0 && explicitSpecs.find((spec) => spec.url === localEquivalencesUrl) === void 0) {
      specs.push({
        url: localEquivalencesUrl,
        enableDefaultSubsources: true,
        transform: {
          outputSpace: emptyValidCoordinateSpace,
          sourceRank: 0,
          transform: void 0,
          inputSpace: emptyValidCoordinateSpace
        },
        subsources: new _Map()
      });
    }
    return specs;
  }
  restoreState(specification) {
    super.restoreState(specification);
    this.displayState.selectedAlpha.restoreState(specification[SELECTED_ALPHA_JSON_KEY]);
    this.displayState.saturation.restoreState(specification[SATURATION_JSON_KEY]);
    this.displayState.notSelectedAlpha.restoreState(specification[NOT_SELECTED_ALPHA_JSON_KEY]);
    this.displayState.objectAlpha.restoreState(specification[OBJECT_ALPHA_JSON_KEY]);
    this.displayState.baseSegmentColoring.restoreState(specification[BASE_SEGMENT_COLORING_JSON_KEY]);
    this.displayState.silhouetteRendering.restoreState(specification[MESH_SILHOUETTE_RENDERING_JSON_KEY]);
    this.displayState.ignoreNullVisibleSet.restoreState(specification[IGNORE_NULL_VISIBLE_SET_JSON_KEY]);
    const skeletonRenderingOptions = this.displayState.skeletonRenderingOptions;
    skeletonRenderingOptions.restoreState(specification[SKELETON_RENDERING_JSON_KEY]);
    const skeletonShader = specification[SKELETON_SHADER_JSON_KEY];
    if (skeletonShader !== void 0) {
      skeletonRenderingOptions.shader.restoreState(skeletonShader);
    }
    this.displayState.renderScaleTarget.restoreState(specification[MESH_RENDER_SCALE_JSON_KEY]);
    this.anchorSegment.restoreState(specification[ANCHOR_SEGMENT_JSON_KEY]);
    this.sliceViewRenderScaleTarget.restoreState(specification[CROSS_SECTION_RENDER_SCALE_JSON_KEY$2]);
    const linkedSegmentationGroupName = verifyOptionalObjectProperty(specification, LINKED_SEGMENTATION_GROUP_JSON_KEY, verifyString);
    if (linkedSegmentationGroupName !== void 0) {
      this.displayState.linkedSegmentationGroup.linkByName(linkedSegmentationGroupName);
    }
    const linkedSegmentationColorGroupName = verifyOptionalObjectProperty(specification, LINKED_SEGMENTATION_COLOR_GROUP_JSON_KEY, (x) => x === false ? void 0 : verifyString(x), linkedSegmentationGroupName);
    if (linkedSegmentationColorGroupName !== void 0) {
      this.displayState.linkedSegmentationColorGroup.linkByName(linkedSegmentationColorGroupName);
    }
    this.displayState.segmentationGroupState.value.restoreState(specification);
    this.displayState.segmentationColorGroupState.value.restoreState(specification);
  }
  toJSON() {
    var _a;
    const x = super.toJSON();
    x[SELECTED_ALPHA_JSON_KEY] = this.displayState.selectedAlpha.toJSON();
    x[NOT_SELECTED_ALPHA_JSON_KEY] = this.displayState.notSelectedAlpha.toJSON();
    x[SATURATION_JSON_KEY] = this.displayState.saturation.toJSON();
    x[OBJECT_ALPHA_JSON_KEY] = this.displayState.objectAlpha.toJSON();
    x[BASE_SEGMENT_COLORING_JSON_KEY] = this.displayState.baseSegmentColoring.toJSON();
    x[IGNORE_NULL_VISIBLE_SET_JSON_KEY] = this.displayState.ignoreNullVisibleSet.toJSON();
    x[MESH_SILHOUETTE_RENDERING_JSON_KEY] = this.displayState.silhouetteRendering.toJSON();
    x[ANCHOR_SEGMENT_JSON_KEY] = this.anchorSegment.toJSON();
    x[SKELETON_RENDERING_JSON_KEY] = this.displayState.skeletonRenderingOptions.toJSON();
    x[MESH_RENDER_SCALE_JSON_KEY] = this.displayState.renderScaleTarget.toJSON();
    x[CROSS_SECTION_RENDER_SCALE_JSON_KEY$2] = this.sliceViewRenderScaleTarget.toJSON();
    var _displayState = this.displayState;
    const linkedSegmentationGroup = _displayState.linkedSegmentationGroup, linkedSegmentationColorGroup = _displayState.linkedSegmentationColorGroup;
    x[LINKED_SEGMENTATION_GROUP_JSON_KEY] = linkedSegmentationGroup.toJSON();
    if (linkedSegmentationColorGroup.root.value !== linkedSegmentationGroup.root.value) {
      x[LINKED_SEGMENTATION_COLOR_GROUP_JSON_KEY] = (_a = linkedSegmentationColorGroup.toJSON()) !== null && _a !== void 0 ? _a : false;
    }
    x[EQUIVALENCES_JSON_KEY] = this.displayState.originalSegmentationGroupState.localGraph.toJSON();
    if (linkedSegmentationGroup.root.value === this) {
      _Object$assign(x, this.displayState.segmentationGroupState.value.toJSON());
    }
    if (linkedSegmentationColorGroup.root.value === this) {
      _Object$assign(x, this.displayState.segmentationColorGroupState.value.toJSON());
    }
    return x;
  }
  transformPickedValue(value) {
    if (value == null) {
      return value;
    }
    return maybeAugmentSegmentId(
      this.displayState,
      value,
      /*mustCopy=*/
      true
    );
  }
  handleAction(action, context) {
    switch (action) {
      case "recolor": {
        this.displayState.segmentationColorGroupState.value.segmentColorHash.randomize();
        break;
      }
      case "clear-segments": {
        if (!this.pick.value) break;
        this.displayState.segmentationGroupState.value.visibleSegments.clear();
        break;
      }
      case "select": {
        if (!this.pick.value) break;
        const segmentSelectionState = this.displayState.segmentSelectionState;
        if (segmentSelectionState.hasSelectedSegment) {
          const segment = segmentSelectionState.selectedSegment;
          const visibleSegments = this.displayState.segmentationGroupState.value.visibleSegments;
          const newVisible = !visibleSegments.has(segment);
          if (newVisible || context.segmentationToggleSegmentState === void 0) {
            context.segmentationToggleSegmentState = newVisible;
          }
          context.defer(() => {
            if (context.segmentationToggleSegmentState === newVisible) {
              visibleSegments.set(segment, newVisible);
            }
          });
        }
        break;
      }
      case "copy-segment-id": {
        if (!this.pick.value) break;
        const segmentSelectionState = this.displayState.segmentSelectionState;
        if (segmentSelectionState.hasSelectedSegment) {
          const segment = segmentSelectionState.selectedSegment;
          this.copiedSegments = [segment.clone()];
          const text = segment.toString();
          if (setClipboard(text)) {
            StatusMessage.showTemporaryMessage(text + " copied to clipboard");
          }
        }
        break;
      }
      case "add-copy-segment-id": {
        if (!this.pick.value) break;
        const segmentSelectionState = this.displayState.segmentSelectionState;
        if (segmentSelectionState.hasSelectedSegment) {
          const segment = segmentSelectionState.selectedSegment;
          this.copiedSegments.push(segment.clone());
          const text = this.copiedSegments.map((s) => s.toString()).join(",");
          if (setClipboard(text)) {
            StatusMessage.showTemporaryMessage(text + " copied to clipboard");
          }
        }
        break;
      }
    }
  }
  selectionStateFromJson(state, json2) {
    super.selectionStateFromJson(state, json2);
    const v = new Uint64();
    let value = state.value;
    if (typeof value === "number") value = value.toString();
    if (typeof value !== "string" || !v.tryParseString(value)) {
      state.value = void 0;
    } else {
      state.value = v;
    }
  }
  selectionStateToJson(state, forPython) {
    const json2 = super.selectionStateToJson(state, forPython);
    let value = state.value;
    if (value instanceof Uint64MapEntry) {
      if (forPython) {
        json2.value = {
          key: value.key.toString(),
          value: value.value ? value.value.toString() : void 0,
          label: value.label
        };
      } else {
        json2.value = (value.value || value.key).toString();
      }
    } else if (value instanceof Uint64) {
      json2.value = value.toString();
    }
    return json2;
  }
  displaySegmentationSelection(state, parent, context) {
    const value = state.value;
    let id;
    if (typeof value === "number" || typeof value === "string") {
      id = new Uint64();
      if (!id.tryParseString(value.toString())) return false;
    }
    if (value instanceof Uint64) {
      id = value.clone();
    } else if (value instanceof Uint64MapEntry) {
      id = value.key.clone();
    } else {
      return false;
    }
    const displayState = this.displayState;
    const normalizedId = augmentSegmentId(displayState, id);
    var _displayState$segment = this.displayState.segmentationGroupState.value;
    const segmentEquivalences = _displayState$segment.segmentEquivalences, segmentPropertyMap = _displayState$segment.segmentPropertyMap.value;
    const mapped = segmentEquivalences.get(id);
    const row = makeSegmentWidget(this.displayState, normalizedId);
    registerCallbackWhenSegmentationDisplayStateChanged(displayState, context, context.redraw);
    context.registerDisposer(bindSegmentListWidth(displayState, row));
    row.classList.add("neuroglancer-selection-details-segment");
    parent.appendChild(row);
    if (segmentPropertyMap !== void 0) {
      const inlineProperties = segmentPropertyMap.segmentPropertyMap.inlineProperties;
      if (inlineProperties !== void 0) {
        const index2 = segmentPropertyMap.getSegmentInlineIndex(mapped);
        if (index2 !== -1) {
          for (const property of inlineProperties.properties) {
            if (property.type === "label") continue;
            if (property.type === "description") {
              const value2 = property.values[index2];
              if (!value2) continue;
              const descriptionElement = document.createElement("div");
              descriptionElement.classList.add("neuroglancer-selection-details-segment-description");
              descriptionElement.textContent = value2;
              parent.appendChild(descriptionElement);
            } else if (property.type === "number" || property.type === "string") {
              const value2 = property.values[index2];
              if (property.type === "number" ? isNaN(value2) : !value2) continue;
              const propertyElement = document.createElement("div");
              propertyElement.classList.add("neuroglancer-selection-details-segment-property");
              const nameElement = document.createElement("div");
              nameElement.classList.add("neuroglancer-selection-details-segment-property-name");
              nameElement.textContent = property.id;
              if (property.description) {
                nameElement.title = property.description;
              }
              const valueElement = document.createElement("div");
              valueElement.classList.add("neuroglancer-selection-details-segment-property-value");
              valueElement.textContent = value2.toString();
              propertyElement.appendChild(nameElement);
              propertyElement.appendChild(valueElement);
              parent.appendChild(propertyElement);
            }
          }
        }
      }
    }
    return true;
  }
  displaySelectionState(state, parent, context) {
    let displayed = this.displaySegmentationSelection(state, parent, context);
    if (super.displaySelectionState(state, parent, context)) displayed = true;
    return displayed;
  }
  moveToSegment(id) {
    for (const layer of this.renderLayers) {
      if (!(layer instanceof MultiscaleMeshLayer)) continue;
      const layerPosition = layer.getObjectPosition(id);
      if (layerPosition === void 0) continue;
      this.setLayerPosition(layer.displayState.transform.value, layerPosition);
      return;
    }
    let hasPositionApi = false;
    for (const layer of this.renderLayers) {
      if (layer instanceof SegmentationRenderLayer) {
        const source = layer.multiscaleSource;
        if (source.getSegmentPosition) {
          hasPositionApi = true;
          source.getSegmentPosition(id).then((position) => {
            this.setLayerPosition(null, position);
          }).catch((error) => {
            StatusMessage.showTemporaryMessage(`Failed to retrieve position for segment ${id}: ${error}`);
          });
        }
      }
    }
    if (!hasPositionApi) {
      StatusMessage.showTemporaryMessage(`No position information loaded for segment ${id}`);
    }
  }
}
SegmentationUserLayer.type = "segmentation";
SegmentationUserLayer.typeAbbreviation = "seg";
SegmentationUserLayer.supportsPickOption = true;
const maxSilhouettePower = 10;
function getViewSpecificSkeletonRenderingControl(viewName) {
  return [_Object$assign({ label: `Skeleton mode (${viewName})`, toolJson: `${SKELETON_RENDERING_JSON_KEY}.mode${viewName}`, isValid: (layer) => layer.hasSkeletonsLayer }, enumLayerControl((layer) => layer.displayState.skeletonRenderingOptions[`params${viewName}`].mode)), _Object$assign({ label: `Line width (${viewName})`, toolJson: `${SKELETON_RENDERING_JSON_KEY}.lineWidth${viewName}`, isValid: (layer) => layer.hasSkeletonsLayer, toolDescription: `Skeleton line width (${viewName})`, title: `Skeleton line width (${viewName})` }, rangeLayerControl((layer) => ({
    value: layer.displayState.skeletonRenderingOptions[`params${viewName}`].lineWidth,
    options: { min: 1, max: 40, step: 1 }
  })))];
}
const LAYER_CONTROLS$1 = [_Object$assign({ label: "Color seed", title: "Color segments based on a hash of their id", toolJson: COLOR_SEED_JSON_KEY }, colorSeedLayerControl()), _Object$assign({ label: "Fixed color", title: "Use a fixed color for all segments without an explicitly-specified color", toolJson: SEGMENT_DEFAULT_COLOR_JSON_KEY }, fixedColorLayerControl()), _Object$assign({ label: "Saturation", toolJson: SATURATION_JSON_KEY, title: "Saturation of segment colors" }, rangeLayerControl((layer) => ({ value: layer.displayState.saturation }))), _Object$assign({ label: "Opacity (on)", toolJson: SELECTED_ALPHA_JSON_KEY, isValid: (layer) => layer.has2dLayer, title: "Opacity in cross-section views of segments that are selected" }, rangeLayerControl((layer) => ({ value: layer.displayState.selectedAlpha }))), _Object$assign({ label: "Opacity (off)", toolJson: NOT_SELECTED_ALPHA_JSON_KEY, isValid: (layer) => layer.has2dLayer, title: "Opacity in cross-section views of segments that are not selected" }, rangeLayerControl((layer) => ({ value: layer.displayState.notSelectedAlpha }))), _Object$assign({ label: "Resolution (slice)", toolJson: CROSS_SECTION_RENDER_SCALE_JSON_KEY$2, isValid: (layer) => layer.has2dLayer }, renderScaleLayerControl((layer) => ({
  histogram: layer.sliceViewRenderScaleHistogram,
  target: layer.sliceViewRenderScaleTarget
}))), _Object$assign({ label: "Resolution (mesh)", toolJson: MESH_RENDER_SCALE_JSON_KEY, isValid: (layer) => layer.has3dLayer }, renderScaleLayerControl((layer) => ({
  histogram: layer.displayState.renderScaleHistogram,
  target: layer.displayState.renderScaleTarget
}))), _Object$assign({ label: "Opacity (3d)", toolJson: OBJECT_ALPHA_JSON_KEY, isValid: (layer) => layer.has3dLayer, title: "Opacity of meshes and skeletons" }, rangeLayerControl((layer) => ({ value: layer.displayState.objectAlpha }))), _Object$assign({ label: "Silhouette (3d)", toolJson: MESH_SILHOUETTE_RENDERING_JSON_KEY, isValid: (layer) => layer.has3dLayer, title: "Set to a non-zero value to increase transparency of object faces perpendicular to view direction" }, rangeLayerControl((layer) => ({
  value: layer.displayState.silhouetteRendering,
  options: { min: 0, max: maxSilhouettePower, step: 0.1 }
}))), _Object$assign({ label: "Hide segment ID 0", toolJson: HIDE_SEGMENT_ZERO_JSON_KEY, title: "Disallow selection and display of segment id 0" }, checkboxLayerControl((layer) => layer.displayState.hideSegmentZero)), _Object$assign({ label: "Base segment coloring", toolJson: BASE_SEGMENT_COLORING_JSON_KEY, title: "Color base segments individually" }, checkboxLayerControl((layer) => layer.displayState.baseSegmentColoring)), _Object$assign({ label: "Show all by default", title: "Show all segments if none are selected", toolJson: IGNORE_NULL_VISIBLE_SET_JSON_KEY }, checkboxLayerControl((layer) => layer.displayState.ignoreNullVisibleSet)), ...getViewSpecificSkeletonRenderingControl("2d"), ...getViewSpecificSkeletonRenderingControl("3d")];
for (const control of LAYER_CONTROLS$1) {
  registerLayerControl(SegmentationUserLayer, control);
}
registerLayerType(SegmentationUserLayer);
registerVolumeLayerType(VolumeType.SEGMENTATION, SegmentationUserLayer);
registerLayerTypeDetector((subsource) => {
  if (subsource.mesh !== void 0) {
    return { layerConstructor: SegmentationUserLayer, priority: 1 };
  }
  return void 0;
});
registerLayerShaderControlsTool(SegmentationUserLayer, (layer) => ({
  shaderControlState: layer.displayState.skeletonRenderingOptions.shaderControlState
}), SKELETON_RENDERING_SHADER_CONTROL_TOOL_ID);
registerSegmentSplitMergeTools();
registerSegmentSelectTools();
const segmentation_user_layer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LAYER_CONTROLS: LAYER_CONTROLS$1,
  SKELETON_RENDERING_SHADER_CONTROL_TOOL_ID,
  SegmentationUserLayer,
  SegmentationUserLayerColorGroupState,
  SegmentationUserLayerGroupState
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LayerReferenceWidget extends RefCounted {
  constructor(ref) {
    super();
    this.ref = ref;
    this.element = document.createElement("label");
    this.selectElement = document.createElement("select");
    this.registerDisposer(ref);
    const element = this.element, selectElement = this.selectElement;
    element.appendChild(selectElement);
    this.updateView();
    this.registerEventListener(selectElement, "change", () => this.updateModel());
    this.registerDisposer(this.ref.changed.add(debounce(() => this.updateView(), 0)));
  }
  updateModel() {
    this.ref.layerName = this.selectElement.value || void 0;
  }
  updateView() {
    const selectElement = this.selectElement, ref = this.ref;
    const filter = ref.filter;
    removeChildren(selectElement);
    const emptyOption = document.createElement("option");
    selectElement.appendChild(emptyOption);
    for (const layer of this.ref.layerManager.managedLayers) {
      if (filter(layer)) {
        const option = document.createElement("option");
        const name2 = layer.name;
        option.textContent = name2;
        option.value = name2;
        selectElement.appendChild(option);
      }
    }
    selectElement.value = ref.layerName || "";
  }
}
const POINTS_JSON_KEY = "points";
const ANNOTATIONS_JSON_KEY = "annotations";
const ANNOTATION_PROPERTIES_JSON_KEY = "annotationProperties";
const ANNOTATION_RELATIONSHIPS_JSON_KEY = "annotationRelationships";
const CROSS_SECTION_RENDER_SCALE_JSON_KEY$1 = "crossSectionAnnotationSpacing";
const PROJECTION_RENDER_SCALE_JSON_KEY = "projectionAnnotationSpacing";
const SHADER_JSON_KEY$1 = "shader";
const SHADER_CONTROLS_JSON_KEY$1 = "shaderControls";
function addPointAnnotations(annotations, obj) {
  if (obj === void 0) {
    return;
  }
  parseArray(obj, (x, i) => {
    annotations.add({
      type: AnnotationType.POINT,
      id: "" + i,
      point: verify3dVec(x),
      properties: []
    });
  });
}
function isValidLinkedSegmentationLayer(layer) {
  const userLayer = layer.layer;
  if (userLayer === null) {
    return true;
  }
  if (userLayer instanceof SegmentationUserLayer) {
    return true;
  }
  return false;
}
function getSegmentationDisplayState(layer) {
  if (layer === void 0) {
    return null;
  }
  const userLayer = layer.layer;
  if (userLayer === null) {
    return null;
  }
  if (!(userLayer instanceof SegmentationUserLayer)) {
    return null;
  }
  return userLayer.displayState;
}
const LINKED_SEGMENTATION_LAYER_JSON_KEY = "linkedSegmentationLayer";
const FILTER_BY_SEGMENTATION_JSON_KEY = "filterBySegmentation";
const IGNORE_NULL_SEGMENT_FILTER_JSON_KEY = "ignoreNullSegmentFilter";
class LinkedSegmentationLayers extends RefCounted {
  constructor(layerManager, annotationStates, annotationDisplayState) {
    super();
    this.layerManager = layerManager;
    this.annotationStates = annotationStates;
    this.annotationDisplayState = annotationDisplayState;
    this.changed = new NullarySignal();
    this.curGeneration = -1;
    this.wasLoading = void 0;
    this.map = new _Map();
    this.registerDisposer(annotationStates.changed.add(() => this.update()));
    this.registerDisposer(annotationStates.isLoadingChanged.add(() => this.update()));
    this.update();
  }
  update() {
    const generation = this.annotationStates.changed.count;
    const isLoading = this.annotationStates.isLoading;
    if (this.curGeneration === generation && isLoading === this.wasLoading) return;
    this.wasLoading = isLoading;
    this.curGeneration = generation;
    const map2 = this.map;
    let changed = false;
    for (const relationship of this.annotationStates.relationships) {
      let state = map2.get(relationship);
      if (state === void 0) {
        state = this.addRelationship(relationship);
        changed = true;
      }
      state.seenGeneration = generation;
    }
    if (!isLoading) {
      for (const _ref of map2) {
        var _ref2 = _slicedToArray(_ref, 2);
        const relationship = _ref2[0];
        const state = _ref2[1];
        if (state.seenGeneration !== generation) {
          map2.delete(relationship);
          changed = true;
        }
      }
    }
    if (changed) {
      this.changed.dispatch();
    }
  }
  addRelationship(relationship) {
    const relationshipState = this.annotationDisplayState.relationshipStates.get(relationship);
    const layerRef = new LayerReference(this.layerManager.addRef(), isValidLinkedSegmentationLayer);
    layerRef.registerDisposer(layerRef.changed.add(() => {
      relationshipState.segmentationState.value = layerRef.layerName === void 0 ? void 0 : getSegmentationDisplayState(layerRef.layer);
    }));
    const showMatches = relationshipState.showMatches;
    const state = {
      layerRef,
      showMatches,
      seenGeneration: -1
    };
    layerRef.changed.add(this.changed.dispatch);
    showMatches.changed.add(this.changed.dispatch);
    this.map.set(relationship, state);
    return state;
  }
  get(relationship) {
    this.update();
    return this.map.get(relationship);
  }
  unbind(state) {
    state.layerRef.changed.remove(this.changed.dispatch);
    state.showMatches.changed.remove(this.changed.dispatch);
  }
  reset() {
    for (const state of this.map.values()) {
      state.showMatches.reset();
    }
  }
  toJSON() {
    const map2 = this.map;
    if (map2.size === 0) return {};
    let linkedJson = void 0;
    const filterBySegmentation = [];
    for (const _ref3 of map2) {
      var _ref4 = _slicedToArray(_ref3, 2);
      const name2 = _ref4[0];
      const state = _ref4[1];
      if (state.showMatches.value) {
        filterBySegmentation.push(name2);
      }
      const layerName = state.layerRef.layerName;
      if (layerName !== void 0) {
        (linkedJson = linkedJson || {})[name2] = layerName;
      }
    }
    filterBySegmentation.sort();
    return {
      [LINKED_SEGMENTATION_LAYER_JSON_KEY]: linkedJson,
      [FILTER_BY_SEGMENTATION_JSON_KEY]: filterBySegmentation.length === 0 ? void 0 : filterBySegmentation
    };
  }
  restoreState(json2) {
    const isLoading = this.annotationStates.isLoading;
    verifyOptionalObjectProperty(json2, LINKED_SEGMENTATION_LAYER_JSON_KEY, (linkedJson) => {
      if (typeof linkedJson === "string") {
        linkedJson = { "segments": linkedJson };
      }
      verifyObject(linkedJson);
      for (const key of _Object$keys(linkedJson)) {
        const value = verifyString(linkedJson[key]);
        let state = this.map.get(key);
        if (state === void 0) {
          if (!isLoading) continue;
          state = this.addRelationship(key);
        }
        state.layerRef.layerName = value;
      }
      for (const _ref5 of this.map) {
        var _ref6 = _slicedToArray(_ref5, 2);
        const relationship = _ref6[0];
        const state = _ref6[1];
        if (!Object.prototype.hasOwnProperty.call(linkedJson, relationship)) {
          state.layerRef.layerName = void 0;
        }
      }
    });
    verifyOptionalObjectProperty(json2, FILTER_BY_SEGMENTATION_JSON_KEY, (filterJson) => {
      if (typeof filterJson === "boolean") {
        filterJson = filterJson === true ? ["segments"] : [];
      }
      for (const key of verifyStringArray(filterJson)) {
        let state = this.map.get(key);
        if (state === void 0) {
          if (!isLoading) continue;
          state = this.addRelationship(key);
        }
        state.showMatches.value = true;
      }
    });
  }
  disposed() {
    const map2 = this.map;
    for (const state of map2.values()) {
      this.unbind(state);
    }
    map2.clear();
    super.disposed();
  }
}
class LinkedSegmentationLayerWidget extends RefCounted {
  constructor(relationship, state) {
    super();
    this.relationship = relationship;
    this.state = state;
    this.element = document.createElement("label");
    this.seenGeneration = -1;
    const element = this.element;
    const checkboxWidget = this.registerDisposer(new TrackableBooleanCheckbox(state.showMatches));
    const layerWidget = new LayerReferenceWidget(state.layerRef);
    element.appendChild(checkboxWidget.element);
    element.appendChild(document.createTextNode(relationship));
    element.appendChild(layerWidget.element);
  }
}
class LinkedSegmentationLayersWidget extends RefCounted {
  constructor(linkedSegmentationLayers) {
    super();
    this.linkedSegmentationLayers = linkedSegmentationLayers;
    this.widgets = new _Map();
    this.element = document.createElement("div");
    this.element.style.display = "contents";
    const debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateView()));
    this.registerDisposer(this.linkedSegmentationLayers.annotationStates.changed.add(debouncedUpdateView));
    this.updateView();
  }
  updateView() {
    const linkedSegmentationLayers = this.linkedSegmentationLayers;
    const annotationStates = linkedSegmentationLayers.annotationStates;
    const generation = annotationStates.changed.count;
    const widgets = this.widgets;
    function* getChildren() {
      for (const relationship of annotationStates.relationships) {
        let widget = widgets.get(relationship);
        if (widget === void 0) {
          widget = new LinkedSegmentationLayerWidget(relationship, linkedSegmentationLayers.get(relationship));
        }
        widget.seenGeneration = generation;
        yield widget.element;
      }
    }
    for (const _ref7 of widgets) {
      var _ref8 = _slicedToArray(_ref7, 2);
      const relationship = _ref8[0];
      const widget = _ref8[1];
      if (widget.seenGeneration !== generation) {
        widget.dispose();
        widgets.delete(relationship);
      }
    }
    updateChildren(this.element, getChildren.call(this));
  }
  disposed() {
    super.disposed();
    for (const widget of this.widgets.values()) {
      widget.dispose();
    }
  }
}
const Base$1 = UserLayerWithAnnotationsMixin(UserLayer);
class AnnotationUserLayer extends Base$1 {
  constructor(managedLayer) {
    super(managedLayer);
    this.annotationProperties = new WatchableValue(void 0);
    this.localAnnotationsJson = void 0;
    this.pointAnnotationsJson = void 0;
    this.linkedSegmentationLayers = this.registerDisposer(new LinkedSegmentationLayers(this.manager.rootLayers, this.annotationStates, this.annotationDisplayState));
    this.linkedSegmentationLayers.changed.add(this.specificationChanged.dispatch);
    this.annotationDisplayState.ignoreNullSegmentFilter.changed.add(this.specificationChanged.dispatch);
    this.annotationCrossSectionRenderScaleTarget.changed.add(this.specificationChanged.dispatch);
    this.tabs.add("rendering", { label: "Rendering", order: -100, getter: () => new RenderingOptionsTab$1(this) });
    this.tabs.default = "annotations";
    this.allowingRefresh = true;
  }
  disposed() {
    const localAnnotations = this.localAnnotations;
    if (localAnnotations !== void 0) {
      localAnnotations.dispose();
    }
    super.disposed();
  }
  restoreState(specification) {
    super.restoreState(specification);
    this.linkedSegmentationLayers.restoreState(specification);
    this.localAnnotationsJson = specification[ANNOTATIONS_JSON_KEY];
    this.localAnnotationProperties = verifyOptionalObjectProperty(specification, ANNOTATION_PROPERTIES_JSON_KEY, parseAnnotationPropertySpecs);
    this.localAnnotationRelationships = verifyOptionalObjectProperty(specification, ANNOTATION_RELATIONSHIPS_JSON_KEY, verifyStringArray, ["segments"]);
    this.pointAnnotationsJson = specification[POINTS_JSON_KEY];
    this.annotationCrossSectionRenderScaleTarget.restoreState(specification[CROSS_SECTION_RENDER_SCALE_JSON_KEY$1]);
    this.annotationProjectionRenderScaleTarget.restoreState(specification[PROJECTION_RENDER_SCALE_JSON_KEY]);
    this.annotationDisplayState.ignoreNullSegmentFilter.restoreState(specification[IGNORE_NULL_SEGMENT_FILTER_JSON_KEY]);
    this.annotationDisplayState.shader.restoreState(specification[SHADER_JSON_KEY$1]);
    this.annotationDisplayState.shaderControls.restoreState(specification[SHADER_CONTROLS_JSON_KEY$1]);
  }
  getLegacyDataSourceSpecifications(sourceSpec, layerSpec, legacyTransform, explicitSpecs) {
    if (Object.prototype.hasOwnProperty.call(layerSpec, "source")) {
      return super.getLegacyDataSourceSpecifications(sourceSpec, layerSpec, legacyTransform, explicitSpecs);
    }
    const scales = verifyOptionalObjectProperty(layerSpec, "voxelSize", (voxelSizeObj) => parseFixedLengthArray(new Float64Array(3), voxelSizeObj, (x) => verifyFinitePositiveFloat(x) / 1e9));
    const units = ["m", "m", "m"];
    if (scales !== void 0) {
      const inputSpace = makeCoordinateSpace({ rank: 3, units, scales, names: ["x", "y", "z"] });
      if (legacyTransform === void 0) {
        legacyTransform = {
          outputSpace: inputSpace,
          sourceRank: 3,
          transform: void 0,
          inputSpace
        };
      } else {
        legacyTransform = _Object$assign(_Object$assign({}, legacyTransform), { inputSpace });
      }
    }
    return [{
      url: localAnnotationsUrl,
      transform: legacyTransform,
      enableDefaultSubsources: true,
      subsources: new _Map()
    }];
  }
  activateDataSubsources(subsources) {
    var _a;
    let hasLocalAnnotations = false;
    let properties;
    for (const loadedSubsource of subsources) {
      const subsourceEntry = loadedSubsource.subsourceEntry;
      const local = subsourceEntry.subsource.local;
      const setProperties = (newProperties) => {
        if (properties !== void 0 && stableStringify(newProperties) !== stableStringify(properties)) {
          loadedSubsource.deactivate("Annotation properties are not compatible");
          return false;
        }
        properties = newProperties;
        return true;
      };
      if (local === LocalDataSource.annotations) {
        if (hasLocalAnnotations) {
          loadedSubsource.deactivate("Only one local annotations source per layer is supported");
          continue;
        }
        hasLocalAnnotations = true;
        if (!setProperties((_a = this.localAnnotationProperties) !== null && _a !== void 0 ? _a : [])) continue;
        loadedSubsource.activate((refCounted) => {
          var _a2;
          const localAnnotations = this.localAnnotations = new LocalAnnotationSource(loadedSubsource.loadedDataSource.transform, (_a2 = this.localAnnotationProperties) !== null && _a2 !== void 0 ? _a2 : [], this.localAnnotationRelationships);
          try {
            localAnnotations.restoreState(this.localAnnotationsJson);
          } catch (_b) {
          }
          refCounted.registerDisposer(() => {
            localAnnotations.dispose();
            this.localAnnotations = void 0;
          });
          refCounted.registerDisposer(this.localAnnotations.changed.add(this.specificationChanged.dispatch));
          try {
            addPointAnnotations(this.localAnnotations, this.pointAnnotationsJson);
          } catch (_c) {
          }
          this.pointAnnotationsJson = void 0;
          this.localAnnotationsJson = void 0;
          const state = new AnnotationLayerState({
            localPosition: this.localPosition,
            transform: refCounted.registerDisposer(getWatchableRenderLayerTransform(this.manager.root.coordinateSpace, this.localPosition.coordinateSpace, loadedSubsource.loadedDataSource.transform, void 0)),
            source: localAnnotations.addRef(),
            displayState: this.annotationDisplayState,
            dataSource: loadedSubsource.loadedDataSource.layerDataSource,
            subsourceIndex: loadedSubsource.subsourceIndex,
            subsourceId: subsourceEntry.id,
            role: RenderLayerRole.ANNOTATION
          });
          this.addAnnotationLayerState(state, loadedSubsource);
        });
        continue;
      }
      const annotation = subsourceEntry.subsource.annotation;
      if (annotation !== void 0) {
        if (!setProperties(annotation.properties)) continue;
        loadedSubsource.activate(() => {
          const state = new AnnotationLayerState({
            localPosition: this.localPosition,
            transform: loadedSubsource.getRenderLayerTransform(),
            source: annotation,
            displayState: this.annotationDisplayState,
            dataSource: loadedSubsource.loadedDataSource.layerDataSource,
            subsourceIndex: loadedSubsource.subsourceIndex,
            subsourceId: subsourceEntry.id,
            role: RenderLayerRole.ANNOTATION
          });
          this.addAnnotationLayerState(state, loadedSubsource);
        });
        continue;
      }
      loadedSubsource.deactivate("Not compatible with annotation layer");
    }
    const prevAnnotationProperties = this.annotationProperties.value;
    if (stableStringify(prevAnnotationProperties) !== stableStringify(properties)) {
      this.annotationProperties.value = properties;
    }
  }
  initializeAnnotationLayerViewTab(tab) {
    const hasChunkedSource = tab.registerDisposer(makeCachedLazyDerivedWatchableValue((states) => states.some((x) => x.source instanceof MultiscaleAnnotationSource), this.annotationStates));
    const renderScaleControls = tab.registerDisposer(new DependentViewWidget(hasChunkedSource, (hasChunkedSource2, parent, refCounted) => {
      if (!hasChunkedSource2) return;
      {
        const renderScaleWidget = refCounted.registerDisposer(new RenderScaleWidget(this.annotationCrossSectionRenderScaleHistogram, this.annotationCrossSectionRenderScaleTarget));
        renderScaleWidget.label.textContent = "Spacing (cross section)";
        parent.appendChild(renderScaleWidget.element);
      }
      {
        const renderScaleWidget = refCounted.registerDisposer(new RenderScaleWidget(this.annotationProjectionRenderScaleHistogram, this.annotationProjectionRenderScaleTarget));
        renderScaleWidget.label.textContent = "Spacing (projection)";
        parent.appendChild(renderScaleWidget.element);
      }
    }));
    tab.element.insertBefore(renderScaleControls.element, tab.element.firstChild);
    {
      const checkbox = tab.registerDisposer(new TrackableBooleanCheckbox(this.annotationDisplayState.ignoreNullSegmentFilter));
      const label = document.createElement("label");
      label.appendChild(document.createTextNode("Ignore null related segment filter"));
      label.title = "Display all annotations if filtering by related segments is enabled but no segments are selected";
      label.appendChild(checkbox.element);
      tab.element.appendChild(label);
    }
    tab.element.appendChild(tab.registerDisposer(new LinkedSegmentationLayersWidget(this.linkedSegmentationLayers)).element);
  }
  toJSON() {
    const x = super.toJSON();
    x[CROSS_SECTION_RENDER_SCALE_JSON_KEY$1] = this.annotationCrossSectionRenderScaleTarget.toJSON();
    x[PROJECTION_RENDER_SCALE_JSON_KEY] = this.annotationProjectionRenderScaleTarget.toJSON();
    if (this.localAnnotations !== void 0) {
      x[ANNOTATIONS_JSON_KEY] = this.localAnnotations.toJSON();
    } else if (this.localAnnotationsJson !== void 0) {
      x[ANNOTATIONS_JSON_KEY] = this.localAnnotationsJson;
    }
    x[ANNOTATION_PROPERTIES_JSON_KEY] = annotationPropertySpecsToJson(this.localAnnotationProperties);
    const localAnnotationRelationships = this.localAnnotationRelationships;
    x[ANNOTATION_RELATIONSHIPS_JSON_KEY] = localAnnotationRelationships && localAnnotationRelationships.length === 1 && localAnnotationRelationships[0] === "segments" ? void 0 : localAnnotationRelationships;
    x[IGNORE_NULL_SEGMENT_FILTER_JSON_KEY] = this.annotationDisplayState.ignoreNullSegmentFilter.toJSON();
    x[SHADER_JSON_KEY$1] = this.annotationDisplayState.shader.toJSON();
    x[SHADER_CONTROLS_JSON_KEY$1] = this.annotationDisplayState.shaderControls.toJSON();
    _Object$assign(x, this.linkedSegmentationLayers.toJSON());
    return x;
  }
}
AnnotationUserLayer.type = "annotation";
AnnotationUserLayer.typeAbbreviation = "ann";
function makeShaderCodeWidget$1(layer) {
  return new ShaderCodeWidget({
    shaderError: layer.annotationDisplayState.shaderError,
    fragmentMain: layer.annotationDisplayState.shader,
    shaderControlState: layer.annotationDisplayState.shaderControls
  });
}
let ShaderCodeOverlay$1 = class ShaderCodeOverlay2 extends Overlay {
  constructor(layer) {
    super();
    this.layer = layer;
    this.codeWidget = this.registerDisposer(makeShaderCodeWidget$1(this.layer));
    this.content.appendChild(this.codeWidget.element);
    this.codeWidget.textEditor.refresh();
  }
};
let RenderingOptionsTab$1 = class RenderingOptionsTab extends Tab {
  constructor(layer) {
    super();
    this.layer = layer;
    this.codeWidget = this.registerDisposer(makeShaderCodeWidget$1(this.layer));
    const element = this.element;
    element.classList.add("neuroglancer-annotation-rendering-tab");
    element.appendChild(this.registerDisposer(new DependentViewWidget(layer.annotationProperties, (properties, parent) => {
      if (properties === void 0 || properties.length === 0) return;
      const propertyList = document.createElement("div");
      parent.appendChild(propertyList);
      propertyList.classList.add("neuroglancer-annotation-shader-property-list");
      for (const property of properties) {
        const div = document.createElement("div");
        div.classList.add("neuroglancer-annotation-shader-property");
        const typeElement = document.createElement("span");
        typeElement.classList.add("neuroglancer-annotation-shader-property-type");
        typeElement.textContent = property.type;
        const nameElement = document.createElement("span");
        nameElement.classList.add("neuroglancer-annotation-shader-property-identifier");
        nameElement.textContent = `prop_${property.identifier}`;
        div.appendChild(typeElement);
        div.appendChild(nameElement);
        const description = property.description;
        if (description !== void 0) {
          div.title = description;
        }
        propertyList.appendChild(div);
      }
    })).element);
    let topRow = document.createElement("div");
    topRow.className = "neuroglancer-segmentation-dropdown-skeleton-shader-header";
    let label = document.createElement("div");
    label.style.flex = "1";
    label.textContent = "Annotation shader:";
    topRow.appendChild(label);
    topRow.appendChild(makeMaximizeButton({
      title: "Show larger editor view",
      onClick: () => {
        new ShaderCodeOverlay$1(this.layer);
      }
    }));
    topRow.appendChild(makeHelpButton({
      title: "Documentation on annotation rendering",
      href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/annotation/rendering.md"
    }));
    element.appendChild(topRow);
    element.appendChild(this.codeWidget.element);
    element.appendChild(this.registerDisposer(new ShaderControls(layer.annotationDisplayState.shaderControls, this.layer.manager.root.display, this.layer, { visibility: this.visibility })).element);
  }
};
registerLayerType(AnnotationUserLayer);
registerLayerType(AnnotationUserLayer, "pointAnnotation");
registerLayerTypeDetector((subsource) => {
  if (subsource.local === LocalDataSource.annotations) {
    return { layerConstructor: AnnotationUserLayer, priority: 100 };
  }
  if (subsource.annotation !== void 0) {
    return { layerConstructor: AnnotationUserLayer, priority: 1 };
  }
  return void 0;
});
registerLayerShaderControlsTool(AnnotationUserLayer, (layer) => ({
  shaderControlState: layer.annotationDisplayState.shaderControls
}));
const user_layer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AnnotationUserLayer
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(user_layer);
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(frontend);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(segmentation_user_layer);
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(color);
function bindDefaultCopyHandler(viewer) {
  viewer.registerEventListener(document, "copy", (event) => {
    if (isInputTextTarget(event.target)) {
      return;
    }
    const selection = document.getSelection();
    if (selection !== null && selection.type === "Range") return;
    const stateJson = getCachedJson(viewer.state).value;
    const clipboardData = event.clipboardData;
    if (clipboardData !== null) {
      clipboardData.setData("text/plain", _JSON$stringify(stateJson, void 0, "  "));
    }
    event.preventDefault();
  });
}
function parsePositionString(s, rank) {
  let pattern = _String$raw`^[\[\]{}()\s,]*`;
  for (let i = 0; i < rank; ++i) {
    if (i !== 0) {
      pattern += _String$raw`[,\s]+`;
    }
    pattern += _String$raw`(\d+(?:\.\d+)?)`;
  }
  pattern += _String$raw`[\[\]{}()\s,]*$`;
  const match = s.match(pattern);
  if (match === null) return void 0;
  const result = new Float32Array(rank);
  for (let i = 0; i < rank; ++i) {
    const n = Number(match[i + 1]);
    if (!_Number$isFinite(n)) return void 0;
    result[i] = n;
  }
  return result;
}
function bindDefaultPasteHandler(viewer) {
  viewer.registerEventListener(document, "paste", (event) => {
    if (isInputTextTarget(event.target)) {
      return;
    }
    const clipboardData = event.clipboardData;
    if (clipboardData !== null) {
      const data = clipboardData.getData("text/plain");
      const parsedPosition = parsePositionString(data, viewer.coordinateSpace.value.rank);
      if (parsedPosition !== void 0) {
        viewer.navigationState.position.value = parsedPosition;
      }
    }
    event.preventDefault();
  });
}
const textureUnitSymbol = _Symbol("SingleTextureVolumeChunk.textureUnit");
const textureLayoutSymbol = _Symbol("SingleTextureVolumeChunk.textureLayout");
class SingleTextureChunkFormat extends RefCounted {
  constructor(shaderKey, dataType) {
    super();
    this.shaderKey = shaderKey;
    this.dataType = dataType;
  }
  defineShader(builder, numChannelDimensions) {
    builder.addTextureSampler(this.shaderSamplerType, "uVolumeChunkSampler", textureUnitSymbol);
  }
  beginDrawing(gl, shader) {
    let textureUnit = shader.textureUnit(textureUnitSymbol);
    gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + textureUnit);
    shader[textureLayoutSymbol] = null;
  }
  endDrawing(gl, shader) {
    gl.bindTexture(textureTargetForSamplerType[this.shaderSamplerType], null);
    shader[textureLayoutSymbol] = null;
  }
  bindChunk(gl, shader, chunk, fixedChunkPosition, chunkDisplaySubspaceDimensions, channelDimensions, newSource) {
    let textureLayout = chunk.textureLayout;
    let existingTextureLayout = shader[textureLayoutSymbol];
    if (existingTextureLayout !== textureLayout || newSource) {
      shader[textureLayoutSymbol] = textureLayout;
      this.setupTextureLayout(gl, shader, textureLayout, fixedChunkPosition, chunkDisplaySubspaceDimensions, channelDimensions);
    }
    gl.bindTexture(textureTargetForSamplerType[this.shaderSamplerType], chunk.texture);
  }
  /**
   * Does nothing, but may be overridden by subclass.
   */
  beginSource(_gl, _shader) {
  }
}
class SingleTextureVolumeChunk extends VolumeChunk {
  constructor(source, x) {
    super(source, x);
    this.texture = null;
    this.data = x["data"];
  }
  copyToGPU(gl) {
    super.copyToGPU(gl);
    let texture = this.texture = gl.createTexture();
    const textureTarget = textureTargetForSamplerType[this.chunkFormat.shaderSamplerType];
    gl.bindTexture(textureTarget, texture);
    this.setTextureData(gl);
    gl.bindTexture(textureTarget, null);
  }
  freeGPUMemory(gl) {
    super.freeGPUMemory(gl);
    gl.deleteTexture(this.texture);
    this.texture = null;
    this.textureLayout.dispose();
    this.textureLayout = null;
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let TextureLayout$1 = class TextureLayout extends RefCounted {
  constructor(gl, chunkDataSize, textureDims) {
    super();
    this.chunkDataSize = chunkDataSize;
    this.textureDims = textureDims;
    this.textureShape = new Uint32Array(this.textureDims);
    const rank = chunkDataSize.length;
    let numRemainingDims = 0;
    for (const size of chunkDataSize) {
      if (size !== 1) ++numRemainingDims;
    }
    const strides = this.strides = new Uint32Array(rank * textureDims);
    const maxTextureSize = textureDims === 3 ? gl.max3dTextureSize : gl.maxTextureSize;
    let textureDim = 0;
    let textureDimSize = 1;
    const textureShape = this.textureShape;
    textureShape.fill(1);
    for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
      const size = chunkDataSize[chunkDim];
      if (size === 1) continue;
      const newSize = size * textureDimSize;
      let stride;
      if (newSize > maxTextureSize || textureDimSize !== 1 && textureDim + numRemainingDims < textureDims) {
        ++textureDim;
        textureDimSize = size;
        stride = 1;
      } else {
        stride = textureDimSize;
        textureDimSize = newSize;
      }
      strides[textureDims * chunkDim + textureDim] = stride;
      textureShape[textureDim] = textureDimSize;
    }
  }
  static get(gl, chunkSizeInVoxels, textureDims) {
    return gl.memoize.get(`sliceview.UncompressedTextureLayout:${chunkSizeInVoxels.join()}:${textureDims}`, () => new TextureLayout(gl, chunkSizeInVoxels, textureDims));
  }
};
let tempStridesUniform$1 = new Uint32Array(3 * 5);
let ChunkFormat$1 = class ChunkFormat extends SingleTextureChunkFormat {
  constructor(_gl, dataType, key, textureDims) {
    super(key, dataType);
    this.textureDims = textureDims;
    computeTextureFormat(this, dataType);
    this.shaderSamplerType = `${this.samplerPrefix}sampler${textureDims}D`;
    this.textureAccessHelper = new TextureAccessHelper("chunkData", textureDims);
  }
  static get(gl, dataType, textureDims) {
    const key = `sliceview.UncompressedChunkFormat:${dataType}:${textureDims}`;
    return gl.memoize.get(key, () => new ChunkFormat(gl, dataType, key, textureDims));
  }
  defineShader(builder, numChannelDimensions) {
    super.defineShader(builder, numChannelDimensions);
    const textureDims = this.textureDims;
    const textureVecType = `ivec${this.textureDims}`;
    let textureAccessHelper = this.textureAccessHelper;
    const stridesUniformLength = (4 + numChannelDimensions) * textureDims;
    if (tempStridesUniform$1.length < stridesUniformLength) {
      tempStridesUniform$1 = new Uint32Array(stridesUniformLength);
    }
    builder.addUniform(`highp ${textureVecType}`, "uVolumeChunkStrides", 4 + numChannelDimensions);
    builder.addFragmentCode(textureAccessHelper.getAccessor("readVolumeData", "uVolumeChunkSampler", this.dataType));
    const shaderType = getShaderType(this.dataType);
    let code = `
${shaderType} getDataValueAt(highp ivec3 p`;
    for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
      code += `, highp int channelIndex${channelDim}`;
    }
    code += `) {
  highp ${textureVecType} offset = uVolumeChunkStrides[0]
                     + p.x * uVolumeChunkStrides[1]
                     + p.y * uVolumeChunkStrides[2]
                     + p.z * uVolumeChunkStrides[3];
`;
    for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
      code += `
  offset += channelIndex${channelDim} * uVolumeChunkStrides[${4 + channelDim}];
`;
    }
    code += `
  return readVolumeData(offset);
}
`;
    builder.addFragmentCode(code);
  }
  /**
   * Called each time textureLayout changes while drawing chunks.
   */
  setupTextureLayout(gl, shader, textureLayout, fixedChunkPosition, chunkDisplaySubspaceDimensions, channelDimensions) {
    const stridesUniform = tempStridesUniform$1;
    const numChannelDimensions = channelDimensions.length;
    const strides = textureLayout.strides;
    const rank = fixedChunkPosition.length;
    const textureDims = this.textureDims;
    for (let i = 0; i < textureDims; ++i) {
      let sum = 0;
      for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
        sum += fixedChunkPosition[chunkDim] * strides[chunkDim * textureDims + i];
      }
      stridesUniform[i] = sum;
    }
    for (let i = 0; i < 3; ++i) {
      const chunkDim = chunkDisplaySubspaceDimensions[i];
      if (chunkDim >= rank) continue;
      for (let j = 0; j < textureDims; ++j) {
        stridesUniform[(i + 1) * textureDims + j] = strides[chunkDim * textureDims + j];
      }
    }
    for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
      const chunkDim = channelDimensions[channelDim];
      if (chunkDim === -1) {
        stridesUniform.fill(0, (4 + channelDim) * textureDims, (4 + channelDim + 1) * textureDims);
      } else {
        for (let i = 0; i < textureDims; ++i) {
          stridesUniform[(4 + channelDim) * textureDims + i] = strides[chunkDim * textureDims + i];
        }
      }
    }
    const uniformDataSize = (4 + numChannelDimensions) * textureDims;
    if (textureDims === 3) {
      gl.uniform3iv(shader.uniform("uVolumeChunkStrides"), stridesUniform, 0, uniformDataSize);
    } else {
      gl.uniform2iv(shader.uniform("uVolumeChunkStrides"), stridesUniform, 0, uniformDataSize);
    }
  }
  getTextureLayout(gl, chunkDataSize) {
    return TextureLayout$1.get(gl, chunkDataSize, this.textureDims);
  }
  setTextureData(gl, textureLayout, data) {
    const textureShape = textureLayout.textureShape;
    (this.textureDims === 3 ? setThreeDimensionalTextureData : setTwoDimensionalTextureData)(gl, this, data, textureShape[0], textureShape[1], textureShape[2]);
  }
};
class UncompressedVolumeChunk extends SingleTextureVolumeChunk {
  setTextureData(gl) {
    let source = this.source;
    let chunkFormatHandler = source.chunkFormatHandler;
    let chunkFormat = chunkFormatHandler.chunkFormat;
    let textureLayout;
    if (this.chunkDataSize === source.spec.chunkDataSize) {
      this.textureLayout = textureLayout = chunkFormatHandler.textureLayout.addRef();
    } else {
      this.textureLayout = textureLayout = chunkFormat.getTextureLayout(gl, this.chunkDataSize);
    }
    this.chunkFormat.setTextureData(gl, textureLayout, this.data);
  }
  getValueAt(dataPosition) {
    let chunkFormat = this.chunkFormat;
    const chunkDataSize = this.chunkDataSize;
    let index2 = 0;
    let stride = 1;
    const rank = dataPosition.length;
    for (let i = 0; i < rank; ++i) {
      index2 += stride * dataPosition[i];
      stride *= chunkDataSize[i];
    }
    let dataType = chunkFormat.dataType;
    let data = this.data;
    switch (dataType) {
      case DataType.UINT8:
      case DataType.INT8:
      case DataType.FLOAT32:
      case DataType.UINT16:
      case DataType.INT16:
      case DataType.UINT32:
      case DataType.INT32:
        return data[index2];
      case DataType.UINT64: {
        let index22 = index2 * 2;
        return new Uint64(data[index22], data[index22 + 1]);
      }
    }
  }
}
class UncompressedChunkFormatHandler extends RefCounted {
  constructor(gl, spec) {
    super();
    let numDims = 0;
    for (const x of spec.chunkDataSize) {
      if (x > 1) ++numDims;
    }
    this.chunkFormat = this.registerDisposer(ChunkFormat$1.get(gl, spec.dataType, numDims >= 3 ? 3 : 2));
    this.textureLayout = this.registerDisposer(this.chunkFormat.getTextureLayout(gl, spec.chunkDataSize));
  }
  getChunk(source, x) {
    return new UncompressedVolumeChunk(source, x);
  }
}
registerChunkFormatHandler((gl, spec) => {
  if (spec.compressedSegmentationBlockSize == null) {
    return new UncompressedChunkFormatHandler(gl, spec);
  }
  return null;
});
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function decodeValueOffset(data, baseOffset, chunkDataSize, blockSize, dataPosition, uint32sPerElement) {
  let gridOffset = 0, subchunkOffset = 0, gridStride = 1, subchunkStride = 1;
  for (let i = 0; i < 3; ++i) {
    let posValue = dataPosition[i];
    let subchunkSizeValue = blockSize[i];
    let gridSubscript = Math.floor(posValue / subchunkSizeValue);
    let subchunkSubscript = posValue % subchunkSizeValue;
    gridOffset += gridSubscript * gridStride;
    gridStride *= Math.ceil(chunkDataSize[i] / subchunkSizeValue);
    subchunkOffset += subchunkSubscript * subchunkStride;
    subchunkStride *= subchunkSizeValue;
  }
  let subchunkHeaderOffset = baseOffset + gridOffset * 2;
  let subchunkHeader0 = data[subchunkHeaderOffset];
  let subchunkHeader1 = data[subchunkHeaderOffset + 1];
  let outputValueOffset = subchunkHeader0 & 16777215;
  let encodingBits = subchunkHeader0 >> 24 & 255;
  if (encodingBits > 0) {
    let encodedValueBaseOffset = baseOffset + subchunkHeader1 & 16777215;
    let encodedValueOffset = encodedValueBaseOffset + Math.floor(subchunkOffset * encodingBits / 32);
    let encodedValue = data[encodedValueOffset];
    let wordOffset = subchunkOffset * encodingBits % 32;
    let decodedValue = encodedValue >> wordOffset & (1 << encodingBits) - 1;
    outputValueOffset += uint32sPerElement * decodedValue;
  }
  return outputValueOffset;
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function readSingleChannelValue$1(data, baseOffset, chunkDataSize, blockSize, dataPosition) {
  let outputValueOffset = decodeValueOffset(data, baseOffset, chunkDataSize, blockSize, dataPosition, 1) + baseOffset;
  return data[outputValueOffset];
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function readSingleChannelValue(out, data, baseOffset, chunkDataSize, blockSize, dataPosition) {
  let outputValueOffset = decodeValueOffset(data, baseOffset, chunkDataSize, blockSize, dataPosition, 2) + baseOffset;
  out.low = data[outputValueOffset];
  out.high = data[outputValueOffset + 1];
  return out;
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TextureLayout2 extends RefCounted {
  constructor(chunkDataSize, subchunkSize) {
    super();
    this.chunkDataSize = chunkDataSize;
    this.subchunkSize = subchunkSize;
    const subchunkGridSize = this.subchunkGridSize = create$3();
    for (let i = 0; i < 3; ++i) {
      subchunkGridSize[i] = Math.ceil(chunkDataSize[i] / subchunkSize[i]);
    }
  }
  static get(gl, chunkDataSize, subchunkSize) {
    return gl.memoize.get(`sliceview.CompressedSegmentationTextureLayout:${vec3Key(chunkDataSize)},${vec3Key(subchunkSize)}`, () => new TextureLayout2(chunkDataSize, subchunkSize));
  }
}
const textureFormat = computeTextureFormat(new TextureFormat(), DataType.UINT32);
let tempStridesUniform = new Uint32Array(4 * 4);
class ChunkFormat2 extends SingleTextureChunkFormat {
  constructor(dataType, subchunkSize, numChannels, key) {
    super(key, dataType);
    this.subchunkSize = subchunkSize;
    this.numChannels = numChannels;
    this.textureAccessHelper = new OneDimensionalTextureAccessHelper("chunkData");
  }
  // numChannels is the number of channels in the compressed segmentation format, which is
  // independent of the channel dimensions presented to the user.
  static get(gl, dataType, subchunkSize, numChannels) {
    let shaderKey = `sliceview.CompressedSegmentationChunkFormat:${dataType}:${numChannels}`;
    let cacheKey = `${shaderKey}:${vec3Key(subchunkSize)}`;
    return gl.memoize.get(cacheKey, () => new ChunkFormat2(dataType, subchunkSize, numChannels, shaderKey));
  }
  get shaderSamplerType() {
    return "usampler2D";
  }
  defineShader(builder, numChannelDimensions) {
    super.defineShader(builder, numChannelDimensions);
    const stridesLength = 4 * (4 + numChannelDimensions);
    if (tempStridesUniform.length < stridesLength) {
      tempStridesUniform = new Uint32Array(stridesLength);
    }
    let textureAccessHelper = this.textureAccessHelper;
    textureAccessHelper.defineShader(builder);
    let local = (x) => "compressedSegmentationChunkFormat_" + x;
    builder.addUniform("highp ivec3", "uSubchunkGridSize");
    builder.addUniform("highp ivec3", "uSubchunkSize");
    builder.addUniform("highp ivec4", "uVolumeChunkStrides", 4 + numChannelDimensions);
    builder.addFragmentCode(glsl_getFortranOrderIndex);
    const dataType = this.dataType;
    const glslType = getShaderType(dataType);
    if (dataType === DataType.UINT64) {
      builder.addFragmentCode(glsl_uint64);
    } else {
      builder.addFragmentCode(glsl_uint32);
    }
    builder.addFragmentCode(textureAccessHelper.getAccessor(local("readTextureValue"), "uVolumeChunkSampler", DataType.UINT32, 1));
    let fragmentCode = `
uint ${local("getChannelOffset")}(int channelIndex) {
  if (channelIndex == 0) {
    return ${this.numChannels}u;
  }
  return ${local("readTextureValue")}(uint(channelIndex)).value;
}
${glslType} getDataValueAt(highp ivec3 p`;
    for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
      fragmentCode += `, highp int channelIndex${channelDim}`;
    }
    fragmentCode += `) {
  highp ivec4 chunkPositionFull = uVolumeChunkStrides[0] +
                     + p.x * uVolumeChunkStrides[1]
                     + p.y * uVolumeChunkStrides[2]
                     + p.z * uVolumeChunkStrides[3];
`;
    for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
      fragmentCode += `
  chunkPositionFull += channelIndex${channelDim} * uVolumeChunkStrides[${4 + channelDim}];
`;
    }
    fragmentCode += `
  highp ivec3 chunkPosition = chunkPositionFull.xyz;

  // TODO: maybe premultiply this and store as uniform.
  ivec3 subchunkGridPosition = chunkPosition / uSubchunkSize;
  int subchunkGridOffset = getFortranOrderIndex(subchunkGridPosition, uSubchunkGridSize);

  int channelOffset = int(${local("getChannelOffset")}(chunkPositionFull[3]));

  // TODO: Maybe just combine this offset into subchunkGridStrides.
  int subchunkHeaderOffset = subchunkGridOffset * 2 + channelOffset;

  highp uint subchunkHeader0 = ${local("readTextureValue")}(uint(subchunkHeaderOffset)).value;
  highp uint subchunkHeader1 = ${local("readTextureValue")}(uint(subchunkHeaderOffset + 1)).value;
  highp uint outputValueOffset = (subchunkHeader0 & 0xFFFFFFu) + uint(channelOffset);
  highp uint encodingBits = subchunkHeader0 >> 24u;
  if (encodingBits > 0u) {
    ivec3 subchunkPosition = chunkPosition - subchunkGridPosition * uSubchunkSize;
    int subchunkOffset = getFortranOrderIndex(subchunkPosition, uSubchunkSize);
    uint encodedValueBaseOffset = subchunkHeader1 + uint(channelOffset);
    uint encodedValueOffset = encodedValueBaseOffset + uint(subchunkOffset) * encodingBits / 32u;
    uint encodedValue = ${local("readTextureValue")}(encodedValueOffset).value;
    uint wordOffset = uint(subchunkOffset) * encodingBits % 32u;
    uint encodedValueShifted = encodedValue >> wordOffset;
    uint decodedValue = encodedValueShifted - (encodedValueShifted >> encodingBits << encodingBits);
    outputValueOffset += decodedValue * ${this.dataType === DataType.UINT64 ? "2u" : "1u"};
  }
  ${glslType} result;
`;
    if (dataType === DataType.UINT64) {
      fragmentCode += `
  result.value[0] = ${local("readTextureValue")}(outputValueOffset).value;
  result.value[1] = ${local("readTextureValue")}(outputValueOffset+1u).value;
`;
    } else {
      fragmentCode += `
  result.value = ${local("readTextureValue")}(outputValueOffset).value;
`;
    }
    fragmentCode += `
  return result;
}
`;
    builder.addFragmentCode(fragmentCode);
  }
  /**
   * Called each time textureLayout changes while drawing chunks.
   *
   * @param channelDimensions The user-specified channel dimensions, independent of the compressed
   * segmentation channels.
   */
  setupTextureLayout(gl, shader, textureLayout, fixedChunkPosition, chunkDisplaySubspaceDimensions, channelDimensions) {
    const subchunkGridSize = textureLayout.subchunkGridSize;
    gl.uniform3i(shader.uniform("uSubchunkGridSize"), subchunkGridSize[0], subchunkGridSize[1], subchunkGridSize[2]);
    const stridesUniform = tempStridesUniform;
    const numChannelDimensions = channelDimensions.length;
    stridesUniform.fill(0);
    for (let i = 0; i < 3; ++i) {
      stridesUniform[i] = fixedChunkPosition[i];
      const chunkDim = chunkDisplaySubspaceDimensions[i];
      if (chunkDim === -1) continue;
      stridesUniform[4 * (i + 1) + chunkDim] = 1;
    }
    for (let channelDim = 0; channelDim < numChannelDimensions; ++channelDim) {
      const chunkDim = channelDimensions[channelDim];
      if (chunkDim === -1) continue;
      stridesUniform[4 * (4 + channelDim) + chunkDim] = 1;
    }
    gl.uniform4iv(shader.uniform("uVolumeChunkStrides"), stridesUniform, 0, (numChannelDimensions + 4) * 4);
  }
  setTextureData(gl, textureLayout, data) {
    setOneDimensionalTextureData(gl, textureFormat, data);
  }
  getTextureLayout(gl, chunkDataSize) {
    return TextureLayout2.get(gl, chunkDataSize, this.subchunkSize);
  }
  beginSource(gl, shader) {
    super.beginSource(gl, shader);
    const subchunkSize = this.subchunkSize;
    gl.uniform3i(shader.uniform("uSubchunkSize"), subchunkSize[0], subchunkSize[1], subchunkSize[2]);
  }
}
class CompressedSegmentationVolumeChunk extends SingleTextureVolumeChunk {
  setTextureData(gl) {
    let data = this.data;
    let chunkFormat = this.chunkFormat;
    let textureLayout = this.textureLayout = chunkFormat.getTextureLayout(gl, this.chunkDataSize);
    chunkFormat.setTextureData(gl, textureLayout, data);
  }
  getValueAt(dataPosition) {
    let chunkDataSize = this.chunkDataSize, chunkFormat = this.chunkFormat;
    let data = this.data;
    let offset = data[dataPosition[3] || 0];
    if (chunkFormat.dataType === DataType.UINT64) {
      let result = new Uint64();
      readSingleChannelValue(
        result,
        data,
        /*baseOffset=*/
        offset,
        chunkDataSize,
        chunkFormat.subchunkSize,
        dataPosition
      );
      return result;
    } else {
      return readSingleChannelValue$1(
        data,
        /*baseOffset=*/
        offset,
        chunkDataSize,
        chunkFormat.subchunkSize,
        dataPosition
      );
    }
  }
}
class CompressedSegmentationChunkFormatHandler extends RefCounted {
  constructor(gl, spec) {
    super();
    let dataType = spec.dataType;
    if (dataType !== DataType.UINT64 && dataType !== DataType.UINT32) {
      throw new Error(`Unsupported compressed segmentation data type: ${DataType[dataType]}`);
    }
    this.chunkFormat = this.registerDisposer(ChunkFormat2.get(gl, spec.dataType, spec.compressedSegmentationBlockSize, spec.chunkDataSize[3] || 1));
  }
  getChunk(source, x) {
    return new CompressedSegmentationVolumeChunk(source, x);
  }
}
registerChunkFormatHandler((gl, spec) => {
  if (spec.compressedSegmentationBlockSize != null) {
    return new CompressedSegmentationChunkFormatHandler(gl, spec);
  }
  return null;
});
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function makeMinimalViewer(options, target = document.getElementById("neuroglancer-container")) {
  try {
    let display = new DisplayContext(target);
    return new Viewer(display, options);
  } catch (error) {
    StatusMessage.showMessage(`Error: ${error.message}`);
    throw error;
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function disableContextMenu(target = document) {
  return registerEventListener(target, "contextmenu", (e) => {
    e.preventDefault();
  });
}
const credentialsKey$2 = "DVID";
function responseText$1(response) {
  return response.text();
}
function makeRequest$1(httpCall, cancellationToken = uncancelableToken) {
  const requestInfo = `${httpCall.url}`;
  const init = { method: httpCall.method, body: httpCall.payload };
  {
    return cancellableFetchOk(requestInfo, init, responseJson, cancellationToken);
  }
}
function makeRequestWithCredentials$1(credentialsProvider, httpCall, cancellationToken = uncancelableToken) {
  return fetchWithDVIDCredentials(credentialsProvider, httpCall.url, { method: httpCall.method, body: httpCall.payload }, responseJson, cancellationToken);
}
function fetchWithDVIDCredentials(credentialsProvider, input, init, transformResponse, cancellationToken = uncancelableToken) {
  return fetchWithCredentials(credentialsProvider, input, init, transformResponse, (credentials, init2) => {
    const newInit = _Object$assign({}, init2);
    if (credentials.token) {
      newInit.headers = _Object$assign(_Object$assign({}, newInit.headers), { Authorization: `Bearer ${credentials}` });
    }
    return newInit;
  }, (error) => {
    const status = error.status;
    if (status === 504) {
      return "retry";
    }
    throw error;
  }, cancellationToken);
}
async function getAuthToken(authServer, cancellationToken = uncancelableToken) {
  const token = await cancellableFetchOk(authServer, { "method": "GET", credentials: "include" }, responseText$1, cancellationToken);
  return { token };
}
class BaseDVIDCredentialsProvider extends CredentialsProvider {
  constructor(authServer) {
    super();
    this.authServer = authServer;
    this.get = makeCredentialsGetter((cancellationToken) => {
      if (!this.authServer) return _Promise.resolve({ token: "" });
      const status = new StatusMessage(
        /*delay=*/
        true
      );
      let cancellationSource;
      return new _Promise((resolve, reject) => {
        const dispose = () => {
          cancellationSource = void 0;
          status.dispose();
        };
        cancellationToken.add(() => {
          if (cancellationSource !== void 0) {
            cancellationSource.cancel();
            cancellationSource = void 0;
            status.dispose();
            reject(CANCELED);
          }
        });
        function writeAuthStatus(authServer2, msg = "DVID authorization required.", linkMessage = "Request authorization.") {
          status.setText(msg + " ");
          let button = document.createElement("button");
          button.textContent = linkMessage;
          status.element.appendChild(button);
          button.addEventListener("click", () => {
            let match = authServer2.match(/^[^\/]+\/\/[^\/\.]+\.([^\/]+)/);
            if (match) {
              const loginServer = `https://flyemlogin.${match[1]}/login`;
              window.alert(`Please log into ${loginServer} and then refresh the neurogalncer page to try again.
If you are unable to log into ${loginServer}, please check your authorization server ${authServer2} to make sure it is correct.`);
            } else {
              window.alert(`Please check your authorization server ${authServer2} to make sure it is correct.`);
            }
          });
          status.setVisible(true);
        }
        function requestAuth(authServer2) {
          if (cancellationSource !== void 0) {
            cancellationSource.cancel();
          }
          cancellationSource = new CancellationTokenSource();
          writeAuthStatus(authServer2, "Waiting for DVID authorization...", "Retry");
          getAuthToken(authServer2, cancellationSource).then((token) => {
            if (cancellationSource !== void 0) {
              dispose();
              resolve(token);
            }
          }, (reason) => {
            if (cancellationSource !== void 0) {
              cancellationSource = void 0;
              writeAuthStatus(authServer2, `DVID authorization failed: ${reason}.`, "Retry");
            }
          });
        }
        requestAuth(this.authServer);
      });
    });
  }
}
class DVIDCredentialsProvider extends AnonymousFirstCredentialsProvider {
  constructor(_dvidServer, authServer) {
    super(new BaseDVIDCredentialsProvider(authServer), {});
  }
}
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
defaultCredentialsManager.register(credentialsKey$2, (params) => new DVIDCredentialsProvider(params.dvidServer, params.authServer));
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CREDENTIALS_PROVIDER_RPC_ID = "CredentialsProvider";
const CREDENTIALS_PROVIDER_GET_RPC_ID = "CredentialsProvider.get";
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Object$getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && _Object$defineProperty(target, key, r), r;
};
let SharedCredentialsProvider = class SharedCredentialsProvider2 extends SharedObject {
  constructor(provider, rpc) {
    super();
    this.provider = provider;
    this.registerDisposer(provider);
    this.initializeCounterpart(rpc);
  }
  get(invalidCredentials, cancellationToken) {
    return this.provider.get(invalidCredentials, cancellationToken);
  }
};
SharedCredentialsProvider = __decorate([registerSharedObjectOwner(CREDENTIALS_PROVIDER_RPC_ID)], SharedCredentialsProvider);
registerPromiseRPC(CREDENTIALS_PROVIDER_GET_RPC_ID, function(x, cancellationToken) {
  const obj = this.get(x.providerId);
  return obj.get(x.invalidCredentials, cancellationToken).then((credentials) => ({
    value: credentials
  }));
});
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getCredentialsProviderCounterpart(chunkManager, credentialsProvider) {
  if (credentialsProvider === void 0) return void 0;
  const sharedCredentialsProvider = chunkManager.memoize.get({ type: "getSharedCredentialsProvider", credentialsProvider: getObjectId(credentialsProvider) }, () => new SharedCredentialsProvider(credentialsProvider.addRef(), chunkManager.rpc));
  const counterpartRef = sharedCredentialsProvider.addCounterpartRef();
  sharedCredentialsProvider.dispose();
  return counterpartRef;
}
function WithCredentialsProvider() {
  return function(Base2) {
    class C extends Base2 {
      constructor(...args) {
        var _a;
        super(...args);
        const options = args[1];
        this.credentialsProvider = (_a = options.credentialsProvider) === null || _a === void 0 ? void 0 : _a.addRef();
      }
      initializeCounterpart(rpc, options) {
        const credentialsProvider = this.credentialsProvider;
        options["credentialsProvider"] = getCredentialsProviderCounterpart(this.chunkManager, credentialsProvider);
        super.initializeCounterpart(rpc, options);
      }
      static encodeOptions(options) {
        const encoding = super.encodeOptions(options);
        const credentialsProvider = options.credentialsProvider;
        encoding.credentialsProvider = credentialsProvider === void 0 ? void 0 : getObjectId(credentialsProvider);
        return encoding;
      }
    }
    return C;
  };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const annotationChunkDataSize$1 = fromValues$1(128, 128, 128);
var VolumeChunkEncoding$3;
(function(VolumeChunkEncoding2) {
  VolumeChunkEncoding2[VolumeChunkEncoding2["JPEG"] = 0] = "JPEG";
  VolumeChunkEncoding2[VolumeChunkEncoding2["RAW"] = 1] = "RAW";
  VolumeChunkEncoding2[VolumeChunkEncoding2["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
  VolumeChunkEncoding2[VolumeChunkEncoding2["COMPRESSED_SEGMENTATIONARRAY"] = 3] = "COMPRESSED_SEGMENTATIONARRAY";
})(VolumeChunkEncoding$3 || (VolumeChunkEncoding$3 = {}));
class DVIDSourceParameters {
}
let VolumeChunkSourceParameters$3 = class VolumeChunkSourceParameters extends DVIDSourceParameters {
};
VolumeChunkSourceParameters$3.RPC_ID = "dvid/VolumeChunkSource";
let SkeletonSourceParameters$2 = class SkeletonSourceParameters extends DVIDSourceParameters {
};
SkeletonSourceParameters$2.RPC_ID = "dvid/SkeletonSource";
let MeshSourceParameters$2 = class MeshSourceParameters extends DVIDSourceParameters {
};
MeshSourceParameters$2.RPC_ID = "dvid/MeshSource";
let AnnotationSourceParametersBase$1 = class AnnotationSourceParametersBase extends DVIDSourceParameters {
  constructor() {
    super(...arguments);
    this.chunkDataSize = annotationChunkDataSize$1;
  }
};
let AnnotationSourceParameters$3 = class AnnotationSourceParameters extends AnnotationSourceParametersBase$1 {
};
AnnotationSourceParameters$3.RPC_ID = "dvid/AnnotationSource";
let AnnotationChunkSourceParameters$1 = class AnnotationChunkSourceParameters extends AnnotationSourceParametersBase$1 {
};
AnnotationChunkSourceParameters$1.RPC_ID = "dvid/AnnotationChunkSource";
let VolumeInfo$1 = class VolumeInfo {
  constructor(obj, format) {
    this.numLevels = 1;
    try {
      verifyObject(obj);
      if (format === "dvid") {
        let extended = verifyObjectProperty(obj, "Extended", verifyObject);
        if (extended.MaxDownresLevel) {
          let maxdownreslevel = verifyObjectProperty(extended, "MaxDownresLevel", verifyPositiveInt);
          this.numLevels = maxdownreslevel + 1;
        }
        this.voxelSize = verifyObjectProperty(extended, "VoxelSize", (x) => parseIntVec(create$3(), x));
        this.upperVoxelBound = verifyObjectProperty(extended, "MaxPoint", (x) => parseIntVec(create$3(), x.map((a) => {
          return ++a;
        })));
        this.lowerVoxelBound = verifyObjectProperty(extended, "MinPoint", (x) => parseIntVec(create$3(), x));
        this.blockSize = verifyObjectProperty(extended, "BlockSize", (x) => parseIntVec(create$3(), x));
      } else if (format === "gs") {
        verifyObject(obj);
        const scaleInfos = verifyObjectProperty(obj, "scales", (x) => x);
        if (scaleInfos.length === 0) throw new Error("Expected at least one scale");
        const baseScale = scaleInfos[0];
        this.voxelSize = verifyObjectProperty(baseScale, "resolution", (x) => parseFiniteVec(create$3(), x));
        this.lowerVoxelBound = verifyOptionalObjectProperty(baseScale, "offset", (x) => parseIntVec(create$3(), x)) || fromValues$1(0, 0, 0);
        const boxSize = verifyObjectProperty(baseScale, "size", (x) => parseIntVec(create$3(), x));
        this.upperVoxelBound = add$2(create$3(), boxSize, this.lowerVoxelBound);
        this.blockSize = fromValues$1(64, 64, 64);
      } else {
        throw new Error("unrecognized volume info");
      }
    } catch (parseError) {
      throw new Error(`Failed to parse volume geometry: ${parseError.message}`);
    }
  }
};
let MultiscaleVolumeInfo$1 = class MultiscaleVolumeInfo {
  constructor(baseVolumeInfo) {
    try {
      this.scales = [];
      this.scales.push(baseVolumeInfo);
      let lastVoxelSize = baseVolumeInfo.voxelSize;
      let lastLowerBounds = baseVolumeInfo.lowerVoxelBound;
      let lastUpperBounds = baseVolumeInfo.upperVoxelBound;
      for (let level = 1; level < baseVolumeInfo.numLevels; ++level) {
        let volumeInfo = _Object$assign({}, baseVolumeInfo);
        volumeInfo.voxelSize = multiply$2(create$3(), lastVoxelSize, fromValues$1(2, 2, 2));
        lastVoxelSize = volumeInfo.voxelSize;
        volumeInfo.upperVoxelBound = ceil(create$3(), divide(create$3(), lastUpperBounds, fromValues$1(2, 2, 2)));
        lastUpperBounds = volumeInfo.upperVoxelBound;
        volumeInfo.lowerVoxelBound = ceil(create$3(), divide(create$3(), lastLowerBounds, fromValues$1(2, 2, 2)));
        lastLowerBounds = volumeInfo.lowerVoxelBound;
        this.scales.push(volumeInfo);
      }
    } catch (parseError) {
      throw new Error(`Failed to parse multiscale volume specification: ${parseError.message}`);
    }
  }
  get numChannels() {
    if (this.scales.length === 0) {
      return 0;
    }
    return this.scales[0].numChannels;
  }
};
let serverDataTypes = new _Map();
serverDataTypes.set("uint8", DataType.UINT8);
serverDataTypes.set("uint32", DataType.UINT32);
serverDataTypes.set("uint64", DataType.UINT64);
class DataInstanceBaseInfo {
  constructor(obj) {
    this.obj = obj;
    verifyObject(obj);
    verifyObjectProperty(obj, "TypeName", verifyString);
  }
  get typeName() {
    return this.obj["TypeName"];
  }
  get compressionName() {
    return this.obj["Compression"];
  }
  get tags() {
    return this.obj["Tags"];
  }
}
class DataInstanceInfo {
  constructor(obj, name2, base) {
    this.name = name2;
    this.base = base;
    this.volumeInfo = new VolumeInfo$1(getVolumeInfoResponseFromTags(base.tags, obj), "dvid");
  }
  get lowerVoxelBound() {
    return this.volumeInfo.lowerVoxelBound;
  }
  get upperVoxelBound() {
    return this.volumeInfo.upperVoxelBound;
  }
  get blockSize() {
    return this.volumeInfo.blockSize;
  }
  get voxelSize() {
    return this.volumeInfo.voxelSize;
  }
  get numLevels() {
    return this.volumeInfo.numLevels;
  }
}
class DVIDVolumeChunkSource extends WithParameters(WithCredentialsProvider()(VolumeChunkSource), VolumeChunkSourceParameters$3) {
}
class DVIDSkeletonSource extends WithParameters(WithCredentialsProvider()(SkeletonSource), SkeletonSourceParameters$2) {
}
class DVIDMeshSource extends WithParameters(WithCredentialsProvider()(MeshSource), MeshSourceParameters$2) {
}
class VolumeDataInstanceInfo extends DataInstanceInfo {
  constructor(obj, name2, base, encoding, instanceNames) {
    super(obj, name2, base);
    this.encoding = encoding;
    let extended = verifyObjectProperty(obj, "Extended", verifyObject);
    let extendedValues = verifyObjectProperty(extended, "Values", (x) => parseArray(x, verifyObject));
    if (extendedValues.length < 1) {
      throw new Error("Expected Extended.Values property to have length >= 1, but received: ${JSON.stringify(extendedValues)}.");
    }
    let instSet = new _Set(instanceNames);
    if (encoding !== VolumeChunkEncoding$3.COMPRESSED_SEGMENTATIONARRAY) {
      while (instSet.has(name2 + "_" + this.volumeInfo.numLevels.toString())) {
        this.volumeInfo.numLevels += 1;
      }
    }
    if (instSet.has(name2 + "_meshes")) {
      this.meshSrc = name2 + "_meshes";
    } else {
      this.meshSrc = "";
    }
    if (instSet.has(name2 + "_skeletons")) {
      this.skeletonSrc = name2 + "_skeletons";
    } else {
      this.skeletonSrc = "";
    }
    this.dataType = verifyObjectProperty(extendedValues[0], "DataType", (x) => verifyMapKey(x, serverDataTypes));
  }
  get volumeType() {
    return this.encoding === VolumeChunkEncoding$3.COMPRESSED_SEGMENTATION || this.encoding === VolumeChunkEncoding$3.COMPRESSED_SEGMENTATIONARRAY ? VolumeType.SEGMENTATION : VolumeType.IMAGE;
  }
  getSources(chunkManager, parameters, volumeSourceOptions, credentialsProvider) {
    const encoding = this.encoding;
    const sources = [];
    const blocksize = 64;
    for (let level = 0; level < this.numLevels; ++level) {
      const downsampleFactor = Math.pow(2, level);
      const invDownsampleFactor = Math.pow(2, -level);
      const lowerVoxelBound = create$3();
      const upperVoxelBound = create$3();
      for (let i = 0; i < 3; ++i) {
        const lowerVoxelNotAligned = Math.floor(this.lowerVoxelBound[i] * invDownsampleFactor);
        lowerVoxelBound[i] = lowerVoxelNotAligned - lowerVoxelNotAligned % blocksize;
        const upperVoxelNotAligned = Math.ceil(this.upperVoxelBound[i] * invDownsampleFactor);
        upperVoxelBound[i] = upperVoxelNotAligned;
        if (upperVoxelNotAligned % blocksize !== 0) {
          upperVoxelBound[i] += blocksize - upperVoxelNotAligned % blocksize;
        }
      }
      let dataInstanceKey = parameters.dataInstanceKey;
      if (encoding !== VolumeChunkEncoding$3.COMPRESSED_SEGMENTATIONARRAY) {
        if (level > 0) {
          dataInstanceKey += "_" + level.toString();
        }
      }
      const volParameters = _Object$assign(_Object$assign({}, parameters), { dataInstanceKey, dataScale: level.toString(), encoding });
      const chunkToMultiscaleTransform = create$4();
      for (let i = 0; i < 3; ++i) {
        chunkToMultiscaleTransform[5 * i] = downsampleFactor;
        chunkToMultiscaleTransform[12 + i] = lowerVoxelBound[i] * downsampleFactor;
      }
      const alternatives = makeDefaultVolumeChunkSpecifications({
        rank: 3,
        chunkToMultiscaleTransform,
        dataType: this.dataType,
        baseVoxelOffset: lowerVoxelBound,
        upperVoxelBound: subtract$1(create$3(), upperVoxelBound, lowerVoxelBound),
        volumeType: this.volumeType,
        volumeSourceOptions,
        compressedSegmentationBlockSize: encoding === VolumeChunkEncoding$3.COMPRESSED_SEGMENTATION || encoding === VolumeChunkEncoding$3.COMPRESSED_SEGMENTATIONARRAY ? fromValues$1(8, 8, 8) : void 0
      }).map((spec) => ({
        chunkSource: chunkManager.getChunkSource(DVIDVolumeChunkSource, { spec, parameters: volParameters, credentialsProvider }),
        chunkToMultiscaleTransform
      }));
      sources.push(alternatives);
    }
    return transposeNestedArrays(sources);
  }
}
function getSyncedLabel(dataInfo) {
  let baseInfo = verifyObjectProperty(dataInfo, "Base", verifyObject);
  let syncs = verifyObjectProperty(baseInfo, "Syncs", verifyStringArray);
  if (syncs.length === 1) {
    return syncs[0];
  } else {
    return "";
  }
}
function getVolumeInfoResponseFromTags(tags, defaultObj) {
  if (!tags) {
    return defaultObj;
  }
  const defaultExtended = defaultObj && defaultObj.Extended || {};
  let MaxDownresLevel = defaultExtended.MaxDownresLevel, MaxPoint = defaultExtended.MaxPoint, MinPoint = defaultExtended.MinPoint, VoxelSize = defaultExtended.VoxelSize, BlockSize = defaultExtended.BlockSize;
  try {
    if (tags.MaxDownresLevel && typeof tags.MaxDownresLevel === "string") {
      MaxDownresLevel = parseInt(verifyObjectProperty(tags, "MaxDownresLevel", verifyString));
      if (MaxDownresLevel < 0) {
        MaxDownresLevel = defaultExtended.MaxDownresLevel;
      }
    } else if (typeof tags.MaxDownresLevel === "number") {
      MaxDownresLevel = verifyObjectProperty(tags, "MaxDownresLevel", verifyNonnegativeInt);
      ;
    }
  } catch (e) {
  }
  try {
    if (tags.MaxPoint && typeof tags.MaxPoint === "string") {
      MaxPoint = JSON.parse(verifyObjectProperty(tags, "MaxPoint", verifyString));
    } else if (Array.isArray(tags.MaxPoint) && tags.MaxPoint.length === 3) {
      MaxPoint = tags.MaxPoint;
    }
  } catch (e) {
  }
  try {
    if (tags.MinPoint && typeof tags.MinPoint === "string") {
      MinPoint = JSON.parse(verifyObjectProperty(tags, "MinPoint", verifyString));
    } else if (Array.isArray(tags.MinPoint) && tags.MinPoint.length === 3) {
      MinPoint = tags.MinPoint;
    }
  } catch (e) {
  }
  try {
    if (tags.VoxelSize && typeof tags.VoxelSize === "string") {
      VoxelSize = JSON.parse(verifyObjectProperty(tags, "VoxelSize", verifyString));
    } else if (Array.isArray(tags.VoxelSize) && tags.VoxelSize.length === 3) {
      VoxelSize = tags.VoxelSize;
    }
  } catch (e) {
  }
  try {
    if (tags.BlockSize && typeof tags.BlockSize === "string") {
      BlockSize = JSON.parse(verifyObjectProperty(tags, "BlockSize", verifyString));
    } else if (Array.isArray(tags.BlockSize) && tags.BlockSize.length === 3) {
      BlockSize = tags.BlockSize;
    }
  } catch (e) {
  }
  const defaultBase = defaultObj && defaultObj.Base;
  let response = {
    Base: defaultBase || {},
    Extended: _Object$assign(_Object$assign({}, defaultExtended), {
      VoxelSize,
      MinPoint,
      MaxPoint,
      MaxDownresLevel,
      BlockSize
    })
  };
  return response;
}
class AnnotationDataInstanceInfo extends DataInstanceInfo {
  get tags() {
    return verifyObjectProperty(this.base.obj, "Tags", verifyObject);
  }
  constructor(obj, name2, base) {
    super(obj, name2, base);
  }
}
function parseDataInstanceFromRepoInfo(dataInstanceObjs, name2, instanceNames) {
  verifyObject(dataInstanceObjs);
  let dataInstanceObj = dataInstanceObjs[name2];
  let baseInfo = verifyObjectProperty(dataInstanceObj, "Base", (x) => new DataInstanceBaseInfo(x));
  if (baseInfo.typeName === "annotation") {
    let syncedLabel = getSyncedLabel(dataInstanceObj);
    if (syncedLabel) {
      dataInstanceObj = dataInstanceObjs[syncedLabel];
    }
    return new AnnotationDataInstanceInfo(dataInstanceObj, name2, baseInfo);
  }
  {
    return parseDataInstance(dataInstanceObj, name2, instanceNames);
  }
}
function parseDataInstance(obj, name2, instanceNames) {
  verifyObject(obj);
  let baseInfo = verifyObjectProperty(obj, "Base", (x) => new DataInstanceBaseInfo(x));
  switch (baseInfo.typeName) {
    case "uint8blk":
    case "grayscale8":
      let isjpegcompress = baseInfo.compressionName.indexOf("jpeg") !== -1;
      return new VolumeDataInstanceInfo(obj, name2, baseInfo, isjpegcompress ? VolumeChunkEncoding$3.JPEG : VolumeChunkEncoding$3.RAW, instanceNames);
    case "labels64":
    case "labelblk":
      return new VolumeDataInstanceInfo(obj, name2, baseInfo, VolumeChunkEncoding$3.COMPRESSED_SEGMENTATION, instanceNames);
    case "labelarray":
    case "labelmap":
      return new VolumeDataInstanceInfo(obj, name2, baseInfo, VolumeChunkEncoding$3.COMPRESSED_SEGMENTATIONARRAY, instanceNames);
    default:
      throw new Error(`DVID data type ${_JSON$stringify(baseInfo.typeName)} is not supported.`);
  }
}
class RepositoryInfo {
  constructor(obj) {
    this.errors = [];
    this.dataInstances = new _Map();
    this.vnodes = new _Set();
    if (obj instanceof RepositoryInfo) {
      this.alias = obj.alias;
      this.description = obj.description;
      this.errors = obj.errors;
      this.dataInstances = obj.dataInstances;
      return;
    }
    verifyObject(obj);
    this.alias = verifyObjectProperty(obj, "Alias", verifyString);
    this.description = verifyObjectProperty(obj, "Description", verifyString);
    let dataInstanceObjs = verifyObjectProperty(obj, "DataInstances", verifyObject);
    let instanceKeys = _Object$keys(dataInstanceObjs);
    for (let key of instanceKeys) {
      try {
        this.dataInstances.set(key, parseDataInstanceFromRepoInfo(dataInstanceObjs, key, instanceKeys));
      } catch (parseError) {
        let message = `Failed to parse data instance ${_JSON$stringify(key)}: ${parseError.message}`;
        console.log(message);
        this.errors.push(message);
      }
    }
    let dagObj = verifyObjectProperty(obj, "DAG", verifyObject);
    let nodeObjs = verifyObjectProperty(dagObj, "Nodes", verifyObject);
    for (let key of _Object$keys(nodeObjs)) {
      this.vnodes.add(key);
    }
  }
}
function parseRepositoriesInfo(obj) {
  try {
    let result = verifyObjectAsMap(obj, (x) => new RepositoryInfo(x));
    let allVersions = new _Map();
    for (let _ref of result) {
      var _ref2 = _slicedToArray(_ref, 2);
      let key = _ref2[0];
      let info = _ref2[1];
      allVersions.set(key, info);
      for (let key2 of info.vnodes) {
        if (key2 !== key) {
          let rep = new RepositoryInfo(info);
          allVersions.set(key2, rep);
        }
      }
    }
    for (let _ref3 of allVersions) {
      var _ref4 = _slicedToArray(_ref3, 2);
      let key = _ref4[0];
      let info = _ref4[1];
      info.uuid = key;
    }
    return allVersions;
  } catch (parseError) {
    throw new Error(`Failed to parse DVID repositories info: ${parseError.message}`);
  }
}
class ServerInfo {
  constructor(obj) {
    this.repositories = parseRepositoriesInfo(obj);
  }
  getNode(nodeKey) {
    let matches = [];
    for (let key of this.repositories.keys()) {
      if (key.startsWith(nodeKey)) {
        matches.push(key);
      }
    }
    if (matches.length !== 1) {
      throw new Error(`Node key ${_JSON$stringify(nodeKey)} matches ${_JSON$stringify(matches)} nodes.`);
    }
    return this.repositories.get(matches[0]);
  }
}
function getServerInfo(chunkManager, baseUrl, credentialsProvider) {
  return chunkManager.memoize.getUncounted({ type: "dvid:getServerInfo", baseUrl }, () => {
    const result = makeRequestWithCredentials$1(credentialsProvider, { url: `${baseUrl}/api/repos/info`, method: "GET" }).then((response) => new ServerInfo(response));
    const description = `repository info for DVID server ${baseUrl}`;
    StatusMessage.forPromise(result, {
      initialMessage: `Retrieving ${description}.`,
      delay: true,
      errorPrefix: `Error retrieving ${description}: `
    });
    return result;
  });
}
class DvidMultiscaleVolumeChunkSource extends MultiscaleVolumeChunkSource$3 {
  constructor(chunkManager, sourceParameters, info, credentialsProvider) {
    super(chunkManager);
    this.sourceParameters = sourceParameters;
    this.info = info;
    this.credentialsProvider = credentialsProvider;
  }
  get dataType() {
    return this.info.dataType;
  }
  get volumeType() {
    return this.info.volumeType;
  }
  get rank() {
    return 3;
  }
  get baseUrl() {
    return this.sourceParameters.baseUrl;
  }
  get nodeKey() {
    return this.sourceParameters.nodeKey;
  }
  get dataInstanceKey() {
    return this.sourceParameters.dataInstanceKey;
  }
  get supervoxels() {
    return this.sourceParameters.supervoxels || false;
  }
  getSegmentPosition(id) {
    const dvidService = this.sourceParameters.dvidService;
    if (dvidService) {
      return fetch(`${dvidService}/locate-body?dvid=${this.baseUrl}&uuid=${this.nodeKey}&segmentation=${this.dataInstanceKey}&body=${id.toString()}${this.supervoxels ? "&supervoxels=true" : ""}`, {
        method: "GET"
      }).then((response) => response.json()).then((location2) => new Float32Array(location2));
    }
    return _Promise.reject("No locate service is available");
  }
  getSources(volumeSourceOptions) {
    return this.info.getSources(this.chunkManager, this.sourceParameters, volumeSourceOptions, this.credentialsProvider);
  }
}
const urlPattern$3 = /^((?:http|https):\/\/[^\/]+)\/([^\/]+)\/([^\/\?#]+)(?:(?:\?|#)(.*))?$/;
function getDefaultAuthServer(baseUrl) {
  if (baseUrl.startsWith("https")) {
    return baseUrl + "/api/server/token";
  } else {
    return void 0;
  }
}
function parseSourceUrl$1(url) {
  let match = url.match(urlPattern$3);
  if (match === null) {
    throw new Error(`Invalid DVID URL: ${_JSON$stringify(url)}.`);
  }
  let sourceParameters = {
    baseUrl: match[1],
    nodeKey: match[2],
    dataInstanceKey: match[3]
  };
  const queryString = match[4];
  if (queryString) {
    const parameters = parseQueryStringParameters(queryString);
    if (parameters.usertag === "true") {
      sourceParameters.usertag = true;
    }
    if (parameters.user) {
      sourceParameters.user = parameters.user;
    }
    const dvidService = parameters.dvidService || parameters.dvidservice || parameters["dvid-service"];
    if (dvidService) {
      sourceParameters.dvidService = dvidService;
    }
    const force = parameters.forceDvidService || parameters.forcedividservice || parameters["force-dvid-service"];
    if (force) {
      sourceParameters.forceDvidService = true;
    }
    sourceParameters.supervoxels = parameters.supervoxels === "true";
  }
  sourceParameters.authServer = getDefaultAuthServer(sourceParameters.baseUrl);
  return sourceParameters;
}
function getAnnotationChunkDataSize(parameters, lowerVoxelBound, upperVoxelBound) {
  if (parameters.usertag) {
    return sub(create$3(), upperVoxelBound, lowerVoxelBound);
  } else {
    return parameters.chunkDataSize;
  }
}
function makeAnnotationGeometrySourceSpecifications$1(multiscaleInfo, parameters) {
  const rank = 3;
  let makeSpec = (volumeInfo) => {
    const lowerVoxelBound = volumeInfo.lowerVoxelBound, upperVoxelBound = volumeInfo.upperVoxelBound;
    const chunkDataSize = getAnnotationChunkDataSize(parameters, lowerVoxelBound, upperVoxelBound);
    let spec = makeSliceViewChunkSpecification({
      rank,
      chunkDataSize: Uint32Array.from(chunkDataSize),
      lowerVoxelBound,
      upperVoxelBound
    });
    return { spec, chunkToMultiscaleTransform: create$4() };
  };
  if (parameters.usertag) {
    if (parameters.user) {
      return [[makeSpec(multiscaleInfo.scales[0])]];
    } else {
      throw "Expecting a valid user";
    }
  } else {
    return [multiscaleInfo.scales.map((scale2) => makeSpec(scale2))];
  }
}
const MultiscaleAnnotationSourceBase$3 = WithParameters(WithCredentialsProvider()(MultiscaleAnnotationSource), AnnotationSourceParameters$3);
class DVIDAnnotationChunkSource extends WithParameters(WithCredentialsProvider()(AnnotationGeometryChunkSource), AnnotationChunkSourceParameters$1) {
}
class DVIDAnnotationSource extends MultiscaleAnnotationSourceBase$3 {
  constructor(chunkManager, options) {
    super(chunkManager, _Object$assign({ rank: 3, relationships: ["segments"], properties: options.parameters.properties }, options));
    this.readonly = false;
    this.parameters = options.parameters;
    this.multiscaleVolumeInfo = options.multiscaleVolumeInfo;
    this.childAdded = this.childAdded || new Signal();
    this.childUpdated = this.childUpdated || new Signal();
    this.childDeleted = this.childDeleted || new Signal();
    this.childRefreshed = this.childRefreshed || new NullarySignal();
    if (this.parameters.readonly !== void 0) {
      this.readonly = this.parameters.readonly;
    }
    if (!this.parameters.user) {
      this.readonly = true;
    }
  }
  getSources(_options) {
    let sourceSpecifications = makeAnnotationGeometrySourceSpecifications$1(this.multiscaleVolumeInfo, this.parameters);
    let limit = 0;
    if (sourceSpecifications[0].length > 1) {
      limit = 3;
    }
    this.chunkSources = sourceSpecifications.map((alternatives) => alternatives.map(({ spec, chunkToMultiscaleTransform }) => ({
      chunkSource: this.chunkManager.getChunkSource(DVIDAnnotationChunkSource, {
        spec: _Object$assign({ limit, chunkToMultiscaleTransform }, spec),
        parent: this,
        credentialsProvider: this.credentialsProvider,
        parameters: this.parameters
      }),
      chunkToMultiscaleTransform
    })));
    return this.chunkSources;
  }
  invalidateCache() {
    this.metadataChunkSource.invalidateCache();
    for (let sources1 of this.chunkSources) {
      for (let source of sources1) {
        source.chunkSource.invalidateCache();
      }
    }
    for (let source of this.segmentFilteredSources) {
      source.invalidateCache();
    }
    this.childRefreshed.dispatch();
  }
}
async function getAnnotationChunkSource$1(options, sourceParameters, dataInstanceInfo, credentialsProvider) {
  let getChunkSource = (multiscaleVolumeInfo2, parameters) => options.chunkManager.getChunkSource(DVIDAnnotationSource, {
    parameters,
    credentialsProvider,
    multiscaleVolumeInfo: multiscaleVolumeInfo2
  });
  let multiscaleVolumeInfo = new MultiscaleVolumeInfo$1(dataInstanceInfo.volumeInfo);
  return getChunkSource(multiscaleVolumeInfo, sourceParameters);
}
async function getAnnotationSource$1(options, sourceParameters, dataInstanceInfo, credentialsProvider) {
  const box2 = {
    lowerBounds: new Float64Array(dataInstanceInfo.lowerVoxelBound),
    upperBounds: Float64Array.from(dataInstanceInfo.upperVoxelBound)
  };
  const modelSpace = makeCoordinateSpace({
    rank: 3,
    names: ["x", "y", "z"],
    units: ["m", "m", "m"],
    scales: Float64Array.from(dataInstanceInfo.voxelSize, (x) => x / 1e9),
    boundingBoxes: [makeIdentityTransformedBoundingBox(box2)]
  });
  const annotation = await getAnnotationChunkSource$1(options, sourceParameters, dataInstanceInfo, credentialsProvider);
  const dataSource = {
    modelTransform: makeIdentityTransform(modelSpace),
    subsources: [{
      id: "default",
      subsource: { annotation },
      default: true
    }]
  };
  return dataSource;
}
function getVolumeSource(options, sourceParameters, dataInstanceInfo, credentialsProvider) {
  const info = dataInstanceInfo;
  const box2 = {
    lowerBounds: new Float64Array(info.lowerVoxelBound),
    upperBounds: Float64Array.from(info.upperVoxelBound)
  };
  const modelSpace = makeCoordinateSpace({
    rank: 3,
    names: ["x", "y", "z"],
    units: ["m", "m", "m"],
    scales: Float64Array.from(info.voxelSize, (x) => x / 1e9),
    boundingBoxes: [makeIdentityTransformedBoundingBox(box2)]
  });
  const volume = new DvidMultiscaleVolumeChunkSource(options.chunkManager, sourceParameters, info, credentialsProvider);
  const dataSource = {
    modelTransform: makeIdentityTransform(modelSpace),
    subsources: [{
      id: "default",
      subsource: { volume },
      default: true
    }]
  };
  if (info.meshSrc) {
    const subsourceToModelSubspaceTransform = create$4();
    for (let i = 0; i < 3; ++i) {
      subsourceToModelSubspaceTransform[5 * i] = 1 / info.voxelSize[i];
    }
    dataSource.subsources.push({
      id: "meshes",
      default: true,
      subsource: {
        mesh: options.chunkManager.getChunkSource(DVIDMeshSource, {
          parameters: _Object$assign(_Object$assign({}, sourceParameters), { segmentationName: info.name, dataInstanceKey: info.meshSrc }),
          "credentialsProvider": credentialsProvider
        })
      },
      subsourceToModelSubspaceTransform
    });
  }
  if (info.skeletonSrc) {
    dataSource.subsources.push({
      id: "skeletons",
      default: true,
      subsource: {
        mesh: options.chunkManager.getChunkSource(DVIDSkeletonSource, {
          parameters: _Object$assign(_Object$assign({}, sourceParameters), { "dataInstanceKey": info.skeletonSrc }),
          "credentialsProvider": credentialsProvider
        })
      }
    });
  }
  dataSource.subsources.push({
    id: "bounds",
    subsource: { staticAnnotations: makeDataBoundsBoundingBoxAnnotationSet(box2) },
    default: true
  });
  return dataSource;
}
function getDataSource$1(options) {
  return options.chunkManager.memoize.getUncounted({
    type: "dvid:MultiscaleVolumeChunkSource",
    sourceUrl: options.providerUrl
  }, async () => {
    const sourceParameters = parseSourceUrl$1(options.providerUrl);
    const baseUrl = sourceParameters.baseUrl, nodeKey = sourceParameters.nodeKey, dataInstanceKey = sourceParameters.dataInstanceKey;
    const i = nodeKey.indexOf(":");
    const nodeKeyForLookup = i !== -1 ? nodeKey.slice(0, i) : nodeKey;
    const credentialsProvider = options.credentialsManager.getCredentialsProvider(credentialsKey$2, { dvidServer: sourceParameters.baseUrl, authServer: sourceParameters.authServer });
    const serverInfo = await getServerInfo(options.chunkManager, baseUrl, credentialsProvider);
    const repositoryInfo = serverInfo.getNode(nodeKeyForLookup);
    if (repositoryInfo === void 0) {
      throw new Error(`Invalid node: ${_JSON$stringify(nodeKey)}.`);
    }
    const dataInstanceInfo = repositoryInfo.dataInstances.get(dataInstanceKey);
    if (!dataInstanceInfo) {
      throw new Error(`Invalid data instance ${dataInstanceKey}.`);
    }
    if (dataInstanceInfo.base.typeName === "annotation") {
      if (!(dataInstanceInfo instanceof AnnotationDataInstanceInfo)) {
        throw new Error(`Invalid data instance ${dataInstanceKey}.`);
      }
      let annotationSourceParameters = _Object$assign(_Object$assign({}, new AnnotationSourceParameters$3()), sourceParameters);
      if (dataInstanceInfo.blockSize) {
        annotationSourceParameters.chunkDataSize = dataInstanceInfo.blockSize;
      }
      annotationSourceParameters.syncedLabel = getSyncedLabel({ Base: dataInstanceInfo.base.obj });
      annotationSourceParameters.properties = [{
        identifier: "rendering_attribute",
        description: "rendering attribute",
        type: "int32",
        default: 0,
        min: 0,
        max: 5,
        step: 1
      }, {
        identifier: "confidence",
        description: "confidence",
        type: "float32",
        default: 0,
        min: 0,
        max: 1,
        step: 0.01
      }];
      return getAnnotationSource$1(options, annotationSourceParameters, dataInstanceInfo, credentialsProvider);
    } else {
      if (!(dataInstanceInfo instanceof VolumeDataInstanceInfo)) {
        throw new Error(`Invalid data instance ${dataInstanceKey}.`);
      }
      return getVolumeSource(options, sourceParameters, dataInstanceInfo, credentialsProvider);
    }
  });
}
function completeInstanceName(repositoryInfo, prefix) {
  return {
    offset: 0,
    completions: getPrefixMatchesWithDescriptions(prefix, repositoryInfo.dataInstances.values(), (instance) => instance.name, (instance) => {
      return `${instance.base.typeName}`;
    })
  };
}
function completeNodeAndInstance(serverInfo, prefix) {
  let match = prefix.match(/^(?:([^\/]+)(?:\/([^\/]*))?)?$/);
  if (match === null) {
    throw new Error(`Invalid DVID URL syntax.`);
  }
  if (match[2] === void 0) {
    return {
      offset: 0,
      completions: getPrefixMatchesWithDescriptions(prefix, serverInfo.repositories.values(), (repository) => repository.uuid + "/", (repository) => `${repository.alias}: ${repository.description}`)
    };
  }
  let nodeKey = match[1];
  let repositoryInfo = serverInfo.getNode(nodeKey);
  return applyCompletionOffset(nodeKey.length + 1, completeInstanceName(repositoryInfo, match[2]));
}
async function completeUrl(options) {
  const curUrlPattern = /^((?:http|https):\/\/[^\/]+)\/([^\?]*).*$/;
  let url = options.providerUrl;
  let match = url.match(curUrlPattern);
  if (match === null) {
    throw null;
  }
  let baseUrl = match[1];
  let path = match[2];
  let authServer = getDefaultAuthServer(baseUrl);
  const serverInfo = await getServerInfo(options.chunkManager, baseUrl, options.credentialsManager.getCredentialsProvider(credentialsKey$2, { dvidServer: baseUrl, authServer }));
  return applyCompletionOffset(baseUrl.length + 1, completeNodeAndInstance(serverInfo, path));
}
class DVIDDataSource extends DataSourceProvider {
  constructor(credentialsManager) {
    super();
    this.credentialsManager = credentialsManager;
  }
  get description() {
    return "DVID";
  }
  get(options) {
    return getDataSource$1(options);
  }
  completeUrl(options) {
    return completeUrl(options);
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerProvider("dvid", (options) => new DVIDDataSource(options.credentialsManager));
function responseText(response) {
  return response.text();
}
function makeRequestWithCredentials(credentialsProvider, tokenRefreshable, httpCall, cancellationToken = uncancelableToken) {
  const requestInit = { method: httpCall.method, body: httpCall.payload };
  if (requestInit.method === "POST") {
    requestInit.headers = {
      "Content-Type": "application/json"
    };
  }
  return fetchWithFlyEMCredentials(credentialsProvider, tokenRefreshable, httpCall.url, requestInit, responseJson, cancellationToken);
}
function applyCredentials(input) {
  return (credentials, init) => {
    let newInit = _Object$assign({}, init);
    if (credentials) {
      newInit.headers = _Object$assign(_Object$assign({}, newInit.headers), { Authorization: `Bearer ${credentials}` });
    } else if (input.startsWith("https:")) {
      newInit.credentials = "include";
    }
    return newInit;
  };
}
function fetchWithFlyEMCredentials(credentialsProvider, tokenRefreshable, input, init, transformResponse, cancellationToken = uncancelableToken) {
  return fetchWithCredentials(credentialsProvider, input, init, transformResponse, applyCredentials(input), (error) => {
    const status = error.status;
    if (status === 403 || status === 401) {
      if (tokenRefreshable) {
        return "refresh";
      }
    }
    if (status === 504) {
      return "retry";
    }
    throw error;
  }, cancellationToken);
}
function getNeurohubToken(w) {
  if ("neurohub" in w) {
    return _Promise.resolve(w.neurohub.clio.auth.getAuthResponse().id_token);
  } else {
    return _Promise.resolve("");
  }
}
class FlyEMCredentialsProvider extends CredentialsProvider {
  constructor(authServer, retry) {
    super();
    this.authServer = authServer;
    this.retry = retry;
    this.get = makeCredentialsGetter((cancellationToken) => {
      const status = new StatusMessage(
        /*delay=*/
        true
      );
      let cancellationSource;
      return new _Promise((resolve, reject) => {
        const dispose = () => {
          cancellationSource = void 0;
          status.dispose();
        };
        cancellationToken.add(() => {
          if (cancellationSource !== void 0) {
            cancellationSource.cancel();
            cancellationSource = void 0;
            status.dispose();
            reject(CANCELED);
          }
        });
        const writeLoginStatus = (msg = "Authorization required.", linkMessage = "Request authorization.") => {
          status.setText(msg + " ");
          if (this.retry) {
            let button = document.createElement("button");
            button.textContent = linkMessage;
            status.element.appendChild(button);
            button.addEventListener("click", this.retry);
          }
          status.setVisible(true);
        };
        let authServer2 = this.authServer;
        const login = () => {
          if (cancellationSource !== void 0) {
            cancellationSource.cancel();
          }
          cancellationSource = new CancellationTokenSource();
          writeLoginStatus("Waiting for authorization...", "Retry");
          this.getAuthToken(authServer2, cancellationSource).then((token) => {
            if (cancellationSource !== void 0) {
              dispose();
              resolve(token);
            }
          }, (reason) => {
            if (cancellationSource !== void 0) {
              cancellationSource = void 0;
              writeLoginStatus(`Authorization failed: ${reason}.`, "Retry");
            }
          });
        };
        login();
      });
    });
  }
  getAuthToken(authServer, cancellationToken = uncancelableToken) {
    if (!authServer) {
      return _Promise.resolve("");
    } else if (authServer.startsWith("token:")) {
      return _Promise.resolve(authServer.substring(6));
    } else if (authServer == "neurohub") {
      return getNeurohubToken(window);
    } else {
      const headers = new Headers();
      return cancellableFetchOk(authServer, { "method": "GET", headers }, responseText, cancellationToken).catch(() => {
        return cancellableFetchOk(authServer, { "method": "GET" }, responseText, cancellationToken);
      });
    }
  }
}
const credentialsKey$1 = "Clio";
const urlPattern$2 = /^([^\/]+:\/\/[^\/]+)\/([^\/]+)\/([^\/\?]+)(\?.*)?$/;
function parseDVIDSourceUrl(url) {
  let match = url.match(urlPattern$2);
  if (match === null) {
    throw new Error(`Invalid DVID URL: ${_JSON$stringify(url)}.`);
  }
  return {
    baseUrl: match[1],
    nodeKey: match[2],
    dataInstanceKey: match[3]
  };
}
function parseGrayscaleUrl(source) {
  let u = parseUrl(source);
  if (u.protocol === "precomputed") {
    u = parseUrl(u.host + u.path);
  }
  return u;
}
function getGrayscaleInfoUrl(u) {
  let protocol = u.protocol, host = u.host, path = u.path;
  switch (protocol) {
    case "gs":
      return `https://storage.googleapis.com/${host}${path}/info`;
    case "dvid":
      const sourceParameters = parseDVIDSourceUrl(host + path);
      return `${sourceParameters.baseUrl}/api/node/${sourceParameters.nodeKey}/${sourceParameters.dataInstanceKey}/info`;
    case "https":
      return `${protocol}://${host}${path}/info`;
    default:
      throw Error("Unrecognized volume information");
  }
}
class ClioInstance {
  constructor(parameters) {
    this.parameters = parameters;
  }
  getTopLevelUrl() {
    var _parameters = this.parameters;
    const baseUrl = _parameters.baseUrl, api = _parameters.api;
    return `${baseUrl}/${api || "clio_toplevel"}`;
  }
  getDatasetsUrl() {
    return `${this.getTopLevelUrl()}/datasets`;
  }
  getGrayscaleInfoUrl() {
    let u = parseGrayscaleUrl(this.parameters.grayscale);
    return getGrayscaleInfoUrl(u);
  }
  getAnnotationEndpoint() {
    return this.parameters.kind === "Atlas" ? "atlas" : "annotations";
  }
  getAnnotationEntryUrl() {
    return `${this.getTopLevelUrl()}/${this.getAnnotationEndpoint()}/${this.parameters.dataset}`;
  }
  getAllAnnotationsUrl() {
    return this.getAnnotationEntryUrl() + (this.parameters.groups ? `?groups=${this.parameters.groups}` : "");
  }
  hasPointQueryApi() {
    return this.parameters.api === "clio_toplevel" || this.parameters.kind === "Atlas";
  }
  getPostAnnotationUrl(position) {
    if (this.hasPointQueryApi()) {
      return `${this.getAnnotationEntryUrl()}?x=${position[0]}&y=${position[1]}&z=${position[2]}`;
    }
    return this.getAnnotationEntryUrl();
  }
  getDeleteAnnotationUrl(id) {
    if (this.hasPointQueryApi()) {
      const tokens = id.match(/(-?\d+)_(-?\d+)_(-?\d+)/);
      if (tokens) {
        return this.getAnnotationUrl(tokens === null || tokens === void 0 ? void 0 : tokens.slice(1, 4));
      }
    }
    return `${this.getAnnotationEntryUrl()}/${id}`;
  }
  getAnnotationUrl(position) {
    return `${this.getAnnotationEntryUrl()}?x=${position[0]}&y=${position[1]}&z=${position[2]}`;
  }
}
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ClioCredentialsProvider extends FlyEMCredentialsProvider {
  constructor(authServer) {
    super(authServer);
    this.authServer = authServer;
  }
}
defaultCredentialsManager.register(credentialsKey$1, (authServer) => new ClioCredentialsProvider(authServer));
const ANNOTAIION_COMMIT_ADD_SIGNAL_RPC_ID = "annotation.add.signal";
registerRPC(ANNOTAIION_COMMIT_ADD_SIGNAL_RPC_ID, function(x) {
  const source = this.get(x.id);
  const newAnnotation = fixAnnotationAfterStructuredCloning(x.newAnnotation);
  if (newAnnotation) {
    source.parent.updateReference(newAnnotation);
    source.parent.childAdded.dispatch(newAnnotation);
  }
});
class AnnotationFacade {
  constructor(annotation) {
    this.annotation = annotation;
  }
  get renderingAttribute() {
    if (this.kind === "Atlas") {
      if (!this.title) {
        return -1;
      } else if (this.checked) {
        return 1;
      }
    } else {
      if (this.bookmarkType === "False Split") {
        return 2;
      } else if (this.bookmarkType === "False Merge") {
        return 3;
      }
    }
    return 0;
  }
  get confidence() {
    return 0;
  }
  updateProperties() {
    this.annotation.properties = [this.renderingAttribute, this.confidence];
  }
  get ext() {
    if (this.annotation.ext === void 0) {
      this.annotation.ext = {};
    }
    return this.annotation.ext;
  }
  get prop() {
    return this.annotation.prop;
  }
  set prop(value) {
    this.annotation.prop = value;
  }
  get bookmarkType() {
    if (this.prop) {
      switch (this.prop.type) {
        case "Split":
          return "False Merge";
        case "Merge":
          return "False Split";
      }
    }
    return "Other";
  }
  get type() {
    return this.annotation.type;
  }
  get kind() {
    return this.annotation.kind;
  }
  set kind(value) {
    this.annotation.kind = value;
    this.update();
  }
  roundPos() {
    if (this.annotation.type === AnnotationType.POINT) {
      this.annotation.point = this.annotation.point.map((x) => Math.round(x));
    } else if (this.annotation.type === AnnotationType.LINE || this.annotation.type === AnnotationType.SPHERE) {
      this.annotation.pointA = this.annotation.pointA.map((x) => Math.round(x));
      this.annotation.pointB = this.annotation.pointB.map((x) => Math.round(x));
    }
  }
  setProp(prop) {
    this.prop = _Object$assign(_Object$assign({}, this.prop), prop);
  }
  get user() {
    return this.prop && this.prop.user;
  }
  set user(value) {
    this.setProp({ user: value });
  }
  get comment() {
    return this.prop && this.prop.comment;
  }
  get description() {
    return this.comment;
  }
  updatePresentation() {
    if (this.title) {
      this.annotation.description = this.title + ": ";
    } else {
      this.annotation.description = "";
    }
    if (this.description) {
      this.annotation.description += this.description;
    }
  }
  update() {
    this.updatePresentation();
    this.updateProperties();
  }
  set comment(s) {
    this.setProp({ comment: s });
    this.updatePresentation();
  }
  updateComment() {
    this.comment = this.annotation.description || "";
    this.annotation.description = void 0;
  }
  get title() {
    return this.prop && this.prop.title;
  }
  set title(s) {
    this.setProp({ title: s });
    this.updatePresentation();
  }
  get timestamp() {
    return this.prop && this.prop.timestamp ? Number(this.prop.timestamp) : 0;
  }
  addTimeStamp() {
    this.setProp({ timestamp: String(Date.now()) });
  }
  get checked() {
    return this.ext && this.ext.verified || this.prop && this.prop.checked || false;
  }
  set checked(c) {
    this.setProp({ checked: c });
  }
  get presentation() {
    this.updatePresentation();
    return this.annotation.description || "";
  }
  set presentation(value) {
    this.annotation.description = value;
  }
}
function parseToken(token) {
  const base64Url = token.split(".")[1];
  if (base64Url) {
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const jsonPayload = decodeURIComponent(window.atob(base64).split("").map(function(c) {
      return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(""));
    return JSON.parse(jsonPayload);
  }
}
function getUserFromToken(token, defaultUser) {
  let tokenUser = void 0;
  const obj = parseToken(token);
  if (obj) {
    if ("user" in obj) {
      tokenUser = obj["user"];
    } else if ("email" in obj) {
      tokenUser = obj["email"];
    }
  }
  if (tokenUser) ;
  else {
    tokenUser = defaultUser;
  }
  return tokenUser;
}
const defaultJsonSchema = {
  "definitions": {},
  "type": "object",
  "required": ["Prop"],
  "properties": {
    "Prop": {
      "$id": "#/properties/Prop",
      "type": "object",
      "title": "Properties",
      "required": ["comment"],
      "properties": {
        "comment": {
          "$id": "#/properties/Prop/properties/comment",
          "type": "string",
          "title": "Comment",
          "default": ""
        }
      }
    }
  }
};
class ClioAnnotationFacade extends AnnotationFacade {
  get title() {
    return this.annotation.ext && this.annotation.ext.title;
  }
  set title(title) {
    this.ext.title = title;
  }
  get description() {
    return this.annotation.ext && this.annotation.ext.description;
  }
  set description(value) {
    this.ext.description = value;
  }
  get user() {
    return this.annotation.ext && this.annotation.ext.user;
  }
  set user(value) {
    this.ext.user = value;
  }
  get checked() {
    return this.ext && this.ext.verified;
  }
  set checked(c) {
    this.ext.verified = c;
  }
}
function parseDescription(description) {
  let match = description.match(/^\${(.*):JSON}$/);
  if (match) {
    return JSON.parse(match[1]);
  } else {
    return null;
  }
}
const defaultAnnotationSchema = {
  "definitions": {},
  "type": "object",
  "required": ["Prop"],
  "properties": {
    "Prop": {
      "$id": "#/properties/Prop",
      "type": "object",
      "title": "Properties",
      "required": ["description"],
      "properties": {
        "description": {
          "$id": "#/properties/Prop/properties/description",
          "type": "string",
          "title": "Description",
          "default": ""
        }
      }
    }
  }
};
const defaultAtlasSchema = {
  "definitions": {},
  "type": "object",
  "required": ["Prop"],
  "properties": {
    "Prop": {
      "$id": "#/properties/Prop",
      "type": "object",
      "title": "Properties",
      "required": ["title", "description"],
      "properties": {
        "title": {
          "$id": "#/properties/Prop/properties/title",
          "type": "string",
          "title": "Title",
          "default": ""
        },
        "description": {
          "$id": "#/properties/Prop/properties/description",
          "type": "string",
          "title": "Description",
          "default": ""
        }
      }
    }
  }
};
function isJsonArray(obj) {
  return Array.isArray(obj);
}
function isJsonObject(obj) {
  if (isJsonArray(obj) || obj === null) {
    return false;
  } else {
    return typeof obj === "object";
  }
}
class PropertyTreeNode {
  constructor(name2) {
    this.name = name2;
    this.childNodeList = new Array();
    this.parentNode = null;
  }
  isRoot() {
    return this.parentNode === null;
  }
  isLeaf() {
    return this.childNodeList.length === 0;
  }
  *[_Symbol$iterator]() {
    function* helper(node) {
      yield node;
      for (let child of node.childNodeList) {
        yield* helper(child);
      }
    }
    yield* helper(this);
  }
  *leafNodes() {
    for (let node of this) {
      if (node.childNodeList.length === 0) {
        yield node;
      }
    }
  }
  get fullName() {
    let finalName = this.name;
    let pn = this.parentNode;
    while (pn) {
      finalName = pn.name + "/" + finalName;
      pn = pn.parentNode;
    }
    return finalName;
  }
  get nameArray() {
    let keyArray = new Array();
    if (!this.isRoot()) {
      keyArray.push(this.name);
      let pn = this.parentNode;
      while (pn && !pn.isRoot()) {
        keyArray.push(pn.name);
        pn = pn.parentNode;
      }
    }
    return keyArray;
  }
  getPropertyValue(obj) {
    if (!this.isRoot() && obj) {
      let keyArray = this.nameArray;
      let subobj = obj;
      for (let i = keyArray.length - 1; i >= 0; --i) {
        if (isJsonObject(subobj)) {
          let key = keyArray[i];
          subobj = subobj[key];
        } else {
          return subobj;
        }
      }
      return subobj;
    }
  }
}
function buildJsonSchemaTree(schema, currentNode) {
  if (schema.type == "object") {
    if (currentNode.properties == void 0) {
      currentNode.properties = {};
    }
    currentNode.properties["title"] = schema["title"];
    let required = schema.required;
    if (isJsonArray(required)) {
      required.forEach((prop) => {
        let node = new PropertyTreeNode(prop);
        node.parentNode = currentNode;
        currentNode.childNodeList.push(node);
        let properties = schema["properties"];
        let property = properties[prop];
        buildJsonSchemaTree(property, node);
      });
    }
  } else {
    currentNode.properties = schema;
  }
}
function getJsonSchemaProperties(schema, rootName) {
  let root = new PropertyTreeNode(rootName);
  buildJsonSchemaTree(schema, root);
  return root;
}
const ANNOTATION_ROOT_ID = "annotation";
function createBasicElement(schema, id, value, readonly = false) {
  let element = document.createElement("div");
  let title = schema["title"];
  if (title) {
    element.appendChild(document.createTextNode(title));
  }
  let valueElement;
  switch (schema["type"]) {
    case "number":
      valueElement = document.createElement("input");
      if (typeof value === "number") {
        valueElement.text = value;
      }
      break;
    case "string":
      let optionList = schema["enum"];
      if (Array.isArray(optionList)) {
        valueElement = document.createElement("select");
        element.appendChild(valueElement);
        optionList.forEach((option) => {
          let optionElement = document.createElement("option");
          optionElement.text = option;
          optionElement.value = option;
          optionElement.disabled = readonly;
          valueElement.appendChild(optionElement);
        });
        if (value !== void 0) {
          valueElement.value = value;
        }
      } else {
        valueElement = document.createElement("input");
        valueElement.setAttribute("autocomplete", "off");
        if (typeof value === "string") {
          valueElement.value = value;
          valueElement.setAttribute("value", value);
        }
      }
      break;
    case "boolean":
      valueElement = document.createElement("input");
      valueElement.type = "checkbox";
      if (typeof value === "boolean") {
        valueElement.checked = value;
      } else {
        valueElement.checked = value == 1 ? true : false;
      }
      break;
  }
  if (valueElement) {
    valueElement.id = id;
    valueElement.readOnly = readonly;
    element.appendChild(valueElement);
  }
  return element;
}
function getElementId(parentId, prop) {
  return parentId + "/" + prop;
}
function createElement(schema, assigned, rootId, readonly = false) {
  let element = document.createElement("div");
  let root = getJsonSchemaProperties(schema, rootId);
  root.record = element;
  for (let node of root) {
    if (!node.isRoot()) {
      if (node.isLeaf()) {
        let value = node.getPropertyValue(assigned);
        let newElement = createBasicElement(node.properties, node.fullName, value, readonly);
        node.parentNode.record.appendChild(newElement);
      } else {
        let fieldset = document.createElement("fieldset");
        let legend = document.createElement("legend");
        legend.textContent = node.properties.title;
        fieldset.appendChild(legend);
        node.record = fieldset;
        node.parentNode.record.appendChild(fieldset);
      }
    }
  }
  return element;
}
function createAnnotationWidget(schema, assigned, readonly = false) {
  return createElement(schema, assigned, ANNOTATION_ROOT_ID, readonly);
}
function getValueFromElement(id) {
  let element = document.getElementById(id);
  if (element) {
    if (element["type"] === "checkbox") {
      return element["checked"];
    } else {
      return element["value"];
    }
  }
}
function getObjectFromWidget(schema, key, result, id) {
  if (schema.type === "object") {
    schema.required.forEach((prop) => {
      let subresult = result;
      if (key) {
        if (typeof result[key] === "undefined") {
          result[key] = {};
        }
        subresult = result[key];
      }
      getObjectFromWidget(schema.properties[prop], prop, subresult, getElementId(id, prop));
    });
  } else {
    result[key] = getValueFromElement(id);
  }
}
function makeAnnotationEditWidget(reference, schema, source, getFacade, getProp, setProp) {
  const annotation = _Object$assign({}, reference.value);
  if (annotation.type !== AnnotationType.POINT && annotation.type !== AnnotationType.LINE && annotation.type !== AnnotationType.SPHERE) {
    return null;
  }
  if (!schema) {
    schema = defaultJsonSchema;
  }
  const annotationRef = getFacade(annotation);
  const prop = getProp ? getProp(annotation) : annotationRef.prop;
  let widget = createAnnotationWidget(schema, prop ? { "Prop": prop } : {}, source.readonly);
  let button = document.createElement("button");
  button.textContent = "update";
  button.onclick = () => {
    let result = {};
    getObjectFromWidget(schema, "", result, "annotation");
    const x = result["Prop"];
    if (setProp) {
      setProp(annotation, x);
    } else {
      annotationRef.setProp(x);
    }
    annotationRef.update();
    source.update(reference, annotation);
    source.commit(reference);
  };
  widget.appendChild(button);
  return widget;
}
let jsonData = `
{
  "definitions": {},
  "type": "object",
  "required": [
    "Prop"
  ],
  "properties": {
    "Prop": {
      "$id": "#/properties/Prop",
      "type": "object",
      "title": "Properties",
      "required": [
        "comment",
        "type",
        "checked"
      ],
      "properties": {
        "comment": {
          "$id": "#/properties/Prop/properties/comment",
          "type": "string",
          "title": "Comment",
          "default": ""
        },
        "type": {
          "$id": "#/properties/Prop/properties/type",
          "type": "string",
          "title": "Type",
          "enum": ["Merge", "Split", "Other"]
        },
        "checked": {
          "$id": "#/properties/Prop/properties/checked",
          "type": "boolean",
          "title": "Checked"
        }
      }
    }
  }
}
`;
JSON.parse(jsonData);
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const annotationChunkDataSize = fromValues$1(64, 64, 64);
class ClioSourceParameters {
}
function isAuthRefreshable(parameters) {
  return parameters.authServer ? parameters.authServer === "neurohub" || parameters.authServer.startsWith("http") : false;
}
class AnnotationSourceParametersBase2 extends ClioSourceParameters {
  constructor() {
    super(...arguments);
    this.chunkDataSize = annotationChunkDataSize;
  }
}
let AnnotationSourceParameters$2 = class AnnotationSourceParameters2 extends AnnotationSourceParametersBase2 {
};
AnnotationSourceParameters$2.RPC_ID = "clio/Annotation";
class AnnotationChunkSourceParameters2 extends AnnotationSourceParametersBase2 {
}
AnnotationChunkSourceParameters2.RPC_ID = "clio/AnnotationChunkSource";
class ClioAnnotationChunkSource extends WithParameters(WithCredentialsProvider()(AnnotationGeometryChunkSource), AnnotationChunkSourceParameters2) {
}
async function getAnnotationDataInfo(parameters) {
  const grayscale = parameters.grayscale;
  if (grayscale) {
    let u = parseGrayscaleUrl(grayscale);
    return makeRequest$1({
      "method": "GET",
      "url": getGrayscaleInfoUrl(u)
    }).then((response) => {
      return new VolumeInfo$1(response, u.protocol === "https" ? "gs" : u.protocol);
    });
  } else {
    return _Promise.resolve({
      numChannels: 1,
      voxelSize: fromValues$1(8, 8, 8),
      lowerVoxelBound: fromValues$1(0, 0, 0),
      upperVoxelBound: fromValues$1(5e4, 5e4, 5e4),
      blockSize: fromValues$1(64, 64, 64),
      numLevels: 1
    });
  }
}
function makeAnnotationGeometrySourceSpecifications(dataInfo) {
  const rank = 3;
  let makeSpec = (info) => {
    const chunkDataSize = info.upperVoxelBound;
    let spec = makeSliceViewChunkSpecification({
      rank,
      chunkDataSize: Uint32Array.from(chunkDataSize),
      lowerVoxelBound: info.lowerVoxelBound,
      upperVoxelBound: info.upperVoxelBound
    });
    return { spec, chunkToMultiscaleTransform: create$4() };
  };
  return [[makeSpec(dataInfo)]];
}
const MultiscaleAnnotationSourceBase$2 = WithParameters(WithCredentialsProvider()(MultiscaleAnnotationSource), AnnotationSourceParameters$2);
class ClioAnnotationSource extends MultiscaleAnnotationSourceBase$2 {
  constructor(chunkManager, options) {
    super(chunkManager, _Object$assign({ rank: 3, relationships: ["segments"], properties: options.parameters.properties }, options));
    this.readonly = false;
    this.parameters = options.parameters;
    this.dataInfo = options.dataInfo;
    this.childAdded = this.childAdded || new Signal();
    this.childUpdated = this.childUpdated || new Signal();
    this.childDeleted = this.childDeleted || new Signal();
    this.makeEditWidget = (reference) => {
      const getFacade = (annotation) => {
        return new ClioAnnotationFacade(annotation);
      };
      const getProp = (annotation) => {
        return _Object$assign(_Object$assign({}, annotation.prop), annotation.ext);
      };
      const setProp = (annotation, prop) => {
        const annotationRef = new ClioAnnotationFacade(annotation);
        if (prop.title) {
          annotationRef.title = prop.title;
        }
        if (prop.description) {
          annotationRef.description = prop.description;
        }
      };
      return makeAnnotationEditWidget(reference, this.parameters.schema, this, getFacade, getProp, setProp);
    };
    this.getUser = () => this.parameters.user;
  }
  getSources(_options) {
    let sourceSpecifications = makeAnnotationGeometrySourceSpecifications(this.dataInfo);
    let limit = 0;
    if (sourceSpecifications[0].length > 1) {
      limit = 10;
    }
    return sourceSpecifications.map((alternatives) => alternatives.map(({ spec, chunkToMultiscaleTransform }) => ({
      chunkSource: this.chunkManager.getChunkSource(ClioAnnotationChunkSource, {
        spec: _Object$assign({ limit, chunkToMultiscaleTransform }, spec),
        parent: this,
        credentialsProvider: this.credentialsProvider,
        parameters: this.parameters
      }),
      chunkToMultiscaleTransform
    })));
  }
  *[_Symbol$iterator]() {
    for (let reference of this.references) {
      if (reference[1].value) {
        yield reference[1].value;
      }
    }
  }
  commit(reference) {
    if (reference.value && (reference.value.type === AnnotationType.LINE || reference.value.type === AnnotationType.SPHERE)) {
      reference.value.pointA = reference.value.pointA.map((x) => Math.round(x));
      reference.value.pointB = reference.value.pointB.map((x) => Math.round(x));
    }
    super.commit(reference);
  }
  add(annotation, commit = true) {
    if (this.readonly) {
      let errorMessage = "Permission denied for changing annotations.";
      StatusMessage.showTemporaryMessage(errorMessage);
      throw Error(errorMessage);
    }
    const clioAnnotation = new ClioAnnotationFacade(annotation);
    clioAnnotation.addTimeStamp();
    if (this.parameters.user) {
      clioAnnotation.user = this.parameters.user;
    }
    if (annotation.type === AnnotationType.POINT) {
      clioAnnotation.kind = this.parameters.kind || "Note";
      if (annotation.description) {
        let defaultProp = parseDescription(annotation.description);
        if (defaultProp) {
          clioAnnotation.setProp(defaultProp);
        }
      }
    }
    clioAnnotation.roundPos();
    clioAnnotation.update();
    return super.add(annotation, commit);
  }
  update(reference, newAnnotation) {
    const annotationRef = new ClioAnnotationFacade(newAnnotation);
    annotationRef.roundPos();
    annotationRef.update();
    super.update(reference, newAnnotation);
  }
  invalidateCache() {
    this.references.forEach((ref) => {
      ref.dispose();
    });
    this.references.clear();
    this.childRefreshed.dispatch();
    this.metadataChunkSource.invalidateCache();
    for (let sources1 of this.getSources({
      multiscaleToViewTransform: new Float32Array(),
      displayRank: 1,
      modelChannelDimensionIndices: []
    })) {
      for (let source of sources1) {
        source.chunkSource.invalidateCache();
      }
    }
    for (let source of this.segmentFilteredSources) {
      source.invalidateCache();
    }
  }
}
async function getAnnotationChunkSource(options, sourceParameters, dataInfo, credentialsProvider) {
  let getChunkSource = (dataInfo2, parameters) => options.chunkManager.getChunkSource(ClioAnnotationSource, {
    parameters,
    credentialsProvider,
    dataInfo: dataInfo2
  });
  return getChunkSource(dataInfo, sourceParameters);
}
async function getAnnotationSource(options, sourceParameters, credentialsProvider) {
  const dataInfo = await getAnnotationDataInfo(sourceParameters);
  const box2 = {
    lowerBounds: new Float64Array(dataInfo.lowerVoxelBound),
    upperBounds: Float64Array.from(dataInfo.upperVoxelBound)
  };
  const modelSpace = makeCoordinateSpace({
    rank: 3,
    names: ["x", "y", "z"],
    units: ["m", "m", "m"],
    scales: Float64Array.from(dataInfo.voxelSize, (x) => x / 1e9),
    boundingBoxes: [makeIdentityTransformedBoundingBox(box2)]
  });
  const annotation = await getAnnotationChunkSource(options, sourceParameters, dataInfo, credentialsProvider);
  const dataSource = {
    modelTransform: makeIdentityTransform(modelSpace),
    subsources: [{
      id: "default",
      subsource: { annotation },
      default: true
    }]
  };
  return dataSource;
}
const urlPattern$1 = /^([^\/]+:\/\/[^\/]+)\/(?:([^\/\?#]+)\/)?([^\/\?#]+)(?:(?:\?|#)(.*))?$/;
function parseSourceUrl(url) {
  let match = url.match(urlPattern$1);
  if (match === null) {
    throw new Error(`Invalid Clio URL: ${_JSON$stringify(url)}.`);
  }
  let sourceParameters = {
    baseUrl: match[1],
    api: match[2],
    dataset: match[3]
  };
  let queryString = match[4];
  if (queryString) {
    let parameters = parseQueryStringParameters(queryString);
    if (parameters.token) {
      sourceParameters.authToken = parameters.token;
      sourceParameters.authServer = "token:" + parameters.token;
    } else if (parameters.auth) {
      sourceParameters.authServer = parameters.auth;
    }
    if (parameters.user) {
      sourceParameters.user = parameters.user;
    } else if (sourceParameters.authToken) {
      sourceParameters.user = getUserFromToken(sourceParameters.authToken);
    }
    if (parameters.kind) {
      if (parameters.kind === "atlas") {
        sourceParameters.kind = "Atlas";
      } else {
        sourceParameters.kind = parameters.kind;
      }
    } else {
      sourceParameters.kind = "Normal";
    }
    if (parameters.groups) {
      sourceParameters.groups = parameters.groups;
    }
  }
  return sourceParameters;
}
async function completeSourceParameters(sourceParameters, getCredentialsProvider) {
  const clioInstance = new ClioInstance(sourceParameters);
  return makeRequestWithCredentials(getCredentialsProvider(sourceParameters.authServer), isAuthRefreshable(sourceParameters), {
    url: clioInstance.getDatasetsUrl(),
    method: "GET"
  }).then((response) => {
    const grayscaleInfo = verifyObjectProperty(response, sourceParameters.dataset, verifyObject);
    if ("location" in grayscaleInfo) {
      sourceParameters.grayscale = verifyObjectProperty(grayscaleInfo, "location", verifyString);
    } else if ("mainLayer" in grayscaleInfo) {
      const mainLayer = verifyObjectProperty(grayscaleInfo, "mainLayer", verifyString);
      const neuroglancer = verifyObjectProperty(grayscaleInfo, "neuroglancer", verifyObject);
      const layers = neuroglancer.layers;
      const layer = layers.find((layer2) => layer2.name === mainLayer);
      if (layer.source && layer.source.url) {
        sourceParameters.grayscale = verifyObjectProperty(layer.source, "url", verifyString);
      } else {
        sourceParameters.grayscale = verifyObjectProperty(layer, "source", verifyString);
      }
    }
    return sourceParameters;
  });
}
async function getDataSource(options, getCredentialsProvider) {
  let sourceParameters = parseSourceUrl(options.providerUrl);
  if (!sourceParameters.user && sourceParameters.authServer) {
    let credentials = getCredentialsProvider(sourceParameters.authServer).get();
    sourceParameters.authToken = (await credentials).credentials;
    sourceParameters.user = getUserFromToken(sourceParameters.authToken);
  }
  return options.chunkManager.memoize.getUncounted(_Object$assign({ type: "clio:MultiscaleVolumeChunkSource" }, sourceParameters), async () => {
    sourceParameters = await completeSourceParameters(sourceParameters, getCredentialsProvider);
    let annotationSourceParameters = _Object$assign(_Object$assign({}, new AnnotationSourceParameters$2()), sourceParameters);
    if (sourceParameters.kind === "Atlas") {
      annotationSourceParameters.schema = defaultAtlasSchema;
    } else {
      annotationSourceParameters.schema = defaultAnnotationSchema;
    }
    annotationSourceParameters.properties = [{
      identifier: "rendering_attribute",
      description: "rendering attribute",
      type: "int32",
      default: 0,
      min: 0,
      max: 5,
      step: 1
    }];
    const credentialsProvider = getCredentialsProvider(sourceParameters.authServer);
    return getAnnotationSource(options, annotationSourceParameters, credentialsProvider);
  });
}
async function completeHttpPath$1(_1) {
  return _Promise.resolve({
    offset: 0,
    completions: [{ value: "" }]
  });
}
class ClioDataSource extends DataSourceProvider {
  constructor(credentialsManager) {
    super();
    this.credentialsManager = credentialsManager;
    this.description = "Clio";
  }
  getCredentialsProvider(authServer) {
    let parameters = "";
    if (authServer) {
      parameters = authServer;
    }
    return this.credentialsManager.getCredentialsProvider(credentialsKey$1, parameters);
  }
  get(options) {
    return getDataSource(options, this.getCredentialsProvider.bind(this));
  }
  completeUrl(options) {
    return completeHttpPath$1(options.providerUrl);
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerProvider("clio", (options) => new ClioDataSource(options.credentialsManager));
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const credentialsKey = "google-brainmaps";
function makeRequest(instance, credentialsProvider, httpCall, cancellationToken = uncancelableToken) {
  return fetchWithOAuth2Credentials(credentialsProvider, `${instance.serverUrl}${httpCall.path}`, { method: httpCall.method, body: httpCall.payload }, httpCall.responseType === "json" ? responseJson : responseArrayBuffer, cancellationToken);
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VolumeChunkEncoding$2;
(function(VolumeChunkEncoding2) {
  VolumeChunkEncoding2[VolumeChunkEncoding2["RAW"] = 0] = "RAW";
  VolumeChunkEncoding2[VolumeChunkEncoding2["JPEG"] = 1] = "JPEG";
  VolumeChunkEncoding2[VolumeChunkEncoding2["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
})(VolumeChunkEncoding$2 || (VolumeChunkEncoding$2 = {}));
class VolumeSourceParameters {
}
VolumeSourceParameters.RPC_ID = "brainmaps/VolumeChunkSource";
let MultiscaleMeshSourceParameters$1 = class MultiscaleMeshSourceParameters {
};
MultiscaleMeshSourceParameters$1.RPC_ID = "brainmaps/MultiscaleMeshSource";
let MeshSourceParameters$1 = class MeshSourceParameters2 {
};
MeshSourceParameters$1.RPC_ID = "brainmaps/MeshSource";
let SkeletonSourceParameters$1 = class SkeletonSourceParameters2 {
};
SkeletonSourceParameters$1.RPC_ID = "brainmaps/SkeletonSource";
let AnnotationSourceParameters$1 = class AnnotationSourceParameters3 {
};
AnnotationSourceParameters$1.RPC_ID = "brainmaps/Annotation";
let AnnotationSpatialIndexSourceParameters$1 = class AnnotationSpatialIndexSourceParameters {
};
AnnotationSpatialIndexSourceParameters$1.RPC_ID = "brainmaps/AnnotationSpatialIndex";
class BrainmapsVolumeChunkSource extends WithParameters(WithCredentialsProvider()(VolumeChunkSource), VolumeSourceParameters) {
}
class BrainmapsMultiscaleMeshSource extends WithParameters(WithCredentialsProvider()(MultiscaleMeshSource), MultiscaleMeshSourceParameters$1) {
}
class BrainmapsMeshSource extends WithParameters(WithCredentialsProvider()(MeshSource), MeshSourceParameters$1) {
}
class BrainmapsSkeletonSource extends WithParameters(WithCredentialsProvider()(SkeletonSource), SkeletonSourceParameters$1) {
}
class BrainmapsAnnotationSpatialIndexSource extends WithParameters(WithCredentialsProvider()(AnnotationGeometryChunkSource), AnnotationSpatialIndexSourceParameters$1) {
}
const SERVER_DATA_TYPES = new _Map();
SERVER_DATA_TYPES.set("UINT8", DataType.UINT8);
SERVER_DATA_TYPES.set("FLOAT", DataType.FLOAT32);
SERVER_DATA_TYPES.set("UINT32", DataType.UINT32);
SERVER_DATA_TYPES.set("UINT64", DataType.UINT64);
function parseBoundingBox(obj) {
  verifyObject(obj);
  try {
    return {
      corner: verifyObjectProperty(obj, "corner", (x) => parseXYZ(create$3(), x, verifyFiniteFloat)),
      size: verifyObjectProperty(obj, "size", (x) => parseXYZ(create$3(), x, verifyFinitePositiveFloat)),
      metadata: verifyObjectProperty(obj, "metadata", verifyOptionalString)
    };
  } catch (parseError) {
    throw new Error(`Failed to parse bounding box: ${parseError.message}`);
  }
}
class VolumeInfo2 {
  constructor(obj) {
    try {
      verifyObject(obj);
      this.numChannels = verifyObjectProperty(obj, "channelCount", verifyPositiveInt);
      this.dataType = verifyObjectProperty(obj, "channelType", (x) => verifyMapKey(x, SERVER_DATA_TYPES));
      this.voxelSize = verifyObjectProperty(obj, "pixelSize", (x) => parseXYZ(create$3(), x, verifyFinitePositiveFloat));
      this.upperVoxelBound = verifyObjectProperty(obj, "volumeSize", (x) => parseXYZ(create$3(), x, verifyPositiveInt));
      this.boundingBoxes = verifyObjectProperty(obj, "boundingBox", (a) => a === void 0 ? [] : parseArray(a, parseBoundingBox));
    } catch (parseError) {
      throw new Error(`Failed to parse BrainMaps volume geometry: ${parseError.message}`);
    }
  }
}
function parseMeshInfo(obj) {
  verifyObject(obj);
  return {
    name: verifyObjectProperty(obj, "name", verifyString),
    type: verifyObjectProperty(obj, "type", verifyString)
  };
}
function parseMeshesResponse(meshesResponse) {
  try {
    verifyObject(meshesResponse);
    return verifyObjectProperty(meshesResponse, "meshes", (y) => {
      if (y === void 0) {
        return [];
      }
      return parseArray(y, parseMeshInfo);
    });
  } catch (parseError) {
    throw new Error(`Failed to parse BrainMaps meshes specification: ${parseError.message}`);
  }
}
const floatPattern = "([0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)";
const intPattern = "([0-9]+)";
const lodPattern = new RegExp(`^(.*)_${intPattern}x${intPattern}x${intPattern}_lod([0-9]+)_${floatPattern}$`);
function getMultiscaleMeshes(volumeInfo, meshes) {
  const multiscaleMeshes = new _Map();
  const baseVolume = volumeInfo.scales[0];
  const invalidLodMeshes = new _Set();
  for (const mesh of meshes) {
    if (mesh.type !== "TRIANGLES") continue;
    const m = mesh.name.match(lodPattern);
    if (m === null) continue;
    const key = m[1];
    let info = multiscaleMeshes.get(key);
    if (info === void 0) {
      info = { key, chunkShape: create$3(), lods: [] };
      multiscaleMeshes.set(key, info);
    }
    const lod = parseInt(m[5]);
    if (info.lods[lod] !== void 0) {
      invalidLodMeshes.add(key);
      continue;
    }
    const chunkShapeInVoxels = fromValues$1(parseInt(m[2], 10), parseInt(m[3], 10), parseInt(m[4], 10));
    const gridShape = new Uint32Array(3);
    for (let i = 0; i < 3; ++i) {
      gridShape[i] = Math.ceil(baseVolume.upperVoxelBound[i] / chunkShapeInVoxels[i]);
    }
    info.lods[lod] = {
      info: mesh,
      scale: parseFloat(m[6]),
      // Temporarily use the relativeBlockShape field to store the absolute shape in voxels.
      relativeBlockShape: chunkShapeInVoxels,
      gridShape
    };
  }
  const output = [];
  meshLoop: for (const mesh of multiscaleMeshes.values()) {
    if (invalidLodMeshes.has(mesh.key)) continue meshLoop;
    const baseLod = mesh.lods[0];
    if (baseLod === void 0) continue meshLoop;
    const baseBlockShapeInVoxels = baseLod.relativeBlockShape;
    multiply$2(mesh.chunkShape, baseBlockShapeInVoxels, baseVolume.voxelSize);
    for (let lodIndex = 1; lodIndex < mesh.lods.length; ++lodIndex) {
      const lod = mesh.lods[lodIndex];
      if (lod === void 0) continue meshLoop;
      const relativeBlockShape = lod.relativeBlockShape;
      for (let i = 0; i < 3; ++i) {
        const curSize = relativeBlockShape[i];
        const baseSize = baseBlockShapeInVoxels[i];
        if (curSize < baseSize || curSize % baseSize !== 0) continue meshLoop;
        relativeBlockShape[i] = curSize / baseSize;
      }
    }
    baseBlockShapeInVoxels.fill(1);
    output.push(mesh);
  }
  return output;
}
function getSingleScaleAndMultiscaleMeshes(volumeInfo, meshes) {
  const multiscaleMeshes = getMultiscaleMeshes(volumeInfo, meshes);
  const results = [];
  const add2 = (entry) => {
    if (results.some((x) => x.name === entry.name)) {
      return;
    }
    results.push(entry);
  };
  const multiscaleLodMeshes = new _Set();
  for (const m of multiscaleMeshes) {
    add2({ multi: m, single: void 0, name: m.key, partOfMultiscale: false });
    for (const s of m.lods) {
      multiscaleLodMeshes.add(s.info);
    }
  }
  for (const m of meshes) {
    add2({
      single: m,
      multi: void 0,
      name: m.name,
      partOfMultiscale: multiscaleLodMeshes.has(m)
    });
  }
  return results;
}
class MultiscaleVolumeInfo2 {
  constructor(volumeInfoResponse) {
    try {
      verifyObject(volumeInfoResponse);
      let scales = this.scales = verifyObjectProperty(volumeInfoResponse, "geometry", (y) => parseArray(y, (x) => new VolumeInfo2(x)));
      if (scales.length === 0) {
        throw new Error("Expected at least one scale.");
      }
      let baseScale = scales[0];
      let numChannels = this.numChannels = baseScale.numChannels;
      let dataType = this.dataType = baseScale.dataType;
      for (let scaleIndex = 1, numScales = scales.length; scaleIndex < numScales; ++scaleIndex) {
        let scale2 = scales[scaleIndex];
        if (scale2.dataType !== dataType) {
          throw new Error(`Scale ${scaleIndex} has data type ${DataType[scale2.dataType]} but scale 0 has data type ${DataType[dataType]}.`);
        }
        if (scale2.numChannels !== numChannels) {
          throw new Error(`Scale ${scaleIndex} has ${scale2.numChannels} channel(s) but scale 0 has ${numChannels} channels.`);
        }
      }
      this.box = {
        lowerBounds: new Float64Array(3),
        upperBounds: new Float64Array(baseScale.upperVoxelBound)
      };
    } catch (parseError) {
      throw new Error(`Failed to parse BrainMaps multiscale volume specification: ${parseError.message}`);
    }
  }
  getModelSpace(channelDimension = false) {
    const baseScale = this.scales[0];
    const names = ["x", "y", "z"];
    const units = ["m", "m", "m"];
    const scales = _Array$from(baseScale.voxelSize, (x) => x / 1e9);
    const upperBounds = _Array$from(baseScale.upperVoxelBound);
    if (channelDimension) {
      names.push("c^");
      units.push("");
      scales.push(1);
      upperBounds.push(this.numChannels);
    }
    return makeCoordinateSpace({
      names,
      units,
      scales: Float64Array.from(scales),
      boundingBoxes: [makeIdentityTransformedBoundingBox({
        lowerBounds: new Float64Array(names.length),
        upperBounds: Float64Array.from(upperBounds)
      })]
    });
  }
}
let MultiscaleVolumeChunkSource$2 = class MultiscaleVolumeChunkSource2 extends MultiscaleVolumeChunkSource$3 {
  constructor(chunkManager, instance, credentialsProvider, volumeId, changeSpec, multiscaleVolumeInfo, options) {
    super(chunkManager);
    this.instance = instance;
    this.credentialsProvider = credentialsProvider;
    this.volumeId = volumeId;
    this.changeSpec = changeSpec;
    this.multiscaleVolumeInfo = multiscaleVolumeInfo;
    this.encoding = options.encoding;
    this.jpegQuality = options.jpegQuality;
    this.chunkLayoutPreference = options.chunkLayoutPreference;
    let volumeType = VolumeType.IMAGE;
    if (this.dataType === DataType.UINT64) {
      volumeType = VolumeType.SEGMENTATION;
    }
    this.volumeType = volumeType;
  }
  get scales() {
    return this.multiscaleVolumeInfo.scales;
  }
  get dataType() {
    return this.multiscaleVolumeInfo.dataType;
  }
  get rank() {
    return this.multiscaleVolumeInfo.numChannels !== 1 ? 4 : 3;
  }
  getSources(volumeSourceOptions) {
    let encoding = VolumeChunkEncoding$2.RAW;
    if ((this.dataType === DataType.UINT64 || this.dataType === DataType.UINT32) && this.volumeType === VolumeType.SEGMENTATION && this.encoding !== VolumeChunkEncoding$2.RAW) {
      encoding = VolumeChunkEncoding$2.COMPRESSED_SEGMENTATION;
    } else if (this.volumeType === VolumeType.IMAGE && this.dataType === DataType.UINT8 && this.multiscaleVolumeInfo.numChannels === 1 && this.encoding !== VolumeChunkEncoding$2.RAW) {
      if (volumeSourceOptions.discreteValues !== true) {
        encoding = VolumeChunkEncoding$2.JPEG;
      }
    }
    const jpegQuality = encoding === VolumeChunkEncoding$2.JPEG ? this.jpegQuality : void 0;
    const baseScale = this.scales[0];
    const baseUpperVoxelBound = baseScale.upperVoxelBound;
    const relativeVoxelSize = create$3();
    const rank = this.rank;
    return transposeNestedArrays(this.scales.map((volumeInfo, scaleIndex) => {
      divide(relativeVoxelSize, volumeInfo.voxelSize, baseScale.voxelSize);
      let upperVoxelBound = volumeInfo.upperVoxelBound;
      let minBlockSize;
      let numChannels = volumeInfo.numChannels;
      const transform = new Float32Array((rank + 1) ** 2);
      transform[(rank + 1) * rank + rank] = 1;
      const upperClipBound = new Float32Array(rank);
      if (numChannels !== 1) {
        upperVoxelBound = Float32Array.of(...upperVoxelBound, numChannels);
        minBlockSize = Uint32Array.of(1, 1, 1, numChannels);
        transform[(rank + 1) * 3 + 3] = 1;
        upperClipBound[3] = numChannels;
      }
      for (let i = 0; i < 3; ++i) {
        transform[(rank + 1) * i + i] = relativeVoxelSize[i];
        upperClipBound[i] = baseUpperVoxelBound[i] / relativeVoxelSize[i];
      }
      return makeDefaultVolumeChunkSpecifications({
        rank,
        minBlockSize,
        chunkToMultiscaleTransform: transform,
        dataType: volumeInfo.dataType,
        upperVoxelBound,
        volumeType: this.volumeType,
        volumeSourceOptions,
        chunkLayoutPreference: this.chunkLayoutPreference,
        maxCompressedSegmentationBlockSize: fromValues$1(64, 64, 64)
      }).map((spec) => {
        return {
          chunkSource: this.chunkManager.getChunkSource(BrainmapsVolumeChunkSource, {
            credentialsProvider: this.credentialsProvider,
            spec,
            parameters: {
              "volumeId": this.volumeId,
              "changeSpec": this.changeSpec,
              "scaleIndex": scaleIndex,
              "encoding": encoding,
              "jpegQuality": jpegQuality,
              "instance": this.instance
            }
          }),
          chunkToMultiscaleTransform: transform,
          upperClipBound
        };
      });
    }));
  }
};
function getNanometersToVoxelsTransform(info) {
  const transform = create$4();
  const baseVoxelSize = info.scales[0].voxelSize;
  for (let i = 0; i < 3; ++i) {
    transform[5 * i] = 1 / baseVoxelSize[i];
  }
  return transform;
}
function parseVolumeKey(key) {
  const match = key.match(/^([^:?\/]+:[^:?\/]+:[^:?\/]+)(?::([^:?\/]+))?(?:\/([^?]+))?(?:\?(.*))?$/);
  if (match === null) {
    throw new Error(`Invalid Brain Maps volume key: ${_JSON$stringify(key)}.`);
  }
  let changeSpec;
  if (match[2] !== void 0) {
    changeSpec = { changeStackId: match[2] };
  }
  const parameters = parseQueryStringParameters(match[4] || "");
  return { volumeId: match[1], changeSpec, meshName: match[3], parameters };
}
function parseProject(obj) {
  try {
    verifyObject(obj);
    return {
      id: verifyObjectProperty(obj, "id", verifyString),
      label: verifyObjectProperty(obj, "label", verifyString),
      description: verifyObjectProperty(obj, "description", verifyOptionalString)
    };
  } catch (parseError) {
    throw new Error(`Failed to parse project: ${parseError.message}`);
  }
}
function parseProjectList(obj) {
  try {
    verifyObject(obj);
    return verifyObjectProperty(obj, "project", (x) => x === void 0 ? [] : parseArray(x, parseProject));
  } catch (parseError) {
    throw new Error(`Error parsing project list: ${parseError.message}`);
  }
}
function parseAPIResponseList(obj, propertyName) {
  try {
    verifyObject(obj);
    return verifyObjectProperty(obj, propertyName, (x) => x === void 0 ? [] : parseArray(x, verifyString));
  } catch (parseError) {
    throw new Error(`Error parsing dataset list: ${parseError.message}`);
  }
}
function parseChangeStackList(x) {
  return verifyObjectProperty(x, "changeStackId", (y) => y === void 0 ? void 0 : parseArray(y, verifyString));
}
const MultiscaleAnnotationSourceBase$1 = WithParameters(WithCredentialsProvider()(MultiscaleAnnotationSource), AnnotationSourceParameters$1);
class BrainmapsAnnotationSource extends MultiscaleAnnotationSourceBase$1 {
  constructor(chunkManager, options) {
    super(chunkManager, _Object$assign({ rank: 3, relationships: ["segments"], properties: [] }, options));
    this.credentialsProvider = this.registerDisposer(options.credentialsProvider.addRef());
  }
  hasNonSerializedProperties() {
    return true;
  }
  getSources() {
    const upperVoxelBound = this.parameters.upperVoxelBound;
    const spec = makeSliceViewChunkSpecification({
      rank: 3,
      chunkDataSize: upperVoxelBound,
      upperVoxelBound
    });
    const chunkToMultiscaleTransform = create$4();
    return [[{
      chunkSource: this.chunkManager.getChunkSource(BrainmapsAnnotationSpatialIndexSource, {
        parent: this,
        spec: _Object$assign({ limit: 0, chunkToMultiscaleTransform }, spec),
        parameters: this.parameters,
        credentialsProvider: this.credentialsProvider
      }),
      chunkToMultiscaleTransform
    }]];
  }
}
const supportedQueryParameters$1 = [{
  key: { value: "encoding", description: "Volume chunk data encoding" },
  values: [{ value: "raw", description: "" }, { value: "jpeg", description: "" }, { value: "compressed_segmentation", description: "" }]
}, {
  key: { value: "chunkLayout", description: "Volume chunk layout preference" },
  values: [{ value: "isotropic", description: "" }, { value: "flat", description: "" }]
}, {
  key: { value: "jpegQuality", description: "JPEG quality (1 to 100)" },
  values: []
}];
class BrainmapsDataSource extends DataSourceProvider {
  constructor(instance, credentialsProvider) {
    super();
    this.instance = instance;
    this.credentialsProvider = credentialsProvider;
  }
  get description() {
    return this.instance.description;
  }
  getMultiscaleInfo(chunkManager, volumeId) {
    return chunkManager.memoize.getUncounted({
      type: "brainmaps:getMultiscaleInfo",
      volumeId,
      instance: this.instance,
      credentialsProvider: getObjectId(this.credentialsProvider)
    }, () => makeRequest(this.instance, this.credentialsProvider, {
      method: "GET",
      path: `/v1beta2/volumes/${volumeId}`,
      responseType: "json"
    }).then((response) => new MultiscaleVolumeInfo2(response)));
  }
  getMeshesInfo(chunkManager, volumeId) {
    return chunkManager.memoize.getUncounted({
      type: "brainmaps:getMeshesInfo",
      volumeId,
      instance: this.instance,
      credentialsProvider: getObjectId(this.credentialsProvider)
    }, () => makeRequest(this.instance, this.credentialsProvider, {
      method: "GET",
      path: `/v1beta2/objects/${volumeId}/meshes`,
      responseType: "json"
    }).then((response) => parseMeshesResponse(response)));
  }
  get(options) {
    var _parseVolumeKey = parseVolumeKey(options.providerUrl);
    const volumeId = _parseVolumeKey.volumeId, changeSpec = _parseVolumeKey.changeSpec, meshName = _parseVolumeKey.meshName, parameters = _parseVolumeKey.parameters;
    verifyObject(parameters);
    const encoding = verifyOptionalObjectProperty(parameters, "encoding", (x) => verifyEnumString(x, VolumeChunkEncoding$2));
    const jpegQuality = verifyOptionalObjectProperty(parameters, "jpegQuality", (x) => {
      const quality = verifyInt(x);
      if (quality < 1 || quality > 100) throw new Error(`Expected integer in range [1, 100], but received: ${x}`);
      return quality;
    }, 70);
    const chunkLayoutPreference = verifyOptionalObjectProperty(parameters, "chunkLayout", (x) => verifyEnumString(x, ChunkLayoutPreference));
    const brainmapsOptions = { encoding, chunkLayoutPreference, jpegQuality };
    return options.chunkManager.memoize.getUncounted({ type: "brainmaps:get", instance: this.instance, volumeId, changeSpec, brainmapsOptions }, async () => {
      var _ref3 = await _Promise.all([this.getMultiscaleInfo(options.chunkManager, volumeId), this.getMeshesInfo(options.chunkManager, volumeId)]), _ref4 = _slicedToArray(_ref3, 2);
      const multiscaleVolumeInfo = _ref4[0], meshesInfo = _ref4[1];
      const volume = new MultiscaleVolumeChunkSource$2(options.chunkManager, this.instance, this.credentialsProvider, volumeId, changeSpec, multiscaleVolumeInfo, brainmapsOptions);
      const dataSource = {
        modelTransform: makeIdentityTransform(multiscaleVolumeInfo.getModelSpace(multiscaleVolumeInfo.numChannels !== 1)),
        subsources: [{
          id: meshName === void 0 ? "default" : "volume",
          subsource: { volume },
          default: meshName === void 0
        }]
      };
      const annotationSet = makeDataBoundsBoundingBoxAnnotationSet(multiscaleVolumeInfo.box);
      const baseScale = multiscaleVolumeInfo.scales[0];
      baseScale.boundingBoxes.forEach((boundingBox, i) => {
        annotationSet.add({
          type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,
          description: boundingBox.metadata,
          pointA: boundingBox.corner,
          pointB: add$2(create$3(), boundingBox.corner, boundingBox.size),
          id: `boundingBox${i}`,
          properties: []
        });
      });
      dataSource.subsources.push({
        id: "bounds",
        subsource: { staticAnnotations: annotationSet },
        default: true
      });
      const allMeshes = getSingleScaleAndMultiscaleMeshes(multiscaleVolumeInfo, meshesInfo);
      const addMeshResource = (mesh, enabled) => {
        let meshSource;
        const single = mesh.single;
        if (single !== void 0) {
          if (single.type === "TRIANGLES") {
            meshSource = options.chunkManager.getChunkSource(BrainmapsMeshSource, {
              credentialsProvider: this.credentialsProvider,
              parameters: {
                "instance": this.instance,
                "volumeId": volumeId,
                "meshName": single.name,
                "changeSpec": changeSpec
              }
            });
          } else {
            meshSource = options.chunkManager.getChunkSource(BrainmapsSkeletonSource, {
              credentialsProvider: this.credentialsProvider,
              parameters: {
                "instance": this.instance,
                "volumeId": volumeId,
                "meshName": mesh.name,
                "changeSpec": changeSpec
              }
            });
          }
        } else {
          const multi = mesh.multi;
          meshSource = options.chunkManager.getChunkSource(BrainmapsMultiscaleMeshSource, {
            credentialsProvider: this.credentialsProvider,
            format: {
              fragmentRelativeVertices: false,
              vertexPositionFormat: VertexPositionFormat.float32
            },
            parameters: {
              "instance": this.instance,
              "volumeId": volumeId,
              "info": multi,
              "changeSpec": changeSpec
            }
          });
        }
        dataSource.subsources.push({
          id: meshName === void 0 ? `/${mesh.name}` : "default",
          subsource: { mesh: meshSource },
          subsourceToModelSubspaceTransform: getNanometersToVoxelsTransform(multiscaleVolumeInfo),
          modelSubspaceDimensionIndices: [0, 1, 2],
          default: enabled
        });
      };
      if (meshName !== void 0) {
        const mesh = allMeshes.find((x) => x.name === meshName);
        if (mesh === void 0) {
          throw new Error(`Mesh/skeleton source not found: ${_JSON$stringify(mesh)}`);
        }
        addMeshResource(mesh, true);
      } else {
        let isFirst = true;
        for (const mesh of allMeshes) {
          if (mesh.partOfMultiscale) continue;
          addMeshResource(mesh, isFirst);
          isFirst = false;
        }
      }
      if (changeSpec !== void 0) {
        dataSource.subsources.push({
          id: "spatials",
          default: true,
          modelSubspaceDimensionIndices: [0, 1, 2],
          subsource: {
            annotation: options.chunkManager.getChunkSource(BrainmapsAnnotationSource, {
              parameters: {
                volumeId,
                changestack: changeSpec.changeStackId,
                instance: this.instance,
                upperVoxelBound: multiscaleVolumeInfo.scales[0].upperVoxelBound
              },
              credentialsProvider: this.credentialsProvider
            })
          }
        });
      }
      return dataSource;
    });
  }
  getProjectList(chunkManager) {
    return chunkManager.memoize.getUncounted({ instance: this.instance, type: "brainmaps:getProjectList" }, () => {
      let promise2 = makeRequest(this.instance, this.credentialsProvider, {
        method: "GET",
        path: "/v1beta2/projects",
        responseType: "json"
      }).then((projectsResponse) => {
        return parseProjectList(projectsResponse);
      });
      const description = `${this.instance.description} project list`;
      StatusMessage.forPromise(promise2, {
        delay: true,
        initialMessage: `Retrieving ${description}.`,
        errorPrefix: `Error retrieving ${description}: `
      });
      return promise2;
    });
  }
  getDatasetList(chunkManager, project) {
    return chunkManager.memoize.getUncounted({ instance: this.instance, type: `brainmaps:${project}:getDatasetList` }, () => {
      let promise2 = makeRequest(this.instance, this.credentialsProvider, {
        method: "GET",
        path: `/v1beta2/datasets?project_id=${project}`,
        responseType: "json"
      }).then((datasetsResponse) => {
        return parseAPIResponseList(datasetsResponse, "datasetIds");
      });
      const description = `${this.instance.description} dataset list`;
      StatusMessage.forPromise(promise2, {
        delay: true,
        initialMessage: `Retrieving ${description}`,
        errorPrefix: `Error retrieving ${description}`
      });
      return promise2;
    });
  }
  getVolumeList(chunkManager, project, dataset) {
    return chunkManager.memoize.getUncounted({ instance: this.instance, type: `brainmaps:${project}:${dataset}:getVolumeList` }, () => {
      let promise2 = makeRequest(this.instance, this.credentialsProvider, {
        method: "GET",
        path: `/v1beta2/volumes?project_id=${project}&dataset_id=${dataset}`,
        responseType: "json"
      }).then((volumesResponse) => {
        const fullyQualifyiedVolumeList = parseAPIResponseList(volumesResponse, "volumeId");
        const splitPoint = project.length + dataset.length + 2;
        const volumeList = [];
        for (const volume of fullyQualifyiedVolumeList) {
          volumeList.push(volume.substring(splitPoint));
        }
        return volumeList;
      });
      const description = `${this.instance.description} volume list`;
      StatusMessage.forPromise(promise2, {
        delay: true,
        initialMessage: `Retrieving ${description}`,
        errorPrefix: `Error retrieving ${description}`
      });
      return promise2;
    });
  }
  getChangeStackList(chunkManager, volumeId) {
    return chunkManager.memoize.getUncounted({ instance: this.instance, type: "brainmaps:getChangeStackList", volumeId }, () => {
      let promise2 = makeRequest(this.instance, this.credentialsProvider, {
        method: "GET",
        path: `/v1beta2/changes/${volumeId}/change_stacks`,
        responseType: "json"
      }).then((response) => parseChangeStackList(response));
      const description = `change stacks for ${volumeId}`;
      StatusMessage.forPromise(promise2, {
        delay: true,
        initialMessage: `Retrieving ${description}.`,
        errorPrefix: `Error retrieving ${description}: `
      });
      return promise2;
    });
  }
  async completeUrl(options) {
    const providerUrl = options.providerUrl;
    const m = providerUrl.match(/^([^:\/?]*)(?::([^:\/?]*)(?::([^:\/?]*)(?::([^:\/?]*))?(?:\/([^?]*))?(?:\?(.*))?)?)?$/);
    if (m === null) throw null;
    var _m = _slicedToArray(m, 7);
    const project = _m[1], dataset = _m[2], volume = _m[3], changestack = _m[4], meshName = _m[5], query = _m[6];
    if (query !== void 0) {
      return applyCompletionOffset(providerUrl.length - query.length, await completeQueryStringParametersFromTable(query, supportedQueryParameters$1));
    }
    if (meshName !== void 0) {
      const volumeId = `${project}:${dataset}:${volume}`;
      const meshes = await this.getMeshesInfo(options.chunkManager, volumeId);
      const results = [];
      const seenMultiscale = new _Set();
      for (const mesh of meshes) {
        if (!mesh.name.startsWith(meshName)) continue;
        switch (mesh.type) {
          case "LINE_SEGMENTS":
            results.push({ value: mesh.name, description: "Skeletons" });
            break;
          case "TRIANGLES": {
            results.push({ value: mesh.name, description: "Mesh (single-resolution)" });
            const m2 = mesh.name.match(lodPattern);
            if (m2 !== null) {
              const key = m2[1];
              if (seenMultiscale.has(key)) break;
              seenMultiscale.add(key);
              results.push({ value: key, description: "Mesh (multi-resolution)" });
            }
            break;
          }
        }
      }
      results.sort((a, b) => defaultStringCompare(a.value, b.value));
      return { offset: providerUrl.length - meshName.length, completions: results };
    }
    if (changestack !== void 0) {
      const volumeId = `${project}:${dataset}:${volume}`;
      const changeStacks = await this.getChangeStackList(options.chunkManager, volumeId);
      if (changeStacks === void 0) {
        throw null;
      }
      return {
        offset: providerUrl.length - changestack.length,
        completions: getPrefixMatches(changestack, changeStacks)
      };
    }
    if (volume !== void 0) {
      return {
        offset: providerUrl.length - volume.length,
        completions: getPrefixMatches(volume, await this.getVolumeList(options.chunkManager, project, dataset))
      };
    }
    if (dataset !== void 0) {
      const datasets = await this.getDatasetList(options.chunkManager, project);
      return {
        offset: providerUrl.length - dataset.length,
        completions: getPrefixMatches(dataset, datasets.map((x) => `${x}:`))
      };
    }
    const projects = await this.getProjectList(options.chunkManager);
    return {
      offset: 0,
      completions: getPrefixMatchesWithDescriptions(project, projects, (x) => `${x.id}:`, (x) => x.label)
    };
  }
}
const productionInstance = {
  description: "Google Brain Maps",
  serverUrl: "https://brainmaps.googleapis.com"
};
registerProvider("brainmaps", (options) => new BrainmapsDataSource(productionInstance, options.credentialsManager.getCredentialsProvider(credentialsKey)));
if (typeof NEUROGLANCER_BRAINMAPS_SERVERS !== "undefined") {
  for (const _ref of _Object$entries(NEUROGLANCER_BRAINMAPS_SERVERS)) {
    var _ref2$1 = _slicedToArray(_ref, 2);
    const key = _ref2$1[0];
    const instance = _ref2$1[1];
    registerProvider(`brainmaps-${key}`, (options) => new BrainmapsDataSource(instance, options.credentialsManager.getCredentialsProvider(credentialsKey)));
  }
}
const AUTH_SERVER = "https://accounts.google.com/o/oauth2/auth";
const AUTH_ORIGIN = "https://accounts.google.com";
function embedRelayFrame(proxyName, rpcToken) {
  let iframe = document.createElement("iframe");
  iframe.style.display = "none";
  iframe.id = proxyName;
  iframe.name = proxyName;
  const origin = location.origin;
  iframe.src = `https://accounts.google.com/o/oauth2/postmessageRelay?parent=${encodeURIComponent(origin)}#rpctoken=${rpcToken}`;
  document.body.appendChild(iframe);
}
class PendingRequest {
  constructor() {
    this.finished = new Signal();
  }
}
class AuthHandler {
  constructor() {
    this.proxyName = `postmessageRelay${getRandomHexString()}`;
    this.rpcToken = `${getRandomHexString()}`;
    this.relayReadyService = `oauth2relayReady:${this.rpcToken}`;
    this.oauth2CallbackService = `oauth2callback:${this.rpcToken}`;
    this.pendingRequests = new _Map();
    embedRelayFrame(this.proxyName, this.rpcToken);
    this.relayReadyPromise = new _Promise((relayReadyPromiseResolve) => {
      addEventListener("message", (event) => {
        if (event.origin !== AUTH_ORIGIN) {
          return;
        }
        try {
          let data = verifyObject(JSON.parse(event.data));
          let service = verifyString(data["s"]);
          if (service === this.relayReadyService) {
            relayReadyPromiseResolve();
          }
          if (service === this.oauth2CallbackService) {
            let args = parseArray(data["a"], (x) => x);
            let arg = verifyString(args[0]);
            let origin = location.origin;
            if (!arg.startsWith(origin + "#") && !arg.startsWith(origin + "?")) {
              throw new Error(`oauth2callback: URL ${_JSON$stringify(arg)} does not match current origin ${origin}.`);
            }
            let hashPart = arg.substring(origin.length + 1);
            let parts = hashPart.split("&");
            let params = new _Map();
            for (let part of parts) {
              let match = part.match("^([a-z_]+)=(.*)$");
              if (match === null) {
                throw new Error(`oauth2callback: URL part ${_JSON$stringify(match)} does not match expected pattern.`);
              }
              params.set(match[1], match[2]);
            }
            let state = params.get("state");
            if (state === void 0) {
              throw new Error(`oauth2callback: State argument is missing.`);
            }
            let request = this.pendingRequests.get(state);
            if (request === void 0) {
              return;
            }
            let error = params.get("error");
            if (error !== void 0) {
              let errorSubtype = params.get("error_subtype");
              let fullMessage = error;
              if (errorSubtype !== void 0) {
                fullMessage += ": " + errorSubtype;
              }
              request.finished.dispatch(void 0, new Error(`Error obtaining Google OAuth2 token: ${fullMessage}`));
              return;
            }
            let accessToken = params.get("access_token");
            let tokenType = params.get("token_type");
            let expiresIn = params.get("expires_in");
            let scope = params.get("scope");
            if (accessToken === void 0 || tokenType === void 0 || expiresIn === void 0 || scope === void 0) {
              throw new Error(`oauth2callback: URL lacks expected parameters.`);
            }
            request.finished.dispatch({
              accessToken,
              tokenType,
              expiresIn,
              scope
            });
            return;
          }
        } catch (parseError) {
          throw new Error(`Invalid message received from ${AUTH_ORIGIN}: ${_JSON$stringify(event.data)}: ${parseError.message}.`);
        }
      });
    });
  }
  addPendingRequest(state) {
    let request = new PendingRequest();
    this.pendingRequests.set(state, request);
    request.finished.add(() => {
      this.pendingRequests.delete(state);
    });
    return request;
  }
  makeAuthRequestUrl(options) {
    let url = `${AUTH_SERVER}?client_id=${encodeURIComponent(options.clientId)}`;
    url += `&redirect_uri=postmessage`;
    url += `&response_type=token`;
    var _options$origin = options.origin;
    let origin = _options$origin === void 0 ? location.origin : _options$origin;
    url += `&origin=${encodeURIComponent(origin)}`;
    url += `&proxy=${this.proxyName}`;
    url += `&include_granted_scopes=true`;
    url += `&scope=${encodeURIComponent(options.scopes.join(" "))}`;
    if (options.state) {
      url += `&state=${options.state}`;
    }
    if (options.approvalPrompt) {
      url += `&approval_prompt=${encodeURIComponent(options.approvalPrompt)}`;
    }
    if (options.loginHint) {
      url += `&login_hint=${encodeURIComponent(options.loginHint)}`;
    }
    if (options.immediate) {
      url += `&immediate=true`;
    }
    if (options.authUser !== void 0) {
      url += `&authuser=${options.authUser}`;
    }
    return url;
  }
}
let authHandlerInstance;
function authHandler() {
  if (authHandlerInstance === void 0) {
    authHandlerInstance = new AuthHandler();
  }
  return authHandlerInstance;
}
function authenticateGoogleOAuth2(options, cancellationToken = uncancelableToken) {
  const state = getRandomHexString();
  const handler = authHandler();
  const url = handler.makeAuthRequestUrl({
    state,
    clientId: options.clientId,
    scopes: options.scopes,
    approvalPrompt: options.approvalPrompt,
    loginHint: options.loginHint,
    immediate: options.immediate,
    authUser: options.authUser
  });
  const request = handler.addPendingRequest(state);
  const promise2 = new _Promise((resolve, reject) => {
    request.finished.add((token, error) => {
      if (token !== void 0) {
        resolve(token);
      } else {
        reject(error);
      }
    });
  });
  request.finished.add(cancellationToken.add(() => {
    request.finished.dispatch(void 0, CANCELED);
  }));
  if (options.immediate) {
    handler.relayReadyPromise.then(() => {
      if (cancellationToken.isCanceled) {
        return;
      }
      const iframe = document.createElement("iframe");
      iframe.src = url;
      iframe.style.display = "none";
      document.body.appendChild(iframe);
      request.finished.add(() => {
        removeFromParent(iframe);
      });
    });
  } else {
    if (!cancellationToken.isCanceled) {
      const newWindow = open(url);
      if (newWindow !== null) {
        request.finished.add(() => {
          newWindow.close();
        });
      }
    }
  }
  return promise2;
}
class GoogleOAuth2CredentialsProvider extends CredentialsProvider {
  constructor(options) {
    super();
    this.options = options;
    this.get = makeCredentialsGetter((cancellationToken) => {
      const options2 = this.options;
      const status = new StatusMessage(
        /*delay=*/
        true
      );
      let cancellationSource;
      return new _Promise((resolve, reject) => {
        const dispose = () => {
          cancellationSource = void 0;
          status.dispose();
        };
        cancellationToken.add(() => {
          if (cancellationSource !== void 0) {
            cancellationSource.cancel();
            cancellationSource = void 0;
            status.dispose();
            reject(CANCELED);
          }
        });
        function writeLoginStatus(msg = `${options2.description} authorization required.`, linkMessage = "Request authorization.") {
          status.setText(msg + "  ");
          let button = document.createElement("button");
          button.textContent = linkMessage;
          status.element.appendChild(button);
          button.addEventListener("click", () => {
            login(
              /*immediate=*/
              false
            );
          });
          status.setVisible(true);
        }
        function login(immediate) {
          if (cancellationSource !== void 0) {
            cancellationSource.cancel();
          }
          cancellationSource = new CancellationTokenSource();
          writeLoginStatus(`Waiting for ${options2.description} authorization...`, "Retry");
          authenticateGoogleOAuth2({
            clientId: options2.clientId,
            scopes: options2.scopes,
            immediate,
            authUser: 0
          }, cancellationSource).then((token) => {
            if (cancellationSource !== void 0) {
              dispose();
              resolve(token);
            }
          }, (reason) => {
            if (cancellationSource !== void 0) {
              cancellationSource = void 0;
              if (immediate) {
                writeLoginStatus();
              } else {
                writeLoginStatus(`${options2.description} authorization failed: ${reason}.`, "Retry");
              }
            }
          });
        }
        login(
          /*immediate=*/
          true
        );
      });
    });
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BRAINMAPS_SCOPE = "https://www.googleapis.com/auth/brainmaps";
class BrainmapsCredentialsProvider extends GoogleOAuth2CredentialsProvider {
  constructor(clientId) {
    super({ clientId, scopes: [BRAINMAPS_SCOPE], description: "Brain Maps" });
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
defaultCredentialsManager.register(credentialsKey, () => new BrainmapsCredentialsProvider(BRAINMAPS_CLIENT_ID));
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VolumeChunkEncoding$1;
(function(VolumeChunkEncoding2) {
  VolumeChunkEncoding2[VolumeChunkEncoding2["RAW"] = 0] = "RAW";
  VolumeChunkEncoding2[VolumeChunkEncoding2["JPEG"] = 1] = "JPEG";
  VolumeChunkEncoding2[VolumeChunkEncoding2["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
  VolumeChunkEncoding2[VolumeChunkEncoding2["COMPRESSO"] = 3] = "COMPRESSO";
  VolumeChunkEncoding2[VolumeChunkEncoding2["PNG"] = 4] = "PNG";
})(VolumeChunkEncoding$1 || (VolumeChunkEncoding$1 = {}));
let VolumeChunkSourceParameters$2 = class VolumeChunkSourceParameters2 {
};
VolumeChunkSourceParameters$2.RPC_ID = "precomputed/VolumeChunkSource";
class MeshSourceParameters3 {
}
MeshSourceParameters3.RPC_ID = "precomputed/MeshSource";
var DataEncoding;
(function(DataEncoding2) {
  DataEncoding2[DataEncoding2["RAW"] = 0] = "RAW";
  DataEncoding2[DataEncoding2["GZIP"] = 1] = "GZIP";
})(DataEncoding || (DataEncoding = {}));
var ShardingHashFunction;
(function(ShardingHashFunction2) {
  ShardingHashFunction2[ShardingHashFunction2["IDENTITY"] = 0] = "IDENTITY";
  ShardingHashFunction2[ShardingHashFunction2["MURMURHASH3_X86_128"] = 1] = "MURMURHASH3_X86_128";
})(ShardingHashFunction || (ShardingHashFunction = {}));
class MultiscaleMeshSourceParameters2 {
}
MultiscaleMeshSourceParameters2.RPC_ID = "precomputed/MultiscaleMeshSource";
class SkeletonSourceParameters3 {
}
SkeletonSourceParameters3.RPC_ID = "precomputed/SkeletonSource";
class AnnotationSpatialIndexSourceParameters2 {
}
AnnotationSpatialIndexSourceParameters2.RPC_ID = "precomputed/AnnotationSpatialIndexSource";
class AnnotationSourceParameters4 {
}
AnnotationSourceParameters4.RPC_ID = "precomputed/AnnotationSource";
class IndexedSegmentPropertySourceParameters {
}
IndexedSegmentPropertySourceParameters.RPC_ID = "precomputed/IndexedSegmentPropertySource";
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getGcsBucketListing(credentialsProvider, bucket, prefix, delimiter, cancellationToken) {
  const response = await fetchWithOAuth2Credentials(credentialsProvider, `https://www.googleapis.com/storage/v1/b/${bucket}/o?delimiter=${encodeURIComponent(delimiter)}&prefix=${encodeURIComponent(prefix)}&neuroglancerOrigin=${encodeURIComponent(location.origin)}`, {}, responseJson, cancellationToken);
  verifyObject(response);
  const prefixes = verifyOptionalObjectProperty(response, "prefixes", verifyStringArray, []);
  const items = verifyOptionalObjectProperty(response, "items", (items2) => parseArray(items2, (item) => {
    verifyObject(item);
    return verifyObjectProperty(item, "name", verifyString);
  }), []).filter((name2) => !name2.endsWith("_$folder$"));
  return [...prefixes, ...items];
}
async function getGcsPathCompletions(credentialsProvider, enteredBucketUrl, bucket, path, cancellationToken) {
  let prefix = path;
  if (!prefix.startsWith("/")) throw null;
  const paths = await getGcsBucketListing(credentialsProvider, bucket, path.substring(1), "/", cancellationToken);
  let offset = path.lastIndexOf("/");
  return {
    offset: offset + enteredBucketUrl.length + 1,
    completions: paths.map((x) => ({ value: x.substring(offset) }))
  };
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getHtmlDirectoryListing(url, cancellationToken, credentialsProvider) {
  var _ref = await cancellableFetchSpecialOk(
    credentialsProvider,
    url,
    /*init=*/
    { headers: { "accept": "text/html" } },
    async (x) => ({ text: await x.text(), contentType: x.headers.get("content-type") }),
    cancellationToken
  );
  const text = _ref.text, contentType = _ref.contentType;
  if (contentType === null || /\btext\/html\b/i.exec(contentType) === null) {
    return [];
  }
  const doc = new DOMParser().parseFromString(text, "text/html");
  const nodes = doc.evaluate("//a/@href", doc, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  const results = [];
  for (let i = 0, n = nodes.snapshotLength; i < n; ++i) {
    const node = nodes.snapshotItem(i);
    const href = node.textContent;
    if (href) {
      results.push(new URL(href, url).toString());
    }
  }
  return results;
}
async function getHtmlPathCompletions(url, cancellationToken, credentialsProvider) {
  console.log("getHtmlPathCompletions");
  const m = url.match(/^([a-z]+:\/\/.*\/)([^\/?#]*)$/);
  if (m === null) throw null;
  const entries2 = await getHtmlDirectoryListing(m[1], cancellationToken, credentialsProvider);
  const offset = m[1].length;
  const matches = [];
  for (const entry of entries2) {
    if (!entry.startsWith(url)) continue;
    matches.push({ value: entry.substring(offset) });
  }
  return {
    offset,
    completions: matches
  };
}
const specialProtocolEmptyCompletions = [{ value: "gs://", description: "Google Cloud Storage (JSON API)" }, { value: "gs+xml://", description: "Google Cloud Storage (XML API)" }, {
  value: "gs+json://",
  description: "Google Cloud Storage (storage JSON API)"
}, {
  value: "gs+ngauth+http://",
  description: "Google Cloud Storage (JSON API) authenticated via ngauth"
}, {
  value: "gs+ngauth+https://",
  description: "Google Cloud Storage (JSON API) authenticated via ngauth"
}, {
  value: "gs+xml+ngauth+http://",
  description: "Google Cloud Storage (XML API) authenticated via ngauth"
}, {
  value: "gs+xml+ngauth+https://",
  description: "Google Cloud Storage (XML API) authenticated via ngauth"
}, { value: "s3://", description: "Amazon Simple Storage Service (S3)" }, { value: "https://" }, { value: "http://" }];
async function completeHttpPath(credentialsManager, url, cancellationToken) {
  if (!url.includes("://")) {
    return {
      offset: 0,
      completions: getPrefixMatchesWithDescriptions(url, specialProtocolEmptyCompletions, (x) => x.value, (x) => x.description)
    };
  }
  var _parseSpecialUrl = parseSpecialUrl(url, credentialsManager);
  const parsedUrl = _parseSpecialUrl.url, credentialsProvider = _parseSpecialUrl.credentialsProvider;
  const offset = url.length - parsedUrl.length;
  let result;
  try {
    result = parseUrl(parsedUrl);
  } catch (_a) {
    throw null;
  }
  var _result = result;
  const protocol = _result.protocol, host = _result.host, path = _result.path;
  const completions = await (async () => {
    if (protocol === "gs+xml" && path.length > 0) {
      return await getS3CompatiblePathCompletions(credentialsProvider, `${protocol}://${host}`, `https://storage.googleapis.com/${host}`, path, cancellationToken);
    } else if ((protocol === "gs" || protocol === "gs+json") && path.length > 0) {
      return await getGcsPathCompletions(credentialsProvider, `${protocol}://${host}`, host, path, cancellationToken);
    } else if (protocol === "s3" && path.length > 0) {
      return await getS3PathCompletions(host, path, cancellationToken);
    }
    const s3Match = parsedUrl.match(/^((?:http|https):\/\/(?:storage\.googleapis\.com\/[^\/]+|[^\/]+\.storage\.googleapis\.com|[^\/]+\.s3(?:[^./]+)?\.amazonaws.com))(\/.*)$/);
    if (s3Match !== null) {
      return await getS3CompatiblePathCompletions(credentialsProvider, s3Match[1], s3Match[1], s3Match[2], cancellationToken);
    }
    if ((protocol === "http" || protocol === "https") && path.length > 0) {
      return await getHtmlPathCompletions(parsedUrl, cancellationToken, credentialsProvider);
    }
    throw null;
  })();
  return { offset: offset + completions.offset, completions: completions.completions };
}
class PrecomputedVolumeChunkSource extends WithParameters(WithCredentialsProvider()(VolumeChunkSource), VolumeChunkSourceParameters$2) {
}
class PrecomputedMeshSource extends WithParameters(WithCredentialsProvider()(MeshSource), MeshSourceParameters3) {
}
class PrecomputedMultiscaleMeshSource extends WithParameters(WithCredentialsProvider()(MultiscaleMeshSource), MultiscaleMeshSourceParameters2) {
}
class PrecomputedSkeletonSource extends WithParameters(WithCredentialsProvider()(SkeletonSource), SkeletonSourceParameters3) {
  get skeletonVertexCoordinatesInVoxels() {
    return false;
  }
  get vertexAttributes() {
    return this.parameters.metadata.vertexAttributes;
  }
}
function resolvePath(a, b) {
  const outputParts = a.split("/");
  for (const part of b.split("/")) {
    if (part === "..") {
      if (outputParts.length !== 0) {
        outputParts.length = outputParts.length - 1;
        continue;
      }
    }
    outputParts.push(part);
  }
  return outputParts.join("/");
}
class ScaleInfo {
  constructor(obj, numChannels) {
    verifyObject(obj);
    const rank = numChannels === 1 ? 3 : 4;
    const resolution = this.resolution = new Float64Array(rank);
    const voxelOffset = this.voxelOffset = new Float32Array(rank);
    const size = this.size = new Float32Array(rank);
    if (rank === 4) {
      resolution[3] = 1;
      size[3] = numChannels;
    }
    verifyObjectProperty(obj, "resolution", (x) => parseFixedLengthArray(resolution.subarray(0, 3), x, verifyFinitePositiveFloat));
    verifyOptionalObjectProperty(obj, "voxel_offset", (x) => parseFixedLengthArray(voxelOffset.subarray(0, 3), x, verifyInt));
    verifyObjectProperty(obj, "size", (x) => parseFixedLengthArray(size.subarray(0, 3), x, verifyPositiveInt));
    this.chunkSizes = verifyObjectProperty(obj, "chunk_sizes", (x) => parseArray(x, (y) => {
      const chunkSize = new Uint32Array(rank);
      if (rank === 4) chunkSize[3] = numChannels;
      parseFixedLengthArray(chunkSize.subarray(0, 3), y, verifyPositiveInt);
      return chunkSize;
    }));
    if (this.chunkSizes.length === 0) {
      throw new Error("No chunk sizes specified.");
    }
    this.sharding = verifyObjectProperty(obj, "sharding", parseShardingParameters);
    if (this.sharding !== void 0 && this.chunkSizes.length !== 1) {
      throw new Error("Sharding requires a single chunk size per scale");
    }
    let encoding = this.encoding = verifyObjectProperty(obj, "encoding", (x) => verifyEnumString(x, VolumeChunkEncoding$1));
    if (encoding === VolumeChunkEncoding$1.COMPRESSED_SEGMENTATION) {
      this.compressedSegmentationBlockSize = verifyObjectProperty(obj, "compressed_segmentation_block_size", (x) => parseFixedLengthArray(create$3(), x, verifyPositiveInt));
    }
    this.key = verifyObjectProperty(obj, "key", verifyString);
  }
}
function parseMultiscaleVolumeInfo(obj) {
  verifyObject(obj);
  const dataType = verifyObjectProperty(obj, "data_type", (x) => verifyEnumString(x, DataType));
  const numChannels = verifyObjectProperty(obj, "num_channels", verifyPositiveInt);
  const volumeType = verifyObjectProperty(obj, "type", (x) => verifyEnumString(x, VolumeType));
  const mesh = verifyObjectProperty(obj, "mesh", verifyOptionalString);
  const skeletons = verifyObjectProperty(obj, "skeletons", verifyOptionalString);
  const segmentPropertyMap = verifyObjectProperty(obj, "segment_properties", verifyOptionalString);
  const scaleInfos = verifyObjectProperty(obj, "scales", (x) => parseArray(x, (y) => new ScaleInfo(y, numChannels)));
  if (scaleInfos.length === 0) throw new Error("Expected at least one scale");
  const baseScale = scaleInfos[0];
  const rank = numChannels === 1 ? 3 : 4;
  const scales = new Float64Array(rank);
  const lowerBounds = new Float64Array(rank);
  const upperBounds = new Float64Array(rank);
  const names = ["x", "y", "z"];
  const units = ["m", "m", "m"];
  for (let i = 0; i < 3; ++i) {
    scales[i] = baseScale.resolution[i] / 1e9;
    lowerBounds[i] = baseScale.voxelOffset[i];
    upperBounds[i] = lowerBounds[i] + baseScale.size[i];
  }
  if (rank === 4) {
    scales[3] = 1;
    upperBounds[3] = numChannels;
    names[3] = "c^";
    units[3] = "";
  }
  const box2 = { lowerBounds, upperBounds };
  const modelSpace = makeCoordinateSpace({
    rank,
    names,
    units,
    scales,
    boundingBoxes: [makeIdentityTransformedBoundingBox(box2)]
  });
  return {
    dataType,
    volumeType,
    mesh,
    skeletons,
    segmentPropertyMap,
    scales: scaleInfos,
    modelSpace
  };
}
class PrecomputedMultiscaleVolumeChunkSource extends MultiscaleVolumeChunkSource$3 {
  constructor(chunkManager, credentialsProvider, url, info) {
    super(chunkManager);
    this.credentialsProvider = credentialsProvider;
    this.url = url;
    this.info = info;
  }
  get dataType() {
    return this.info.dataType;
  }
  get volumeType() {
    return this.info.volumeType;
  }
  get rank() {
    return this.info.modelSpace.rank;
  }
  getSources(volumeSourceOptions) {
    const modelResolution = this.info.scales[0].resolution;
    const rank = this.rank;
    return transposeNestedArrays(this.info.scales.map((scaleInfo) => {
      const resolution = scaleInfo.resolution;
      const stride = rank + 1;
      const chunkToMultiscaleTransform = new Float32Array(stride * stride);
      chunkToMultiscaleTransform[chunkToMultiscaleTransform.length - 1] = 1;
      var _info$modelSpace$boun = this.info.modelSpace.boundingBoxes[0].box;
      const baseLowerBound = _info$modelSpace$boun.lowerBounds, baseUpperBound = _info$modelSpace$boun.upperBounds;
      const lowerClipBound = new Float32Array(rank);
      const upperClipBound = new Float32Array(rank);
      for (let i = 0; i < 3; ++i) {
        const relativeScale = resolution[i] / modelResolution[i];
        chunkToMultiscaleTransform[stride * i + i] = relativeScale;
        const voxelOffsetValue = scaleInfo.voxelOffset[i];
        chunkToMultiscaleTransform[stride * rank + i] = voxelOffsetValue * relativeScale;
        lowerClipBound[i] = baseLowerBound[i] / relativeScale - voxelOffsetValue;
        upperClipBound[i] = baseUpperBound[i] / relativeScale - voxelOffsetValue;
      }
      if (rank === 4) {
        chunkToMultiscaleTransform[stride * 3 + 3] = 1;
        lowerClipBound[3] = baseLowerBound[3];
        upperClipBound[3] = baseUpperBound[3];
      }
      return makeDefaultVolumeChunkSpecifications({
        rank,
        dataType: this.dataType,
        chunkToMultiscaleTransform,
        upperVoxelBound: scaleInfo.size,
        volumeType: this.volumeType,
        chunkDataSizes: scaleInfo.chunkSizes,
        baseVoxelOffset: scaleInfo.voxelOffset,
        compressedSegmentationBlockSize: scaleInfo.compressedSegmentationBlockSize,
        volumeSourceOptions
      }).map((spec) => ({
        chunkSource: this.chunkManager.getChunkSource(PrecomputedVolumeChunkSource, {
          credentialsProvider: this.credentialsProvider,
          spec,
          parameters: {
            url: resolvePath(this.url, scaleInfo.key),
            encoding: scaleInfo.encoding,
            sharding: scaleInfo.sharding
          }
        }),
        chunkToMultiscaleTransform,
        lowerClipBound,
        upperClipBound
      }));
    }));
  }
}
const MultiscaleAnnotationSourceBase = WithParameters(WithCredentialsProvider()(MultiscaleAnnotationSource), AnnotationSourceParameters4);
class PrecomputedAnnotationSpatialIndexSource extends WithParameters(WithCredentialsProvider()(AnnotationGeometryChunkSource), AnnotationSpatialIndexSourceParameters2) {
}
class PrecomputedAnnotationSource extends MultiscaleAnnotationSourceBase {
  constructor(chunkManager, options) {
    const parameters = options.parameters;
    super(chunkManager, {
      rank: parameters.rank,
      relationships: parameters.relationships.map((x) => x.name),
      properties: parameters.properties,
      parameters
    });
    this.readonly = true;
    this.metadata = options.metadata;
    this.credentialsProvider = options.credentialsProvider;
  }
  getSources() {
    return [this.metadata.spatialIndices.map((spatialIndexLevel) => {
      const spec = spatialIndexLevel.spec;
      return {
        chunkSource: this.chunkManager.getChunkSource(PrecomputedAnnotationSpatialIndexSource, {
          credentialsProvider: this.credentialsProvider,
          parent: this,
          spec,
          parameters: spatialIndexLevel.parameters
        }),
        chunkToMultiscaleTransform: spec.chunkToMultiscaleTransform
      };
    })];
  }
}
function getLegacyMeshSource(chunkManager, credentialsProvider, parameters) {
  return chunkManager.getChunkSource(PrecomputedMeshSource, { parameters, credentialsProvider });
}
function parseTransform(data) {
  return verifyObjectProperty(data, "transform", (value) => {
    const transform = create$4();
    if (value !== void 0) {
      parseFixedLengthArray(transform.subarray(0, 12), value, verifyFiniteFloat);
    }
    transpose(transform, transform);
    return transform;
  });
}
function parseMeshMetadata(data) {
  verifyObject(data);
  const t = verifyObjectProperty(data, "@type", verifyString);
  let metadata;
  if (t === "neuroglancer_legacy_mesh") {
    metadata = void 0;
  } else if (t !== "neuroglancer_multilod_draco") {
    throw new Error(`Unsupported mesh type: ${_JSON$stringify(t)}`);
  } else {
    const lodScaleMultiplier = verifyObjectProperty(data, "lod_scale_multiplier", verifyFinitePositiveFloat);
    const vertexQuantizationBits = verifyObjectProperty(data, "vertex_quantization_bits", verifyPositiveInt);
    const transform = parseTransform(data);
    const sharding = verifyObjectProperty(data, "sharding", parseShardingParameters);
    metadata = { lodScaleMultiplier, transform, sharding, vertexQuantizationBits };
  }
  const segmentPropertyMap = verifyObjectProperty(data, "segment_properties", verifyOptionalString);
  return { metadata, segmentPropertyMap };
}
async function getMeshMetadata(chunkManager, credentialsProvider, url) {
  let metadata;
  try {
    metadata = await getJsonMetadata(chunkManager, credentialsProvider, url);
  } catch (e) {
    if (isNotFoundError(e)) {
      return { metadata: void 0 };
    }
    throw e;
  }
  return parseMeshMetadata(metadata);
}
function parseShardingEncoding(y) {
  if (y === void 0) return DataEncoding.RAW;
  return verifyEnumString(y, DataEncoding);
}
function parseShardingParameters(shardingData) {
  if (shardingData === void 0) return void 0;
  verifyObject(shardingData);
  const t = verifyObjectProperty(shardingData, "@type", verifyString);
  if (t !== "neuroglancer_uint64_sharded_v1") {
    throw new Error(`Unsupported sharding format: ${_JSON$stringify(t)}`);
  }
  const hash = verifyObjectProperty(shardingData, "hash", (y) => verifyEnumString(y, ShardingHashFunction));
  const preshiftBits = verifyObjectProperty(shardingData, "preshift_bits", verifyInt);
  const shardBits = verifyObjectProperty(shardingData, "shard_bits", verifyInt);
  const minishardBits = verifyObjectProperty(shardingData, "minishard_bits", verifyInt);
  const minishardIndexEncoding = verifyObjectProperty(shardingData, "minishard_index_encoding", parseShardingEncoding);
  const dataEncoding = verifyObjectProperty(shardingData, "data_encoding", parseShardingEncoding);
  return { hash, preshiftBits, shardBits, minishardBits, minishardIndexEncoding, dataEncoding };
}
function parseSkeletonMetadata(data) {
  verifyObject(data);
  const t = verifyObjectProperty(data, "@type", verifyString);
  if (t !== "neuroglancer_skeletons") {
    throw new Error(`Unsupported skeleton type: ${_JSON$stringify(t)}`);
  }
  const transform = parseTransform(data);
  const vertexAttributes = new _Map();
  verifyObjectProperty(data, "vertex_attributes", (attributes) => {
    if (attributes === void 0) return;
    parseArray(attributes, (attributeData) => {
      verifyObject(attributeData);
      const id = verifyObjectProperty(attributeData, "id", verifyString);
      if (id === "") throw new Error("vertex attribute id must not be empty");
      if (vertexAttributes.has(id)) {
        throw new Error(`duplicate vertex attribute id ${_JSON$stringify(id)}`);
      }
      const dataType = verifyObjectProperty(attributeData, "data_type", (y) => verifyEnumString(y, DataType));
      const numComponents = verifyObjectProperty(attributeData, "num_components", verifyPositiveInt);
      vertexAttributes.set(id, { dataType, numComponents });
    });
  });
  const sharding = verifyObjectProperty(data, "sharding", parseShardingParameters);
  const segmentPropertyMap = verifyObjectProperty(data, "segment_properties", verifyOptionalString);
  return {
    metadata: { transform, vertexAttributes, sharding },
    segmentPropertyMap
  };
}
async function getSkeletonMetadata(chunkManager, credentialsProvider, url) {
  const metadata = await getJsonMetadata(chunkManager, credentialsProvider, url);
  return parseSkeletonMetadata(metadata);
}
function getDefaultCoordinateSpace() {
  return makeCoordinateSpace({ names: ["x", "y", "z"], units: ["m", "m", "m"], scales: Float64Array.of(1e-9, 1e-9, 1e-9) });
}
async function getMeshSource(chunkManager, credentialsProvider, url) {
  var _ref = await getMeshMetadata(chunkManager, credentialsProvider, url);
  const metadata = _ref.metadata, segmentPropertyMap = _ref.segmentPropertyMap;
  if (metadata === void 0) {
    return {
      source: getLegacyMeshSource(chunkManager, credentialsProvider, { url, lod: 0 }),
      transform: create$4(),
      segmentPropertyMap
    };
  }
  let vertexPositionFormat;
  const vertexQuantizationBits = metadata.vertexQuantizationBits;
  if (vertexQuantizationBits === 10) {
    vertexPositionFormat = VertexPositionFormat.uint10;
  } else if (vertexQuantizationBits === 16) {
    vertexPositionFormat = VertexPositionFormat.uint16;
  } else {
    throw new Error(`Invalid vertex quantization bits: ${vertexQuantizationBits}`);
  }
  return {
    source: chunkManager.getChunkSource(PrecomputedMultiscaleMeshSource, {
      credentialsProvider,
      parameters: { url, metadata },
      format: {
        fragmentRelativeVertices: true,
        vertexPositionFormat
      }
    }),
    transform: metadata.transform,
    segmentPropertyMap
  };
}
async function getSkeletonSource(chunkManager, credentialsProvider, url) {
  var _ref2 = await getSkeletonMetadata(chunkManager, credentialsProvider, url);
  const metadata = _ref2.metadata, segmentPropertyMap = _ref2.segmentPropertyMap;
  return {
    source: chunkManager.getChunkSource(PrecomputedSkeletonSource, {
      credentialsProvider,
      parameters: {
        url,
        metadata
      }
    }),
    transform: metadata.transform,
    segmentPropertyMap
  };
}
function getJsonMetadata(chunkManager, credentialsProvider, url) {
  return chunkManager.memoize.getUncounted({ "type": "precomputed:metadata", url, credentialsProvider: getObjectId(credentialsProvider) }, async () => {
    return await cancellableFetchSpecialOk(credentialsProvider, `${url}/info`, {}, responseJson);
  });
}
function getSubsourceToModelSubspaceTransform(info) {
  const m = create$4();
  const resolution = info.scales[0].resolution;
  for (let i = 0; i < 3; ++i) {
    m[5 * i] = 1 / resolution[i];
  }
  return m;
}
async function getVolumeDataSource(options, credentialsProvider, url, metadata) {
  const info = parseMultiscaleVolumeInfo(metadata);
  const volume = new PrecomputedMultiscaleVolumeChunkSource(options.chunkManager, credentialsProvider, url, info);
  const modelSpace = info.modelSpace;
  const subsources = [{
    id: "default",
    default: true,
    subsource: { volume }
  }, {
    id: "bounds",
    default: true,
    subsource: {
      staticAnnotations: makeDataBoundsBoundingBoxAnnotationSet(modelSpace.bounds)
    }
  }];
  if (info.segmentPropertyMap !== void 0) {
    const mapUrl = resolvePath(url, info.segmentPropertyMap);
    const metadata2 = await getJsonMetadata(options.chunkManager, credentialsProvider, mapUrl);
    const segmentPropertyMap = getSegmentPropertyMap(options.chunkManager, credentialsProvider, metadata2);
    subsources.push({
      id: "properties",
      default: true,
      subsource: { segmentPropertyMap }
    });
  }
  if (info.mesh !== void 0) {
    const meshUrl = resolvePath(url, info.mesh);
    var _ref3 = await getMeshSource(options.chunkManager, credentialsProvider, meshUrl);
    const meshSource = _ref3.source, transform = _ref3.transform;
    const subsourceToModelSubspaceTransform = getSubsourceToModelSubspaceTransform(info);
    multiply$3(subsourceToModelSubspaceTransform, subsourceToModelSubspaceTransform, transform);
    subsources.push({
      id: "mesh",
      default: true,
      subsource: { mesh: meshSource },
      subsourceToModelSubspaceTransform
    });
  }
  if (info.skeletons !== void 0) {
    const skeletonsUrl = resolvePath(url, info.skeletons);
    var _ref4 = await getSkeletonSource(options.chunkManager, credentialsProvider, skeletonsUrl);
    const skeletonSource = _ref4.source, transform = _ref4.transform;
    const subsourceToModelSubspaceTransform = getSubsourceToModelSubspaceTransform(info);
    multiply$3(subsourceToModelSubspaceTransform, subsourceToModelSubspaceTransform, transform);
    subsources.push({
      id: "skeletons",
      default: true,
      subsource: { mesh: skeletonSource },
      subsourceToModelSubspaceTransform
    });
  }
  return { modelTransform: makeIdentityTransform(modelSpace), subsources };
}
async function getSkeletonsDataSource(options, credentialsProvider, url) {
  var _ref5 = await getSkeletonSource(options.chunkManager, credentialsProvider, url);
  const skeletons = _ref5.source, transform = _ref5.transform, segmentPropertyMap = _ref5.segmentPropertyMap;
  const subsources = [{
    id: "default",
    default: true,
    subsource: { mesh: skeletons },
    subsourceToModelSubspaceTransform: transform
  }];
  if (segmentPropertyMap !== void 0) {
    const mapUrl = resolvePath(url, segmentPropertyMap);
    const metadata = await getJsonMetadata(options.chunkManager, credentialsProvider, mapUrl);
    const segmentPropertyMapData = getSegmentPropertyMap(options.chunkManager, credentialsProvider, metadata);
    subsources.push({
      id: "properties",
      default: true,
      subsource: { segmentPropertyMap: segmentPropertyMapData }
    });
  }
  return {
    modelTransform: makeIdentityTransform(getDefaultCoordinateSpace()),
    subsources
  };
}
function parseKeyAndShardingSpec(url, obj) {
  verifyObject(obj);
  return {
    url: resolvePath(url, verifyObjectProperty(obj, "key", verifyString)),
    sharding: verifyObjectProperty(obj, "sharding", parseShardingParameters)
  };
}
class AnnotationMetadata {
  constructor(url, metadata) {
    this.url = url;
    verifyObject(metadata);
    const baseCoordinateSpace = verifyObjectProperty(metadata, "dimensions", coordinateSpaceFromJson);
    const rank = baseCoordinateSpace.rank;
    const lowerBounds = verifyObjectProperty(metadata, "lower_bound", (boundJson) => parseFixedLengthArray(new Float64Array(rank), boundJson, verifyFiniteFloat));
    const upperBounds = verifyObjectProperty(metadata, "upper_bound", (boundJson) => parseFixedLengthArray(new Float64Array(rank), boundJson, verifyFiniteFloat));
    this.coordinateSpace = makeCoordinateSpace({
      rank,
      names: baseCoordinateSpace.names,
      units: baseCoordinateSpace.units,
      scales: baseCoordinateSpace.scales,
      boundingBoxes: [makeIdentityTransformedBoundingBox({ lowerBounds, upperBounds })]
    });
    this.parameters = {
      type: verifyObjectProperty(metadata, "annotation_type", (typeObj) => verifyEnumString(typeObj, AnnotationType)),
      rank,
      relationships: verifyObjectProperty(metadata, "relationships", (relsObj) => parseArray(relsObj, (relObj) => {
        const common = parseKeyAndShardingSpec(url, relObj);
        const name2 = verifyObjectProperty(relObj, "id", verifyString);
        return _Object$assign(_Object$assign({}, common), { name: name2 });
      })),
      properties: verifyObjectProperty(metadata, "properties", parseAnnotationPropertySpecs),
      byId: verifyObjectProperty(metadata, "by_id", (obj) => parseKeyAndShardingSpec(url, obj))
    };
    this.spatialIndices = verifyObjectProperty(metadata, "spatial", (spatialObj) => parseArray(spatialObj, (levelObj) => {
      const common = parseKeyAndShardingSpec(url, levelObj);
      const gridShape = verifyObjectProperty(levelObj, "grid_shape", (j) => parseFixedLengthArray(new Float32Array(rank), j, verifyPositiveInt));
      const chunkShape = verifyObjectProperty(levelObj, "chunk_size", (j) => parseFixedLengthArray(new Float32Array(rank), j, verifyFinitePositiveFloat));
      const limit = verifyObjectProperty(levelObj, "limit", verifyPositiveInt);
      const gridShapeInVoxels = new Float32Array(rank);
      for (let i = 0; i < rank; ++i) {
        gridShapeInVoxels[i] = gridShape[i] * chunkShape[i];
      }
      const chunkToMultiscaleTransform = createIdentity(Float32Array, rank + 1);
      for (let i = 0; i < rank; ++i) {
        chunkToMultiscaleTransform[(rank + 1) * rank + i] = lowerBounds[i];
      }
      const spec = _Object$assign({
        limit,
        chunkToMultiscaleTransform
      }, makeSliceViewChunkSpecification({
        rank,
        chunkDataSize: chunkShape,
        upperVoxelBound: gridShapeInVoxels
      }));
      spec.upperChunkBound = gridShape;
      return {
        parameters: common,
        spec,
        limit
      };
    }));
    this.spatialIndices.reverse();
  }
}
async function getAnnotationDataSource(options, credentialsProvider, url, metadata) {
  const info = new AnnotationMetadata(url, metadata);
  const dataSource = {
    modelTransform: makeIdentityTransform(info.coordinateSpace),
    subsources: [{
      id: "default",
      default: true,
      subsource: {
        annotation: options.chunkManager.getChunkSource(PrecomputedAnnotationSource, {
          credentialsProvider,
          metadata: info,
          parameters: info.parameters
        })
      }
    }]
  };
  return dataSource;
}
async function getMeshDataSource(options, credentialsProvider, url) {
  var _ref6 = await getMeshSource(options.chunkManager, credentialsProvider, url);
  const mesh = _ref6.source, transform = _ref6.transform, segmentPropertyMap = _ref6.segmentPropertyMap;
  const subsources = [{
    id: "default",
    default: true,
    subsource: { mesh },
    subsourceToModelSubspaceTransform: transform
  }];
  if (segmentPropertyMap !== void 0) {
    const mapUrl = resolvePath(url, segmentPropertyMap);
    const metadata = await getJsonMetadata(options.chunkManager, credentialsProvider, mapUrl);
    const segmentPropertyMapData = getSegmentPropertyMap(options.chunkManager, credentialsProvider, metadata);
    subsources.push({
      id: "properties",
      default: true,
      subsource: { segmentPropertyMap: segmentPropertyMapData }
    });
  }
  return {
    modelTransform: makeIdentityTransform(getDefaultCoordinateSpace()),
    subsources
  };
}
function parseInlinePropertyMap(data) {
  verifyObject(data);
  const tempUint642 = new Uint64();
  const ids = verifyObjectProperty(data, "ids", (idsObj) => {
    idsObj = verifyStringArray(idsObj);
    const numIds2 = idsObj.length;
    const ids2 = new Uint32Array(numIds2 * 2);
    for (let i = 0; i < numIds2; ++i) {
      if (!tempUint642.tryParseString(idsObj[i])) {
        throw new Error(`Invalid uint64 id: ${_JSON$stringify(idsObj[i])}`);
      }
      ids2[2 * i] = tempUint642.low;
      ids2[2 * i + 1] = tempUint642.high;
    }
    return ids2;
  });
  const numIds = ids.length / 2;
  const properties = verifyObjectProperty(data, "properties", (propertiesObj) => parseArray(propertiesObj, (propertyObj) => {
    verifyObject(propertyObj);
    const id = verifyObjectProperty(propertyObj, "id", verifyString);
    const description = verifyOptionalObjectProperty(propertyObj, "description", verifyString);
    const type = verifyObjectProperty(propertyObj, "type", (type2) => {
      if (type2 !== "label" && type2 !== "description" && type2 !== "string" && type2 !== "tags" && type2 !== "number") {
        throw new Error(`Invalid property type: ${_JSON$stringify(type2)}`);
      }
      return type2;
    });
    if (type === "tags") {
      const tags = verifyObjectProperty(propertyObj, "tags", verifyStringArray);
      let tagDescriptions = verifyOptionalObjectProperty(propertyObj, "tag_descriptions", verifyStringArray);
      if (tagDescriptions === void 0) {
        tagDescriptions = new Array(tags.length);
        tagDescriptions.fill("");
      } else {
        if (tagDescriptions.length !== tags.length) {
          throw new Error(`Expected tag_descriptions to have length: ${tags.length}`);
        }
      }
      const values3 = verifyObjectProperty(propertyObj, "values", (valuesObj) => {
        if (!Array.isArray(valuesObj) || valuesObj.length !== numIds) {
          throw new Error(`Expected ${numIds} values, but received: ${valuesObj.length}`);
        }
        return valuesObj.map((tagIndices) => {
          return String.fromCharCode(...tagIndices);
        });
      });
      return { id, description, type, tags, tagDescriptions, values: values3 };
    }
    if (type === "number") {
      const dataType = verifyObjectProperty(propertyObj, "data_type", (x) => verifyEnumString(x, DataType));
      if (dataType === DataType.UINT64) {
        throw new Error("uint64 properties not supported");
      }
      const values3 = verifyObjectProperty(propertyObj, "values", (valuesObj) => {
        if (!Array.isArray(valuesObj) || valuesObj.length !== numIds) {
          throw new Error(`Expected ${numIds} values, but received: ${valuesObj.length}`);
        }
        return DATA_TYPE_ARRAY_CONSTRUCTOR[dataType].from(valuesObj);
      });
      let min2 = Infinity, max = -Infinity;
      for (let i = values3.length - 1; i >= 0; --i) {
        const v = values3[i];
        if (v < min2) min2 = v;
        if (v > max) max = v;
      }
      return { id, description, type, dataType, values: values3, bounds: [min2, max] };
    }
    const values2 = verifyObjectProperty(propertyObj, "values", (valuesObj) => {
      verifyStringArray(valuesObj);
      if (valuesObj.length !== numIds) {
        throw new Error(`Expected ${numIds} values, but received: ${valuesObj.length}`);
      }
      return valuesObj;
    });
    return { id, description, type, values: values2 };
  }));
  return normalizeInlineSegmentPropertyMap({ ids, properties });
}
WithParameters(WithCredentialsProvider()(IndexedSegmentPropertySource), IndexedSegmentPropertySourceParameters);
function getSegmentPropertyMap(chunkManager, credentialsProvider, data, url) {
  try {
    const t = verifyObjectProperty(data, "@type", verifyString);
    if (t !== "neuroglancer_segment_properties") {
      throw new Error(`Unsupported segment property map type: ${_JSON$stringify(t)}`);
    }
    const inlineProperties = verifyOptionalObjectProperty(data, "inline", parseInlinePropertyMap);
    return new SegmentPropertyMap({ inlineProperties });
  } catch (e) {
    throw new Error(`Error parsing segment property map: ${e.message}`);
  }
}
async function getSegmentPropertyMapDataSource(options, credentialsProvider, url, metadata) {
  return {
    modelTransform: makeIdentityTransform(emptyValidCoordinateSpace),
    subsources: [{
      id: "default",
      default: true,
      subsource: {
        segmentPropertyMap: getSegmentPropertyMap(options.chunkManager, credentialsProvider, metadata)
      }
    }]
  };
}
const urlPattern = /^([^#]*)(?:#(.*))?$/;
function parseProviderUrl(providerUrl) {
  var _providerUrl$match = providerUrl.match(urlPattern), _providerUrl$match2 = _slicedToArray(_providerUrl$match, 3);
  let url = _providerUrl$match2[1], fragment = _providerUrl$match2[2];
  if (url.endsWith("/")) {
    url = url.substring(0, url.length - 1);
  }
  const parameters = parseQueryStringParameters(fragment || "");
  return { url, parameters };
}
function unparseProviderUrl(url, parameters) {
  const fragment = unparseQueryStringParameters(parameters);
  if (fragment) {
    url += `#${fragment}`;
  }
  return url;
}
class PrecomputedDataSource extends DataSourceProvider {
  get description() {
    return "Precomputed file-backed data source";
  }
  normalizeUrl(options) {
    var _parseProviderUrl = parseProviderUrl(options.providerUrl);
    const url = _parseProviderUrl.url, parameters = _parseProviderUrl.parameters;
    return options.providerProtocol + "://" + unparseProviderUrl(url, parameters);
  }
  convertLegacyUrl(options) {
    var _parseProviderUrl2 = parseProviderUrl(options.providerUrl);
    const url = _parseProviderUrl2.url, parameters = _parseProviderUrl2.parameters;
    if (options.type === "mesh") {
      parameters["type"] = "mesh";
    }
    return options.providerProtocol + "://" + unparseProviderUrl(url, parameters);
  }
  get(options) {
    var _parseProviderUrl3 = parseProviderUrl(options.providerUrl);
    const providerUrl = _parseProviderUrl3.url, parameters = _parseProviderUrl3.parameters;
    return options.chunkManager.memoize.getUncounted({ "type": "precomputed:get", providerUrl, parameters }, async () => {
      var _parseSpecialUrl = parseSpecialUrl(providerUrl, options.credentialsManager);
      const url = _parseSpecialUrl.url, credentialsProvider = _parseSpecialUrl.credentialsProvider;
      let metadata;
      try {
        metadata = await getJsonMetadata(options.chunkManager, credentialsProvider, url);
      } catch (e) {
        if (isNotFoundError(e)) {
          if (parameters["type"] === "mesh") {
            return await getMeshDataSource(options, credentialsProvider, url);
          }
        }
        throw e;
      }
      verifyObject(metadata);
      const redirect = verifyOptionalObjectProperty(metadata, "redirect", verifyString);
      if (redirect !== void 0) {
        throw new RedirectError(redirect);
      }
      const t = verifyOptionalObjectProperty(metadata, "@type", verifyString);
      switch (t) {
        case "neuroglancer_skeletons":
          return await getSkeletonsDataSource(options, credentialsProvider, url);
        case "neuroglancer_multilod_draco":
        case "neuroglancer_legacy_mesh":
          return await getMeshDataSource(options, credentialsProvider, url);
        case "neuroglancer_annotations_v1":
          return await getAnnotationDataSource(options, credentialsProvider, url, metadata);
        case "neuroglancer_segment_properties":
          return await getSegmentPropertyMapDataSource(options, credentialsProvider, url, metadata);
        case "neuroglancer_multiscale_volume":
        case void 0:
          return await getVolumeDataSource(options, credentialsProvider, url, metadata);
        default:
          throw new Error(`Invalid type: ${_JSON$stringify(t)}`);
      }
    });
  }
  completeUrl(options) {
    return completeHttpPath(options.credentialsManager, options.providerUrl, options.cancellationToken);
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerProvider("precomputed", () => new PrecomputedDataSource());
var objectDestructuringEmpty = {};
var hasRequiredObjectDestructuringEmpty;
function requireObjectDestructuringEmpty() {
  if (hasRequiredObjectDestructuringEmpty) return objectDestructuringEmpty;
  hasRequiredObjectDestructuringEmpty = 1;
  objectDestructuringEmpty.__esModule = true;
  objectDestructuringEmpty.default = function(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  };
  return objectDestructuringEmpty;
}
var objectDestructuringEmptyExports = requireObjectDestructuringEmpty();
const _objectDestructuringEmpty = /* @__PURE__ */ getDefaultExportFromCjs(objectDestructuringEmptyExports);
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VolumeChunkEncoding;
(function(VolumeChunkEncoding2) {
  VolumeChunkEncoding2[VolumeChunkEncoding2["RAW"] = 0] = "RAW";
  VolumeChunkEncoding2[VolumeChunkEncoding2["GZIP"] = 1] = "GZIP";
  VolumeChunkEncoding2[VolumeChunkEncoding2["BLOSC"] = 2] = "BLOSC";
})(VolumeChunkEncoding || (VolumeChunkEncoding = {}));
let VolumeChunkSourceParameters$1 = class VolumeChunkSourceParameters3 {
};
VolumeChunkSourceParameters$1.RPC_ID = "n5/VolumeChunkSource";
class N5VolumeChunkSource extends WithParameters(WithCredentialsProvider()(VolumeChunkSource), VolumeChunkSourceParameters$1) {
}
let MultiscaleVolumeChunkSource$1 = class MultiscaleVolumeChunkSource3 extends MultiscaleVolumeChunkSource$3 {
  constructor(chunkManager, credentialsProvider, multiscaleMetadata, scales) {
    super(chunkManager);
    this.credentialsProvider = credentialsProvider;
    this.multiscaleMetadata = multiscaleMetadata;
    this.scales = scales;
    let dataType;
    let baseScaleIndex;
    scales.forEach((scale2, i) => {
      if (scale2 === void 0) return;
      if (baseScaleIndex === void 0) {
        baseScaleIndex = i;
      }
      if (dataType !== void 0 && scale2.dataType !== dataType) {
        throw new Error(`Scale s${i} has data type ${DataType[scale2.dataType]} but expected ${DataType[dataType]}.`);
      }
      dataType = scale2.dataType;
    });
    if (dataType === void 0) {
      throw new Error(`At least one scale must be specified.`);
    }
    const baseDownsamplingInfo = multiscaleMetadata.scales[baseScaleIndex];
    const baseScale = scales[baseScaleIndex];
    this.dataType = dataType;
    this.volumeType = VolumeType.IMAGE;
    this.baseScaleIndex = baseScaleIndex;
    const baseModelSpace = multiscaleMetadata.modelSpace;
    const rank = baseModelSpace.rank;
    this.modelSpace = makeCoordinateSpace({
      names: baseModelSpace.names,
      scales: baseModelSpace.scales,
      units: baseModelSpace.units,
      boundingBoxes: [{
        transform: createHomogeneousScaleMatrix(
          Float64Array,
          baseDownsamplingInfo.downsamplingFactor,
          /*square=*/
          false
        ),
        box: {
          lowerBounds: new Float64Array(rank),
          upperBounds: new Float64Array(baseScale.size)
        }
      }],
      coordinateArrays: baseModelSpace.coordinateArrays
    });
  }
  get rank() {
    return this.modelSpace.rank;
  }
  getSources(volumeSourceOptions) {
    _objectDestructuringEmpty(this);
    const scales = this.scales, rank = this.rank;
    const scalesDownsamplingInfo = this.multiscaleMetadata.scales;
    return transposeNestedArrays(scales.filter((scale2) => scale2 !== void 0).map((scale2, i) => {
      const scaleDownsamplingInfo = scalesDownsamplingInfo[i];
      const transform = createHomogeneousScaleMatrix(Float32Array, scaleDownsamplingInfo.downsamplingFactor);
      return makeDefaultVolumeChunkSpecifications({
        rank,
        chunkToMultiscaleTransform: transform,
        dataType: scale2.dataType,
        upperVoxelBound: scale2.size,
        volumeType: this.volumeType,
        chunkDataSizes: [scale2.chunkSize],
        volumeSourceOptions
      }).map((spec) => ({
        chunkSource: this.chunkManager.getChunkSource(N5VolumeChunkSource, {
          credentialsProvider: this.credentialsProvider,
          spec,
          parameters: { url: scaleDownsamplingInfo.url, encoding: scale2.encoding }
        }),
        chunkToMultiscaleTransform: transform
      }));
    }));
  }
};
class ScaleMetadata {
  constructor(obj) {
    verifyObject(obj);
    this.dataType = verifyObjectProperty(obj, "dataType", (x) => verifyEnumString(x, DataType));
    this.size = Float32Array.from(verifyObjectProperty(obj, "dimensions", (x) => parseArray(x, verifyPositiveInt)));
    this.chunkSize = verifyObjectProperty(obj, "blockSize", (x) => parseFixedLengthArray(new Uint32Array(this.size.length), x, verifyPositiveInt));
    let encoding;
    verifyOptionalObjectProperty(obj, "compression", (compression) => {
      encoding = verifyObjectProperty(compression, "type", (x) => verifyEnumString(x, VolumeChunkEncoding));
    });
    if (encoding === void 0) {
      encoding = verifyObjectProperty(obj, "compressionType", (x) => verifyEnumString(x, VolumeChunkEncoding));
    }
    this.encoding = encoding;
  }
}
function getAllScales(chunkManager, credentialsProvider, multiscaleMetadata) {
  return _Promise.all(multiscaleMetadata.scales.map(async (scale2) => {
    const attributes = await getAttributes$1(chunkManager, credentialsProvider, scale2.url, true);
    if (attributes === void 0) return void 0;
    return new ScaleMetadata(attributes);
  }));
}
function getAttributesJsonUrls(url) {
  var _parseUrl = parseUrl(url);
  let protocol = _parseUrl.protocol, host = _parseUrl.host, path = _parseUrl.path;
  if (path.endsWith("/")) {
    path = path.substring(0, path.length - 1);
  }
  const urls = [];
  while (true) {
    urls.push(`${protocol}://${host}${path}/attributes.json`);
    const index2 = path.lastIndexOf("/");
    if (index2 === -1) break;
    path = path.substring(0, index2);
  }
  return urls;
}
function getIndividualAttributesJson(chunkManager, credentialsProvider, url, required) {
  return chunkManager.memoize.getUncounted({ type: "n5:attributes.json", url, credentialsProvider: getObjectId(credentialsProvider) }, () => cancellableFetchSpecialOk(credentialsProvider, url, {}, responseJson).then((j) => {
    try {
      return verifyObject(j);
    } catch (e) {
      throw new Error(`Error reading attributes from ${url}: ${e.message}`);
    }
  }).catch((e) => {
    if (isNotFoundError(e)) {
      if (required) return void 0;
      return {};
    }
    throw e;
  }));
}
async function getAttributes$1(chunkManager, credentialsProvider, url, required) {
  const attributesJsonUrls = getAttributesJsonUrls(url);
  const metadata = await _Promise.all(attributesJsonUrls.map((u, i) => getIndividualAttributesJson(chunkManager, credentialsProvider, u, required && i === attributesJsonUrls.length - 1)));
  if (metadata.indexOf(void 0) !== -1) return void 0;
  metadata.reverse();
  return _Object$assign({}, ...metadata);
}
function verifyRank(existing, n) {
  if (existing !== -1 && n !== existing) {
    throw new Error(`Rank mismatch, received ${n} but expected ${existing}`);
  }
  return n;
}
function parseSingleResolutionDownsamplingFactors(obj) {
  return Float64Array.from(parseArray(obj, verifyFinitePositiveFloat));
}
function parseMultiResolutionDownsamplingFactors(obj) {
  const a = expectArray(obj);
  if (a.length === 0) throw new Error("Expected non-empty array");
  let rank = -1;
  const allFactors = parseArray(a, (x) => {
    const f = parseSingleResolutionDownsamplingFactors(x);
    rank = verifyRank(rank, f.length);
    return f;
  });
  return { all: allFactors, single: void 0, rank };
}
function parseDownsamplingFactors(obj) {
  const a = expectArray(obj);
  if (a.length === 0) throw new Error("Expected non-empty array");
  if (Array.isArray(a[0])) {
    return parseMultiResolutionDownsamplingFactors(a);
  }
  const f = parseSingleResolutionDownsamplingFactors(obj);
  return { all: void 0, single: f, rank: f.length };
}
const defaultAxes = ["x", "y", "z", "t", "c"];
function getDefaultAxes(rank) {
  const axes = defaultAxes.slice(0, rank);
  while (axes.length < rank) {
    axes.push(`d${axes.length + 1}`);
  }
  return axes;
}
function getMultiscaleMetadata(url, attributes) {
  verifyObject(attributes);
  let rank = -1;
  let scales = verifyOptionalObjectProperty(attributes, "resolution", (x) => {
    const scales2 = Float64Array.from(parseArray(x, verifyFinitePositiveFloat));
    rank = verifyRank(rank, scales2.length);
    return scales2;
  });
  let axes = verifyOptionalObjectProperty(attributes, "axes", (x) => {
    const names = parseArray(x, verifyString);
    rank = verifyRank(rank, names.length);
    return names;
  });
  let units = verifyOptionalObjectProperty(attributes, "units", (x) => {
    const units2 = parseArray(x, unitFromJson);
    rank = verifyRank(rank, units2.length);
    return units2;
  });
  let defaultUnit = { unit: "m", exponent: -9 };
  let singleDownsamplingFactors;
  let allDownsamplingFactors;
  verifyOptionalObjectProperty(attributes, "downsamplingFactors", (dObj) => {
    var _parseDownsamplingFac = parseDownsamplingFactors(dObj);
    const single = _parseDownsamplingFac.single, all = _parseDownsamplingFac.all, curRank = _parseDownsamplingFac.rank;
    rank = verifyRank(rank, curRank);
    if (single !== void 0) {
      singleDownsamplingFactors = single;
    }
    if (all !== void 0) {
      allDownsamplingFactors = all;
    }
  });
  verifyOptionalObjectProperty(attributes, "pixelResolution", (resObj) => {
    defaultUnit = verifyObjectProperty(resObj, "unit", unitFromJson);
    verifyOptionalObjectProperty(resObj, "dimensions", (scalesObj) => {
      scales = Float64Array.from(parseArray(scalesObj, verifyFinitePositiveFloat));
      rank = verifyRank(rank, scales.length);
    });
  });
  verifyOptionalObjectProperty(attributes, "scales", (scalesObj) => {
    var _parseMultiResolution = parseMultiResolutionDownsamplingFactors(scalesObj);
    const all = _parseMultiResolution.all, curRank = _parseMultiResolution.rank;
    rank = verifyRank(rank, curRank);
    allDownsamplingFactors = all;
  });
  const dimensions = verifyOptionalObjectProperty(attributes, "dimensions", (x) => {
    const dimensions2 = parseArray(x, verifyPositiveInt);
    rank = verifyRank(rank, dimensions2.length);
    return dimensions2;
  });
  if (rank === -1) {
    throw new Error("Unable to determine rank of dataset");
  }
  if (units === void 0) {
    units = new Array(rank);
    units.fill(defaultUnit);
  }
  if (scales === void 0) {
    scales = new Float64Array(rank);
    scales.fill(1);
  }
  for (let i = 0; i < rank; ++i) {
    scales[i] = scaleByExp10(scales[i], units[i].exponent);
  }
  const coordinateArrays = new Array(rank);
  if (axes !== void 0) {
    verifyOptionalObjectProperty(attributes, "coordinateArrays", (coordinateArraysObj) => {
      verifyObject(coordinateArraysObj);
      for (let i = 0; i < rank; ++i) {
        const name2 = axes[i];
        if (Object.prototype.hasOwnProperty.call(coordinateArraysObj, name2)) {
          const labels = verifyStringArray(coordinateArraysObj[name2]);
          coordinateArrays[i] = {
            explicit: false,
            labels,
            coordinates: _Array$from(labels, (_, i2) => i2)
          };
          units[i] = { unit: "", exponent: 0 };
          scales[i] = 1;
        }
      }
    });
  }
  if (axes === void 0) {
    axes = getDefaultAxes(rank);
  }
  const modelSpace = makeCoordinateSpace({
    rank,
    valid: true,
    names: axes,
    scales,
    units: units.map((x) => x.unit),
    coordinateArrays
  });
  if (dimensions === void 0) {
    if (allDownsamplingFactors === void 0) {
      throw new Error("Not valid single-resolution or multi-resolution dataset");
    }
    return {
      modelSpace,
      url,
      attributes,
      scales: allDownsamplingFactors.map((f, i) => ({ url: `${url}/s${i}`, downsamplingFactor: f }))
    };
  }
  if (singleDownsamplingFactors === void 0) {
    singleDownsamplingFactors = new Float64Array(rank);
    singleDownsamplingFactors.fill(1);
  }
  return {
    modelSpace,
    url,
    attributes,
    scales: [{ url, downsamplingFactor: singleDownsamplingFactors }]
  };
}
class N5DataSource extends DataSourceProvider {
  get description() {
    return "N5 data source";
  }
  get(options) {
    let providerUrl = options.providerUrl;
    if (providerUrl.endsWith("/")) {
      providerUrl = providerUrl.substring(0, providerUrl.length - 1);
    }
    return options.chunkManager.memoize.getUncounted({ "type": "n5:MultiscaleVolumeChunkSource", providerUrl }, async () => {
      var _parseSpecialUrl = parseSpecialUrl(providerUrl, options.credentialsManager);
      const url = _parseSpecialUrl.url, credentialsProvider = _parseSpecialUrl.credentialsProvider;
      const attributes = await getAttributes$1(options.chunkManager, credentialsProvider, url, false);
      const multiscaleMetadata = getMultiscaleMetadata(url, attributes);
      const scales = await getAllScales(options.chunkManager, credentialsProvider, multiscaleMetadata);
      const volume = new MultiscaleVolumeChunkSource$1(options.chunkManager, credentialsProvider, multiscaleMetadata, scales);
      return {
        modelTransform: makeIdentityTransform(volume.modelSpace),
        subsources: [{
          id: "default",
          default: true,
          url: void 0,
          subsource: { volume }
        }, {
          id: "bounds",
          default: true,
          url: void 0,
          subsource: {
            staticAnnotations: makeDataBoundsBoundingBoxAnnotationSet(volume.modelSpace.bounds)
          }
        }]
      };
    });
  }
  completeUrl(options) {
    return completeHttpPath(options.credentialsManager, options.providerUrl, options.cancellationToken);
  }
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerProvider("n5", () => new N5DataSource());
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ZarrCompressor;
(function(ZarrCompressor2) {
  ZarrCompressor2[ZarrCompressor2["RAW"] = 0] = "RAW";
  ZarrCompressor2[ZarrCompressor2["GZIP"] = 1] = "GZIP";
  ZarrCompressor2[ZarrCompressor2["BLOSC"] = 2] = "BLOSC";
})(ZarrCompressor || (ZarrCompressor = {}));
class VolumeChunkSourceParameters4 {
}
VolumeChunkSourceParameters4.RPC_ID = "zarr/VolumeChunkSource";
const supportedDataTypes = new _Map();
supportedDataTypes.set("|u1", {
  endianness: Endianness.LITTLE,
  dataType: DataType.UINT8
});
supportedDataTypes.set("|i1", {
  endianness: Endianness.LITTLE,
  dataType: DataType.INT8
});
for (let _ref of [["<", Endianness.LITTLE], [">", Endianness.BIG]]) {
  var _ref2 = _slicedToArray(_ref, 2);
  let endiannessChar = _ref2[0];
  let endianness = _ref2[1];
  for (let typeChar of ["u", "i"]) {
    supportedDataTypes.set(`${endiannessChar}${typeChar}8`, {
      endianness,
      dataType: DataType.UINT64
    });
  }
  supportedDataTypes.set(`${endiannessChar}u2`, {
    endianness,
    dataType: DataType.UINT16
  });
  supportedDataTypes.set(`${endiannessChar}i2`, {
    endianness,
    dataType: DataType.INT16
  });
  supportedDataTypes.set(`${endiannessChar}u4`, {
    endianness,
    dataType: DataType.UINT32
  });
  supportedDataTypes.set(`${endiannessChar}i4`, {
    endianness,
    dataType: DataType.INT32
  });
  supportedDataTypes.set(`${endiannessChar}f4`, {
    endianness,
    dataType: DataType.FLOAT32
  });
}
function parseNumpyDtype(typestr) {
  const dtype = supportedDataTypes.get(typestr);
  if (dtype === void 0) {
    throw new Error(`Unsupported numpy data type: ${_JSON$stringify(typestr)}`);
  }
  return dtype;
}
class ZarrVolumeChunkSource extends WithParameters(WithCredentialsProvider()(VolumeChunkSource), VolumeChunkSourceParameters4) {
}
function parseDimensionSeparator(obj) {
  return verifyOptionalObjectProperty(obj, "dimension_separator", (value) => {
    if (value !== "." && value !== "/") {
      throw new Error(`Expected "." or "/", but received: ${_JSON$stringify(value)}`);
    }
    return value;
  });
}
function parseZarrMetadata(obj) {
  try {
    verifyObject(obj);
    verifyObjectProperty(obj, "zarr_format", (zarrFormat) => {
      if (zarrFormat !== 2) {
        throw new Error(`Expected 2 but received: ${_JSON$stringify(zarrFormat)}`);
      }
    });
    const shape = verifyObjectProperty(obj, "shape", (shape2) => parseArray(shape2, (x) => {
      if (typeof x !== "number" || !_Number$isInteger(x) || x < 0) {
        throw new Error(`Expected non-negative integer, but received: ${_JSON$stringify(x)}`);
      }
      return x;
    }));
    const chunks = verifyObjectProperty(obj, "chunks", (chunks2) => parseFixedLengthArray(new Array(shape.length), chunks2, (x) => {
      if (typeof x !== "number" || !_Number$isInteger(x) || x <= 0) {
        throw new Error(`Expected positive integer, but received: ${_JSON$stringify(x)}`);
      }
      return x;
    }));
    const order = verifyObjectProperty(obj, "order", (order2) => {
      if (order2 !== "C" && order2 !== "F") {
        throw new Error(`Expected "C" or "F", but received: ${_JSON$stringify(order2)}`);
      }
      return order2;
    });
    const dimensionSeparator = parseDimensionSeparator(obj);
    const numpyDtype = verifyObjectProperty(obj, "dtype", (dtype) => parseNumpyDtype(verifyString(dtype)));
    const compressor = verifyObjectProperty(obj, "compressor", (compressor2) => {
      if (compressor2 === null) return ZarrCompressor.RAW;
      verifyObject(compressor2);
      const id = verifyObjectProperty(compressor2, "id", verifyString);
      switch (id) {
        case "blosc":
          return ZarrCompressor.BLOSC;
        case "gzip":
          return ZarrCompressor.GZIP;
        case "zlib":
          return ZarrCompressor.GZIP;
        default:
          throw new Error(`Unsupported compressor: ${_JSON$stringify(id)}`);
      }
    });
    return {
      rank: shape.length,
      shape,
      chunks,
      order,
      dataType: numpyDtype.dataType,
      encoding: { compressor, endianness: numpyDtype.endianness },
      dimensionSeparator
    };
  } catch (e) {
    throw new Error(`Error parsing zarr metadata: ${e.message}`);
  }
}
class MultiscaleVolumeChunkSource4 extends MultiscaleVolumeChunkSource$3 {
  constructor(chunkManager, credentialsProvider, url, separator, metadata, attrs) {
    super(chunkManager);
    this.credentialsProvider = credentialsProvider;
    this.url = url;
    this.separator = separator;
    this.metadata = metadata;
    this.attrs = attrs;
    this.dataType = metadata.dataType;
    this.volumeType = VolumeType.IMAGE;
    let names = verifyOptionalObjectProperty(attrs, "_ARRAY_DIMENSIONS", (names2) => parseFixedLengthArray(new Array(metadata.rank), names2, verifyString));
    if (names === void 0) {
      names = _Array$from(metadata.shape, (_, i) => `d${i}`);
    }
    this.modelSpace = makeCoordinateSpace({
      names,
      scales: Float64Array.from(metadata.shape, () => 1),
      units: _Array$from(metadata.shape, () => ""),
      boundingBoxes: [makeIdentityTransformedBoundingBox({
        lowerBounds: new Float64Array(metadata.rank),
        upperBounds: Float64Array.from(metadata.shape)
      })]
    });
  }
  get rank() {
    return this.metadata.rank;
  }
  getSources(volumeSourceOptions) {
    const metadata = this.metadata;
    const rank = metadata.rank, chunks = metadata.chunks, shape = metadata.shape;
    let permutedChunkShape;
    let permutedDataShape;
    let transform;
    if (metadata.order === "F") {
      permutedChunkShape = Uint32Array.from(chunks);
      permutedDataShape = Float32Array.from(shape);
      transform = createIdentity(Float32Array, rank + 1);
    } else {
      permutedChunkShape = new Uint32Array(rank);
      permutedDataShape = new Float32Array(rank);
      transform = new Float32Array((rank + 1) ** 2);
      transform[(rank + 1) ** 2 - 1] = 1;
      for (let i = 0; i < rank; ++i) {
        permutedChunkShape[i] = chunks[rank - 1 - i];
        permutedDataShape[i] = shape[rank - 1 - i];
        transform[i + (rank - 1 - i) * (rank + 1)] = 1;
      }
    }
    return transposeNestedArrays([makeDefaultVolumeChunkSpecifications({
      rank,
      chunkToMultiscaleTransform: transform,
      dataType: metadata.dataType,
      upperVoxelBound: permutedDataShape,
      volumeType: this.volumeType,
      chunkDataSizes: [permutedChunkShape],
      volumeSourceOptions
    }).map((spec) => ({
      chunkSource: this.chunkManager.getChunkSource(ZarrVolumeChunkSource, {
        credentialsProvider: this.credentialsProvider,
        spec,
        parameters: {
          url: this.url,
          encoding: metadata.encoding,
          separator: this.separator
        }
      }),
      chunkToMultiscaleTransform: transform
    }))]);
  }
}
function getAttributes(chunkManager, credentialsProvider, url) {
  return chunkManager.memoize.getUncounted({ type: "zarr:.zattrs json", url, credentialsProvider: getObjectId(credentialsProvider) }, async () => {
    try {
      const json2 = await cancellableFetchSpecialOk(credentialsProvider, url + "/.zattrs", {}, responseJson);
      verifyObject(json2);
      return json2;
    } catch (e) {
      if (isNotFoundError(e)) return {};
      throw e;
    }
  });
}
function getMetadata(chunkManager, credentialsProvider, url) {
  return chunkManager.memoize.getUncounted({ type: "zarr:.zarray json", url, credentialsProvider: getObjectId(credentialsProvider) }, async () => {
    const json2 = await cancellableFetchSpecialOk(credentialsProvider, url + "/.zarray", {}, responseJson);
    return parseZarrMetadata(json2);
  });
}
const supportedQueryParameters = [{
  key: { value: "dimension_separator", description: "Dimension separator in chunk keys" },
  values: [{ value: ".", description: "(default)" }, { value: "/", description: "" }]
}];
class ZarrDataSource extends DataSourceProvider {
  get description() {
    return "Zarr data source";
  }
  get(options) {
    var _options$providerUrl$ = options.providerUrl.match(/([^?]*)(?:\?(.*))?$/), _options$providerUrl$2 = _slicedToArray(_options$providerUrl$, 3);
    let providerUrl = _options$providerUrl$2[1], query = _options$providerUrl$2[2];
    const parameters = parseQueryStringParameters(query || "");
    verifyObject(parameters);
    const dimensionSeparator = parseDimensionSeparator(parameters);
    if (providerUrl.endsWith("/")) {
      providerUrl = providerUrl.substring(0, providerUrl.length - 1);
    }
    return options.chunkManager.memoize.getUncounted({ "type": "zarr:MultiscaleVolumeChunkSource", providerUrl, dimensionSeparator }, async () => {
      var _parseSpecialUrl = parseSpecialUrl(providerUrl, options.credentialsManager);
      const url = _parseSpecialUrl.url, credentialsProvider = _parseSpecialUrl.credentialsProvider;
      var _ref = await _Promise.all([getMetadata(options.chunkManager, credentialsProvider, url), getAttributes(options.chunkManager, credentialsProvider, url)]), _ref2 = _slicedToArray(_ref, 2);
      const metadata = _ref2[0], attrs = _ref2[1];
      if (metadata.dimensionSeparator !== void 0 && dimensionSeparator !== void 0 && metadata.dimensionSeparator !== dimensionSeparator) {
        throw new Error(`Explicitly specified dimension separator ${_JSON$stringify(dimensionSeparator)} does not match value in .zarray ${_JSON$stringify(metadata.dimensionSeparator)}`);
      }
      const volume = new MultiscaleVolumeChunkSource4(options.chunkManager, credentialsProvider, url, dimensionSeparator || metadata.dimensionSeparator || ".", metadata, attrs);
      return {
        modelTransform: makeIdentityTransform(volume.modelSpace),
        subsources: [{
          id: "default",
          default: true,
          url: void 0,
          subsource: { volume }
        }, {
          id: "bounds",
          default: true,
          url: void 0,
          subsource: {
            staticAnnotations: makeDataBoundsBoundingBoxAnnotationSet(volume.modelSpace.bounds)
          }
        }]
      };
    });
  }
  async completeUrl(options) {
    var _options$providerUrl$3 = options.providerUrl.match(/([^?]*)(?:\?(.*))?$/), _options$providerUrl$4 = _slicedToArray(_options$providerUrl$3, 3);
    let query = _options$providerUrl$4[2];
    if (query !== void 0) {
      return applyCompletionOffset(options.providerUrl.length - query.length, await completeQueryStringParametersFromTable(query, supportedQueryParameters));
    }
    return await completeHttpPath(options.credentialsManager, options.providerUrl, options.cancellationToken);
  }
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerProvider("zarr", () => new ZarrDataSource());
var BLEND_MODES;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["DEFAULT"] = 0] = "DEFAULT";
  BLEND_MODES2[BLEND_MODES2["ADDITIVE"] = 1] = "ADDITIVE";
})(BLEND_MODES || (BLEND_MODES = {}));
const BLEND_FUNCTIONS = new _Map([[BLEND_MODES.DEFAULT, (gl) => {
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
}], [BLEND_MODES.ADDITIVE, (gl) => {
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
}]]);
function trackableBlendModeValue(initialValue = BLEND_MODES.DEFAULT) {
  return new TrackableEnum(BLEND_MODES, initialValue);
}
const DEFAULT_FRAGMENT_MAIN = `#uicontrol invlerp normalized
void main() {
  emitGrayscale(normalized());
}
`;
function getTrackableFragmentMain(value = DEFAULT_FRAGMENT_MAIN) {
  return makeTrackableFragmentMain(value);
}
function defineImageLayerShader(builder, shaderBuilderState) {
  builder.addFragmentCode(`
#define VOLUME_RENDERING false

void emitRGBA(vec4 rgba) {
  emit(vec4(rgba.rgb, rgba.a * uOpacity));
}
void emitRGB(vec3 rgb) {
  emit(vec4(rgb, uOpacity));
}
void emitGrayscale(float value) {
  emit(vec4(value, value, value, uOpacity));
}
void emitTransparent() {
  emit(vec4(0.0, 0.0, 0.0, 0.0));
}
`);
  builder.addFragmentCode(glsl_COLORMAPS);
  addControlsToBuilder(shaderBuilderState, builder);
  builder.setFragmentMainFunction(shaderCodeWithLineDirective(shaderBuilderState.parseResult.code));
}
class ImageRenderLayer extends SliceViewVolumeRenderLayer {
  constructor(multiscaleSource, options) {
    var _a, _b, _c;
    const opacity = options.opacity, blendMode = options.blendMode, shaderControlState = options.shaderControlState;
    super(multiscaleSource, _Object$assign(_Object$assign({}, options), { fallbackShaderParameters: new WatchableValue(getFallbackBuilderState(parseShaderUiControls(DEFAULT_FRAGMENT_MAIN, {
      imageData: {
        dataType: multiscaleSource.dataType,
        channelRank: (_c = (_b = (_a = options.channelCoordinateSpace) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.rank) !== null && _c !== void 0 ? _c : 0
      }
    }))), encodeShaderParameters: (p) => p.key, shaderParameters: shaderControlState.builderState, dataHistogramSpecifications: shaderControlState.histogramSpecifications }));
    this.shaderControlState = shaderControlState;
    this.opacity = opacity;
    this.blendMode = blendMode;
    this.registerDisposer(opacity.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(blendMode.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(shaderControlState.changed.add(this.redrawNeeded.dispatch));
  }
  defineShader(builder, shaderBuilderState) {
    if (shaderBuilderState.parseResult.errors.length !== 0) {
      throw new Error("Invalid UI control specification");
    }
    builder.addUniform("highp float", "uOpacity");
    defineImageLayerShader(builder, shaderBuilderState);
  }
  initializeShader(_sliceView, shader, parameters) {
    const gl = this.gl;
    gl.uniform1f(shader.uniform("uOpacity"), this.opacity.value);
    setControlsInShader(gl, shader, this.shaderControlState, parameters.parseResult.controls);
  }
  setGLBlendMode(gl, renderLayerNum) {
    const blendModeValue = this.blendMode.value;
    if (blendModeValue === BLEND_MODES.ADDITIVE || renderLayerNum > 0) {
      gl.enable(gl.BLEND);
      BLEND_FUNCTIONS.get(blendModeValue)(gl);
    } else {
      gl.disable(WebGL2RenderingContext.BLEND);
    }
  }
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VOLUME_RENDERING_RENDER_LAYER_RPC_ID = "volume_rendering/VolumeRenderingRenderLayer";
const VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID = "volume_rendering/VolumeRenderingRenderLayer/update";
const volumeRenderingDepthSamples = 64;
const tempMat3 = create$5();
function getVolumeRenderingNearFarBounds(clippingPlanes, displayLowerBound, displayUpperBound) {
  let volumeMinZ = 0, volumeMaxZ = 0;
  for (let i = 0; i < 3; ++i) {
    const planeCoeff = clippingPlanes[16 + i];
    const a = planeCoeff * displayLowerBound[i], b = planeCoeff * displayUpperBound[i];
    volumeMinZ += Math.min(a, b);
    volumeMaxZ += Math.max(a, b);
  }
  const near = -clippingPlanes[19];
  const adjustedNear = Math.max(near, volumeMinZ);
  const far = clippingPlanes[23];
  const adjustedFar = Math.min(far, volumeMaxZ);
  return { near, far, adjustedNear, adjustedFar };
}
function forEachVisibleVolumeRenderingChunk(projectionParameters, localPosition, renderScaleTarget, transformedSources, beginScale, callback) {
  if (transformedSources.length === 0) return;
  const viewMatrix = projectionParameters.viewMatrix, projectionMat = projectionParameters.projectionMat, displayDimensionRenderInfo = projectionParameters.displayDimensionRenderInfo;
  const voxelPhysicalScales = displayDimensionRenderInfo.voxelPhysicalScales;
  const canonicalToPhysicalScale = prod3(voxelPhysicalScales);
  const targetViewSpacing = getViewFrustrumDepthRange(projectionMat) / volumeRenderingDepthSamples;
  const targetViewVolume = targetViewSpacing ** 3;
  const viewDet = determinant(mat3FromMat4(tempMat3, viewMatrix));
  const getViewVolume = (scaleIndex) => {
    const tsource2 = transformedSources[scaleIndex];
    return Math.abs(tsource2.chunkLayout.detTransform * viewDet);
  };
  let bestScaleIndex = transformedSources.length - 1;
  let bestViewVolume = getViewVolume(bestScaleIndex);
  for (let scaleIndex = bestScaleIndex - 1; scaleIndex >= 0; --scaleIndex) {
    const viewVolume = getViewVolume(scaleIndex);
    if (Math.abs(viewVolume - targetViewVolume) < Math.abs(bestViewVolume - targetViewVolume)) {
      bestViewVolume = viewVolume;
      bestScaleIndex = scaleIndex;
    } else {
      break;
    }
  }
  const physicalSpacing = Math.pow(bestViewVolume * canonicalToPhysicalScale / viewDet, 1 / 3);
  const pixelSpacing = Math.pow(bestViewVolume, 1 / 3) * projectionParameters.width / (2 * projectionMat[0]);
  let firstChunk = true;
  const tsource = transformedSources[bestScaleIndex];
  forEachVisibleVolumetricChunk(projectionParameters, localPosition, tsource, (positionInChunks, clippingPlanes) => {
    if (firstChunk) {
      beginScale(tsource, bestScaleIndex, physicalSpacing, pixelSpacing, clippingPlanes);
      firstChunk = false;
    }
    callback(tsource, bestScaleIndex, positionInChunks);
  });
}
const tempMat4 = create$4();
const tempVisibleVolumetricClippingPlanes = new Float32Array(24);
class VolumeRenderingRenderLayer extends PerspectiveViewRenderLayer {
  constructor(options) {
    super();
    this.multiscaleSource = options.multiscaleSource;
    this.transform = options.transform;
    this.channelCoordinateSpace = options.channelCoordinateSpace;
    this.shaderControlState = options.shaderControlState;
    this.localPosition = options.localPosition;
    this.renderScaleTarget = options.renderScaleTarget;
    this.renderScaleHistogram = options.renderScaleHistogram;
    this.registerDisposer(this.renderScaleHistogram.visibility.add(this.visibility));
    const numChannelDimensions = this.registerDisposer(makeCachedDerivedWatchableValue((space) => space.rank, [this.channelCoordinateSpace]));
    this.shaderGetter = parameterizedContextDependentShaderGetter(this, this.gl, {
      memoizeKey: "VolumeRenderingRenderLayer",
      parameters: options.shaderControlState.builderState,
      getContextKey: ({ emitter, chunkFormat }) => `${getObjectId(emitter)}:${chunkFormat.shaderKey}`,
      shaderError: options.shaderError,
      extraParameters: numChannelDimensions,
      defineShader: (builder, { emitter, chunkFormat }, shaderBuilderState, numChannelDimensions2) => {
        if (shaderBuilderState.parseResult.errors.length !== 0) {
          throw new Error("Invalid UI control specification");
        }
        defineVertexId(builder);
        builder.addFragmentCode(`
#define VOLUME_RENDERING true
`);
        emitter(builder);
        builder.addUniform("highp float", "uNearLimitFraction");
        builder.addUniform("highp float", "uFarLimitFraction");
        builder.addUniform("highp int", "uMaxSteps");
        builder.addUniform("highp vec3", "uTranslation");
        builder.addUniform("highp mat4", "uModelViewProjectionMatrix");
        builder.addUniform("highp mat4", "uInvModelViewProjectionMatrix");
        builder.addUniform("highp vec3", "uChunkDataSize");
        builder.addUniform("highp vec3", "uLowerClipBound");
        builder.addUniform("highp vec3", "uUpperClipBound");
        builder.addUniform("highp float", "uBrightnessFactor");
        builder.addVarying("highp vec4", "vNormalizedPosition");
        builder.addVertexCode(glsl_getBoxFaceVertexPosition);
        builder.setVertexMain(`
vec3 boxVertex = getBoxFaceVertexPosition(gl_VertexID);
vec3 position = max(uLowerClipBound, min(uUpperClipBound, uTranslation + boxVertex * uChunkDataSize));
vNormalizedPosition = gl_Position = uModelViewProjectionMatrix * vec4(position, 1.0);
gl_Position.z = 0.0;
`);
        builder.addFragmentCode(`
vec3 curChunkPosition;
vec4 outputColor;
void userMain();
`);
        defineChunkDataShaderAccess(builder, chunkFormat, numChannelDimensions2, `curChunkPosition`);
        builder.addFragmentCode(`
void emitRGBA(vec4 rgba) {
  float alpha = rgba.a * uBrightnessFactor;
  outputColor += vec4(rgba.rgb * alpha, alpha);
}
void emitRGB(vec3 rgb) {
  emitRGBA(vec4(rgb, 1.0));
}
void emitGrayscale(float value) {
  emitRGB(vec3(value, value, value));
}
void emitTransparent() {
  emitRGBA(vec4(0.0, 0.0, 0.0, 0.0));
}
`);
        builder.setFragmentMainFunction(`
void main() {
  vec2 normalizedPosition = vNormalizedPosition.xy / vNormalizedPosition.w;
  vec4 nearPointH = uInvModelViewProjectionMatrix * vec4(normalizedPosition, -1.0, 1.0);
  vec4 farPointH = uInvModelViewProjectionMatrix * vec4(normalizedPosition, 1.0, 1.0);
  vec3 nearPoint = nearPointH.xyz / nearPointH.w;
  vec3 farPoint = farPointH.xyz / farPointH.w;
  vec3 rayVector = farPoint - nearPoint;
  vec3 boxStart = max(uLowerClipBound, uTranslation);
  vec3 boxEnd = min(boxStart + uChunkDataSize, uUpperClipBound);
  float intersectStart = uNearLimitFraction;
  float intersectEnd = uFarLimitFraction;
  for (int i = 0; i < 3; ++i) {
    float startPt = nearPoint[i];
    float endPt = farPoint[i];
    float boxLower = boxStart[i];
    float boxUpper = boxEnd[i];
    float r = rayVector[i];
    float startFraction;
    float endFraction;
    if (startPt >= boxLower && startPt <= boxUpper) {
      startFraction = 0.0;
    } else {
      startFraction = min((boxLower - startPt) / r, (boxUpper - startPt) / r);
    }
    if (endPt >= boxLower && endPt <= boxUpper) {
      endFraction = 1.0;
    } else {
      endFraction = max((boxLower - startPt) / r, (boxUpper - startPt) / r);
    }
    intersectStart = max(intersectStart, startFraction);
    intersectEnd = min(intersectEnd, endFraction);
  }
  float stepSize = (uFarLimitFraction - uNearLimitFraction) / float(uMaxSteps - 1);
  int startStep = int(floor((intersectStart - uNearLimitFraction) / stepSize));
  int endStep = min(uMaxSteps, int(floor((intersectEnd - uNearLimitFraction) / stepSize)) + 1);
  outputColor = vec4(0, 0, 0, 0);
  for (int step = startStep; step < endStep; ++step) {
    vec3 position = mix(nearPoint, farPoint, uNearLimitFraction + float(step) * stepSize);
    curChunkPosition = position - uTranslation;
    userMain();
  }
  emit(outputColor, 0u);
}
`);
        builder.addFragmentCode(glsl_COLORMAPS);
        addControlsToBuilder(shaderBuilderState, builder);
        builder.addFragmentCode(`
#define main userMain
` + shaderCodeWithLineDirective(shaderBuilderState.parseResult.code) + `
#undef main
`);
      }
    });
    this.vertexIdHelper = this.registerDisposer(VertexIdHelper.get(this.gl));
    this.registerDisposer(this.renderScaleTarget.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(this.shaderControlState.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(this.localPosition.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(this.transform.changed.add(this.redrawNeeded.dispatch));
    this.registerDisposer(this.shaderControlState.fragmentMain.changed.add(this.redrawNeeded.dispatch));
    const chunkManager = this.multiscaleSource.chunkManager;
    const sharedObject = this.registerDisposer(new ChunkRenderLayerFrontend(this.layerChunkProgressInfo));
    const rpc = chunkManager.rpc;
    sharedObject.RPC_TYPE_ID = VOLUME_RENDERING_RENDER_LAYER_RPC_ID;
    sharedObject.initializeCounterpart(rpc, {
      chunkManager: chunkManager.rpcId,
      localPosition: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.localPosition)).rpcId,
      renderScaleTarget: this.registerDisposer(SharedWatchableValue.makeFromExisting(rpc, this.renderScaleTarget)).rpcId
    });
    this.backend = sharedObject;
  }
  get gl() {
    return this.multiscaleSource.chunkManager.gl;
  }
  get isTransparent() {
    return true;
  }
  get isVolumeRendering() {
    return true;
  }
  get dataType() {
    return this.multiscaleSource.dataType;
  }
  attach(attachment) {
    super.attach(attachment);
    attachment.state = {
      sources: attachment.registerDisposer(registerNested((context, transform, displayDimensionRenderInfo) => {
        const transformedSources = getVolumetricTransformedSources(displayDimensionRenderInfo, transform, (options) => this.multiscaleSource.getSources(options), attachment.messages, this);
        for (const scales of transformedSources) {
          for (const tsource of scales) {
            context.registerDisposer(tsource.source);
          }
        }
        attachment.view.flushBackendProjectionParameters();
        this.backend.rpc.invoke(VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, {
          layer: this.backend.rpcId,
          view: attachment.view.rpcId,
          sources: serializeAllTransformedSources(transformedSources)
        });
        this.redrawNeeded.dispatch();
        return transformedSources;
      }, this.transform, attachment.view.displayDimensionRenderInfo))
    };
  }
  get chunkManager() {
    return this.multiscaleSource.chunkManager;
  }
  draw(renderContext, attachment) {
    if (!renderContext.emitColor) return;
    const allSources = attachment.state.sources.value;
    if (allSources.length === 0) return;
    let curPhysicalSpacing = 0;
    let curPixelSpacing = 0;
    let shader = null;
    let prevChunkFormat;
    let shaderResult;
    const chunkDataDisplaySize = create$3();
    const gl = this.gl;
    this.vertexIdHelper.enable();
    const renderScaleHistogram = this.renderScaleHistogram;
    renderScaleHistogram.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
    const endShader = () => {
      if (shader === null) return;
      if (prevChunkFormat !== null) {
        prevChunkFormat.endDrawing(gl, shader);
      }
      if (presentCount !== 0 || notPresentCount !== 0) {
        renderScaleHistogram.add(curPhysicalSpacing, curPixelSpacing, presentCount, notPresentCount);
      }
    };
    let newSource = true;
    const projectionParameters = renderContext.projectionParameters;
    let chunks;
    let presentCount = 0, notPresentCount = 0;
    let chunkDataSize;
    const chunkRank = this.multiscaleSource.rank;
    const chunkPosition = create$3();
    gl.enable(WebGL2RenderingContext.CULL_FACE);
    gl.cullFace(WebGL2RenderingContext.FRONT);
    forEachVisibleVolumeRenderingChunk(renderContext.projectionParameters, this.localPosition.value, this.renderScaleTarget.value, allSources[0], (transformedSource, _, physicalSpacing, pixelSpacing) => {
      curPhysicalSpacing = physicalSpacing;
      curPixelSpacing = pixelSpacing;
      const chunkLayout = getNormalizedChunkLayout(projectionParameters, transformedSource.chunkLayout);
      const source = transformedSource.source;
      const fixedPositionWithinChunk = transformedSource.fixedPositionWithinChunk, chunkDisplayDimensionIndices = transformedSource.chunkDisplayDimensionIndices;
      for (const chunkDim of chunkDisplayDimensionIndices) {
        fixedPositionWithinChunk[chunkDim] = 0;
      }
      const chunkFormat = source.chunkFormat;
      if (chunkFormat !== prevChunkFormat) {
        prevChunkFormat = chunkFormat;
        endShader();
        shaderResult = this.shaderGetter({ emitter: renderContext.emitter, chunkFormat });
        shader = shaderResult.shader;
        if (shader !== null) {
          shader.bind();
          if (chunkFormat !== null) {
            setControlsInShader(gl, shader, this.shaderControlState, shaderResult.parameters.parseResult.controls);
            chunkFormat.beginDrawing(gl, shader);
            chunkFormat.beginSource(gl, shader);
          }
        }
      }
      chunkDataSize = void 0;
      if (shader === null) return;
      chunks = source.chunks;
      chunkDataDisplaySize.fill(1);
      const modelViewProjection = multiply$3(tempMat4, projectionParameters.viewProjectionMat, chunkLayout.transform);
      gl.uniformMatrix4fv(shader.uniform("uModelViewProjectionMatrix"), false, modelViewProjection);
      const clippingPlanes = tempVisibleVolumetricClippingPlanes;
      getFrustrumPlanes(clippingPlanes, modelViewProjection);
      invert$1(modelViewProjection, modelViewProjection);
      gl.uniformMatrix4fv(shader.uniform("uInvModelViewProjectionMatrix"), false, modelViewProjection);
      var _getVolumeRenderingNe = getVolumeRenderingNearFarBounds(clippingPlanes, transformedSource.lowerClipDisplayBound, transformedSource.upperClipDisplayBound);
      const near = _getVolumeRenderingNe.near, far = _getVolumeRenderingNe.far, adjustedNear = _getVolumeRenderingNe.adjustedNear, adjustedFar = _getVolumeRenderingNe.adjustedFar;
      const step = (adjustedFar - adjustedNear) / (volumeRenderingDepthSamples - 1);
      const brightnessFactor = step / (far - near);
      gl.uniform1f(shader.uniform("uBrightnessFactor"), brightnessFactor);
      const nearLimitFraction = (adjustedNear - near) / (far - near);
      const farLimitFraction = (adjustedFar - near) / (far - near);
      gl.uniform1f(shader.uniform("uNearLimitFraction"), nearLimitFraction);
      gl.uniform1f(shader.uniform("uFarLimitFraction"), farLimitFraction);
      gl.uniform1i(shader.uniform("uMaxSteps"), volumeRenderingDepthSamples);
      gl.uniform3fv(shader.uniform("uLowerClipBound"), transformedSource.lowerClipDisplayBound);
      gl.uniform3fv(shader.uniform("uUpperClipBound"), transformedSource.upperClipDisplayBound);
    }, (transformedSource) => {
      if (shader === null) return;
      const key = transformedSource.curPositionInChunks.join();
      const chunk = chunks.get(key);
      if (chunk !== void 0 && chunk.state === ChunkState.GPU_MEMORY) {
        const originalChunkSize = transformedSource.chunkLayout.size;
        let newChunkDataSize = chunk.chunkDataSize;
        const chunkDisplayDimensionIndices = transformedSource.chunkDisplayDimensionIndices, fixedPositionWithinChunk = transformedSource.fixedPositionWithinChunk, channelToChunkDimensionIndices = transformedSource.chunkTransform.channelToChunkDimensionIndices;
        _objectDestructuringEmpty(transformedSource);
        if (newChunkDataSize !== chunkDataSize) {
          chunkDataSize = newChunkDataSize;
          for (let i = 0; i < 3; ++i) {
            const chunkDim = chunkDisplayDimensionIndices[i];
            chunkDataDisplaySize[i] = chunkDim === -1 || chunkDim >= chunkRank ? 1 : chunkDataSize[chunkDim];
          }
          gl.uniform3fv(shader.uniform("uChunkDataSize"), chunkDataDisplaySize);
        }
        const chunkGridPosition = chunk.chunkGridPosition;
        for (let i = 0; i < 3; ++i) {
          const chunkDim = chunkDisplayDimensionIndices[i];
          chunkPosition[i] = chunkDim === -1 || chunkDim >= chunkRank ? 0 : originalChunkSize[i] * chunkGridPosition[chunkDim];
        }
        if (prevChunkFormat != null) {
          prevChunkFormat.bindChunk(gl, shader, chunk, fixedPositionWithinChunk, chunkDisplayDimensionIndices, channelToChunkDimensionIndices, newSource);
        }
        newSource = false;
        gl.uniform3fv(shader.uniform("uTranslation"), chunkPosition);
        drawBoxes(gl, 1, 1);
        ++presentCount;
      } else {
        ++notPresentCount;
      }
    });
    gl.disable(WebGL2RenderingContext.CULL_FACE);
    endShader();
    this.vertexIdHelper.disable();
  }
  isReady(renderContext, attachment) {
    const allSources = attachment.state.sources.value;
    if (allSources.length === 0) return true;
    let missing = false;
    forEachVisibleVolumeRenderingChunk(renderContext.projectionParameters, this.localPosition.value, this.renderScaleTarget.value, allSources[0], () => {
    }, (tsource) => {
      const chunk = tsource.source.chunks.get(tsource.curPositionInChunks.join());
      if (chunk === void 0 || chunk.state !== ChunkState.GPU_MEMORY) {
        missing = true;
      }
    });
    return missing;
  }
}
const inputEventMap = EventActionMap.fromObject({
  "arrowup": { action: "tab-backward" },
  "arrowdown": { action: "tab-forward" },
  "tab": { action: "tab-forward" },
  "shift+tab": { action: "tab-backward" },
  "enter": { action: "commit" },
  "escape": { action: "cancel" }
});
class DimensionWidget2 {
  constructor(id) {
    this.id = id;
    this.element = document.createElement("div");
    this.nameContainer = document.createElement("div");
    this.nameElement = document.createElement("input");
    this.lowerElement = document.createElement("div");
    this.upperElement = document.createElement("div");
    const element = this.element, nameContainer = this.nameContainer, nameElement = this.nameElement, lowerElement = this.lowerElement, upperElement = this.upperElement;
    element.classList.add("neuroglancer-channel-dimensions-widget-dim");
    nameContainer.classList.add("neuroglancer-channel-dimensions-widget-name-container");
    nameElement.classList.add("neuroglancer-channel-dimensions-widget-name");
    nameContainer.appendChild(nameElement);
    lowerElement.classList.add("neuroglancer-channel-dimensions-widget-lower");
    upperElement.classList.add("neuroglancer-channel-dimensions-widget-upper");
    element.appendChild(nameContainer);
    element.appendChild(lowerElement);
    element.appendChild(upperElement);
    nameContainer.draggable = true;
    nameElement.disabled = true;
    nameElement.spellcheck = false;
    nameElement.autocomplete = "off";
    nameElement.required = true;
    nameElement.placeholder = " ";
    nameContainer.title = `Drag to reorder, double click to rename.  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).`;
    nameContainer.addEventListener("dblclick", () => {
      nameElement.disabled = false;
      nameElement.focus();
      nameElement.select();
    });
    nameElement.addEventListener("focus", () => {
      nameElement.select();
    });
  }
}
class ChannelDimensionsWidget extends RefCounted {
  constructor(combiner) {
    super();
    this.combiner = combiner;
    this.element = document.createElement("div");
    this.dimensionWidgets = [];
    this.curCoordinateSpace = void 0;
    this.dragSource = void 0;
    this.coordinateSpace = this.combiner.combined;
    const element = this.element;
    element.classList.add("neuroglancer-channel-dimensions-widget");
    const debouncedUpdateView = this.registerCancellable(animationFrameDebounce(() => this.updateView()));
    this.registerDisposer(combiner.combined.changed.add(debouncedUpdateView));
    const keyboardHandler = this.registerDisposer(new KeyboardEventBinder(element, inputEventMap));
    keyboardHandler.allShortcutsAreGlobal = true;
    this.registerDisposer(registerActionListener(element, "cancel", (event) => {
      this.forceUpdateView();
      const target = event.target;
      if (target instanceof HTMLElement) {
        target.blur();
      }
    }));
    this.updateView();
  }
  reorderDimensionTo(targetIndex, sourceIndex) {
    if (targetIndex === sourceIndex) return;
    const coordinateSpace = this.coordinateSpace;
    coordinateSpace.value = insertDimensionAt(coordinateSpace.value, targetIndex, sourceIndex);
  }
  makeNewDimensionWidget(id) {
    const widget = new DimensionWidget2(id);
    widget.nameContainer.addEventListener("dragstart", (event) => {
      this.dragSource = widget;
      event.stopPropagation();
      event.dataTransfer.setData("neuroglancer-dimension", "");
    });
    widget.nameContainer.addEventListener("dragenter", (event) => {
      const dragSource2 = this.dragSource;
      if (dragSource2 === void 0 || dragSource2 === widget) return;
      const dimensionWidgets = this.dimensionWidgets;
      const sourceIndex = dimensionWidgets.indexOf(dragSource2);
      const targetIndex = dimensionWidgets.indexOf(widget);
      if (sourceIndex === -1 || targetIndex === -1) return;
      event.preventDefault();
      this.reorderDimensionTo(targetIndex, sourceIndex);
    });
    widget.nameContainer.addEventListener("dragend", (event) => {
      if (this.dragSource === widget) {
        this.dragSource = void 0;
      }
    });
    widget.nameElement.addEventListener("blur", (event) => {
      widget.nameElement.disabled = true;
      const relatedTarget = event.relatedTarget;
      if (this.dimensionWidgets.some((widget2) => widget2.nameElement === relatedTarget)) {
        return;
      }
      if (!this.updateNames()) {
        this.forceUpdateView();
      }
    });
    widget.nameElement.addEventListener("input", () => {
      const nameElement = widget.nameElement;
      updateInputFieldWidth$1(nameElement);
      this.updateNameValidity();
    });
    registerActionListener(widget.nameElement, "commit", () => {
      this.updateNames();
    });
    registerActionListener(widget.nameElement, "tab-forward", (event) => this.selectAdjacentField(event, widget, 1));
    registerActionListener(widget.nameElement, "tab-backward", (event) => this.selectAdjacentField(event, widget, -1));
    return widget;
  }
  selectAdjacentField(event, widget, dir) {
    event.stopPropagation();
    const dimensionWidgets = this.dimensionWidgets;
    const dimIndex = dimensionWidgets.indexOf(widget);
    if (dimIndex === -1) return;
    const nextIndex = dimIndex + dir;
    if (nextIndex < 0 || nextIndex >= dimensionWidgets.length) return;
    const nextWidget = dimensionWidgets[nextIndex];
    nextWidget.nameElement.disabled = false;
    nextWidget.nameElement.focus();
    event.preventDefault();
  }
  updateNames() {
    const dimensionWidgets = this.dimensionWidgets, coordinateSpace = this.coordinateSpace;
    const existing = coordinateSpace.value;
    const names = dimensionWidgets.map((x) => x.nameElement.value);
    if (this.combiner.getRenameValidity(names).includes(false)) return false;
    const existingNames = existing.names;
    if (arraysEqual(existingNames, names)) return false;
    const timestamps = existing.timestamps.map((t, i) => existingNames[i] === names[i] ? t : Date.now());
    const newSpace = _Object$assign(_Object$assign({}, existing), { names, timestamps });
    coordinateSpace.value = newSpace;
    return true;
  }
  updateNameValidity() {
    const dimensionWidgets = this.dimensionWidgets;
    const names = dimensionWidgets.map((w) => w.nameElement.value);
    const rank = names.length;
    const isValid = this.combiner.getRenameValidity(names);
    for (let i = 0; i < rank; ++i) {
      dimensionWidgets[i].nameElement.dataset.isValid = isValid[i] === false ? "false" : "true";
    }
  }
  forceUpdateView() {
    this.curCoordinateSpace = void 0;
    this.updateView();
  }
  updateView() {
    const coordinateSpace = this.coordinateSpace.value;
    if (this.curCoordinateSpace === coordinateSpace) return;
    this.curCoordinateSpace = coordinateSpace;
    const element = this.element;
    const oldDimensionWidgets = this.dimensionWidgets;
    const dimensionWidgets = this.dimensionWidgets = coordinateSpace.ids.map((id) => oldDimensionWidgets.find((x) => x.id === id) || this.makeNewDimensionWidget(id));
    function* getChildren() {
      const names = coordinateSpace.names, rank = coordinateSpace.rank;
      var _coordinateSpace$boun = coordinateSpace.bounds;
      const lowerBounds = _coordinateSpace$boun.lowerBounds, upperBounds = _coordinateSpace$boun.upperBounds;
      for (let i = 0; i < rank; ++i) {
        const widget = dimensionWidgets[i];
        widget.nameElement.value = names[i];
        delete widget.nameElement.dataset.isValid;
        updateInputFieldWidth$1(widget.nameElement);
        widget.lowerElement.textContent = lowerBounds[i].toString();
        widget.upperElement.textContent = upperBounds[i].toString();
        yield widget.element;
      }
    }
    updateChildren(element, getChildren.call(this));
  }
}
const OPACITY_JSON_KEY = "opacity";
const BLEND_JSON_KEY = "blend";
const SHADER_JSON_KEY = "shader";
const SHADER_CONTROLS_JSON_KEY = "shaderControls";
const CROSS_SECTION_RENDER_SCALE_JSON_KEY = "crossSectionRenderScale";
const CHANNEL_DIMENSIONS_JSON_KEY = "channelDimensions";
const VOLUME_RENDERING_JSON_KEY = "volumeRendering";
const VOLUME_RENDER_SCALE_JSON_KEY = "volumeRenderScale";
const Base = UserLayerWithAnnotationsMixin(UserLayer);
class ImageUserLayer extends Base {
  constructor(managedLayer) {
    super(managedLayer);
    this.opacity = trackableAlphaValue(0.5);
    this.blendMode = trackableBlendModeValue();
    this.fragmentMain = getTrackableFragmentMain();
    this.shaderError = makeWatchableShaderError();
    this.dataType = new WatchableValue(void 0);
    this.sliceViewRenderScaleHistogram = new RenderScaleHistogram();
    this.sliceViewRenderScaleTarget = trackableRenderScaleTarget(1);
    this.volumeRenderingRenderScaleHistogram = new RenderScaleHistogram();
    this.volumeRenderingRenderScaleTarget = trackableRenderScaleTarget(1);
    this.channelCoordinateSpace = new TrackableCoordinateSpace();
    this.channelCoordinateSpaceCombiner = new CoordinateSpaceCombiner(this.channelCoordinateSpace, isChannelDimension);
    this.channelSpace = this.registerDisposer(makeCachedLazyDerivedWatchableValue((channelCoordinateSpace) => makeValueOrError(() => getChannelSpace(channelCoordinateSpace)), this.channelCoordinateSpace));
    this.volumeRendering = new TrackableBoolean(false, false);
    this.shaderControlState = this.registerDisposer(new ShaderControlState(this.fragmentMain, this.registerDisposer(makeCachedDerivedWatchableValue((dataType, channelCoordinateSpace) => {
      if (dataType === void 0) return null;
      return { imageData: { dataType, channelRank: channelCoordinateSpace.rank } };
    }, [this.dataType, this.channelCoordinateSpace], (a, b) => _JSON$stringify(a) === _JSON$stringify(b))), this.channelCoordinateSpaceCombiner));
    this.localCoordinateSpaceCombiner.includeDimensionPredicate = isLocalDimension;
    this.blendMode.changed.add(this.specificationChanged.dispatch);
    this.opacity.changed.add(this.specificationChanged.dispatch);
    this.fragmentMain.changed.add(this.specificationChanged.dispatch);
    this.shaderControlState.changed.add(this.specificationChanged.dispatch);
    this.sliceViewRenderScaleTarget.changed.add(this.specificationChanged.dispatch);
    this.volumeRendering.changed.add(this.specificationChanged.dispatch);
    this.tabs.add("rendering", { label: "Rendering", order: -100, getter: () => new RenderingOptionsTab2(this) });
    this.tabs.default = "rendering";
  }
  markLoading() {
    const baseDisposer = super.markLoading();
    const channelDisposer = this.channelCoordinateSpaceCombiner.retain();
    return () => {
      baseDisposer();
      channelDisposer();
    };
  }
  addCoordinateSpace(coordinateSpace) {
    const baseBinding = super.addCoordinateSpace(coordinateSpace);
    const channelBinding = this.channelCoordinateSpaceCombiner.bind(coordinateSpace);
    return () => {
      baseBinding();
      channelBinding();
    };
  }
  activateDataSubsources(subsources) {
    let dataType;
    for (const loadedSubsource of subsources) {
      if (this.addStaticAnnotations(loadedSubsource)) continue;
      const subsourceEntry = loadedSubsource.subsourceEntry;
      const subsource = subsourceEntry.subsource;
      const volume = subsource.volume;
      if (!(volume instanceof MultiscaleVolumeChunkSource$3)) {
        loadedSubsource.deactivate("Not compatible with image layer");
        continue;
      }
      if (dataType && volume.dataType !== dataType) {
        loadedSubsource.deactivate(`Data type must be ${DataType[volume.dataType].toLowerCase()}`);
        continue;
      }
      dataType = volume.dataType;
      loadedSubsource.activate((context) => {
        loadedSubsource.addRenderLayer(new ImageRenderLayer(volume, {
          opacity: this.opacity,
          blendMode: this.blendMode,
          shaderControlState: this.shaderControlState,
          shaderError: this.shaderError,
          transform: loadedSubsource.getRenderLayerTransform(this.channelCoordinateSpace),
          renderScaleTarget: this.sliceViewRenderScaleTarget,
          renderScaleHistogram: this.sliceViewRenderScaleHistogram,
          localPosition: this.localPosition,
          channelCoordinateSpace: this.channelCoordinateSpace
        }));
        const volumeRenderLayer = context.registerDisposer(new VolumeRenderingRenderLayer({
          multiscaleSource: volume,
          shaderControlState: this.shaderControlState,
          shaderError: this.shaderError,
          transform: loadedSubsource.getRenderLayerTransform(this.channelCoordinateSpace),
          renderScaleTarget: this.volumeRenderingRenderScaleTarget,
          renderScaleHistogram: this.volumeRenderingRenderScaleHistogram,
          localPosition: this.localPosition,
          channelCoordinateSpace: this.channelCoordinateSpace
        }));
        context.registerDisposer(loadedSubsource.messages.addChild(volumeRenderLayer.messages));
        context.registerDisposer(registerNested((context2, volumeRendering) => {
          if (!volumeRendering) return;
          context2.registerDisposer(this.addRenderLayer(volumeRenderLayer.addRef()));
        }, this.volumeRendering));
        this.shaderError.changed.dispatch();
      });
    }
    this.dataType.value = dataType;
  }
  restoreState(specification) {
    super.restoreState(specification);
    this.opacity.restoreState(specification[OPACITY_JSON_KEY]);
    verifyOptionalObjectProperty(specification, BLEND_JSON_KEY, (blendValue) => this.blendMode.restoreState(blendValue));
    this.fragmentMain.restoreState(specification[SHADER_JSON_KEY]);
    this.shaderControlState.restoreState(specification[SHADER_CONTROLS_JSON_KEY]);
    this.sliceViewRenderScaleTarget.restoreState(specification[CROSS_SECTION_RENDER_SCALE_JSON_KEY]);
    this.channelCoordinateSpace.restoreState(specification[CHANNEL_DIMENSIONS_JSON_KEY]);
    this.volumeRendering.restoreState(specification[VOLUME_RENDERING_JSON_KEY]);
  }
  toJSON() {
    const x = super.toJSON();
    x[OPACITY_JSON_KEY] = this.opacity.toJSON();
    x[BLEND_JSON_KEY] = this.blendMode.toJSON();
    x[SHADER_JSON_KEY] = this.fragmentMain.toJSON();
    x[SHADER_CONTROLS_JSON_KEY] = this.shaderControlState.toJSON();
    x[CROSS_SECTION_RENDER_SCALE_JSON_KEY] = this.sliceViewRenderScaleTarget.toJSON();
    x[CHANNEL_DIMENSIONS_JSON_KEY] = this.channelCoordinateSpace.toJSON();
    x[VOLUME_RENDERING_JSON_KEY] = this.volumeRendering.toJSON();
    return x;
  }
  displayImageSelectionState(state, parent) {
    const value = state.value;
    if (value == null) return false;
    const channelSpace = this.channelSpace.value;
    if (channelSpace.error !== void 0) return false;
    const numChannels = channelSpace.numChannels, coordinates = channelSpace.coordinates;
    var _channelSpace$channel = channelSpace.channelCoordinateSpace;
    const names = _channelSpace$channel.names, rank = _channelSpace$channel.rank;
    const grid = document.createElement("div");
    grid.classList.add("neuroglancer-selection-details-value-grid");
    let gridTemplateColumns = "[copy] 0fr ";
    if (rank !== 0) {
      gridTemplateColumns += `repeat(${rank}, [dim] 0fr [coord] 0fr) `;
    }
    gridTemplateColumns += `[value] 1fr`;
    grid.style.gridTemplateColumns = gridTemplateColumns;
    for (let channelIndex = 0; channelIndex < numChannels; ++channelIndex) {
      const x = rank === 0 ? value : value[channelIndex];
      const valueString = x == null ? "" : x.toString();
      const copyButton = makeCopyButton({
        title: `Copy value`,
        onClick: () => {
          setClipboard(valueString);
        }
      });
      grid.appendChild(copyButton);
      for (let channelDim = 0; channelDim < rank; ++channelDim) {
        const dimElement = document.createElement("div");
        dimElement.classList.add("neuroglancer-selection-details-value-grid-dim");
        dimElement.textContent = names[channelDim];
        grid.appendChild(dimElement);
        const coordElement = document.createElement("div");
        coordElement.classList.add("neuroglancer-selection-details-value-grid-coord");
        coordElement.textContent = coordinates[channelIndex * rank + channelDim].toString();
        grid.appendChild(coordElement);
      }
      const valueElement = document.createElement("div");
      valueElement.classList.add("neuroglancer-selection-details-value-grid-value");
      valueElement.textContent = valueString;
      grid.appendChild(valueElement);
    }
    parent.appendChild(grid);
    return true;
  }
  displaySelectionState(state, parent, context) {
    let displayed = this.displayImageSelectionState(state, parent);
    if (super.displaySelectionState(state, parent, context)) displayed = true;
    return displayed;
  }
  getLegendShaderOptions() {
    return {
      memoizeKey: `ImageUserLayer`,
      parameters: this.shaderControlState.builderState,
      // fixme: support fallback
      encodeParameters: (p) => p.key,
      defineShader: (builder, shaderBuilderState) => {
        builder.addFragmentCode(`
#define uOpacity 1.0
`);
        defineImageLayerShader(builder, shaderBuilderState);
      },
      initializeShader: (shaderResult) => {
        const shader = shaderResult.shader;
        setControlsInShader(this.manager.root.display.gl, shader, this.shaderControlState, shaderResult.parameters.parseResult.controls);
      }
    };
  }
}
ImageUserLayer.type = "image";
ImageUserLayer.typeAbbreviation = "img";
function makeShaderCodeWidget(layer) {
  return new ShaderCodeWidget({
    shaderError: layer.shaderError,
    fragmentMain: layer.fragmentMain,
    shaderControlState: layer.shaderControlState
  });
}
const LAYER_CONTROLS = [_Object$assign({ label: "Resolution (slice)", toolJson: CROSS_SECTION_RENDER_SCALE_JSON_KEY }, renderScaleLayerControl((layer) => ({
  histogram: layer.sliceViewRenderScaleHistogram,
  target: layer.sliceViewRenderScaleTarget
}))), _Object$assign({ label: "Blending", toolJson: BLEND_JSON_KEY }, enumLayerControl((layer) => layer.blendMode)), _Object$assign({ label: "Volume rendering (experimental)", toolJson: VOLUME_RENDERING_JSON_KEY }, checkboxLayerControl((layer) => layer.volumeRendering)), _Object$assign({ label: "Resolution (3d)", toolJson: VOLUME_RENDER_SCALE_JSON_KEY, isValid: (layer) => layer.volumeRendering }, renderScaleLayerControl((layer) => ({
  histogram: layer.volumeRenderingRenderScaleHistogram,
  target: layer.volumeRenderingRenderScaleTarget
}))), _Object$assign({ label: "Opacity", toolJson: OPACITY_JSON_KEY }, rangeLayerControl((layer) => ({ value: layer.opacity })))];
for (const control of LAYER_CONTROLS) {
  registerLayerControl(ImageUserLayer, control);
}
class RenderingOptionsTab2 extends Tab {
  constructor(layer) {
    super();
    this.layer = layer;
    this.codeWidget = this.registerDisposer(makeShaderCodeWidget(this.layer));
    const element = this.element;
    element.classList.add("neuroglancer-image-dropdown");
    for (const control of LAYER_CONTROLS) {
      element.appendChild(addLayerControlToOptionsTab(this, layer, this.visibility, control));
    }
    let spacer = document.createElement("div");
    spacer.style.flex = "1";
    let topRow = document.createElement("div");
    topRow.className = "neuroglancer-image-dropdown-top-row";
    topRow.appendChild(document.createTextNode("Shader"));
    topRow.appendChild(spacer);
    topRow.appendChild(makeMaximizeButton({
      title: "Show larger editor view",
      onClick: () => {
        new ShaderCodeOverlay3(this.layer);
      }
    }));
    topRow.appendChild(makeHelpButton({
      title: "Documentation on image layer rendering",
      href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md"
    }));
    element.appendChild(topRow);
    element.appendChild(this.registerDisposer(new ChannelDimensionsWidget(layer.channelCoordinateSpaceCombiner)).element);
    element.appendChild(this.codeWidget.element);
    element.appendChild(this.registerDisposer(new ShaderControls(layer.shaderControlState, this.layer.manager.root.display, this.layer, {
      visibility: this.visibility,
      legendShaderOptions: this.layer.getLegendShaderOptions()
    })).element);
  }
}
class ShaderCodeOverlay3 extends Overlay {
  constructor(layer) {
    super();
    this.layer = layer;
    this.codeWidget = this.registerDisposer(makeShaderCodeWidget(this.layer));
    this.content.classList.add("neuroglancer-image-layer-shader-overlay");
    this.content.appendChild(this.codeWidget.element);
    this.codeWidget.textEditor.refresh();
  }
}
registerLayerType(ImageUserLayer);
registerVolumeLayerType(VolumeType.IMAGE, ImageUserLayer);
registerLayerTypeDetector((subsource) => {
  const volume = subsource.volume;
  if (volume === void 0) return void 0;
  if (volume.volumeType !== VolumeType.UNKNOWN) return void 0;
  return { layerConstructor: ImageUserLayer, priority: -100 };
});
registerLayerShaderControlsTool(ImageUserLayer, (layer) => ({
  shaderControlState: layer.shaderControlState,
  legendShaderOptions: layer.getLegendShaderOptions()
}));
function setupDefaultViewer(options) {
  if (options.brainMapsClientId) {
    const clientId = options.brainMapsClientId;
    defaultCredentialsManager.register(credentialsKey, () => new BrainmapsCredentialsProvider(clientId));
  }
  let viewer = makeMinimalViewer({ bundleRoot: options.bundleRoot }, options.target);
  setDefaultInputEventBindings(viewer.inputEventBindings);
  bindDefaultCopyHandler(viewer);
  bindDefaultPasteHandler(viewer);
  disableContextMenu(options.target);
  return viewer;
}
class Neuroglancer {
  version() {
    return "0.0.1";
  }
}
const main_module = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Neuroglancer,
  setupDefaultViewer
}, Symbol.toStringTag, { value: "Module" }));
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(main_module);
const require$$7 = /* @__PURE__ */ getAugmentedNamespace(uint64);
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(json);
const require$$9 = /* @__PURE__ */ getAugmentedNamespace(url_hash_binding);
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  (function(exports) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseUrlHash = parseUrlHash;
    exports.getNeuroglancerViewerState = getNeuroglancerViewerState;
    exports.getNeuroglancerColor = getNeuroglancerColor;
    exports.closeSelectionTab = closeSelectionTab;
    exports.getLayerManager = getLayerManager;
    exports.getManagedLayer = getManagedLayer;
    exports.getAnnotationLayer = getAnnotationLayer;
    exports.getAnnotationSource = getAnnotationSource2;
    exports.addLayerSignalRemover = addLayerSignalRemover;
    exports.unsubscribeLayersChangedSignals = unsubscribeLayersChangedSignals;
    exports.configureLayersChangedSignals = configureLayersChangedSignals;
    exports.configureAnnotationLayer = configureAnnotationLayer;
    exports.configureAnnotationLayerChanged = configureAnnotationLayerChanged;
    exports.getAnnotationSelectionHost = getAnnotationSelectionHost;
    exports.getSelectedAnnotationId = getSelectedAnnotationId;
    exports["default"] = void 0;
    var _react = _interopRequireDefault(React__default);
    var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes());
    var _user_layer = require$$2;
    var _frontend = require$$3;
    var _segmentation_user_layer = require$$4;
    var _color = require$$5;
    var _neuroglancer = require$$6;
    var _uint = require$$7;
    var _json = require$$8;
    var _url_hash_binding = require$$9;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len2) {
      if (len2 == null || len2 > arr.length) len2 = arr.length;
      for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var viewersKeyed = {};
    var viewerNoKey;
    function parseUrlHash(url) {
      var state = null;
      var s = url.replace(/^[^#]+/, "");
      if (s === "" || s === "#" || s === "#!") {
        s = "#!{}";
      }
      if (s.startsWith("#!+")) {
        s = s.slice(3);
        s = decodeURIComponent(s);
        state = (0, _json.urlSafeParse)(s);
      } else if (s.startsWith("#!")) {
        s = s.slice(2);
        s = decodeURIComponent(s);
        state = (0, _json.urlSafeParse)(s);
      } else {
        throw new Error('URL hash is expected to be of the form "#!{...}" or "#!+{...}".');
      }
      return state;
    }
    function getNeuroglancerViewerState(key) {
      var v = key ? viewersKeyed[key] : viewerNoKey;
      return v ? v.state.toJSON() : {};
    }
    function getNeuroglancerColor(idStr, key) {
      try {
        var id = _uint.Uint64.parseString(idStr);
        var v = key ? viewersKeyed[key] : viewerNoKey;
        if (v) {
          var _iterator = _createForOfIteratorHelper(v.layerManager.managedLayers), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var layer = _step.value;
              if (layer.layer instanceof _segmentation_user_layer.SegmentationUserLayer) {
                var displayState = layer.layer.displayState;
                var colorVec = (0, _frontend.getObjectColor)(displayState, id);
                if (displayState.segmentSelectionState.isSelected(id)) {
                  for (var i = 0; i < 3; i += 1) {
                    colorVec[i] = (colorVec[i] - 0.5) / 0.5;
                  }
                }
                var colorStr = (0, _color.serializeColor)(colorVec);
                return colorStr;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      } catch (_unused) {
      }
      return "";
    }
    function closeSelectionTab(key) {
      var v = key ? viewersKeyed[key] : viewerNoKey;
      if (v && v.closeSelectionTab) {
        v.closeSelectionTab();
      }
    }
    function getLayerManager(key) {
      var v = key ? viewersKeyed[key] : viewerNoKey;
      if (v) {
        return v.layerManager;
      }
      return void 0;
    }
    function getManagedLayer(key, name2) {
      var layerManager = getLayerManager(key);
      if (layerManager) {
        return layerManager.managedLayers.filter(function(layer) {
          return layer.name === name2;
        })[0];
      }
      return void 0;
    }
    function getAnnotationLayer(key, name2) {
      var layer = getManagedLayer(key, name2);
      if (layer && layer.layer instanceof _user_layer.AnnotationUserLayer) {
        return layer.layer;
      }
      return void 0;
    }
    function getAnnotationSource2(key, name2) {
      var layer = getAnnotationLayer(key, name2);
      if (layer && layer.dataSources && layer.dataSources[0].loadState_) {
        var dataSource = layer.dataSources[0].loadState_.dataSource;
        if (dataSource) {
          return dataSource.subsources[0].subsource.annotation;
        }
      }
      return void 0;
    }
    function addLayerSignalRemover(key, name2, remover) {
      var layerManager = getLayerManager(key);
      if (layerManager && name2 && remover) {
        if (!layerManager.customSignalHandlerRemovers) {
          layerManager.customSignalHandlerRemovers = {};
        }
        if (!layerManager.customSignalHandlerRemovers[name2]) {
          layerManager.customSignalHandlerRemovers[name2] = [];
        }
        layerManager.customSignalHandlerRemovers[name2].push(remover);
      }
    }
    function unsubscribeLayersChangedSignals(layerManager, signalKey) {
      if (layerManager) {
        if (layerManager.customSignalHandlerRemovers) {
          if (layerManager.customSignalHandlerRemovers[signalKey]) {
            layerManager.customSignalHandlerRemovers[signalKey].forEach(function(remover) {
              remover();
            });
            delete layerManager.customSignalHandlerRemovers[signalKey];
          }
        }
      }
    }
    function configureLayersChangedSignals(key, layerConfig) {
      var layerManager = getLayerManager(key);
      if (layerManager) {
        var layerName = layerConfig.layerName;
        unsubscribeLayersChangedSignals(layerManager, layerName);
        if (layerConfig.process) {
          var recordRemover = function recordRemover2(remover) {
            return addLayerSignalRemover(void 0, layerName, remover);
          };
          recordRemover(layerManager.layersChanged.add(function() {
            var layer2 = getManagedLayer(void 0, layerName);
            if (layer2) {
              layerConfig.process(layer2);
            }
          }));
          var layer = getManagedLayer(void 0, layerName);
          if (layer) {
            layerConfig.process(layer);
          }
          return function() {
            if (layerConfig.cancel) {
              layerConfig.cancel();
            }
            unsubscribeLayersChangedSignals(layerManager, layerName);
          };
        }
      }
      return layerConfig.cancel;
    }
    function configureAnnotationSource(source, props, recordRemover) {
      if (source && !source.signalReady) {
        if (props.onAnnotationAdded) {
          recordRemover(source.childAdded.add(function(annotation) {
            props.onAnnotationAdded(annotation);
          }));
        }
        if (props.onAnnotationDeleted) {
          recordRemover(source.childDeleted.add(function(id) {
            props.onAnnotationDeleted(id);
          }));
        }
        if (props.onAnnotationUpdated) {
          recordRemover(source.childUpdated.add(function(annotation) {
            props.onAnnotationUpdated(annotation);
          }));
        }
        if (props.onAnnotationChanged && source.referencesChanged) {
          recordRemover(source.referencesChanged.add(props.onAnnotationChanged));
        }
        source.signalReady = true;
        recordRemover(function() {
          source.signalReady = false;
        });
      }
    }
    function getLoadedDataSource(layer) {
      if (layer.dataSources && layer.dataSources.length > 0 && layer.dataSources[0].loadState_ && layer.dataSources[0].loadState_.dataSource) {
        return layer.dataSources[0].loadState_.dataSource;
      }
    }
    function getAnnotationSourceFromLayer(layer) {
      var dataSource = getLoadedDataSource(layer);
      if (dataSource) {
        return dataSource.subsources[0].subsource.annotation;
      }
    }
    function configureAnnotationSourceChange(annotationLayer, props, recordRemover) {
      var configure = function configure2() {
        var source = getAnnotationSourceFromLayer(annotationLayer);
        if (source) {
          configureAnnotationSource(source, props, recordRemover);
        }
      };
      var sourceChanged = annotationLayer.dataSourcesChanged;
      if (sourceChanged && !sourceChanged.signalReady) {
        recordRemover(sourceChanged.add(configure));
        sourceChanged.signalReady = true;
        recordRemover(function() {
          sourceChanged.signalReady = false;
        });
        configure();
      }
    }
    function configureAnnotationLayer(layer, props, recordRemover) {
      if (layer) {
        layer.expectingExternalTable = true;
        if (layer.selectedAnnotation && !layer.selectedAnnotation.changed.signalReady) {
          if (props.onAnnotationSelectionChanged) {
            recordRemover(layer.selectedAnnotation.changed.add(function() {
              props.onAnnotationSelectionChanged(layer.selectedAnnotation.value);
            }));
            recordRemover(function() {
              layer.selectedAnnotation.changed.signalReady = false;
            });
            layer.selectedAnnotation.changed.signalReady = true;
          }
        }
        configureAnnotationSourceChange(layer, props, recordRemover);
      }
    }
    function configureAnnotationLayerChanged(layer, props, recordRemover) {
      if (!layer.layerChanged.signalReady) {
        var remover = layer.layerChanged.add(function() {
          configureAnnotationLayer(layer.layer, props, recordRemover);
        });
        layer.layerChanged.signalReady = true;
        recordRemover(remover);
        recordRemover(function() {
          layer.layerChanged.signalReady = false;
        });
        configureAnnotationLayer(layer.layer, props, recordRemover);
      }
    }
    function getAnnotationSelectionHost(key) {
      var viewer = key ? viewersKeyed[key] : viewerNoKey;
      if (viewer) {
        if (viewer.selectionDetailsState) {
          return "viewer";
        }
        return "layer";
      }
      return null;
    }
    function getSelectedAnnotationId(key, layerName) {
      var viewer = key ? viewersKeyed[key] : viewerNoKey;
      if (viewer) {
        if (viewer.selectionDetailsState) {
          if (viewer.selectionDetailsState.value) {
            var layers = viewer.selectionDetailsState.value.layers;
            if (layers) {
              var layer = layers.find(function(_layer) {
                return _layer.layer.managedLayer.name === layerName;
              });
              if (layer && layer.state) {
                return layer.state.annotationId;
              }
            }
          }
        } else {
          var _layer2 = getAnnotationLayer(void 0, layerName);
          if (_layer2 && _layer2.selectedAnnotation && _layer2.selectedAnnotation.value) {
            return _layer2.selectedAnnotation.value.id;
          }
        }
      }
      return null;
    }
    var Neuroglancer2 = /* @__PURE__ */ function(_React$Component) {
      _inherits(Neuroglancer3, _React$Component);
      var _super = _createSuper(Neuroglancer3);
      function Neuroglancer3(props) {
        var _this;
        _classCallCheck(this, Neuroglancer3);
        _this = _super.call(this, props);
        _defineProperty(_assertThisInitialized(_this), "updateEventBindings", function(eventBindingsToUpdate) {
          var root = _this.viewer.inputEventBindings;
          var traverse = function traverse2(current) {
            var replace = function replace2(eaMap, event0, event1) {
              var action = eaMap.get(event0);
              if (action) {
                eaMap["delete"](event0);
                if (event1) {
                  eaMap.set(event1, action);
                }
              }
            };
            var eventActionMap = current.bindings;
            eventBindingsToUpdate.forEach(function(oldNewBinding) {
              var eventOldBase = Array.isArray(oldNewBinding) ? oldNewBinding[0] : oldNewBinding;
              var eventOldA = "at:".concat(eventOldBase);
              var eventNewA = oldNewBinding[1] ? "at:".concat(oldNewBinding[1]) : void 0;
              replace(eventActionMap, eventOldA, eventNewA);
              var eventOldB = "bubble:".concat(eventOldBase);
              var eventNewB = oldNewBinding[1] ? "bubble:".concat(oldNewBinding[1]) : void 0;
              replace(eventActionMap, eventOldB, eventNewB);
            });
            current.parents.forEach(function(parent) {
              traverse2(parent);
            });
          };
          traverse(root.global);
          traverse(root.perspectiveView);
          traverse(root.sliceView);
        });
        _defineProperty(_assertThisInitialized(_this), "selectionDetailsStateChanged", function() {
          if (_this.viewer) {
            var onSelectionDetailsStateChanged = _this.props.onSelectionDetailsStateChanged;
            if (onSelectionDetailsStateChanged) {
              onSelectionDetailsStateChanged();
            }
          }
        });
        _defineProperty(_assertThisInitialized(_this), "layersChanged", function() {
          if (_this.handlerRemovers) {
            _this.handlerRemovers.forEach(function(remover2) {
              return remover2();
            });
          }
          if (_this.viewer) {
            var _this$props = _this.props, onSelectedChanged = _this$props.onSelectedChanged, onVisibleChanged = _this$props.onVisibleChanged;
            if (onSelectedChanged || onVisibleChanged) {
              _this.handlerRemovers = [];
              var _iterator2 = _createForOfIteratorHelper(_this.viewer.layerManager.managedLayers), _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                  var layer = _step2.value;
                  if (layer.layer instanceof _segmentation_user_layer.SegmentationUserLayer) {
                    var segmentSelectionState = layer.layer.displayState.segmentSelectionState;
                    var visibleSegments = layer.layer.displayState.segmentationGroupState.value.visibleSegments;
                    if (segmentSelectionState && onSelectedChanged) {
                      var selectedChanged = _this.selectedChanged.bind(void 0, layer);
                      var remover = segmentSelectionState.changed.add(selectedChanged);
                      _this.handlerRemovers.push(remover);
                      layer.registerDisposer(remover);
                    }
                    if (visibleSegments && onVisibleChanged) {
                      var visibleChanged = _this.visibleChanged.bind(void 0, layer);
                      var _remover = visibleSegments.changed.add(visibleChanged);
                      _this.handlerRemovers.push(_remover);
                      layer.registerDisposer(_remover);
                    }
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          }
        });
        _defineProperty(_assertThisInitialized(_this), "selectedChanged", function(layer) {
          if (_this.viewer) {
            var onSelectedChanged = _this.props.onSelectedChanged;
            if (onSelectedChanged) {
              var segmentSelectionState = layer.layer.displayState.segmentSelectionState;
              if (segmentSelectionState) {
                var segment = segmentSelectionState.hasSelectedSegment ? segmentSelectionState.selectedSegment : null;
                onSelectedChanged(segment, layer);
              }
            }
          }
        });
        _defineProperty(_assertThisInitialized(_this), "visibleChanged", function(layer) {
          if (_this.viewer) {
            var onVisibleChanged = _this.props.onVisibleChanged;
            if (onVisibleChanged) {
              var visibleSegments = layer.layer.displayState.segmentationGroupState.value.visibleSegments;
              if (visibleSegments) {
                onVisibleChanged(visibleSegments, layer);
              }
            }
          }
        });
        _this.ngContainer = /* @__PURE__ */ _react["default"].createRef();
        _this.viewer = null;
        return _this;
      }
      _createClass(Neuroglancer3, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this2 = this;
          var _this$props2 = this.props, perspectiveZoom = _this$props2.perspectiveZoom, viewerState = _this$props2.viewerState, brainMapsClientId = _this$props2.brainMapsClientId, eventBindingsToUpdate = _this$props2.eventBindingsToUpdate, onViewerStateChanged = _this$props2.onViewerStateChanged, callbacks = _this$props2.callbacks, ngServer = _this$props2.ngServer, key = _this$props2.key, bundleRoot = _this$props2.bundleRoot;
          this.viewer = (0, _neuroglancer.setupDefaultViewer)({
            brainMapsClientId,
            target: this.ngContainer.current,
            bundleRoot: bundleRoot || "/"
          });
          this.setCallbacks(callbacks);
          if (eventBindingsToUpdate) {
            this.updateEventBindings(eventBindingsToUpdate);
          }
          this.viewer.expectingExternalUI = true;
          if (ngServer) {
            this.viewer.makeUrlFromState = function(state) {
              var newState = _objectSpread({}, state);
              if (state.layers) {
                newState.layers = state.layers.filter(function(layer) {
                  if (layer.source) {
                    var sourceUrl = layer.source.url || layer.source;
                    if (typeof sourceUrl === "string") {
                      return !sourceUrl.startsWith("clio://");
                    }
                  }
                  return true;
                });
              }
              return "".concat(ngServer, "/#!").concat((0, _url_hash_binding.encodeFragment)(JSON.stringify(newState)));
            };
          }
          if (this.viewer.selectionDetailsState) {
            this.viewer.selectionDetailsState.changed.add(this.selectionDetailsStateChanged);
          }
          this.viewer.layerManager.layersChanged.add(this.layersChanged);
          if (viewerState) {
            var newViewerState = viewerState;
            if (newViewerState.projectionScale === null) {
              delete newViewerState.projectionScale;
            }
            if (newViewerState.crossSectionScale === null) {
              delete newViewerState.crossSectionScale;
            }
            if (newViewerState.projectionOrientation === null) {
              delete newViewerState.projectionOrientation;
            }
            if (newViewerState.crossSectionOrientation === null) {
              delete newViewerState.crossSectionOrientation;
            }
            this.viewer.state.restoreState(newViewerState);
          } else {
            this.viewer.state.restoreState({
              layers: {
                grayscale: {
                  type: "image",
                  source: "dvid://https://flyem.dvid.io/ab6e610d4fe140aba0e030645a1d7229/grayscalejpeg"
                },
                segmentation: {
                  type: "segmentation",
                  source: "dvid://https://flyem.dvid.io/d925633ed0974da78e2bb5cf38d01f4d/segmentation"
                }
              },
              perspectiveZoom,
              navigation: {
                zoomFactor: 8
              }
            });
          }
          this.viewer.state.changed.add(function() {
            if (onViewerStateChanged) {
              try {
                if (_this2.viewer.state.viewer.position) {
                  onViewerStateChanged(_this2.viewer.state.toJSON());
                }
              } catch (error) {
                console.debug(error);
              }
            }
          });
          if (key) {
            viewersKeyed[key] = this.viewer;
          } else {
            viewerNoKey = this.viewer;
          }
          window.viewer = this.viewer;
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          var _this3 = this;
          var selectedSegments = {};
          var _iterator3 = _createForOfIteratorHelper(this.viewer.layerManager.managedLayers), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var layer = _step3.value;
              if (layer.layer instanceof _segmentation_user_layer.SegmentationUserLayer) {
                var segmentSelectionState = layer.layer.displayState.segmentSelectionState;
                selectedSegments[layer.name] = segmentSelectionState.selectedSegment;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          var viewerState = this.props.viewerState;
          if (viewerState) {
            var newViewerState = _objectSpread({}, viewerState);
            var restoreStates = [function() {
              _this3.viewer.state.restoreState(newViewerState);
            }];
            if (viewerState.projectionScale === null) {
              delete newViewerState.projectionScale;
              restoreStates.push(function() {
                _this3.viewer.projectionScale.reset();
              });
            }
            if (viewerState.crossSectionScale === null) {
              delete newViewerState.crossSectionScale;
            }
            restoreStates.forEach(function(restore) {
              return restore();
            });
          }
          var _iterator4 = _createForOfIteratorHelper(this.viewer.layerManager.managedLayers), _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
              var _layer3 = _step4.value;
              if (_layer3.layer instanceof _segmentation_user_layer.SegmentationUserLayer) {
                var _segmentSelectionState = _layer3.layer.displayState.segmentSelectionState;
                _segmentSelectionState.set(selectedSegments[_layer3.name]);
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          if ("position" in viewerState) {
            if (Array.isArray(viewerState.position)) {
              if (viewerState.position.length === 0) {
                this.viewer.position.reset();
              }
            }
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          var key = this.props.key;
          if (key) {
            delete viewersKeyed[key];
          } else {
            viewerNoKey = void 0;
          }
        }
        /* setCallbacks allows us to set a callback on a neuroglancer event
         * each callback created should be in the format:
         * [
         *   {
         *     name: 'unique-name',
         *     event: 'the neuroglancer event to target, eg: click0, keyt',
         *     function: (slice) => { slice.whatever }
         *   },
         *   {...}
         * ]
         *
         */
      }, {
        key: "setCallbacks",
        value: function setCallbacks(callbacks) {
          var _this4 = this;
          callbacks.forEach(function(callback) {
            _this4.viewer.bindCallback(callback.name, callback["function"]);
            _this4.viewer.inputEventBindings.sliceView.set(callback.event, callback.name);
          });
        }
      }, {
        key: "render",
        value: function render() {
          var perspectiveZoom = this.props.perspectiveZoom;
          return /* @__PURE__ */ _react["default"].createElement("div", {
            className: "neuroglancer-container",
            ref: this.ngContainer
          }, /* @__PURE__ */ _react["default"].createElement("p", null, "Neuroglancer here with zoom ", perspectiveZoom));
        }
      }]);
      return Neuroglancer3;
    }(_react["default"].Component);
    exports["default"] = Neuroglancer2;
    Neuroglancer2.propTypes = {
      perspectiveZoom: _propTypes["default"].number,
      viewerState: _propTypes["default"].object,
      brainMapsClientId: _propTypes["default"].string,
      key: _propTypes["default"].string,
      /**
       * An array of event bindings to change in Neuroglancer.  The array format is as follows:
       * [[old-event1, new-event1], [old-event2], old-event3]
       * Here, `old-event1`'s will be unbound and its action will be re-bound to `new-event1`.
       * The bindings for `old-event2` and `old-event3` will be removed.
       * Neuroglancer has its own syntax for event descriptors, and here are some examples:
       * 'keya', 'shift+keyb' 'control+keyc', 'digit4', 'space', 'arrowleft', 'comma', 'period',
       * 'minus', 'equal', 'bracketleft'.
       */
      eventBindingsToUpdate: _propTypes["default"].array,
      /**
       * A function of the form `(segment, layer) => {}`, called each time there is a change to
       * the segment the user has "selected" (i.e., hovered over) in Neuroglancer.
       * The `segment` argument will be a Neuroglancer `Uint64` with the ID of the now-selected
       * segment, or `null` if no segment is now selected.
       * The `layer` argument will be a Neuroglaner `ManagedUserLayer`, whose `layer` property
       * will be a Neuroglancer `SegmentationUserLayer`.
       */
      onSelectedChanged: _propTypes["default"].func,
      /**
       * A function of the form `(segments, layer) => {}`, called each time there is a change to
       * the segments the user has designated as "visible" (i.e., double-clicked on) in Neuroglancer.
       * The `segments` argument will be a Neuroglancer `Uint64Set` whose elements are `Uint64`
       * instances for the IDs of the now-visible segments.
       * The `layer` argument will be a Neuroglaner `ManagedUserLayer`, whose `layer` property
       * will be a Neuroglancer `SegmentationUserLayer`.
       */
      onVisibleChanged: _propTypes["default"].func,
      /**
       * A function of the form `() => {}` to respond to selection changes in the viewer.
       */
      onSelectionDetailsStateChanged: _propTypes["default"].func,
      onViewerStateChanged: _propTypes["default"].func,
      callbacks: _propTypes["default"].arrayOf(_propTypes["default"].object),
      ngServer: _propTypes["default"].string
    };
    Neuroglancer2.defaultProps = {
      perspectiveZoom: 20,
      eventBindingsToUpdate: null,
      brainMapsClientId: "NOT_A_VALID_ID",
      viewerState: null,
      onSelectedChanged: null,
      onVisibleChanged: null,
      onSelectionDetailsStateChanged: null,
      onViewerStateChanged: null,
      key: null,
      callbacks: [],
      ngServer: "https://neuroglancer-demo.appspot.com/"
    };
  })(lib);
  return lib;
}
var libExports = requireLib();
const index = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
const index$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [libExports]);
export {
  index$1 as i
};
