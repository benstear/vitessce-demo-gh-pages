import * as React$1 from "react";
import React__default, { useContext, forwardRef, useRef, useMemo, createContext, createElement, Suspense } from "react";
import * as ReactDOM from "react-dom";
import "@vitessce/vit-s";
function accessor(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}
function getter(path2) {
  return path2.length === 1 ? get1(path2[0]) : getN(path2);
}
const get1 = (field2) => function(obj) {
  return obj[field2];
};
const getN = (path2) => {
  const len = path2.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path2[i]];
    }
    return obj;
  };
};
function error(message) {
  throw Error(message);
}
function splitAccessPath(p) {
  const path2 = [], n = p.length;
  let q = null, b2 = 0, s = "", i, j, c2;
  p = p + "";
  function push2() {
    path2.push(s + p.substring(i, j));
    s = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c2 = p[j];
    if (c2 === "\\") {
      s += p.substring(i, j);
      s += p.substring(++j, ++j);
      i = j;
    } else if (c2 === q) {
      push2();
      q = null;
      b2 = -1;
    } else if (q) {
      continue;
    } else if (i === b2 && c2 === '"') {
      i = j + 1;
      q = c2;
    } else if (i === b2 && c2 === "'") {
      i = j + 1;
      q = c2;
    } else if (c2 === "." && !b2) {
      if (j > i) {
        push2();
      } else {
        i = j + 1;
      }
    } else if (c2 === "[") {
      if (j > i) push2();
      b2 = i = j + 1;
    } else if (c2 === "]") {
      if (!b2) error("Access path missing open bracket: " + p);
      if (b2 > 0) push2();
      b2 = 0;
      i = j + 1;
    }
  }
  if (b2) error("Access path missing closing bracket: " + p);
  if (q) error("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push2();
  }
  return path2;
}
function field$1(field2, name, opt) {
  const path2 = splitAccessPath(field2);
  field2 = path2.length === 1 ? path2[0] : field2;
  return accessor((opt && opt.get || getter)(path2), [field2], name || field2);
}
const id = field$1("id");
const identity$6 = accessor((_) => _, [], "identity");
const zero$5 = accessor(() => 0, [], "zero");
const one$3 = accessor(() => 1, [], "one");
const truthy = accessor(() => true, [], "true");
const falsy = accessor(() => false, [], "false");
function log$1$1(method2, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method2].apply(console, args);
}
const None$2 = 0;
const Error$1 = 1;
const Warn = 2;
const Info = 3;
const Debug = 4;
function logger(_, method2, handler = log$1$1) {
  let level = _ || None$2;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$1) handler(method2 || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn) handler(method2 || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info) handler(method2 || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug) handler(method2 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var isArray$1 = Array.isArray;
function isObject$1(_) {
  return _ === Object(_);
}
const isLegalKey = (key2) => key2 !== "__proto__";
function mergeConfig(...configs) {
  return configs.reduce((out, source2) => {
    for (const key2 in source2) {
      if (key2 === "signals") {
        out.signals = mergeNamed(out.signals, source2.signals);
      } else {
        const r2 = key2 === "legend" ? {
          layout: 1
        } : key2 === "style" ? true : null;
        writeConfig(out, key2, source2[key2], r2);
      }
    }
    return out;
  }, {});
}
function writeConfig(output2, key2, value2, recurse2) {
  if (!isLegalKey(key2)) return;
  let k, o;
  if (isObject$1(value2) && !isArray$1(value2)) {
    o = isObject$1(output2[key2]) ? output2[key2] : output2[key2] = {};
    for (k in value2) {
      if (recurse2 && (recurse2 === true || recurse2[k])) {
        writeConfig(o, k, value2[k]);
      } else if (isLegalKey(k)) {
        o[k] = value2[k];
      }
    }
  } else {
    output2[key2] = value2;
  }
}
function mergeNamed(a2, b2) {
  if (a2 == null) return b2;
  const map2 = {}, out = [];
  function add2(_) {
    if (!map2[_.name]) {
      map2[_.name] = 1;
      out.push(_);
    }
  }
  b2.forEach(add2);
  a2.forEach(add2);
  return out;
}
function peek$2(array2) {
  return array2[array2.length - 1];
}
function toNumber(_) {
  return _ == null || _ === "" ? null : +_;
}
const exp$2 = (sign2) => (x2) => sign2 * Math.exp(x2);
const log$5 = (sign2) => (x2) => Math.log(sign2 * x2);
const symlog$1 = (c2) => (x2) => Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
const symexp = (c2) => (x2) => Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
const pow$4 = (exponent2) => (x2) => x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
function pan(domain2, delta, lift, ground) {
  const d0 = lift(domain2[0]), d1 = lift(peek$2(domain2)), dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear(domain2, delta) {
  return pan(domain2, delta, toNumber, identity$6);
}
function panLog(domain2, delta) {
  var sign2 = Math.sign(domain2[0]);
  return pan(domain2, delta, log$5(sign2), exp$2(sign2));
}
function panPow(domain2, delta, exponent2) {
  return pan(domain2, delta, pow$4(exponent2), pow$4(1 / exponent2));
}
function panSymlog(domain2, delta, constant2) {
  return pan(domain2, delta, symlog$1(constant2), symexp(constant2));
}
function zoom$2(domain2, anchor, scale2, lift, ground) {
  const d0 = lift(domain2[0]), d1 = lift(peek$2(domain2)), da = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da + (d0 - da) * scale2), ground(da + (d1 - da) * scale2)];
}
function zoomLinear(domain2, anchor, scale2) {
  return zoom$2(domain2, anchor, scale2, toNumber, identity$6);
}
function zoomLog(domain2, anchor, scale2) {
  const sign2 = Math.sign(domain2[0]);
  return zoom$2(domain2, anchor, scale2, log$5(sign2), exp$2(sign2));
}
function zoomPow(domain2, anchor, scale2, exponent2) {
  return zoom$2(domain2, anchor, scale2, pow$4(exponent2), pow$4(1 / exponent2));
}
function zoomSymlog(domain2, anchor, scale2, constant2) {
  return zoom$2(domain2, anchor, scale2, symlog$1(constant2), symexp(constant2));
}
function quarter(date2) {
  return 1 + ~~(new Date(date2).getMonth() / 3);
}
function utcquarter(date2) {
  return 1 + ~~(new Date(date2).getUTCMonth() / 3);
}
function array$5(_) {
  return _ != null ? isArray$1(_) ? _ : [_] : [];
}
function clampRange(range2, min2, max2) {
  let lo = range2[0], hi = range2[1], span2;
  if (hi < lo) {
    span2 = hi;
    hi = lo;
    lo = span2;
  }
  span2 = hi - lo;
  return span2 >= max2 - min2 ? [min2, max2] : [lo = Math.min(Math.max(lo, min2), max2 - span2), lo + span2];
}
function isFunction$3(_) {
  return typeof _ === "function";
}
const DESCENDING = "descending";
function compare$9(fields, orders, opt) {
  opt = opt || {};
  orders = array$5(orders) || [];
  const ord = [], get2 = [], fmap = {}, gen = opt.comparator || comparator$2;
  array$5(fields).forEach((f, i) => {
    if (f == null) return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get2.push(f = isFunction$3(f) ? f : field$1(f, null, opt));
    (accessorFields(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get2.length === 0 ? null : accessor(gen(get2, ord), Object.keys(fmap));
}
const ascending$3 = (u2, v) => (u2 < v || u2 == null) && v != null ? -1 : (u2 > v || v == null) && u2 != null ? 1 : (v = v instanceof Date ? +v : v, u2 = u2 instanceof Date ? +u2 : u2) !== u2 && v === v ? -1 : v !== v && u2 === u2 ? 1 : 0;
const comparator$2 = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
const compare1 = (field2, order) => function(a2, b2) {
  return ascending$3(field2(a2), field2(b2)) * order;
};
const compareN = (fields, orders, n) => {
  orders.push(0);
  return function(a2, b2) {
    let f, c2 = 0, i = -1;
    while (c2 === 0 && ++i < n) {
      f = fields[i];
      c2 = ascending$3(f(a2), f(b2));
    }
    return c2 * orders[i];
  };
};
function constant$5(_) {
  return isFunction$3(_) ? _ : () => _;
}
function debounce$1(delay, handler) {
  let tid;
  return (e3) => {
    if (tid) clearTimeout(tid);
    tid = setTimeout(() => (handler(e3), tid = null), delay);
  };
}
function extend$3(_) {
  for (let x2, k, i = 1, len = arguments.length; i < len; ++i) {
    x2 = arguments[i];
    for (k in x2) {
      _[k] = x2[k];
    }
  }
  return _;
}
function extent(array2, f) {
  let i = 0, n, v, min2, max2;
  if (array2 && (n = array2.length)) {
    if (f == null) {
      for (v = array2[i]; i < n && (v == null || v !== v); v = array2[++i]) ;
      min2 = max2 = v;
      for (; i < n; ++i) {
        v = array2[i];
        if (v != null) {
          if (v < min2) min2 = v;
          if (v > max2) max2 = v;
        }
      }
    } else {
      for (v = f(array2[i]); i < n && (v == null || v !== v); v = f(array2[++i])) ;
      min2 = max2 = v;
      for (; i < n; ++i) {
        v = f(array2[i]);
        if (v != null) {
          if (v < min2) min2 = v;
          if (v > max2) max2 = v;
        }
      }
    }
  }
  return [min2, max2];
}
function extentIndex(array2, f) {
  const n = array2.length;
  let i = -1, a2, b2, c2, u2, v;
  if (f == null) {
    while (++i < n) {
      b2 = array2[i];
      if (b2 != null && b2 >= b2) {
        a2 = c2 = b2;
        break;
      }
    }
    if (i === n) return [-1, -1];
    u2 = v = i;
    while (++i < n) {
      b2 = array2[i];
      if (b2 != null) {
        if (a2 > b2) {
          a2 = b2;
          u2 = i;
        }
        if (c2 < b2) {
          c2 = b2;
          v = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b2 = f(array2[i], i, array2);
      if (b2 != null && b2 >= b2) {
        a2 = c2 = b2;
        break;
      }
    }
    if (i === n) return [-1, -1];
    u2 = v = i;
    while (++i < n) {
      b2 = f(array2[i], i, array2);
      if (b2 != null) {
        if (a2 > b2) {
          a2 = b2;
          u2 = i;
        }
        if (c2 < b2) {
          c2 = b2;
          v = i;
        }
      }
    }
  }
  return [u2, v];
}
const hop = Object.prototype.hasOwnProperty;
function has$2(object2, property2) {
  return hop.call(object2, property2);
}
const NULL = {};
function fastmap(input) {
  let obj = {}, test2;
  function has$12(key2) {
    return has$2(obj, key2) && obj[key2] !== NULL;
  }
  const map2 = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$12,
    get(key2) {
      return has$12(key2) ? obj[key2] : void 0;
    },
    set(key2, value2) {
      if (!has$12(key2)) {
        ++map2.size;
        if (obj[key2] === NULL) --map2.empty;
      }
      obj[key2] = value2;
      return this;
    },
    delete(key2) {
      if (has$12(key2)) {
        --map2.size;
        ++map2.empty;
        obj[key2] = NULL;
      }
      return this;
    },
    clear() {
      map2.size = map2.empty = 0;
      map2.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test2 = _;
        return map2;
      } else {
        return test2;
      }
    },
    clean() {
      const next2 = {};
      let size = 0;
      for (const key2 in obj) {
        const value2 = obj[key2];
        if (value2 !== NULL && (!test2 || !test2(value2))) {
          next2[key2] = value2;
          ++size;
        }
      }
      map2.size = size;
      map2.empty = 0;
      map2.object = obj = next2;
    }
  };
  if (input) Object.keys(input).forEach((key2) => {
    map2.set(key2, input[key2]);
  });
  return map2;
}
function flush(range2, value2, threshold2, left, right, center) {
  if (!threshold2 && threshold2 !== 0) return center;
  const t4 = +threshold2;
  let a2 = range2[0], b2 = peek$2(range2), l;
  if (b2 < a2) {
    l = a2;
    a2 = b2;
    b2 = l;
  }
  l = Math.abs(value2 - a2);
  const r2 = Math.abs(b2 - value2);
  return l < r2 && l <= t4 ? left : r2 <= t4 ? right : center;
}
function inherits(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend$3(proto, members);
}
function inrange(value2, range2, left, right) {
  let r0 = range2[0], r1 = range2[range2.length - 1], t4;
  if (r0 > r1) {
    t4 = r0;
    r0 = r1;
    r1 = t4;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value2 : r0 < value2) && (right ? value2 <= r1 : value2 < r1);
}
function isBoolean$2(_) {
  return typeof _ === "boolean";
}
function isDate$1(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable(_) {
  return _ && isFunction$3(_[Symbol.iterator]);
}
function isNumber$1(_) {
  return typeof _ === "number";
}
function isRegExp(_) {
  return Object.prototype.toString.call(_) === "[object RegExp]";
}
function isString(_) {
  return typeof _ === "string";
}
function key(fields, flat2, opt) {
  if (fields) {
    fields = flat2 ? array$5(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array$5(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter, map2 = (f) => gen(flat2 ? [f] : splitAccessPath(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get2 = map2(fields[0]);
    fn = function(_) {
      return "" + get2(_);
    };
  } else {
    const get2 = fields.map(map2);
    fn = function(_) {
      let s = "" + get2[0](_), i = 0;
      while (++i < len) s += "|" + get2[i](_);
      return s;
    };
  }
  return accessor(fn, fields, "key");
}
function lerp(array2, frac) {
  const lo = array2[0], hi = peek$2(array2), f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}
const DEFAULT_MAX_SIZE = 1e4;
function lruCache$1(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev2, size;
  const clear2 = () => {
    curr = {};
    prev2 = {};
    size = 0;
  };
  const update2 = (key2, value2) => {
    if (++size > maxsize) {
      prev2 = curr;
      curr = {};
      size = 1;
    }
    return curr[key2] = value2;
  };
  clear2();
  return {
    clear: clear2,
    has: (key2) => has$2(curr, key2) || has$2(prev2, key2),
    get: (key2) => has$2(curr, key2) ? curr[key2] : has$2(prev2, key2) ? update2(key2, prev2[key2]) : void 0,
    set: (key2, value2) => has$2(curr, key2) ? curr[key2] = value2 : update2(key2, value2)
  };
}
function merge$4(compare2, array0, array1, output2) {
  const n0 = array0.length, n1 = array1.length;
  if (!n1) return array0;
  if (!n0) return array1;
  const merged = output2 || new array0.constructor(n0 + n1);
  let i0 = 0, i1 = 0, i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare2(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}
function repeat(str, reps) {
  let s = "";
  while (--reps >= 0) s += str;
  return s;
}
function pad$2(str, length2, padchar, align2) {
  const c2 = padchar || " ", s = str + "", n = length2 - s.length;
  return n <= 0 ? s : align2 === "left" ? repeat(c2, n) + s : align2 === "center" ? repeat(c2, ~~(n / 2)) + s + repeat(c2, Math.ceil(n / 2)) : s + repeat(c2, n);
}
function span(array2) {
  return array2 && peek$2(array2) - array2[0] || 0;
}
function $(x2) {
  return isArray$1(x2) ? "[" + x2.map($) + "]" : isObject$1(x2) || isString(x2) ? (
    // Output valid JSON and JS source strings.
    // See http://timelessrepo.com/json-isnt-a-javascript-subset
    JSON.stringify(x2).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029")
  ) : x2;
}
function toBoolean(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
const defaultParser = (_) => isNumber$1(_) ? _ : isDate$1(_) ? _ : Date.parse(_);
function toDate(_, parser2) {
  parser2 = parser2 || defaultParser;
  return _ == null || _ === "" ? null : parser2(_);
}
function toString(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet(_) {
  const s = {}, n = _.length;
  for (let i = 0; i < n; ++i) s[_[i]] = true;
  return s;
}
function truncate$1(str, length2, align2, ellipsis) {
  const e3 = ellipsis != null ? ellipsis : "…", s = str + "", n = s.length, l = Math.max(0, length2 - e3.length);
  return n <= length2 ? s : align2 === "left" ? e3 + s.slice(n - l) : align2 === "center" ? s.slice(0, Math.ceil(l / 2)) + e3 + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e3;
}
function visitArray(array2, filter2, visitor) {
  if (array2) {
    if (filter2) {
      const n = array2.length;
      for (let i = 0; i < n; ++i) {
        const t4 = filter2(array2[i]);
        if (t4) visitor(t4, i, array2);
      }
    } else {
      array2.forEach(visitor);
    }
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest$x(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
}
function formatValue$3(value2, valueToHtml, maxDepth2) {
  if (isArray$1(value2)) {
    return `[${value2.map((v) => valueToHtml(isString(v) ? v : stringify$4(v, maxDepth2))).join(", ")}]`;
  }
  if (isObject$1(value2)) {
    let content2 = "";
    const _a = value2, { title: title2, image: image2 } = _a, rest = __rest$x(_a, ["title", "image"]);
    if (title2) {
      content2 += `<h2>${valueToHtml(title2)}</h2>`;
    }
    if (image2) {
      content2 += `<img src="${valueToHtml(image2)}">`;
    }
    const keys2 = Object.keys(rest);
    if (keys2.length > 0) {
      content2 += "<table>";
      for (const key2 of keys2) {
        let val = rest[key2];
        if (val === void 0) {
          continue;
        }
        if (isObject$1(val)) {
          val = stringify$4(val, maxDepth2);
        }
        content2 += `<tr><td class="key">${valueToHtml(key2)}:</td><td class="value">${valueToHtml(val)}</td></tr>`;
      }
      content2 += `</table>`;
    }
    return content2 || "{}";
  }
  return valueToHtml(value2);
}
function replacer$1(maxDepth2) {
  const stack2 = [];
  return function(key2, value2) {
    if (typeof value2 !== "object" || value2 === null) {
      return value2;
    }
    const pos = stack2.indexOf(this) + 1;
    stack2.length = pos;
    if (stack2.length > maxDepth2) {
      return "[Object]";
    }
    if (stack2.indexOf(value2) >= 0) {
      return "[Circular]";
    }
    stack2.push(value2);
    return value2;
  };
}
function stringify$4(obj, maxDepth2) {
  return JSON.stringify(obj, replacer$1(maxDepth2));
}
var defaultStyle$1 = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black; }
  #vg-tooltip-element.visible {
    visibility: visible; }
  #vg-tooltip-element h2 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 13px; }
  #vg-tooltip-element img {
    max-width: 200px;
    max-height: 200px; }
  #vg-tooltip-element table {
    border-spacing: 0; }
    #vg-tooltip-element table tr {
      border: none; }
      #vg-tooltip-element table tr td {
        overflow: hidden;
        text-overflow: ellipsis;
        padding-top: 2px;
        padding-bottom: 2px; }
        #vg-tooltip-element table tr td.key {
          color: #808080;
          max-width: 150px;
          text-align: right;
          padding-right: 4px; }
        #vg-tooltip-element table tr td.value {
          display: block;
          max-width: 300px;
          max-height: 7em;
          text-align: left; }
  #vg-tooltip-element.dark-theme {
    background-color: rgba(32, 32, 32, 0.9);
    border: 1px solid #f5f5f5;
    color: white; }
    #vg-tooltip-element.dark-theme td.key {
      color: #bfbfbf; }
`;
const EL_ID$1 = "vg-tooltip-element";
const DEFAULT_OPTIONS$1 = {
  /**
   * X offset.
   */
  offsetX: 10,
  /**
   * Y offset.
   */
  offsetY: 10,
  /**
   * ID of the tooltip element.
   */
  id: EL_ID$1,
  /**
   * ID of the tooltip CSS style.
   */
  styleId: "vega-tooltip-style",
  /**
   * The name of the theme. You can use the CSS class called [THEME]-theme to style the tooltips.
   *
   * There are two predefined themes: "light" (default) and "dark".
   */
  theme: "light",
  /**
   * Do not use the default styles provided by Vega Tooltip. If you enable this option, you need to use your own styles. It is not necessary to disable the default style when using a custom theme.
   */
  disableDefaultStyle: false,
  /**
   * HTML sanitizer function that removes dangerous HTML to prevent XSS.
   *
   * This should be a function from string to string. You may replace it with a formatter such as a markdown formatter.
   */
  sanitize: escapeHTML$1,
  /**
   * The maximum recursion depth when printing objects in the tooltip.
   */
  maxDepth: 2,
  /**
   * A function to customize the rendered HTML of the tooltip.
   * @param value A value string, or object of value strings keyed by field
   * @param sanitize The `sanitize` function from `options.sanitize`
   * @returns {string} The returned string will become the `innerHTML` of the tooltip element
   */
  formatTooltip: formatValue$3
};
function escapeHTML$1(value2) {
  return String(value2).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function createDefaultStyle$1(id2) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(id2)) {
    throw new Error("Invalid HTML ID");
  }
  return defaultStyle$1.toString().replace(EL_ID$1, id2);
}
function calculatePosition$1(event2, tooltipBox, offsetX, offsetY) {
  let x2 = event2.clientX + offsetX;
  if (x2 + tooltipBox.width > window.innerWidth) {
    x2 = +event2.clientX - offsetX - tooltipBox.width;
  }
  let y2 = event2.clientY + offsetY;
  if (y2 + tooltipBox.height > window.innerHeight) {
    y2 = +event2.clientY - offsetY - tooltipBox.height;
  }
  return { x: x2, y: y2 };
}
let Handler$2 = class Handler {
  /**
   * Create the tooltip handler and initialize the element and style.
   *
   * @param options Tooltip Options
   */
  constructor(options) {
    this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS$1), options);
    const elementId = this.options.id;
    this.el = null;
    this.call = this.tooltipHandler.bind(this);
    if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const style2 = document.createElement("style");
      style2.setAttribute("id", this.options.styleId);
      style2.innerHTML = createDefaultStyle$1(elementId);
      const head = document.head;
      if (head.childNodes.length > 0) {
        head.insertBefore(style2, head.childNodes[0]);
      } else {
        head.appendChild(style2);
      }
    }
  }
  /**
   * The tooltip handler function.
   */
  tooltipHandler(handler, event2, item, value2) {
    var _a;
    this.el = document.getElementById(this.options.id);
    if (!this.el) {
      this.el = document.createElement("div");
      this.el.setAttribute("id", this.options.id);
      this.el.classList.add("vg-tooltip");
      document.body.appendChild(this.el);
    }
    const tooltipContainer = (_a = document.fullscreenElement) !== null && _a !== void 0 ? _a : document.body;
    tooltipContainer.appendChild(this.el);
    if (value2 == null || value2 === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = this.options.formatTooltip(value2, this.options.sanitize, this.options.maxDepth);
    this.el.classList.add("visible", `${this.options.theme}-theme`);
    const { x: x2, y: y2 } = calculatePosition$1(event2, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
    this.el.setAttribute("style", `top: ${y2}px; left: ${x2}px`);
  }
};
var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object2 = objectConverter(columns);
  return function(row, i) {
    return f(object2(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column2 in row) {
      if (!(column2 in columnSet)) {
        columns.push(columnSet[column2] = column2);
      }
    }
  });
  return columns;
}
function pad$1(value2, width2) {
  var s = value2 + "", length2 = s.length;
  return length2 < width2 ? new Array(width2 - length2 + 1).join(0) + s : s;
}
function formatYear$1(year2) {
  return year2 < 0 ? "-" + pad$1(-year2, 6) : year2 > 9999 ? "+" + pad$1(year2, 6) : pad$1(year2, 4);
}
function formatDate(date2) {
  var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds = date2.getUTCSeconds(), milliseconds = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear$1(date2.getUTCFullYear()) + "-" + pad$1(date2.getUTCMonth() + 1, 2) + "-" + pad$1(date2.getUTCDate(), 2) + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z" : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z" : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z" : "");
}
function dsvFormat(delimiter2) {
  var reFormat = new RegExp('["' + delimiter2 + "\n\r]"), DELIMITER = delimiter2.charCodeAt(0);
  function parse2(text2, f) {
    var convert, columns, rows = parseRows(text2, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text2, f) {
    var rows = [], N = text2.length, I = 0, n = 0, t4, eof = N <= 0, eol = false;
    if (text2.charCodeAt(N - 1) === NEWLINE) --N;
    if (text2.charCodeAt(N - 1) === RETURN) --N;
    function token2() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;
      var i, j = I, c2;
      if (text2.charCodeAt(j) === QUOTE) {
        while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE) ;
        if ((i = I) >= N) eof = true;
        else if ((c2 = text2.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE) ++I;
        }
        return text2.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c2 = text2.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE) ++I;
        } else if (c2 !== DELIMITER) continue;
        return text2.slice(j, i);
      }
      return eof = true, text2.slice(j, N);
    }
    while ((t4 = token2()) !== EOF) {
      var row = [];
      while (t4 !== EOL && t4 !== EOF) row.push(t4), t4 = token2();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column2) {
        return formatValue2(row[column2]);
      }).join(delimiter2);
    });
  }
  function format2(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue2).join(delimiter2)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue2).join(delimiter2);
  }
  function formatValue2(value2) {
    return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
  }
  return {
    parse: parse2,
    parseRows,
    format: format2,
    formatBody,
    formatRows,
    formatRow,
    formatValue: formatValue2
  };
}
function identity$5(x2) {
  return x2;
}
function transform$3(transform2) {
  if (transform2 == null) return identity$5;
  var x02, y02, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
  return function(input, i) {
    if (!i) x02 = y02 = 0;
    var j = 2, n = input.length, output2 = new Array(n);
    output2[0] = (x02 += input[0]) * kx + dx;
    output2[1] = (y02 += input[1]) * ky + dy;
    while (j < n) output2[j] = input[j], ++j;
    return output2;
  };
}
function reverse$2(array2, n) {
  var t4, j = array2.length, i = j - n;
  while (i < --j) t4 = array2[i], array2[i++] = array2[j], array2[j] = t4;
}
function feature(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
    return feature$1(topology, o2);
  }) } : feature$1(topology, o);
}
function feature$1(topology, o) {
  var id2 = o.id, bbox = o.bbox, properties2 = o.properties == null ? {} : o.properties, geometry = object$2(topology, o);
  return id2 == null && bbox == null ? { type: "Feature", properties: properties2, geometry } : bbox == null ? { type: "Feature", id: id2, properties: properties2, geometry } : { type: "Feature", id: id2, bbox, properties: properties2, geometry };
}
function object$2(topology, o) {
  var transformPoint = transform$3(topology.transform), arcs = topology.arcs;
  function arc2(i, points2) {
    if (points2.length) points2.pop();
    for (var a2 = arcs[i < 0 ? ~i : i], k = 0, n = a2.length; k < n; ++k) {
      points2.push(transformPoint(a2[k], k));
    }
    if (i < 0) reverse$2(points2, n);
  }
  function point2(p) {
    return transformPoint(p);
  }
  function line2(arcs2) {
    var points2 = [];
    for (var i = 0, n = arcs2.length; i < n; ++i) arc2(arcs2[i], points2);
    if (points2.length < 2) points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line2(arcs2);
    while (points2.length < 4) points2.push(points2[0]);
    return points2;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o2) {
    var type2 = o2.type, coordinates;
    switch (type2) {
      case "GeometryCollection":
        return { type: type2, geometries: o2.geometries.map(geometry) };
      case "Point":
        coordinates = point2(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point2);
        break;
      case "LineString":
        coordinates = line2(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line2);
        break;
      case "Polygon":
        coordinates = polygon(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return { type: type2, coordinates };
  }
  return geometry(o);
}
function stitch(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc2 = topology.arcs[i < 0 ? ~i : i], t4;
    if (arc2.length < 3 && !arc2[1][0] && !arc2[1][1]) {
      t4 = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t4;
    }
  });
  arcs.forEach(function(i) {
    var e3 = ends(i), start = e3[0], end = e3[1], f, g;
    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });
  function ends(i) {
    var arc2 = topology.arcs[i < 0 ? ~i : i], p02 = arc2[0], p1;
    if (topology.transform) p1 = [0, 0], arc2.forEach(function(dp) {
      p1[0] += dp[0], p1[1] += dp[1];
    });
    else p1 = arc2[arc2.length - 1];
    return i < 0 ? [p1, p02] : [p02, p1];
  }
  function flush2(fragmentByEnd2, fragmentByStart2) {
    for (var k in fragmentByEnd2) {
      var f = fragmentByEnd2[k];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush2(fragmentByEnd, fragmentByStart);
  flush2(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
  });
  return fragments;
}
function mesh(topology) {
  return object$2(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object2, filter2) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object2, filter2);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return { type: "MultiLineString", arcs: stitch(topology, arcs) };
}
function extractArcs(topology, object2, filter2) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o.arcs);
        break;
      case "MultiPolygon":
        extract3(o.arcs);
        break;
    }
  }
  geometry(object2);
  geomsByArc.forEach(filter2 == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter2(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
  });
  return arcs;
}
function ascending$2(a2, b2) {
  return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function descending$1(a2, b2) {
  return a2 == null || b2 == null ? NaN : b2 < a2 ? -1 : b2 > a2 ? 1 : b2 >= a2 ? 0 : NaN;
}
function bisector$1(f) {
  let compare12, compare2, delta;
  if (f.length !== 2) {
    compare12 = ascending$2;
    compare2 = (d, x2) => ascending$2(f(d), x2);
    delta = (d, x2) => f(d) - x2;
  } else {
    compare12 = f === ascending$2 || f === descending$1 ? f : zero$4;
    compare2 = f;
    delta = f;
  }
  function left(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare12(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare12(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a2, x2, lo = 0, hi = a2.length) {
    const i = left(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero$4() {
  return 0;
}
function number$7(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers$2(values2, valueof) {
  if (valueof === void 0) {
    for (let value2 of values2) {
      if (value2 != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index2, values2)) != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}
const ascendingBisect = bisector$1(ascending$2);
const bisectRight$1 = ascendingBisect.right;
const bisectLeft$1 = ascendingBisect.left;
bisector$1(number$7).center;
function variance(values2, valueof) {
  let count2 = 0;
  let delta;
  let mean2 = 0;
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value2 of values2) {
      if (value2 != null && (value2 = +value2) >= value2) {
        delta = value2 - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value2 - mean2);
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index2, values2)) != null && (value2 = +value2) >= value2) {
        delta = value2 - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value2 - mean2);
      }
    }
  }
  if (count2 > 1) return sum2 / (count2 - 1);
}
function deviation(values2, valueof) {
  const v = variance(values2, valueof);
  return v ? Math.sqrt(v) : v;
}
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x2) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y2 = p[j], hi = x2 + y2, lo = Math.abs(x2) < Math.abs(y2) ? x2 - (hi - y2) : y2 - (hi - x2);
      if (lo) p[i++] = lo;
      x2 = hi;
    }
    p[i] = x2;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x2, y2, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x2 = hi;
        y2 = p[--n];
        hi = x2 + y2;
        lo = y2 - (hi - x2);
        if (lo) break;
      }
      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
        y2 = lo * 2;
        x2 = hi + y2;
        if (y2 == x2 - hi) hi = x2;
      }
    }
    return hi;
  }
}
class InternMap extends Map {
  constructor(entries2, key2 = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key2 } });
    if (entries2 != null) for (const [key22, value2] of entries2) this.set(key22, value2);
  }
  get(key2) {
    return super.get(intern_get(this, key2));
  }
  has(key2) {
    return super.has(intern_get(this, key2));
  }
  set(key2, value2) {
    return super.set(intern_set(this, key2), value2);
  }
  delete(key2) {
    return super.delete(intern_delete(this, key2));
  }
}
class InternSet extends Set {
  constructor(values2, key2 = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key2 } });
    if (values2 != null) for (const value2 of values2) this.add(value2);
  }
  has(value2) {
    return super.has(intern_get(this, value2));
  }
  add(value2) {
    return super.add(intern_set(this, value2));
  }
  delete(value2) {
    return super.delete(intern_delete(this, value2));
  }
}
function intern_get({ _intern, _key }, value2) {
  const key2 = _key(value2);
  return _intern.has(key2) ? _intern.get(key2) : value2;
}
function intern_set({ _intern, _key }, value2) {
  const key2 = _key(value2);
  if (_intern.has(key2)) return _intern.get(key2);
  _intern.set(key2, value2);
  return value2;
}
function intern_delete({ _intern, _key }, value2) {
  const key2 = _key(value2);
  if (_intern.has(key2)) {
    value2 = _intern.get(key2);
    _intern.delete(key2);
  }
  return value2;
}
function keyof(value2) {
  return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
}
function permute(source2, keys2) {
  return Array.from(keys2, (key2) => source2[key2]);
}
function compareDefined(compare2 = ascending$2) {
  if (compare2 === ascending$2) return ascendingDefined;
  if (typeof compare2 !== "function") throw new TypeError("compare is not a function");
  return (a2, b2) => {
    const x2 = compare2(a2, b2);
    if (x2 || x2 === 0) return x2;
    return (compare2(b2, b2) === 0) - (compare2(a2, a2) === 0);
  };
}
function ascendingDefined(a2, b2) {
  return (a2 == null || !(a2 >= a2)) - (b2 == null || !(b2 >= b2)) || (a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
}
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function ticks(start, stop3, count2) {
  var reverse2, i = -1, n, ticks2, step;
  stop3 = +stop3, start = +start, count2 = +count2;
  if (start === stop3 && count2 > 0) return [start];
  if (reverse2 = stop3 < start) n = start, start = stop3, stop3 = n;
  if ((step = tickIncrement(start, stop3, count2)) === 0 || !isFinite(step)) return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop3 / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop3) --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks2[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop3 * step);
    if (r0 / step < start) ++r0;
    if (r1 / step > stop3) --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks2[i] = (r0 + i) / step;
  }
  if (reverse2) ticks2.reverse();
  return ticks2;
}
function tickIncrement(start, stop3, count2) {
  var step = (stop3 - start) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error2 = step / Math.pow(10, power);
  return power >= 0 ? (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1);
}
function tickStep(start, stop3, count2) {
  var step0 = Math.abs(stop3 - start) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error2 = step0 / step1;
  if (error2 >= e10) step1 *= 10;
  else if (error2 >= e5) step1 *= 5;
  else if (error2 >= e2) step1 *= 2;
  return stop3 < start ? -step1 : step1;
}
function max$2(values2, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value2 of values2) {
      if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
        max2 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index2, values2)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
        max2 = value2;
      }
    }
  }
  return max2;
}
function min$2(values2, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value2 of values2) {
      if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
        min2 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index2, values2)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
        min2 = value2;
      }
    }
  }
  return min2;
}
function quickselect(array2, k, left = 0, right = array2.length - 1, compare2) {
  compare2 = compare2 === void 0 ? ascendingDefined : compareDefined(compare2);
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m2 = k - left + 1;
      const z2 = Math.log(n);
      const s = 0.5 * Math.exp(2 * z2 / 3);
      const sd = 0.5 * Math.sqrt(z2 * s * (n - s) / n) * (m2 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m2 * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m2) * s / n + sd));
      quickselect(array2, k, newLeft, newRight, compare2);
    }
    const t4 = array2[k];
    let i = left;
    let j = right;
    swap$1(array2, left, k);
    if (compare2(array2[right], t4) > 0) swap$1(array2, left, right);
    while (i < j) {
      swap$1(array2, i, j), ++i, --j;
      while (compare2(array2[i], t4) < 0) ++i;
      while (compare2(array2[j], t4) > 0) --j;
    }
    if (compare2(array2[left], t4) === 0) swap$1(array2, left, j);
    else ++j, swap$1(array2, j, right);
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
  return array2;
}
function swap$1(array2, i, j) {
  const t4 = array2[i];
  array2[i] = array2[j];
  array2[j] = t4;
}
function quantile$1(values2, p, valueof) {
  values2 = Float64Array.from(numbers$2(values2, valueof));
  if (!(n = values2.length)) return;
  if ((p = +p) <= 0 || n < 2) return min$2(values2);
  if (p >= 1) return max$2(values2);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max$2(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min$2(values2.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values2, p, valueof = number$7) {
  if (!(n = values2.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values2[0], 0, values2);
  if (p >= 1) return +valueof(values2[n - 1], n - 1, values2);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values2[i0], i0, values2), value1 = +valueof(values2[i0 + 1], i0 + 1, values2);
  return value0 + (value1 - value0) * (i - i0);
}
function mean(values2, valueof) {
  let count2 = 0;
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value2 of values2) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count2, sum2 += value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index2, values2)) != null && (value2 = +value2) >= value2) {
        ++count2, sum2 += value2;
      }
    }
  }
  if (count2) return sum2 / count2;
}
function median(values2, valueof) {
  return quantile$1(values2, 0.5, valueof);
}
function* flatten(arrays) {
  for (const array2 of arrays) {
    yield* array2;
  }
}
function merge$3(arrays) {
  return Array.from(flatten(arrays));
}
function range$6(start, stop3, step) {
  start = +start, stop3 = +stop3, step = (n = arguments.length) < 2 ? (stop3 = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop3 - start) / step)) | 0, range2 = new Array(n);
  while (++i < n) {
    range2[i] = start + i * step;
  }
  return range2;
}
function sum$1(values2, valueof) {
  let sum2 = 0;
  {
    for (let value2 of values2) {
      if (value2 = +value2) {
        sum2 += value2;
      }
    }
  }
  return sum2;
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value2, width2) {
    var i = value2.length, t4 = [], j = 0, g = grouping[0], length2 = 0;
    while (i > 0 && g > 0) {
      if (length2 + g + 1 > width2) g = Math.max(1, width2 - length2);
      t4.push(value2.substring(i -= g, i + g));
      if ((length2 += g + 1) > width2) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t4.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re$3 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match2 = re$3.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match2;
  return new FormatSpecifier({
    fill: match2[1],
    align: match2[2],
    sign: match2[3],
    symbol: match2[4],
    zero: match2[5],
    width: match2[6],
    comma: match2[7],
    precision: match2[8] && match2[8].slice(1),
    trim: match2[9],
    type: match2[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent;
function formatPrefixAuto(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d) return x2 + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
}
function formatRounded(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d) return x2 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x2, p) => (x2 * 100).toFixed(p),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal,
  "e": (x2, p) => x2.toExponential(p),
  "f": (x2, p) => x2.toFixed(p),
  "g": (x2, p) => x2.toPrecision(p),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p) => formatRounded(x2 * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$4(x2) {
  return x2;
}
var map$1 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$1(locale2) {
  var group2 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$4 : formatGroup(map$1.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$4 : formatNumerals(map$1.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill2 = specifier.fill, align2 = specifier.align, sign2 = specifier.sign, symbol2 = specifier.symbol, zero2 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type2 = specifier.type;
    if (type2 === "n") comma = true, type2 = "g";
    else if (!formatTypes[type2]) precision === void 0 && (precision = 12), trim2 = true, type2 = "g";
    if (zero2 || fill2 === "0" && align2 === "=") zero2 = true, fill2 = "0", align2 = "=";
    var prefix2 = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value2) {
      var valuePrefix = prefix2, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim2) value2 = formatTrim(value2);
        if (valueNegative && +value2 === 0 && sign2 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value2.length;
          while (++i < n) {
            if (c2 = value2.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
              value2 = value2.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2) value2 = group2(value2, Infinity);
      var length2 = valuePrefix.length + value2.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill2) : "";
      if (comma && zero2) value2 = group2(padding2 + value2, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
      switch (align2) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding2;
          break;
        case "=":
          value2 = valuePrefix + padding2 + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value2 + valueSuffix + padding2.slice(length2);
          break;
        default:
          value2 = padding2 + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value2) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3, k = Math.pow(10, -e3), prefix2 = prefixes[8 + e3 / 3];
    return function(value22) {
      return f(k * value22) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$2;
var format$3;
var formatPrefix;
defaultLocale$2({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$2(definition2) {
  locale$2 = formatLocale$1(definition2);
  format$3 = locale$2.format;
  formatPrefix = locale$2.formatPrefix;
  return locale$2;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value2) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
var t0$2 = /* @__PURE__ */ new Date(), t1$1 = /* @__PURE__ */ new Date();
function newInterval(floori, offseti, count2, field2) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step) {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = function(start, stop3, step) {
    var range2 = [], previous;
    start = interval2.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop3) || !(step > 0)) return range2;
    do
      range2.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop3);
    return range2;
  };
  interval2.filter = function(test2) {
    return newInterval(function(date2) {
      if (date2 >= date2) while (floori(date2), !test2(date2)) date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test2(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test2(date2)) {
          }
        }
      }
    });
  };
  if (count2) {
    interval2.count = function(start, end) {
      t0$2.setTime(+start), t1$1.setTime(+end);
      floori(t0$2), floori(t1$1);
      return Math.floor(count2(t0$2, t1$1));
    };
    interval2.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field2 ? function(d) {
        return field2(d) % step === 0;
      } : function(d) {
        return interval2.count(0, d) % step === 0;
      });
    };
  }
  return interval2;
}
var millisecond = newInterval(function() {
}, function(date2, step) {
  date2.setTime(+date2 + step);
}, function(start, end) {
  return end - start;
});
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k) * k);
  }, function(date2, step) {
    date2.setTime(+date2 + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
millisecond.range;
const durationSecond$1 = 1e3;
const durationMinute$1 = durationSecond$1 * 60;
const durationHour$1 = durationMinute$1 * 60;
const durationDay$1 = durationHour$1 * 24;
const durationWeek$1 = durationDay$1 * 7;
const durationMonth$1 = durationDay$1 * 30;
const durationYear$1 = durationDay$1 * 365;
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step) {
  date2.setTime(+date2 + step * durationSecond$1);
}, function(start, end) {
  return (end - start) / durationSecond$1;
}, function(date2) {
  return date2.getUTCSeconds();
});
second.range;
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$1);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute$1);
}, function(start, end) {
  return (end - start) / durationMinute$1;
}, function(date2) {
  return date2.getMinutes();
});
minute.range;
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$1 - date2.getMinutes() * durationMinute$1);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour$1);
}, function(start, end) {
  return (end - start) / durationHour$1;
}, function(date2) {
  return date2.getHours();
});
hour.range;
var day = newInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1,
  (date2) => date2.getDate() - 1
);
day.range;
function weekday$1(i) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
  });
}
var sunday = weekday$1(0);
var monday = weekday$1(1);
var tuesday = weekday$1(2);
var wednesday = weekday$1(3);
var thursday = weekday$1(4);
var friday = weekday$1(5);
var saturday = weekday$1(6);
sunday.range;
monday.range;
tuesday.range;
wednesday.range;
thursday.range;
friday.range;
saturday.range;
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setMonth(date2.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
month.range;
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setFullYear(date2.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setFullYear(date2.getFullYear() + step * k);
  });
};
year.range;
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute$1);
}, function(start, end) {
  return (end - start) / durationMinute$1;
}, function(date2) {
  return date2.getUTCMinutes();
});
utcMinute.range;
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour$1);
}, function(start, end) {
  return (end - start) / durationHour$1;
}, function(date2) {
  return date2.getUTCHours();
});
utcHour.range;
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCDate(date2.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay$1;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
utcDay.range;
function utcWeekday(i) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek$1;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
utcMonth.range;
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
  });
};
utcYear.range;
function ticker(year2, month2, week2, day2, hour2, minute2) {
  const tickIntervals = [
    [second, 1, durationSecond$1],
    [second, 5, 5 * durationSecond$1],
    [second, 15, 15 * durationSecond$1],
    [second, 30, 30 * durationSecond$1],
    [minute2, 1, durationMinute$1],
    [minute2, 5, 5 * durationMinute$1],
    [minute2, 15, 15 * durationMinute$1],
    [minute2, 30, 30 * durationMinute$1],
    [hour2, 1, durationHour$1],
    [hour2, 3, 3 * durationHour$1],
    [hour2, 6, 6 * durationHour$1],
    [hour2, 12, 12 * durationHour$1],
    [day2, 1, durationDay$1],
    [day2, 2, 2 * durationDay$1],
    [week2, 1, durationWeek$1],
    [month2, 1, durationMonth$1],
    [month2, 3, 3 * durationMonth$1],
    [year2, 1, durationYear$1]
  ];
  function ticks2(start, stop3, count2) {
    const reverse2 = stop3 < start;
    if (reverse2) [start, stop3] = [stop3, start];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start, stop3, count2);
    const ticks22 = interval2 ? interval2.range(start, +stop3 + 1) : [];
    return reverse2 ? ticks22.reverse() : ticks22;
  }
  function tickInterval(start, stop3, count2) {
    const target2 = Math.abs(stop3 - start) / count2;
    const i = bisector$1(([, , step2]) => step2).right(tickIntervals, target2);
    if (i === tickIntervals.length) return year2.every(tickStep(start / durationYear$1, stop3 / durationYear$1, count2));
    if (i === 0) return millisecond.every(Math.max(tickStep(start, stop3, count2), 1));
    const [t4, step] = tickIntervals[target2 / tickIntervals[i - 1][2] < tickIntervals[i][2] / target2 ? i - 1 : i];
    return t4.every(step);
  }
  return [ticks2, tickInterval];
}
const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute);
const [timeTicks, timeTickInterval] = ticker(year, month, sunday, day, hour, minute);
const YEAR = "year";
const QUARTER = "quarter";
const MONTH = "month";
const WEEK = "week";
const DATE = "date";
const DAY = "day";
const DAYOFYEAR = "dayofyear";
const HOURS = "hours";
const MINUTES = "minutes";
const SECONDS = "seconds";
const MILLISECONDS = "milliseconds";
const TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
const UNITS = TIME_UNITS.reduce((o, u2, i) => (o[u2] = 1 + i, o), {});
function timeUnits(units) {
  const u2 = array$5(units).slice(), m2 = {};
  if (!u2.length) error("Missing time unit.");
  u2.forEach((unit2) => {
    if (has$2(UNITS, unit2)) {
      m2[unit2] = 1;
    } else {
      error("Invalid time unit: ".concat(unit2, "."));
    }
  });
  const numTypes = (m2[WEEK] || m2[DAY] ? 1 : 0) + (m2[QUARTER] || m2[MONTH] || m2[DATE] ? 1 : 0) + (m2[DAYOFYEAR] ? 1 : 0);
  if (numTypes > 1) {
    error("Incompatible time units: ".concat(units));
  }
  u2.sort((a2, b2) => UNITS[a2] - UNITS[b2]);
  return u2;
}
const defaultSpecifiers = {
  [YEAR]: "%Y ",
  [QUARTER]: "Q%q ",
  [MONTH]: "%b ",
  [DATE]: "%d ",
  [WEEK]: "W%U ",
  [DAY]: "%a ",
  [DAYOFYEAR]: "%j ",
  [HOURS]: "%H:00",
  [MINUTES]: "00:%M",
  [SECONDS]: ":%S",
  [MILLISECONDS]: ".%L",
  ["".concat(YEAR, "-").concat(MONTH)]: "%Y-%m ",
  ["".concat(YEAR, "-").concat(MONTH, "-").concat(DATE)]: "%Y-%m-%d ",
  ["".concat(HOURS, "-").concat(MINUTES)]: "%H:%M"
};
function timeUnitSpecifier(units, specifiers) {
  const s = extend$3({}, defaultSpecifiers, specifiers), u2 = timeUnits(units), n = u2.length;
  let fmt = "", start = 0, end, key2;
  for (start = 0; start < n; ) {
    for (end = u2.length; end > start; --end) {
      key2 = u2.slice(start, end).join("-");
      if (s[key2] != null) {
        fmt += s[key2];
        start = end;
        break;
      }
    }
  }
  return fmt.trim();
}
const t0$1 = /* @__PURE__ */ new Date();
function localYear(y2) {
  t0$1.setFullYear(y2);
  t0$1.setMonth(0);
  t0$1.setDate(1);
  t0$1.setHours(0, 0, 0, 0);
  return t0$1;
}
function dayofyear(d) {
  return localDayOfYear(new Date(d));
}
function week(d) {
  return localWeekNum(new Date(d));
}
function localDayOfYear(d) {
  return day.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return sunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y2) {
  return localYear(y2).getDay();
}
function localDate$1(y2, m2, d, H, M2, S, L) {
  if (0 <= y2 && y2 < 100) {
    const date2 = new Date(-1, m2, d, H, M2, S, L);
    date2.setFullYear(y2);
    return date2;
  }
  return new Date(y2, m2, d, H, M2, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear(new Date(d));
}
function utcweek(d) {
  return utcWeekNum(new Date(d));
}
function utcDayOfYear(d) {
  const y2 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y2 - 1, d);
}
function utcWeekNum(d) {
  const y2 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y2 - 1, d);
}
function utcFirst(y2) {
  t0$1.setTime(Date.UTC(y2, 0, 1));
  return t0$1.getUTCDay();
}
function utcDate$1(y2, m2, d, H, M2, S, L) {
  if (0 <= y2 && y2 < 100) {
    const date2 = new Date(Date.UTC(-1, m2, d, H, M2, S, L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(y2, m2, d, H, M2, S, L));
}
function floor(units, step, get2, inv, newDate2) {
  const s = step || 1, b2 = peek$2(units), _ = (unit2, p, key2) => {
    key2 = key2 || unit2;
    return getUnit(get2[key2], inv[key2], unit2 === b2 && s, p);
  };
  const t4 = /* @__PURE__ */ new Date(), u2 = toSet(units), y2 = u2[YEAR] ? _(YEAR) : constant$5(2012), m2 = u2[MONTH] ? _(MONTH) : u2[QUARTER] ? _(QUARTER) : zero$5, d = u2[WEEK] && u2[DAY] ? _(DAY, 1, WEEK + DAY) : u2[WEEK] ? _(WEEK, 1) : u2[DAY] ? _(DAY, 1) : u2[DATE] ? _(DATE, 1) : u2[DAYOFYEAR] ? _(DAYOFYEAR, 1) : one$3, H = u2[HOURS] ? _(HOURS) : zero$5, M2 = u2[MINUTES] ? _(MINUTES) : zero$5, S = u2[SECONDS] ? _(SECONDS) : zero$5, L = u2[MILLISECONDS] ? _(MILLISECONDS) : zero$5;
  return function(v) {
    t4.setTime(+v);
    const year2 = y2(t4);
    return newDate2(year2, m2(t4), d(t4, year2), H(t4), M2(t4), S(t4), L(t4));
  };
}
function getUnit(f, inv, step, phase) {
  const u2 = step <= 1 ? f : phase ? (d, y2) => phase + step * Math.floor((f(d, y2) - phase) / step) : (d, y2) => step * Math.floor(f(d, y2) / step);
  return inv ? (d, y2) => inv(u2(d, y2), y2) : u2;
}
function weekday(week2, day2, firstDay) {
  return day2 + week2 * 7 - (firstDay + 6) % 7;
}
const localGet = {
  [YEAR]: (d) => d.getFullYear(),
  [QUARTER]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH]: (d) => d.getMonth(),
  [DATE]: (d) => d.getDate(),
  [HOURS]: (d) => d.getHours(),
  [MINUTES]: (d) => d.getMinutes(),
  [SECONDS]: (d) => d.getSeconds(),
  [MILLISECONDS]: (d) => d.getMilliseconds(),
  [DAYOFYEAR]: (d) => localDayOfYear(d),
  [WEEK]: (d) => localWeekNum(d),
  [WEEK + DAY]: (d, y2) => weekday(localWeekNum(d), d.getDay(), localFirst(y2)),
  [DAY]: (d, y2) => weekday(1, d.getDay(), localFirst(y2))
};
const localInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w2, y2) => weekday(w2, 0, localFirst(y2))
};
function timeFloor(units, step) {
  return floor(units, step || 1, localGet, localInv, localDate$1);
}
const utcGet = {
  [YEAR]: (d) => d.getUTCFullYear(),
  [QUARTER]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH]: (d) => d.getUTCMonth(),
  [DATE]: (d) => d.getUTCDate(),
  [HOURS]: (d) => d.getUTCHours(),
  [MINUTES]: (d) => d.getUTCMinutes(),
  [SECONDS]: (d) => d.getUTCSeconds(),
  [MILLISECONDS]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR]: (d) => utcDayOfYear(d),
  [WEEK]: (d) => utcWeekNum(d),
  [DAY]: (d, y2) => weekday(1, d.getUTCDay(), utcFirst(y2)),
  [WEEK + DAY]: (d, y2) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y2))
};
const utcInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w2, y2) => weekday(w2, 0, utcFirst(y2))
};
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet, utcInv, utcDate$1);
}
const timeIntervals = {
  [YEAR]: year,
  [QUARTER]: month.every(3),
  [MONTH]: month,
  [WEEK]: sunday,
  [DATE]: day,
  [DAY]: day,
  [DAYOFYEAR]: day,
  [HOURS]: hour,
  [MINUTES]: minute,
  [SECONDS]: second,
  [MILLISECONDS]: millisecond
};
const utcIntervals = {
  [YEAR]: utcYear,
  [QUARTER]: utcMonth.every(3),
  [MONTH]: utcMonth,
  [WEEK]: utcSunday,
  [DATE]: utcDay,
  [DAY]: utcDay,
  [DAYOFYEAR]: utcDay,
  [HOURS]: utcHour,
  [MINUTES]: utcMinute,
  [SECONDS]: second,
  [MILLISECONDS]: millisecond
};
function timeInterval(unit2) {
  return timeIntervals[unit2];
}
function utcInterval(unit2) {
  return utcIntervals[unit2];
}
function offset$3(ival, date2, step) {
  return ival ? ival.offset(date2, step) : void 0;
}
function timeOffset(unit2, date2, step) {
  return offset$3(timeInterval(unit2), date2, step);
}
function utcOffset(unit2, date2, step) {
  return offset$3(utcInterval(unit2), date2, step);
}
function sequence$1(ival, start, stop3, step) {
  return ival ? ival.range(start, stop3, step) : void 0;
}
function timeSequence(unit2, start, stop3, step) {
  return sequence$1(timeInterval(unit2), start, stop3, step);
}
function utcSequence(unit2, start, stop3, step) {
  return sequence$1(utcInterval(unit2), start, stop3, step);
}
const durationSecond = 1e3, durationMinute = durationSecond * 60, durationHour = durationMinute * 60, durationDay = durationHour * 24, durationWeek = durationDay * 7, durationMonth = durationDay * 30, durationYear = durationDay * 365;
const Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS], Seconds = Milli.slice(0, -1), Minutes = Seconds.slice(0, -1), Hours = Minutes.slice(0, -1), Day = Hours.slice(0, -1), Week = [YEAR, WEEK], Month = [YEAR, MONTH], Year = [YEAR];
const intervals = [[Seconds, 1, durationSecond], [Seconds, 5, 5 * durationSecond], [Seconds, 15, 15 * durationSecond], [Seconds, 30, 30 * durationSecond], [Minutes, 1, durationMinute], [Minutes, 5, 5 * durationMinute], [Minutes, 15, 15 * durationMinute], [Minutes, 30, 30 * durationMinute], [Hours, 1, durationHour], [Hours, 3, 3 * durationHour], [Hours, 6, 6 * durationHour], [Hours, 12, 12 * durationHour], [Day, 1, durationDay], [Week, 1, durationWeek], [Month, 1, durationMonth], [Month, 3, 3 * durationMonth], [Year, 1, durationYear]];
function bin$1(opt) {
  const ext = opt.extent, max2 = opt.maxbins || 40, target2 = Math.abs(span(ext)) / max2;
  let i = bisector$1((i2) => i2[2]).right(intervals, target2), units, step;
  if (i === intervals.length) {
    units = Year, step = tickStep(ext[0] / durationYear, ext[1] / durationYear, max2);
  } else if (i) {
    i = intervals[target2 / intervals[i - 1][2] < intervals[i][2] / target2 ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli;
    step = Math.max(tickStep(ext[0], ext[1], max2), 1);
  }
  return {
    units,
    step
  };
}
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m2, d) {
  return { y: y2, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats2 = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats2.x = newFormat(locale_date, formats2);
  formats2.X = newFormat(locale_time, formats2);
  formats2.c = newFormat(locale_dateTime, formats2);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats22) {
    return function(date2) {
      var string2 = [], i = -1, j = 0, n = specifier.length, c2, pad2, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string2.push(specifier.slice(j, i));
          if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null) c2 = specifier.charAt(++i);
          else pad2 = c2 === "e" ? " " : "0";
          if (format2 = formats22[c2]) c2 = format2(date2, pad2);
          string2.push(c2);
          j = i + 1;
        }
      }
      string2.push(specifier.slice(j, i));
      return string2.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string2) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += "", 0), week2, day$1;
      if (i != string2.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week2 = utcDate(newDate(d.y, 0, 1)), day$1 = week2.getUTCDay();
          week2 = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week2) : utcMonday(week2);
          week2 = utcDay.offset(week2, (d.V - 1) * 7);
          d.y = week2.getUTCFullYear();
          d.m = week2.getUTCMonth();
          d.d = week2.getUTCDate() + (d.w + 6) % 7;
        } else {
          week2 = localDate(newDate(d.y, 0, 1)), day$1 = week2.getDay();
          week2 = day$1 > 4 || day$1 === 0 ? monday.ceil(week2) : monday(week2);
          week2 = day.offset(week2, (d.V - 1) * 7);
          d.y = week2.getFullYear();
          d.m = week2.getMonth();
          d.d = week2.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string2, j) {
    var i = 0, n = specifier.length, m2 = string2.length, c2, parse2;
    while (i < n) {
      if (j >= m2) return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse2 = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse2 || (j = parse2(d, string2, j)) < 0) return -1;
      } else if (c2 != string2.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string2, i) {
    var n = periodRe.exec(string2.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string2, i) {
    var n = shortWeekdayRe.exec(string2.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string2, i) {
    var n = weekdayRe.exec(string2.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string2, i) {
    var n = shortMonthRe.exec(string2.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string2, i) {
    var n = monthRe.exec(string2.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string2, i) {
    return parseSpecifier(d, locale_dateTime, string2, i);
  }
  function parseLocaleDate(d, string2, i) {
    return parseSpecifier(d, locale_date, string2, i);
  }
  function parseLocaleTime(d, string2, i) {
    return parseSpecifier(d, locale_time, string2, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats2);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value2, fill2, width2) {
  var sign2 = value2 < 0 ? "-" : "", string2 = (sign2 ? -value2 : value2) + "", length2 = string2.length;
  return sign2 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill2) + string2 : string2);
}
function requote(s) {
  return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string2, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string2, i) {
  var n = percentRe.exec(string2.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string2, i) {
  var n = numberRe.exec(string2.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + day.count(year(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z2 = d.getTimezoneOffset();
  return (z2 > 0 ? "-" : (z2 *= -1, "+")) + pad(z2 / 60 | 0, "0", 2) + pad(z2 % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}
var locale$1;
var timeFormat$2;
var timeParse$1;
var utcFormat$1;
var utcParse$1;
defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale$1(definition2) {
  locale$1 = formatLocale(definition2);
  timeFormat$2 = locale$1.format;
  timeParse$1 = locale$1.parse;
  utcFormat$1 = locale$1.utcFormat;
  utcParse$1 = locale$1.utcParse;
  return locale$1;
}
function memoize$2(method2) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method2(spec));
}
function trimZeroes(numberFormat2, decimalChar) {
  return (x2) => {
    const str = numberFormat2(x2), dec = str.indexOf(decimalChar);
    if (dec < 0) return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec) if (str[idx] !== "0") {
      ++idx;
      break;
    }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit(str, dec) {
  let i = str.lastIndexOf("e"), c2;
  if (i > 0) return i;
  for (i = str.length; --i > dec; ) {
    c2 = str.charCodeAt(i);
    if (c2 >= 48 && c2 <= 57) return i + 1;
  }
}
function numberLocale(locale2) {
  const format2 = memoize$2(locale2.format), formatPrefix2 = locale2.formatPrefix;
  return {
    format: format2,
    formatPrefix: formatPrefix2,
    formatFloat(spec) {
      const s = formatSpecifier(spec || ",");
      if (s.precision == null) {
        s.precision = 12;
        switch (s.type) {
          case "%":
            s.precision -= 2;
            break;
          case "e":
            s.precision -= 1;
            break;
        }
        return trimZeroes(
          format2(s),
          // number format
          format2(".1f")(1)[1]
          // decimal point character
        );
      } else {
        return format2(s);
      }
    },
    formatSpan(start, stop3, count2, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop3, count2), value2 = Math.max(Math.abs(start), Math.abs(stop3));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix(step, value2))) {
              specifier.precision = precision;
            }
            return formatPrefix2(specifier, value2);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound(step, value2))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format2(specifier);
    }
  };
}
let defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format: format$3,
    formatPrefix
  });
}
function numberFormatLocale(definition2) {
  return numberLocale(formatLocale$1(definition2));
}
function numberFormatDefaultLocale(definition2) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition2) : defaultNumberLocale;
}
function timeMultiFormat(format2, interval2, spec) {
  spec = spec || {};
  if (!isObject$1(spec)) {
    error("Invalid time multi-format specifier: ".concat(spec));
  }
  const second2 = interval2(SECONDS), minute2 = interval2(MINUTES), hour2 = interval2(HOURS), day2 = interval2(DATE), week2 = interval2(WEEK), month2 = interval2(MONTH), quarter2 = interval2(QUARTER), year2 = interval2(YEAR), L = format2(spec[MILLISECONDS] || ".%L"), S = format2(spec[SECONDS] || ":%S"), M2 = format2(spec[MINUTES] || "%I:%M"), H = format2(spec[HOURS] || "%I %p"), d = format2(spec[DATE] || spec[DAY] || "%a %d"), w2 = format2(spec[WEEK] || "%b %d"), m2 = format2(spec[MONTH] || "%B"), q = format2(spec[QUARTER] || "%B"), y2 = format2(spec[YEAR] || "%Y");
  return (date2) => (second2(date2) < date2 ? L : minute2(date2) < date2 ? S : hour2(date2) < date2 ? M2 : day2(date2) < date2 ? H : month2(date2) < date2 ? week2(date2) < date2 ? d : w2 : year2(date2) < date2 ? quarter2(date2) < date2 ? m2 : q : y2)(date2);
}
function timeLocale(locale2) {
  const timeFormat2 = memoize$2(locale2.format), utcFormat2 = memoize$2(locale2.utcFormat);
  return {
    timeFormat: (spec) => isString(spec) ? timeFormat2(spec) : timeMultiFormat(timeFormat2, timeInterval, spec),
    utcFormat: (spec) => isString(spec) ? utcFormat2(spec) : timeMultiFormat(utcFormat2, utcInterval, spec),
    timeParse: memoize$2(locale2.parse),
    utcParse: memoize$2(locale2.utcParse)
  };
}
let defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: timeFormat$2,
    parse: timeParse$1,
    utcFormat: utcFormat$1,
    utcParse: utcParse$1
  });
}
function timeFormatLocale(definition2) {
  return timeLocale(formatLocale(definition2));
}
function timeFormatDefaultLocale(definition2) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition2) : defaultTimeLocale;
}
const createLocale = (number2, time2) => extend$3({}, number2, time2);
function locale(numberSpec, timeSpec) {
  const number2 = numberSpec ? numberFormatLocale(numberSpec) : numberFormatDefaultLocale();
  const time2 = timeSpec ? timeFormatLocale(timeSpec) : timeFormatDefaultLocale();
  return createLocale(number2, time2);
}
function defaultLocale(numberSpec, timeSpec) {
  const args = arguments.length;
  if (args && args !== 2) {
    error("defaultLocale expects either zero or two arguments.");
  }
  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale();
  resetTimeFormatDefaultLocale();
  return defaultLocale();
}
const protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/;
const allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
const whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
const fileProtocol = "file://";
function loaderFactory(fetch2, fs) {
  return (options) => ({
    options: options || {},
    sanitize,
    load: load$1,
    fileAccess: false,
    file: fileLoader(fs),
    http: httpLoader(fetch2)
  });
}
async function load$1(uri, options) {
  const opt = await this.sanitize(uri, options), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options);
}
async function sanitize(uri, options) {
  options = extend$3({}, this.options, options);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base2;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error("Sanitize failure, invalid URI: " + $(uri));
  }
  const hasProtocol = protocol_re.test(uri);
  if ((base2 = options.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base2.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base2 + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith("//")) {
    if (options.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options.target) {
    result.target = options.target + "";
  }
  if (options.rel) {
    result.rel = options.rel + "";
  }
  if (options.context === "image" && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + "";
  }
  return result;
}
function fileLoader(fs) {
  return fs ? (filename) => new Promise((accept, reject) => {
    fs.readFile(filename, (error2, data2) => {
      if (error2) reject(error2);
      else accept(data2);
    });
  }) : fileReject;
}
async function fileReject() {
  error("No file system access.");
}
function httpLoader(fetch2) {
  return fetch2 ? async function(url, options) {
    const opt = extend$3({}, this.options.http, options), type2 = options && options.response, response = await fetch2(url, opt);
    return !response.ok ? error(response.status + "" + response.statusText) : isFunction$3(response[type2]) ? response[type2]() : response.text();
  } : httpReject;
}
async function httpReject() {
  error("No HTTP fetch method available.");
}
const isValid$1 = (_) => _ != null && _ === _;
const isBoolean$1 = (_) => _ === "true" || _ === "false" || _ === true || _ === false;
const isDate = (_) => !Number.isNaN(Date.parse(_));
const isNumber = (_) => !Number.isNaN(+_) && !(_ instanceof Date);
const isInteger$1 = (_) => isNumber(_) && Number.isInteger(+_);
const typeParsers = {
  boolean: toBoolean,
  integer: toNumber,
  number: toNumber,
  date: toDate,
  string: toString,
  unknown: identity$6
};
const typeTests = [isBoolean$1, isInteger$1, isNumber, isDate];
const typeList = ["boolean", "integer", "number", "date"];
function inferType(values2, field2) {
  if (!values2 || !values2.length) return "unknown";
  const n = values2.length, m2 = typeTests.length, a2 = typeTests.map((_, i) => i + 1);
  for (let i = 0, t4 = 0, j, value2; i < n; ++i) {
    value2 = field2 ? values2[i][field2] : values2[i];
    for (j = 0; j < m2; ++j) {
      if (a2[j] && isValid$1(value2) && !typeTests[j](value2)) {
        a2[j] = 0;
        ++t4;
        if (t4 === typeTests.length) return "string";
      }
    }
  }
  return typeList[a2.reduce((u2, v) => u2 === 0 ? v : u2, 0) - 1];
}
function inferTypes(data2, fields) {
  return fields.reduce((types, field2) => {
    types[field2] = inferType(data2, field2);
    return types;
  }, {});
}
function delimitedFormat(delimiter2) {
  const parse2 = function(data2, format2) {
    const delim = {
      delimiter: delimiter2
    };
    return dsv(data2, format2 ? extend$3(format2, delim) : delim);
  };
  parse2.responseType = "text";
  return parse2;
}
function dsv(data2, format2) {
  if (format2.header) {
    data2 = format2.header.map($).join(format2.delimiter) + "\n" + data2;
  }
  return dsvFormat(format2.delimiter).parse(data2 + "");
}
dsv.responseType = "text";
function isBuffer$1(_) {
  return typeof Buffer === "function" && isFunction$3(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json(data2, format2) {
  const prop = format2 && format2.property ? field$1(format2.property) : identity$6;
  return isObject$1(data2) && !isBuffer$1(data2) ? parseJSON(prop(data2), format2) : prop(JSON.parse(data2));
}
json.responseType = "json";
function parseJSON(data2, format2) {
  if (!isArray$1(data2) && isIterable(data2)) {
    data2 = [...data2];
  }
  return format2 && format2.copy ? JSON.parse(JSON.stringify(data2)) : data2;
}
const filters = {
  interior: (a2, b2) => a2 !== b2,
  exterior: (a2, b2) => a2 === b2
};
function topojson(data2, format2) {
  let method2, object2, property2, filter2;
  data2 = json(data2, format2);
  if (format2 && format2.feature) {
    method2 = feature;
    property2 = format2.feature;
  } else if (format2 && format2.mesh) {
    method2 = mesh;
    property2 = format2.mesh;
    filter2 = filters[format2.filter];
  } else {
    error("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data2.objects[property2]) ? method2(data2, object2, filter2) : error("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson.responseType = "json";
const format$2 = {
  dsv,
  csv: delimitedFormat(","),
  tsv: delimitedFormat("	"),
  json,
  topojson
};
function formats$1(name, reader) {
  if (arguments.length > 1) {
    format$2[name] = reader;
    return this;
  } else {
    return has$2(format$2, name) ? format$2[name] : null;
  }
}
function responseType(type2) {
  const f = formats$1(type2);
  return f && f.responseType || "text";
}
function read(data2, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats$1(schema.type || "json");
  if (!reader) error("Unknown data format type: " + schema.type);
  data2 = reader(data2, schema);
  if (schema.parse) parse$7(data2, schema.parse, timeParser, utcParser);
  if (has$2(data2, "columns")) delete data2.columns;
  return data2;
}
function parse$7(data2, types, timeParser, utcParser) {
  if (!data2.length) return;
  const locale2 = timeFormatDefaultLocale();
  timeParser = timeParser || locale2.timeParse;
  utcParser = utcParser || locale2.utcParse;
  let fields = data2.columns || Object.keys(data2[0]), datum2, field2, i, j, n, m2;
  if (types === "auto") types = inferTypes(data2, fields);
  fields = Object.keys(types);
  const parsers = fields.map((field3) => {
    const type2 = types[field3];
    let parts, pattern;
    if (type2 && (type2.startsWith("date:") || type2.startsWith("utc:"))) {
      parts = type2.split(/:(.+)?/, 2);
      pattern = parts[1];
      if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }
      const parse2 = parts[0] === "utc" ? utcParser : timeParser;
      return parse2(pattern);
    }
    if (!typeParsers[type2]) {
      throw Error("Illegal format pattern: " + field3 + ":" + type2);
    }
    return typeParsers[type2];
  });
  for (i = 0, n = data2.length, m2 = fields.length; i < n; ++i) {
    datum2 = data2[i];
    for (j = 0; j < m2; ++j) {
      field2 = fields[j];
      datum2[field2] = parsers[j](datum2[field2]);
    }
  }
}
const loader = loaderFactory(
  typeof fetch !== "undefined" && fetch,
  // use built-in fetch API
  null
  // no file system access
);
function UniqueList(idFunc) {
  const $2 = idFunc || identity$6, list = [], ids = {};
  list.add = (_) => {
    const id2 = $2(_);
    if (!ids[id2]) {
      ids[id2] = 1;
      list.push(_);
    }
    return list;
  };
  list.remove = (_) => {
    const id2 = $2(_);
    if (ids[id2]) {
      ids[id2] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0) list.splice(idx, 1);
    }
    return list;
  };
  return list;
}
async function asyncCallback(df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}
const TUPLE_ID_KEY = Symbol("vega_id");
let TUPLE_ID = 1;
function isTuple(t4) {
  return !!(t4 && tupleid(t4));
}
function tupleid(t4) {
  return t4[TUPLE_ID_KEY];
}
function setid(t4, id2) {
  t4[TUPLE_ID_KEY] = id2;
  return t4;
}
function ingest$1(datum2) {
  const t4 = datum2 === Object(datum2) ? datum2 : {
    data: datum2
  };
  return tupleid(t4) ? t4 : setid(t4, TUPLE_ID++);
}
function derive(t4) {
  return rederive(t4, ingest$1({}));
}
function rederive(t4, d) {
  for (const k in t4) d[k] = t4[k];
  return d;
}
function replace$2(t4, d) {
  return setid(d, tupleid(t4));
}
function stableCompare(cmp2, f) {
  return !cmp2 ? null : f ? (a2, b2) => cmp2(a2, b2) || tupleid(f(a2)) - tupleid(f(b2)) : (a2, b2) => cmp2(a2, b2) || tupleid(a2) - tupleid(b2);
}
function isChangeSet(v) {
  return v && v.constructor === changeset;
}
function changeset() {
  const add2 = [], rem2 = [], mod = [], remp = [], modp = [];
  let clean = null, reflow2 = false;
  return {
    constructor: changeset,
    insert(t4) {
      const d = array$5(t4), n = d.length;
      for (let i = 0; i < n; ++i) add2.push(d[i]);
      return this;
    },
    remove(t4) {
      const a2 = isFunction$3(t4) ? remp : rem2, d = array$5(t4), n = d.length;
      for (let i = 0; i < n; ++i) a2.push(d[i]);
      return this;
    },
    modify(t4, field2, value2) {
      const m2 = {
        field: field2,
        value: constant$5(value2)
      };
      if (isFunction$3(t4)) {
        m2.filter = t4;
        modp.push(m2);
      } else {
        m2.tuple = t4;
        mod.push(m2);
      }
      return this;
    },
    encode(t4, set2) {
      if (isFunction$3(t4)) modp.push({
        filter: t4,
        field: set2
      });
      else mod.push({
        tuple: t4,
        field: set2
      });
      return this;
    },
    clean(value2) {
      clean = value2;
      return this;
    },
    reflow() {
      reflow2 = true;
      return this;
    },
    pulse(pulse2, tuples) {
      const cur = {}, out = {};
      let i, n, m2, f, t4, id2;
      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      }
      for (i = 0, n = rem2.length; i < n; ++i) {
        t4 = rem2[i];
        cur[tupleid(t4)] = -1;
      }
      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach((t5) => {
          if (f(t5)) cur[tupleid(t5)] = -1;
        });
      }
      for (i = 0, n = add2.length; i < n; ++i) {
        t4 = add2[i];
        id2 = tupleid(t4);
        if (cur[id2]) {
          cur[id2] = 1;
        } else {
          pulse2.add.push(ingest$1(add2[i]));
        }
      }
      for (i = 0, n = tuples.length; i < n; ++i) {
        t4 = tuples[i];
        if (cur[tupleid(t4)] < 0) pulse2.rem.push(t4);
      }
      function modify2(t5, f2, v) {
        if (v) {
          t5[f2] = v(t5);
        } else {
          pulse2.encode = f2;
        }
        if (!reflow2) out[tupleid(t5)] = t5;
      }
      for (i = 0, n = mod.length; i < n; ++i) {
        m2 = mod[i];
        t4 = m2.tuple;
        f = m2.field;
        id2 = cur[tupleid(t4)];
        if (id2 > 0) {
          modify2(t4, f, m2.value);
          pulse2.modifies(f);
        }
      }
      for (i = 0, n = modp.length; i < n; ++i) {
        m2 = modp[i];
        f = m2.filter;
        tuples.forEach((t5) => {
          if (f(t5) && cur[tupleid(t5)] > 0) {
            modify2(t5, m2.field, m2.value);
          }
        });
        pulse2.modifies(m2.field);
      }
      if (reflow2) {
        pulse2.mod = rem2.length || remp.length ? tuples.filter((t5) => cur[tupleid(t5)] > 0) : tuples.slice();
      } else {
        for (id2 in out) pulse2.mod.push(out[id2]);
      }
      if (clean || clean == null && (rem2.length || remp.length)) {
        pulse2.clean(true);
      }
      return pulse2;
    }
  };
}
const CACHE$1 = "_:mod:_";
function Parameters() {
  Object.defineProperty(this, CACHE$1, {
    writable: true,
    value: {}
  });
}
Parameters.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(name, index2, value2, force2) {
    const o = this, v = o[name], mod = o[CACHE$1];
    if (index2 != null && index2 >= 0) {
      if (v[index2] !== value2 || force2) {
        v[index2] = value2;
        mod[index2 + ":" + name] = -1;
        mod[name] = -1;
      }
    } else if (v !== value2 || force2) {
      o[name] = value2;
      mod[name] = isArray$1(value2) ? 1 + value2.length : -1;
    }
    return o;
  },
  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(name, index2) {
    const mod = this[CACHE$1];
    if (!arguments.length) {
      for (const k in mod) {
        if (mod[k]) return true;
      }
      return false;
    } else if (isArray$1(name)) {
      for (let k = 0; k < name.length; ++k) {
        if (mod[name[k]]) return true;
      }
      return false;
    }
    return index2 != null && index2 >= 0 ? index2 + 1 < mod[name] || !!mod[index2 + ":" + name] : !!mod[name];
  },
  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    this[CACHE$1] = {};
    return this;
  }
};
let OP_ID = 0;
const PULSE = "pulse", NO_PARAMS = new Parameters();
const SKIP$1$1 = 1, MODIFIED = 2;
function Operator(init2, update2, params2, react) {
  this.id = ++OP_ID;
  this.value = init2;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;
  if (update2) {
    this._update = update2;
  }
  if (params2) this.parameters(params2, react);
}
function flag(bit) {
  return function(state) {
    const f = this.flags;
    if (arguments.length === 0) return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}
Operator.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = UniqueList(id));
  },
  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(value2) {
    if (this.value !== value2) {
      this.value = value2;
      return 1;
    } else {
      return 0;
    }
  },
  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: flag(SKIP$1$1),
  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: flag(MODIFIED),
  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initiatal evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(params2, react, initonly) {
    react = react !== false;
    const argval = this._argval = this._argval || new Parameters(), argops = this._argops = this._argops || [], deps = [];
    let name, value2, n, i;
    const add2 = (name2, index2, value3) => {
      if (value3 instanceof Operator) {
        if (value3 !== this) {
          if (react) value3.targets().add(this);
          deps.push(value3);
        }
        argops.push({
          op: value3,
          name: name2,
          index: index2
        });
      } else {
        argval.set(name2, index2, value3);
      }
    };
    for (name in params2) {
      value2 = params2[name];
      if (name === PULSE) {
        array$5(value2).forEach((op) => {
          if (!(op instanceof Operator)) {
            error("Pulse parameters must be operator instances.");
          } else if (op !== this) {
            op.targets().add(this);
            deps.push(op);
          }
        });
        this.source = value2;
      } else if (isArray$1(value2)) {
        argval.set(name, -1, Array(n = value2.length));
        for (i = 0; i < n; ++i) add2(name, i, value2[i]);
      } else {
        add2(name, -1, value2);
      }
    }
    this.marshall().clear();
    if (initonly) argops.initonly = true;
    return deps;
  },
  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(stamp) {
    const argval = this._argval || NO_PARAMS, argops = this._argops;
    let item, i, op, mod;
    if (argops) {
      const n = argops.length;
      for (i = 0; i < n; ++i) {
        item = argops[i];
        op = item.op;
        mod = op.modified() && op.stamp === stamp;
        argval.set(item.name, item.index, op.value, mod);
      }
      if (argops.initonly) {
        for (i = 0; i < n; ++i) {
          item = argops[i];
          item.op.targets().remove(this);
        }
        this._argops = null;
        this._update = null;
      }
    }
    return argval;
  },
  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const argops = this._argops;
    let i, n, item, op;
    if (argops) {
      for (i = 0, n = argops.length; i < n; ++i) {
        item = argops[i];
        op = item.op;
        if (op._targets) {
          op._targets.remove(this);
        }
      }
    }
    this.pulse = null;
    this.source = null;
  },
  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(pulse2) {
    const update2 = this._update;
    if (update2) {
      const params2 = this.marshall(pulse2.stamp), v = update2.call(this, params2, pulse2);
      params2.clear();
      if (v !== this.value) {
        this.value = v;
      } else if (!this.modified()) {
        return pulse2.StopPropagation;
      }
    }
  },
  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse2) {
    if (pulse2.stamp < this.stamp) return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
      rv = 0;
    } else {
      rv = this.evaluate(pulse2);
    }
    return this.pulse = rv || pulse2;
  }
};
function add$4(init2, update2, params2, react) {
  let shift2 = 1, op;
  if (init2 instanceof Operator) {
    op = init2;
  } else if (init2 && init2.prototype instanceof Operator) {
    op = new init2();
  } else if (isFunction$3(init2)) {
    op = new Operator(null, init2);
  } else {
    shift2 = 0;
    op = new Operator(init2, update2);
  }
  this.rank(op);
  if (shift2) {
    react = params2;
    params2 = update2;
  }
  if (params2) this.connect(op, op.parameters(params2, react));
  this.touch(op);
  return op;
}
function connect(target2, sources) {
  const targetRank = target2.rank, n = sources.length;
  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target2);
      return;
    }
  }
}
let STREAM_ID = 0;
function EventStream(filter2, apply2, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive) this.receive = receive;
  if (filter2) this._filter = filter2;
  if (apply2) this._apply = apply2;
}
function stream(filter2, apply2, receive) {
  return new EventStream(filter2, apply2, receive);
}
EventStream.prototype = {
  _filter: truthy,
  _apply: identity$6,
  targets() {
    return this._targets || (this._targets = UniqueList(id));
  },
  consume(_) {
    if (!arguments.length) return !!this._consume;
    this._consume = !!_;
    return this;
  },
  receive(evt) {
    if (this._filter(evt)) {
      const val = this.value = this._apply(evt), trg = this._targets, n = trg ? trg.length : 0;
      for (let i = 0; i < n; ++i) trg[i].receive(val);
      if (this._consume) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }
  },
  filter(filter2) {
    const s = stream(filter2);
    this.targets().add(s);
    return s;
  },
  apply(apply2) {
    const s = stream(null, apply2);
    this.targets().add(s);
    return s;
  },
  merge() {
    const s = stream();
    this.targets().add(s);
    for (let i = 0, n = arguments.length; i < n; ++i) {
      arguments[i].targets().add(s);
    }
    return s;
  },
  throttle(pause) {
    let t4 = -1;
    return this.filter(() => {
      const now2 = Date.now();
      if (now2 - t4 > pause) {
        t4 = now2;
        return 1;
      } else {
        return 0;
      }
    });
  },
  debounce(delay) {
    const s = stream();
    this.targets().add(stream(null, null, debounce$1(delay, (e3) => {
      const df = e3.dataflow;
      s.receive(e3);
      if (df && df.run) df.run();
    })));
    return s;
  },
  between(a2, b2) {
    let active = false;
    a2.targets().add(stream(null, null, () => active = true));
    b2.targets().add(stream(null, null, () => active = false));
    return this.filter(() => active);
  },
  detach() {
    this._filter = truthy;
    this._targets = null;
  }
};
function events$2(source2, type2, filter2, apply2) {
  const df = this, s = stream(filter2, apply2), send = function(e3) {
    e3.dataflow = df;
    try {
      s.receive(e3);
    } catch (error2) {
      df.error(error2);
    } finally {
      df.run();
    }
  };
  let sources;
  if (typeof source2 === "string" && typeof document !== "undefined") {
    sources = document.querySelectorAll(source2);
  } else {
    sources = array$5(source2);
  }
  const n = sources.length;
  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type2, send);
  }
  return s;
}
function parse$6(data2, format2) {
  const locale2 = this.locale();
  return read(data2, format2, locale2.timeParse, locale2.utcParse);
}
function ingest(target2, data2, format2) {
  data2 = this.parse(data2, format2);
  return this.pulse(target2, this.changeset().insert(data2));
}
async function request(url, format2) {
  const df = this;
  let status = 0, data2;
  try {
    data2 = await df.loader().load(url, {
      context: "dataflow",
      response: responseType(format2 && format2.type)
    });
    try {
      data2 = df.parse(data2, format2);
    } catch (err) {
      status = -2;
      df.warn("Data ingestion failed", url, err);
    }
  } catch (err) {
    status = -1;
    df.warn("Loading failed", url, err);
  }
  return {
    data: data2,
    status
  };
}
async function preload(target2, url, format2) {
  const df = this, pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format2);
  df.pulse(target2, df.changeset().remove(truthy).insert(res.data || []));
  pending.done();
  return res;
}
function loadPending(df) {
  let accept;
  const pending = new Promise((a2) => accept = a2);
  pending.requests = 0;
  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };
  return df._pending = pending;
}
const SKIP$2 = {
  skip: true
};
function on(source2, target2, update2, params2, options) {
  const fn = source2 instanceof Operator ? onOperator : onStream;
  fn(this, source2, target2, update2, params2, options);
  return this;
}
function onStream(df, stream2, target2, update2, params2, options) {
  const opt = extend$3({}, options, SKIP$2);
  let func, op;
  if (!isFunction$3(target2)) target2 = constant$5(target2);
  if (update2 === void 0) {
    func = (e3) => df.touch(target2(e3));
  } else if (isFunction$3(update2)) {
    op = new Operator(null, update2, params2, false);
    func = (e3) => {
      op.evaluate(e3);
      const t4 = target2(e3), v = op.value;
      isChangeSet(v) ? df.pulse(t4, v, options) : df.update(t4, v, opt);
    };
  } else {
    func = (e3) => df.update(target2(e3), update2, opt);
  }
  stream2.apply(func);
}
function onOperator(df, source2, target2, update2, params2, options) {
  if (update2 === void 0) {
    source2.targets().add(target2);
  } else {
    const opt = options || {}, op = new Operator(null, updater(target2, update2), params2, false);
    op.modified(opt.force);
    op.rank = source2.rank;
    source2.targets().add(op);
    if (target2) {
      op.skip(true);
      op.value = target2.value;
      op.targets().add(target2);
      df.connect(target2, [op]);
    }
  }
}
function updater(target2, update2) {
  update2 = isFunction$3(update2) ? update2 : constant$5(update2);
  return target2 ? function(_, pulse2) {
    const value2 = update2(_, pulse2);
    if (!target2.skip()) {
      target2.skip(value2 !== this.value).value = value2;
    }
    return value2;
  } : update2;
}
function rank(op) {
  op.rank = ++this._rank;
}
function rerank(op) {
  const queue = [op];
  let cur, list, i;
  while (queue.length) {
    this.rank(cur = queue.pop());
    if (list = cur._targets) {
      for (i = list.length; --i >= 0; ) {
        queue.push(cur = list[i]);
        if (cur === op) error("Cycle detected in dataflow graph.");
      }
    }
  }
}
const StopPropagation = {};
const ADD = 1 << 0, REM = 1 << 1, MOD$1 = 1 << 2, ADD_REM = ADD | REM, ADD_MOD = ADD | MOD$1, ALL = ADD | REM | MOD$1, REFLOW = 1 << 3, SOURCE = 1 << 4, NO_SOURCE = 1 << 5, NO_FIELDS = 1 << 6;
function Pulse(dataflow, stamp, encode2) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode2 || null;
}
function materialize(data2, filter2) {
  const out = [];
  visitArray(data2, filter2, (_) => out.push(_));
  return out;
}
function filter$1(pulse2, flags) {
  const map2 = {};
  pulse2.visit(flags, (t4) => {
    map2[tupleid(t4)] = 1;
  });
  return (t4) => map2[tupleid(t4)] ? null : t4;
}
function addFilter(a2, b2) {
  return a2 ? (t4, i) => a2(t4, i) && b2(t4, i) : b2;
}
Pulse.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation,
  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD,
  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM,
  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD: MOD$1,
  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM,
  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD,
  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL,
  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW,
  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE,
  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE,
  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS,
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(flags) {
    return new Pulse(this.dataflow).init(this, flags);
  },
  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const p = this.fork(ALL);
    p.add = p.add.slice();
    p.rem = p.rem.slice();
    p.mod = p.mod.slice();
    if (p.source) p.source = p.source.slice();
    return p.materialize(ALL | SOURCE);
  },
  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let p = this;
    const reuse = !p.source || p.add === p.rem || !p.rem.length && p.source.length === p.add.length;
    if (reuse) {
      return p;
    } else {
      p = new Pulse(this.dataflow).init(this);
      p.add = p.source;
      p.rem = [];
      return p;
    }
  },
  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(src, flags) {
    const p = this;
    p.stamp = src.stamp;
    p.encode = src.encode;
    if (src.fields && !(flags & NO_FIELDS)) {
      p.fields = src.fields;
    }
    if (flags & ADD) {
      p.addF = src.addF;
      p.add = src.add;
    } else {
      p.addF = null;
      p.add = [];
    }
    if (flags & REM) {
      p.remF = src.remF;
      p.rem = src.rem;
    } else {
      p.remF = null;
      p.rem = [];
    }
    if (flags & MOD$1) {
      p.modF = src.modF;
      p.mod = src.mod;
    } else {
      p.modF = null;
      p.mod = [];
    }
    if (flags & NO_SOURCE) {
      p.srcF = null;
      p.source = null;
    } else {
      p.srcF = src.srcF;
      p.source = src.source;
      if (src.cleans) p.cleans = src.cleans;
    }
    return p;
  },
  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(func) {
    this.dataflow.runAfter(func);
  },
  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(flags) {
    const f = flags || ALL;
    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD$1 && this.mod.length;
  },
  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(fork) {
    if (fork) return this.fork(ALL).reflow();
    const len = this.add.length, src = this.source && this.source.length;
    if (src && src !== len) {
      this.mod = this.source;
      if (len) this.filter(MOD$1, filter$1(this, ADD));
    }
    return this;
  },
  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(value2) {
    if (arguments.length) {
      this.cleans = !!value2;
      return this;
    } else {
      return this.cleans;
    }
  },
  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(_) {
    const hash2 = this.fields || (this.fields = {});
    if (isArray$1(_)) {
      _.forEach((f) => hash2[f] = true);
    } else {
      hash2[_] = true;
    }
    return this;
  },
  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(_, nomod) {
    const fields = this.fields;
    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray$1(_) ? _.some((f) => fields[f]) : fields[_];
  },
  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(flags, filter2) {
    const p = this;
    if (flags & ADD) p.addF = addFilter(p.addF, filter2);
    if (flags & REM) p.remF = addFilter(p.remF, filter2);
    if (flags & MOD$1) p.modF = addFilter(p.modF, filter2);
    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter2);
    return p;
  },
  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(flags) {
    flags = flags || ALL;
    const p = this;
    if (flags & ADD && p.addF) {
      p.add = materialize(p.add, p.addF);
      p.addF = null;
    }
    if (flags & REM && p.remF) {
      p.rem = materialize(p.rem, p.remF);
      p.remF = null;
    }
    if (flags & MOD$1 && p.modF) {
      p.mod = materialize(p.mod, p.modF);
      p.modF = null;
    }
    if (flags & SOURCE && p.srcF) {
      p.source = p.source.filter(p.srcF);
      p.srcF = null;
    }
    return p;
  },
  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(flags, visitor) {
    const p = this, v = visitor;
    if (flags & SOURCE) {
      visitArray(p.source, p.srcF, v);
      return p;
    }
    if (flags & ADD) visitArray(p.add, p.addF, v);
    if (flags & REM) visitArray(p.rem, p.remF, v);
    if (flags & MOD$1) visitArray(p.mod, p.modF, v);
    const src = p.source;
    if (flags & REFLOW && src) {
      const sum2 = p.add.length + p.mod.length;
      if (sum2 === src.length) ;
      else if (sum2) {
        visitArray(src, filter$1(p, ADD_MOD), v);
      } else {
        visitArray(src, p.srcF, v);
      }
    }
    return p;
  }
};
function MultiPulse(dataflow, stamp, pulses, encode2) {
  const p = this, n = pulses.length;
  let c2 = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode2 || null;
  this.pulses = pulses;
  for (let i = 0; i < n; ++i) {
    const pulse2 = pulses[i];
    if (pulse2.stamp !== stamp) continue;
    if (pulse2.fields) {
      const hash2 = p.fields || (p.fields = {});
      for (const f in pulse2.fields) {
        hash2[f] = 1;
      }
    }
    if (pulse2.changed(p.ADD)) c2 |= p.ADD;
    if (pulse2.changed(p.REM)) c2 |= p.REM;
    if (pulse2.changed(p.MOD)) c2 |= p.MOD;
  }
  this.changes = c2;
}
inherits(MultiPulse, Pulse, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(flags) {
    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);
    if (flags !== void 0) {
      if (flags & p.ADD) this.visit(p.ADD, (t4) => p.add.push(t4));
      if (flags & p.REM) this.visit(p.REM, (t4) => p.rem.push(t4));
      if (flags & p.MOD) this.visit(p.MOD, (t4) => p.mod.push(t4));
    }
    return p;
  },
  changed(flags) {
    return this.changes & flags;
  },
  modified(_) {
    const p = this, fields = p.fields;
    return !(fields && p.changes & p.MOD) ? 0 : isArray$1(_) ? _.some((f) => fields[f]) : fields[_];
  },
  filter() {
    error("MultiPulse does not support filtering.");
  },
  materialize() {
    error("MultiPulse does not support materialization.");
  },
  visit(flags, visitor) {
    const p = this, pulses = p.pulses, n = pulses.length;
    let i = 0;
    if (flags & p.SOURCE) {
      for (; i < n; ++i) {
        pulses[i].visit(flags, visitor);
      }
    } else {
      for (; i < n; ++i) {
        if (pulses[i].stamp === p.stamp) {
          pulses[i].visit(flags, visitor);
        }
      }
    }
    return p;
  }
});
async function evaluate(encode2, prerun, postrun) {
  const df = this, async2 = [];
  if (df._pulse) return reentrant(df);
  if (df._pending) await df._pending;
  if (prerun) await asyncCallback(df, prerun);
  if (!df._touched.length) {
    df.debug("Dataflow invoked, but nothing to do.");
    return df;
  }
  const stamp = ++df._clock;
  df._pulse = new Pulse(df, stamp, encode2);
  df._touched.forEach((op2) => df._enqueue(op2, true));
  df._touched = UniqueList(id);
  let count2 = 0, op, next2, error2;
  try {
    while (df._heap.size() > 0) {
      op = df._heap.pop();
      if (op.rank !== op.qrank) {
        df._enqueue(op, true);
        continue;
      }
      next2 = op.run(df._getPulse(op, encode2));
      if (next2.then) {
        next2 = await next2;
      } else if (next2.async) {
        async2.push(next2.async);
        next2 = StopPropagation;
      }
      if (next2 !== StopPropagation) {
        if (op._targets) op._targets.forEach((op2) => df._enqueue(op2));
      }
      ++count2;
    }
  } catch (err) {
    df._heap.clear();
    error2 = err;
  }
  df._input = {};
  df._pulse = null;
  df.debug(`Pulse ${stamp}: ${count2} operators`);
  if (error2) {
    df._postrun = [];
    df.error(error2);
  }
  if (df._postrun.length) {
    const pr = df._postrun.sort((a2, b2) => b2.priority - a2.priority);
    df._postrun = [];
    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  }
  if (postrun) await asyncCallback(df, postrun);
  if (async2.length) {
    Promise.all(async2).then((cb) => df.runAsync(null, () => {
      cb.forEach((f) => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }
  return df;
}
async function runAsync(encode2, prerun, postrun) {
  while (this._running) await this._running;
  const clear2 = () => this._running = null;
  (this._running = this.evaluate(encode2, prerun, postrun)).then(clear2, clear2);
  return this._running;
}
function run(encode2, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode2, prerun, postrun), this);
}
function runAfter(callback, enqueue2, priority) {
  if (this._pulse || enqueue2) {
    this._postrun.push({
      priority: priority || 0,
      callback
    });
  } else {
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}
function reentrant(df) {
  df.error("Dataflow already running. Use runAsync() to chain invocations.");
  return df;
}
function enqueue(op, force2) {
  const q = op.stamp < this._clock;
  if (q) op.stamp = this._clock;
  if (q || force2) {
    op.qrank = op.rank;
    this._heap.push(op);
  }
}
function getPulse(op, encode2) {
  const s = op.source, stamp = this._clock;
  return s && isArray$1(s) ? new MultiPulse(this, stamp, s.map((_) => _.pulse), encode2) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);
}
function singlePulse(p, s) {
  if (s && s.stamp === p.stamp) {
    return s;
  }
  p = p.fork();
  if (s && s !== StopPropagation) {
    p.source = s.source;
  }
  return p;
}
const NO_OPT = {
  skip: false,
  force: false
};
function touch(op, options) {
  const opt = options || NO_OPT;
  if (this._pulse) {
    this._enqueue(op);
  } else {
    this._touched.add(op);
  }
  if (opt.skip) op.skip(true);
  return this;
}
function update$7(op, value2, options) {
  const opt = options || NO_OPT;
  if (op.set(value2) || opt.force) {
    this.touch(op, opt);
  }
  return this;
}
function pulse(op, changeset2, options) {
  this.touch(op, options || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)), t4 = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset2.pulse(p, t4);
  return this;
}
function Heap(cmp2) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: (x2) => {
      nodes.push(x2);
      return siftdown(nodes, 0, nodes.length - 1, cmp2);
    },
    pop: () => {
      const last = nodes.pop();
      let item;
      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp2);
      } else {
        item = last;
      }
      return item;
    }
  };
}
function siftdown(array2, start, idx, cmp2) {
  let parent, pidx;
  const item = array2[idx];
  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array2[pidx];
    if (cmp2(item, parent) < 0) {
      array2[idx] = parent;
      idx = pidx;
      continue;
    }
    break;
  }
  return array2[idx] = item;
}
function siftup(array2, idx, cmp2) {
  const start = idx, end = array2.length, item = array2[idx];
  let cidx = (idx << 1) + 1, ridx;
  while (cidx < end) {
    ridx = cidx + 1;
    if (ridx < end && cmp2(array2[cidx], array2[ridx]) >= 0) {
      cidx = ridx;
    }
    array2[idx] = array2[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }
  array2[idx] = item;
  return siftdown(array2, start, idx, cmp2);
}
function Dataflow() {
  this.logger(logger());
  this.logLevel(Error$1);
  this._clock = 0;
  this._rank = 0;
  this._locale = defaultLocale();
  try {
    this._loader = loader();
  } catch (e3) {
  }
  this._touched = UniqueList(id);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a2, b2) => a2.qrank - b2.qrank);
  this._postrun = [];
}
function logMethod(method2) {
  return function() {
    return this._log[method2].apply(this, arguments);
  };
}
Dataflow.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },
  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(_) {
    if (arguments.length) {
      this._loader = _;
      return this;
    } else {
      return this._loader;
    }
  },
  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(_) {
    if (arguments.length) {
      this._locale = _;
      return this;
    } else {
      return this._locale;
    }
  },
  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(logger2) {
    if (arguments.length) {
      this._log = logger2;
      return this;
    } else {
      return this._log;
    }
  },
  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: logMethod("error"),
  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: logMethod("warn"),
  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: logMethod("info"),
  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: logMethod("debug"),
  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: logMethod("level"),
  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add: add$4,
  connect,
  rank,
  rerank,
  // OPERATOR UPDATES
  pulse,
  touch,
  update: update$7,
  changeset,
  // DATA LOADING
  ingest,
  parse: parse$6,
  preload,
  request,
  // EVENT HANDLING
  events: events$2,
  on,
  // PULSE PROPAGATION
  evaluate,
  run,
  runAsync,
  runAfter,
  _enqueue: enqueue,
  _getPulse: getPulse
};
function Transform(init2, params2) {
  Operator.call(this, init2, null, params2);
}
inherits(Transform, Operator, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse2) {
    if (pulse2.stamp < this.stamp) return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
    } else {
      rv = this.evaluate(pulse2);
    }
    rv = rv || pulse2;
    if (rv.then) {
      rv = rv.then((_) => this.pulse = _);
    } else if (rv !== pulse2.StopPropagation) {
      this.pulse = rv;
    }
    return rv;
  },
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(pulse2) {
    const params2 = this.marshall(pulse2.stamp), out = this.transform(params2, pulse2);
    params2.clear();
    return out;
  },
  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {
  }
});
const transforms = {};
function definition$1(type2) {
  const t4 = transform$2(type2);
  return t4 && t4.Definition || null;
}
function transform$2(type2) {
  type2 = type2 && type2.toLowerCase();
  return has$2(transforms, type2) ? transforms[type2] : null;
}
function* numbers$1(values2, valueof) {
  if (valueof == null) {
    for (let value2 of values2) {
      if (value2 != null && value2 !== "" && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values2) {
      value2 = valueof(value2, ++index2, values2);
      if (value2 != null && value2 !== "" && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}
function quantiles(array2, p, f) {
  const values2 = Float64Array.from(numbers$1(array2, f));
  values2.sort(ascending$2);
  return p.map((_) => quantileSorted(values2, _));
}
function quartiles(array2, f) {
  return quantiles(array2, [0.25, 0.5, 0.75], f);
}
function estimateBandwidth(array2, f) {
  const n = array2.length, d = deviation(array2, f), q = quartiles(array2, f), h2 = (q[2] - q[0]) / 1.34, v = Math.min(d, h2) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n, -0.2);
}
function bin(_) {
  const maxb = _.maxbins || 20, base2 = _.base || 10, logb = Math.log(base2), div = _.divide || [5, 2];
  let min2 = _.extent[0], max2 = _.extent[1], step, level, minstep, v, i, n;
  const span2 = _.span || max2 - min2 || Math.abs(min2) || 1;
  if (_.step) {
    step = _.step;
  } else if (_.steps) {
    v = span2 / maxb;
    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i) ;
    step = _.steps[Math.max(0, i - 1)];
  } else {
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base2, Math.round(Math.log(span2) / logb) - level));
    while (Math.ceil(span2 / step) > maxb) {
      step *= base2;
    }
    for (i = 0, n = div.length; i < n; ++i) {
      v = step / div[i];
      if (v >= minstep && span2 / v <= maxb) step = v;
    }
  }
  v = Math.log(step);
  const precision = v >= 0 ? 0 : ~~(-v / logb) + 1, eps = Math.pow(base2, -precision - 1);
  if (_.nice || _.nice === void 0) {
    v = Math.floor(min2 / step + eps) * step;
    min2 = min2 < v ? v - step : v;
    max2 = Math.ceil(max2 / step) * step;
  }
  return {
    start: min2,
    stop: max2 === min2 ? min2 + step : max2,
    step
  };
}
var random = Math.random;
function setRandom(r2) {
  random = r2;
}
function bootstrapCI(array2, samples, alpha2, f) {
  if (!array2.length) return [void 0, void 0];
  const values2 = Float64Array.from(numbers$1(array2, f)), n = values2.length, m2 = samples;
  let a2, i, j, mu;
  for (j = 0, mu = Array(m2); j < m2; ++j) {
    for (a2 = 0, i = 0; i < n; ++i) {
      a2 += values2[~~(random() * n)];
    }
    mu[j] = a2 / n;
  }
  mu.sort(ascending$2);
  return [quantile$1(mu, alpha2 / 2), quantile$1(mu, 1 - alpha2 / 2)];
}
function dotbin(array2, step, smooth, f) {
  f = f || ((_) => _);
  const n = array2.length, v = new Float64Array(n);
  let i = 0, j = 1, a2 = f(array2[0]), b2 = a2, w2 = a2 + step, x2;
  for (; j < n; ++j) {
    x2 = f(array2[j]);
    if (x2 >= w2) {
      b2 = (a2 + b2) / 2;
      for (; i < j; ++i) v[i] = b2;
      w2 = x2 + step;
      a2 = x2;
    }
    b2 = x2;
  }
  b2 = (a2 + b2) / 2;
  for (; i < j; ++i) v[i] = b2;
  return smooth ? smoothing(v, step + step / 4) : v;
}
function smoothing(v, thresh) {
  const n = v.length;
  let a2 = 0, b2 = 1, c2, d;
  while (v[a2] === v[b2]) ++b2;
  while (b2 < n) {
    c2 = b2 + 1;
    while (v[b2] === v[c2]) ++c2;
    if (v[b2] - v[b2 - 1] < thresh) {
      d = b2 + (a2 + c2 - b2 - b2 >> 1);
      while (d < b2) v[d++] = v[b2];
      while (d > b2) v[d--] = v[a2];
    }
    a2 = b2;
    b2 = c2;
  }
  return v;
}
function lcg$2(seed) {
  return function() {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}
function integer(min2, max2) {
  if (max2 == null) {
    max2 = min2;
    min2 = 0;
  }
  let a2, b2, d;
  const dist2 = {
    min(_) {
      if (arguments.length) {
        a2 = _ || 0;
        d = b2 - a2;
        return dist2;
      } else {
        return a2;
      }
    },
    max(_) {
      if (arguments.length) {
        b2 = _ || 0;
        d = b2 - a2;
        return dist2;
      } else {
        return b2;
      }
    },
    sample() {
      return a2 + Math.floor(d * random());
    },
    pdf(x2) {
      return x2 === Math.floor(x2) && x2 >= a2 && x2 < b2 ? 1 / d : 0;
    },
    cdf(x2) {
      const v = Math.floor(x2);
      return v < a2 ? 0 : v >= b2 ? 1 : (v - a2 + 1) / d;
    },
    icdf(p) {
      return p >= 0 && p <= 1 ? a2 - 1 + Math.floor(p * d) : NaN;
    }
  };
  return dist2.min(min2).max(max2);
}
const SQRT2PI = Math.sqrt(2 * Math.PI);
const SQRT2 = Math.SQRT2;
let nextSample = NaN;
function sampleNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  let x2 = 0, y2 = 0, rds, c2;
  if (nextSample === nextSample) {
    x2 = nextSample;
    nextSample = NaN;
  } else {
    do {
      x2 = random() * 2 - 1;
      y2 = random() * 2 - 1;
      rds = x2 * x2 + y2 * y2;
    } while (rds === 0 || rds > 1);
    c2 = Math.sqrt(-2 * Math.log(rds) / rds);
    x2 *= c2;
    nextSample = y2 * c2;
  }
  return mean2 + x2 * stdev;
}
function densityNormal(value2, mean2, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z2 = (value2 - (mean2 || 0)) / stdev;
  return Math.exp(-0.5 * z2 * z2) / (stdev * SQRT2PI);
}
function cumulativeNormal(value2, mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z2 = (value2 - mean2) / stdev, Z = Math.abs(z2);
  let cd;
  if (Z > 37) {
    cd = 0;
  } else {
    const exp2 = Math.exp(-Z * Z / 2);
    let sum2;
    if (Z < 7.07106781186547) {
      sum2 = 0.0352624965998911 * Z + 0.700383064443688;
      sum2 = sum2 * Z + 6.37396220353165;
      sum2 = sum2 * Z + 33.912866078383;
      sum2 = sum2 * Z + 112.079291497871;
      sum2 = sum2 * Z + 221.213596169931;
      sum2 = sum2 * Z + 220.206867912376;
      cd = exp2 * sum2;
      sum2 = 0.0883883476483184 * Z + 1.75566716318264;
      sum2 = sum2 * Z + 16.064177579207;
      sum2 = sum2 * Z + 86.7807322029461;
      sum2 = sum2 * Z + 296.564248779674;
      sum2 = sum2 * Z + 637.333633378831;
      sum2 = sum2 * Z + 793.826512519948;
      sum2 = sum2 * Z + 440.413735824752;
      cd = cd / sum2;
    } else {
      sum2 = Z + 0.65;
      sum2 = Z + 4 / sum2;
      sum2 = Z + 3 / sum2;
      sum2 = Z + 2 / sum2;
      sum2 = Z + 1 / sum2;
      cd = exp2 / sum2 / 2.506628274631;
    }
  }
  return z2 > 0 ? 1 - cd : cd;
}
function quantileNormal(p, mean2, stdev) {
  if (p < 0 || p > 1) return NaN;
  return (mean2 || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
}
function erfinv(x2) {
  let w2 = -Math.log((1 - x2) * (1 + x2)), p;
  if (w2 < 6.25) {
    w2 -= 3.125;
    p = -364441206401782e-35;
    p = -16850591381820166e-35 + p * w2;
    p = 128584807152564e-32 + p * w2;
    p = 11157877678025181e-33 + p * w2;
    p = -1333171662854621e-31 + p * w2;
    p = 20972767875968562e-33 + p * w2;
    p = 6637638134358324e-30 + p * w2;
    p = -4054566272975207e-29 + p * w2;
    p = -8151934197605472e-29 + p * w2;
    p = 26335093153082323e-28 + p * w2;
    p = -12975133253453532e-27 + p * w2;
    p = -5415412054294628e-26 + p * w2;
    p = 10512122733215323e-25 + p * w2;
    p = -4112633980346984e-24 + p * w2;
    p = -29070369957882005e-24 + p * w2;
    p = 42347877827932404e-23 + p * w2;
    p = -13654692000834679e-22 + p * w2;
    p = -13882523362786469e-21 + p * w2;
    p = 18673420803405714e-20 + p * w2;
    p = -740702534166267e-18 + p * w2;
    p = -0.006033670871430149 + p * w2;
    p = 0.24015818242558962 + p * w2;
    p = 1.6536545626831027 + p * w2;
  } else if (w2 < 16) {
    w2 = Math.sqrt(w2) - 3.25;
    p = 22137376921775787e-25;
    p = 9075656193888539e-23 + p * w2;
    p = -27517406297064545e-23 + p * w2;
    p = 18239629214389228e-24 + p * w2;
    p = 15027403968909828e-22 + p * w2;
    p = -4013867526981546e-21 + p * w2;
    p = 29234449089955446e-22 + p * w2;
    p = 12475304481671779e-21 + p * w2;
    p = -47318229009055734e-21 + p * w2;
    p = 6828485145957318e-20 + p * w2;
    p = 24031110387097894e-21 + p * w2;
    p = -3550375203628475e-19 + p * w2;
    p = 9532893797373805e-19 + p * w2;
    p = -0.0016882755560235047 + p * w2;
    p = 0.002491442096107851 + p * w2;
    p = -0.003751208507569241 + p * w2;
    p = 0.005370914553590064 + p * w2;
    p = 1.0052589676941592 + p * w2;
    p = 3.0838856104922208 + p * w2;
  } else if (Number.isFinite(w2)) {
    w2 = Math.sqrt(w2) - 5;
    p = -27109920616438573e-27;
    p = -2555641816996525e-25 + p * w2;
    p = 15076572693500548e-25 + p * w2;
    p = -3789465440126737e-24 + p * w2;
    p = 761570120807834e-23 + p * w2;
    p = -1496002662714924e-23 + p * w2;
    p = 2914795345090108e-23 + p * w2;
    p = -6771199775845234e-23 + p * w2;
    p = 22900482228026655e-23 + p * w2;
    p = -99298272942317e-20 + p * w2;
    p = 4526062597223154e-21 + p * w2;
    p = -1968177810553167e-20 + p * w2;
    p = 7599527703001776e-20 + p * w2;
    p = -21503011930044477e-20 + p * w2;
    p = -13871931833623122e-20 + p * w2;
    p = 1.0103004648645344 + p * w2;
    p = 4.849906401408584 + p * w2;
  } else {
    p = Infinity;
  }
  return p * x2;
}
function gaussian(mean2, stdev) {
  let mu, sigma;
  const dist2 = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist2;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist2;
      } else {
        return sigma;
      }
    },
    sample: () => sampleNormal(mu, sigma),
    pdf: (value2) => densityNormal(value2, mu, sigma),
    cdf: (value2) => cumulativeNormal(value2, mu, sigma),
    icdf: (p) => quantileNormal(p, mu, sigma)
  };
  return dist2.mean(mean2).stdev(stdev);
}
function kde(support, bandwidth2) {
  const kernel = gaussian();
  let n = 0;
  const dist2 = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist2.bandwidth(bandwidth2);
      } else {
        return support;
      }
    },
    bandwidth(_) {
      if (!arguments.length) return bandwidth2;
      bandwidth2 = _;
      if (!bandwidth2 && support) bandwidth2 = estimateBandwidth(support);
      return dist2;
    },
    sample() {
      return support[~~(random() * n)] + bandwidth2 * kernel.sample();
    },
    pdf(x2) {
      let y2 = 0, i = 0;
      for (; i < n; ++i) {
        y2 += kernel.pdf((x2 - support[i]) / bandwidth2);
      }
      return y2 / bandwidth2 / n;
    },
    cdf(x2) {
      let y2 = 0, i = 0;
      for (; i < n; ++i) {
        y2 += kernel.cdf((x2 - support[i]) / bandwidth2);
      }
      return y2 / n;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return dist2.data(support);
}
function sampleLogNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean2 + sampleNormal() * stdev);
}
function densityLogNormal(value2, mean2, stdev) {
  if (value2 <= 0) return 0;
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z2 = (Math.log(value2) - mean2) / stdev;
  return Math.exp(-0.5 * z2 * z2) / (stdev * SQRT2PI * value2);
}
function cumulativeLogNormal(value2, mean2, stdev) {
  return cumulativeNormal(Math.log(value2), mean2, stdev);
}
function quantileLogNormal(p, mean2, stdev) {
  return Math.exp(quantileNormal(p, mean2, stdev));
}
function lognormal(mean2, stdev) {
  let mu, sigma;
  const dist2 = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist2;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist2;
      } else {
        return sigma;
      }
    },
    sample: () => sampleLogNormal(mu, sigma),
    pdf: (value2) => densityLogNormal(value2, mu, sigma),
    cdf: (value2) => cumulativeLogNormal(value2, mu, sigma),
    icdf: (p) => quantileLogNormal(p, mu, sigma)
  };
  return dist2.mean(mean2).stdev(stdev);
}
function mixture$1(dists, weights) {
  let m2 = 0, w2;
  function normalize2(x2) {
    const w3 = [];
    let sum2 = 0, i;
    for (i = 0; i < m2; ++i) {
      sum2 += w3[i] = x2[i] == null ? 1 : +x2[i];
    }
    for (i = 0; i < m2; ++i) {
      w3[i] /= sum2;
    }
    return w3;
  }
  const dist2 = {
    weights(_) {
      if (arguments.length) {
        w2 = normalize2(weights = _ || []);
        return dist2;
      }
      return weights;
    },
    distributions(_) {
      if (arguments.length) {
        if (_) {
          m2 = _.length;
          dists = _;
        } else {
          m2 = 0;
          dists = [];
        }
        return dist2.weights(weights);
      }
      return dists;
    },
    sample() {
      const r2 = random();
      let d = dists[m2 - 1], v = w2[0], i = 0;
      for (; i < m2 - 1; v += w2[++i]) {
        if (r2 < v) {
          d = dists[i];
          break;
        }
      }
      return d.sample();
    },
    pdf(x2) {
      let p = 0, i = 0;
      for (; i < m2; ++i) {
        p += w2[i] * dists[i].pdf(x2);
      }
      return p;
    },
    cdf(x2) {
      let p = 0, i = 0;
      for (; i < m2; ++i) {
        p += w2[i] * dists[i].cdf(x2);
      }
      return p;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return dist2.distributions(dists).weights(weights);
}
function sampleUniform(min2, max2) {
  if (max2 == null) {
    max2 = min2 == null ? 1 : min2;
    min2 = 0;
  }
  return min2 + (max2 - min2) * random();
}
function densityUniform(value2, min2, max2) {
  if (max2 == null) {
    max2 = min2 == null ? 1 : min2;
    min2 = 0;
  }
  return value2 >= min2 && value2 <= max2 ? 1 / (max2 - min2) : 0;
}
function cumulativeUniform(value2, min2, max2) {
  if (max2 == null) {
    max2 = min2 == null ? 1 : min2;
    min2 = 0;
  }
  return value2 < min2 ? 0 : value2 > max2 ? 1 : (value2 - min2) / (max2 - min2);
}
function quantileUniform(p, min2, max2) {
  if (max2 == null) {
    max2 = min2 == null ? 1 : min2;
    min2 = 0;
  }
  return p >= 0 && p <= 1 ? min2 + p * (max2 - min2) : NaN;
}
function uniform(min2, max2) {
  let a2, b2;
  const dist2 = {
    min(_) {
      if (arguments.length) {
        a2 = _ || 0;
        return dist2;
      } else {
        return a2;
      }
    },
    max(_) {
      if (arguments.length) {
        b2 = _ == null ? 1 : _;
        return dist2;
      } else {
        return b2;
      }
    },
    sample: () => sampleUniform(a2, b2),
    pdf: (value2) => densityUniform(value2, a2, b2),
    cdf: (value2) => cumulativeUniform(value2, a2, b2),
    icdf: (p) => quantileUniform(p, a2, b2)
  };
  if (max2 == null) {
    max2 = min2 == null ? 1 : min2;
    min2 = 0;
  }
  return dist2.min(min2).max(max2);
}
function ols(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}
function points(data2, x2, y2, sort2) {
  data2 = data2.filter((d2) => {
    let u2 = x2(d2), v = y2(d2);
    return u2 != null && (u2 = +u2) >= u2 && v != null && (v = +v) >= v;
  });
  if (sort2) {
    data2.sort((a2, b2) => x2(a2) - x2(b2));
  }
  const n = data2.length, X3 = new Float64Array(n), Y3 = new Float64Array(n);
  let i = 0, ux = 0, uy = 0, xv, yv, d;
  for (d of data2) {
    X3[i] = xv = +x2(d);
    Y3[i] = yv = +y2(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }
  for (i = 0; i < n; ++i) {
    X3[i] -= ux;
    Y3[i] -= uy;
  }
  return [X3, Y3, ux, uy];
}
function visitPoints(data2, x2, y2, callback) {
  let i = -1, u2, v;
  for (const d of data2) {
    u2 = x2(d);
    v = y2(d);
    if (u2 != null && (u2 = +u2) >= u2 && v != null && (v = +v) >= v) {
      callback(u2, v, ++i);
    }
  }
}
function rSquared(data2, x2, y2, uY, predict) {
  let SSE = 0, SST = 0;
  visitPoints(data2, x2, y2, (dx, dy) => {
    const sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}
function linear$3(data2, x2, y2) {
  let X3 = 0, Y3 = 0, XY = 0, X22 = 0, n = 0;
  visitPoints(data2, x2, y2, (dx, dy) => {
    ++n;
    X3 += (dx - X3) / n;
    Y3 += (dy - Y3) / n;
    XY += (dx * dy - XY) / n;
    X22 += (dx * dx - X22) / n;
  });
  const coef = ols(X3, Y3, XY, X22), predict = (x3) => coef[0] + coef[1] * x3;
  return {
    coef,
    predict,
    rSquared: rSquared(data2, x2, y2, Y3, predict)
  };
}
function log$4(data2, x2, y2) {
  let X3 = 0, Y3 = 0, XY = 0, X22 = 0, n = 0;
  visitPoints(data2, x2, y2, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X3 += (dx - X3) / n;
    Y3 += (dy - Y3) / n;
    XY += (dx * dy - XY) / n;
    X22 += (dx * dx - X22) / n;
  });
  const coef = ols(X3, Y3, XY, X22), predict = (x3) => coef[0] + coef[1] * Math.log(x3);
  return {
    coef,
    predict,
    rSquared: rSquared(data2, x2, y2, Y3, predict)
  };
}
function exp$1(data2, x2, y2) {
  const [xv, yv, ux, uy] = points(data2, x2, y2);
  let YL = 0, XY = 0, XYL = 0, X2Y = 0, n = 0, dx, ly2, xy;
  visitPoints(data2, x2, y2, (_, dy) => {
    dx = xv[n++];
    ly2 = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly2 - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly2 - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });
  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy), predict = (x3) => Math.exp(c0 + c1 * (x3 - ux));
  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict,
    rSquared: rSquared(data2, x2, y2, uy, predict)
  };
}
function pow$3(data2, x2, y2) {
  let X3 = 0, Y3 = 0, XY = 0, X22 = 0, YS = 0, n = 0;
  visitPoints(data2, x2, y2, (dx, dy) => {
    const lx2 = Math.log(dx), ly2 = Math.log(dy);
    ++n;
    X3 += (lx2 - X3) / n;
    Y3 += (ly2 - Y3) / n;
    XY += (lx2 * ly2 - XY) / n;
    X22 += (lx2 * lx2 - X22) / n;
    YS += (dy - YS) / n;
  });
  const coef = ols(X3, Y3, XY, X22), predict = (x3) => coef[0] * Math.pow(x3, coef[1]);
  coef[0] = Math.exp(coef[0]);
  return {
    coef,
    predict,
    rSquared: rSquared(data2, x2, y2, YS, predict)
  };
}
function quad(data2, x2, y2) {
  const [xv, yv, ux, uy] = points(data2, x2, y2), n = xv.length;
  let X22 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x22;
  for (i = 0; i < n; ) {
    dx = xv[i];
    dy = yv[i++];
    x22 = dx * dx;
    X22 += (x22 - X22) / i;
    X3 += (x22 * dx - X3) / i;
    X4 += (x22 * x22 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x22 * dy - X2Y) / i;
  }
  const X2X2 = X4 - X22 * X22, d = X22 * X2X2 - X3 * X3, a2 = (X2Y * X22 - XY * X3) / d, b2 = (XY * X2X2 - X2Y * X3) / d, c2 = -a2 * X22, predict = (x3) => {
    x3 = x3 - ux;
    return a2 * x3 * x3 + b2 * x3 + c2 + uy;
  };
  return {
    coef: [c2 - b2 * ux + a2 * ux * ux + uy, b2 - 2 * a2 * ux, a2],
    predict,
    rSquared: rSquared(data2, x2, y2, uy, predict)
  };
}
function poly(data2, x2, y2, order) {
  if (order === 1) return linear$3(data2, x2, y2);
  if (order === 2) return quad(data2, x2, y2);
  const [xv, yv, ux, uy] = points(data2, x2, y2), n = xv.length, lhs = [], rhs = [], k = order + 1;
  let i, j, l, v, c2;
  for (i = 0; i < k; ++i) {
    for (l = 0, v = 0; l < n; ++l) {
      v += Math.pow(xv[l], i) * yv[l];
    }
    lhs.push(v);
    c2 = new Float64Array(k);
    for (j = 0; j < k; ++j) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i + j);
      }
      c2[j] = v;
    }
    rhs.push(c2);
  }
  rhs.push(lhs);
  const coef = gaussianElimination(rhs), predict = (x3) => {
    x3 -= ux;
    let y3 = uy + coef[0] + coef[1] * x3 + coef[2] * x3 * x3;
    for (i = 3; i < k; ++i) y3 += coef[i] * Math.pow(x3, i);
    return y3;
  };
  return {
    coef: uncenter(k, coef, -ux, uy),
    predict,
    rSquared: rSquared(data2, x2, y2, uy, predict)
  };
}
function uncenter(k, a2, x2, y2) {
  const z2 = Array(k);
  let i, j, v, c2;
  for (i = 0; i < k; ++i) z2[i] = 0;
  for (i = k - 1; i >= 0; --i) {
    v = a2[i];
    c2 = 1;
    z2[i] += v;
    for (j = 1; j <= i; ++j) {
      c2 *= (i + 1 - j) / j;
      z2[i - j] += v * Math.pow(x2, j) * c2;
    }
  }
  z2[0] += y2;
  return z2;
}
function gaussianElimination(matrix) {
  const n = matrix.length - 1, coef = [];
  let i, j, k, r2, t4;
  for (i = 0; i < n; ++i) {
    r2 = i;
    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r2])) {
        r2 = j;
      }
    }
    for (k = i; k < n + 1; ++k) {
      t4 = matrix[k][i];
      matrix[k][i] = matrix[k][r2];
      matrix[k][r2] = t4;
    }
    for (j = i + 1; j < n; ++j) {
      for (k = n; k >= i; k--) {
        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (j = n - 1; j >= 0; --j) {
    t4 = 0;
    for (k = j + 1; k < n; ++k) {
      t4 += matrix[k][j] * coef[k];
    }
    coef[j] = (matrix[n][j] - t4) / matrix[j][j];
  }
  return coef;
}
const maxiters = 2, epsilon$6 = 1e-12;
function loess(data2, x2, y2, bandwidth2) {
  const [xv, yv, ux, uy] = points(data2, x2, y2, true), n = xv.length, bw = Math.max(2, ~~(bandwidth2 * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
  for (let iter = -1; ++iter <= maxiters; ) {
    const interval2 = [0, bw - 1];
    for (let i = 0; i < n; ++i) {
      const dx = xv[i], i0 = interval2[0], i1 = interval2[1], edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0, X3 = 0, Y3 = 0, XY = 0, X22 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1);
      for (let k = i0; k <= i1; ++k) {
        const xk = xv[k], yk = yv[k], w2 = tricube(Math.abs(dx - xk) * denom) * robustWeights[k], xkw = xk * w2;
        W += w2;
        X3 += xkw;
        Y3 += yk * w2;
        XY += yk * xkw;
        X22 += xk * xkw;
      }
      const [a2, b2] = ols(X3 / W, Y3 / W, XY / W, X22 / W);
      yhat[i] = a2 + b2 * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval2);
    }
    if (iter === maxiters) {
      break;
    }
    const medianResidual = median(residuals);
    if (Math.abs(medianResidual) < epsilon$6) break;
    for (let i = 0, arg, w2; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual);
      robustWeights[i] = arg >= 1 ? epsilon$6 : (w2 = 1 - arg * arg) * w2;
    }
  }
  return output$1(xv, yhat, ux, uy);
}
function tricube(x2) {
  return (x2 = 1 - x2 * x2 * x2) * x2 * x2;
}
function updateInterval(xv, i, interval2) {
  const val = xv[i];
  let left = interval2[0], right = interval2[1] + 1;
  if (right >= xv.length) return;
  while (i > left && xv[right] - val <= val - xv[left]) {
    interval2[0] = ++left;
    interval2[1] = right;
    ++right;
  }
}
function output$1(xv, yhat, ux, uy) {
  const n = xv.length, out = [];
  let i = 0, cnt = 0, prev2 = [], v;
  for (; i < n; ++i) {
    v = xv[i] + ux;
    if (prev2[0] === v) {
      prev2[1] += (yhat[i] - prev2[1]) / ++cnt;
    } else {
      cnt = 0;
      prev2[1] += uy;
      prev2 = [v, yhat[i]];
      out.push(prev2);
    }
  }
  prev2[1] += uy;
  return out;
}
const MIN_RADIANS = 0.5 * Math.PI / 180;
function sampleCurve(f, extent2, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);
  const point2 = (x2) => [x2, f(x2)], minX = extent2[0], maxX = extent2[1], span2 = maxX - minX, stop3 = span2 / maxSteps, prev2 = [point2(minX)], next2 = [];
  if (minSteps === maxSteps) {
    for (let i = 1; i < maxSteps; ++i) {
      prev2.push(point2(minX + i / minSteps * span2));
    }
    prev2.push(point2(maxX));
    return prev2;
  } else {
    next2.push(point2(maxX));
    for (let i = minSteps; --i > 0; ) {
      next2.push(point2(minX + i / minSteps * span2));
    }
  }
  let p02 = prev2[0];
  let p1 = next2[next2.length - 1];
  const sx = 1 / span2;
  const sy = scaleY(p02[1], next2);
  while (p1) {
    const pm = point2((p02[0] + p1[0]) / 2);
    const dx = pm[0] - p02[0] >= stop3;
    if (dx && angleDelta(p02, pm, p1, sx, sy) > MIN_RADIANS) {
      next2.push(pm);
    } else {
      p02 = p1;
      prev2.push(p1);
      next2.pop();
    }
    p1 = next2[next2.length - 1];
  }
  return prev2;
}
function scaleY(init2, points2) {
  let ymin = init2;
  let ymax = init2;
  const n = points2.length;
  for (let i = 0; i < n; ++i) {
    const y2 = points2[i][1];
    if (y2 < ymin) ymin = y2;
    if (y2 > ymax) ymax = y2;
  }
  return 1 / (ymax - ymin);
}
function angleDelta(p, q, r2, sx, sy) {
  const a0 = Math.atan2(sy * (r2[1] - p[1]), sx * (r2[0] - p[0])), a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
  return Math.abs(a0 - a1);
}
function multikey(f) {
  return (x2) => {
    const n = f.length;
    let i = 1, k = String(f[0](x2));
    for (; i < n; ++i) {
      k += "|" + f[i](x2);
    }
    return k;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function() {
    return "";
  } : fields.length === 1 ? fields[0] : multikey(fields);
}
function measureName(op, field2, as) {
  return as || op + (!field2 ? "" : "_" + field2);
}
const noop$4 = () => {
};
const base_op = {
  init: noop$4,
  add: noop$4,
  rem: noop$4,
  idx: 0
};
const AggregateOps = {
  values: {
    init: (m2) => m2.cell.store = true,
    value: (m2) => m2.cell.data.values(),
    idx: -1
  },
  count: {
    value: (m2) => m2.cell.num
  },
  __count__: {
    value: (m2) => m2.missing + m2.valid
  },
  missing: {
    value: (m2) => m2.missing
  },
  valid: {
    value: (m2) => m2.valid
  },
  sum: {
    init: (m2) => m2.sum = 0,
    value: (m2) => m2.sum,
    add: (m2, v) => m2.sum += +v,
    rem: (m2, v) => m2.sum -= v
  },
  product: {
    init: (m2) => m2.product = 1,
    value: (m2) => m2.valid ? m2.product : void 0,
    add: (m2, v) => m2.product *= v,
    rem: (m2, v) => m2.product /= v
  },
  mean: {
    init: (m2) => m2.mean = 0,
    value: (m2) => m2.valid ? m2.mean : void 0,
    add: (m2, v) => (m2.mean_d = v - m2.mean, m2.mean += m2.mean_d / m2.valid),
    rem: (m2, v) => (m2.mean_d = v - m2.mean, m2.mean -= m2.valid ? m2.mean_d / m2.valid : m2.mean)
  },
  average: {
    value: (m2) => m2.valid ? m2.mean : void 0,
    req: ["mean"],
    idx: 1
  },
  variance: {
    init: (m2) => m2.dev = 0,
    value: (m2) => m2.valid > 1 ? m2.dev / (m2.valid - 1) : void 0,
    add: (m2, v) => m2.dev += m2.mean_d * (v - m2.mean),
    rem: (m2, v) => m2.dev -= m2.mean_d * (v - m2.mean),
    req: ["mean"],
    idx: 1
  },
  variancep: {
    value: (m2) => m2.valid > 1 ? m2.dev / m2.valid : void 0,
    req: ["variance"],
    idx: 2
  },
  stdev: {
    value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / (m2.valid - 1)) : void 0,
    req: ["variance"],
    idx: 2
  },
  stdevp: {
    value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / m2.valid) : void 0,
    req: ["variance"],
    idx: 2
  },
  stderr: {
    value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / (m2.valid * (m2.valid - 1))) : void 0,
    req: ["variance"],
    idx: 2
  },
  distinct: {
    value: (m2) => m2.cell.data.distinct(m2.get),
    req: ["values"],
    idx: 3
  },
  ci0: {
    value: (m2) => m2.cell.data.ci0(m2.get),
    req: ["values"],
    idx: 3
  },
  ci1: {
    value: (m2) => m2.cell.data.ci1(m2.get),
    req: ["values"],
    idx: 3
  },
  median: {
    value: (m2) => m2.cell.data.q2(m2.get),
    req: ["values"],
    idx: 3
  },
  q1: {
    value: (m2) => m2.cell.data.q1(m2.get),
    req: ["values"],
    idx: 3
  },
  q3: {
    value: (m2) => m2.cell.data.q3(m2.get),
    req: ["values"],
    idx: 3
  },
  min: {
    init: (m2) => m2.min = void 0,
    value: (m2) => m2.min = Number.isNaN(m2.min) ? m2.cell.data.min(m2.get) : m2.min,
    add: (m2, v) => {
      if (v < m2.min || m2.min === void 0) m2.min = v;
    },
    rem: (m2, v) => {
      if (v <= m2.min) m2.min = NaN;
    },
    req: ["values"],
    idx: 4
  },
  max: {
    init: (m2) => m2.max = void 0,
    value: (m2) => m2.max = Number.isNaN(m2.max) ? m2.cell.data.max(m2.get) : m2.max,
    add: (m2, v) => {
      if (v > m2.max || m2.max === void 0) m2.max = v;
    },
    rem: (m2, v) => {
      if (v >= m2.max) m2.max = NaN;
    },
    req: ["values"],
    idx: 4
  },
  argmin: {
    init: (m2) => m2.argmin = void 0,
    value: (m2) => m2.argmin || m2.cell.data.argmin(m2.get),
    add: (m2, v, t4) => {
      if (v < m2.min) m2.argmin = t4;
    },
    rem: (m2, v) => {
      if (v <= m2.min) m2.argmin = void 0;
    },
    req: ["min", "values"],
    idx: 3
  },
  argmax: {
    init: (m2) => m2.argmax = void 0,
    value: (m2) => m2.argmax || m2.cell.data.argmax(m2.get),
    add: (m2, v, t4) => {
      if (v > m2.max) m2.argmax = t4;
    },
    rem: (m2, v) => {
      if (v >= m2.max) m2.argmax = void 0;
    },
    req: ["max", "values"],
    idx: 3
  }
};
const ValidAggregateOps = Object.keys(AggregateOps);
function measure(key2, value2) {
  return (out) => extend$3({
    name: key2,
    out: out || key2
  }, base_op, value2);
}
ValidAggregateOps.forEach((key2) => {
  AggregateOps[key2] = measure(key2, AggregateOps[key2]);
});
function createMeasure(op, name) {
  return AggregateOps[op](name);
}
function compareIndex(a2, b2) {
  return a2.idx - b2.idx;
}
function resolve(agg) {
  const map2 = {};
  agg.forEach((a2) => map2[a2.name] = a2);
  const getreqs = (a2) => {
    if (!a2.req) return;
    a2.req.forEach((key2) => {
      if (!map2[key2]) getreqs(map2[key2] = AggregateOps[key2]());
    });
  };
  agg.forEach(getreqs);
  return Object.values(map2).sort(compareIndex);
}
function init() {
  this.valid = 0;
  this.missing = 0;
  this._ops.forEach((op) => op.init(this));
}
function add$3(v, t4) {
  if (v == null || v === "") {
    ++this.missing;
    return;
  }
  if (v !== v) return;
  ++this.valid;
  this._ops.forEach((op) => op.add(this, v, t4));
}
function rem(v, t4) {
  if (v == null || v === "") {
    --this.missing;
    return;
  }
  if (v !== v) return;
  --this.valid;
  this._ops.forEach((op) => op.rem(this, v, t4));
}
function set$5(t4) {
  this._out.forEach((op) => t4[op.out] = op.value(this));
  return t4;
}
function compileMeasures(agg, field2) {
  const get2 = field2 || identity$6, ops2 = resolve(agg), out = agg.slice().sort(compareIndex);
  function ctr(cell2) {
    this._ops = ops2;
    this._out = out;
    this.cell = cell2;
    this.init();
  }
  ctr.prototype.init = init;
  ctr.prototype.add = add$3;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set$5;
  ctr.prototype.get = get2;
  ctr.fields = agg.map((op) => op.out);
  return ctr;
}
function TupleStore(key2) {
  this._key = key2 ? field$1(key2) : tupleid;
  this.reset();
}
const prototype$1 = TupleStore.prototype;
prototype$1.reset = function() {
  this._add = [];
  this._rem = [];
  this._ext = null;
  this._get = null;
  this._q = null;
};
prototype$1.add = function(v) {
  this._add.push(v);
};
prototype$1.rem = function(v) {
  this._rem.push(v);
};
prototype$1.values = function() {
  this._get = null;
  if (this._rem.length === 0) return this._add;
  const a2 = this._add, r2 = this._rem, k = this._key, n = a2.length, m2 = r2.length, x2 = Array(n - m2), map2 = {};
  let i, j, v;
  for (i = 0; i < m2; ++i) {
    map2[k(r2[i])] = 1;
  }
  for (i = 0, j = 0; i < n; ++i) {
    if (map2[k(v = a2[i])]) {
      map2[k(v)] = 0;
    } else {
      x2[j++] = v;
    }
  }
  this._rem = [];
  return this._add = x2;
};
prototype$1.distinct = function(get2) {
  const v = this.values(), map2 = {};
  let n = v.length, count2 = 0, s;
  while (--n >= 0) {
    s = get2(v[n]) + "";
    if (!has$2(map2, s)) {
      map2[s] = 1;
      ++count2;
    }
  }
  return count2;
};
prototype$1.extent = function(get2) {
  if (this._get !== get2 || !this._ext) {
    const v = this.values(), i = extentIndex(v, get2);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get2;
  }
  return this._ext;
};
prototype$1.argmin = function(get2) {
  return this.extent(get2)[0] || {};
};
prototype$1.argmax = function(get2) {
  return this.extent(get2)[1] || {};
};
prototype$1.min = function(get2) {
  const m2 = this.extent(get2)[0];
  return m2 != null ? get2(m2) : void 0;
};
prototype$1.max = function(get2) {
  const m2 = this.extent(get2)[1];
  return m2 != null ? get2(m2) : void 0;
};
prototype$1.quartile = function(get2) {
  if (this._get !== get2 || !this._q) {
    this._q = quartiles(this.values(), get2);
    this._get = get2;
  }
  return this._q;
};
prototype$1.q1 = function(get2) {
  return this.quartile(get2)[0];
};
prototype$1.q2 = function(get2) {
  return this.quartile(get2)[1];
};
prototype$1.q3 = function(get2) {
  return this.quartile(get2)[2];
};
prototype$1.ci = function(get2) {
  if (this._get !== get2 || !this._ci) {
    this._ci = bootstrapCI(this.values(), 1e3, 0.05, get2);
    this._get = get2;
  }
  return this._ci;
};
prototype$1.ci0 = function(get2) {
  return this.ci(get2)[0];
};
prototype$1.ci1 = function(get2) {
  return this.ci(get2)[1];
};
function Aggregate$1(params2) {
  Transform.call(this, null, params2);
  this._adds = [];
  this._mods = [];
  this._alen = 0;
  this._mlen = 0;
  this._drop = true;
  this._cross = false;
  this._dims = [];
  this._dnames = [];
  this._measures = [];
  this._countOnly = false;
  this._counts = null;
  this._prev = null;
  this._inputs = null;
  this._outputs = null;
}
Aggregate$1.Definition = {
  "type": "Aggregate",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidAggregateOps
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "drop",
    "type": "boolean",
    "default": true
  }, {
    "name": "cross",
    "type": "boolean",
    "default": false
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(Aggregate$1, Transform, {
  transform(_, pulse2) {
    const aggr = this, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), mod = _.modified();
    aggr.stamp = out.stamp;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      aggr._prev = aggr.value;
      aggr.value = mod ? aggr.init(_) : {};
      pulse2.visit(pulse2.SOURCE, (t4) => aggr.add(t4));
    } else {
      aggr.value = aggr.value || aggr.init(_);
      pulse2.visit(pulse2.REM, (t4) => aggr.rem(t4));
      pulse2.visit(pulse2.ADD, (t4) => aggr.add(t4));
    }
    out.modifies(aggr._outputs);
    aggr._drop = _.drop !== false;
    if (_.cross && aggr._dims.length > 1) {
      aggr._drop = false;
      aggr.cross();
    }
    if (pulse2.clean() && aggr._drop) {
      out.clean(true).runAfter(() => this.clean());
    }
    return aggr.changes(out);
  },
  cross() {
    const aggr = this, curr = aggr.value, dims = aggr._dnames, vals2 = dims.map(() => ({})), n = dims.length;
    function collect2(cells) {
      let key2, i, t4, v;
      for (key2 in cells) {
        t4 = cells[key2].tuple;
        for (i = 0; i < n; ++i) {
          vals2[i][v = t4[dims[i]]] = v;
        }
      }
    }
    collect2(aggr._prev);
    collect2(curr);
    function generate2(base2, tuple, index2) {
      const name = dims[index2], v = vals2[index2++];
      for (const k in v) {
        const key2 = base2 ? base2 + "|" + k : k;
        tuple[name] = v[k];
        if (index2 < n) generate2(key2, tuple, index2);
        else if (!curr[key2]) aggr.cell(key2, tuple);
      }
    }
    generate2("", {}, 0);
  },
  init(_) {
    const inputs = this._inputs = [], outputs = this._outputs = [], inputMap = {};
    function inputVisit(get2) {
      const fields2 = array$5(accessorFields(get2)), n2 = fields2.length;
      let i2 = 0, f;
      for (; i2 < n2; ++i2) {
        if (!inputMap[f = fields2[i2]]) {
          inputMap[f] = 1;
          inputs.push(f);
        }
      }
    }
    this._dims = array$5(_.groupby);
    this._dnames = this._dims.map((d) => {
      const dname = accessorName(d);
      inputVisit(d);
      outputs.push(dname);
      return dname;
    });
    this.cellkey = _.key ? _.key : groupkey(this._dims);
    this._countOnly = true;
    this._counts = [];
    this._measures = [];
    const fields = _.fields || [null], ops2 = _.ops || ["count"], as = _.as || [], n = fields.length, map2 = {};
    let field2, op, m2, mname, outname, i;
    if (n !== ops2.length) {
      error("Unmatched number of fields and aggregate ops.");
    }
    for (i = 0; i < n; ++i) {
      field2 = fields[i];
      op = ops2[i];
      if (field2 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      mname = accessorName(field2);
      outname = measureName(op, mname, as[i]);
      outputs.push(outname);
      if (op === "count") {
        this._counts.push(outname);
        continue;
      }
      m2 = map2[mname];
      if (!m2) {
        inputVisit(field2);
        m2 = map2[mname] = [];
        m2.field = field2;
        this._measures.push(m2);
      }
      if (op !== "count") this._countOnly = false;
      m2.push(createMeasure(op, outname));
    }
    this._measures = this._measures.map((m3) => compileMeasures(m3, m3.field));
    return {};
  },
  // -- Cell Management -----
  cellkey: groupkey(),
  cell(key2, t4) {
    let cell2 = this.value[key2];
    if (!cell2) {
      cell2 = this.value[key2] = this.newcell(key2, t4);
      this._adds[this._alen++] = cell2;
    } else if (cell2.num === 0 && this._drop && cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._adds[this._alen++] = cell2;
    } else if (cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._mods[this._mlen++] = cell2;
    }
    return cell2;
  },
  newcell(key2, t4) {
    const cell2 = {
      key: key2,
      num: 0,
      agg: null,
      tuple: this.newtuple(t4, this._prev && this._prev[key2]),
      stamp: this.stamp,
      store: false
    };
    if (!this._countOnly) {
      const measures = this._measures, n = measures.length;
      cell2.agg = Array(n);
      for (let i = 0; i < n; ++i) {
        cell2.agg[i] = new measures[i](cell2);
      }
    }
    if (cell2.store) {
      cell2.data = new TupleStore();
    }
    return cell2;
  },
  newtuple(t4, p) {
    const names = this._dnames, dims = this._dims, n = dims.length, x2 = {};
    for (let i = 0; i < n; ++i) {
      x2[names[i]] = dims[i](t4);
    }
    return p ? replace$2(p.tuple, x2) : ingest$1(x2);
  },
  clean() {
    const cells = this.value;
    for (const key2 in cells) {
      if (cells[key2].num === 0) {
        delete cells[key2];
      }
    }
  },
  // -- Process Tuples -----
  add(t4) {
    const key2 = this.cellkey(t4), cell2 = this.cell(key2, t4);
    cell2.num += 1;
    if (this._countOnly) return;
    if (cell2.store) cell2.data.add(t4);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].add(agg[i].get(t4), t4);
    }
  },
  rem(t4) {
    const key2 = this.cellkey(t4), cell2 = this.cell(key2, t4);
    cell2.num -= 1;
    if (this._countOnly) return;
    if (cell2.store) cell2.data.rem(t4);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].rem(agg[i].get(t4), t4);
    }
  },
  celltuple(cell2) {
    const tuple = cell2.tuple, counts = this._counts;
    if (cell2.store) {
      cell2.data.values();
    }
    for (let i = 0, n = counts.length; i < n; ++i) {
      tuple[counts[i]] = cell2.num;
    }
    if (!this._countOnly) {
      const agg = cell2.agg;
      for (let i = 0, n = agg.length; i < n; ++i) {
        agg[i].set(tuple);
      }
    }
    return tuple;
  },
  changes(out) {
    const adds = this._adds, mods = this._mods, prev2 = this._prev, drop = this._drop, add2 = out.add, rem2 = out.rem, mod = out.mod;
    let cell2, key2, i, n;
    if (prev2) for (key2 in prev2) {
      cell2 = prev2[key2];
      if (!drop || cell2.num) rem2.push(cell2.tuple);
    }
    for (i = 0, n = this._alen; i < n; ++i) {
      add2.push(this.celltuple(adds[i]));
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      cell2 = mods[i];
      (cell2.num === 0 && drop ? rem2 : mod).push(this.celltuple(cell2));
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
    this._prev = null;
    return out;
  }
});
const EPSILON$1 = 1e-14;
function Bin(params2) {
  Transform.call(this, null, params2);
}
Bin.Definition = {
  "type": "Bin",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "interval",
    "type": "boolean",
    "default": true
  }, {
    "name": "anchor",
    "type": "number"
  }, {
    "name": "maxbins",
    "type": "number",
    "default": 20
  }, {
    "name": "base",
    "type": "number",
    "default": 10
  }, {
    "name": "divide",
    "type": "number",
    "array": true,
    "default": [5, 2]
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "span",
    "type": "number"
  }, {
    "name": "step",
    "type": "number"
  }, {
    "name": "steps",
    "type": "number",
    "array": true
  }, {
    "name": "minstep",
    "type": "number",
    "default": 0
  }, {
    "name": "nice",
    "type": "boolean",
    "default": true
  }, {
    "name": "name",
    "type": "string"
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["bin0", "bin1"]
  }]
};
inherits(Bin, Transform, {
  transform(_, pulse2) {
    const band2 = _.interval !== false, bins2 = this._bins(_), start = bins2.start, step = bins2.step, as = _.as || ["bin0", "bin1"], b0 = as[0], b1 = as[1];
    let flag2;
    if (_.modified()) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
    } else {
      flag2 = pulse2.modified(accessorFields(_.field)) ? pulse2.ADD_MOD : pulse2.ADD;
    }
    pulse2.visit(flag2, band2 ? (t4) => {
      const v = bins2(t4);
      t4[b0] = v;
      t4[b1] = v == null ? null : start + step * (1 + (v - start) / step);
    } : (t4) => t4[b0] = bins2(t4));
    return pulse2.modifies(band2 ? as : b0);
  },
  _bins(_) {
    if (this.value && !_.modified()) {
      return this.value;
    }
    const field2 = _.field, bins2 = bin(_), step = bins2.step;
    let start = bins2.start, stop3 = start + Math.ceil((bins2.stop - start) / step) * step, a2, d;
    if ((a2 = _.anchor) != null) {
      d = a2 - (start + step * Math.floor((a2 - start) / step));
      start += d;
      stop3 += d;
    }
    const f = function(t4) {
      let v = toNumber(field2(t4));
      return v == null ? null : v < start ? -Infinity : v > stop3 ? Infinity : (v = Math.max(start, Math.min(v, stop3 - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));
    };
    f.start = start;
    f.stop = bins2.stop;
    f.step = step;
    return this.value = accessor(f, accessorFields(field2), _.name || "bin_" + accessorName(field2));
  }
});
function SortedList(idFunc, source2, input) {
  const $2 = idFunc;
  let data2 = source2 || [], add2 = input || [], rem2 = {}, cnt = 0;
  return {
    add: (t4) => add2.push(t4),
    remove: (t4) => rem2[$2(t4)] = ++cnt,
    size: () => data2.length,
    data: (compare2, resort) => {
      if (cnt) {
        data2 = data2.filter((t4) => !rem2[$2(t4)]);
        rem2 = {};
        cnt = 0;
      }
      if (resort && compare2) {
        data2.sort(compare2);
      }
      if (add2.length) {
        data2 = compare2 ? merge$4(compare2, data2, add2.sort(compare2)) : data2.concat(add2);
        add2 = [];
      }
      return data2;
    }
  };
}
function Collect$1(params2) {
  Transform.call(this, [], params2);
}
Collect$1.Definition = {
  "type": "Collect",
  "metadata": {
    "source": true
  },
  "params": [{
    "name": "sort",
    "type": "compare"
  }]
};
inherits(Collect$1, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), list = SortedList(tupleid, this.value, out.materialize(out.ADD).add), sort2 = _.sort, mod = pulse2.changed() || sort2 && (_.modified("sort") || pulse2.modified(sort2.fields));
    out.visit(out.REM, list.remove);
    this.modified(mod);
    this.value = out.source = list.data(stableCompare(sort2), mod);
    if (pulse2.source && pulse2.source.root) {
      this.value.root = pulse2.source.root;
    }
    return out;
  }
});
function Compare$1(params2) {
  Operator.call(this, null, update$5, params2);
}
inherits(Compare$1, Operator);
function update$5(_) {
  return this.value && !_.modified() ? this.value : compare$9(_.fields, _.orders);
}
function CountPattern(params2) {
  Transform.call(this, null, params2);
}
CountPattern.Definition = {
  "type": "CountPattern",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "case",
    "type": "enum",
    "values": ["upper", "lower", "mixed"],
    "default": "mixed"
  }, {
    "name": "pattern",
    "type": "string",
    "default": '[\\w"]+'
  }, {
    "name": "stopwords",
    "type": "string",
    "default": ""
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["text", "count"]
  }]
};
function tokenize(text2, tcase, match2) {
  switch (tcase) {
    case "upper":
      text2 = text2.toUpperCase();
      break;
    case "lower":
      text2 = text2.toLowerCase();
      break;
  }
  return text2.match(match2);
}
inherits(CountPattern, Transform, {
  transform(_, pulse2) {
    const process2 = (update2) => (tuple) => {
      var tokens = tokenize(get2(tuple), _.case, match2) || [], t4;
      for (var i = 0, n = tokens.length; i < n; ++i) {
        if (!stop3.test(t4 = tokens[i])) update2(t4);
      }
    };
    const init2 = this._parameterCheck(_, pulse2), counts = this._counts, match2 = this._match, stop3 = this._stop, get2 = _.field, as = _.as || ["text", "count"], add2 = process2((t4) => counts[t4] = 1 + (counts[t4] || 0)), rem2 = process2((t4) => counts[t4] -= 1);
    if (init2) {
      pulse2.visit(pulse2.SOURCE, add2);
    } else {
      pulse2.visit(pulse2.ADD, add2);
      pulse2.visit(pulse2.REM, rem2);
    }
    return this._finish(pulse2, as);
  },
  _parameterCheck(_, pulse2) {
    let init2 = false;
    if (_.modified("stopwords") || !this._stop) {
      this._stop = new RegExp("^" + (_.stopwords || "") + "$", "i");
      init2 = true;
    }
    if (_.modified("pattern") || !this._match) {
      this._match = new RegExp(_.pattern || "[\\w']+", "g");
      init2 = true;
    }
    if (_.modified("field") || pulse2.modified(_.field.fields)) {
      init2 = true;
    }
    if (init2) this._counts = {};
    return init2;
  },
  _finish(pulse2, as) {
    const counts = this._counts, tuples = this._tuples || (this._tuples = {}), text2 = as[0], count2 = as[1], out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    let w2, t4, c2;
    for (w2 in counts) {
      t4 = tuples[w2];
      c2 = counts[w2] || 0;
      if (!t4 && c2) {
        tuples[w2] = t4 = ingest$1({});
        t4[text2] = w2;
        t4[count2] = c2;
        out.add.push(t4);
      } else if (c2 === 0) {
        if (t4) out.rem.push(t4);
        counts[w2] = null;
        tuples[w2] = null;
      } else if (t4[count2] !== c2) {
        t4[count2] = c2;
        out.mod.push(t4);
      }
    }
    return out.modifies(as);
  }
});
function Cross(params2) {
  Transform.call(this, null, params2);
}
Cross.Definition = {
  "type": "Cross",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "filter",
    "type": "expr"
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["a", "b"]
  }]
};
inherits(Cross, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), as = _.as || ["a", "b"], a2 = as[0], b2 = as[1], reset3 = !this.value || pulse2.changed(pulse2.ADD_REM) || _.modified("as") || _.modified("filter");
    let data2 = this.value;
    if (reset3) {
      if (data2) out.rem = data2;
      data2 = pulse2.materialize(pulse2.SOURCE).source;
      out.add = this.value = cross(data2, a2, b2, _.filter || truthy);
    } else {
      out.mod = data2;
    }
    out.source = this.value;
    return out.modifies(as);
  }
});
function cross(input, a2, b2, filter2) {
  var data2 = [], t4 = {}, n = input.length, i = 0, j, left;
  for (; i < n; ++i) {
    t4[a2] = left = input[i];
    for (j = 0; j < n; ++j) {
      t4[b2] = input[j];
      if (filter2(t4)) {
        data2.push(ingest$1(t4));
        t4 = {};
        t4[a2] = left;
      }
    }
  }
  return data2;
}
const Distributions = {
  kde,
  mixture: mixture$1,
  normal: gaussian,
  lognormal,
  uniform
};
const DISTRIBUTIONS = "distributions", FUNCTION = "function", FIELD = "field";
function parse$5(def2, data2) {
  const func = def2[FUNCTION];
  if (!has$2(Distributions, func)) {
    error("Unknown distribution function: " + func);
  }
  const d = Distributions[func]();
  for (const name in def2) {
    if (name === FIELD) {
      d.data((def2.from || data2()).map(def2[name]));
    } else if (name === DISTRIBUTIONS) {
      d[name](def2[name].map((_) => parse$5(_, data2)));
    } else if (typeof d[name] === FUNCTION) {
      d[name](def2[name]);
    }
  }
  return d;
}
function Density(params2) {
  Transform.call(this, null, params2);
}
const distributions = [{
  "key": {
    "function": "normal"
  },
  "params": [{
    "name": "mean",
    "type": "number",
    "default": 0
  }, {
    "name": "stdev",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "lognormal"
  },
  "params": [{
    "name": "mean",
    "type": "number",
    "default": 0
  }, {
    "name": "stdev",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "uniform"
  },
  "params": [{
    "name": "min",
    "type": "number",
    "default": 0
  }, {
    "name": "max",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "kde"
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "from",
    "type": "data"
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0
  }]
}];
const mixture = {
  "key": {
    "function": "mixture"
  },
  "params": [{
    "name": "distributions",
    "type": "param",
    "array": true,
    "params": distributions
  }, {
    "name": "weights",
    "type": "number",
    "array": true
  }]
};
Density.Definition = {
  "type": "Density",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "steps",
    "type": "number"
  }, {
    "name": "minsteps",
    "type": "number",
    "default": 25
  }, {
    "name": "maxsteps",
    "type": "number",
    "default": 200
  }, {
    "name": "method",
    "type": "string",
    "default": "pdf",
    "values": ["pdf", "cdf"]
  }, {
    "name": "distribution",
    "type": "param",
    "params": distributions.concat(mixture)
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["value", "density"]
  }]
};
inherits(Density, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const dist2 = parse$5(_.distribution, source$1(pulse2)), minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      let method2 = _.method || "pdf";
      if (method2 !== "pdf" && method2 !== "cdf") {
        error("Invalid density method: " + method2);
      }
      if (!_.extent && !dist2.data) {
        error("Missing density extent parameter.");
      }
      method2 = dist2[method2];
      const as = _.as || ["value", "density"], domain2 = _.extent || extent(dist2.data()), values2 = sampleCurve(method2, domain2, minsteps, maxsteps).map((v) => {
        const tuple = {};
        tuple[as[0]] = v[0];
        tuple[as[1]] = v[1];
        return ingest$1(tuple);
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});
function source$1(pulse2) {
  return () => pulse2.materialize(pulse2.SOURCE).source;
}
function fieldNames(fields, as) {
  if (!fields) return null;
  return fields.map((f, i) => as[i] || accessorName(f));
}
function partition$1$1(data2, groupby, field2) {
  const groups = [], get2 = (f) => f(t4);
  let map2, i, n, t4, k, g;
  if (groupby == null) {
    groups.push(data2.map(field2));
  } else {
    for (map2 = {}, i = 0, n = data2.length; i < n; ++i) {
      t4 = data2[i];
      k = groupby.map(get2);
      g = map2[k];
      if (!g) {
        map2[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(field2(t4));
    }
  }
  return groups;
}
const Output$5 = "bin";
function DotBin(params2) {
  Transform.call(this, null, params2);
}
DotBin.Definition = {
  "type": "DotBin",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "step",
    "type": "number"
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "default": Output$5
  }]
};
const autostep = (data2, field2) => span(extent(data2, field2)) / 30;
inherits(DotBin, Transform, {
  transform(_, pulse2) {
    if (this.value && !(_.modified() || pulse2.changed())) {
      return pulse2;
    }
    const source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1$1(pulse2.source, _.groupby, identity$6), smooth = _.smooth || false, field2 = _.field, step = _.step || autostep(source2, field2), sort2 = stableCompare((a2, b2) => field2(a2) - field2(b2)), as = _.as || Output$5, n = groups.length;
    let min2 = Infinity, max2 = -Infinity, i = 0, j;
    for (; i < n; ++i) {
      const g = groups[i].sort(sort2);
      j = -1;
      for (const v of dotbin(g, step, smooth, field2)) {
        if (v < min2) min2 = v;
        if (v > max2) max2 = v;
        g[++j][as] = v;
      }
    }
    this.value = {
      start: min2,
      stop: max2,
      step
    };
    return pulse2.reflow(true).modifies(as);
  }
});
function Expression$1(params2) {
  Operator.call(this, null, update$4, params2);
  this.modified(true);
}
inherits(Expression$1, Operator);
function update$4(_) {
  const expr2 = _.expr;
  return this.value && !_.modified("expr") ? this.value : accessor((datum2) => expr2(datum2, _), accessorFields(expr2), accessorName(expr2));
}
function Extent(params2) {
  Transform.call(this, [void 0, void 0], params2);
}
Extent.Definition = {
  "type": "Extent",
  "metadata": {},
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }]
};
inherits(Extent, Transform, {
  transform(_, pulse2) {
    const extent2 = this.value, field2 = _.field, mod = pulse2.changed() || pulse2.modified(field2.fields) || _.modified("field");
    let min2 = extent2[0], max2 = extent2[1];
    if (mod || min2 == null) {
      min2 = Infinity;
      max2 = -Infinity;
    }
    pulse2.visit(mod ? pulse2.SOURCE : pulse2.ADD, (t4) => {
      const v = toNumber(field2(t4));
      if (v != null) {
        if (v < min2) min2 = v;
        if (v > max2) max2 = v;
      }
    });
    if (!Number.isFinite(min2) || !Number.isFinite(max2)) {
      let name = accessorName(field2);
      if (name) name = ' for field "'.concat(name, '"');
      pulse2.dataflow.warn("Infinite extent".concat(name, ": [").concat(min2, ", ").concat(max2, "]"));
      min2 = max2 = void 0;
    }
    this.value = [min2, max2];
  }
});
function Subflow(pulse2, parent) {
  Operator.call(this, pulse2);
  this.parent = parent;
  this.count = 0;
}
inherits(Subflow, Operator, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(target2) {
    this.detachSubflow = target2.detachSubflow;
    this.targets().add(target2);
    return target2.source = this;
  },
  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(t4) {
    this.count += 1;
    this.value.add.push(t4);
  },
  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(t4) {
    this.count -= 1;
    this.value.rem.push(t4);
  },
  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(t4) {
    this.value.mod.push(t4);
  },
  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(pulse2) {
    this.value.init(pulse2, pulse2.NO_SOURCE);
  },
  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    return this.value;
  }
});
function Facet$1(params2) {
  Transform.call(this, {}, params2);
  this._keys = fastmap();
  const a2 = this._targets = [];
  a2.active = 0;
  a2.forEach = (f) => {
    for (let i = 0, n = a2.active; i < n; ++i) {
      f(a2[i], i, a2);
    }
  };
}
inherits(Facet$1, Transform, {
  activate(flow) {
    this._targets[this._targets.active++] = flow;
  },
  // parent argument provided by PreFacet subclass
  subflow(key2, flow, pulse2, parent) {
    const flows = this.value;
    let sf = has$2(flows, key2) && flows[key2], df, p;
    if (!sf) {
      p = parent || (p = this._group[key2]) && p.tuple;
      df = pulse2.dataflow;
      sf = new Subflow(pulse2.fork(pulse2.NO_SOURCE), this);
      df.add(sf).connect(flow(df, key2, p));
      flows[key2] = sf;
      this.activate(sf);
    } else if (sf.value.stamp < pulse2.stamp) {
      sf.init(pulse2);
      this.activate(sf);
    }
    return sf;
  },
  clean() {
    const flows = this.value;
    let detached = 0;
    for (const key2 in flows) {
      if (flows[key2].count === 0) {
        const detach = flows[key2].detachSubflow;
        if (detach) detach();
        delete flows[key2];
        ++detached;
      }
    }
    if (detached) {
      const active = this._targets.filter((sf) => sf && sf.count > 0);
      this.initTargets(active);
    }
  },
  initTargets(act) {
    const a2 = this._targets, n = a2.length, m2 = act ? act.length : 0;
    let i = 0;
    for (; i < m2; ++i) {
      a2[i] = act[i];
    }
    for (; i < n && a2[i] != null; ++i) {
      a2[i] = null;
    }
    a2.active = m2;
  },
  transform(_, pulse2) {
    const df = pulse2.dataflow, key2 = _.key, flow = _.subflow, cache2 = this._keys, rekey = _.modified("key"), subflow = (key3) => this.subflow(key3, flow, pulse2);
    this._group = _.group || {};
    this.initTargets();
    pulse2.visit(pulse2.REM, (t4) => {
      const id2 = tupleid(t4), k = cache2.get(id2);
      if (k !== void 0) {
        cache2.delete(id2);
        subflow(k).rem(t4);
      }
    });
    pulse2.visit(pulse2.ADD, (t4) => {
      const k = key2(t4);
      cache2.set(tupleid(t4), k);
      subflow(k).add(t4);
    });
    if (rekey || pulse2.modified(key2.fields)) {
      pulse2.visit(pulse2.MOD, (t4) => {
        const id2 = tupleid(t4), k0 = cache2.get(id2), k1 = key2(t4);
        if (k0 === k1) {
          subflow(k1).mod(t4);
        } else {
          cache2.set(id2, k1);
          subflow(k0).rem(t4);
          subflow(k1).add(t4);
        }
      });
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t4) => {
        subflow(cache2.get(tupleid(t4))).mod(t4);
      });
    }
    if (rekey) {
      pulse2.visit(pulse2.REFLOW, (t4) => {
        const id2 = tupleid(t4), k0 = cache2.get(id2), k1 = key2(t4);
        if (k0 !== k1) {
          cache2.set(id2, k1);
          subflow(k0).rem(t4);
          subflow(k1).add(t4);
        }
      });
    }
    if (pulse2.clean()) {
      df.runAfter(() => {
        this.clean();
        cache2.clean();
      });
    } else if (cache2.empty > df.cleanThreshold) {
      df.runAfter(cache2.clean);
    }
    return pulse2;
  }
});
function Field$1(params2) {
  Operator.call(this, null, update$3, params2);
}
inherits(Field$1, Operator);
function update$3(_) {
  return this.value && !_.modified() ? this.value : isArray$1(_.name) ? array$5(_.name).map((f) => field$1(f)) : field$1(_.name, _.as);
}
function Filter(params2) {
  Transform.call(this, fastmap(), params2);
}
Filter.Definition = {
  "type": "Filter",
  "metadata": {
    "changes": true
  },
  "params": [{
    "name": "expr",
    "type": "expr",
    "required": true
  }]
};
inherits(Filter, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, cache2 = this.value, output2 = pulse2.fork(), add2 = output2.add, rem2 = output2.rem, mod = output2.mod, test2 = _.expr;
    let isMod = true;
    pulse2.visit(pulse2.REM, (t4) => {
      const id2 = tupleid(t4);
      if (!cache2.has(id2)) rem2.push(t4);
      else cache2.delete(id2);
    });
    pulse2.visit(pulse2.ADD, (t4) => {
      if (test2(t4, _)) add2.push(t4);
      else cache2.set(tupleid(t4), 1);
    });
    function revisit(t4) {
      const id2 = tupleid(t4), b2 = test2(t4, _), s = cache2.get(id2);
      if (b2 && s) {
        cache2.delete(id2);
        add2.push(t4);
      } else if (!b2 && !s) {
        cache2.set(id2, 1);
        rem2.push(t4);
      } else if (isMod && b2 && !s) {
        mod.push(t4);
      }
    }
    pulse2.visit(pulse2.MOD, revisit);
    if (_.modified()) {
      isMod = false;
      pulse2.visit(pulse2.REFLOW, revisit);
    }
    if (cache2.empty > df.cleanThreshold) df.runAfter(cache2.clean);
    return output2;
  }
});
function Flatten(params2) {
  Transform.call(this, [], params2);
}
Flatten.Definition = {
  "type": "Flatten",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "index",
    "type": "string"
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Flatten, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(fields, _.as || []), index2 = _.index || null, m2 = as.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t4) => {
      const arrays = fields.map((f) => f(t4)), maxlen = arrays.reduce((l, a2) => Math.max(l, a2.length), 0);
      let i = 0, j, d, v;
      for (; i < maxlen; ++i) {
        d = derive(t4);
        for (j = 0; j < m2; ++j) {
          d[as[j]] = (v = arrays[j][i]) == null ? null : v;
        }
        if (index2) {
          d[index2] = i;
        }
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    if (index2) out.modifies(index2);
    return out.modifies(as);
  }
});
function Fold(params2) {
  Transform.call(this, [], params2);
}
Fold.Definition = {
  "type": "Fold",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["key", "value"]
  }]
};
inherits(Fold, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, fnames = fields.map(accessorName), as = _.as || ["key", "value"], k = as[0], v = as[1], n = fields.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t4) => {
      for (let i = 0, d; i < n; ++i) {
        d = derive(t4);
        d[k] = fnames[i];
        d[v] = fields[i](t4);
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    return out.modifies(as);
  }
});
function Formula(params2) {
  Transform.call(this, null, params2);
}
Formula.Definition = {
  "type": "Formula",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "expr",
    "type": "expr",
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "required": true
  }, {
    "name": "initonly",
    "type": "boolean"
  }]
};
inherits(Formula, Transform, {
  transform(_, pulse2) {
    const func = _.expr, as = _.as, mod = _.modified(), flag2 = _.initonly ? pulse2.ADD : mod ? pulse2.SOURCE : pulse2.modified(func.fields) || pulse2.modified(as) ? pulse2.ADD_MOD : pulse2.ADD;
    if (mod) {
      pulse2 = pulse2.materialize().reflow(true);
    }
    if (!_.initonly) {
      pulse2.modifies(as);
    }
    return pulse2.visit(flag2, (t4) => t4[as] = func(t4, _));
  }
});
function Generate(params2) {
  Transform.call(this, [], params2);
}
inherits(Generate, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), gen = _.generator;
    let data2 = this.value, num = _.size - data2.length, add2, rem2, t4;
    if (num > 0) {
      for (add2 = []; --num >= 0; ) {
        add2.push(t4 = ingest$1(gen(_)));
        data2.push(t4);
      }
      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add2) : add2;
    } else {
      rem2 = data2.slice(0, -num);
      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem2) : rem2;
      data2 = data2.slice(-num);
    }
    out.source = this.value = data2;
    return out;
  }
});
const Methods$1 = {
  value: "value",
  median,
  mean,
  min: min$2,
  max: max$2
};
const Empty$1 = [];
function Impute(params2) {
  Transform.call(this, [], params2);
}
Impute.Definition = {
  "type": "Impute",
  "metadata": {
    "changes": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "key",
    "type": "field",
    "required": true
  }, {
    "name": "keyvals",
    "array": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "method",
    "type": "enum",
    "default": "value",
    "values": ["value", "mean", "median", "max", "min"]
  }, {
    "name": "value",
    "default": 0
  }]
};
function getValue$2(_) {
  var m2 = _.method || Methods$1.value, v;
  if (Methods$1[m2] == null) {
    error("Unrecognized imputation method: " + m2);
  } else if (m2 === Methods$1.value) {
    v = _.value !== void 0 ? _.value : 0;
    return () => v;
  } else {
    return Methods$1[m2];
  }
}
function getField$1(_) {
  const f = _.field;
  return (t4) => t4 ? f(t4) : NaN;
}
inherits(Impute, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), impute = getValue$2(_), field2 = getField$1(_), fName = accessorName(_.field), kName = accessorName(_.key), gNames = (_.groupby || []).map(accessorName), groups = partition$4(pulse2.source, _.groupby, _.key, _.keyvals), curr = [], prev2 = this.value, m2 = groups.domain.length, group2, value2, gVals, kVal, g, i, j, l, n, t4;
    for (g = 0, l = groups.length; g < l; ++g) {
      group2 = groups[g];
      gVals = group2.values;
      value2 = NaN;
      for (j = 0; j < m2; ++j) {
        if (group2[j] != null) continue;
        kVal = groups.domain[j];
        t4 = {
          _impute: true
        };
        for (i = 0, n = gVals.length; i < n; ++i) t4[gNames[i]] = gVals[i];
        t4[kName] = kVal;
        t4[fName] = Number.isNaN(value2) ? value2 = impute(group2, field2) : value2;
        curr.push(ingest$1(t4));
      }
    }
    if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);
    if (prev2.length) out.rem = out.materialize(out.REM).rem.concat(prev2);
    this.value = curr;
    return out;
  }
});
function partition$4(data2, groupby, key2, keyvals) {
  var get2 = (f) => f(t4), groups = [], domain2 = keyvals ? keyvals.slice() : [], kMap = {}, gMap = {}, gVals, gKey, group2, i, j, k, n, t4;
  domain2.forEach((k2, i2) => kMap[k2] = i2 + 1);
  for (i = 0, n = data2.length; i < n; ++i) {
    t4 = data2[i];
    k = key2(t4);
    j = kMap[k] || (kMap[k] = domain2.push(k));
    gKey = (gVals = groupby ? groupby.map(get2) : Empty$1) + "";
    if (!(group2 = gMap[gKey])) {
      group2 = gMap[gKey] = [];
      groups.push(group2);
      group2.values = gVals;
    }
    group2[j - 1] = t4;
  }
  groups.domain = domain2;
  return groups;
}
function JoinAggregate(params2) {
  Aggregate$1.call(this, params2);
}
JoinAggregate.Definition = {
  "type": "JoinAggregate",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidAggregateOps
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(JoinAggregate, Aggregate$1, {
  transform(_, pulse2) {
    const aggr = this, mod = _.modified();
    let cells;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      cells = aggr.value = mod ? aggr.init(_) : {};
      pulse2.visit(pulse2.SOURCE, (t4) => aggr.add(t4));
    } else {
      cells = aggr.value = aggr.value || this.init(_);
      pulse2.visit(pulse2.REM, (t4) => aggr.rem(t4));
      pulse2.visit(pulse2.ADD, (t4) => aggr.add(t4));
    }
    aggr.changes();
    pulse2.visit(pulse2.SOURCE, (t4) => {
      extend$3(t4, cells[aggr.cellkey(t4)].tuple);
    });
    return pulse2.reflow(mod).modifies(this._outputs);
  },
  changes() {
    const adds = this._adds, mods = this._mods;
    let i, n;
    for (i = 0, n = this._alen; i < n; ++i) {
      this.celltuple(adds[i]);
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      this.celltuple(mods[i]);
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
  }
});
function KDE(params2) {
  Transform.call(this, null, params2);
}
KDE.Definition = {
  "type": "KDE",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "cumulative",
    "type": "boolean",
    "default": false
  }, {
    "name": "counts",
    "type": "boolean",
    "default": false
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "steps",
    "type": "number"
  }, {
    "name": "minsteps",
    "type": "number",
    "default": 25
  }, {
    "name": "maxsteps",
    "type": "number",
    "default": 200
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["value", "density"]
  }]
};
inherits(KDE, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1$1(source2, _.groupby, _.field), names = (_.groupby || []).map(accessorName), bandwidth2 = _.bandwidth, method2 = _.cumulative ? "cdf" : "pdf", as = _.as || ["value", "density"], values2 = [];
      let domain2 = _.extent, minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      if (method2 !== "pdf" && method2 !== "cdf") {
        error("Invalid density method: " + method2);
      }
      if (_.resolve === "shared") {
        if (!domain2) domain2 = extent(source2, _.field);
        minsteps = maxsteps = _.steps || maxsteps;
      }
      groups.forEach((g) => {
        const density = kde(g, bandwidth2)[method2], scale2 = _.counts ? g.length : 1, local = domain2 || extent(g);
        sampleCurve(density, local, minsteps, maxsteps).forEach((v) => {
          const t4 = {};
          for (let i = 0; i < names.length; ++i) {
            t4[names[i]] = g.dims[i];
          }
          t4[as[0]] = v[0];
          t4[as[1]] = v[1] * scale2;
          values2.push(ingest$1(t4));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});
function Key$1(params2) {
  Operator.call(this, null, update$2, params2);
}
inherits(Key$1, Operator);
function update$2(_) {
  return this.value && !_.modified() ? this.value : key(_.fields, _.flat);
}
function Load$1(params2) {
  Transform.call(this, [], params2);
  this._pending = null;
}
inherits(Load$1, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow;
    if (this._pending) {
      return output(this, pulse2, this._pending);
    }
    if (stop(_)) return pulse2.StopPropagation;
    if (_.values) {
      return output(this, pulse2, df.parse(_.values, _.format));
    } else if (_.async) {
      const p = df.request(_.url, _.format).then((res) => {
        this._pending = array$5(res.data);
        return (df2) => df2.touch(this);
      });
      return {
        async: p
      };
    } else {
      return df.request(_.url, _.format).then((res) => output(this, pulse2, array$5(res.data)));
    }
  }
});
function stop(_) {
  return _.modified("async") && !(_.modified("values") || _.modified("url") || _.modified("format"));
}
function output(op, pulse2, data2) {
  data2.forEach(ingest$1);
  const out = pulse2.fork(pulse2.NO_FIELDS & pulse2.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data2;
  op._pending = null;
  if (out.rem.length) out.clean(true);
  return out;
}
function Lookup(params2) {
  Transform.call(this, {}, params2);
}
Lookup.Definition = {
  "type": "Lookup",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "index",
    "type": "index",
    "params": [{
      "name": "from",
      "type": "data",
      "required": true
    }, {
      "name": "key",
      "type": "field",
      "required": true
    }]
  }, {
    "name": "values",
    "type": "field",
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }, {
    "name": "default",
    "default": null
  }]
};
inherits(Lookup, Transform, {
  transform(_, pulse2) {
    const keys2 = _.fields, index2 = _.index, values2 = _.values, defaultValue = _.default == null ? null : _.default, reset3 = _.modified(), n = keys2.length;
    let flag2 = reset3 ? pulse2.SOURCE : pulse2.ADD, out = pulse2, as = _.as, set2, m2, mods;
    if (values2) {
      m2 = values2.length;
      if (n > 1 && !as) {
        error('Multi-field lookup requires explicit "as" parameter.');
      }
      if (as && as.length !== n * m2) {
        error('The "as" parameter has too few output field names.');
      }
      as = as || values2.map(accessorName);
      set2 = function(t4) {
        for (var i = 0, k = 0, j, v; i < n; ++i) {
          v = index2.get(keys2[i](t4));
          if (v == null) for (j = 0; j < m2; ++j, ++k) t4[as[k]] = defaultValue;
          else for (j = 0; j < m2; ++j, ++k) t4[as[k]] = values2[j](v);
        }
      };
    } else {
      if (!as) {
        error("Missing output field names.");
      }
      set2 = function(t4) {
        for (var i = 0, v; i < n; ++i) {
          v = index2.get(keys2[i](t4));
          t4[as[i]] = v == null ? defaultValue : v;
        }
      };
    }
    if (reset3) {
      out = pulse2.reflow(true);
    } else {
      mods = keys2.some((k) => pulse2.modified(k.fields));
      flag2 |= mods ? pulse2.MOD : 0;
    }
    pulse2.visit(flag2, set2);
    return out.modifies(as);
  }
});
function MultiExtent$1(params2) {
  Operator.call(this, null, update$1, params2);
}
inherits(MultiExtent$1, Operator);
function update$1(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }
  const ext = _.extents, n = ext.length;
  let min2 = Infinity, max2 = -Infinity, i, e3;
  for (i = 0; i < n; ++i) {
    e3 = ext[i];
    if (e3[0] < min2) min2 = e3[0];
    if (e3[1] > max2) max2 = e3[1];
  }
  return [min2, max2];
}
function MultiValues$1(params2) {
  Operator.call(this, null, update$6, params2);
}
inherits(MultiValues$1, Operator);
function update$6(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data2, _2) => data2.concat(_2), []);
}
function Params$2(params2) {
  Transform.call(this, null, params2);
}
inherits(Params$2, Transform, {
  transform(_, pulse2) {
    this.modified(_.modified());
    this.value = _;
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function Pivot(params2) {
  Aggregate$1.call(this, params2);
}
Pivot.Definition = {
  "type": "Pivot",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "value",
    "type": "field",
    "required": true
  }, {
    "name": "op",
    "type": "enum",
    "values": ValidAggregateOps,
    "default": "sum"
  }, {
    "name": "limit",
    "type": "number",
    "default": 0
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(Pivot, Aggregate$1, {
  _transform: Aggregate$1.prototype.transform,
  transform(_, pulse2) {
    return this._transform(aggregateParams(_, pulse2), pulse2);
  }
});
function aggregateParams(_, pulse2) {
  const key2 = _.field, value2 = _.value, op = (_.op === "count" ? "__count__" : _.op) || "sum", fields = accessorFields(key2).concat(accessorFields(value2)), keys2 = pivotKeys(key2, _.limit || 0, pulse2);
  if (pulse2.changed()) _.set("__pivot__", null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys2.map(() => op),
    fields: keys2.map((k) => get$5(k, key2, value2, fields)),
    as: keys2.map((k) => k + ""),
    modified: _.modified.bind(_)
  };
}
function get$5(k, key2, value2, fields) {
  return accessor((d) => key2(d) === k ? value2(d) : NaN, fields, k + "");
}
function pivotKeys(key2, limit, pulse2) {
  const map2 = {}, list = [];
  pulse2.visit(pulse2.SOURCE, (t4) => {
    const k = key2(t4);
    if (!map2[k]) {
      map2[k] = 1;
      list.push(k);
    }
  });
  list.sort(ascending$3);
  return limit ? list.slice(0, limit) : list;
}
function PreFacet$1(params2) {
  Facet$1.call(this, params2);
}
inherits(PreFacet$1, Facet$1, {
  transform(_, pulse2) {
    const flow = _.subflow, field2 = _.field, subflow = (t4) => this.subflow(tupleid(t4), flow, pulse2, t4);
    if (_.modified("field") || field2 && pulse2.modified(accessorFields(field2))) {
      error("PreFacet does not support field modification.");
    }
    this.initTargets();
    if (field2) {
      pulse2.visit(pulse2.MOD, (t4) => {
        const sf = subflow(t4);
        field2(t4).forEach((_2) => sf.mod(_2));
      });
      pulse2.visit(pulse2.ADD, (t4) => {
        const sf = subflow(t4);
        field2(t4).forEach((_2) => sf.add(ingest$1(_2)));
      });
      pulse2.visit(pulse2.REM, (t4) => {
        const sf = subflow(t4);
        field2(t4).forEach((_2) => sf.rem(_2));
      });
    } else {
      pulse2.visit(pulse2.MOD, (t4) => subflow(t4).mod(t4));
      pulse2.visit(pulse2.ADD, (t4) => subflow(t4).add(t4));
      pulse2.visit(pulse2.REM, (t4) => subflow(t4).rem(t4));
    }
    if (pulse2.clean()) {
      pulse2.runAfter(() => this.clean());
    }
    return pulse2;
  }
});
function Project(params2) {
  Transform.call(this, null, params2);
}
Project.Definition = {
  "type": "Project",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }]
};
inherits(Project, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(_.fields, _.as || []), derive2 = fields ? (s, t4) => project$1(s, t4, fields, as) : rederive;
    let lut;
    if (this.value) {
      lut = this.value;
    } else {
      pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    pulse2.visit(pulse2.REM, (t4) => {
      const id2 = tupleid(t4);
      out.rem.push(lut[id2]);
      lut[id2] = null;
    });
    pulse2.visit(pulse2.ADD, (t4) => {
      const dt = derive2(t4, ingest$1({}));
      lut[tupleid(t4)] = dt;
      out.add.push(dt);
    });
    pulse2.visit(pulse2.MOD, (t4) => {
      out.mod.push(derive2(t4, lut[tupleid(t4)]));
    });
    return out;
  }
});
function project$1(s, t4, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t4[as[i]] = fields[i](s);
  }
  return t4;
}
function Proxy$2(params2) {
  Transform.call(this, null, params2);
}
inherits(Proxy$2, Transform, {
  transform(_, pulse2) {
    this.value = _.value;
    return _.modified("value") ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function Quantile$1(params2) {
  Transform.call(this, null, params2);
}
Quantile$1.Definition = {
  "type": "Quantile",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "probs",
    "type": "number",
    "array": true
  }, {
    "name": "step",
    "type": "number",
    "default": 0.01
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["prob", "value"]
  }]
};
const EPSILON$2 = 1e-14;
inherits(Quantile$1, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), as = _.as || ["prob", "value"];
    if (this.value && !_.modified() && !pulse2.changed()) {
      out.source = this.value;
      return out;
    }
    const source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1$1(source2, _.groupby, _.field), names = (_.groupby || []).map(accessorName), values2 = [], step = _.step || 0.01, p = _.probs || range$6(step / 2, 1 - EPSILON$2, step), n = p.length;
    groups.forEach((g) => {
      const q = quantiles(g, p);
      for (let i = 0; i < n; ++i) {
        const t4 = {};
        for (let i2 = 0; i2 < names.length; ++i2) {
          t4[names[i2]] = g.dims[i2];
        }
        t4[as[0]] = p[i];
        t4[as[1]] = q[i];
        values2.push(ingest$1(t4));
      }
    });
    if (this.value) out.rem = this.value;
    this.value = out.add = out.source = values2;
    return out;
  }
});
function Relay$1(params2) {
  Transform.call(this, null, params2);
}
inherits(Relay$1, Transform, {
  transform(_, pulse2) {
    let out, lut;
    if (this.value) {
      lut = this.value;
    } else {
      out = pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    if (_.derive) {
      out = pulse2.fork(pulse2.NO_SOURCE);
      pulse2.visit(pulse2.REM, (t4) => {
        const id2 = tupleid(t4);
        out.rem.push(lut[id2]);
        lut[id2] = null;
      });
      pulse2.visit(pulse2.ADD, (t4) => {
        const dt = derive(t4);
        lut[tupleid(t4)] = dt;
        out.add.push(dt);
      });
      pulse2.visit(pulse2.MOD, (t4) => {
        const dt = lut[tupleid(t4)];
        for (const k in t4) {
          dt[k] = t4[k];
          out.modifies(k);
        }
        out.mod.push(dt);
      });
    }
    return out;
  }
});
function Sample(params2) {
  Transform.call(this, [], params2);
  this.count = 0;
}
Sample.Definition = {
  "type": "Sample",
  "metadata": {},
  "params": [{
    "name": "size",
    "type": "number",
    "default": 1e3
  }]
};
inherits(Sample, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), mod = _.modified("size"), num = _.size, map2 = this.value.reduce((m2, t4) => (m2[tupleid(t4)] = 1, m2), {});
    let res = this.value, cnt = this.count, cap = 0;
    function update2(t4) {
      let p, idx;
      if (res.length < num) {
        res.push(t4);
      } else {
        idx = ~~((cnt + 1) * random());
        if (idx < res.length && idx >= cap) {
          p = res[idx];
          if (map2[tupleid(p)]) out.rem.push(p);
          res[idx] = t4;
        }
      }
      ++cnt;
    }
    if (pulse2.rem.length) {
      pulse2.visit(pulse2.REM, (t4) => {
        const id2 = tupleid(t4);
        if (map2[id2]) {
          map2[id2] = -1;
          out.rem.push(t4);
        }
        --cnt;
      });
      res = res.filter((t4) => map2[tupleid(t4)] !== -1);
    }
    if ((pulse2.rem.length || mod) && res.length < num && pulse2.source) {
      cap = cnt = res.length;
      pulse2.visit(pulse2.SOURCE, (t4) => {
        if (!map2[tupleid(t4)]) update2(t4);
      });
      cap = -1;
    }
    if (mod && res.length > num) {
      const n = res.length - num;
      for (let i = 0; i < n; ++i) {
        map2[tupleid(res[i])] = -1;
        out.rem.push(res[i]);
      }
      res = res.slice(n);
    }
    if (pulse2.mod.length) {
      pulse2.visit(pulse2.MOD, (t4) => {
        if (map2[tupleid(t4)]) out.mod.push(t4);
      });
    }
    if (pulse2.add.length) {
      pulse2.visit(pulse2.ADD, update2);
    }
    if (pulse2.add.length || cap < 0) {
      out.add = res.filter((t4) => !map2[tupleid(t4)]);
    }
    this.count = cnt;
    this.value = out.source = res;
    return out;
  }
});
function Sequence(params2) {
  Transform.call(this, null, params2);
}
Sequence.Definition = {
  "type": "Sequence",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "start",
    "type": "number",
    "required": true
  }, {
    "name": "stop",
    "type": "number",
    "required": true
  }, {
    "name": "step",
    "type": "number",
    "default": 1
  }, {
    "name": "as",
    "type": "string",
    "default": "data"
  }]
};
inherits(Sequence, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified()) return;
    const out = pulse2.materialize().fork(pulse2.MOD), as = _.as || "data";
    out.rem = this.value ? pulse2.rem.concat(this.value) : pulse2.rem;
    this.value = range$6(_.start, _.stop, _.step || 1).map((v) => {
      const t4 = {};
      t4[as] = v;
      return ingest$1(t4);
    });
    out.add = pulse2.add.concat(this.value);
    return out;
  }
});
function Sieve$1(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Sieve$1, Transform, {
  transform(_, pulse2) {
    this.value = pulse2.source;
    return pulse2.changed() ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function TimeUnit(params2) {
  Transform.call(this, null, params2);
}
const OUTPUT = ["unit0", "unit1"];
TimeUnit.Definition = {
  "type": "TimeUnit",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "interval",
    "type": "boolean",
    "default": true
  }, {
    "name": "units",
    "type": "enum",
    "values": TIME_UNITS,
    "array": true
  }, {
    "name": "step",
    "type": "number",
    "default": 1
  }, {
    "name": "maxbins",
    "type": "number",
    "default": 40
  }, {
    "name": "extent",
    "type": "date",
    "array": true
  }, {
    "name": "timezone",
    "type": "enum",
    "default": "local",
    "values": ["local", "utc"]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": OUTPUT
  }]
};
inherits(TimeUnit, Transform, {
  transform(_, pulse2) {
    const field2 = _.field, band2 = _.interval !== false, utc = _.timezone === "utc", floor2 = this._floor(_, pulse2), offset2 = (utc ? utcInterval : timeInterval)(floor2.unit).offset, as = _.as || OUTPUT, u0 = as[0], u1 = as[1], step = floor2.step;
    let min2 = floor2.start || Infinity, max2 = floor2.stop || -Infinity, flag2 = pulse2.ADD;
    if (_.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(field2))) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
      min2 = Infinity;
      max2 = -Infinity;
    }
    pulse2.visit(flag2, (t4) => {
      const v = field2(t4);
      let a2, b2;
      if (v == null) {
        t4[u0] = null;
        if (band2) t4[u1] = null;
      } else {
        t4[u0] = a2 = b2 = floor2(v);
        if (band2) t4[u1] = b2 = offset2(a2, step);
        if (a2 < min2) min2 = a2;
        if (b2 > max2) max2 = b2;
      }
    });
    floor2.start = min2;
    floor2.stop = max2;
    return pulse2.modifies(band2 ? as : u0);
  },
  _floor(_, pulse2) {
    const utc = _.timezone === "utc";
    const {
      units,
      step
    } = _.units ? {
      units: _.units,
      step: _.step || 1
    } : bin$1({
      extent: _.extent || extent(pulse2.materialize(pulse2.SOURCE).source, _.field),
      maxbins: _.maxbins
    });
    const tunits = timeUnits(units), prev2 = this.value || {}, floor2 = (utc ? utcFloor : timeFloor)(tunits, step);
    floor2.unit = peek$2(tunits);
    floor2.units = tunits;
    floor2.step = step;
    floor2.start = prev2.start;
    floor2.stop = prev2.stop;
    return this.value = floor2;
  }
});
function TupleIndex(params2) {
  Transform.call(this, fastmap(), params2);
}
inherits(TupleIndex, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, field2 = _.field, index2 = this.value, set2 = (t4) => index2.set(field2(t4), t4);
    let mod = true;
    if (_.modified("field") || pulse2.modified(field2.fields)) {
      index2.clear();
      pulse2.visit(pulse2.SOURCE, set2);
    } else if (pulse2.changed()) {
      pulse2.visit(pulse2.REM, (t4) => index2.delete(field2(t4)));
      pulse2.visit(pulse2.ADD, set2);
    } else {
      mod = false;
    }
    this.modified(mod);
    if (index2.empty > df.cleanThreshold) df.runAfter(index2.clean);
    return pulse2.fork();
  }
});
function Values$1(params2) {
  Transform.call(this, null, params2);
}
inherits(Values$1, Transform, {
  transform(_, pulse2) {
    const run2 = !this.value || _.modified("field") || _.modified("sort") || pulse2.changed() || _.sort && pulse2.modified(_.sort.fields);
    if (run2) {
      this.value = (_.sort ? pulse2.source.slice().sort(stableCompare(_.sort)) : pulse2.source).map(_.field);
    }
  }
});
function WindowOp(op, field2, param2, as) {
  const fn = WindowOps[op](field2, param2);
  return {
    init: fn.init || zero$5,
    update: function(w2, t4) {
      t4[as] = fn.next(w2);
    }
  };
}
const WindowOps = {
  row_number: function() {
    return {
      next: (w2) => w2.index + 1
    };
  },
  rank: function() {
    let rank2;
    return {
      init: () => rank2 = 1,
      next: (w2) => {
        const i = w2.index, data2 = w2.data;
        return i && w2.compare(data2[i - 1], data2[i]) ? rank2 = i + 1 : rank2;
      }
    };
  },
  dense_rank: function() {
    let drank;
    return {
      init: () => drank = 1,
      next: (w2) => {
        const i = w2.index, d = w2.data;
        return i && w2.compare(d[i - 1], d[i]) ? ++drank : drank;
      }
    };
  },
  percent_rank: function() {
    const rank2 = WindowOps.rank(), next2 = rank2.next;
    return {
      init: rank2.init,
      next: (w2) => (next2(w2) - 1) / (w2.data.length - 1)
    };
  },
  cume_dist: function() {
    let cume;
    return {
      init: () => cume = 0,
      next: (w2) => {
        const d = w2.data, c2 = w2.compare;
        let i = w2.index;
        if (cume < i) {
          while (i + 1 < d.length && !c2(d[i], d[i + 1])) ++i;
          cume = i;
        }
        return (1 + cume) / d.length;
      }
    };
  },
  ntile: function(field2, num) {
    num = +num;
    if (!(num > 0)) error("ntile num must be greater than zero.");
    const cume = WindowOps.cume_dist(), next2 = cume.next;
    return {
      init: cume.init,
      next: (w2) => Math.ceil(num * next2(w2))
    };
  },
  lag: function(field2, offset2) {
    offset2 = +offset2 || 1;
    return {
      next: (w2) => {
        const i = w2.index - offset2;
        return i >= 0 ? field2(w2.data[i]) : null;
      }
    };
  },
  lead: function(field2, offset2) {
    offset2 = +offset2 || 1;
    return {
      next: (w2) => {
        const i = w2.index + offset2, d = w2.data;
        return i < d.length ? field2(d[i]) : null;
      }
    };
  },
  first_value: function(field2) {
    return {
      next: (w2) => field2(w2.data[w2.i0])
    };
  },
  last_value: function(field2) {
    return {
      next: (w2) => field2(w2.data[w2.i1 - 1])
    };
  },
  nth_value: function(field2, nth) {
    nth = +nth;
    if (!(nth > 0)) error("nth_value nth must be greater than zero.");
    return {
      next: (w2) => {
        const i = w2.i0 + (nth - 1);
        return i < w2.i1 ? field2(w2.data[i]) : null;
      }
    };
  },
  prev_value: function(field2) {
    let prev2;
    return {
      init: () => prev2 = null,
      next: (w2) => {
        const v = field2(w2.data[w2.index]);
        return v != null ? prev2 = v : prev2;
      }
    };
  },
  next_value: function(field2) {
    let v, i;
    return {
      init: () => (v = null, i = -1),
      next: (w2) => {
        const d = w2.data;
        return w2.index <= i ? v : (i = find$3(field2, d, w2.index)) < 0 ? (i = d.length, v = null) : v = field2(d[i]);
      }
    };
  }
};
function find$3(field2, data2, index2) {
  for (let n = data2.length; index2 < n; ++index2) {
    const v = field2(data2[index2]);
    if (v != null) return index2;
  }
  return -1;
}
const ValidWindowOps = Object.keys(WindowOps);
function WindowState(_) {
  const ops2 = array$5(_.ops), fields = array$5(_.fields), params2 = array$5(_.params), as = array$5(_.as), outputs = this.outputs = [], windows = this.windows = [], inputs = {}, map2 = {}, counts = [], measures = [];
  let countOnly = true;
  function visitInputs(f) {
    array$5(accessorFields(f)).forEach((_2) => inputs[_2] = 1);
  }
  visitInputs(_.sort);
  ops2.forEach((op, i) => {
    const field2 = fields[i], mname = accessorName(field2), name = measureName(op, mname, as[i]);
    visitInputs(field2);
    outputs.push(name);
    if (has$2(WindowOps, op)) {
      windows.push(WindowOp(op, fields[i], params2[i], name));
    } else {
      if (field2 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      if (op === "count") {
        counts.push(name);
        return;
      }
      countOnly = false;
      let m2 = map2[mname];
      if (!m2) {
        m2 = map2[mname] = [];
        m2.field = field2;
        measures.push(m2);
      }
      m2.push(createMeasure(op, name));
    }
  });
  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }
  this.inputs = Object.keys(inputs);
}
const prototype = WindowState.prototype;
prototype.init = function() {
  this.windows.forEach((_) => _.init());
  if (this.cell) this.cell.init();
};
prototype.update = function(w2, t4) {
  const cell2 = this.cell, wind = this.windows, data2 = w2.data, m2 = wind && wind.length;
  let j;
  if (cell2) {
    for (j = w2.p0; j < w2.i0; ++j) cell2.rem(data2[j]);
    for (j = w2.p1; j < w2.i1; ++j) cell2.add(data2[j]);
    cell2.set(t4);
  }
  for (j = 0; j < m2; ++j) wind[j].update(w2, t4);
};
function cell(measures, counts, countOnly) {
  measures = measures.map((m2) => compileMeasures(m2, m2.field));
  const cell2 = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };
  if (!countOnly) {
    var n = measures.length, a2 = cell2.agg = Array(n), i = 0;
    for (; i < n; ++i) a2[i] = new measures[i](cell2);
  }
  if (cell2.store) {
    var store = cell2.data = new TupleStore();
  }
  cell2.add = function(t4) {
    cell2.num += 1;
    if (countOnly) return;
    if (store) store.add(t4);
    for (let i2 = 0; i2 < n; ++i2) {
      a2[i2].add(a2[i2].get(t4), t4);
    }
  };
  cell2.rem = function(t4) {
    cell2.num -= 1;
    if (countOnly) return;
    if (store) store.rem(t4);
    for (let i2 = 0; i2 < n; ++i2) {
      a2[i2].rem(a2[i2].get(t4), t4);
    }
  };
  cell2.set = function(t4) {
    let i2, n2;
    if (store) store.values();
    for (i2 = 0, n2 = counts.length; i2 < n2; ++i2) t4[counts[i2]] = cell2.num;
    if (!countOnly) for (i2 = 0, n2 = a2.length; i2 < n2; ++i2) a2[i2].set(t4);
  };
  cell2.init = function() {
    cell2.num = 0;
    if (store) store.reset();
    for (let i2 = 0; i2 < n; ++i2) a2[i2].init();
  };
  return cell2;
}
function Window(params2) {
  Transform.call(this, {}, params2);
  this._mlen = 0;
  this._mods = [];
}
Window.Definition = {
  "type": "Window",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "sort",
    "type": "compare"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidWindowOps.concat(ValidAggregateOps)
  }, {
    "name": "params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "frame",
    "type": "number",
    "null": true,
    "array": true,
    "length": 2,
    "default": [null, 0]
  }, {
    "name": "ignorePeers",
    "type": "boolean",
    "default": false
  }]
};
inherits(Window, Transform, {
  transform(_, pulse2) {
    this.stamp = pulse2.stamp;
    const mod = _.modified(), cmp2 = stableCompare(_.sort), key2 = groupkey(_.groupby), group2 = (t4) => this.group(key2(t4));
    let state = this.state;
    if (!state || mod) {
      state = this.state = new WindowState(_);
    }
    if (mod || pulse2.modified(state.inputs)) {
      this.value = {};
      pulse2.visit(pulse2.SOURCE, (t4) => group2(t4).add(t4));
    } else {
      pulse2.visit(pulse2.REM, (t4) => group2(t4).remove(t4));
      pulse2.visit(pulse2.ADD, (t4) => group2(t4).add(t4));
    }
    for (let i = 0, n = this._mlen; i < n; ++i) {
      processPartition(this._mods[i], state, cmp2, _);
    }
    this._mlen = 0;
    this._mods = [];
    return pulse2.reflow(mod).modifies(state.outputs);
  },
  group(key2) {
    let group2 = this.value[key2];
    if (!group2) {
      group2 = this.value[key2] = SortedList(tupleid);
      group2.stamp = -1;
    }
    if (group2.stamp < this.stamp) {
      group2.stamp = this.stamp;
      this._mods[this._mlen++] = group2;
    }
    return group2;
  }
});
function processPartition(list, state, cmp2, _) {
  const sort2 = _.sort, range2 = sort2 && !_.ignorePeers, frame2 = _.frame || [null, 0], data2 = list.data(cmp2), n = data2.length, b2 = range2 ? bisector$1(sort2) : null, w2 = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: data2,
    compare: sort2 || constant$5(-1)
  };
  state.init();
  for (let i = 0; i < n; ++i) {
    setWindow(w2, frame2, i, n);
    if (range2) adjustRange(w2, b2);
    state.update(w2, data2[i]);
  }
}
function setWindow(w2, f, i, n) {
  w2.p0 = w2.i0;
  w2.p1 = w2.i1;
  w2.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w2.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w2.index = i;
}
function adjustRange(w2, bisect2) {
  const r0 = w2.i0, r1 = w2.i1 - 1, c2 = w2.compare, d = w2.data, n = d.length - 1;
  if (r0 > 0 && !c2(d[r0], d[r0 - 1])) w2.i0 = bisect2.left(d, d[r0]);
  if (r1 < n && !c2(d[r1], d[r1 + 1])) w2.i1 = bisect2.right(d, d[r1]);
}
const tx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aggregate: Aggregate$1,
  bin: Bin,
  collect: Collect$1,
  compare: Compare$1,
  countpattern: CountPattern,
  cross: Cross,
  density: Density,
  dotbin: DotBin,
  expression: Expression$1,
  extent: Extent,
  facet: Facet$1,
  field: Field$1,
  filter: Filter,
  flatten: Flatten,
  fold: Fold,
  formula: Formula,
  generate: Generate,
  impute: Impute,
  joinaggregate: JoinAggregate,
  kde: KDE,
  key: Key$1,
  load: Load$1,
  lookup: Lookup,
  multiextent: MultiExtent$1,
  multivalues: MultiValues$1,
  params: Params$2,
  pivot: Pivot,
  prefacet: PreFacet$1,
  project: Project,
  proxy: Proxy$2,
  quantile: Quantile$1,
  relay: Relay$1,
  sample: Sample,
  sequence: Sequence,
  sieve: Sieve$1,
  subflow: Subflow,
  timeunit: TimeUnit,
  tupleindex: TupleIndex,
  values: Values$1,
  window: Window
}, Symbol.toStringTag, { value: "Module" }));
function constant$4(x2) {
  return function constant2() {
    return x2;
  };
}
const abs$3 = Math.abs;
const atan2$1 = Math.atan2;
const cos$2 = Math.cos;
const max$1 = Math.max;
const min$1 = Math.min;
const sin$2 = Math.sin;
const sqrt$3 = Math.sqrt;
const epsilon$5 = 1e-12;
const pi$3 = Math.PI;
const halfPi$2 = pi$3 / 2;
const tau$3 = 2 * pi$3;
function acos$1(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi$3 : Math.acos(x2);
}
function asin$2(x2) {
  return x2 >= 1 ? halfPi$2 : x2 <= -1 ? -halfPi$2 : Math.asin(x2);
}
const pi$2 = Math.PI, tau$2 = 2 * pi$2, epsilon$4 = 1e-6, tauEpsilon = tau$2 - epsilon$4;
function append$1(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append$1;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}
let Path$1 = class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append$1 : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x12, y12, x2, y2) {
    this._append`Q${+x12},${+y12},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x12, y12, x2, y2, x3, y3) {
    this._append`C${+x12},${+y12},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x12, y12, x2, y2, r2) {
    x12 = +x12, y12 = +y12, x2 = +x2, y2 = +y2, r2 = +r2;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x02 = this._x1, y02 = this._y1, x21 = x2 - x12, y21 = y2 - y12, x01 = x02 - x12, y01 = y02 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon$4)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$4) || !r2) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x2 - x02, y20 = y2 - y02, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon$4) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x2, y2, r2, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x02 = x2 + dx, y02 = y2 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x02},${y02}`;
    } else if (Math.abs(this._x1 - x02) > epsilon$4 || Math.abs(this._y1 - y02) > epsilon$4) {
      this._append`L${x02},${y02}`;
    }
    if (!r2) return;
    if (da < 0) da = da % tau$2 + tau$2;
    if (da > tauEpsilon) {
      this._append`A${r2},${r2},0,1,${cw2},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw2},${this._x1 = x02},${this._y1 = y02}`;
    } else if (da > epsilon$4) {
      this._append`A${r2},${r2},0,${+(da >= pi$2)},${cw2},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w2, h2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w2 = +w2}v${+h2}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
};
function path$3() {
  return new Path$1();
}
path$3.prototype = Path$1.prototype;
function withPath(shape2) {
  let digits = 3;
  shape2.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape2;
  };
  return () => new Path$1(digits);
}
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect$3(x02, y02, x12, y12, x2, y2, x3, y3) {
  var x10 = x12 - x02, y10 = y12 - y02, x32 = x3 - x2, y32 = y3 - y2, t4 = y32 * x10 - x32 * y10;
  if (t4 * t4 < epsilon$5) return;
  t4 = (x32 * (y02 - y2) - y32 * (x02 - x2)) / t4;
  return [x02 + t4 * x10, y02 + t4 * y10];
}
function cornerTangents(x02, y02, x12, y12, r1, rc, cw2) {
  var x01 = x02 - x12, y01 = y02 - y12, lo = (cw2 ? rc : -rc) / sqrt$3(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x02 + ox, y11 = y02 + oy, x10 = x12 + ox, y10 = y12 + oy, x002 = (x11 + x10) / 2, y002 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r2 = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt$3(max$1(0, r2 * r2 * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x002, dy0 = cy0 - y002, dx1 = cx1 - x002, dy1 = cy1 - y002;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function arc$2$1() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$4(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context2 = null, path2 = withPath(arc2);
  function arc2() {
    var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi$2, a1 = endAngle.apply(this, arguments) - halfPi$2, da = abs$3(a1 - a0), cw2 = a1 > a0;
    if (!context2) context2 = buffer = path2();
    if (r1 < r0) r2 = r1, r1 = r0, r0 = r2;
    if (!(r1 > epsilon$5)) context2.moveTo(0, 0);
    else if (da > tau$3 - epsilon$5) {
      context2.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));
      context2.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon$5) {
        context2.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));
        context2.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$5 && (padRadius ? +padRadius.apply(this, arguments) : sqrt$3(r0 * r0 + r1 * r1)), rc = min$1(abs$3(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon$5) {
        var p02 = asin$2(rp / r0 * sin$2(ap)), p1 = asin$2(rp / r1 * sin$2(ap));
        if ((da0 -= p02 * 2) > epsilon$5) p02 *= cw2 ? 1 : -1, a00 += p02, a10 -= p02;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$5) p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos$2(a01), y01 = r1 * sin$2(a01), x10 = r0 * cos$2(a10), y10 = r0 * sin$2(a10);
      if (rc > epsilon$5) {
        var x11 = r1 * cos$2(a11), y11 = r1 * sin$2(a11), x002 = r0 * cos$2(a00), y002 = r0 * sin$2(a00), oc;
        if (da < pi$3) {
          if (oc = intersect$3(x01, y01, x002, y002, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$3(ax * ax + ay * ay) * sqrt$3(bx * bx + by * by))) / 2), lc = sqrt$3(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min$1(rc, (r0 - lc) / (kc - 1));
            rc1 = min$1(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon$5)) context2.moveTo(x01, y01);
      else if (rc1 > epsilon$5) {
        t02 = cornerTangents(x002, y002, x01, y01, r1, rc1, cw2);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context2.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc) context2.arc(t02.cx, t02.cy, rc1, atan2$1(t02.y01, t02.x01), atan2$1(t12.y01, t12.x01), !cw2);
        else {
          context2.arc(t02.cx, t02.cy, rc1, atan2$1(t02.y01, t02.x01), atan2$1(t02.y11, t02.x11), !cw2);
          context2.arc(0, 0, r1, atan2$1(t02.cy + t02.y11, t02.cx + t02.x11), atan2$1(t12.cy + t12.y11, t12.cx + t12.x11), !cw2);
          context2.arc(t12.cx, t12.cy, rc1, atan2$1(t12.y11, t12.x11), atan2$1(t12.y01, t12.x01), !cw2);
        }
      } else context2.moveTo(x01, y01), context2.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon$5) || !(da0 > epsilon$5)) context2.lineTo(x10, y10);
      else if (rc0 > epsilon$5) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t12 = cornerTangents(x01, y01, x002, y002, r0, -rc0, cw2);
        context2.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc) context2.arc(t02.cx, t02.cy, rc0, atan2$1(t02.y01, t02.x01), atan2$1(t12.y01, t12.x01), !cw2);
        else {
          context2.arc(t02.cx, t02.cy, rc0, atan2$1(t02.y01, t02.x01), atan2$1(t02.y11, t02.x11), !cw2);
          context2.arc(0, 0, r0, atan2$1(t02.cy + t02.y11, t02.cx + t02.x11), atan2$1(t12.cy + t12.y11, t12.cx + t12.x11), cw2);
          context2.arc(t12.cx, t12.cy, rc0, atan2$1(t12.y11, t12.x11), atan2$1(t12.y01, t12.x01), !cw2);
        }
      } else context2.arc(0, 0, r0, a10, a00, cw2);
    }
    context2.closePath();
    if (buffer) return context2 = null, buffer + "" || null;
  }
  arc2.centroid = function() {
    var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$3 / 2;
    return [cos$2(a2) * r2, sin$2(a2) * r2];
  };
  arc2.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$4(+_), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$4(+_), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$4(+_), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), arc2) : padRadius;
  };
  arc2.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$4(+_), arc2) : startAngle;
  };
  arc2.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$4(+_), arc2) : endAngle;
  };
  arc2.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$4(+_), arc2) : padAngle;
  };
  arc2.context = function(_) {
    return arguments.length ? (context2 = _ == null ? null : _, arc2) : context2;
  };
  return arc2;
}
function array$4(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear$1(context2) {
  this._context = context2;
}
Linear$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context2) {
  return new Linear$1(context2);
}
function x$3(p) {
  return p[0];
}
function y$3(p) {
  return p[1];
}
function line$2$1(x2, y2) {
  var defined2 = constant$4(true), context2 = null, curve2 = curveLinear, output2 = null, path2 = withPath(line2);
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x$3 : constant$4(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y$3 : constant$4(y2);
  function line2(data2) {
    var i, n = (data2 = array$4(data2)).length, d, defined0 = false, buffer;
    if (context2 == null) output2 = curve2(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0) output2.lineStart();
        else output2.lineEnd();
      }
      if (defined0) output2.point(+x2(d, i, data2), +y2(d, i, data2));
    }
    if (buffer) return output2 = null, buffer + "" || null;
  }
  line2.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant$4(+_), line2) : x2;
  };
  line2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant$4(+_), line2) : y2;
  };
  line2.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant$4(!!_), line2) : defined2;
  };
  line2.curve = function(_) {
    return arguments.length ? (curve2 = _, context2 != null && (output2 = curve2(context2)), line2) : curve2;
  };
  line2.context = function(_) {
    return arguments.length ? (_ == null ? context2 = output2 = null : output2 = curve2(context2 = _), line2) : context2;
  };
  return line2;
}
function area$2$1(x02, y02, y12) {
  var x12 = null, defined2 = constant$4(true), context2 = null, curve2 = curveLinear, output2 = null, path2 = withPath(area2);
  x02 = typeof x02 === "function" ? x02 : x02 === void 0 ? x$3 : constant$4(+x02);
  y02 = typeof y02 === "function" ? y02 : y02 === void 0 ? constant$4(0) : constant$4(+y02);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y$3 : constant$4(+y12);
  function area2(data2) {
    var i, j, k, n = (data2 = array$4(data2)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context2 == null) output2 = curve2(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output2.areaStart();
          output2.lineStart();
        } else {
          output2.lineEnd();
          output2.lineStart();
          for (k = i - 1; k >= j; --k) {
            output2.point(x0z[k], y0z[k]);
          }
          output2.lineEnd();
          output2.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x02(d, i, data2), y0z[i] = +y02(d, i, data2);
        output2.point(x12 ? +x12(d, i, data2) : x0z[i], y12 ? +y12(d, i, data2) : y0z[i]);
      }
    }
    if (buffer) return output2 = null, buffer + "" || null;
  }
  function arealine() {
    return line$2$1().defined(defined2).curve(curve2).context(context2);
  }
  area2.x = function(_) {
    return arguments.length ? (x02 = typeof _ === "function" ? _ : constant$4(+_), x12 = null, area2) : x02;
  };
  area2.x0 = function(_) {
    return arguments.length ? (x02 = typeof _ === "function" ? _ : constant$4(+_), area2) : x02;
  };
  area2.x1 = function(_) {
    return arguments.length ? (x12 = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), area2) : x12;
  };
  area2.y = function(_) {
    return arguments.length ? (y02 = typeof _ === "function" ? _ : constant$4(+_), y12 = null, area2) : y02;
  };
  area2.y0 = function(_) {
    return arguments.length ? (y02 = typeof _ === "function" ? _ : constant$4(+_), area2) : y02;
  };
  area2.y1 = function(_) {
    return arguments.length ? (y12 = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), area2) : y12;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x02).y(y02);
  };
  area2.lineY1 = function() {
    return arealine().x(x02).y(y12);
  };
  area2.lineX1 = function() {
    return arealine().x(x12).y(y02);
  };
  area2.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant$4(!!_), area2) : defined2;
  };
  area2.curve = function(_) {
    return arguments.length ? (curve2 = _, context2 != null && (output2 = curve2(context2)), area2) : curve2;
  };
  area2.context = function(_) {
    return arguments.length ? (_ == null ? context2 = output2 = null : output2 = curve2(context2 = _), area2) : context2;
  };
  return area2;
}
const circle$2 = {
  draw(context2, size) {
    const r2 = sqrt$3(size / pi$3);
    context2.moveTo(r2, 0);
    context2.arc(0, 0, r2, 0, tau$3);
  }
};
function Symbol$2(type2, size) {
  let context2 = null, path2 = withPath(symbol2);
  type2 = typeof type2 === "function" ? type2 : constant$4(type2 || circle$2);
  size = typeof size === "function" ? size : constant$4(size === void 0 ? 64 : +size);
  function symbol2() {
    let buffer;
    if (!context2) context2 = buffer = path2();
    type2.apply(this, arguments).draw(context2, +size.apply(this, arguments));
    if (buffer) return context2 = null, buffer + "" || null;
  }
  symbol2.type = function(_) {
    return arguments.length ? (type2 = typeof _ === "function" ? _ : constant$4(_), symbol2) : type2;
  };
  symbol2.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$4(+_), symbol2) : size;
  };
  symbol2.context = function(_) {
    return arguments.length ? (context2 = _ == null ? null : _, symbol2) : context2;
  };
  return symbol2;
}
function noop$3() {
}
function point$7(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context2) {
  this._context = context2;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$7(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        point$7(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasis(context2) {
  return new Basis(context2);
}
function BasisClosed(context2) {
  this._context = context2;
}
BasisClosed.prototype = {
  areaStart: noop$3,
  areaEnd: noop$3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point$7(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisClosed(context2) {
  return new BasisClosed(context2);
}
function BasisOpen(context2) {
  this._context = context2;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x02 = (this._x0 + 4 * this._x1 + x2) / 6, y02 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x02, y02) : this._context.moveTo(x02, y02);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point$7(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisOpen(context2) {
  return new BasisOpen(context2);
}
function Bundle(context2, beta) {
  this._basis = new Basis(context2);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, j = x2.length - 1;
    if (j > 0) {
      var x02 = x2[0], y02 = y2[0], dx = x2[j] - x02, dy = y2[j] - y02, i = -1, t4;
      while (++i <= j) {
        t4 = i / j;
        this._basis.point(
          this._beta * x2[i] + (1 - this._beta) * (x02 + t4 * dx),
          this._beta * y2[i] + (1 - this._beta) * (y02 + t4 * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
const curveBundle = function custom(beta) {
  function bundle2(context2) {
    return beta === 1 ? new Basis(context2) : new Bundle(context2, beta);
  }
  bundle2.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle2;
}(0.85);
function point$6(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context2, tension) {
  this._context = context2;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point$6(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point$6(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCardinal = function custom2(tension) {
  function cardinal(context2) {
    return new Cardinal(context2, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);
function CardinalClosed(context2, tension) {
  this._context = context2;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop$3,
  areaEnd: noop$3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point$6(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCardinalClosed = function custom3(tension) {
  function cardinal(context2) {
    return new CardinalClosed(context2, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);
function CardinalOpen(context2, tension) {
  this._context = context2;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point$6(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCardinalOpen = function custom4(tension) {
  function cardinal(context2) {
    return new CardinalOpen(context2, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);
function point$5(that, x2, y2) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon$5) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon$5) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b2 + that._x1 * that._l23_2a - x2 * that._l12_2a) / m2;
    y22 = (y22 * b2 + that._y1 * that._l23_2a - y2 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context2, alpha2) {
  this._context = context2;
  this._alpha = alpha2;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point$5(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCatmullRom = function custom5(alpha2) {
  function catmullRom(context2) {
    return alpha2 ? new CatmullRom(context2, alpha2) : new Cardinal(context2, 0);
  }
  catmullRom.alpha = function(alpha22) {
    return custom5(+alpha22);
  };
  return catmullRom;
}(0.5);
function CatmullRomClosed(context2, alpha2) {
  this._context = context2;
  this._alpha = alpha2;
}
CatmullRomClosed.prototype = {
  areaStart: noop$3,
  areaEnd: noop$3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point$5(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCatmullRomClosed = function custom6(alpha2) {
  function catmullRom(context2) {
    return alpha2 ? new CatmullRomClosed(context2, alpha2) : new CardinalClosed(context2, 0);
  }
  catmullRom.alpha = function(alpha22) {
    return custom6(+alpha22);
  };
  return catmullRom;
}(0.5);
function CatmullRomOpen(context2, alpha2) {
  this._context = context2;
  this._alpha = alpha2;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point$5(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCatmullRomOpen = function custom7(alpha2) {
  function catmullRom(context2) {
    return alpha2 ? new CatmullRomOpen(context2, alpha2) : new CardinalOpen(context2, 0);
  }
  catmullRom.alpha = function(alpha22) {
    return custom7(+alpha22);
  };
  return catmullRom;
}(0.5);
function LinearClosed(context2) {
  this._context = context2;
}
LinearClosed.prototype = {
  areaStart: noop$3,
  areaEnd: noop$3,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) this._context.lineTo(x2, y2);
    else this._point = 1, this._context.moveTo(x2, y2);
  }
};
function curveLinearClosed(context2) {
  return new LinearClosed(context2);
}
function sign$1(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t4) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t4) / 2 : t4;
}
function point$4(that, t02, t12) {
  var x02 = that._x0, y02 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x02) / 3;
  that._context.bezierCurveTo(x02 + dx, y02 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
}
function MonotoneX(context2) {
  this._context = context2;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point$4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point$4(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
        break;
      default:
        point$4(this, this._t0, t12 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY(context2) {
  this._context = new ReflectContext(context2);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context2) {
  this._context = context2;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y12, x12, y2, x2, y3, x3);
  }
};
function monotoneX(context2) {
  return new MonotoneX(context2);
}
function monotoneY(context2) {
  return new MonotoneY(context2);
}
function Natural(context2) {
  this._context = context2;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px2 = controlPoints(x2), py2 = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px2[0][i0], py2[0][i0], px2[1][i0], py2[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m2, a2 = new Array(n), b2 = new Array(n), r2 = new Array(n);
  a2[0] = 0, b2[0] = 2, r2[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i) a2[i] = 1, b2[i] = 4, r2[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b2[n - 1] = 7, r2[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i) m2 = a2[i] / b2[i - 1], b2[i] -= m2, r2[i] -= m2 * r2[i - 1];
  a2[n - 1] = r2[n - 1] / b2[n - 1];
  for (i = n - 2; i >= 0; --i) a2[i] = (r2[i] - a2[i + 1]) / b2[i];
  b2[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b2[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b2];
}
function curveNatural(context2) {
  return new Natural(context2);
}
function Step(context2, t4) {
  this._context = context2;
  this._t = t4;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x12 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function curveStep(context2) {
  return new Step(context2, 0.5);
}
function stepBefore(context2) {
  return new Step(context2, 0);
}
function stepAfter(context2) {
  return new Step(context2, 1);
}
function domCanvas(w2, h2) {
  if (typeof document !== "undefined" && document.createElement) {
    const c2 = document.createElement("canvas");
    if (c2 && c2.getContext) {
      c2.width = w2;
      c2.height = h2;
      return c2;
    }
  }
  return null;
}
const domImage = () => typeof Image !== "undefined" ? Image : null;
function initRange(domain2, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain2);
      break;
    default:
      this.range(range2).domain(domain2);
      break;
  }
  return this;
}
function initInterpolator(domain2, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain2 === "function") this.interpolator(domain2);
      else this.range(domain2);
      break;
    }
    default: {
      this.domain(domain2);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}
const implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain2 = [], range2 = [], unknown = implicit;
  function scale2(d) {
    let i = index2.get(d);
    if (i === void 0) {
      if (unknown !== implicit) return unknown;
      index2.set(d, i = domain2.push(d) - 1);
    }
    return range2[i % range2.length];
  }
  scale2.domain = function(_) {
    if (!arguments.length) return domain2.slice();
    domain2 = [], index2 = new InternMap();
    for (const value2 of _) {
      if (index2.has(value2)) continue;
      index2.set(value2, domain2.push(value2) - 1);
    }
    return scale2;
  };
  scale2.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), scale2) : range2.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain2, range2).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
function define$2(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend$2(parent, definition2) {
  var prototype2 = Object.create(parent.prototype);
  for (var key2 in definition2) prototype2[key2] = definition2[key2];
  return prototype2;
}
function Color$2() {
}
var darker$2 = 0.7;
var brighter$2 = 1 / darker$2;
var reI$2 = "\\s*([+-]?\\d+)\\s*", reN$2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP$2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex$2 = /^#([0-9a-f]{3,8})$/, reRgbInteger$2 = new RegExp(`^rgb\\(${reI$2},${reI$2},${reI$2}\\)$`), reRgbPercent$2 = new RegExp(`^rgb\\(${reP$2},${reP$2},${reP$2}\\)$`), reRgbaInteger$2 = new RegExp(`^rgba\\(${reI$2},${reI$2},${reI$2},${reN$2}\\)$`), reRgbaPercent$2 = new RegExp(`^rgba\\(${reP$2},${reP$2},${reP$2},${reN$2}\\)$`), reHslPercent$2 = new RegExp(`^hsl\\(${reN$2},${reP$2},${reP$2}\\)$`), reHslaPercent$2 = new RegExp(`^hsla\\(${reN$2},${reP$2},${reP$2},${reN$2}\\)$`);
var named$2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define$2(Color$2, color$6, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex$2,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex$2,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl$2,
  formatRgb: color_formatRgb$2,
  toString: color_formatRgb$2
});
function color_formatHex$2() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl$2() {
  return hslConvert$2(this).formatHsl();
}
function color_formatRgb$2() {
  return this.rgb().formatRgb();
}
function color$6(format2) {
  var m2, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex$2.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn$2(m2) : l === 3 ? new Rgb$2(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba$2(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba$2(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger$2.exec(format2)) ? new Rgb$2(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent$2.exec(format2)) ? new Rgb$2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger$2.exec(format2)) ? rgba$2(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent$2.exec(format2)) ? rgba$2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent$2.exec(format2)) ? hsla$2(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent$2.exec(format2)) ? hsla$2(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named$2.hasOwnProperty(format2) ? rgbn$2(named$2[format2]) : format2 === "transparent" ? new Rgb$2(NaN, NaN, NaN, 0) : null;
}
function rgbn$2(n) {
  return new Rgb$2(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba$2(r2, g, b2, a2) {
  if (a2 <= 0) r2 = g = b2 = NaN;
  return new Rgb$2(r2, g, b2, a2);
}
function rgbConvert$2(o) {
  if (!(o instanceof Color$2)) o = color$6(o);
  if (!o) return new Rgb$2();
  o = o.rgb();
  return new Rgb$2(o.r, o.g, o.b, o.opacity);
}
function rgb$3(r2, g, b2, opacity2) {
  return arguments.length === 1 ? rgbConvert$2(r2) : new Rgb$2(r2, g, b2, opacity2 == null ? 1 : opacity2);
}
function Rgb$2(r2, g, b2, opacity2) {
  this.r = +r2;
  this.g = +g;
  this.b = +b2;
  this.opacity = +opacity2;
}
define$2(Rgb$2, rgb$3, extend$2(Color$2, {
  brighter(k) {
    k = k == null ? brighter$2 : Math.pow(brighter$2, k);
    return new Rgb$2(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker$2 : Math.pow(darker$2, k);
    return new Rgb$2(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb$2(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex$2,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex$2,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb$2,
  toString: rgb_formatRgb$2
}));
function rgb_formatHex$2() {
  return `#${hex$2(this.r)}${hex$2(this.g)}${hex$2(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex$2(this.r)}${hex$2(this.g)}${hex$2(this.b)}${hex$2((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb$2() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity2) {
  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex$2(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla$2(h2, s, l, a2) {
  if (a2 <= 0) h2 = s = l = NaN;
  else if (l <= 0 || l >= 1) h2 = s = NaN;
  else if (s <= 0) h2 = NaN;
  return new Hsl$2(h2, s, l, a2);
}
function hslConvert$2(o) {
  if (o instanceof Hsl$2) return new Hsl$2(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color$2)) o = color$6(o);
  if (!o) return new Hsl$2();
  if (o instanceof Hsl$2) return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b2 = o.b / 255, min2 = Math.min(r2, g, b2), max2 = Math.max(r2, g, b2), h2 = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r2 === max2) h2 = (g - b2) / s + (g < b2) * 6;
    else if (g === max2) h2 = (b2 - r2) / s + 2;
    else h2 = (r2 - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl$2(h2, s, l, o.opacity);
}
function hsl$4(h2, s, l, opacity2) {
  return arguments.length === 1 ? hslConvert$2(h2) : new Hsl$2(h2, s, l, opacity2 == null ? 1 : opacity2);
}
function Hsl$2(h2, s, l, opacity2) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity2;
}
define$2(Hsl$2, hsl$4, extend$2(Color$2, {
  brighter(k) {
    k = k == null ? brighter$2 : Math.pow(brighter$2, k);
    return new Hsl$2(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker$2 : Math.pow(darker$2, k);
    return new Hsl$2(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb$2(
      hsl2rgb$2(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb$2(h2, m1, m2),
      hsl2rgb$2(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl$2(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb$2(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const radians$1 = Math.PI / 180;
const degrees$2 = 180 / Math.PI;
const K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb$2)) o = rgbConvert$2(o);
  var r2 = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b2 = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r2 + 0.7168786 * g + 0.0606169 * b2) / Yn), x2, z2;
  if (r2 === g && g === b2) x2 = z2 = y2;
  else {
    x2 = xyz2lab((0.4360747 * r2 + 0.3850649 * g + 0.1430804 * b2) / Xn);
    z2 = xyz2lab((0.0139322 * r2 + 0.0971045 * g + 0.7141733 * b2) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z2), o.opacity);
}
function lab$1(l, a2, b2, opacity2) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b2, opacity2 == null ? 1 : opacity2);
}
function Lab(l, a2, b2, opacity2) {
  this.l = +l;
  this.a = +a2;
  this.b = +b2;
  this.opacity = +opacity2;
}
define$2(Lab, lab$1, extend$2(Color$2, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z2 = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y2 = Yn * lab2xyz(y2);
    z2 = Zn * lab2xyz(z2);
    return new Rgb$2(
      lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z2),
      lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z2),
      lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z2),
      this.opacity
    );
  }
}));
function xyz2lab(t4) {
  return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t2 + t0;
}
function lab2xyz(t4) {
  return t4 > t1 ? t4 * t4 * t4 : t2 * (t4 - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h2 = Math.atan2(o.b, o.a) * degrees$2;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl$2(h2, c2, l, opacity2) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c2, l, opacity2 == null ? 1 : opacity2);
}
function Hcl(h2, c2, l, opacity2) {
  this.h = +h2;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity2;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h2 = o.h * radians$1;
  return new Lab(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
}
define$2(Hcl, hcl$2, extend$2(Color$2, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));
var A = -0.14861, B$1 = 1.78277, C$1 = -0.29227, D$1 = -0.90649, E = 1.97294, ED = E * D$1, EB = E * B$1, BC_DA = B$1 * C$1 - D$1 * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb$2)) o = rgbConvert$2(o);
  var r2 = o.r / 255, g = o.g / 255, b2 = o.b / 255, l = (BC_DA * b2 + ED * r2 - EB * g) / (BC_DA + ED - EB), bl2 = b2 - l, k = (E * (g - l) - C$1 * bl2) / D$1, s = Math.sqrt(k * k + bl2 * bl2) / (E * l * (1 - l)), h2 = s ? Math.atan2(k, bl2) * degrees$2 - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s, l, o.opacity);
}
function cubehelix$2(h2, s, l, opacity2) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s, l, opacity2 == null ? 1 : opacity2);
}
function Cubehelix(h2, s, l, opacity2) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity2;
}
define$2(Cubehelix, cubehelix$2, extend$2(Color$2, {
  brighter(k) {
    k = k == null ? brighter$2 : Math.pow(brighter$2, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker$2 : Math.pow(darker$2, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians$1, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
    return new Rgb$2(
      255 * (l + a2 * (A * cosh2 + B$1 * sinh2)),
      255 * (l + a2 * (C$1 * cosh2 + D$1 * sinh2)),
      255 * (l + a2 * (E * cosh2)),
      this.opacity
    );
  }
}));
function basis$1(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis$2(values2) {
  var n = values2.length - 1;
  return function(t4) {
    var i = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n - 1) : Math.floor(t4 * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
    return basis$1((t4 - i / n) * n, v0, v1, v2, v3);
  };
}
function basisClosed(values2) {
  var n = values2.length;
  return function(t4) {
    var i = Math.floor(((t4 %= 1) < 0 ? ++t4 : t4) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
    return basis$1((t4 - i / n) * n, v0, v1, v2, v3);
  };
}
const constant$3 = (x2) => () => x2;
function linear$2(a2, d) {
  return function(t4) {
    return a2 + t4 * d;
  };
}
function exponential$1(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t4) {
    return Math.pow(a2 + t4 * b2, y2);
  };
}
function hue$1(a2, b2) {
  var d = b2 - a2;
  return d ? linear$2(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a2) ? b2 : a2);
}
function gamma$1(y2) {
  return (y2 = +y2) === 1 ? nogamma$1 : function(a2, b2) {
    return b2 - a2 ? exponential$1(a2, b2, y2) : constant$3(isNaN(a2) ? b2 : a2);
  };
}
function nogamma$1(a2, b2) {
  var d = b2 - a2;
  return d ? linear$2(a2, d) : constant$3(isNaN(a2) ? b2 : a2);
}
const rgb$2 = function rgbGamma(y2) {
  var color2 = gamma$1(y2);
  function rgb2(start, end) {
    var r2 = color2((start = rgb$3(start)).r, (end = rgb$3(end)).r), g = color2(start.g, end.g), b2 = color2(start.b, end.b), opacity2 = nogamma$1(start.opacity, end.opacity);
    return function(t4) {
      start.r = r2(t4);
      start.g = g(t4);
      start.b = b2(t4);
      start.opacity = opacity2(t4);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline$1(spline) {
  return function(colors2) {
    var n = colors2.length, r2 = new Array(n), g = new Array(n), b2 = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb$3(colors2[i]);
      r2[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b2[i] = color2.b || 0;
    }
    r2 = spline(r2);
    g = spline(g);
    b2 = spline(b2);
    color2.opacity = 1;
    return function(t4) {
      color2.r = r2(t4);
      color2.g = g(t4);
      color2.b = b2(t4);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline$1(basis$2);
var rgbBasisClosed = rgbSpline$1(basisClosed);
function numberArray$1(a2, b2) {
  if (!b2) b2 = [];
  var n = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i;
  return function(t4) {
    for (i = 0; i < n; ++i) c2[i] = a2[i] * (1 - t4) + b2[i] * t4;
    return c2;
  };
}
function isNumberArray$1(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function array$3(a2, b2) {
  return (isNumberArray$1(b2) ? numberArray$1 : genericArray$1)(a2, b2);
}
function genericArray$1(a2, b2) {
  var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i) x2[i] = interpolate$1$1(a2[i], b2[i]);
  for (; i < nb; ++i) c2[i] = b2[i];
  return function(t4) {
    for (i = 0; i < na; ++i) c2[i] = x2[i](t4);
    return c2;
  };
}
function date$2(a2, b2) {
  var d = /* @__PURE__ */ new Date();
  return a2 = +a2, b2 = +b2, function(t4) {
    return d.setTime(a2 * (1 - t4) + b2 * t4), d;
  };
}
function interpolateNumber(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t4) {
    return a2 * (1 - t4) + b2 * t4;
  };
}
function object$1(a2, b2) {
  var i = {}, c2 = {}, k;
  if (a2 === null || typeof a2 !== "object") a2 = {};
  if (b2 === null || typeof b2 !== "object") b2 = {};
  for (k in b2) {
    if (k in a2) {
      i[k] = interpolate$1$1(a2[k], b2[k]);
    } else {
      c2[k] = b2[k];
    }
  }
  return function(t4) {
    for (k in i) c2[k] = i[k](t4);
    return c2;
  };
}
var reA$1 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB$1 = new RegExp(reA$1.source, "g");
function zero$3(b2) {
  return function() {
    return b2;
  };
}
function one$2(b2) {
  return function(t4) {
    return b2(t4) + "";
  };
}
function string$1(a2, b2) {
  var bi = reA$1.lastIndex = reB$1.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA$1.exec(a2)) && (bm = reB$1.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB$1.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one$2(q[0].x) : zero$3(b2) : (b2 = q.length, function(t4) {
    for (var i2 = 0, o; i2 < b2; ++i2) s[(o = q[i2]).i] = o.x(t4);
    return s.join("");
  });
}
function interpolate$1$1(a2, b2) {
  var t4 = typeof b2, c2;
  return b2 == null || t4 === "boolean" ? constant$3(b2) : (t4 === "number" ? interpolateNumber : t4 === "string" ? (c2 = color$6(b2)) ? (b2 = c2, rgb$2) : string$1 : b2 instanceof color$6 ? rgb$2 : b2 instanceof Date ? date$2 : isNumberArray$1(b2) ? numberArray$1 : Array.isArray(b2) ? genericArray$1 : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object$1 : interpolateNumber)(a2, b2);
}
function discrete$1(range2) {
  var n = range2.length;
  return function(t4) {
    return range2[Math.max(0, Math.min(n - 1, Math.floor(t4 * n)))];
  };
}
function hue(a2, b2) {
  var i = hue$1(+a2, +b2);
  return function(t4) {
    var x2 = i(t4);
    return x2 - 360 * Math.floor(x2 / 360);
  };
}
function interpolateRound(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t4) {
    return Math.round(a2 * (1 - t4) + b2 * t4);
  };
}
var degrees$1 = 180 / Math.PI;
var identity$3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a2, b2, c2, d, e3, f) {
  var scaleX, scaleY2, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b2 * b2)) a2 /= scaleX, b2 /= scaleX;
  if (skewX = a2 * c2 + b2 * d) c2 -= a2 * skewX, d -= b2 * skewX;
  if (scaleY2 = Math.sqrt(c2 * c2 + d * d)) c2 /= scaleY2, d /= scaleY2, skewX /= scaleY2;
  if (a2 * d < b2 * c2) a2 = -a2, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f,
    rotate: Math.atan2(b2, a2) * degrees$1,
    skewX: Math.atan(skewX) * degrees$1,
    scaleX,
    scaleY: scaleY2
  };
}
var svgNode;
function parseCss(value2) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m2.isIdentity ? identity$3 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value2) {
  if (value2 == null) return identity$3;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate())) return identity$3;
  value2 = value2.matrix;
  return decompose(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate2(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate2(a2, b2, s, q) {
    if (a2 !== b2) {
      if (a2 - b2 > 180) b2 += 360;
      else if (b2 - a2 > 180) a2 += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b2) });
    } else if (b2) {
      s.push(pop(s) + "rotate(" + b2 + degParen);
    }
  }
  function skewX(a2, b2, s, q) {
    if (a2 !== b2) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b2) });
    } else if (b2) {
      s.push(pop(s) + "skewX(" + b2 + degParen);
    }
  }
  function scale2(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b2) {
    var s = [], q = [];
    a2 = parse2(a2), b2 = parse2(b2);
    translate2(a2.translateX, a2.translateY, b2.translateX, b2.translateY, s, q);
    rotate2(a2.rotate, b2.rotate, s, q);
    skewX(a2.skewX, b2.skewX, s, q);
    scale2(a2.scaleX, a2.scaleY, b2.scaleX, b2.scaleY, s, q);
    a2 = b2 = null;
    return function(t4) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t4);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var epsilon2$1 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
const zoom$1 = function zoomRho(rho, rho2, rho4) {
  function zoom2(p02, p1) {
    var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2$1) {
      S = Math.log(w1 / w0) / rho;
      i = function(t4) {
        return [
          ux0 + t4 * dx,
          uy0 + t4 * dy,
          w0 * Math.exp(rho * t4 * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t4) {
        var s = t4 * S, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u2 * dx,
          uy0 + u2 * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom2;
}(Math.SQRT2, 2, 4);
function hsl$2(hue2) {
  return function(start, end) {
    var h2 = hue2((start = hsl$4(start)).h, (end = hsl$4(end)).h), s = nogamma$1(start.s, end.s), l = nogamma$1(start.l, end.l), opacity2 = nogamma$1(start.opacity, end.opacity);
    return function(t4) {
      start.h = h2(t4);
      start.s = s(t4);
      start.l = l(t4);
      start.opacity = opacity2(t4);
      return start + "";
    };
  };
}
const hsl$3 = hsl$2(hue$1);
var hslLong = hsl$2(nogamma$1);
function lab(start, end) {
  var l = nogamma$1((start = lab$1(start)).l, (end = lab$1(end)).l), a2 = nogamma$1(start.a, end.a), b2 = nogamma$1(start.b, end.b), opacity2 = nogamma$1(start.opacity, end.opacity);
  return function(t4) {
    start.l = l(t4);
    start.a = a2(t4);
    start.b = b2(t4);
    start.opacity = opacity2(t4);
    return start + "";
  };
}
function hcl(hue2) {
  return function(start, end) {
    var h2 = hue2((start = hcl$2(start)).h, (end = hcl$2(end)).h), c2 = nogamma$1(start.c, end.c), l = nogamma$1(start.l, end.l), opacity2 = nogamma$1(start.opacity, end.opacity);
    return function(t4) {
      start.h = h2(t4);
      start.c = c2(t4);
      start.l = l(t4);
      start.opacity = opacity2(t4);
      return start + "";
    };
  };
}
const hcl$1 = hcl(hue$1);
var hclLong = hcl(nogamma$1);
function cubehelix(hue2) {
  return function cubehelixGamma(y2) {
    y2 = +y2;
    function cubehelix2(start, end) {
      var h2 = hue2((start = cubehelix$2(start)).h, (end = cubehelix$2(end)).h), s = nogamma$1(start.s, end.s), l = nogamma$1(start.l, end.l), opacity2 = nogamma$1(start.opacity, end.opacity);
      return function(t4) {
        start.h = h2(t4);
        start.s = s(t4);
        start.l = l(Math.pow(t4, y2));
        start.opacity = opacity2(t4);
        return start + "";
      };
    }
    cubehelix2.gamma = cubehelixGamma;
    return cubehelix2;
  }(1);
}
const cubehelix$1 = cubehelix(hue$1);
var cubehelixLong = cubehelix(nogamma$1);
function piecewise$1(interpolate2, values2) {
  if (values2 === void 0) values2 = interpolate2, interpolate2 = interpolate$1$1;
  var i = 0, n = values2.length - 1, v = values2[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate2(v, v = values2[++i]);
  return function(t4) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t4 *= n)));
    return I[i2](t4 - i2);
  };
}
function quantize$2(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}
const $$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  interpolate: interpolate$1$1,
  interpolateArray: array$3,
  interpolateBasis: basis$2,
  interpolateBasisClosed: basisClosed,
  interpolateCubehelix: cubehelix$1,
  interpolateCubehelixLong: cubehelixLong,
  interpolateDate: date$2,
  interpolateDiscrete: discrete$1,
  interpolateHcl: hcl$1,
  interpolateHclLong: hclLong,
  interpolateHsl: hsl$3,
  interpolateHslLong: hslLong,
  interpolateHue: hue,
  interpolateLab: lab,
  interpolateNumber,
  interpolateNumberArray: numberArray$1,
  interpolateObject: object$1,
  interpolateRgb: rgb$2,
  interpolateRgbBasis: rgbBasis,
  interpolateRgbBasisClosed: rgbBasisClosed,
  interpolateRound,
  interpolateString: string$1,
  interpolateTransformCss,
  interpolateTransformSvg,
  interpolateZoom: zoom$1,
  piecewise: piecewise$1,
  quantize: quantize$2
}, Symbol.toStringTag, { value: "Module" }));
function constants$2(x2) {
  return function() {
    return x2;
  };
}
function number$6(x2) {
  return +x2;
}
var unit = [0, 1];
function identity$2(x2) {
  return x2;
}
function normalize$2(a2, b2) {
  return (b2 -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b2;
  } : constants$2(isNaN(b2) ? NaN : 0.5);
}
function clamper(a2, b2) {
  var t4;
  if (a2 > b2) t4 = a2, a2 = b2, b2 = t4;
  return function(x2) {
    return Math.max(a2, Math.min(b2, x2));
  };
}
function bimap(domain2, range2, interpolate2) {
  var d0 = domain2[0], d1 = domain2[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0) d0 = normalize$2(d1, d0), r0 = interpolate2(r1, r0);
  else d0 = normalize$2(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain2, range2, interpolate2) {
  var j = Math.min(domain2.length, range2.length) - 1, d = new Array(j), r2 = new Array(j), i = -1;
  if (domain2[j] < domain2[0]) {
    domain2 = domain2.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize$2(domain2[i], domain2[i + 1]);
    r2[i] = interpolate2(range2[i], range2[i + 1]);
  }
  return function(x2) {
    var i2 = bisectRight$1(domain2, x2, 1, j) - 1;
    return r2[i2](d[i2](x2));
  };
}
function copy$3(source2, target2) {
  return target2.domain(source2.domain()).range(source2.range()).interpolate(source2.interpolate()).clamp(source2.clamp()).unknown(source2.unknown());
}
function transformer$3() {
  var domain2 = unit, range2 = unit, interpolate2 = interpolate$1$1, transform2, untransform, unknown, clamp2 = identity$2, piecewise2, output2, input;
  function rescale() {
    var n = Math.min(domain2.length, range2.length);
    if (clamp2 !== identity$2) clamp2 = clamper(domain2[0], domain2[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output2 = input = null;
    return scale2;
  }
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output2 || (output2 = piecewise2(domain2.map(transform2), range2, interpolate2)))(transform2(clamp2(x2)));
  }
  scale2.invert = function(y2) {
    return clamp2(untransform((input || (input = piecewise2(range2, domain2.map(transform2), interpolateNumber)))(y2)));
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain2 = Array.from(_, number$6), rescale()) : domain2.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale2.rangeRound = function(_) {
    return range2 = Array.from(_), interpolate2 = interpolateRound, rescale();
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity$2, rescale()) : clamp2 !== identity$2;
  };
  scale2.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, rescale()) : interpolate2;
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t4, u2) {
    transform2 = t4, untransform = u2;
    return rescale();
  };
}
function continuous$1() {
  return transformer$3()(identity$2, identity$2);
}
function tickFormat$1(start, stop3, count2, specifier) {
  var step = tickStep(start, stop3, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value2 = Math.max(Math.abs(start), Math.abs(stop3));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value2))) specifier.precision = precision;
      return formatPrefix(specifier, value2);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop3))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format$3(specifier);
}
function linearish(scale2) {
  var domain2 = scale2.domain;
  scale2.ticks = function(count2) {
    var d = domain2();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale2.tickFormat = function(count2, specifier) {
    var d = domain2();
    return tickFormat$1(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale2.nice = function(count2) {
    if (count2 == null) count2 = 10;
    var d = domain2();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop3 = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop3 < start) {
      step = start, start = stop3, stop3 = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop3, count2);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop3;
        return domain2(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop3 = Math.ceil(stop3 / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop3 = Math.floor(stop3 * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear$1() {
  var scale2 = continuous$1();
  scale2.copy = function() {
    return copy$3(scale2, linear$1());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}
function identity$1(domain2) {
  var unknown;
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
  }
  scale2.invert = scale2;
  scale2.domain = scale2.range = function(_) {
    return arguments.length ? (domain2 = Array.from(_, number$6), scale2) : domain2.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return identity$1(domain2).unknown(unknown);
  };
  domain2 = arguments.length ? Array.from(domain2, number$6) : [0, 1];
  return linearish(scale2);
}
function nice$1(domain2, interval2) {
  domain2 = domain2.slice();
  var i0 = 0, i1 = domain2.length - 1, x02 = domain2[i0], x12 = domain2[i1], t4;
  if (x12 < x02) {
    t4 = i0, i0 = i1, i1 = t4;
    t4 = x02, x02 = x12, x12 = t4;
  }
  domain2[i0] = interval2.floor(x02);
  domain2[i1] = interval2.ceil(x12);
  return domain2;
}
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base2) {
  return base2 === 10 ? pow10 : base2 === Math.E ? Math.exp : (x2) => Math.pow(base2, x2);
}
function logp(base2) {
  return base2 === Math.E ? Math.log : base2 === 10 && Math.log10 || base2 === 2 && Math.log2 || (base2 = Math.log(base2), (x2) => Math.log(x2) / base2);
}
function reflect(f) {
  return (x2, k) => -f(-x2, k);
}
function loggish(transform2) {
  const scale2 = transform2(transformLog, transformExp);
  const domain2 = scale2.domain;
  let base2 = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base2), pows = powp(base2);
    if (domain2()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale2;
  }
  scale2.base = function(_) {
    return arguments.length ? (base2 = +_, rescale()) : base2;
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain2(_), rescale()) : domain2();
  };
  scale2.ticks = (count2) => {
    const d = domain2();
    let u2 = d[0];
    let v = d[d.length - 1];
    const r2 = v < u2;
    if (r2) [u2, v] = [v, u2];
    let i = logs(u2);
    let j = logs(v);
    let k;
    let t4;
    const n = count2 == null ? 10 : +count2;
    let z2 = [];
    if (!(base2 % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u2 > 0) for (; i <= j; ++i) {
        for (k = 1; k < base2; ++k) {
          t4 = i < 0 ? k / pows(-i) : k * pows(i);
          if (t4 < u2) continue;
          if (t4 > v) break;
          z2.push(t4);
        }
      }
      else for (; i <= j; ++i) {
        for (k = base2 - 1; k >= 1; --k) {
          t4 = i > 0 ? k / pows(-i) : k * pows(i);
          if (t4 < u2) continue;
          if (t4 > v) break;
          z2.push(t4);
        }
      }
      if (z2.length * 2 < n) z2 = ticks(u2, v, n);
    } else {
      z2 = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r2 ? z2.reverse() : z2;
  };
  scale2.tickFormat = (count2, specifier) => {
    if (count2 == null) count2 = 10;
    if (specifier == null) specifier = base2 === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base2 % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format$3(specifier);
    }
    if (count2 === Infinity) return specifier;
    const k = Math.max(1, base2 * count2 / scale2.ticks().length);
    return (d) => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base2 < base2 - 0.5) i *= base2;
      return i <= k ? specifier(d) : "";
    };
  };
  scale2.nice = () => {
    return domain2(nice$1(domain2(), {
      floor: (x2) => pows(Math.floor(logs(x2))),
      ceil: (x2) => pows(Math.ceil(logs(x2)))
    }));
  };
  return scale2;
}
function log$3() {
  const scale2 = loggish(transformer$3()).domain([1, 10]);
  scale2.copy = () => copy$3(scale2, log$3()).base(scale2.base());
  initRange.apply(scale2, arguments);
  return scale2;
}
function transformSymlog(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
  };
}
function transformSymexp(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
  };
}
function symlogish(transform2) {
  var c2 = 1, scale2 = transform2(transformSymlog(c2), transformSymexp(c2));
  scale2.constant = function(_) {
    return arguments.length ? transform2(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
  };
  return linearish(scale2);
}
function symlog() {
  var scale2 = symlogish(transformer$3());
  scale2.copy = function() {
    return copy$3(scale2, symlog()).constant(scale2.constant());
  };
  return initRange.apply(scale2, arguments);
}
function transformPow(exponent2) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform2) {
  var scale2 = transform2(identity$2, identity$2), exponent2 = 1;
  function rescale() {
    return exponent2 === 1 ? transform2(identity$2, identity$2) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));
  }
  scale2.exponent = function(_) {
    return arguments.length ? (exponent2 = +_, rescale()) : exponent2;
  };
  return linearish(scale2);
}
function pow$2() {
  var scale2 = powish(transformer$3());
  scale2.copy = function() {
    return copy$3(scale2, pow$2()).exponent(scale2.exponent());
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
function sqrt$2() {
  return pow$2.apply(null, arguments).exponent(0.5);
}
function quantile() {
  var domain2 = [], range2 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range2.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = quantileSorted(domain2, i / n);
    return scale2;
  }
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : range2[bisectRight$1(thresholds, x2)];
  }
  scale2.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain2[0],
      i < thresholds.length ? thresholds[i] : domain2[domain2.length - 1]
    ];
  };
  scale2.domain = function(_) {
    if (!arguments.length) return domain2.slice();
    domain2 = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain2.push(d);
    domain2.sort(ascending$2);
    return rescale();
  };
  scale2.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.quantiles = function() {
    return thresholds.slice();
  };
  scale2.copy = function() {
    return quantile().domain(domain2).range(range2).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}
function quantize$1() {
  var x02 = 0, x12 = 1, n = 1, domain2 = [0.5], range2 = [0, 1], unknown;
  function scale2(x2) {
    return x2 != null && x2 <= x2 ? range2[bisectRight$1(domain2, x2, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain2 = new Array(n);
    while (++i < n) domain2[i] = ((i + 1) * x12 - (i - n) * x02) / (n + 1);
    return scale2;
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x02, x12] = _, x02 = +x02, x12 = +x12, rescale()) : [x02, x12];
  };
  scale2.range = function(_) {
    return arguments.length ? (n = (range2 = Array.from(_)).length - 1, rescale()) : range2.slice();
  };
  scale2.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x02, domain2[0]] : i >= n ? [domain2[n - 1], x12] : [domain2[i - 1], domain2[i]];
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : scale2;
  };
  scale2.thresholds = function() {
    return domain2.slice();
  };
  scale2.copy = function() {
    return quantize$1().domain([x02, x12]).range(range2).unknown(unknown);
  };
  return initRange.apply(linearish(scale2), arguments);
}
function threshold() {
  var domain2 = [0.5], range2 = [0, 1], unknown, n = 1;
  function scale2(x2) {
    return x2 != null && x2 <= x2 ? range2[bisectRight$1(domain2, x2, 0, n)] : unknown;
  }
  scale2.domain = function(_) {
    return arguments.length ? (domain2 = Array.from(_), n = Math.min(domain2.length, range2.length - 1), scale2) : domain2.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), n = Math.min(domain2.length, range2.length - 1), scale2) : range2.slice();
  };
  scale2.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return [domain2[i - 1], domain2[i]];
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return threshold().domain(domain2).range(range2).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}
function date$1(t4) {
  return new Date(t4);
}
function number$5(t4) {
  return t4 instanceof Date ? +t4 : +/* @__PURE__ */ new Date(+t4);
}
function calendar(ticks2, tickInterval, year2, month2, week2, day2, hour2, minute2, second2, format2) {
  var scale2 = continuous$1(), invert2 = scale2.invert, domain2 = scale2.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week2(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale2.invert = function(y2) {
    return new Date(invert2(y2));
  };
  scale2.domain = function(_) {
    return arguments.length ? domain2(Array.from(_, number$5)) : domain2().map(date$1);
  };
  scale2.ticks = function(interval2) {
    var d = domain2();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale2.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale2.nice = function(interval2) {
    var d = domain2();
    if (!interval2 || typeof interval2.range !== "function") interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain2(nice$1(d, interval2)) : scale2;
  };
  scale2.copy = function() {
    return copy$3(scale2, calendar(ticks2, tickInterval, year2, month2, week2, day2, hour2, minute2, second2, format2));
  };
  return scale2;
}
function time$1() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, year, month, sunday, day, hour, minute, second, timeFormat$2).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat$1).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$2() {
  var x02 = 0, x12 = 1, t02, t12, k10, transform2, interpolator = identity$2, clamp2 = false, unknown;
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform2(x2) - t02) * k10, clamp2 ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x02, x12] = _, t02 = transform2(x02 = +x02), t12 = transform2(x12 = +x12), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale2) : [x02, x12];
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale2) : clamp2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  function range2(interpolate2) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale2) : [interpolator(0), interpolator(1)];
    };
  }
  scale2.range = range2(interpolate$1$1);
  scale2.rangeRound = range2(interpolateRound);
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t4) {
    transform2 = t4, t02 = t4(x02), t12 = t4(x12), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
    return scale2;
  };
}
function copy$2(source2, target2) {
  return target2.domain(source2.domain()).interpolator(source2.interpolator()).clamp(source2.clamp()).unknown(source2.unknown());
}
function sequential() {
  var scale2 = linearish(transformer$2()(identity$2));
  scale2.copy = function() {
    return copy$2(scale2, sequential());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialLog() {
  var scale2 = loggish(transformer$2()).domain([1, 10]);
  scale2.copy = function() {
    return copy$2(scale2, sequentialLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialSymlog() {
  var scale2 = symlogish(transformer$2());
  scale2.copy = function() {
    return copy$2(scale2, sequentialSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialPow() {
  var scale2 = powish(transformer$2());
  scale2.copy = function() {
    return copy$2(scale2, sequentialPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
function transformer$1() {
  var x02 = 0, x12 = 0.5, x2 = 1, s = 1, t02, t12, t22, k10, k21, interpolator = identity$2, transform2, clamp2 = false, unknown;
  function scale2(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform2(x3)) - t12) * (s * x3 < s * t12 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x02, x12, x2] = _, t02 = transform2(x02 = +x02), t12 = transform2(x12 = +x12), t22 = transform2(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), s = t12 < t02 ? -1 : 1, scale2) : [x02, x12, x2];
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale2) : clamp2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  function range2(interpolate2) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise$1(interpolate2, [r0, r1, r2]), scale2) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale2.range = range2(interpolate$1$1);
  scale2.rangeRound = range2(interpolateRound);
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t4) {
    transform2 = t4, t02 = t4(x02), t12 = t4(x12), t22 = t4(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), s = t12 < t02 ? -1 : 1;
    return scale2;
  };
}
function diverging() {
  var scale2 = linearish(transformer$1()(identity$2));
  scale2.copy = function() {
    return copy$2(scale2, diverging());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingLog() {
  var scale2 = loggish(transformer$1()).domain([0.1, 1, 10]);
  scale2.copy = function() {
    return copy$2(scale2, divergingLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSymlog() {
  var scale2 = symlogish(transformer$1());
  scale2.copy = function() {
    return copy$2(scale2, divergingSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingPow() {
  var scale2 = powish(transformer$1());
  scale2.copy = function() {
    return copy$2(scale2, divergingPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
function bandSpace(count2, paddingInner2, paddingOuter2) {
  const space = count2 - paddingInner2 + paddingOuter2 * 2;
  return count2 ? space > 0 ? space : 1 : 0;
}
const Identity = "identity";
const Linear = "linear";
const Log = "log";
const Pow = "pow";
const Sqrt = "sqrt";
const Symlog = "symlog";
const Time = "time";
const UTC = "utc";
const Sequential = "sequential";
const Diverging = "diverging";
const Quantile = "quantile";
const Quantize = "quantize";
const Threshold = "threshold";
const Ordinal = "ordinal";
const Point = "point";
const Band = "band";
const BinOrdinal = "bin-ordinal";
const Continuous = "continuous";
const Discrete$1 = "discrete";
const Discretizing = "discretizing";
const Interpolating = "interpolating";
const Temporal = "temporal";
function invertRange(scale2) {
  return function(_) {
    let lo = _[0], hi = _[1], t4;
    if (hi < lo) {
      t4 = lo;
      lo = hi;
      hi = t4;
    }
    return [scale2.invert(lo), scale2.invert(hi)];
  };
}
function invertRangeExtent(scale2) {
  return function(_) {
    const range2 = scale2.range();
    let lo = _[0], hi = _[1], min2 = -1, max2, t4, i, n;
    if (hi < lo) {
      t4 = lo;
      lo = hi;
      hi = t4;
    }
    for (i = 0, n = range2.length; i < n; ++i) {
      if (range2[i] >= lo && range2[i] <= hi) {
        if (min2 < 0) min2 = i;
        max2 = i;
      }
    }
    if (min2 < 0) return void 0;
    lo = scale2.invertExtent(range2[min2]);
    hi = scale2.invertExtent(range2[max2]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band() {
  const scale2 = ordinal().unknown(void 0), domain2 = scale2.domain, ordinalRange = scale2.range;
  let range$12 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale2.unknown;
  function rescale() {
    const n = domain2().length, reverse2 = range$12[1] < range$12[0], stop3 = range$12[1 - reverse2], space = bandSpace(n, paddingInner2, paddingOuter2);
    let start = range$12[reverse2 - 0];
    step = (stop3 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop3 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values2 = range$6(n).map((i) => start + step * i);
    return ordinalRange(reverse2 ? values2.reverse() : values2);
  }
  scale2.domain = function(_) {
    if (arguments.length) {
      domain2(_);
      return rescale();
    } else {
      return domain2();
    }
  };
  scale2.range = function(_) {
    if (arguments.length) {
      range$12 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$12.slice();
    }
  };
  scale2.rangeRound = function(_) {
    range$12 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale2.bandwidth = function() {
    return bandwidth2;
  };
  scale2.step = function() {
    return step;
  };
  scale2.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale2.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale2.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale2.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale2.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale2.invertRange = function(_) {
    if (_[0] == null || _[1] == null) return;
    const reverse2 = range$12[1] < range$12[0], values2 = reverse2 ? ordinalRange().reverse() : ordinalRange(), n = values2.length - 1;
    let lo = +_[0], hi = +_[1], a2, b2, t4;
    if (lo !== lo || hi !== hi) return;
    if (hi < lo) {
      t4 = lo;
      lo = hi;
      hi = t4;
    }
    if (hi < values2[0] || lo > range$12[1 - reverse2]) return;
    a2 = Math.max(0, bisectRight$1(values2, lo) - 1);
    b2 = lo === hi ? a2 : bisectRight$1(values2, hi) - 1;
    if (lo - values2[a2] > bandwidth2 + 1e-10) ++a2;
    if (reverse2) {
      t4 = a2;
      a2 = n - b2;
      b2 = n - t4;
    }
    return a2 > b2 ? void 0 : domain2().slice(a2, b2 + 1);
  };
  scale2.invert = function(_) {
    const value2 = scale2.invertRange([_, _]);
    return value2 ? value2[0] : value2;
  };
  scale2.copy = function() {
    return band().domain(domain2()).range(range$12).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish(scale2) {
  const copy2 = scale2.copy;
  scale2.padding = scale2.paddingOuter;
  delete scale2.paddingInner;
  scale2.copy = function() {
    return pointish(copy2());
  };
  return scale2;
}
function point$3() {
  return pointish(band().paddingInner(1));
}
var map = Array.prototype.map;
function numbers(_) {
  return map.call(_, toNumber);
}
const slice$3 = Array.prototype.slice;
function scaleBinOrdinal() {
  let domain2 = [], range2 = [];
  function scale2(x2) {
    return x2 == null || x2 !== x2 ? void 0 : range2[(bisectRight$1(domain2, x2) - 1) % range2.length];
  }
  scale2.domain = function(_) {
    if (arguments.length) {
      domain2 = numbers(_);
      return scale2;
    } else {
      return domain2.slice();
    }
  };
  scale2.range = function(_) {
    if (arguments.length) {
      range2 = slice$3.call(_);
      return scale2;
    } else {
      return range2.slice();
    }
  };
  scale2.tickFormat = function(count2, specifier) {
    return tickFormat$1(domain2[0], peek$2(domain2), count2 == null ? 10 : count2, specifier);
  };
  scale2.copy = function() {
    return scaleBinOrdinal().domain(scale2.domain()).range(scale2.range());
  };
  return scale2;
}
const scales = {};
function create$2(type2, constructor, metadata2) {
  const ctr = function scale2() {
    const s = constructor();
    if (!s.invertRange) {
      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : void 0;
    }
    s.type = type2;
    return s;
  };
  ctr.metadata = toSet(array$5(metadata2));
  return ctr;
}
function scale$4(type2, scale2, metadata2) {
  if (arguments.length > 1) {
    scales[type2] = create$2(type2, scale2, metadata2);
    return this;
  } else {
    return isValidScaleType(type2) ? scales[type2] : void 0;
  }
}
scale$4(Identity, identity$1);
scale$4(Linear, linear$1, Continuous);
scale$4(Log, log$3, [Continuous, Log]);
scale$4(Pow, pow$2, Continuous);
scale$4(Sqrt, sqrt$2, Continuous);
scale$4(Symlog, symlog, Continuous);
scale$4(Time, time$1, [Continuous, Temporal]);
scale$4(UTC, utcTime, [Continuous, Temporal]);
scale$4(Sequential, sequential, [Continuous, Interpolating]);
scale$4("".concat(Sequential, "-").concat(Linear), sequential, [Continuous, Interpolating]);
scale$4("".concat(Sequential, "-").concat(Log), sequentialLog, [Continuous, Interpolating, Log]);
scale$4("".concat(Sequential, "-").concat(Pow), sequentialPow, [Continuous, Interpolating]);
scale$4("".concat(Sequential, "-").concat(Sqrt), sequentialSqrt, [Continuous, Interpolating]);
scale$4("".concat(Sequential, "-").concat(Symlog), sequentialSymlog, [Continuous, Interpolating]);
scale$4("".concat(Diverging, "-").concat(Linear), diverging, [Continuous, Interpolating]);
scale$4("".concat(Diverging, "-").concat(Log), divergingLog, [Continuous, Interpolating, Log]);
scale$4("".concat(Diverging, "-").concat(Pow), divergingPow, [Continuous, Interpolating]);
scale$4("".concat(Diverging, "-").concat(Sqrt), divergingSqrt, [Continuous, Interpolating]);
scale$4("".concat(Diverging, "-").concat(Symlog), divergingSymlog, [Continuous, Interpolating]);
scale$4(Quantile, quantile, [Discretizing, Quantile]);
scale$4(Quantize, quantize$1, Discretizing);
scale$4(Threshold, threshold, Discretizing);
scale$4(BinOrdinal, scaleBinOrdinal, [Discrete$1, Discretizing]);
scale$4(Ordinal, ordinal, Discrete$1);
scale$4(Band, band, Discrete$1);
scale$4(Point, point$3, Discrete$1);
function isValidScaleType(type2) {
  return has$2(scales, type2);
}
function hasType(key2, type2) {
  const s = scales[key2];
  return s && s.metadata[type2];
}
function isContinuous$1(key2) {
  return hasType(key2, Continuous);
}
function isDiscrete$2(key2) {
  return hasType(key2, Discrete$1);
}
function isDiscretizing$1(key2) {
  return hasType(key2, Discretizing);
}
function isLogarithmic(key2) {
  return hasType(key2, Log);
}
function isTemporal(key2) {
  return hasType(key2, Temporal);
}
function isInterpolating(key2) {
  return hasType(key2, Interpolating);
}
function isQuantile$1(key2) {
  return hasType(key2, Quantile);
}
const scaleProps = ["clamp", "base", "constant", "exponent"];
function interpolateRange$1(interpolator, range2) {
  const start = range2[0], span2 = peek$2(range2) - start;
  return function(i) {
    return interpolator(start + i * span2);
  };
}
function interpolateColors(colors2, type2, gamma2) {
  return piecewise$1(interpolate$2(type2 || "rgb", gamma2), colors2);
}
function quantizeInterpolator(interpolator, count2) {
  const samples = new Array(count2), n = count2 + 1;
  for (let i = 0; i < count2; ) samples[i] = interpolator(++i / n);
  return samples;
}
function scaleFraction(scale$12, min2, max2) {
  const delta = max2 - min2;
  let i, t4, s;
  if (!delta || !Number.isFinite(delta)) {
    return constant$5(0.5);
  } else {
    i = (t4 = scale$12.type).indexOf("-");
    t4 = i < 0 ? t4 : t4.slice(i + 1);
    s = scale$4(t4)().domain([min2, max2]).range([0, 1]);
    scaleProps.forEach((m2) => scale$12[m2] ? s[m2](scale$12[m2]()) : 0);
    return s;
  }
}
function interpolate$2(type2, gamma2) {
  const interp = $$1[method(type2)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method(type2) {
  return "interpolate" + type2.toLowerCase().split("-").map((s) => s[0].toUpperCase() + s.slice(1)).join("");
}
const continuous = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
const discrete = {
  category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
  accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
  dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
  paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
  pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
  pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
  set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
  set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
  set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
};
function colors(palette) {
  const n = palette.length / 6 | 0, c2 = new Array(n);
  for (let i = 0; i < n; ) {
    c2[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c2;
}
function apply$1(_, f) {
  for (const k in _) scheme$1(k, f(_[k]));
}
const schemes = {};
apply$1(discrete, colors);
apply$1(continuous, (_) => interpolateColors(colors(_)));
function scheme$1(name, scheme2) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes[name] = scheme2;
    return this;
  } else {
    return schemes[name];
  }
}
const SymbolLegend = "symbol";
const DiscreteLegend = "discrete";
const GradientLegend = "gradient";
const defaultFormatter = (value2) => isArray$1(value2) ? value2.map((v) => String(v)) : String(value2);
const ascending$1 = (a2, b2) => a2[1] - b2[1];
const descending = (a2, b2) => b2[1] - a2[1];
function tickCount(scale2, count2, minStep) {
  let step;
  if (isNumber$1(count2)) {
    if (scale2.bins) {
      count2 = Math.max(count2, scale2.bins.length);
    }
    if (minStep != null) {
      count2 = Math.min(count2, Math.floor(span(scale2.domain()) / minStep || 1));
    }
  }
  if (isObject$1(count2)) {
    step = count2.step;
    count2 = count2.interval;
  }
  if (isString(count2)) {
    count2 = scale2.type === Time ? timeInterval(count2) : scale2.type == UTC ? utcInterval(count2) : error("Only time and utc scales accept interval strings.");
    if (step) count2 = count2.every(step);
  }
  return count2;
}
function validTicks(scale2, ticks2, count2) {
  let range2 = scale2.range(), lo = range2[0], hi = peek$2(range2), cmp2 = ascending$1;
  if (lo > hi) {
    range2 = hi;
    hi = lo;
    lo = range2;
    cmp2 = descending;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks2 = ticks2.map((v) => [v, scale2(v)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp2).map((_) => _[0]);
  if (count2 > 0 && ticks2.length > 1) {
    const endpoints = [ticks2[0], peek$2(ticks2)];
    while (ticks2.length > count2 && ticks2.length >= 3) {
      ticks2 = ticks2.filter((_, i) => !(i % 2));
    }
    if (ticks2.length < 3) {
      ticks2 = endpoints;
    }
  }
  return ticks2;
}
function tickValues(scale2, count2) {
  return scale2.bins ? validTicks(scale2, scale2.bins) : scale2.ticks ? scale2.ticks(count2) : scale2.domain();
}
function tickFormat(locale2, scale2, count2, specifier, formatType, noSkip) {
  const type2 = scale2.type;
  let format2 = defaultFormatter;
  if (type2 === Time || formatType === Time) {
    format2 = locale2.timeFormat(specifier);
  } else if (type2 === UTC || formatType === UTC) {
    format2 = locale2.utcFormat(specifier);
  } else if (isLogarithmic(type2)) {
    const varfmt = locale2.formatFloat(specifier);
    if (noSkip || scale2.bins) {
      format2 = varfmt;
    } else {
      const test2 = tickLog(scale2, count2, false);
      format2 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale2.tickFormat) {
    const d = scale2.domain();
    format2 = locale2.formatSpan(d[0], d[d.length - 1], count2, specifier);
  } else if (specifier) {
    format2 = locale2.format(specifier);
  }
  return format2;
}
function tickLog(scale2, count2, values2) {
  const ticks2 = tickValues(scale2, count2), base2 = scale2.base(), logb = Math.log(base2), k = Math.max(1, base2 * count2 / ticks2.length);
  const test2 = (d) => {
    let i = d / Math.pow(base2, Math.round(Math.log(d) / logb));
    if (i * base2 < base2 - 0.5) i *= base2;
    return i <= k;
  };
  return values2 ? ticks2.filter(test2) : test2;
}
const symbols$2 = {
  [Quantile]: "quantiles",
  [Quantize]: "thresholds",
  [Threshold]: "domain"
};
const formats = {
  [Quantile]: "quantiles",
  [Quantize]: "domain"
};
function labelValues(scale2, count2) {
  return scale2.bins ? binValues(scale2.bins) : scale2.type === Log ? tickLog(scale2, count2, true) : symbols$2[scale2.type] ? thresholdValues(scale2[symbols$2[scale2.type]]()) : tickValues(scale2, count2);
}
function thresholdFormat(locale2, scale2, specifier) {
  const _ = scale2[formats[scale2.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale2.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues(thresholds) {
  const values2 = [-Infinity].concat(thresholds);
  values2.max = Infinity;
  return values2;
}
function binValues(bins2) {
  const values2 = bins2.slice(0, -1);
  values2.max = peek$2(bins2);
  return values2;
}
const isDiscreteRange = (scale2) => symbols$2[scale2.type] || scale2.bins;
function labelFormat(locale2, scale2, count2, type2, specifier, formatType, noSkip) {
  const format2 = formats[scale2.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale2, scale2, specifier) : tickFormat(locale2, scale2, count2, specifier, formatType, noSkip);
  return type2 === SymbolLegend && isDiscreteRange(scale2) ? formatRange(format2) : type2 === DiscreteLegend ? formatDiscrete(format2) : formatPoint(format2);
}
const formatRange = (format2) => (value2, index2, array2) => {
  const limit = get$4(array2[index2 + 1], get$4(array2.max, Infinity)), lo = formatValue$2(value2, format2), hi = formatValue$2(limit, format2);
  return lo && hi ? lo + " – " + hi : hi ? "< " + hi : "≥ " + lo;
};
const get$4 = (value2, dflt) => value2 != null ? value2 : dflt;
const formatDiscrete = (format2) => (value2, index2) => index2 ? format2(value2) : null;
const formatPoint = (format2) => (value2) => format2(value2);
const formatValue$2 = (value2, format2) => Number.isFinite(value2) ? format2(value2) : null;
function labelFraction(scale2) {
  const domain2 = scale2.domain(), count2 = domain2.length - 1;
  let lo = +domain2[0], hi = +peek$2(domain2), span2 = hi - lo;
  if (scale2.type === Threshold) {
    const adjust = count2 ? span2 / count2 : 0.1;
    lo -= adjust;
    hi += adjust;
    span2 = hi - lo;
  }
  return (value2) => (value2 - lo) / span2;
}
function format$1(locale2, scale2, specifier, formatType) {
  const type2 = formatType || scale2.type;
  if (isString(specifier) && isTemporal(type2)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type2 === Time ? locale2.timeFormat("%A, %d %B %Y, %X") : !specifier && type2 === UTC ? locale2.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat(locale2, scale2, 5, null, specifier, formatType, true);
}
function domainCaption(locale2, scale2, opt) {
  opt = opt || {};
  const max2 = Math.max(3, opt.maxlen || 7), fmt = format$1(locale2, scale2, opt.format, opt.formatType);
  if (isDiscretizing$1(scale2.type)) {
    const v = labelValues(scale2).slice(1).map(fmt), n = v.length;
    return "".concat(n, " boundar").concat(n === 1 ? "y" : "ies", ": ").concat(v.join(", "));
  } else if (isDiscrete$2(scale2.type)) {
    const d = scale2.domain(), n = d.length, v = n > max2 ? d.slice(0, max2 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return "".concat(n, " value").concat(n === 1 ? "" : "s", ": ").concat(v);
  } else {
    const d = scale2.domain();
    return "values from ".concat(fmt(d[0]), " to ").concat(fmt(peek$2(d)));
  }
}
let gradient_id = 0;
function resetSVGGradientId() {
  gradient_id = 0;
}
const patternPrefix = "p_";
function isGradient(value2) {
  return value2 && value2.gradient;
}
function gradientRef(g, defs, base2) {
  const type2 = g.gradient;
  let id2 = g.id, prefix2 = type2 === "radial" ? patternPrefix : "";
  if (!id2) {
    id2 = g.id = "gradient_" + gradient_id++;
    if (type2 === "radial") {
      g.x1 = get$3(g.x1, 0.5);
      g.y1 = get$3(g.y1, 0.5);
      g.r1 = get$3(g.r1, 0);
      g.x2 = get$3(g.x2, 0.5);
      g.y2 = get$3(g.y2, 0.5);
      g.r2 = get$3(g.r2, 0.5);
      prefix2 = patternPrefix;
    } else {
      g.x1 = get$3(g.x1, 0);
      g.y1 = get$3(g.y1, 0);
      g.x2 = get$3(g.x2, 1);
      g.y2 = get$3(g.y2, 0);
    }
  }
  defs[id2] = g;
  return "url(" + (base2 || "") + "#" + prefix2 + id2 + ")";
}
function get$3(val, def2) {
  return val != null ? val : def2;
}
function Gradient$1(p02, p1) {
  var stops = [], gradient2;
  return gradient2 = {
    gradient: "linear",
    x1: p02 ? p02[0] : 0,
    y1: p02 ? p02[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops,
    stop: function(offset2, color2) {
      stops.push({
        offset: offset2,
        color: color2
      });
      return gradient2;
    }
  };
}
const lookup$4 = {
  "basis": {
    curve: curveBasis
  },
  "basis-closed": {
    curve: curveBasisClosed
  },
  "basis-open": {
    curve: curveBasisOpen
  },
  "bundle": {
    curve: curveBundle,
    tension: "beta",
    value: 0.85
  },
  "cardinal": {
    curve: curveCardinal,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: curveCardinalOpen,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: curveCardinalClosed,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: curveCatmullRom,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: curveCatmullRomClosed,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: curveCatmullRomOpen,
    tension: "alpha",
    value: 0.5
  },
  "linear": {
    curve: curveLinear
  },
  "linear-closed": {
    curve: curveLinearClosed
  },
  "monotone": {
    horizontal: monotoneY,
    vertical: monotoneX
  },
  "natural": {
    curve: curveNatural
  },
  "step": {
    curve: curveStep
  },
  "step-after": {
    curve: stepAfter
  },
  "step-before": {
    curve: stepBefore
  }
};
function curves(type2, orientation, tension) {
  var entry2 = has$2(lookup$4, type2) && lookup$4[type2], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
const paramCounts = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
const commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
const numberPattern = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
const spacePattern = /^((\s+,?\s*)|(,\s*))/;
const flagPattern = /^[01]/;
function parse$4(path2) {
  const commands = [];
  const matches = path2.match(commandPattern) || [];
  matches.forEach((str) => {
    let cmd = str[0];
    const type2 = cmd.toLowerCase();
    const paramCount = paramCounts[type2];
    const params2 = parseParams(type2, paramCount, str.slice(1).trim());
    const count2 = params2.length;
    if (count2 < paramCount || count2 && count2 % paramCount !== 0) {
      throw Error("Invalid SVG path, incorrect parameter count");
    }
    commands.push([cmd, ...params2.slice(0, paramCount)]);
    if (count2 === paramCount) {
      return;
    }
    if (type2 === "m") {
      cmd = cmd === "M" ? "L" : "l";
    }
    for (let i = paramCount; i < count2; i += paramCount) {
      commands.push([cmd, ...params2.slice(i, i + paramCount)]);
    }
  });
  return commands;
}
function parseParams(type2, paramCount, segment) {
  const params2 = [];
  for (let index2 = 0; paramCount && index2 < segment.length; ) {
    for (let i = 0; i < paramCount; ++i) {
      const pattern = type2 === "a" && (i === 3 || i === 4) ? flagPattern : numberPattern;
      const match2 = segment.slice(index2).match(pattern);
      if (match2 === null) {
        throw Error("Invalid SVG path, incorrect parameter type");
      }
      index2 += match2[0].length;
      params2.push(+match2[0]);
      const ws = segment.slice(index2).match(spacePattern);
      if (ws !== null) {
        index2 += ws[0].length;
      }
    }
  }
  return params2;
}
const DegToRad = Math.PI / 180;
const Epsilon = 1e-14;
const HalfPi = Math.PI / 2;
const Tau = Math.PI * 2;
const HalfSqrt3 = Math.sqrt(3) / 2;
var segmentCache = {};
var bezierCache = {};
var join$1 = [].join;
function segments(x2, y2, rx, ry, large, sweep, rotateX, ox, oy) {
  const key2 = join$1.call(arguments);
  if (segmentCache[key2]) {
    return segmentCache[key2];
  }
  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px2 = cos_th * (ox - x2) * 0.5 + sin_th * (oy - y2) * 0.5;
  const py2 = cos_th * (oy - y2) * 0.5 - sin_th * (ox - x2) * 0.5;
  let pl = px2 * px2 / (rx * rx) + py2 * py2 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x02 = a00 * ox + a01 * oy;
  const y02 = a10 * ox + a11 * oy;
  const x12 = a00 * x2 + a01 * y2;
  const y12 = a10 * x2 + a11 * y2;
  const d = (x12 - x02) * (x12 - x02) + (y12 - y02) * (y12 - y02);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large) sfactor = -sfactor;
  const xc = 0.5 * (x02 + x12) - sfactor * (y12 - y02);
  const yc = 0.5 * (y02 + y12) + sfactor * (x12 - x02);
  const th0 = Math.atan2(y02 - yc, x02 - xc);
  const th1 = Math.atan2(y12 - yc, x12 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache[key2] = result;
}
function bezier(params2) {
  const key2 = join$1.call(params2);
  if (bezierCache[key2]) {
    return bezierCache[key2];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t4 = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x12 = cx + cos_th0 - t4 * sin_th0;
  const y12 = cy + sin_th0 + t4 * cos_th0;
  const x3 = cx + cos_th1;
  const y3 = cy + sin_th1;
  const x2 = x3 + t4 * sin_th1;
  const y2 = y3 - t4 * cos_th1;
  return bezierCache[key2] = [a00 * x12 + a01 * y12, a10 * x12 + a11 * y12, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}
const temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$1$1(current2, sX, sY) {
  const c2 = temp[0] = current2[0];
  if (c2 === "a" || c2 === "A") {
    temp[1] = sX * current2[1];
    temp[2] = sY * current2[2];
    temp[3] = current2[3];
    temp[4] = current2[4];
    temp[5] = current2[5];
    temp[6] = sX * current2[6];
    temp[7] = sY * current2[7];
  } else if (c2 === "h" || c2 === "H") {
    temp[1] = sX * current2[1];
  } else if (c2 === "v" || c2 === "V") {
    temp[1] = sY * current2[1];
  } else {
    for (var i = 1, n = current2.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current2[i];
    }
  }
  return temp;
}
function pathRender(context2, path2, l, t4, sX, sY) {
  var current2, previous = null, x2 = 0, y2 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY, anchorX = 0, anchorY = 0;
  if (l == null) l = 0;
  if (t4 == null) t4 = 0;
  if (sX == null) sX = 1;
  if (sY == null) sY = sX;
  if (context2.beginPath) context2.beginPath();
  for (var i = 0, len = path2.length; i < len; ++i) {
    current2 = path2[i];
    if (sX !== 1 || sY !== 1) {
      current2 = scale$1$1(current2, sX, sY);
    }
    switch (current2[0]) {
      // first letter
      case "l":
        x2 += current2[1];
        y2 += current2[2];
        context2.lineTo(x2 + l, y2 + t4);
        break;
      case "L":
        x2 = current2[1];
        y2 = current2[2];
        context2.lineTo(x2 + l, y2 + t4);
        break;
      case "h":
        x2 += current2[1];
        context2.lineTo(x2 + l, y2 + t4);
        break;
      case "H":
        x2 = current2[1];
        context2.lineTo(x2 + l, y2 + t4);
        break;
      case "v":
        y2 += current2[1];
        context2.lineTo(x2 + l, y2 + t4);
        break;
      case "V":
        y2 = current2[1];
        context2.lineTo(x2 + l, y2 + t4);
        break;
      case "m":
        x2 += current2[1];
        y2 += current2[2];
        anchorX = x2;
        anchorY = y2;
        context2.moveTo(x2 + l, y2 + t4);
        break;
      case "M":
        x2 = current2[1];
        y2 = current2[2];
        anchorX = x2;
        anchorY = y2;
        context2.moveTo(x2 + l, y2 + t4);
        break;
      case "c":
        tempX = x2 + current2[5];
        tempY = y2 + current2[6];
        controlX = x2 + current2[3];
        controlY = y2 + current2[4];
        context2.bezierCurveTo(
          x2 + current2[1] + l,
          // x1
          y2 + current2[2] + t4,
          // y1
          controlX + l,
          // x2
          controlY + t4,
          // y2
          tempX + l,
          tempY + t4
        );
        x2 = tempX;
        y2 = tempY;
        break;
      case "C":
        x2 = current2[5];
        y2 = current2[6];
        controlX = current2[3];
        controlY = current2[4];
        context2.bezierCurveTo(current2[1] + l, current2[2] + t4, controlX + l, controlY + t4, x2 + l, y2 + t4);
        break;
      case "s":
        tempX = x2 + current2[3];
        tempY = y2 + current2[4];
        controlX = 2 * x2 - controlX;
        controlY = 2 * y2 - controlY;
        context2.bezierCurveTo(controlX + l, controlY + t4, x2 + current2[1] + l, y2 + current2[2] + t4, tempX + l, tempY + t4);
        controlX = x2 + current2[1];
        controlY = y2 + current2[2];
        x2 = tempX;
        y2 = tempY;
        break;
      case "S":
        tempX = current2[3];
        tempY = current2[4];
        controlX = 2 * x2 - controlX;
        controlY = 2 * y2 - controlY;
        context2.bezierCurveTo(controlX + l, controlY + t4, current2[1] + l, current2[2] + t4, tempX + l, tempY + t4);
        x2 = tempX;
        y2 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "q":
        tempX = x2 + current2[3];
        tempY = y2 + current2[4];
        controlX = x2 + current2[1];
        controlY = y2 + current2[2];
        context2.quadraticCurveTo(controlX + l, controlY + t4, tempX + l, tempY + t4);
        x2 = tempX;
        y2 = tempY;
        break;
      case "Q":
        tempX = current2[3];
        tempY = current2[4];
        context2.quadraticCurveTo(current2[1] + l, current2[2] + t4, tempX + l, tempY + t4);
        x2 = tempX;
        y2 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "t":
        tempX = x2 + current2[1];
        tempY = y2 + current2[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x2;
          controlY = y2;
        } else if (previous[0] === "t") {
          controlX = 2 * x2 - tempControlX;
          controlY = 2 * y2 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x2 - controlX;
          controlY = 2 * y2 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context2.quadraticCurveTo(controlX + l, controlY + t4, tempX + l, tempY + t4);
        x2 = tempX;
        y2 = tempY;
        controlX = x2 + current2[1];
        controlY = y2 + current2[2];
        break;
      case "T":
        tempX = current2[1];
        tempY = current2[2];
        controlX = 2 * x2 - controlX;
        controlY = 2 * y2 - controlY;
        context2.quadraticCurveTo(controlX + l, controlY + t4, tempX + l, tempY + t4);
        x2 = tempX;
        y2 = tempY;
        break;
      case "a":
        drawArc(context2, x2 + l, y2 + t4, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x2 + l, current2[7] + y2 + t4]);
        x2 += current2[6];
        y2 += current2[7];
        break;
      case "A":
        drawArc(context2, x2 + l, y2 + t4, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t4]);
        x2 = current2[6];
        y2 = current2[7];
        break;
      case "z":
      case "Z":
        x2 = anchorX;
        y2 = anchorY;
        context2.closePath();
        break;
    }
    previous = current2;
  }
}
function drawArc(context2, x2, y2, coords) {
  const seg = segments(
    coords[5],
    // end x
    coords[6],
    // end y
    coords[0],
    // radius x
    coords[1],
    // radius y
    coords[3],
    // large flag
    coords[4],
    // sweep flag
    coords[2],
    // rotation
    x2,
    y2
  );
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context2.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
const Tan30 = 0.5773502691896257;
const builtins = {
  "circle": {
    draw: function(context2, size) {
      const r2 = Math.sqrt(size) / 2;
      context2.moveTo(r2, 0);
      context2.arc(0, 0, r2, 0, Tau);
    }
  },
  "cross": {
    draw: function(context2, size) {
      var r2 = Math.sqrt(size) / 2, s = r2 / 2.5;
      context2.moveTo(-r2, -s);
      context2.lineTo(-r2, s);
      context2.lineTo(-s, s);
      context2.lineTo(-s, r2);
      context2.lineTo(s, r2);
      context2.lineTo(s, s);
      context2.lineTo(r2, s);
      context2.lineTo(r2, -s);
      context2.lineTo(s, -s);
      context2.lineTo(s, -r2);
      context2.lineTo(-s, -r2);
      context2.lineTo(-s, -s);
      context2.closePath();
    }
  },
  "diamond": {
    draw: function(context2, size) {
      const r2 = Math.sqrt(size) / 2;
      context2.moveTo(-r2, 0);
      context2.lineTo(0, -r2);
      context2.lineTo(r2, 0);
      context2.lineTo(0, r2);
      context2.closePath();
    }
  },
  "square": {
    draw: function(context2, size) {
      var w2 = Math.sqrt(size), x2 = -w2 / 2;
      context2.rect(x2, x2, w2, w2);
    }
  },
  "arrow": {
    draw: function(context2, size) {
      var r2 = Math.sqrt(size) / 2, s = r2 / 7, t4 = r2 / 2.5, v = r2 / 8;
      context2.moveTo(-s, r2);
      context2.lineTo(s, r2);
      context2.lineTo(s, -v);
      context2.lineTo(t4, -v);
      context2.lineTo(0, -r2);
      context2.lineTo(-t4, -v);
      context2.lineTo(-s, -v);
      context2.closePath();
    }
  },
  "wedge": {
    draw: function(context2, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2, o = h2 - r2 * Tan30, b2 = r2 / 4;
      context2.moveTo(0, -h2 - o);
      context2.lineTo(-b2, h2 - o);
      context2.lineTo(b2, h2 - o);
      context2.closePath();
    }
  },
  "triangle": {
    draw: function(context2, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2, o = h2 - r2 * Tan30;
      context2.moveTo(0, -h2 - o);
      context2.lineTo(-r2, h2 - o);
      context2.lineTo(r2, h2 - o);
      context2.closePath();
    }
  },
  "triangle-up": {
    draw: function(context2, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2;
      context2.moveTo(0, -h2);
      context2.lineTo(-r2, h2);
      context2.lineTo(r2, h2);
      context2.closePath();
    }
  },
  "triangle-down": {
    draw: function(context2, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2;
      context2.moveTo(0, h2);
      context2.lineTo(-r2, -h2);
      context2.lineTo(r2, -h2);
      context2.closePath();
    }
  },
  "triangle-right": {
    draw: function(context2, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2;
      context2.moveTo(h2, 0);
      context2.lineTo(-h2, -r2);
      context2.lineTo(-h2, r2);
      context2.closePath();
    }
  },
  "triangle-left": {
    draw: function(context2, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2;
      context2.moveTo(-h2, 0);
      context2.lineTo(h2, -r2);
      context2.lineTo(h2, r2);
      context2.closePath();
    }
  },
  "stroke": {
    draw: function(context2, size) {
      const r2 = Math.sqrt(size) / 2;
      context2.moveTo(-r2, 0);
      context2.lineTo(r2, 0);
    }
  }
};
function symbols$1(_) {
  return has$2(builtins, _) ? builtins[_] : customSymbol(_);
}
var custom$1 = {};
function customSymbol(path2) {
  if (!has$2(custom$1, path2)) {
    const parsed = parse$4(path2);
    custom$1[path2] = {
      draw: function(context2, size) {
        pathRender(context2, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom$1[path2];
}
const C = 0.448084975506;
function rectangleX(d) {
  return d.x;
}
function rectangleY(d) {
  return d.y;
}
function rectangleWidth(d) {
  return d.width;
}
function rectangleHeight(d) {
  return d.height;
}
function number$4(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp$1(value2, min2, max2) {
  return Math.max(min2, Math.min(value2, max2));
}
function vg_rect() {
  var x2 = rectangleX, y2 = rectangleY, width2 = rectangleWidth, height2 = rectangleHeight, crTL = number$4(0), crTR = crTL, crBL = crTL, crBR = crTL, context2 = null;
  function rectangle2(_, x02, y02) {
    var buffer, x12 = x02 != null ? x02 : +x2.call(this, _), y12 = y02 != null ? y02 : +y2.call(this, _), w2 = +width2.call(this, _), h2 = +height2.call(this, _), s = Math.min(w2, h2) / 2, tl2 = clamp$1(+crTL.call(this, _), 0, s), tr2 = clamp$1(+crTR.call(this, _), 0, s), bl2 = clamp$1(+crBL.call(this, _), 0, s), br2 = clamp$1(+crBR.call(this, _), 0, s);
    if (!context2) context2 = buffer = path$3();
    if (tl2 <= 0 && tr2 <= 0 && bl2 <= 0 && br2 <= 0) {
      context2.rect(x12, y12, w2, h2);
    } else {
      var x22 = x12 + w2, y22 = y12 + h2;
      context2.moveTo(x12 + tl2, y12);
      context2.lineTo(x22 - tr2, y12);
      context2.bezierCurveTo(x22 - C * tr2, y12, x22, y12 + C * tr2, x22, y12 + tr2);
      context2.lineTo(x22, y22 - br2);
      context2.bezierCurveTo(x22, y22 - C * br2, x22 - C * br2, y22, x22 - br2, y22);
      context2.lineTo(x12 + bl2, y22);
      context2.bezierCurveTo(x12 + C * bl2, y22, x12, y22 - C * bl2, x12, y22 - bl2);
      context2.lineTo(x12, y12 + tl2);
      context2.bezierCurveTo(x12, y12 + C * tl2, x12 + C * tl2, y12, x12 + tl2, y12);
      context2.closePath();
    }
    if (buffer) {
      context2 = null;
      return buffer + "" || null;
    }
  }
  rectangle2.x = function(_) {
    if (arguments.length) {
      x2 = number$4(_);
      return rectangle2;
    } else {
      return x2;
    }
  };
  rectangle2.y = function(_) {
    if (arguments.length) {
      y2 = number$4(_);
      return rectangle2;
    } else {
      return y2;
    }
  };
  rectangle2.width = function(_) {
    if (arguments.length) {
      width2 = number$4(_);
      return rectangle2;
    } else {
      return width2;
    }
  };
  rectangle2.height = function(_) {
    if (arguments.length) {
      height2 = number$4(_);
      return rectangle2;
    } else {
      return height2;
    }
  };
  rectangle2.cornerRadius = function(tl2, tr2, br2, bl2) {
    if (arguments.length) {
      crTL = number$4(tl2);
      crTR = tr2 != null ? number$4(tr2) : crTL;
      crBR = br2 != null ? number$4(br2) : crTL;
      crBL = bl2 != null ? number$4(bl2) : crTR;
      return rectangle2;
    } else {
      return crTL;
    }
  };
  rectangle2.context = function(_) {
    if (arguments.length) {
      context2 = _ == null ? null : _;
      return rectangle2;
    } else {
      return context2;
    }
  };
  return rectangle2;
}
function vg_trail() {
  var x2, y2, size, defined2, context2 = null, ready, x12, y12, r1;
  function point2(x22, y22, w2) {
    const r2 = w2 / 2;
    if (ready) {
      var ux = y12 - y22, uy = x22 - x12;
      if (ux || uy) {
        var ud = Math.sqrt(ux * ux + uy * uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t4 = Math.atan2(uy, ux);
        context2.moveTo(x12 - rx, y12 - ry);
        context2.lineTo(x22 - ux * r2, y22 - uy * r2);
        context2.arc(x22, y22, r2, t4 - Math.PI, t4);
        context2.lineTo(x12 + rx, y12 + ry);
        context2.arc(x12, y12, r1, t4, t4 + Math.PI);
      } else {
        context2.arc(x22, y22, r2, 0, Tau);
      }
      context2.closePath();
    } else {
      ready = 1;
    }
    x12 = x22;
    y12 = y22;
    r1 = r2;
  }
  function trail2(data2) {
    var i, n = data2.length, d, defined0 = false, buffer;
    if (context2 == null) context2 = buffer = path$3();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0) ready = 0;
      }
      if (defined0) point2(+x2(d, i, data2), +y2(d, i, data2), +size(d, i, data2));
    }
    if (buffer) {
      context2 = null;
      return buffer + "" || null;
    }
  }
  trail2.x = function(_) {
    if (arguments.length) {
      x2 = _;
      return trail2;
    } else {
      return x2;
    }
  };
  trail2.y = function(_) {
    if (arguments.length) {
      y2 = _;
      return trail2;
    } else {
      return y2;
    }
  };
  trail2.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail2;
    } else {
      return size;
    }
  };
  trail2.defined = function(_) {
    if (arguments.length) {
      defined2 = _;
      return trail2;
    } else {
      return defined2;
    }
  };
  trail2.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context2 = null;
      } else {
        context2 = _;
      }
      return trail2;
    } else {
      return context2;
    }
  };
  return trail2;
}
function value$1(a2, b2) {
  return a2 != null ? a2 : b2;
}
const x$2 = (item) => item.x || 0, y$2 = (item) => item.y || 0, w$1 = (item) => item.width || 0, h = (item) => item.height || 0, xw = (item) => (item.x || 0) + (item.width || 0), yh = (item) => (item.y || 0) + (item.height || 0), sa = (item) => item.startAngle || 0, ea = (item) => item.endAngle || 0, pa = (item) => item.padAngle || 0, ir = (item) => item.innerRadius || 0, or = (item) => item.outerRadius || 0, cr = (item) => item.cornerRadius || 0, tl = (item) => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0, tr = (item) => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0, br = (item) => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0, bl = (item) => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0, sz = (item) => value$1(item.size, 64), ts = (item) => item.size || 1, def = (item) => !(item.defined === false), type$1 = (item) => symbols$1(item.shape || "circle");
const arcShape = arc$2$1().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr), areavShape = area$2$1().x(x$2).y1(y$2).y0(yh).defined(def), areahShape = area$2$1().y(y$2).x1(x$2).x0(xw).defined(def), lineShape = line$2$1().x(x$2).y(y$2).defined(def), rectShape = vg_rect().x(x$2).y(y$2).width(w$1).height(h).cornerRadius(tl, tr, br, bl), symbolShape = Symbol$2().type(type$1).size(sz), trailShape = vg_trail().x(x$2).y(y$2).defined(def).size(ts);
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$1$1(context2, item) {
  return arcShape.context(context2)(item);
}
function area$1$1(context2, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context2)(items);
}
function line$1$1(context2, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context2)(items);
}
function rectangle(context2, item, x2, y2) {
  return rectShape.context(context2)(item, x2, y2);
}
function shape$1(context2, item) {
  return (item.mark.shape || item.shape).context(context2)(item);
}
function symbol$1(context2, item) {
  return symbolShape.context(context2)(item);
}
function trail$1(context2, items) {
  return trailShape.context(context2)(items);
}
var clip_id = 1;
function resetSVGClipId() {
  clip_id = 1;
}
function clip$1$1(renderer, item, size) {
  var clip2 = item.clip, defs = renderer._defs, id2 = item.clip_id || (item.clip_id = "clip" + clip_id++), c2 = defs.clipping[id2] || (defs.clipping[id2] = {
    id: id2
  });
  if (isFunction$3(clip2)) {
    c2.path = clip2(null);
  } else if (hasCornerRadius(size)) {
    c2.path = rectangle(null, size, 0, 0);
  } else {
    c2.width = size.width || 0;
    c2.height = size.height || 0;
  }
  return "url(#" + id2 + ")";
}
function Bounds(b2) {
  this.clear();
  if (b2) this.union(b2);
}
Bounds.prototype = {
  clone() {
    return new Bounds(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b2) {
    return this.x1 === b2.x1 && this.y1 === b2.y1 && this.x2 === b2.x2 && this.y2 === b2.y2;
  },
  set(x12, y12, x2, y2) {
    if (x2 < x12) {
      this.x2 = x12;
      this.x1 = x2;
    } else {
      this.x1 = x12;
      this.x2 = x2;
    }
    if (y2 < y12) {
      this.y2 = y12;
      this.y1 = y2;
    } else {
      this.y1 = y12;
      this.y2 = y2;
    }
    return this;
  },
  add(x2, y2) {
    if (x2 < this.x1) this.x1 = x2;
    if (y2 < this.y1) this.y1 = y2;
    if (x2 > this.x2) this.x2 = x2;
    if (y2 > this.y2) this.y2 = y2;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s) {
    this.x1 *= s;
    this.y1 *= s;
    this.x2 *= s;
    this.y2 *= s;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle2, x2, y2) {
    const p = this.rotatedPoints(angle2, x2, y2);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle2, x2, y2) {
    var {
      x1: x12,
      y1: y12,
      x2: x22,
      y2: y22
    } = this, cos2 = Math.cos(angle2), sin2 = Math.sin(angle2), cx = x2 - x2 * cos2 + y2 * sin2, cy = y2 - x2 * sin2 - y2 * cos2;
    return [cos2 * x12 - sin2 * y12 + cx, sin2 * x12 + cos2 * y12 + cy, cos2 * x12 - sin2 * y22 + cx, sin2 * x12 + cos2 * y22 + cy, cos2 * x22 - sin2 * y12 + cx, sin2 * x22 + cos2 * y12 + cy, cos2 * x22 - sin2 * y22 + cx, sin2 * x22 + cos2 * y22 + cy];
  },
  union(b2) {
    if (b2.x1 < this.x1) this.x1 = b2.x1;
    if (b2.y1 < this.y1) this.y1 = b2.y1;
    if (b2.x2 > this.x2) this.x2 = b2.x2;
    if (b2.y2 > this.y2) this.y2 = b2.y2;
    return this;
  },
  intersect(b2) {
    if (b2.x1 > this.x1) this.x1 = b2.x1;
    if (b2.y1 > this.y1) this.y1 = b2.y1;
    if (b2.x2 < this.x2) this.x2 = b2.x2;
    if (b2.y2 < this.y2) this.y2 = b2.y2;
    return this;
  },
  encloses(b2) {
    return b2 && this.x1 <= b2.x1 && this.x2 >= b2.x2 && this.y1 <= b2.y1 && this.y2 >= b2.y2;
  },
  alignsWith(b2) {
    return b2 && (this.x1 == b2.x1 || this.x2 == b2.x2 || this.y1 == b2.y1 || this.y2 == b2.y2);
  },
  intersects(b2) {
    return b2 && !(this.x2 < b2.x1 || this.x1 > b2.x2 || this.y2 < b2.y1 || this.y1 > b2.y2);
  },
  contains(x2, y2) {
    return !(x2 < this.x1 || x2 > this.x2 || y2 < this.y1 || y2 > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Item(mark2) {
  this.mark = mark2;
  this.bounds = this.bounds || new Bounds();
}
function GroupItem(mark2) {
  Item.call(this, mark2);
  this.items = this.items || [];
}
inherits(GroupItem, Item);
function ResourceLoader(customLoader) {
  this._pending = 0;
  this._loader = customLoader || loader();
}
function increment(loader2) {
  loader2._pending += 1;
}
function decrement(loader2) {
  loader2._pending -= 1;
}
ResourceLoader.prototype = {
  pending() {
    return this._pending;
  },
  sanitizeURL(uri) {
    const loader2 = this;
    increment(loader2);
    return loader2._loader.sanitize(uri, {
      context: "href"
    }).then((opt) => {
      decrement(loader2);
      return opt;
    }).catch(() => {
      decrement(loader2);
      return null;
    });
  },
  loadImage(uri) {
    const loader2 = this, Image2 = domImage();
    increment(loader2);
    return loader2._loader.sanitize(uri, {
      context: "image"
    }).then((opt) => {
      const url = opt.href;
      if (!url || !Image2) throw {
        url
      };
      const img = new Image2();
      const cors = has$2(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
      if (cors != null) img.crossOrigin = cors;
      img.onload = () => decrement(loader2);
      img.onerror = () => decrement(loader2);
      img.src = url;
      return img;
    }).catch((e3) => {
      decrement(loader2);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e3 && e3.url || ""
      };
    });
  },
  ready() {
    const loader2 = this;
    return new Promise((accept) => {
      function poll(value2) {
        if (!loader2.pending()) accept(value2);
        else setTimeout(() => {
          poll(true);
        }, 10);
      }
      poll(false);
    });
  }
};
function boundStroke(bounds2, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds2.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }
  return bounds2;
}
function miterAdjustment(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
const circleThreshold = Tau - 1e-8;
let bounds, lx, ly, rot, ma, mb, mc, md;
const add$2 = (x2, y2) => bounds.add(x2, y2);
const addL = (x2, y2) => add$2(lx = x2, ly = y2);
const addX = (x2) => add$2(x2, bounds.y1);
const addY = (y2) => add$2(bounds.x1, y2);
const px = (x2, y2) => ma * x2 + mc * y2;
const py = (x2, y2) => mb * x2 + md * y2;
const addp = (x2, y2) => add$2(px(x2, y2), py(x2, y2));
const addpL = (x2, y2) => addL(px(x2, y2), py(x2, y2));
function boundContext(_, deg) {
  bounds = _;
  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }
  return context$1;
}
const context$1 = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: addpL,
  lineTo: addpL,
  rect(x2, y2, w2, h2) {
    if (rot) {
      addp(x2 + w2, y2);
      addp(x2 + w2, y2 + h2);
      addp(x2, y2 + h2);
      addpL(x2, y2);
    } else {
      add$2(x2 + w2, y2 + h2);
      addL(x2, y2);
    }
  },
  quadraticCurveTo(x12, y12, x2, y2) {
    const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x2, y2), py2 = py(x2, y2);
    quadExtrema(lx, px1, px2, addX);
    quadExtrema(ly, py1, py2, addY);
    addL(px2, py2);
  },
  bezierCurveTo(x12, y12, x2, y2, x3, y3) {
    const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x2, y2), py2 = py(x2, y2), px3 = px(x3, y3), py3 = py(x3, y3);
    cubicExtrema(lx, px1, px2, px3, addX);
    cubicExtrema(ly, py1, py2, py3, addY);
    addL(px3, py3);
  },
  arc(cx, cy, r2, sa2, ea2, ccw) {
    sa2 += rot;
    ea2 += rot;
    lx = r2 * Math.cos(ea2) + cx;
    ly = r2 * Math.sin(ea2) + cy;
    if (Math.abs(ea2 - sa2) > circleThreshold) {
      add$2(cx - r2, cy - r2);
      add$2(cx + r2, cy + r2);
    } else {
      const update2 = (a2) => add$2(r2 * Math.cos(a2) + cx, r2 * Math.sin(a2) + cy);
      let s, i;
      update2(sa2);
      update2(ea2);
      if (ea2 !== sa2) {
        sa2 = sa2 % Tau;
        if (sa2 < 0) sa2 += Tau;
        ea2 = ea2 % Tau;
        if (ea2 < 0) ea2 += Tau;
        if (ea2 < sa2) {
          ccw = !ccw;
          s = sa2;
          sa2 = ea2;
          ea2 = s;
        }
        if (ccw) {
          ea2 -= Tau;
          s = sa2 - sa2 % HalfPi;
          for (i = 0; i < 4 && s > ea2; ++i, s -= HalfPi) update2(s);
        } else {
          s = sa2 - sa2 % HalfPi + HalfPi;
          for (i = 0; i < 4 && s < ea2; ++i, s = s + HalfPi) update2(s);
        }
      }
    }
  }
};
function quadExtrema(x02, x12, x2, cb) {
  const t4 = (x02 - x12) / (x02 + x2 - 2 * x12);
  if (0 < t4 && t4 < 1) cb(x02 + (x12 - x02) * t4);
}
function cubicExtrema(x02, x12, x2, x3, cb) {
  const a2 = x3 - x02 + 3 * x12 - 3 * x2, b2 = x02 + x2 - 2 * x12, c2 = x02 - x12;
  let t02 = 0, t12 = 0, r2;
  if (Math.abs(a2) > Epsilon) {
    r2 = b2 * b2 + c2 * a2;
    if (r2 >= 0) {
      r2 = Math.sqrt(r2);
      t02 = (-b2 + r2) / a2;
      t12 = (-b2 - r2) / a2;
    }
  } else {
    t02 = 0.5 * c2 / b2;
  }
  if (0 < t02 && t02 < 1) cb(cubic(t02, x02, x12, x2, x3));
  if (0 < t12 && t12 < 1) cb(cubic(t12, x02, x12, x2, x3));
}
function cubic(t4, x02, x12, x2, x3) {
  const s = 1 - t4, s2 = s * s, t22 = t4 * t4;
  return s2 * s * x02 + 3 * s2 * t4 * x12 + 3 * s * t22 * x2 + t22 * t4 * x3;
}
var context$2 = (context$2 = domCanvas(1, 1)) ? context$2.getContext("2d") : null;
const b = new Bounds();
function intersectPath(draw2) {
  return function(item, brush) {
    if (!context$2) return true;
    draw2(context$2, item);
    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x12,
      y1: y12,
      x2,
      y2
    } = b;
    for (let y3 = y12; y3 <= y2; ++y3) {
      for (let x3 = x12; x3 <= x2; ++x3) {
        if (context$2.isPointInPath(x3, y3)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x2 = item.x || 0, y2 = item.y || 0, w2 = item.width || 0, h2 = item.height || 0;
  return box.intersects(b.set(x2, y2, x2 + w2, y2 + h2));
}
function intersectRule(item, box) {
  const x2 = item.x || 0, y2 = item.y || 0, x22 = item.x2 != null ? item.x2 : x2, y22 = item.y2 != null ? item.y2 : y2;
  return intersectBoxLine(box, x2, y2, x22, y22);
}
function intersectBoxLine(box, x2, y2, u2, v) {
  const {
    x1: x12,
    y1: y12,
    x2: x22,
    y2: y22
  } = box, dx = u2 - x2, dy = v - y2;
  let t02 = 0, t12 = 1, p, q, r2, e3;
  for (e3 = 0; e3 < 4; ++e3) {
    if (e3 === 0) {
      p = -dx;
      q = -(x12 - x2);
    }
    if (e3 === 1) {
      p = dx;
      q = x22 - x2;
    }
    if (e3 === 2) {
      p = -dy;
      q = -(y12 - y2);
    }
    if (e3 === 3) {
      p = dy;
      q = y22 - y2;
    }
    if (Math.abs(p) < 1e-10 && q < 0) return false;
    r2 = q / p;
    if (p < 0) {
      if (r2 > t12) return false;
      else if (r2 > t02) t02 = r2;
    } else if (p > 0) {
      if (r2 < t02) return false;
      else if (r2 < t12) t12 = r2;
    }
  }
  return true;
}
function blend(context2, item) {
  context2.globalCompositeOperation = item.blend || "source-over";
}
function value$2(value2, dflt) {
  return value2 == null ? dflt : value2;
}
function addStops(gradient2, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient2.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient2;
}
function gradient$2(context2, spec, bounds2) {
  const w2 = bounds2.width(), h2 = bounds2.height();
  let gradient2;
  if (spec.gradient === "radial") {
    gradient2 = context2.createRadialGradient(bounds2.x1 + value$2(spec.x1, 0.5) * w2, bounds2.y1 + value$2(spec.y1, 0.5) * h2, Math.max(w2, h2) * value$2(spec.r1, 0), bounds2.x1 + value$2(spec.x2, 0.5) * w2, bounds2.y1 + value$2(spec.y2, 0.5) * h2, Math.max(w2, h2) * value$2(spec.r2, 0.5));
  } else {
    const x12 = value$2(spec.x1, 0), y12 = value$2(spec.y1, 0), x2 = value$2(spec.x2, 1), y2 = value$2(spec.y2, 0);
    if (x12 === x2 || y12 === y2 || w2 === h2) {
      gradient2 = context2.createLinearGradient(bounds2.x1 + x12 * w2, bounds2.y1 + y12 * h2, bounds2.x1 + x2 * w2, bounds2.y1 + y2 * h2);
    } else {
      const image2 = domCanvas(Math.ceil(w2), Math.ceil(h2)), ictx = image2.getContext("2d");
      ictx.scale(w2, h2);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x12, y12, x2, y2), spec.stops);
      ictx.fillRect(0, 0, w2, h2);
      return context2.createPattern(image2, "no-repeat");
    }
  }
  return addStops(gradient2, spec.stops);
}
function color$5(context2, item, value2) {
  return isGradient(value2) ? gradient$2(context2, value2, item.bounds) : value2;
}
function fill(context2, item, opacity2) {
  opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity2 > 0) {
    context2.globalAlpha = opacity2;
    context2.fillStyle = color$5(context2, item, item.fill);
    return true;
  } else {
    return false;
  }
}
var Empty = [];
function stroke(context2, item, opacity2) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0) return false;
  opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity2 > 0) {
    context2.globalAlpha = opacity2;
    context2.strokeStyle = color$5(context2, item, item.stroke);
    context2.lineWidth = lw;
    context2.lineCap = item.strokeCap || "butt";
    context2.lineJoin = item.strokeJoin || "miter";
    context2.miterLimit = item.strokeMiterLimit || 10;
    if (context2.setLineDash) {
      context2.setLineDash(item.strokeDash || Empty);
      context2.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare$8(a2, b2) {
  return a2.zindex - b2.zindex || a2.index - b2.index;
}
function zorder(scene) {
  if (!scene.zdirty) return scene.zitems;
  var items = scene.items, output2 = [], item, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex) output2.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output2.sort(compare$8);
}
function visit(scene, visitor) {
  var items = scene.items, i, n;
  if (!items || !items.length) return;
  const zitems = zorder(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex) visitor(items[i]);
    }
    items = zitems;
  }
  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit(scene, visitor) {
  var items = scene.items, hit2, i;
  if (!items || !items.length) return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length) items = zitems;
  for (i = items.length; --i >= 0; ) {
    if (hit2 = visitor(items[i])) return hit2;
  }
  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0; ) {
      if (!items[i].zindex) {
        if (hit2 = visitor(items[i])) return hit2;
      }
    }
  }
  return null;
}
function drawAll(path2) {
  return function(context2, scene, bounds2) {
    visit(scene, (item) => {
      if (!bounds2 || bounds2.intersects(item.bounds)) {
        drawPath(path2, context2, item, item);
      }
    });
  };
}
function drawOne(path2) {
  return function(context2, scene, bounds2) {
    if (scene.items.length && (!bounds2 || bounds2.intersects(scene.bounds))) {
      drawPath(path2, context2, scene.items[0], scene.items);
    }
  };
}
function drawPath(path2, context2, item, items) {
  var opacity2 = item.opacity == null ? 1 : item.opacity;
  if (opacity2 === 0) return;
  if (path2(context2, items)) return;
  blend(context2, item);
  if (item.fill && fill(context2, item, opacity2)) {
    context2.fill();
  }
  if (item.stroke && stroke(context2, item, opacity2)) {
    context2.stroke();
  }
}
function pick$1(test2) {
  test2 = test2 || truthy;
  return function(context2, scene, x2, y2, gx, gy) {
    x2 *= context2.pixelRatio;
    y2 *= context2.pixelRatio;
    return pickVisit(scene, (item) => {
      const b2 = item.bounds;
      if (b2 && !b2.contains(gx, gy) || !b2) return;
      if (test2(context2, item, x2, y2, gx, gy)) return item;
    });
  };
}
function hitPath(path2, filled) {
  return function(context2, o, x2, y2) {
    var item = Array.isArray(o) ? o[0] : o, fill2 = filled == null ? item.fill : filled, stroke2 = item.stroke && context2.isPointInStroke, lw, lc;
    if (stroke2) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context2.lineWidth = lw != null ? lw : 1;
      context2.lineCap = lc != null ? lc : "butt";
    }
    return path2(context2, o) ? false : fill2 && context2.isPointInPath(x2, y2) || stroke2 && context2.isPointInStroke(x2, y2);
  };
}
function pickPath(path2) {
  return pick$1(hitPath(path2));
}
function translate$2(x2, y2) {
  return "translate(" + x2 + "," + y2 + ")";
}
function rotate(a2) {
  return "rotate(" + a2 + ")";
}
function scale$3(scaleX, scaleY2) {
  return "scale(" + scaleX + "," + scaleY2 + ")";
}
function translateItem(item) {
  return translate$2(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate$2(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "");
}
function transformItem(item) {
  return translate$2(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale$3(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath(type2, shape2, isect) {
  function attr2(emit2, item) {
    emit2("transform", rotateItem(item));
    emit2("d", shape2(null, item));
  }
  function bound2(bounds2, item) {
    shape2(boundContext(bounds2, item.angle), item);
    return boundStroke(bounds2, item).translate(item.x || 0, item.y || 0);
  }
  function draw2(context2, item) {
    var x2 = item.x || 0, y2 = item.y || 0, a2 = item.angle || 0;
    context2.translate(x2, y2);
    if (a2) context2.rotate(a2 *= DegToRad);
    context2.beginPath();
    shape2(context2, item);
    if (a2) context2.rotate(-a2);
    context2.translate(-x2, -y2);
  }
  return {
    type: type2,
    tag: "path",
    nested: false,
    attr: attr2,
    bound: bound2,
    draw: drawAll(draw2),
    pick: pickPath(draw2),
    isect: isect || intersectPath(draw2)
  };
}
var arc$2 = markItemPath("arc", arc$1$1);
function pickArea(a2, p) {
  var v = a2[0].orient === "horizontal" ? p[1] : p[0], z2 = a2[0].orient === "horizontal" ? "y" : "x", i = a2.length, min2 = Infinity, hit2, d;
  while (--i >= 0) {
    if (a2[i].defined === false) continue;
    d = Math.abs(a2[i][z2] - v);
    if (d < min2) {
      min2 = d;
      hit2 = a2[i];
    }
  }
  return hit2;
}
function pickLine(a2, p) {
  var t4 = Math.pow(a2[0].strokeWidth || 1, 2), i = a2.length, dx, dy, dd;
  while (--i >= 0) {
    if (a2[i].defined === false) continue;
    dx = a2[i].x - p[0];
    dy = a2[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t4) return a2[i];
  }
  return null;
}
function pickTrail(a2, p) {
  var i = a2.length, dx, dy, dd;
  while (--i >= 0) {
    if (a2[i].defined === false) continue;
    dx = a2[i].x - p[0];
    dy = a2[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a2[i].size || 1;
    if (dd < dx * dx) return a2[i];
  }
  return null;
}
function markMultiItemPath(type2, shape2, tip) {
  function attr2(emit2, item) {
    var items = item.mark.items;
    if (items.length) emit2("d", shape2(null, items));
  }
  function bound2(bounds2, mark2) {
    var items = mark2.items;
    if (items.length === 0) {
      return bounds2;
    } else {
      shape2(boundContext(bounds2), items);
      return boundStroke(bounds2, items[0]);
    }
  }
  function draw2(context2, items) {
    context2.beginPath();
    shape2(context2, items);
  }
  const hit2 = hitPath(draw2);
  function pick2(context2, scene, x2, y2, gx, gy) {
    var items = scene.items, b2 = scene.bounds;
    if (!items || !items.length || b2 && !b2.contains(gx, gy)) {
      return null;
    }
    x2 *= context2.pixelRatio;
    y2 *= context2.pixelRatio;
    return hit2(context2, items, x2, y2) ? items[0] : null;
  }
  return {
    type: type2,
    tag: "path",
    nested: true,
    attr: attr2,
    bound: bound2,
    draw: drawOne(draw2),
    pick: pick2,
    isect: intersectPoint,
    tip
  };
}
var area$2 = markMultiItemPath("area", area$1$1, pickArea);
function clip$2(context2, scene) {
  var clip2 = scene.clip;
  context2.save();
  if (isFunction$3(clip2)) {
    context2.beginPath();
    clip2(context2);
    context2.clip();
  } else {
    clipGroup(context2, scene.group);
  }
}
function clipGroup(context2, group2) {
  context2.beginPath();
  hasCornerRadius(group2) ? rectangle(context2, group2, 0, 0) : context2.rect(0, 0, group2.width || 0, group2.height || 0);
  context2.clip();
}
function offset$1$1(item) {
  const sw = value$2(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$5(emit2, item) {
  emit2("transform", translateItem(item));
}
function emitRectangle(emit2, item) {
  const off = offset$1$1(item);
  emit2("d", rectangle(null, item, off, off));
}
function background$1(emit2, item) {
  emit2("class", "background");
  emit2("aria-hidden", true);
  emitRectangle(emit2, item);
}
function foreground(emit2, item) {
  emit2("class", "foreground");
  emit2("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle(emit2, item);
  } else {
    emit2("d", "");
  }
}
function content(emit2, item, renderer) {
  const url = item.clip ? clip$1$1(renderer, item, item) : null;
  emit2("clip-path", url);
}
function bound$5(bounds2, group2) {
  if (!group2.clip && group2.items) {
    const items = group2.items, m2 = items.length;
    for (let j = 0; j < m2; ++j) {
      bounds2.union(items[j].bounds);
    }
  }
  if ((group2.clip || group2.width || group2.height) && !group2.noBound) {
    bounds2.add(0, 0).add(group2.width || 0, group2.height || 0);
  }
  boundStroke(bounds2, group2);
  return bounds2.translate(group2.x || 0, group2.y || 0);
}
function rectanglePath(context2, group2, x2, y2) {
  const off = offset$1$1(group2);
  context2.beginPath();
  rectangle(context2, group2, (x2 || 0) + off, (y2 || 0) + off);
}
const hitBackground = hitPath(rectanglePath);
const hitForeground = hitPath(rectanglePath, false);
const hitCorner = hitPath(rectanglePath, true);
function draw$4(context2, scene, bounds2) {
  visit(scene, (group2) => {
    const gx = group2.x || 0, gy = group2.y || 0, fore = group2.strokeForeground, opacity2 = group2.opacity == null ? 1 : group2.opacity;
    if ((group2.stroke || group2.fill) && opacity2) {
      rectanglePath(context2, group2, gx, gy);
      blend(context2, group2);
      if (group2.fill && fill(context2, group2, opacity2)) {
        context2.fill();
      }
      if (group2.stroke && !fore && stroke(context2, group2, opacity2)) {
        context2.stroke();
      }
    }
    context2.save();
    context2.translate(gx, gy);
    if (group2.clip) clipGroup(context2, group2);
    if (bounds2) bounds2.translate(-gx, -gy);
    visit(group2, (item) => {
      this.draw(context2, item, bounds2);
    });
    if (bounds2) bounds2.translate(gx, gy);
    context2.restore();
    if (fore && group2.stroke && opacity2) {
      rectanglePath(context2, group2, gx, gy);
      blend(context2, group2);
      if (stroke(context2, group2, opacity2)) {
        context2.stroke();
      }
    }
  });
}
function pick$2(context2, scene, x2, y2, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x2 * context2.pixelRatio, cy = y2 * context2.pixelRatio;
  return pickVisit(scene, (group2) => {
    let hit2, dx, dy;
    const b2 = group2.bounds;
    if (b2 && !b2.contains(gx, gy)) return;
    dx = group2.x || 0;
    dy = group2.y || 0;
    const dw = dx + (group2.width || 0), dh = dy + (group2.height || 0), c2 = group2.clip;
    if (c2 && (gx < dx || gx > dw || gy < dy || gy > dh)) return;
    context2.save();
    context2.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c2 && hasCornerRadius(group2) && !hitCorner(context2, group2, cx, cy)) {
      context2.restore();
      return null;
    }
    const fore = group2.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group2.stroke && hitForeground(context2, group2, cx, cy)) {
      context2.restore();
      return group2;
    }
    hit2 = pickVisit(group2, (mark2) => pickMark(mark2, dx, dy) ? this.pick(mark2, x2, y2, dx, dy) : null);
    if (!hit2 && ix && (group2.fill || !fore && group2.stroke) && hitBackground(context2, group2, cx, cy)) {
      hit2 = group2;
    }
    context2.restore();
    return hit2 || null;
  });
}
function pickMark(mark2, x2, y2) {
  return (mark2.interactive !== false || mark2.marktype === "group") && mark2.bounds && mark2.bounds.contains(x2, y2);
}
var group = {
  type: "group",
  tag: "g",
  nested: false,
  attr: attr$5,
  bound: bound$5,
  draw: draw$4,
  pick: pick$2,
  isect: intersectRect,
  content,
  background: background$1,
  foreground
};
var metadata = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "version": "1.1"
};
function getImage(item, renderer) {
  var image2 = item.image;
  if (!image2 || item.url && item.url !== image2.url) {
    image2 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image3) => {
      item.image = image3;
      item.image.url = item.url;
    });
  }
  return image2;
}
function imageWidth(item, image2) {
  return item.width != null ? item.width : !image2 || !image2.width ? 0 : item.aspect !== false && item.height ? item.height * image2.width / image2.height : image2.width;
}
function imageHeight(item, image2) {
  return item.height != null ? item.height : !image2 || !image2.height ? 0 : item.aspect !== false && item.width ? item.width * image2.height / image2.width : image2.height;
}
function imageXOffset(align2, w2) {
  return align2 === "center" ? w2 / 2 : align2 === "right" ? w2 : 0;
}
function imageYOffset(baseline2, h2) {
  return baseline2 === "middle" ? h2 / 2 : baseline2 === "bottom" ? h2 : 0;
}
function attr$4(emit2, item, renderer) {
  const img = getImage(item, renderer), w2 = imageWidth(item, img), h2 = imageHeight(item, img), x2 = (item.x || 0) - imageXOffset(item.align, w2), y2 = (item.y || 0) - imageYOffset(item.baseline, h2), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit2("href", i, metadata["xmlns:xlink"], "xlink:href");
  emit2("transform", translate$2(x2, y2));
  emit2("width", w2);
  emit2("height", h2);
  emit2("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$4(bounds2, item) {
  const img = item.image, w2 = imageWidth(item, img), h2 = imageHeight(item, img), x2 = (item.x || 0) - imageXOffset(item.align, w2), y2 = (item.y || 0) - imageYOffset(item.baseline, h2);
  return bounds2.set(x2, y2, x2 + w2, y2 + h2);
}
function draw$3(context2, scene, bounds2) {
  visit(scene, (item) => {
    if (bounds2 && !bounds2.intersects(item.bounds)) return;
    const img = getImage(item, this);
    let w2 = imageWidth(item, img);
    let h2 = imageHeight(item, img);
    if (w2 === 0 || h2 === 0) return;
    let x2 = (item.x || 0) - imageXOffset(item.align, w2), y2 = (item.y || 0) - imageYOffset(item.baseline, h2), opacity2, ar0, ar1, t4;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t4 = w2 / ar0;
          y2 += (h2 - t4) / 2;
          h2 = t4;
        } else {
          t4 = h2 * ar0;
          x2 += (w2 - t4) / 2;
          w2 = t4;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend(context2, item);
      context2.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
      context2.imageSmoothingEnabled = item.smooth !== false;
      context2.drawImage(img, x2, y2, w2, h2);
    }
  });
}
var image$2 = {
  type: "image",
  tag: "image",
  nested: false,
  attr: attr$4,
  bound: bound$4,
  draw: draw$3,
  pick: pick$1(),
  isect: truthy,
  // bounds check is sufficient
  get: getImage,
  xOffset: imageXOffset,
  yOffset: imageYOffset
};
var line$3 = markMultiItemPath("line", line$1$1, pickLine);
function attr$3(emit2, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit2("vector-effect", "non-scaling-stroke");
  }
  emit2("transform", transformItem(item));
  emit2("d", item.path);
}
function path$1(context2, item) {
  var path2 = item.path;
  if (path2 == null) return true;
  var x2 = item.x || 0, y2 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a2 = (item.angle || 0) * DegToRad, cache2 = item.pathCache;
  if (!cache2 || cache2.path !== path2) {
    (item.pathCache = cache2 = parse$4(path2)).path = path2;
  }
  if (a2 && context2.rotate && context2.translate) {
    context2.translate(x2, y2);
    context2.rotate(a2);
    pathRender(context2, cache2, 0, 0, sx, sy);
    context2.rotate(-a2);
    context2.translate(-x2, -y2);
  } else {
    pathRender(context2, cache2, x2, y2, sx, sy);
  }
}
function bound$3(bounds2, item) {
  return path$1(boundContext(bounds2, item.angle), item) ? bounds2.set(0, 0, 0, 0) : boundStroke(bounds2, item, true);
}
var path$2 = {
  type: "path",
  tag: "path",
  nested: false,
  attr: attr$3,
  bound: bound$3,
  draw: drawAll(path$1),
  pick: pickPath(path$1),
  isect: intersectPath(path$1)
};
function attr$2(emit2, item) {
  emit2("d", rectangle(null, item));
}
function bound$2(bounds2, item) {
  var x2, y2;
  return boundStroke(bounds2.set(x2 = item.x || 0, y2 = item.y || 0, x2 + item.width || 0, y2 + item.height || 0), item);
}
function draw$2(context2, item) {
  context2.beginPath();
  rectangle(context2, item);
}
var rect$1 = {
  type: "rect",
  tag: "path",
  nested: false,
  attr: attr$2,
  bound: bound$2,
  draw: drawAll(draw$2),
  pick: pickPath(draw$2),
  isect: intersectRect
};
function attr$1(emit2, item) {
  emit2("transform", translateItem(item));
  emit2("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit2("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$1(bounds2, item) {
  var x12, y12;
  return boundStroke(bounds2.set(x12 = item.x || 0, y12 = item.y || 0, item.x2 != null ? item.x2 : x12, item.y2 != null ? item.y2 : y12), item);
}
function path(context2, item, opacity2) {
  var x12, y12, x2, y2;
  if (item.stroke && stroke(context2, item, opacity2)) {
    x12 = item.x || 0;
    y12 = item.y || 0;
    x2 = item.x2 != null ? item.x2 : x12;
    y2 = item.y2 != null ? item.y2 : y12;
    context2.beginPath();
    context2.moveTo(x12, y12);
    context2.lineTo(x2, y2);
    return true;
  }
  return false;
}
function draw$1(context2, scene, bounds2) {
  visit(scene, (item) => {
    if (bounds2 && !bounds2.intersects(item.bounds)) return;
    var opacity2 = item.opacity == null ? 1 : item.opacity;
    if (opacity2 && path(context2, item, opacity2)) {
      blend(context2, item);
      context2.stroke();
    }
  });
}
function hit$1(context2, item, x2, y2) {
  if (!context2.isPointInStroke) return false;
  return path(context2, item, 1) && context2.isPointInStroke(x2, y2);
}
var rule$2 = {
  type: "rule",
  tag: "line",
  nested: false,
  attr: attr$1,
  bound: bound$1,
  draw: draw$1,
  pick: pick$1(hit$1),
  isect: intersectRule
};
var shape$2 = markItemPath("shape", shape$1);
var symbol = markItemPath("symbol", symbol$1, intersectPoint);
const widthCache = lruCache$1();
var textMetrics = {
  height: fontSize,
  measureWidth,
  estimateWidth,
  width: estimateWidth,
  canvas: useCanvas
};
useCanvas(true);
function useCanvas(use) {
  textMetrics.width = use && context$2 ? measureWidth : estimateWidth;
}
function estimateWidth(item, text2) {
  return _estimateWidth(textValue(item, text2), fontSize(item));
}
function _estimateWidth(text2, currentFontHeight) {
  return ~~(0.8 * text2.length * currentFontHeight);
}
function measureWidth(item, text2) {
  return fontSize(item) <= 0 || !(text2 = textValue(item, text2)) ? 0 : _measureWidth(text2, font$1(item));
}
function _measureWidth(text2, currentFont) {
  const key2 = "(".concat(currentFont, ") ").concat(text2);
  let width2 = widthCache.get(key2);
  if (width2 === void 0) {
    context$2.font = currentFont;
    width2 = context$2.measureText(text2).width;
    widthCache.set(key2, width2);
  }
  return width2;
}
function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}
function lineArray(_) {
  return isArray$1(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines(item) {
  return lineArray(item.lineBreak && item.text && !isArray$1(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl2 = textLines(item);
  return (isArray$1(tl2) ? tl2.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line2) {
  const text2 = line2 == null ? "" : (line2 + "").trim();
  return item.limit > 0 && text2.length ? truncate(item, text2) : text2;
}
function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    const currentFont = font$1(item);
    return (text2) => _measureWidth(text2, currentFont);
  } else {
    const currentFontHeight = fontSize(item);
    return (text2) => _estimateWidth(text2, currentFontHeight);
  }
}
function truncate(item, text2) {
  var limit = +item.limit, width2 = widthGetter(item);
  if (width2(text2) < limit) return text2;
  var ellipsis = item.ellipsis || "…", rtl = item.dir === "rtl", lo = 0, hi = text2.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text2.slice(mid)) > limit) lo = mid + 1;
      else hi = mid;
    }
    return ellipsis + text2.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text2.slice(0, mid)) < limit) lo = mid;
      else hi = mid - 1;
    }
    return text2.slice(0, lo) + ellipsis;
  }
}
function fontFamily(item, quote) {
  var font2 = item.font;
  return (quote && font2 ? String(font2).replace(/"/g, "'") : font2) || "sans-serif";
}
function font$1(item, quote) {
  return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize(item) + "px " + fontFamily(item, quote);
}
function offset$2(item) {
  var baseline2 = item.baseline, h2 = fontSize(item);
  return Math.round(baseline2 === "top" ? 0.79 * h2 : baseline2 === "middle" ? 0.3 * h2 : baseline2 === "bottom" ? -0.21 * h2 : baseline2 === "line-top" ? 0.29 * h2 + 0.5 * lineHeight(item) : baseline2 === "line-bottom" ? 0.29 * h2 - 0.5 * lineHeight(item) : 0);
}
const textAlign = {
  "left": "start",
  "center": "middle",
  "right": "end"
};
const tempBounds$1 = new Bounds();
function anchorPoint(item) {
  var x2 = item.x || 0, y2 = item.y || 0, r2 = item.radius || 0, t4;
  if (r2) {
    t4 = (item.theta || 0) - HalfPi;
    x2 += r2 * Math.cos(t4);
    y2 += r2 * Math.sin(t4);
  }
  tempBounds$1.x1 = x2;
  tempBounds$1.y1 = y2;
  return tempBounds$1;
}
function attr(emit2, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset$2(item), p = anchorPoint(item), x2 = p.x1, y2 = p.y1, a2 = item.angle || 0, t4;
  emit2("text-anchor", textAlign[item.align] || "start");
  if (a2) {
    t4 = translate$2(x2, y2) + " " + rotate(a2);
    if (dx || dy) t4 += " " + translate$2(dx, dy);
  } else {
    t4 = translate$2(x2 + dx, y2 + dy);
  }
  emit2("transform", t4);
}
function bound(bounds2, item, mode) {
  var h2 = textMetrics.height(item), a2 = item.align, p = anchorPoint(item), x2 = p.x1, y2 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset$2(item) - Math.round(0.8 * h2), tl2 = textLines(item), w2;
  if (isArray$1(tl2)) {
    h2 += lineHeight(item) * (tl2.length - 1);
    w2 = tl2.reduce((w3, t4) => Math.max(w3, textMetrics.width(item, t4)), 0);
  } else {
    w2 = textMetrics.width(item, tl2);
  }
  if (a2 === "center") {
    dx -= w2 / 2;
  } else if (a2 === "right") {
    dx -= w2;
  } else ;
  bounds2.set(dx += x2, dy += y2, dx + w2, dy + h2);
  if (item.angle && !mode) {
    bounds2.rotate(item.angle * DegToRad, x2, y2);
  } else if (mode === 2) {
    return bounds2.rotatedPoints(item.angle * DegToRad, x2, y2);
  }
  return bounds2;
}
function draw$5(context2, scene, bounds2) {
  visit(scene, (item) => {
    var opacity2 = item.opacity == null ? 1 : item.opacity, p, x2, y2, i, lh, tl2, str;
    if (bounds2 && !bounds2.intersects(item.bounds) || // bounds check
    opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;
    context2.font = font$1(item);
    context2.textAlign = item.align || "left";
    p = anchorPoint(item);
    x2 = p.x1, y2 = p.y1;
    if (item.angle) {
      context2.save();
      context2.translate(x2, y2);
      context2.rotate(item.angle * DegToRad);
      x2 = y2 = 0;
    }
    x2 += item.dx || 0;
    y2 += (item.dy || 0) + offset$2(item);
    tl2 = textLines(item);
    blend(context2, item);
    if (isArray$1(tl2)) {
      lh = lineHeight(item);
      for (i = 0; i < tl2.length; ++i) {
        str = textValue(item, tl2[i]);
        if (item.fill && fill(context2, item, opacity2)) {
          context2.fillText(str, x2, y2);
        }
        if (item.stroke && stroke(context2, item, opacity2)) {
          context2.strokeText(str, x2, y2);
        }
        y2 += lh;
      }
    } else {
      str = textValue(item, tl2);
      if (item.fill && fill(context2, item, opacity2)) {
        context2.fillText(str, x2, y2);
      }
      if (item.stroke && stroke(context2, item, opacity2)) {
        context2.strokeText(str, x2, y2);
      }
    }
    if (item.angle) context2.restore();
  });
}
function hit(context2, item, x2, y2, gx, gy) {
  if (item.fontSize <= 0) return false;
  if (!item.angle) return true;
  var p = anchorPoint(item), ax = p.x1, ay = p.y1, b2 = bound(tempBounds$1, item, 1), a2 = -item.angle * DegToRad, cos2 = Math.cos(a2), sin2 = Math.sin(a2), px2 = cos2 * gx - sin2 * gy + (ax - cos2 * ax + sin2 * ay), py2 = sin2 * gx + cos2 * gy + (ay - sin2 * ax - cos2 * ay);
  return b2.contains(px2, py2);
}
function intersectText(item, box) {
  const p = bound(tempBounds$1, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}
var text$2 = {
  type: "text",
  tag: "text",
  nested: false,
  attr,
  bound,
  draw: draw$5,
  pick: pick$1(hit),
  isect: intersectText
};
var trail$2 = markMultiItemPath("trail", trail$1, pickTrail);
var Marks = {
  arc: arc$2,
  area: area$2,
  group,
  image: image$2,
  line: line$3,
  path: path$2,
  rect: rect$1,
  rule: rule$2,
  shape: shape$2,
  symbol,
  text: text$2,
  trail: trail$2
};
function boundItem$1(item, func, opt) {
  var type2 = Marks[item.mark.marktype], bound2 = func || type2.bound;
  if (type2.nested) item = item.mark;
  return bound2(item.bounds || (item.bounds = new Bounds()), item, opt);
}
var DUMMY = {
  mark: null
};
function boundMark(mark2, bounds2, opt) {
  var type2 = Marks[mark2.marktype], bound2 = type2.bound, items = mark2.items, hasItems = items && items.length, i, n, item, b2;
  if (type2.nested) {
    if (hasItems) {
      item = items[0];
    } else {
      DUMMY.mark = mark2;
      item = DUMMY;
    }
    b2 = boundItem$1(item, bound2, opt);
    bounds2 = bounds2 && bounds2.union(b2) || b2;
    return bounds2;
  }
  bounds2 = bounds2 || mark2.bounds && mark2.bounds.clear() || new Bounds();
  if (hasItems) {
    for (i = 0, n = items.length; i < n; ++i) {
      bounds2.union(boundItem$1(items[i], bound2, opt));
    }
  }
  return mark2.bounds = bounds2;
}
const keys$4 = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  // layout
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  // fill
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  // stroke
  "strokeDash",
  "strokeDashOffset",
  // stroke dash
  "strokeForeground",
  "strokeOffset",
  // group
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  // arc
  "cornerRadius",
  "padAngle",
  // arc, rect
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  // rect, group
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  // area, line
  "url",
  "aspect",
  "smooth",
  // image
  "path",
  "scaleX",
  "scaleY",
  // path
  "x2",
  "y2",
  // rule
  "size",
  "shape",
  // symbol
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  // text
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  // font
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
  // aria
];
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys$4, indent);
}
function sceneFromJSON(json2) {
  const scene = typeof json2 === "string" ? JSON.parse(json2) : json2;
  return initialize$1(scene);
}
function initialize$1(scene) {
  var type2 = scene.marktype, items = scene.items, parent, i, n;
  if (items) {
    for (i = 0, n = items.length; i < n; ++i) {
      parent = type2 ? "mark" : "group";
      items[i][parent] = scene;
      if (items[i].zindex) items[i][parent].zdirty = true;
      if ("group" === (type2 || parent)) initialize$1(items[i]);
    }
  }
  if (type2) boundMark(scene);
  return scene;
}
function Scenegraph(scene) {
  if (arguments.length) {
    this.root = sceneFromJSON(scene);
  } else {
    this.root = createMark({
      marktype: "group",
      name: "root",
      role: "frame"
    });
    this.root.items = [new GroupItem(this.root)];
  }
}
Scenegraph.prototype = {
  toJSON(indent) {
    return sceneToJSON(this.root, indent || 0);
  },
  mark(markdef, group2, index2) {
    group2 = group2 || this.root.items[0];
    const mark2 = createMark(markdef, group2);
    group2.items[index2] = mark2;
    if (mark2.zindex) mark2.group.zdirty = true;
    return mark2;
  }
};
function createMark(def2, group2) {
  const mark2 = {
    bounds: new Bounds(),
    clip: !!def2.clip,
    group: group2,
    interactive: def2.interactive === false ? false : true,
    items: [],
    marktype: def2.marktype,
    name: def2.name || void 0,
    role: def2.role || void 0,
    zindex: def2.zindex || 0
  };
  if (def2.aria != null) {
    mark2.aria = def2.aria;
  }
  if (def2.description) {
    mark2.description = def2.description;
  }
  return mark2;
}
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {
    return nodes[i];
  }
}
function domChild(el, index2, tag, ns) {
  var a2 = el.childNodes[index2], b2;
  if (!a2 || a2.tagName.toLowerCase() !== tag.toLowerCase()) {
    b2 = a2 || null;
    a2 = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a2, b2);
  }
  return a2;
}
function domClear(el, index2) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index2) el.removeChild(nodes[--curr]);
  return el;
}
function cssClass(mark2) {
  return "mark-" + mark2.marktype + (mark2.role ? " role-" + mark2.role : "") + (mark2.name ? " " + mark2.name : "");
}
function point$2(event2, el) {
  const rect2 = el.getBoundingClientRect();
  return [event2.clientX - rect2.left - (el.clientLeft || 0), event2.clientY - rect2.top - (el.clientTop || 0)];
}
function resolveItem(item, event2, el, origin) {
  var mark2 = item && item.mark, mdef, p;
  if (mark2 && (mdef = Marks[mark2.marktype]).tip) {
    p = point$2(event2, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark2.items, p);
  }
  return item;
}
function Handler$1(customLoader, customTooltip) {
  this._active = null;
  this._handlers = {};
  this._loader = customLoader || loader();
  this._tooltip = customTooltip || defaultTooltip$1;
}
function defaultTooltip$1(handler, event2, item, value2) {
  handler.element().setAttribute("title", value2 || "");
}
Handler$1.prototype = {
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  },
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  },
  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length) return this._scene;
    this._scene = scene;
    return this;
  },
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  },
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  },
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h2, type2, handler) {
    for (let i = h2 ? h2.length : 0; --i >= 0; ) {
      if (h2[i].type === type2 && (!handler || h2[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  },
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type2) {
    const h2 = this._handlers, a2 = [];
    if (type2) {
      a2.push(...h2[this.eventName(type2)]);
    } else {
      for (const k in h2) {
        a2.push(...h2[k]);
      }
    }
    return a2;
  },
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf(".");
    return i < 0 ? name : name.slice(0, i);
  },
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event2, item, href2) {
    this._loader.sanitize(href2, {
      context: "href"
    }).then((opt) => {
      const e3 = new MouseEvent(event2.type, event2), a2 = domCreate(null, "a");
      for (const name in opt) a2.setAttribute(name, opt[name]);
      a2.dispatchEvent(e3);
    }).catch(() => {
    });
  },
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event2, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem(item, event2, this.canvas(), this._origin);
      const value2 = show && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event2, item, value2);
    }
  },
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el) return;
    const rect2 = el.getBoundingClientRect(), origin = this._origin, bounds2 = item.bounds, width2 = bounds2.width(), height2 = bounds2.height();
    let x2 = bounds2.x1 + origin[0] + rect2.left, y2 = bounds2.y1 + origin[1] + rect2.top;
    while (item.mark && (item = item.mark.group)) {
      x2 += item.x || 0;
      y2 += item.y || 0;
    }
    return {
      x: x2,
      y: y2,
      width: width2,
      height: height2,
      left: x2,
      top: y2,
      right: x2 + width2,
      bottom: y2 + height2
    };
  }
};
function Renderer(loader2) {
  this._el = null;
  this._bgcolor = null;
  this._loader = new ResourceLoader(loader2);
}
Renderer.prototype = {
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._el = el;
    return this.resize(width2, height2, origin, scaleFactor);
  },
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },
  /**
   * Get / set the background color.
   */
  background(bgcolor2) {
    if (arguments.length === 0) return this._bgcolor;
    this._bgcolor = bgcolor2;
    return this;
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    this._width = width2;
    this._height = height2;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  },
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  },
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @return {Renderer} - This renderer instance.
   */
  render(scene) {
    const r2 = this;
    r2._call = function() {
      r2._render(scene);
    };
    r2._call();
    r2._call = null;
    return r2;
  },
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render() {
  },
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene) {
    const r2 = this.render(scene);
    return this._ready ? this._ready.then(() => r2) : Promise.resolve(r2);
  },
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method2, uri) {
    var r2 = this, p = r2._loader[method2](uri);
    if (!r2._ready) {
      const call = r2._call;
      r2._ready = r2._loader.ready().then((redraw) => {
        if (redraw) call();
        r2._ready = null;
      });
    }
    return p;
  },
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load("sanitizeURL", uri);
  },
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load("loadImage", uri);
  }
};
const KeyDownEvent = "keydown";
const KeyPressEvent = "keypress";
const KeyUpEvent = "keyup";
const DragEnterEvent = "dragenter";
const DragLeaveEvent = "dragleave";
const DragOverEvent = "dragover";
const MouseDownEvent = "mousedown";
const MouseUpEvent = "mouseup";
const MouseMoveEvent = "mousemove";
const MouseOutEvent = "mouseout";
const MouseOverEvent = "mouseover";
const ClickEvent = "click";
const DoubleClickEvent = "dblclick";
const WheelEvent = "wheel";
const MouseWheelEvent = "mousewheel";
const TouchStartEvent = "touchstart";
const TouchMoveEvent = "touchmove";
const TouchEndEvent = "touchend";
const Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
const TooltipShowEvent = MouseMoveEvent;
const TooltipHideEvent = MouseOutEvent;
const HrefEvent = ClickEvent;
function CanvasHandler(loader2, tooltip2) {
  Handler$1.call(this, loader2, tooltip2);
  this._down = null;
  this._touch = null;
  this._first = true;
  this._events = {};
}
const eventBundle = (type2) => type2 === TouchStartEvent || type2 === TouchMoveEvent || type2 === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type2];
function eventListenerCheck(handler, type2) {
  eventBundle(type2).forEach((_) => addEventListener(handler, _));
}
function addEventListener(handler, type2) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type2]) {
    handler._events[type2] = 1;
    canvas.addEventListener(type2, handler[type2] ? (evt) => handler[type2](evt) : (evt) => handler.fire(type2, evt));
  }
}
function move(moveEvent, overEvent, outEvent) {
  return function(evt) {
    const a2 = this._active, p = this.pickEvent(evt);
    if (p === a2) {
      this.fire(moveEvent, evt);
    } else {
      if (!a2 || !a2.exit) {
        this.fire(outEvent, evt);
      }
      this._active = p;
      this.fire(overEvent, evt);
      this.fire(moveEvent, evt);
    }
  };
}
function inactive(type2) {
  return function(evt) {
    this.fire(type2, evt);
    this._active = null;
  };
}
inherits(CanvasHandler, Handler$1, {
  initialize(el, origin, obj) {
    this._canvas = el && domFind(el, "canvas");
    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach((type2) => eventListenerCheck(this, type2));
    return Handler$1.prototype.initialize.call(this, el, origin, obj);
  },
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  },
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  },
  // supported events
  events: Events,
  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent, evt);
  },
  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),
  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),
  mouseout: inactive(MouseOutEvent),
  dragleave: inactive(DragLeaveEvent),
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent, evt);
  },
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent, evt);
      this._down = null;
    }
  },
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent, evt, true);
  },
  touchmove(evt) {
    this.fire(TouchMoveEvent, evt, true);
  },
  touchend(evt) {
    this.fire(TouchEndEvent, evt, true);
    this._touch = null;
  },
  // fire an event
  fire(type2, evt, touch2) {
    const a2 = touch2 ? this._touch : this._active, h2 = this._handlers[type2];
    evt.vegaType = type2;
    if (type2 === HrefEvent && a2 && a2.href) {
      this.handleHref(evt, a2, a2.href);
    } else if (type2 === TooltipShowEvent || type2 === TooltipHideEvent) {
      this.handleTooltip(evt, a2, type2 !== TooltipHideEvent);
    }
    if (h2) {
      for (let i = 0, len = h2.length; i < len; ++i) {
        h2[i].handler.call(this._obj, evt, a2);
      }
    }
  },
  // add an event handler
  on(type2, handler) {
    const name = this.eventName(type2), h2 = this._handlers, i = this._handlerIndex(h2[name], type2, handler);
    if (i < 0) {
      eventListenerCheck(this, type2);
      (h2[name] || (h2[name] = [])).push({
        type: type2,
        handler
      });
    }
    return this;
  },
  // remove an event handler
  off(type2, handler) {
    const name = this.eventName(type2), h2 = this._handlers[name], i = this._handlerIndex(h2, type2, handler);
    if (i >= 0) {
      h2.splice(i, 1);
    }
    return this;
  },
  pickEvent(evt) {
    const p = point$2(evt, this._canvas), o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  },
  // find the scenegraph item at the current mouse position
  // x, y -- the absolute x, y mouse coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x2, y2, gx, gy) {
    const g = this.context(), mark2 = Marks[scene.marktype];
    return mark2.pick.call(this, g, scene, x2, y2, gx, gy);
  }
});
function devicePixelRatio() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
var pixelRatio = devicePixelRatio();
function resize(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context2 = canvas.getContext("2d"), ratio = inDOM ? pixelRatio : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key2 in opt) {
    context2[key2] = opt[key2];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context2.pixelRatio = ratio;
  context2.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
function CanvasRenderer(loader2) {
  Renderer.call(this, loader2);
  this._options = {};
  this._redraw = false;
  this._dirty = new Bounds();
  this._tempb = new Bounds();
}
const base$1 = Renderer.prototype;
const viewBounds = (origin, width2, height2) => new Bounds().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
function clipToBounds(g, b2, origin) {
  b2.expand(1).round();
  if (g.pixelRatio % 1) {
    b2.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b2.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b2.x1, b2.y1, b2.width(), b2.height());
  g.clip();
  return b2;
}
inherits(CanvasRenderer, Renderer, {
  initialize(el, width2, height2, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : domCanvas(1, 1, this._options.type);
    if (el && this._canvas) {
      domClear(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute("class", "marks");
    }
    return base$1.initialize.call(this, el, width2, height2, origin, scaleFactor);
  },
  resize(width2, height2, origin, scaleFactor) {
    base$1.resize.call(this, width2, height2, origin, scaleFactor);
    if (this._canvas) {
      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      const ctx = this._options.externalContext;
      if (!ctx) error("CanvasRenderer is missing a valid canvas or context");
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  },
  dirty(item) {
    const b2 = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b2.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b2);
  },
  _render(scene) {
    const g = this.context(), o = this._origin, w2 = this._width, h2 = this._height, db = this._dirty, vb = viewBounds(o, w2, h2);
    g.save();
    const b2 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w2, h2);
    this.draw(g, scene, b2);
    g.restore();
    db.clear();
    return this;
  },
  draw(ctx, scene, bounds2) {
    const mark2 = Marks[scene.marktype];
    if (scene.clip) clip$2(ctx, scene);
    mark2.draw.call(this, ctx, scene, bounds2);
    if (scene.clip) ctx.restore();
  },
  clear(x2, y2, w2, h2) {
    const opt = this._options, g = this.context();
    if (opt.type !== "pdf" && !opt.externalContext) {
      g.clearRect(x2, y2, w2, h2);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x2, y2, w2, h2);
    }
  }
});
function SVGHandler(loader2, tooltip2) {
  Handler$1.call(this, loader2, tooltip2);
  const h2 = this;
  h2._hrefHandler = listener(h2, (evt, item) => {
    if (item && item.href) h2.handleHref(evt, item, item.href);
  });
  h2._tooltipHandler = listener(h2, (evt, item) => {
    h2.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
  });
}
const listener = (context2, handler) => (evt) => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context2._obj, evt, item);
};
inherits(SVGHandler, Handler$1, {
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    this._svg = svg = el && domFind(el, "svg");
    if (svg) {
      svg.addEventListener(HrefEvent, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    return Handler$1.prototype.initialize.call(this, el, origin, obj);
  },
  canvas() {
    return this._svg;
  },
  // add an event handler
  on(type2, handler) {
    const name = this.eventName(type2), h2 = this._handlers, i = this._handlerIndex(h2[name], type2, handler);
    if (i < 0) {
      const x2 = {
        type: type2,
        handler,
        listener: listener(this, handler)
      };
      (h2[name] || (h2[name] = [])).push(x2);
      if (this._svg) {
        this._svg.addEventListener(name, x2.listener);
      }
    }
    return this;
  },
  // remove an event handler
  off(type2, handler) {
    const name = this.eventName(type2), h2 = this._handlers[name], i = this._handlerIndex(h2, type2, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h2[i].listener);
      }
      h2.splice(i, 1);
    }
    return this;
  }
});
const ARIA_HIDDEN = "aria-hidden";
const ARIA_LABEL = "aria-label";
const ARIA_ROLE = "role";
const ARIA_ROLEDESCRIPTION = "aria-roledescription";
const GRAPHICS_OBJECT = "graphics-object";
const GRAPHICS_SYMBOL = "graphics-symbol";
const bundle = (role, roledesc, label2) => ({
  [ARIA_ROLE]: role,
  [ARIA_ROLEDESCRIPTION]: roledesc,
  [ARIA_LABEL]: label2 || void 0
});
const AriaIgnore = toSet(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
const AriaGuides = {
  "axis": {
    desc: "axis",
    caption: axisCaption
  },
  "legend": {
    desc: "legend",
    caption: legendCaption
  },
  "title-text": {
    desc: "title",
    caption: (item) => "Title text '".concat(titleCaption(item), "'")
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (item) => "Subtitle text '".concat(titleCaption(item), "'")
  }
};
const AriaEncode = {
  ariaRole: ARIA_ROLE,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
  description: ARIA_LABEL
};
function ariaItemAttributes(emit2, item) {
  const hide2 = item.aria === false;
  emit2(ARIA_HIDDEN, hide2 || void 0);
  if (hide2 || item.description == null) {
    for (const prop in AriaEncode) {
      emit2(AriaEncode[prop], void 0);
    }
  } else {
    const type2 = item.mark.marktype;
    emit2(ARIA_LABEL, item.description);
    emit2(ARIA_ROLE, item.ariaRole || (type2 === "group" ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit2(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || "".concat(type2, " mark"));
  }
}
function ariaMarkAttributes(mark2) {
  return mark2.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark2.role] ? null : AriaGuides[mark2.role] ? ariaGuide(mark2, AriaGuides[mark2.role]) : ariaMark(mark2);
}
function ariaMark(mark2) {
  const type2 = mark2.marktype;
  const recurse2 = type2 === "group" || type2 === "text" || mark2.items.some((_) => _.description != null && _.aria !== false);
  return bundle(recurse2 ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, "".concat(type2, " mark container"), mark2.description);
}
function ariaGuide(mark2, opt) {
  try {
    const item = mark2.items[0], caption = opt.caption || (() => "");
    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption(item) {
  return array$5(item.text).join(" ");
}
function axisCaption(item) {
  const datum2 = item.datum, orient2 = item.orient, title2 = datum2.title ? extractTitle(item) : null, ctx = item.context, scale2 = ctx.scales[datum2.scale].value, locale2 = ctx.dataflow.locale(), type2 = scale2.type, xy = orient2 === "left" || orient2 === "right" ? "Y" : "X";
  return "".concat(xy, "-axis") + (title2 ? " titled '".concat(title2, "'") : "") + " for a ".concat(isDiscrete$2(type2) ? "discrete" : type2, " scale") + " with ".concat(domainCaption(locale2, scale2, item));
}
function legendCaption(item) {
  const datum2 = item.datum, title2 = datum2.title ? extractTitle(item) : null, type2 = "".concat(datum2.type || "", " legend").trim(), scales2 = datum2.scales, props = Object.keys(scales2), ctx = item.context, scale2 = ctx.scales[scales2[props[0]]].value, locale2 = ctx.dataflow.locale();
  return capitalize$3(type2) + (title2 ? " titled '".concat(title2, "'") : "") + " for ".concat(channelCaption(props)) + " with ".concat(domainCaption(locale2, scale2, item));
}
function extractTitle(item) {
  try {
    return array$5(peek$2(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek$2(props);
}
function capitalize$3(s) {
  return s.length ? s[0].toUpperCase() + s.slice(1) : s;
}
const innerText = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
const attrText = (val) => innerText(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup() {
  let buf = "", outer = "", inner2 = "";
  const stack2 = [], clear2 = () => outer = inner2 = "", push2 = (tag) => {
    if (outer) {
      buf += "".concat(outer, ">").concat(inner2);
      clear2();
    }
    stack2.push(tag);
  }, attr2 = (name, value2) => {
    if (value2 != null) outer += " ".concat(name, '="').concat(attrText(value2), '"');
    return m2;
  }, m2 = {
    open(tag) {
      push2(tag);
      outer = "<" + tag;
      for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        attrs[_key - 1] = arguments[_key];
      }
      for (const set2 of attrs) {
        for (const key2 in set2) attr2(key2, set2[key2]);
      }
      return m2;
    },
    close() {
      const tag = stack2.pop();
      if (outer) {
        buf += outer + (inner2 ? ">".concat(inner2, "</").concat(tag, ">") : "/>");
      } else {
        buf += "</".concat(tag, ">");
      }
      clear2();
      return m2;
    },
    attr: attr2,
    text: (t4) => (inner2 += innerText(t4), m2),
    toString: () => buf
  };
  return m2;
}
const serializeXML = (node2) => _serialize(markup(), node2) + "";
function _serialize(m2, node2) {
  m2.open(node2.tagName);
  if (node2.hasAttributes()) {
    const attrs = node2.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m2.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node2.hasChildNodes()) {
    const children2 = node2.childNodes;
    for (const child of children2) {
      child.nodeType === 3 ? m2.text(child.nodeValue) : _serialize(m2, child);
    }
  }
  return m2.close();
}
const stylesAttr = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
};
const stylesCss = {
  blend: "mix-blend-mode"
};
const rootAttributes = {
  "fill": "none",
  "stroke-miterlimit": 10
};
const RootIndex = 0, xmlns = "http://www.w3.org/2000/xmlns/", svgns = metadata.xmlns;
function SVGRenderer(loader2) {
  Renderer.call(this, loader2);
  this._dirtyID = 0;
  this._dirty = [];
  this._svg = null;
  this._root = null;
  this._defs = null;
}
const base = Renderer.prototype;
inherits(SVGRenderer, Renderer, {
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild(el, 0, "svg", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns:xlink", metadata["xmlns:xlink"]);
      this._svg.setAttribute("version", metadata["version"]);
      this._svg.setAttribute("class", "marks");
      domClear(el, 1);
      this._root = domChild(this._svg, RootIndex, "g", svgns);
      setAttributes$1(this._root, rootAttributes);
      domClear(this._svg, RootIndex + 1);
    }
    this.background(this._bgcolor);
    return base.initialize.call(this, el, width2, height2, origin, scaleFactor);
  },
  /**
   * Get / set the background color.
   */
  background(bgcolor2) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty("background-color", bgcolor2);
    }
    return base.background.apply(this, arguments);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    base.resize.call(this, width2, height2, origin, scaleFactor);
    if (this._svg) {
      setAttributes$1(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: "0 0 ".concat(this._width, " ").concat(this._height)
      });
      this._root.setAttribute("transform", "translate(".concat(this._origin, ")"));
    }
    this._dirty = [];
    return this;
  },
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  },
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg, bg = this._bgcolor;
    if (!svg) return null;
    let node2;
    if (bg) {
      svg.removeAttribute("style");
      node2 = domChild(svg, RootIndex, "rect", svgns);
      setAttributes$1(node2, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text2 = serializeXML(svg);
    if (bg) {
      svg.removeChild(node2);
      this._svg.style.setProperty("background-color", bg);
    }
    return text2;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    if (this._dirtyCheck()) {
      if (this._dirtyAll) this._clearDefs();
      this.mark(this._root, scene);
      domClear(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  },
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  },
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
  },
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID) return true;
    const id2 = ++this._dirtyID;
    let item, mark2, type2, mdef, i, n, o;
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark2 = item.mark;
      if (mark2.marktype !== type2) {
        type2 = mark2.marktype;
        mdef = Marks[type2];
      }
      if (mark2.zdirty && mark2.dirty !== id2) {
        this._dirtyAll = false;
        dirtyParents(item, id2);
        mark2.items.forEach((i2) => {
          i2.dirty = id2;
        });
      }
      if (mark2.zdirty) continue;
      if (item.exit) {
        if (mdef.nested && mark2.items.length) {
          o = mark2.items[0];
          if (o._svg) this._update(mdef, o._svg, o);
        } else if (item._svg) {
          o = item._svg.parentNode;
          if (o) o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark2.items[0] : item;
      if (item._update === id2) continue;
      if (!item._svg || !item._svg.ownerSVGElement) {
        this._dirtyAll = false;
        dirtyParents(item, id2);
      } else {
        this._update(mdef, item._svg, item);
      }
      item._update = id2;
    }
    return !this._dirtyAll;
  },
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   */
  mark(el, scene, prev2) {
    if (!this.isDirty(scene)) {
      return scene._svg;
    }
    const svg = this._svg, mdef = Marks[scene.marktype], events2 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
    const parent = bind$1(scene, el, prev2, "g", svg);
    parent.setAttribute("class", cssClass(scene));
    const aria2 = ariaMarkAttributes(scene);
    for (const key2 in aria2) setAttribute(parent, key2, aria2[key2]);
    if (!isGroup) {
      setAttribute(parent, "pointer-events", events2);
    }
    setAttribute(parent, "clip-path", scene.clip ? clip$1$1(this, scene, scene.group) : null);
    let sibling = null, i = 0;
    const process2 = (item) => {
      const dirty = this.isDirty(item), node2 = bind$1(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node2, item);
        if (isGroup) recurse(this, node2, item);
      }
      sibling = node2;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length) process2(scene.items[0]);
    } else {
      visit(scene, process2);
    }
    domClear(parent, i);
    return parent;
  },
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    element$1 = el;
    values$4 = el.__values__;
    ariaItemAttributes(emit, item);
    mdef.attr(emit, item, this);
    const extra = mark_extras[mdef.type];
    if (extra) extra.call(this, mdef, el, item);
    if (element$1) this.style(element$1, item);
  },
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null) return;
    for (const prop in stylesAttr) {
      let value2 = prop === "font" ? fontFamily(item) : item[prop];
      if (value2 === values$4[prop]) continue;
      const name = stylesAttr[prop];
      if (value2 == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient(value2)) {
          value2 = gradientRef(value2, this._defs.gradient, href());
        }
        el.setAttribute(name, value2 + "");
      }
      values$4[prop] = value2;
    }
    for (const prop in stylesCss) {
      setStyle(el, stylesCss[prop], item[prop]);
    }
  },
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg, defs = this._defs;
    let el = defs.el, index2 = 0;
    for (const id2 in defs.gradient) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index2 = updateGradient(el, defs.gradient[id2], index2);
    }
    for (const id2 in defs.clipping) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index2 = updateClipping(el, defs.clipping[id2], index2);
    }
    if (el) {
      index2 === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index2);
    }
  },
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def2 = this._defs;
    def2.gradient = {};
    def2.clipping = {};
  }
});
function dirtyParents(item, id2) {
  for (; item && item.dirty !== id2; item = item.mark.group) {
    item.dirty = id2;
    if (item.mark && item.mark.dirty !== id2) {
      item.mark.dirty = id2;
    } else return;
  }
}
function updateGradient(el, grad, index2) {
  let i, n, stop3;
  if (grad.gradient === "radial") {
    let pt = domChild(el, index2++, "pattern", svgns);
    setAttributes$1(pt, {
      id: patternPrefix + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild(pt, 0, "rect", svgns);
    setAttributes$1(pt, {
      width: 1,
      height: 1,
      fill: "url(".concat(href(), "#").concat(grad.id, ")")
    });
    el = domChild(el, index2++, "radialGradient", svgns);
    setAttributes$1(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index2++, "linearGradient", svgns);
    setAttributes$1(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop3 = domChild(el, i, "stop", svgns);
    stop3.setAttribute("offset", grad.stops[i].offset);
    stop3.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear(el, i);
  return index2;
}
function updateClipping(el, clip2, index2) {
  let mask;
  el = domChild(el, index2, "clipPath", svgns);
  el.setAttribute("id", clip2.id);
  if (clip2.path) {
    mask = domChild(el, 0, "path", svgns);
    mask.setAttribute("d", clip2.path);
  } else {
    mask = domChild(el, 0, "rect", svgns);
    setAttributes$1(mask, {
      x: 0,
      y: 0,
      width: clip2.width,
      height: clip2.height
    });
  }
  domClear(el, 1);
  return index2 + 1;
}
function recurse(renderer, el, group2) {
  el = el.lastChild.previousSibling;
  let prev2, idx = 0;
  visit(group2, (item) => {
    prev2 = renderer.mark(el, item, prev2);
    ++idx;
  });
  domClear(el, 1 + idx);
}
function bind$1(item, el, sibling, tag, svg) {
  let node2 = item._svg, doc;
  if (!node2) {
    doc = el.ownerDocument;
    node2 = domCreate(doc, tag, svgns);
    item._svg = node2;
    if (item.mark) {
      node2.__data__ = item;
      node2.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate(doc, "path", svgns);
        node2.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, "g", svgns);
        node2.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, "path", svgns);
        node2.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node2.ownerSVGElement !== svg || siblingCheck(node2, sibling)) {
    el.insertBefore(node2, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node2;
}
function siblingCheck(node2, sibling) {
  return node2.parentNode && node2.parentNode.childNodes.length > 1 && node2.previousSibling != sibling;
}
let element$1 = null, values$4 = null;
const mark_extras = {
  group(mdef, el, item) {
    const fg = element$1 = el.childNodes[2];
    values$4 = fg.__values__;
    mdef.foreground(emit, item, this);
    values$4 = el.__values__;
    element$1 = el.childNodes[1];
    mdef.content(emit, item, this);
    const bg = element$1 = el.childNodes[0];
    mdef.background(emit, item, this);
    const value2 = item.mark.interactive === false ? "none" : null;
    if (value2 !== values$4.events) {
      setAttribute(fg, "pointer-events", value2);
      setAttribute(bg, "pointer-events", value2);
      values$4.events = value2;
    }
    if (item.strokeForeground && item.stroke) {
      const fill2 = item.fill;
      setAttribute(fg, "display", null);
      this.style(bg, item);
      setAttribute(bg, "stroke", null);
      if (fill2) item.fill = null;
      values$4 = fg.__values__;
      this.style(fg, item);
      if (fill2) item.fill = fill2;
      element$1 = null;
    } else {
      setAttribute(fg, "display", "none");
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle(el, "image-rendering", "optimizeSpeed");
      setStyle(el, "image-rendering", "pixelated");
    } else {
      setStyle(el, "image-rendering", null);
    }
  },
  text(mdef, el, item) {
    const tl2 = textLines(item);
    let key2, value2, doc, lh;
    if (isArray$1(tl2)) {
      value2 = tl2.map((_) => textValue(item, _));
      key2 = value2.join("\n");
      if (key2 !== values$4.text) {
        domClear(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight(item);
        value2.forEach((t4, i) => {
          const ts2 = domCreate(doc, "tspan", svgns);
          ts2.__data__ = item;
          ts2.textContent = t4;
          if (i) {
            ts2.setAttribute("x", 0);
            ts2.setAttribute("dy", lh);
          }
          el.appendChild(ts2);
        });
        values$4.text = key2;
      }
    } else {
      value2 = textValue(item, tl2);
      if (value2 !== values$4.text) {
        el.textContent = value2;
        values$4.text = value2;
      }
    }
    setAttribute(el, "font-family", fontFamily(item));
    setAttribute(el, "font-size", fontSize(item) + "px");
    setAttribute(el, "font-style", item.fontStyle);
    setAttribute(el, "font-variant", item.fontVariant);
    setAttribute(el, "font-weight", item.fontWeight);
  }
};
function emit(name, value2, ns) {
  if (value2 === values$4[name]) return;
  if (ns) {
    setAttributeNS(element$1, name, value2, ns);
  } else {
    setAttribute(element$1, name, value2);
  }
  values$4[name] = value2;
}
function setStyle(el, name, value2) {
  if (value2 !== values$4[name]) {
    if (value2 == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value2 + "");
    }
    values$4[name] = value2;
  }
}
function setAttributes$1(el, attrs) {
  for (const key2 in attrs) {
    setAttribute(el, key2, attrs[key2]);
  }
}
function setAttribute(el, name, value2) {
  if (value2 != null) {
    el.setAttribute(name, value2);
  } else {
    el.removeAttribute(name);
  }
}
function setAttributeNS(el, name, value2, ns) {
  if (value2 != null) {
    el.setAttributeNS(ns, name, value2);
  } else {
    el.removeAttributeNS(ns, name);
  }
}
function href() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
function SVGStringRenderer(loader2) {
  Renderer.call(this, loader2);
  this._text = null;
  this._defs = {
    gradient: {},
    clipping: {}
  };
}
inherits(SVGStringRenderer, Renderer, {
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m2 = markup();
    m2.open("svg", extend$3({}, metadata, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: "0 0 ".concat(this._width, " ").concat(this._height)
    }));
    const bg = this._bgcolor;
    if (bg && bg !== "transparent" && bg !== "none") {
      m2.open("rect", {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }
    m2.open("g", rootAttributes, {
      transform: "translate(" + this._origin + ")"
    });
    this.mark(m2, scene);
    m2.close();
    this.defs(m2);
    this._text = m2.close() + "";
    return this;
  },
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m2, scene) {
    const mdef = Marks[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes, mdef.attr];
    m2.open("g", {
      "class": cssClass(scene),
      "clip-path": scene.clip ? clip$1$1(this, scene, scene.group) : null
    }, ariaMarkAttributes(scene), {
      "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
    });
    const process2 = (item) => {
      const href2 = this.href(item);
      if (href2) m2.open("a", href2);
      m2.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
      if (tag === "text") {
        const tl2 = textLines(item);
        if (isArray$1(tl2)) {
          const attrs = {
            x: 0,
            dy: lineHeight(item)
          };
          for (let i = 0; i < tl2.length; ++i) {
            m2.open("tspan", i ? attrs : null).text(textValue(item, tl2[i])).close();
          }
        } else {
          m2.text(textValue(item, tl2));
        }
      } else if (tag === "g") {
        const fore = item.strokeForeground, fill2 = item.fill, stroke2 = item.stroke;
        if (fore && stroke2) {
          item.stroke = null;
        }
        m2.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
        m2.open("g", this.attr(scene, item, mdef.content));
        visit(item, (scene2) => this.mark(m2, scene2));
        m2.close();
        if (fore && stroke2) {
          if (fill2) item.fill = null;
          item.stroke = stroke2;
          m2.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
          if (fill2) item.fill = fill2;
        } else {
          m2.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
        }
      }
      m2.close();
      if (href2) m2.close();
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length) process2(scene.items[0]);
    } else {
      visit(scene, process2);
    }
    return m2.close();
  },
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href2 = item.href;
    let attr2;
    if (href2) {
      if (attr2 = this._hrefs && this._hrefs[href2]) {
        return attr2;
      } else {
        this.sanitizeURL(href2).then((attr3) => {
          attr3["xlink:href"] = attr3.href;
          attr3.href = null;
          (this._hrefs || (this._hrefs = {}))[href2] = attr3;
        });
      }
    }
    return null;
  },
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object2 = {}, emit2 = (name, value2, ns, prefixed) => {
      object2[prefixed || name] = value2;
    };
    if (Array.isArray(attrs)) {
      attrs.forEach((fn) => fn(emit2, item, this));
    } else {
      attrs(emit2, item, this);
    }
    if (tag) {
      style$2(object2, item, scene, tag, this._defs);
    }
    return object2;
  },
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m2) {
    const gradient2 = this._defs.gradient, clipping = this._defs.clipping, count2 = Object.keys(gradient2).length + Object.keys(clipping).length;
    if (count2 === 0) return;
    m2.open("defs");
    for (const id2 in gradient2) {
      const def2 = gradient2[id2], stops = def2.stops;
      if (def2.gradient === "radial") {
        m2.open("pattern", {
          id: patternPrefix + id2,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        m2.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + id2 + ")"
        }).close();
        m2.close();
        m2.open("radialGradient", {
          id: id2,
          fx: def2.x1,
          fy: def2.y1,
          fr: def2.r1,
          cx: def2.x2,
          cy: def2.y2,
          r: def2.r2
        });
      } else {
        m2.open("linearGradient", {
          id: id2,
          x1: def2.x1,
          x2: def2.x2,
          y1: def2.y1,
          y2: def2.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m2.open("stop", {
          offset: stops[i].offset,
          "stop-color": stops[i].color
        }).close();
      }
      m2.close();
    }
    for (const id2 in clipping) {
      const def2 = clipping[id2];
      m2.open("clipPath", {
        id: id2
      });
      if (def2.path) {
        m2.open("path", {
          d: def2.path
        }).close();
      } else {
        m2.open("rect", {
          x: 0,
          y: 0,
          width: def2.width,
          height: def2.height
        }).close();
      }
      m2.close();
    }
    m2.close();
  }
});
function style$2(s, item, scene, tag, defs) {
  let styleList;
  if (item == null) return s;
  if (tag === "bgrect" && scene.interactive === false) {
    s["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s["pointer-events"] = "none";
    }
    s.display = "none";
    if (item.fill !== null) return s;
  }
  if (tag === "image" && item.smooth === false) {
    styleList = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"];
  }
  if (tag === "text") {
    s["font-family"] = fontFamily(item);
    s["font-size"] = fontSize(item) + "px";
    s["font-style"] = item.fontStyle;
    s["font-variant"] = item.fontVariant;
    s["font-weight"] = item.fontWeight;
  }
  for (const prop in stylesAttr) {
    let value2 = item[prop];
    const name = stylesAttr[prop];
    if (value2 === "transparent" && (name === "fill" || name === "stroke")) ;
    else if (value2 != null) {
      if (isGradient(value2)) {
        value2 = gradientRef(value2, defs.gradient, "");
      }
      s[name] = value2;
    }
  }
  for (const prop in stylesCss) {
    const value2 = item[prop];
    if (value2 != null) {
      styleList = styleList || [];
      styleList.push("".concat(stylesCss[prop], ": ").concat(value2, ";"));
    }
  }
  if (styleList) {
    s.style = styleList.join(" ");
  }
  return s;
}
const Canvas = "canvas";
const PNG = "png";
const SVG = "svg";
const None$1 = "none";
const RenderType = {
  Canvas,
  PNG,
  SVG,
  None: None$1
};
const modules = {};
modules[Canvas] = modules[PNG] = {
  renderer: CanvasRenderer,
  headless: CanvasRenderer,
  handler: CanvasHandler
};
modules[SVG] = {
  renderer: SVGRenderer,
  headless: SVGStringRenderer,
  handler: SVGHandler
};
modules[None$1] = {};
function renderModule(name, _) {
  name = String(name || "").toLowerCase();
  if (arguments.length > 1) {
    modules[name] = _;
    return this;
  } else {
    return modules[name];
  }
}
function intersect$2(scene, bounds2, filter2) {
  const hits = [], box = new Bounds().union(bounds2), type2 = scene.marktype;
  return type2 ? intersectMark(scene, box, filter2, hits) : type2 === "group" ? intersectGroup(scene, box, filter2, hits) : error("Intersect scene must be mark node or group item.");
}
function intersectMark(mark2, box, filter2, hits) {
  if (visitMark(mark2, box, filter2)) {
    const items = mark2.items, type2 = mark2.marktype, n = items.length;
    let i = 0;
    if (type2 === "group") {
      for (; i < n; ++i) {
        intersectGroup(items[i], box, filter2, hits);
      }
    } else {
      for (const test2 = Marks[type2].isect; i < n; ++i) {
        const item = items[i];
        if (intersectItem(item, box, test2)) hits.push(item);
      }
    }
  }
  return hits;
}
function visitMark(mark2, box, filter2) {
  return mark2.bounds && box.intersects(mark2.bounds) && (mark2.marktype === "group" || mark2.interactive !== false && (!filter2 || filter2(mark2)));
}
function intersectGroup(group2, box, filter2, hits) {
  if (filter2 && filter2(group2.mark) && intersectItem(group2, box, Marks.group.isect)) {
    hits.push(group2);
  }
  const marks = group2.items, n = marks && marks.length;
  if (n) {
    const x2 = group2.x || 0, y2 = group2.y || 0;
    box.translate(-x2, -y2);
    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter2, hits);
    }
    box.translate(x2, y2);
  }
  return hits;
}
function intersectItem(item, box, test2) {
  const bounds2 = item.bounds;
  return box.encloses(bounds2) || box.intersects(bounds2) && test2(item, box);
}
const clipBounds = new Bounds();
function boundClip(mark2) {
  const clip2 = mark2.clip;
  if (isFunction$3(clip2)) {
    clip2(boundContext(clipBounds.clear()));
  } else if (clip2) {
    clipBounds.set(0, 0, mark2.group.width, mark2.group.height);
  } else return;
  mark2.bounds.intersect(clipBounds);
}
const TOLERANCE = 1e-9;
function sceneEqual(a2, b2, key2) {
  return a2 === b2 ? true : key2 === "path" ? pathEqual(a2, b2) : a2 instanceof Date && b2 instanceof Date ? +a2 === +b2 : isNumber$1(a2) && isNumber$1(b2) ? Math.abs(a2 - b2) <= TOLERANCE : !a2 || !b2 || !isObject$1(a2) && !isObject$1(b2) ? a2 == b2 : objectEqual(a2, b2);
}
function pathEqual(a2, b2) {
  return sceneEqual(parse$4(a2), parse$4(b2));
}
function objectEqual(a2, b2) {
  var ka = Object.keys(a2), kb = Object.keys(b2), key2, i;
  if (ka.length !== kb.length) return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key2 = ka[i];
    if (!sceneEqual(a2[key2], b2[key2], key2)) return false;
  }
  return typeof a2 === typeof b2;
}
function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}
const Top$1 = "top";
const Left$1 = "left";
const Right$1 = "right";
const Bottom$1 = "bottom";
const TopLeft = "top-left";
const TopRight = "top-right";
const BottomLeft = "bottom-left";
const BottomRight = "bottom-right";
const Start$1 = "start";
const Middle$1 = "middle";
const End$1 = "end";
const X$1 = "x";
const Y$1 = "y";
const Group = "group";
const AxisRole$1 = "axis";
const TitleRole$1 = "title";
const FrameRole$1 = "frame";
const ScopeRole$1 = "scope";
const LegendRole$1 = "legend";
const RowHeader = "row-header";
const RowFooter = "row-footer";
const RowTitle = "row-title";
const ColHeader = "column-header";
const ColFooter = "column-footer";
const ColTitle = "column-title";
const Padding$1 = "padding";
const Symbols$1 = "symbol";
const Fit = "fit";
const FitX = "fit-x";
const FitY = "fit-y";
const Pad = "pad";
const None = "none";
const All = "all";
const Each = "each";
const Flush = "flush";
const Column = "column";
const Row = "row";
function Bound$1(params2) {
  Transform.call(this, null, params2);
}
inherits(Bound$1, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow, mark2 = _.mark, type2 = mark2.marktype, entry2 = Marks[type2], bound2 = entry2.bound;
    let markBounds = mark2.bounds, rebound;
    if (entry2.nested) {
      if (mark2.items.length) view.dirty(mark2.items[0]);
      markBounds = boundItem(mark2, bound2);
      mark2.items.forEach((item) => {
        item.bounds.clear().union(markBounds);
      });
    } else if (type2 === Group || _.modified()) {
      pulse2.visit(pulse2.MOD, (item) => view.dirty(item));
      markBounds.clear();
      mark2.items.forEach((item) => markBounds.union(boundItem(item, bound2)));
      switch (mark2.role) {
        case AxisRole$1:
        case LegendRole$1:
        case TitleRole$1:
          pulse2.reflow();
      }
    } else {
      rebound = pulse2.changed(pulse2.REM);
      pulse2.visit(pulse2.ADD, (item) => {
        markBounds.union(boundItem(item, bound2));
      });
      pulse2.visit(pulse2.MOD, (item) => {
        rebound = rebound || markBounds.alignsWith(item.bounds);
        view.dirty(item);
        markBounds.union(boundItem(item, bound2));
      });
      if (rebound) {
        markBounds.clear();
        mark2.items.forEach((item) => markBounds.union(item.bounds));
      }
    }
    boundClip(mark2);
    return pulse2.modifies("bounds");
  }
});
function boundItem(item, bound2, opt) {
  return bound2(item.bounds.clear(), item, opt);
}
const COUNTER_NAME = ":vega_identifier:";
function Identifier$1(params2) {
  Transform.call(this, 0, params2);
}
Identifier$1.Definition = {
  "type": "Identifier",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "as",
    "type": "string",
    "required": true
  }]
};
inherits(Identifier$1, Transform, {
  transform(_, pulse2) {
    const counter2 = getCounter(pulse2.dataflow), as = _.as;
    let id2 = counter2.value;
    pulse2.visit(pulse2.ADD, (t4) => t4[as] = t4[as] || ++id2);
    counter2.set(this.value = id2);
    return pulse2;
  }
});
function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}
function Mark$2(params2) {
  Transform.call(this, null, params2);
}
inherits(Mark$2, Transform, {
  transform(_, pulse2) {
    let mark2 = this.value;
    if (!mark2) {
      mark2 = pulse2.dataflow.scenegraph().mark(_.markdef, lookup$3(_), _.index);
      mark2.group.context = _.context;
      if (!_.context.group) _.context.group = mark2.group;
      mark2.source = this.source;
      mark2.clip = _.clip;
      mark2.interactive = _.interactive;
      this.value = mark2;
    }
    const Init = mark2.marktype === Group ? GroupItem : Item;
    pulse2.visit(pulse2.ADD, (item) => Init.call(item, mark2));
    if (_.modified("clip") || _.modified("interactive")) {
      mark2.clip = _.clip;
      mark2.interactive = !!_.interactive;
      mark2.zdirty = true;
      pulse2.reflow();
    }
    mark2.items = pulse2.source;
    return pulse2;
  }
});
function lookup$3(_) {
  const g = _.groups, p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}
function Overlap$1(params2) {
  Transform.call(this, null, params2);
}
const methods = {
  parity: (items) => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
  greedy: (items, sep) => {
    let a2;
    return items.filter((b2, i) => !i || !intersect$1(a2.bounds, b2.bounds, sep) ? (a2 = b2, 1) : b2.opacity = 0);
  }
};
const intersect$1 = (a2, b2, sep) => sep > Math.max(b2.x1 - a2.x2, a2.x1 - b2.x2, b2.y1 - a2.y2, a2.y1 - b2.y2);
const hasOverlap = (items, pad2) => {
  for (var i = 1, n = items.length, a2 = items[0].bounds, b2; i < n; a2 = b2, ++i) {
    if (intersect$1(a2, b2 = items[i].bounds, pad2)) return true;
  }
};
const hasBounds = (item) => {
  const b2 = item.bounds;
  return b2.width() > 1 && b2.height() > 1;
};
const boundTest = (scale2, orient2, tolerance) => {
  var range2 = scale2.range(), b2 = new Bounds();
  if (orient2 === Top$1 || orient2 === Bottom$1) {
    b2.set(range2[0], -Infinity, range2[1], Infinity);
  } else {
    b2.set(-Infinity, range2[0], Infinity, range2[1]);
  }
  b2.expand(tolerance || 1);
  return (item) => b2.encloses(item.bounds);
};
const reset$1 = (source2) => {
  source2.forEach((item) => item.opacity = 1);
  return source2;
};
const reflow = (pulse2, _) => pulse2.reflow(_.modified()).modifies("opacity");
inherits(Overlap$1, Transform, {
  transform(_, pulse2) {
    const reduce2 = methods[_.method] || methods.parity, sep = _.separation || 0;
    let source2 = pulse2.materialize(pulse2.SOURCE).source, items, test2;
    if (!source2 || !source2.length) return;
    if (!_.method) {
      if (_.modified("method")) {
        reset$1(source2);
        pulse2 = reflow(pulse2, _);
      }
      return pulse2;
    }
    source2 = source2.filter(hasBounds);
    if (!source2.length) return;
    if (_.sort) {
      source2 = source2.slice().sort(_.sort);
    }
    items = reset$1(source2);
    pulse2 = reflow(pulse2, _);
    if (items.length >= 3 && hasOverlap(items, sep)) {
      do {
        items = reduce2(items, sep);
      } while (items.length >= 3 && hasOverlap(items, sep));
      if (items.length < 3 && !peek$2(source2).opacity) {
        if (items.length > 1) peek$2(items).opacity = 0;
        peek$2(source2).opacity = 1;
      }
    }
    if (_.boundScale && _.boundTolerance >= 0) {
      test2 = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
      source2.forEach((item) => {
        if (!test2(item)) item.opacity = 0;
      });
    }
    const bounds2 = items[0].mark.bounds.clear();
    source2.forEach((item) => {
      if (item.opacity) bounds2.union(item.bounds);
    });
    return pulse2;
  }
});
function Render$1(params2) {
  Transform.call(this, null, params2);
}
inherits(Render$1, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    pulse2.visit(pulse2.ALL, (item) => view.dirty(item));
    if (pulse2.fields && pulse2.fields["zindex"]) {
      const item = pulse2.source && pulse2.source[0];
      if (item) item.mark.zdirty = true;
    }
  }
});
const tempBounds = new Bounds();
function set$4(item, property2, value2) {
  return item[property2] === value2 ? 0 : (item[property2] = value2, 1);
}
function isYAxis(mark2) {
  var orient2 = mark2.items[0].orient;
  return orient2 === Left$1 || orient2 === Right$1;
}
function axisIndices(datum2) {
  let index2 = +datum2.grid;
  return [
    datum2.ticks ? index2++ : -1,
    // ticks index
    datum2.labels ? index2++ : -1,
    // labels index
    index2 + +datum2.domain
    // title index
  ];
}
function axisLayout(view, axis, width2, height2) {
  var item = axis.items[0], datum2 = item.datum, delta = item.translate != null ? item.translate : 0.5, orient2 = item.orient, indices = axisIndices(datum2), range2 = item.range, offset2 = item.offset, position2 = item.position, minExtent = item.minExtent, maxExtent = item.maxExtent, title2 = datum2.title && item.items[indices[2]].items[0], titlePadding = item.titlePadding, bounds2 = item.bounds, dl = title2 && multiLineOffset(title2), x2 = 0, y2 = 0, i, s;
  tempBounds.clear().union(bounds2);
  bounds2.clear();
  if ((i = indices[0]) > -1) bounds2.union(item.items[i].bounds);
  if ((i = indices[1]) > -1) bounds2.union(item.items[i].bounds);
  switch (orient2) {
    case Top$1:
      x2 = position2 || 0;
      y2 = -offset2;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds2.y1));
      bounds2.add(0, -s).add(range2, 0);
      if (title2) axisTitleLayout(view, title2, s, titlePadding, dl, 0, -1, bounds2);
      break;
    case Left$1:
      x2 = -offset2;
      y2 = position2 || 0;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds2.x1));
      bounds2.add(-s, 0).add(0, range2);
      if (title2) axisTitleLayout(view, title2, s, titlePadding, dl, 1, -1, bounds2);
      break;
    case Right$1:
      x2 = width2 + offset2;
      y2 = position2 || 0;
      s = Math.max(minExtent, Math.min(maxExtent, bounds2.x2));
      bounds2.add(0, 0).add(s, range2);
      if (title2) axisTitleLayout(view, title2, s, titlePadding, dl, 1, 1, bounds2);
      break;
    case Bottom$1:
      x2 = position2 || 0;
      y2 = height2 + offset2;
      s = Math.max(minExtent, Math.min(maxExtent, bounds2.y2));
      bounds2.add(0, 0).add(range2, s);
      if (title2) axisTitleLayout(view, title2, s, titlePadding, 0, 0, 1, bounds2);
      break;
    default:
      x2 = item.x;
      y2 = item.y;
  }
  boundStroke(bounds2.translate(x2, y2), item);
  if (set$4(item, "x", x2 + delta) | set$4(item, "y", y2 + delta)) {
    item.bounds = tempBounds;
    view.dirty(item);
    item.bounds = bounds2;
    view.dirty(item);
  }
  return item.mark.bounds.clear().union(bounds2);
}
function axisTitleLayout(view, title2, offset2, pad2, dl, isYAxis2, sign2, bounds2) {
  const b2 = title2.bounds;
  if (title2.auto) {
    const v = sign2 * (offset2 + dl + pad2);
    let dx = 0, dy = 0;
    view.dirty(title2);
    isYAxis2 ? dx = (title2.x || 0) - (title2.x = v) : dy = (title2.y || 0) - (title2.y = v);
    title2.mark.bounds.clear().union(b2.translate(-dx, -dy));
    view.dirty(title2);
  }
  bounds2.union(b2);
}
const min = (a2, b2) => Math.floor(Math.min(a2, b2));
const max = (a2, b2) => Math.ceil(Math.max(a2, b2));
function gridLayoutGroups(group2) {
  var groups = group2.items, n = groups.length, i = 0, mark2, items;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; i < n; ++i) {
    mark2 = groups[i];
    items = mark2.items;
    if (mark2.marktype === Group) {
      switch (mark2.role) {
        case AxisRole$1:
        case LegendRole$1:
        case TitleRole$1:
          break;
        case RowHeader:
          views.rowheaders.push(...items);
          break;
        case RowFooter:
          views.rowfooters.push(...items);
          break;
        case ColHeader:
          views.colheaders.push(...items);
          break;
        case ColFooter:
          views.colfooters.push(...items);
          break;
        case RowTitle:
          views.rowtitle = items[0];
          break;
        case ColTitle:
          views.coltitle = items[0];
          break;
        default:
          views.marks.push(...items);
      }
    }
  }
  return views;
}
function bboxFlush(item) {
  return new Bounds().set(0, 0, item.width || 0, item.height || 0);
}
function bboxFull(item) {
  const b2 = item.bounds.clone();
  return b2.empty() ? b2.set(0, 0, 0, 0) : b2.translate(-(item.x || 0), -(item.y || 0));
}
function get$2(opt, key2, d) {
  const v = isObject$1(opt) ? opt[key2] : opt;
  return v != null ? v : d !== void 0 ? d : 0;
}
function offsetValue$1(v) {
  return v < 0 ? Math.ceil(-v) : 0;
}
function gridLayout(view, groups, opt) {
  var dirty = !opt.nodirty, bbox = opt.bounds === Flush ? bboxFlush : bboxFull, bounds2 = tempBounds.set(0, 0, 0, 0), alignCol = get$2(opt.align, Column), alignRow = get$2(opt.align, Row), padCol = get$2(opt.padding, Column), padRow = get$2(opt.padding, Row), ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), n = groups.length, xOffset = Array(n), xExtent = Array(ncols), xMax = 0, yOffset = Array(n), yExtent = Array(nrows), yMax = 0, dx = Array(n), dy = Array(n), boxes = Array(n), m2, i, c2, r2, b2, g, px2, py2, x2, y2, offset2;
  for (i = 0; i < ncols; ++i) xExtent[i] = 0;
  for (i = 0; i < nrows; ++i) yExtent[i] = 0;
  for (i = 0; i < n; ++i) {
    g = groups[i];
    b2 = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c2 = i % ncols;
    r2 = ~~(i / ncols);
    xMax = Math.max(xMax, px2 = Math.ceil(b2.x2));
    yMax = Math.max(yMax, py2 = Math.ceil(b2.y2));
    xExtent[c2] = Math.max(xExtent[c2], px2);
    yExtent[r2] = Math.max(yExtent[r2], py2);
    xOffset[i] = padCol + offsetValue$1(b2.x1);
    yOffset[i] = padRow + offsetValue$1(b2.y1);
    if (dirty) view.dirty(groups[i]);
  }
  for (i = 0; i < n; ++i) {
    if (i % ncols === 0) xOffset[i] = 0;
    if (i < ncols) yOffset[i] = 0;
  }
  if (alignCol === Each) {
    for (c2 = 1; c2 < ncols; ++c2) {
      for (offset2 = 0, i = c2; i < n; i += ncols) {
        if (offset2 < xOffset[i]) offset2 = xOffset[i];
      }
      for (i = c2; i < n; i += ncols) {
        xOffset[i] = offset2 + xExtent[c2 - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset2 = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset2 < xOffset[i]) offset2 = xOffset[i];
    }
    for (i = 0; i < n; ++i) {
      if (i % ncols) xOffset[i] = offset2 + xMax;
    }
  } else {
    for (alignCol = false, c2 = 1; c2 < ncols; ++c2) {
      for (i = c2; i < n; i += ncols) {
        xOffset[i] += xExtent[c2 - 1];
      }
    }
  }
  if (alignRow === Each) {
    for (r2 = 1; r2 < nrows; ++r2) {
      for (offset2 = 0, i = r2 * ncols, m2 = i + ncols; i < m2; ++i) {
        if (offset2 < yOffset[i]) offset2 = yOffset[i];
      }
      for (i = r2 * ncols; i < m2; ++i) {
        yOffset[i] = offset2 + yExtent[r2 - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset2 = 0, i = ncols; i < n; ++i) {
      if (offset2 < yOffset[i]) offset2 = yOffset[i];
    }
    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset2 + yMax;
    }
  } else {
    for (alignRow = false, r2 = 1; r2 < nrows; ++r2) {
      for (i = r2 * ncols, m2 = i + ncols; i < m2; ++i) {
        yOffset[i] += yExtent[r2 - 1];
      }
    }
  }
  for (x2 = 0, i = 0; i < n; ++i) {
    x2 = xOffset[i] + (i % ncols ? x2 : 0);
    dx[i] += x2 - groups[i].x;
  }
  for (c2 = 0; c2 < ncols; ++c2) {
    for (y2 = 0, i = c2; i < n; i += ncols) {
      y2 += yOffset[i];
      dy[i] += y2 - groups[i].y;
    }
  }
  if (alignCol && get$2(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b2 = alignCol === All ? xMax : xExtent[i % ncols];
      x2 = b2 - boxes[i].x2 - groups[i].x - dx[i];
      if (x2 > 0) dx[i] += x2 / 2;
    }
  }
  if (alignRow && get$2(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b2 = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y2 = b2 - boxes[i].y2 - groups[i].y - dy[i];
      if (y2 > 0) dy[i] += y2 / 2;
    }
  }
  for (i = 0; i < n; ++i) {
    bounds2.union(boxes[i].translate(dx[i], dy[i]));
  }
  x2 = get$2(opt.anchor, X$1);
  y2 = get$2(opt.anchor, Y$1);
  switch (get$2(opt.anchor, Column)) {
    case End$1:
      x2 -= bounds2.width();
      break;
    case Middle$1:
      x2 -= bounds2.width() / 2;
  }
  switch (get$2(opt.anchor, Row)) {
    case End$1:
      y2 -= bounds2.height();
      break;
    case Middle$1:
      y2 -= bounds2.height() / 2;
  }
  x2 = Math.round(x2);
  y2 = Math.round(y2);
  bounds2.clear();
  for (i = 0; i < n; ++i) {
    groups[i].mark.bounds.clear();
  }
  for (i = 0; i < n; ++i) {
    g = groups[i];
    g.x += dx[i] += x2;
    g.y += dy[i] += y2;
    bounds2.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty) view.dirty(g);
  }
  return bounds2;
}
function trellisLayout(view, group2, opt) {
  var views = gridLayoutGroups(group2), groups = views.marks, bbox = opt.bounds === Flush ? boundFlush : boundFull, off = opt.offset, ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), cells = nrows * ncols, x2, y2, x22, y22, anchor, band2, offset2;
  const bounds2 = gridLayout(view, groups, opt);
  if (bounds2.empty()) bounds2.set(0, 0, 0, 0);
  if (views.rowheaders) {
    band2 = get$2(opt.headerBand, Row, null);
    x2 = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get$2(off, "rowHeader"), min, 0, bbox, "x1", 0, ncols, 1, band2);
  }
  if (views.colheaders) {
    band2 = get$2(opt.headerBand, Column, null);
    y2 = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get$2(off, "columnHeader"), min, 1, bbox, "y1", 0, 1, ncols, band2);
  }
  if (views.rowfooters) {
    band2 = get$2(opt.footerBand, Row, null);
    x22 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get$2(off, "rowFooter"), max, 0, bbox, "x2", ncols - 1, ncols, 1, band2);
  }
  if (views.colfooters) {
    band2 = get$2(opt.footerBand, Column, null);
    y22 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get$2(off, "columnFooter"), max, 1, bbox, "y2", cells - ncols, 1, ncols, band2);
  }
  if (views.rowtitle) {
    anchor = get$2(opt.titleAnchor, Row);
    offset2 = get$2(off, "rowTitle");
    offset2 = anchor === End$1 ? x22 + offset2 : x2 - offset2;
    band2 = get$2(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset2, 0, bounds2, band2);
  }
  if (views.coltitle) {
    anchor = get$2(opt.titleAnchor, Column);
    offset2 = get$2(off, "columnTitle");
    offset2 = anchor === End$1 ? y22 + offset2 : y2 - offset2;
    band2 = get$2(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset2, 1, bounds2, band2);
  }
}
function boundFlush(item, field2) {
  return field2 === "x1" ? item.x || 0 : field2 === "y1" ? item.y || 0 : field2 === "x2" ? (item.x || 0) + (item.width || 0) : field2 === "y2" ? (item.y || 0) + (item.height || 0) : void 0;
}
function boundFull(item, field2) {
  return item.bounds[field2];
}
function layoutHeaders(view, headers, groups, ncols, limit, offset2, agg, isX2, bound2, bf, start, stride, back, band2) {
  var n = groups.length, init2 = 0, edge = 0, i, j, k, m2, b2, h2, g, x2, y2;
  if (!n) return init2;
  for (i = start; i < n; i += stride) {
    if (groups[i]) init2 = agg(init2, bound2(groups[i], bf));
  }
  if (!headers.length) return init2;
  if (headers.length > limit) {
    view.warn("Grid headers exceed limit: " + limit);
    headers = headers.slice(0, limit);
  }
  init2 += offset2;
  for (j = 0, m2 = headers.length; j < m2; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  }
  for (i = start, j = 0, m2 = headers.length; j < m2; ++j, i += stride) {
    h2 = headers[j];
    b2 = h2.mark.bounds;
    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back) ;
    if (isX2) {
      x2 = band2 == null ? g.x : Math.round(g.bounds.x1 + band2 * g.bounds.width());
      y2 = init2;
    } else {
      x2 = init2;
      y2 = band2 == null ? g.y : Math.round(g.bounds.y1 + band2 * g.bounds.height());
    }
    b2.union(h2.bounds.translate(x2 - (h2.x || 0), y2 - (h2.y || 0)));
    h2.x = x2;
    h2.y = y2;
    view.dirty(h2);
    edge = agg(edge, b2[bf]);
  }
  return edge;
}
function layoutTitle(view, g, offset2, isX2, bounds2, band2) {
  if (!g) return;
  view.dirty(g);
  var x2 = offset2, y2 = offset2;
  isX2 ? x2 = Math.round(bounds2.x1 + band2 * bounds2.width()) : y2 = Math.round(bounds2.y1 + band2 * bounds2.height());
  g.bounds.translate(x2 - (g.x || 0), y2 - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x2;
  g.y = y2;
  view.dirty(g);
}
function lookup$1$1(config, orient2) {
  const opt = config[orient2] || {};
  return (key2, d) => opt[key2] != null ? opt[key2] : config[key2] != null ? config[key2] : d;
}
function offsets(legends, value2) {
  let max2 = -Infinity;
  legends.forEach((item) => {
    if (item.offset != null) max2 = Math.max(max2, item.offset);
  });
  return max2 > -Infinity ? max2 : value2;
}
function legendParams(g, orient2, config, xb, yb, w2, h2) {
  const _ = lookup$1$1(config, orient2), offset2 = offsets(g, _("offset", 0)), anchor = _("anchor", Start$1), mult2 = anchor === End$1 ? 1 : anchor === Middle$1 ? 0.5 : 0;
  const p = {
    align: Each,
    bounds: _("bounds", Flush),
    columns: _("direction") === "vertical" ? 1 : g.length,
    padding: _("margin", 8),
    center: _("center"),
    nodirty: true
  };
  switch (orient2) {
    case Left$1:
      p.anchor = {
        x: Math.floor(xb.x1) - offset2,
        column: End$1,
        y: mult2 * (h2 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Right$1:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset2,
        y: mult2 * (h2 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Top$1:
      p.anchor = {
        y: Math.floor(yb.y1) - offset2,
        row: End$1,
        x: mult2 * (w2 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case Bottom$1:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset2,
        x: mult2 * (w2 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case TopLeft:
      p.anchor = {
        x: offset2,
        y: offset2
      };
      break;
    case TopRight:
      p.anchor = {
        x: w2 - offset2,
        y: offset2,
        column: End$1
      };
      break;
    case BottomLeft:
      p.anchor = {
        x: offset2,
        y: h2 - offset2,
        row: End$1
      };
      break;
    case BottomRight:
      p.anchor = {
        x: w2 - offset2,
        y: h2 - offset2,
        column: End$1,
        row: End$1
      };
      break;
  }
  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0], datum2 = item.datum, orient2 = item.orient, bounds2 = item.bounds, x2 = item.x, y2 = item.y, w2, h2;
  item._bounds ? item._bounds.clear().union(bounds2) : item._bounds = bounds2.clone();
  bounds2.clear();
  legendGroupLayout(view, item, item.items[0].items[0]);
  bounds2 = legendBounds(item, bounds2);
  w2 = 2 * item.padding;
  h2 = 2 * item.padding;
  if (!bounds2.empty()) {
    w2 = Math.ceil(bounds2.width() + w2);
    h2 = Math.ceil(bounds2.height() + h2);
  }
  if (datum2.type === Symbols$1) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }
  if (orient2 !== None) {
    item.x = x2 = 0;
    item.y = y2 = 0;
  }
  item.width = w2;
  item.height = h2;
  boundStroke(bounds2.set(x2, y2, x2 + w2, y2 + h2), item);
  item.mark.bounds.clear().union(bounds2);
  return item;
}
function legendBounds(item, b2) {
  item.items.forEach((_) => b2.union(_.bounds));
  b2.x1 = item.padding;
  b2.y1 = item.padding;
  return b2;
}
function legendGroupLayout(view, item, entry2) {
  var pad2 = item.padding, ex = pad2 - entry2.x, ey = pad2 - entry2.y;
  if (!item.datum.title) {
    if (ex || ey) translate$1(view, entry2, ex, ey);
  } else {
    var title2 = item.items[1].items[0], anchor = title2.anchor, tpad = item.titlePadding || 0, tx2 = pad2 - title2.x, ty = pad2 - title2.y;
    switch (title2.orient) {
      case Left$1:
        ex += Math.ceil(title2.bounds.width()) + tpad;
        break;
      case Right$1:
      case Bottom$1:
        break;
      default:
        ey += title2.bounds.height() + tpad;
    }
    if (ex || ey) translate$1(view, entry2, ex, ey);
    switch (title2.orient) {
      case Left$1:
        ty += legendTitleOffset(item, entry2, title2, anchor, 1, 1);
        break;
      case Right$1:
        tx2 += legendTitleOffset(item, entry2, title2, End$1, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry2, title2, anchor, 1, 1);
        break;
      case Bottom$1:
        tx2 += legendTitleOffset(item, entry2, title2, anchor, 0, 0);
        ty += legendTitleOffset(item, entry2, title2, End$1, -1, 0, 1) + tpad;
        break;
      default:
        tx2 += legendTitleOffset(item, entry2, title2, anchor, 0, 0);
    }
    if (tx2 || ty) translate$1(view, title2, tx2, ty);
    if ((tx2 = Math.round(title2.bounds.x1 - pad2)) < 0) {
      translate$1(view, entry2, -tx2, 0);
      translate$1(view, title2, -tx2, 0);
    }
  }
}
function legendTitleOffset(item, entry2, title2, anchor, y2, lr, noBar) {
  const grad = item.datum.type !== "symbol", vgrad = title2.datum.vgrad, e3 = grad && (lr || !vgrad) && !noBar ? entry2.items[0] : entry2, s = e3.bounds[y2 ? "y2" : "x2"] - item.padding, u2 = vgrad && lr ? s : 0, v = vgrad && lr ? 0 : s, o = y2 <= 0 ? 0 : multiLineOffset(title2);
  return Math.round(anchor === Start$1 ? u2 : anchor === End$1 ? v - o : 0.5 * (s - o));
}
function translate$1(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}
function legendEntryLayout(entries2) {
  const widths = entries2.reduce((w2, g) => {
    w2[g.column] = Math.max(g.bounds.x2 - g.x, w2[g.column] || 0);
    return w2;
  }, {});
  entries2.forEach((g) => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}
function titleLayout(view, mark2, width2, height2, viewBounds2) {
  var group2 = mark2.items[0], frame2 = group2.frame, orient2 = group2.orient, anchor = group2.anchor, offset2 = group2.offset, padding2 = group2.padding, title2 = group2.items[0].items[0], subtitle = group2.items[1] && group2.items[1].items[0], end = orient2 === Left$1 || orient2 === Right$1 ? height2 : width2, start = 0, x2 = 0, y2 = 0, sx = 0, sy = 0, pos;
  if (frame2 !== Group) {
    orient2 === Left$1 ? (start = viewBounds2.y2, end = viewBounds2.y1) : orient2 === Right$1 ? (start = viewBounds2.y1, end = viewBounds2.y2) : (start = viewBounds2.x1, end = viewBounds2.x2);
  } else if (orient2 === Left$1) {
    start = height2, end = 0;
  }
  pos = anchor === Start$1 ? start : anchor === End$1 ? end : (start + end) / 2;
  if (subtitle && subtitle.text) {
    switch (orient2) {
      case Top$1:
      case Bottom$1:
        sy = title2.bounds.height() + padding2;
        break;
      case Left$1:
        sx = title2.bounds.width() + padding2;
        break;
      case Right$1:
        sx = -title2.bounds.width() - padding2;
        break;
    }
    tempBounds.clear().union(subtitle.bounds);
    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));
    if (set$4(subtitle, "x", sx) | set$4(subtitle, "y", sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds);
      subtitle.mark.bounds.clear().union(tempBounds);
      view.dirty(subtitle);
    }
    tempBounds.clear().union(subtitle.bounds);
  } else {
    tempBounds.clear();
  }
  tempBounds.union(title2.bounds);
  switch (orient2) {
    case Top$1:
      x2 = pos;
      y2 = viewBounds2.y1 - tempBounds.height() - offset2;
      break;
    case Left$1:
      x2 = viewBounds2.x1 - tempBounds.width() - offset2;
      y2 = pos;
      break;
    case Right$1:
      x2 = viewBounds2.x2 + tempBounds.width() + offset2;
      y2 = pos;
      break;
    case Bottom$1:
      x2 = pos;
      y2 = viewBounds2.y2 + offset2;
      break;
    default:
      x2 = group2.x;
      y2 = group2.y;
  }
  if (set$4(group2, "x", x2) | set$4(group2, "y", y2)) {
    tempBounds.translate(x2, y2);
    view.dirty(group2);
    group2.bounds.clear().union(tempBounds);
    mark2.bounds.clear().union(tempBounds);
    view.dirty(group2);
  }
  return group2.bounds;
}
function ViewLayout$1(params2) {
  Transform.call(this, null, params2);
}
inherits(ViewLayout$1, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    _.mark.items.forEach((group2) => {
      if (_.layout) trellisLayout(view, group2, _.layout);
      layoutGroup(view, group2, _);
    });
    return shouldReflow(_.mark.group) ? pulse2.reflow() : pulse2;
  }
});
function shouldReflow(group2) {
  return group2 && group2.mark.role !== "legend-entry";
}
function layoutGroup(view, group2, _) {
  var items = group2.items, width2 = Math.max(0, group2.width || 0), height2 = Math.max(0, group2.height || 0), viewBounds2 = new Bounds().set(0, 0, width2, height2), xBounds = viewBounds2.clone(), yBounds = viewBounds2.clone(), legends = [], title2, mark2, orient2, b2, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    mark2 = items[i];
    switch (mark2.role) {
      case AxisRole$1:
        b2 = isYAxis(mark2) ? xBounds : yBounds;
        b2.union(axisLayout(view, mark2, width2, height2));
        break;
      case TitleRole$1:
        title2 = mark2;
        break;
      case LegendRole$1:
        legends.push(legendLayout(view, mark2));
        break;
      case FrameRole$1:
      case ScopeRole$1:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark2.bounds);
        yBounds.union(mark2.bounds);
        break;
      default:
        viewBounds2.union(mark2.bounds);
    }
  }
  if (legends.length) {
    const l = {};
    legends.forEach((item) => {
      orient2 = item.orient || Right$1;
      if (orient2 !== None) (l[orient2] || (l[orient2] = [])).push(item);
    });
    for (const orient3 in l) {
      const g = l[orient3];
      gridLayout(view, g, legendParams(g, orient3, _.legends, xBounds, yBounds, width2, height2));
    }
    legends.forEach((item) => {
      const b3 = item.bounds;
      if (!b3.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item);
        item.bounds = b3;
        view.dirty(item);
      }
      if (_.autosize && _.autosize.type === Fit) {
        switch (item.orient) {
          case Left$1:
          case Right$1:
            viewBounds2.add(b3.x1, 0).add(b3.x2, 0);
            break;
          case Top$1:
          case Bottom$1:
            viewBounds2.add(0, b3.y1).add(0, b3.y2);
        }
      } else {
        viewBounds2.union(b3);
      }
    });
  }
  viewBounds2.union(xBounds).union(yBounds);
  if (title2) {
    viewBounds2.union(titleLayout(view, title2, width2, height2, viewBounds2));
  }
  if (group2.clip) {
    viewBounds2.set(0, 0, group2.width || 0, group2.height || 0);
  }
  viewSizeLayout(view, group2, viewBounds2, _);
}
function viewSizeLayout(view, group2, viewBounds2, _) {
  const auto = _.autosize || {}, type2 = auto.type;
  if (view._autosize < 1 || !type2) return;
  let viewWidth2 = view._width, viewHeight2 = view._height, width2 = Math.max(0, group2.width || 0), left = Math.max(0, Math.ceil(-viewBounds2.x1)), height2 = Math.max(0, group2.height || 0), top = Math.max(0, Math.ceil(-viewBounds2.y1));
  const right = Math.max(0, Math.ceil(viewBounds2.x2 - width2)), bottom = Math.max(0, Math.ceil(viewBounds2.y2 - height2));
  if (auto.contains === Padding$1) {
    const padding2 = view.padding();
    viewWidth2 -= padding2.left + padding2.right;
    viewHeight2 -= padding2.top + padding2.bottom;
  }
  if (type2 === None) {
    left = 0;
    top = 0;
    width2 = viewWidth2;
    height2 = viewHeight2;
  } else if (type2 === Fit) {
    width2 = Math.max(0, viewWidth2 - left - right);
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type2 === FitX) {
    width2 = Math.max(0, viewWidth2 - left - right);
    viewHeight2 = height2 + top + bottom;
  } else if (type2 === FitY) {
    viewWidth2 = width2 + left + right;
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type2 === Pad) {
    viewWidth2 = width2 + left + right;
    viewHeight2 = height2 + top + bottom;
  }
  view._resizeView(viewWidth2, viewHeight2, width2, height2, [left, top], auto.resize);
}
const vtx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bound: Bound$1,
  identifier: Identifier$1,
  mark: Mark$2,
  overlap: Overlap$1,
  render: Render$1,
  viewlayout: ViewLayout$1
}, Symbol.toStringTag, { value: "Module" }));
function AxisTicks$1(params2) {
  Transform.call(this, null, params2);
}
inherits(AxisTicks$1, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale2 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), ticks2 = this.value, scale2 = _.scale, tally = _.count == null ? _.values ? _.values.length : 10 : _.count, count2 = tickCount(scale2, tally, _.minstep), format2 = _.format || tickFormat(locale2, scale2, count2, _.formatSpecifier, _.formatType, !!_.values), values2 = _.values ? validTicks(scale2, _.values, count2) : tickValues(scale2, count2);
    if (ticks2) out.rem = ticks2;
    ticks2 = values2.map((value2, i) => ingest$1({
      index: i / (values2.length - 1 || 1),
      value: value2,
      label: format2(value2)
    }));
    if (_.extra && ticks2.length) {
      ticks2.push(ingest$1({
        index: -1,
        extra: {
          value: ticks2[0].value
        },
        label: ""
      }));
    }
    out.source = ticks2;
    out.add = ticks2;
    this.value = ticks2;
    return out;
  }
});
function DataJoin$1(params2) {
  Transform.call(this, null, params2);
}
function defaultItemCreate() {
  return ingest$1({});
}
function newMap(key2) {
  const map2 = fastmap().test((t4) => t4.exit);
  map2.lookup = (t4) => map2.get(key2(t4));
  return map2;
}
inherits(DataJoin$1, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), item = _.item || defaultItemCreate, key2 = _.key || tupleid, map2 = this.value;
    if (isArray$1(out.encode)) {
      out.encode = null;
    }
    if (map2 && (_.modified("key") || pulse2.modified(key2))) {
      error("DataJoin does not support modified key function or fields.");
    }
    if (!map2) {
      pulse2 = pulse2.addAll();
      this.value = map2 = newMap(key2);
    }
    pulse2.visit(pulse2.ADD, (t4) => {
      const k = key2(t4);
      let x2 = map2.get(k);
      if (x2) {
        if (x2.exit) {
          map2.empty--;
          out.add.push(x2);
        } else {
          out.mod.push(x2);
        }
      } else {
        x2 = item(t4);
        map2.set(k, x2);
        out.add.push(x2);
      }
      x2.datum = t4;
      x2.exit = false;
    });
    pulse2.visit(pulse2.MOD, (t4) => {
      const k = key2(t4), x2 = map2.get(k);
      if (x2) {
        x2.datum = t4;
        out.mod.push(x2);
      }
    });
    pulse2.visit(pulse2.REM, (t4) => {
      const k = key2(t4), x2 = map2.get(k);
      if (t4 === x2.datum && !x2.exit) {
        out.rem.push(x2);
        x2.exit = true;
        ++map2.empty;
      }
    });
    if (pulse2.changed(pulse2.ADD_MOD)) out.modifies("datum");
    if (pulse2.clean() || _.clean && map2.empty > df.cleanThreshold) {
      df.runAfter(map2.clean);
    }
    return out;
  }
});
function Encode$1(params2) {
  Transform.call(this, null, params2);
}
inherits(Encode$1, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ADD_REM), fmod = _.mod || false, encoders = _.encoders, encode2 = pulse2.encode;
    if (isArray$1(encode2)) {
      if (out.changed() || encode2.every((e3) => encoders[e3])) {
        encode2 = encode2[0];
        out.encode = null;
      } else {
        return pulse2.StopPropagation;
      }
    }
    var reenter = encode2 === "enter", update2 = encoders.update || falsy, enter = encoders.enter || falsy, exit = encoders.exit || falsy, set2 = (encode2 && !reenter ? encoders[encode2] : update2) || falsy;
    if (pulse2.changed(pulse2.ADD)) {
      pulse2.visit(pulse2.ADD, (t4) => {
        enter(t4, _);
        update2(t4, _);
      });
      out.modifies(enter.output);
      out.modifies(update2.output);
      if (set2 !== falsy && set2 !== update2) {
        pulse2.visit(pulse2.ADD, (t4) => {
          set2(t4, _);
        });
        out.modifies(set2.output);
      }
    }
    if (pulse2.changed(pulse2.REM) && exit !== falsy) {
      pulse2.visit(pulse2.REM, (t4) => {
        exit(t4, _);
      });
      out.modifies(exit.output);
    }
    if (reenter || set2 !== falsy) {
      const flag2 = pulse2.MOD | (_.modified() ? pulse2.REFLOW : 0);
      if (reenter) {
        pulse2.visit(flag2, (t4) => {
          const mod = enter(t4, _) || fmod;
          if (set2(t4, _) || mod) out.mod.push(t4);
        });
        if (out.mod.length) out.modifies(enter.output);
      } else {
        pulse2.visit(flag2, (t4) => {
          if (set2(t4, _) || fmod) out.mod.push(t4);
        });
      }
      if (out.mod.length) out.modifies(set2.output);
    }
    return out.changed() ? out : pulse2.StopPropagation;
  }
});
function LegendEntries$1(params2) {
  Transform.call(this, [], params2);
}
inherits(LegendEntries$1, Transform, {
  transform(_, pulse2) {
    if (this.value != null && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale2 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), items = this.value, type2 = _.type || SymbolLegend, scale2 = _.scale, limit = +_.limit, count2 = tickCount(scale2, _.count == null ? 5 : _.count, _.minstep), lskip = !!_.values || type2 === SymbolLegend, format2 = _.format || labelFormat(locale2, scale2, count2, type2, _.formatSpecifier, _.formatType, lskip), values2 = _.values || labelValues(scale2, count2), domain2, fraction, size, offset2, ellipsis;
    if (items) out.rem = items;
    if (type2 === SymbolLegend) {
      if (limit && values2.length > limit) {
        pulse2.dataflow.warn("Symbol legend count exceeds limit, filtering items.");
        items = values2.slice(0, limit - 1);
        ellipsis = true;
      } else {
        items = values2;
      }
      if (isFunction$3(size = _.size)) {
        if (!_.values && scale2(items[0]) === 0) {
          items = items.slice(1);
        }
        offset2 = items.reduce((max2, value2) => Math.max(max2, size(value2, _)), 0);
      } else {
        size = constant$5(offset2 = size || 8);
      }
      items = items.map((value2, index2) => ingest$1({
        index: index2,
        label: format2(value2, index2, items),
        value: value2,
        offset: offset2,
        size: size(value2, _)
      }));
      if (ellipsis) {
        ellipsis = values2[items.length];
        items.push(ingest$1({
          index: items.length,
          label: "…".concat(values2.length - items.length, " entries"),
          value: ellipsis,
          offset: offset2,
          size: size(ellipsis, _)
        }));
      }
    } else if (type2 === GradientLegend) {
      domain2 = scale2.domain(), fraction = scaleFraction(scale2, domain2[0], peek$2(domain2));
      if (values2.length < 3 && !_.values && domain2[0] !== peek$2(domain2)) {
        values2 = [domain2[0], peek$2(domain2)];
      }
      items = values2.map((value2, index2) => ingest$1({
        index: index2,
        label: format2(value2, index2, values2),
        value: value2,
        perc: fraction(value2)
      }));
    } else {
      size = values2.length - 1;
      fraction = labelFraction(scale2);
      items = values2.map((value2, index2) => ingest$1({
        index: index2,
        label: format2(value2, index2, values2),
        value: value2,
        perc: index2 ? fraction(value2) : 0,
        perc2: index2 === size ? 1 : fraction(values2[index2 + 1])
      }));
    }
    out.source = items;
    out.add = items;
    this.value = items;
    return out;
  }
});
const sourceX = (t4) => t4.source.x;
const sourceY = (t4) => t4.source.y;
const targetX = (t4) => t4.target.x;
const targetY = (t4) => t4.target.y;
function LinkPath(params2) {
  Transform.call(this, {}, params2);
}
LinkPath.Definition = {
  "type": "LinkPath",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "sourceX",
    "type": "field",
    "default": "source.x"
  }, {
    "name": "sourceY",
    "type": "field",
    "default": "source.y"
  }, {
    "name": "targetX",
    "type": "field",
    "default": "target.x"
  }, {
    "name": "targetY",
    "type": "field",
    "default": "target.y"
  }, {
    "name": "orient",
    "type": "enum",
    "default": "vertical",
    "values": ["horizontal", "vertical", "radial"]
  }, {
    "name": "shape",
    "type": "enum",
    "default": "line",
    "values": ["line", "arc", "curve", "diagonal", "orthogonal"]
  }, {
    "name": "require",
    "type": "signal"
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
inherits(LinkPath, Transform, {
  transform(_, pulse2) {
    var sx = _.sourceX || sourceX, sy = _.sourceY || sourceY, tx2 = _.targetX || targetX, ty = _.targetY || targetY, as = _.as || "path", orient2 = _.orient || "vertical", shape2 = _.shape || "line", path2 = Paths.get(shape2 + "-" + orient2) || Paths.get(shape2);
    if (!path2) {
      error("LinkPath unsupported type: " + _.shape + (_.orient ? "-" + _.orient : ""));
    }
    pulse2.visit(pulse2.SOURCE, (t4) => {
      t4[as] = path2(sx(t4), sy(t4), tx2(t4), ty(t4));
    });
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
const line$2 = (sx, sy, tx2, ty) => "M" + sx + "," + sy + "L" + tx2 + "," + ty;
const lineR = (sa2, sr, ta, tr2) => line$2(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
const arc$1 = (sx, sy, tx2, ty) => {
  var dx = tx2 - sx, dy = ty - sy, rr = Math.sqrt(dx * dx + dy * dy) / 2, ra = 180 * Math.atan2(dy, dx) / Math.PI;
  return "M" + sx + "," + sy + "A" + rr + "," + rr + " " + ra + " 0 1 " + tx2 + "," + ty;
};
const arcR = (sa2, sr, ta, tr2) => arc$1(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
const curve = (sx, sy, tx2, ty) => {
  const dx = tx2 - sx, dy = ty - sy, ix = 0.2 * (dx + dy), iy = 0.2 * (dy - dx);
  return "M" + sx + "," + sy + "C" + (sx + ix) + "," + (sy + iy) + " " + (tx2 + iy) + "," + (ty - ix) + " " + tx2 + "," + ty;
};
const curveR = (sa2, sr, ta, tr2) => curve(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
const orthoX = (sx, sy, tx2, ty) => "M" + sx + "," + sy + "V" + ty + "H" + tx2;
const orthoY = (sx, sy, tx2, ty) => "M" + sx + "," + sy + "H" + tx2 + "V" + ty;
const orthoR = (sa2, sr, ta, tr2) => {
  const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), sf = Math.abs(ta - sa2) > Math.PI ? ta <= sa2 : ta > sa2;
  return "M" + sr * sc + "," + sr * ss + "A" + sr + "," + sr + " 0 0," + (sf ? 1 : 0) + " " + sr * tc + "," + sr * ts2 + "L" + tr2 * tc + "," + tr2 * ts2;
};
const diagonalX = (sx, sy, tx2, ty) => {
  const m2 = (sx + tx2) / 2;
  return "M" + sx + "," + sy + "C" + m2 + "," + sy + " " + m2 + "," + ty + " " + tx2 + "," + ty;
};
const diagonalY = (sx, sy, tx2, ty) => {
  const m2 = (sy + ty) / 2;
  return "M" + sx + "," + sy + "C" + sx + "," + m2 + " " + tx2 + "," + m2 + " " + tx2 + "," + ty;
};
const diagonalR = (sa2, sr, ta, tr2) => {
  const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), mr = (sr + tr2) / 2;
  return "M" + sr * sc + "," + sr * ss + "C" + mr * sc + "," + mr * ss + " " + mr * tc + "," + mr * ts2 + " " + tr2 * tc + "," + tr2 * ts2;
};
const Paths = fastmap({
  "line": line$2,
  "line-radial": lineR,
  "arc": arc$1,
  "arc-radial": arcR,
  "curve": curve,
  "curve-radial": curveR,
  "orthogonal-horizontal": orthoX,
  "orthogonal-vertical": orthoY,
  "orthogonal-radial": orthoR,
  "diagonal-horizontal": diagonalX,
  "diagonal-vertical": diagonalY,
  "diagonal-radial": diagonalR
});
function Pie(params2) {
  Transform.call(this, null, params2);
}
Pie.Definition = {
  "type": "Pie",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "startAngle",
    "type": "number",
    "default": 0
  }, {
    "name": "endAngle",
    "type": "number",
    "default": 6.283185307179586
  }, {
    "name": "sort",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["startAngle", "endAngle"]
  }]
};
inherits(Pie, Transform, {
  transform(_, pulse2) {
    var as = _.as || ["startAngle", "endAngle"], startAngle = as[0], endAngle = as[1], field2 = _.field || one$3, start = _.startAngle || 0, stop3 = _.endAngle != null ? _.endAngle : 2 * Math.PI, data2 = pulse2.source, values2 = data2.map(field2), n = values2.length, a2 = start, k = (stop3 - start) / sum$1(values2), index2 = range$6(n), i, t4, v;
    if (_.sort) {
      index2.sort((a3, b2) => values2[a3] - values2[b2]);
    }
    for (i = 0; i < n; ++i) {
      v = values2[index2[i]];
      t4 = data2[index2[i]];
      t4[startAngle] = a2;
      t4[endAngle] = a2 += v * k;
    }
    this.value = values2;
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
const DEFAULT_COUNT = 5;
function includeZero(scale2) {
  const type2 = scale2.type;
  return !scale2.bins && (type2 === Linear || type2 === Pow || type2 === Sqrt);
}
function includePad(type2) {
  return isContinuous$1(type2) && type2 !== Sequential;
}
const SKIP$1 = toSet(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
function Scale$1(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Scale$1, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, scale$12 = this.value, key2 = scaleKey(_);
    if (!scale$12 || key2 !== scale$12.type) {
      this.value = scale$12 = scale$4(key2)();
    }
    for (key2 in _) if (!SKIP$1[key2]) {
      if (key2 === "padding" && includePad(scale$12.type)) continue;
      isFunction$3(scale$12[key2]) ? scale$12[key2](_[key2]) : df.warn("Unsupported scale property: " + key2);
    }
    configureRange(scale$12, _, configureBins(scale$12, _, configureDomain(scale$12, _, df)));
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function scaleKey(_) {
  var t4 = _.type, d = "", n;
  if (t4 === Sequential) return Sequential + "-" + Linear;
  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? Sequential + "-" : n === 3 ? Diverging + "-" : "";
  }
  return (d + t4 || Linear).toLowerCase();
}
function isContinuousColor(_) {
  const t4 = _.type;
  return isContinuous$1(t4) && t4 !== Time && t4 !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));
}
function configureDomain(scale2, _, df) {
  const raw = rawDomain(scale2, _.domainRaw, df);
  if (raw > -1) return raw;
  var domain2 = _.domain, type2 = scale2.type, zero2 = _.zero || _.zero === void 0 && includeZero(scale2), n, mid;
  if (!domain2) return 0;
  if (includePad(type2) && _.padding && domain2[0] !== peek$2(domain2)) {
    domain2 = padDomain(type2, domain2, _.range, _.padding, _.exponent, _.constant);
  }
  if (zero2 || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain2 = domain2.slice()).length - 1 || 1;
    if (zero2) {
      if (domain2[0] > 0) domain2[0] = 0;
      if (domain2[n] < 0) domain2[n] = 0;
    }
    if (_.domainMin != null) domain2[0] = _.domainMin;
    if (_.domainMax != null) domain2[n] = _.domainMax;
    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain2[n] ? n + 1 : mid < domain2[0] ? 0 : n;
      if (i !== n) df.warn("Scale domainMid exceeds domain min or max.", mid);
      domain2.splice(i, 0, mid);
    }
  }
  scale2.domain(domainCheck(type2, domain2, df));
  if (type2 === Ordinal) {
    scale2.unknown(_.domainImplicit ? implicit : void 0);
  }
  if (_.nice && scale2.nice) {
    scale2.nice(_.nice !== true && tickCount(scale2, _.nice) || null);
  }
  return domain2.length;
}
function rawDomain(scale2, raw, df) {
  if (raw) {
    scale2.domain(domainCheck(scale2.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}
function padDomain(type2, domain2, range2, pad2, exponent2, constant2) {
  var span2 = Math.abs(peek$2(range2) - range2[0]), frac = span2 / (span2 - 2 * pad2), d = type2 === Log ? zoomLog(domain2, null, frac) : type2 === Sqrt ? zoomPow(domain2, null, frac, 0.5) : type2 === Pow ? zoomPow(domain2, null, frac, exponent2 || 1) : type2 === Symlog ? zoomSymlog(domain2, null, frac, constant2 || 1) : zoomLinear(domain2, null, frac);
  domain2 = domain2.slice();
  domain2[0] = d[0];
  domain2[domain2.length - 1] = d[1];
  return domain2;
}
function domainCheck(type2, domain2, df) {
  if (isLogarithmic(type2)) {
    var s = Math.abs(domain2.reduce((s2, v) => s2 + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));
    if (s !== domain2.length) {
      df.warn("Log scale domain includes zero: " + $(domain2));
    }
  }
  return domain2;
}
function configureBins(scale2, _, count2) {
  let bins2 = _.bins;
  if (bins2 && !isArray$1(bins2)) {
    const domain2 = scale2.domain(), lo = domain2[0], hi = peek$2(domain2), step = bins2.step;
    let start = bins2.start == null ? lo : bins2.start, stop3 = bins2.stop == null ? hi : bins2.stop;
    if (!step) error("Scale bins parameter missing step property.");
    if (start < lo) start = step * Math.ceil(lo / step);
    if (stop3 > hi) stop3 = step * Math.floor(hi / step);
    bins2 = range$6(start, stop3 + step / 2, step);
  }
  if (bins2) {
    scale2.bins = bins2;
  } else if (scale2.bins) {
    delete scale2.bins;
  }
  if (scale2.type === BinOrdinal) {
    if (!bins2) {
      scale2.bins = scale2.domain();
    } else if (!_.domain && !_.domainRaw) {
      scale2.domain(bins2);
      count2 = bins2.length;
    }
  }
  return count2;
}
function configureRange(scale2, _, count2) {
  var type2 = scale2.type, round2 = _.round || false, range2 = _.range;
  if (_.rangeStep != null) {
    range2 = configureRangeStep(type2, _, count2);
  } else if (_.scheme) {
    range2 = configureScheme(type2, _, count2);
    if (isFunction$3(range2)) {
      if (scale2.interpolator) {
        return scale2.interpolator(range2);
      } else {
        error("Scale type ".concat(type2, " does not support interpolating color schemes."));
      }
    }
  }
  if (range2 && isInterpolating(type2)) {
    return scale2.interpolator(interpolateColors(flip$1(range2, _.reverse), _.interpolate, _.interpolateGamma));
  }
  if (range2 && _.interpolate && scale2.interpolate) {
    scale2.interpolate(interpolate$2(_.interpolate, _.interpolateGamma));
  } else if (isFunction$3(scale2.round)) {
    scale2.round(round2);
  } else if (isFunction$3(scale2.rangeRound)) {
    scale2.interpolate(round2 ? interpolateRound : interpolate$1$1);
  }
  if (range2) scale2.range(flip$1(range2, _.reverse));
}
function configureRangeStep(type2, _, count2) {
  if (type2 !== Band && type2 !== Point) {
    error("Only band and point scales support rangeStep.");
  }
  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0, inner2 = type2 === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * bandSpace(count2, inner2, outer)];
}
function configureScheme(type2, _, count2) {
  var extent2 = _.schemeExtent, name, scheme$1$1;
  if (isArray$1(_.scheme)) {
    scheme$1$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name = _.scheme.toLowerCase();
    scheme$1$1 = scheme$1(name);
    if (!scheme$1$1) error("Unrecognized scheme name: ".concat(_.scheme));
  }
  count2 = type2 === Threshold ? count2 + 1 : type2 === BinOrdinal ? count2 - 1 : type2 === Quantile || type2 === Quantize ? +_.schemeCount || DEFAULT_COUNT : count2;
  return isInterpolating(type2) ? adjustScheme(scheme$1$1, extent2, _.reverse) : isFunction$3(scheme$1$1) ? quantizeInterpolator(adjustScheme(scheme$1$1, extent2), count2) : type2 === Ordinal ? scheme$1$1 : scheme$1$1.slice(0, count2);
}
function adjustScheme(scheme2, extent2, reverse2) {
  return isFunction$3(scheme2) && (extent2 || reverse2) ? interpolateRange$1(scheme2, flip$1(extent2 || [0, 1], reverse2)) : scheme2;
}
function flip$1(array2, reverse2) {
  return reverse2 ? array2.slice().reverse() : array2;
}
function SortItems$1(params2) {
  Transform.call(this, null, params2);
}
inherits(SortItems$1, Transform, {
  transform(_, pulse2) {
    const mod = _.modified("sort") || pulse2.changed(pulse2.ADD) || pulse2.modified(_.sort.fields) || pulse2.modified("datum");
    if (mod) pulse2.source.sort(stableCompare(_.sort));
    this.modified(mod);
    return pulse2;
  }
});
const Zero = "zero", Center$1 = "center", Normalize = "normalize", DefOutput = ["y0", "y1"];
function Stack$1(params2) {
  Transform.call(this, null, params2);
}
Stack$1.Definition = {
  "type": "Stack",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "offset",
    "type": "enum",
    "default": Zero,
    "values": [Zero, Center$1, Normalize]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": DefOutput
  }]
};
inherits(Stack$1, Transform, {
  transform(_, pulse2) {
    var as = _.as || DefOutput, y02 = as[0], y12 = as[1], sort2 = stableCompare(_.sort), field2 = _.field || one$3, stack2 = _.offset === Center$1 ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero, groups, i, n, max2;
    groups = partition$3(pulse2.source, _.groupby, sort2, field2);
    for (i = 0, n = groups.length, max2 = groups.max; i < n; ++i) {
      stack2(groups[i], max2, field2, y02, y12);
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function stackCenter(group2, max2, field2, y02, y12) {
  var last = (max2 - group2.sum) / 2, m2 = group2.length, j = 0, t4;
  for (; j < m2; ++j) {
    t4 = group2[j];
    t4[y02] = last;
    t4[y12] = last += Math.abs(field2(t4));
  }
}
function stackNormalize(group2, max2, field2, y02, y12) {
  var scale2 = 1 / group2.sum, last = 0, m2 = group2.length, j = 0, v = 0, t4;
  for (; j < m2; ++j) {
    t4 = group2[j];
    t4[y02] = last;
    t4[y12] = last = scale2 * (v += Math.abs(field2(t4)));
  }
}
function stackZero(group2, max2, field2, y02, y12) {
  var lastPos = 0, lastNeg = 0, m2 = group2.length, j = 0, v, t4;
  for (; j < m2; ++j) {
    t4 = group2[j];
    v = +field2(t4);
    if (v < 0) {
      t4[y02] = lastNeg;
      t4[y12] = lastNeg += v;
    } else {
      t4[y02] = lastPos;
      t4[y12] = lastPos += v;
    }
  }
}
function partition$3(data2, groupby, sort2, field2) {
  var groups = [], get2 = (f) => f(t4), map2, i, n, m2, t4, k, g, s, max2;
  if (groupby == null) {
    groups.push(data2.slice());
  } else {
    for (map2 = {}, i = 0, n = data2.length; i < n; ++i) {
      t4 = data2[i];
      k = groupby.map(get2);
      g = map2[k];
      if (!g) {
        map2[k] = g = [];
        groups.push(g);
      }
      g.push(t4);
    }
  }
  for (k = 0, max2 = 0, m2 = groups.length; k < m2; ++k) {
    g = groups[k];
    for (i = 0, s = 0, n = g.length; i < n; ++i) {
      s += Math.abs(field2(g[i]));
    }
    g.sum = s;
    if (s > max2) max2 = s;
    if (sort2) g.sort(sort2);
  }
  groups.max = max2;
  return groups;
}
const encode$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  axisticks: AxisTicks$1,
  datajoin: DataJoin$1,
  encode: Encode$1,
  legendentries: LegendEntries$1,
  linkpath: LinkPath,
  pie: Pie,
  scale: Scale$1,
  sortitems: SortItems$1,
  stack: Stack$1
}, Symbol.toStringTag, { value: "Module" }));
var epsilon$3 = 1e-6;
var epsilon2 = 1e-12;
var pi$1 = Math.PI;
var halfPi$1 = pi$1 / 2;
var quarterPi = pi$1 / 4;
var tau$1 = pi$1 * 2;
var degrees = 180 / pi$1;
var radians = pi$1 / 180;
var abs$2 = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos$1 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var hypot = Math.hypot;
var log$2 = Math.log;
var pow$1 = Math.pow;
var sin$1 = Math.sin;
var sign = Math.sign || function(x2) {
  return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
};
var sqrt$1 = Math.sqrt;
var tan = Math.tan;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi$1 : Math.acos(x2);
}
function asin$1(x2) {
  return x2 > 1 ? halfPi$1 : x2 < -1 ? -halfPi$1 : Math.asin(x2);
}
function noop$2() {
}
function streamGeometry(geometry, stream2) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream2);
  }
}
var streamObjectType = {
  Feature: function(object2, stream2) {
    streamGeometry(object2.geometry, stream2);
  },
  FeatureCollection: function(object2, stream2) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream2);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream2) {
    stream2.sphere();
  },
  Point: function(object2, stream2) {
    object2 = object2.coordinates;
    stream2.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object2 = coordinates[i], stream2.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream2) {
    streamLine(object2.coordinates, stream2, 0);
  },
  MultiLineString: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream2, 0);
  },
  Polygon: function(object2, stream2) {
    streamPolygon(object2.coordinates, stream2);
  },
  MultiPolygon: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream2);
  },
  GeometryCollection: function(object2, stream2) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream2);
  }
};
function streamLine(coordinates, stream2, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream2.lineStart();
  while (++i < n) coordinate = coordinates[i], stream2.point(coordinate[0], coordinate[1], coordinate[2]);
  stream2.lineEnd();
}
function streamPolygon(coordinates, stream2) {
  var i = -1, n = coordinates.length;
  stream2.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream2, 1);
  stream2.polygonEnd();
}
function geoStream(object2, stream2) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream2);
  } else {
    streamGeometry(object2, stream2);
  }
}
var areaRingSum$1 = new Adder();
var areaSum$1 = new Adder(), lambda00$2, phi00$2, lambda0$1, cosPhi0, sinPhi0;
var areaStream$1 = {
  point: noop$2,
  lineStart: noop$2,
  lineEnd: noop$2,
  polygonStart: function() {
    areaRingSum$1 = new Adder();
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum$1;
    areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop$2;
  },
  sphere: function() {
    areaSum$1.add(tau$1);
  }
};
function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}
function areaRingEnd$1() {
  areaPoint$1(lambda00$2, phi00$2);
}
function areaPointFirst$1(lambda, phi2) {
  areaStream$1.point = areaPoint$1;
  lambda00$2 = lambda, phi00$2 = phi2;
  lambda *= radians, phi2 *= radians;
  lambda0$1 = lambda, cosPhi0 = cos$1(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin$1(phi2);
}
function areaPoint$1(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  phi2 = phi2 / 2 + quarterPi;
  var dLambda = lambda - lambda0$1, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos$1(phi2), sinPhi = sin$1(phi2), k = sinPhi0 * sinPhi, u2 = cosPhi0 * cosPhi + k * cos$1(adLambda), v = k * sdLambda * sin$1(adLambda);
  areaRingSum$1.add(atan2(v, u2));
  lambda0$1 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}
function geoArea$1(object2) {
  areaSum$1 = new Adder();
  geoStream(object2, areaStream$1);
  return areaSum$1 * 2;
}
function spherical(cartesian2) {
  return [atan2(cartesian2[1], cartesian2[0]), asin$1(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos$1(phi2);
  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi2)];
}
function cartesianDot(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
}
function cartesianCross(a2, b2) {
  return [a2[1] * b2[2] - a2[2] * b2[1], a2[2] * b2[0] - a2[0] * b2[2], a2[0] * b2[1] - a2[1] * b2[0]];
}
function cartesianAddInPlace(a2, b2) {
  a2[0] += b2[0], a2[1] += b2[1], a2[2] += b2[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt$1(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}
var lambda0, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum, ranges, range$5;
var boundsStream$1 = {
  point: boundsPoint$1,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream$1.point = boundsRingPoint;
    boundsStream$1.lineStart = boundsRingStart;
    boundsStream$1.lineEnd = boundsRingEnd;
    deltaSum = new Adder();
    areaStream$1.polygonStart();
  },
  polygonEnd: function() {
    areaStream$1.polygonEnd();
    boundsStream$1.point = boundsPoint$1;
    boundsStream$1.lineStart = boundsLineStart;
    boundsStream$1.lineEnd = boundsLineEnd;
    if (areaRingSum$1 < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon$3) phi1 = 90;
    else if (deltaSum < -1e-6) phi0 = -90;
    range$5[0] = lambda0, range$5[1] = lambda1;
  },
  sphere: function() {
    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};
function boundsPoint$1(lambda, phi2) {
  ranges.push(range$5 = [lambda0 = lambda, lambda1 = lambda]);
  if (phi2 < phi0) phi0 = phi2;
  if (phi2 > phi1) phi1 = phi2;
}
function linePoint(lambda, phi2) {
  var p = cartesian([lambda * radians, phi2 * radians]);
  if (p0) {
    var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs$2(delta) > 180;
    if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
      phii = inflection[1] * degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
      phii = -inflection[1] * degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi2 < phi0) phi0 = phi2;
      if (phi2 > phi1) phi1 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range$5 = [lambda0 = lambda, lambda1 = lambda]);
  }
  if (phi2 < phi0) phi0 = phi2;
  if (phi2 > phi1) phi1 = phi2;
  p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream$1.point = linePoint;
}
function boundsLineEnd() {
  range$5[0] = lambda0, range$5[1] = lambda1;
  boundsStream$1.point = boundsPoint$1;
  p0 = null;
}
function boundsRingPoint(lambda, phi2) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs$2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi2;
  }
  areaStream$1.point(lambda, phi2);
  linePoint(lambda, phi2);
}
function boundsRingStart() {
  areaStream$1.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream$1.lineEnd();
  if (abs$2(deltaSum) > epsilon$3) lambda0 = -(lambda1 = 180);
  range$5[0] = lambda0, range$5[1] = lambda1;
  p0 = null;
}
function angle(lambda02, lambda12) {
  return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
}
function rangeCompare(a2, b2) {
  return a2[0] - b2[0];
}
function rangeContains(range2, x2) {
  return range2[0] <= range2[1] ? range2[0] <= x2 && x2 <= range2[1] : x2 < range2[0] || range2[1] < x2;
}
function geoBounds$1(feature2) {
  var i, n, a2, b2, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  geoStream(feature2, boundsStream$1);
  if (n = ranges.length) {
    ranges.sort(rangeCompare);
    for (i = 1, a2 = ranges[0], merged = [a2]; i < n; ++i) {
      b2 = ranges[i];
      if (rangeContains(a2, b2[0]) || rangeContains(a2, b2[1])) {
        if (angle(a2[0], b2[1]) > angle(a2[0], a2[1])) a2[1] = b2[1];
        if (angle(b2[0], a2[1]) > angle(a2[0], a2[1])) a2[0] = b2[0];
      } else {
        merged.push(a2 = b2);
      }
    }
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a2 = merged[n]; i <= n; a2 = b2, ++i) {
      b2 = merged[i];
      if ((delta = angle(a2[1], b2[0])) > deltaMax) deltaMax = delta, lambda0 = b2[0], lambda1 = a2[1];
    }
  }
  ranges = range$5 = null;
  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];
}
var W0, W1, X0$1, Y0$1, Z0$1, X1$1, Y1$1, Z1$1, X2$2, Y2$2, Z2$1, lambda00, phi00, x0$4, y0$4, z0;
var centroidStream$1 = {
  sphere: noop$2,
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function() {
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  }
};
function centroidPoint$1(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2);
  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi2));
}
function centroidPointCartesian(x2, y2, z2) {
  ++W0;
  X0$1 += (x2 - X0$1) / W0;
  Y0$1 += (y2 - Y0$1) / W0;
  Z0$1 += (z2 - Z0$1) / W0;
}
function centroidLineStart$1() {
  centroidStream$1.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2);
  x0$4 = cosPhi * cos$1(lambda);
  y0$4 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi2);
  centroidStream$1.point = centroidLinePoint;
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2), x2 = cosPhi * cos$1(lambda), y2 = cosPhi * sin$1(lambda), z2 = sin$1(phi2), w2 = atan2(sqrt$1((w2 = y0$4 * z2 - z0 * y2) * w2 + (w2 = z0 * x2 - x0$4 * z2) * w2 + (w2 = x0$4 * y2 - y0$4 * x2) * w2), x0$4 * x2 + y0$4 * y2 + z0 * z2);
  W1 += w2;
  X1$1 += w2 * (x0$4 + (x0$4 = x2));
  Y1$1 += w2 * (y0$4 + (y0$4 = y2));
  Z1$1 += w2 * (z0 + (z0 = z2));
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}
function centroidRingStart$1() {
  centroidStream$1.point = centroidRingPointFirst;
}
function centroidRingEnd$1() {
  centroidRingPoint(lambda00, phi00);
  centroidStream$1.point = centroidPoint$1;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians, phi2 *= radians;
  centroidStream$1.point = centroidRingPoint;
  var cosPhi = cos$1(phi2);
  x0$4 = cosPhi * cos$1(lambda);
  y0$4 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi2);
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2), x2 = cosPhi * cos$1(lambda), y2 = cosPhi * sin$1(lambda), z2 = sin$1(phi2), cx = y0$4 * z2 - z0 * y2, cy = z0 * x2 - x0$4 * z2, cz = x0$4 * y2 - y0$4 * x2, m2 = hypot(cx, cy, cz), w2 = asin$1(m2), v = m2 && -w2 / m2;
  X2$2.add(v * cx);
  Y2$2.add(v * cy);
  Z2$1.add(v * cz);
  W1 += w2;
  X1$1 += w2 * (x0$4 + (x0$4 = x2));
  Y1$1 += w2 * (y0$4 + (y0$4 = y2));
  Z1$1 += w2 * (z0 + (z0 = z2));
  centroidPointCartesian(x0$4, y0$4, z0);
}
function geoCentroid$1(object2) {
  W0 = W1 = X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = 0;
  X2$2 = new Adder();
  Y2$2 = new Adder();
  Z2$1 = new Adder();
  geoStream(object2, centroidStream$1);
  var x2 = +X2$2, y2 = +Y2$2, z2 = +Z2$1, m2 = hypot(x2, y2, z2);
  if (m2 < epsilon2) {
    x2 = X1$1, y2 = Y1$1, z2 = Z1$1;
    if (W1 < epsilon$3) x2 = X0$1, y2 = Y0$1, z2 = Z0$1;
    m2 = hypot(x2, y2, z2);
    if (m2 < epsilon2) return [NaN, NaN];
  }
  return [atan2(y2, x2) * degrees, asin$1(z2 / m2) * degrees];
}
function compose$1(a2, b2) {
  function compose2(x2, y2) {
    return x2 = a2(x2, y2), b2(x2[0], x2[1]);
  }
  if (a2.invert && b2.invert) compose2.invert = function(x2, y2) {
    return x2 = b2.invert(x2, y2), x2 && a2.invert(x2[0], x2[1]);
  };
  return compose2;
}
function rotationIdentity(lambda, phi2) {
  return [abs$2(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau$1) ? deltaPhi || deltaGamma ? compose$1(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation2 = forwardRotationLambda(deltaLambda);
  rotation2.invert = forwardRotationLambda(-deltaLambda);
  return rotation2;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos$1(deltaPhi), sinDeltaPhi = sin$1(deltaPhi), cosDeltaGamma = cos$1(deltaGamma), sinDeltaGamma = sin$1(deltaGamma);
  function rotation2(lambda, phi2) {
    var cosPhi = cos$1(phi2), x2 = cos$1(lambda) * cosPhi, y2 = sin$1(lambda) * cosPhi, z2 = sin$1(phi2), k = z2 * cosDeltaPhi + x2 * sinDeltaPhi;
    return [
      atan2(y2 * cosDeltaGamma - k * sinDeltaGamma, x2 * cosDeltaPhi - z2 * sinDeltaPhi),
      asin$1(k * cosDeltaGamma + y2 * sinDeltaGamma)
    ];
  }
  rotation2.invert = function(lambda, phi2) {
    var cosPhi = cos$1(phi2), x2 = cos$1(lambda) * cosPhi, y2 = sin$1(lambda) * cosPhi, z2 = sin$1(phi2), k = z2 * cosDeltaGamma - y2 * sinDeltaGamma;
    return [
      atan2(y2 * cosDeltaGamma + z2 * sinDeltaGamma, x2 * cosDeltaPhi + k * sinDeltaPhi),
      asin$1(k * cosDeltaPhi - x2 * sinDeltaPhi)
    ];
  };
  return rotation2;
}
function rotation(rotate2) {
  rotate2 = rotateRadians(rotate2[0] * radians, rotate2[1] * radians, rotate2.length > 2 ? rotate2[2] * radians : 0);
  function forward(coordinates) {
    coordinates = rotate2(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate2.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };
  return forward;
}
function circleStream(stream2, radius2, delta, direction, t02, t12) {
  if (!delta) return;
  var cosRadius = cos$1(radius2), sinRadius = sin$1(radius2), step = direction * delta;
  if (t02 == null) {
    t02 = radius2 + direction * tau$1;
    t12 = radius2 - step / 2;
  } else {
    t02 = circleRadius(cosRadius, t02);
    t12 = circleRadius(cosRadius, t12);
    if (direction > 0 ? t02 < t12 : t02 > t12) t02 += direction * tau$1;
  }
  for (var point2, t4 = t02; direction > 0 ? t4 > t12 : t4 < t12; t4 -= step) {
    point2 = spherical([cosRadius, -sinRadius * cos$1(t4), -sinRadius * sin$1(t4)]);
    stream2.point(point2[0], point2[1]);
  }
}
function circleRadius(cosRadius, point2) {
  point2 = cartesian(point2), point2[0] -= cosRadius;
  cartesianNormalizeInPlace(point2);
  var radius2 = acos(-point2[1]);
  return ((-point2[2] < 0 ? -radius2 : radius2) + tau$1 - epsilon$3) % tau$1;
}
function clipBuffer() {
  var lines = [], line2;
  return {
    point: function(x2, y2, m2) {
      line2.push([x2, y2, m2]);
    },
    lineStart: function() {
      lines.push(line2 = []);
    },
    lineEnd: noop$2,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line2 = null;
      return result;
    }
  };
}
function pointEqual(a2, b2) {
  return abs$2(a2[0] - b2[0]) < epsilon$3 && abs$2(a2[1] - b2[1]) < epsilon$3;
}
function Intersection(point2, points2, other, entry2) {
  this.x = point2;
  this.z = points2;
  this.o = other;
  this.e = entry2;
  this.v = false;
  this.n = this.p = null;
}
function clipRejoin(segments2, compareIntersection2, startInside, interpolate2, stream2) {
  var subject = [], clip2 = [], i, n;
  segments2.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0) return;
    var n2, p02 = segment[0], p1 = segment[n2], x2;
    if (pointEqual(p02, p1)) {
      if (!p02[2] && !p1[2]) {
        stream2.lineStart();
        for (i = 0; i < n2; ++i) stream2.point((p02 = segment[i])[0], p02[1]);
        stream2.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon$3;
    }
    subject.push(x2 = new Intersection(p02, segment, null, true));
    clip2.push(x2.o = new Intersection(p02, null, x2, false));
    subject.push(x2 = new Intersection(p1, segment, null, false));
    clip2.push(x2.o = new Intersection(p1, null, x2, true));
  });
  if (!subject.length) return;
  clip2.sort(compareIntersection2);
  link(subject);
  link(clip2);
  for (i = 0, n = clip2.length; i < n; ++i) {
    clip2[i].e = startInside = !startInside;
  }
  var start = subject[0], points2, point2;
  while (1) {
    var current2 = start, isSubject = true;
    while (current2.v) if ((current2 = current2.n) === start) return;
    points2 = current2.z;
    stream2.lineStart();
    do {
      current2.v = current2.o.v = true;
      if (current2.e) {
        if (isSubject) {
          for (i = 0, n = points2.length; i < n; ++i) stream2.point((point2 = points2[i])[0], point2[1]);
        } else {
          interpolate2(current2.x, current2.n.x, 1, stream2);
        }
        current2 = current2.n;
      } else {
        if (isSubject) {
          points2 = current2.p.z;
          for (i = points2.length - 1; i >= 0; --i) stream2.point((point2 = points2[i])[0], point2[1]);
        } else {
          interpolate2(current2.x, current2.p.x, -1, stream2);
        }
        current2 = current2.p;
      }
      current2 = current2.o;
      points2 = current2.z;
      isSubject = !isSubject;
    } while (!current2.v);
    stream2.lineEnd();
  }
}
function link(array2) {
  if (!(n = array2.length)) return;
  var n, i = 0, a2 = array2[0], b2;
  while (++i < n) {
    a2.n = b2 = array2[i];
    b2.p = a2;
    a2 = b2;
  }
  a2.n = b2 = array2[0];
  b2.p = a2;
}
function longitude(point2) {
  return abs$2(point2[0]) <= pi$1 ? point2[0] : sign(point2[0]) * ((abs$2(point2[0]) + pi$1) % tau$1 - pi$1);
}
function polygonContains(polygon, point2) {
  var lambda = longitude(point2), phi2 = point2[1], sinPhi = sin$1(phi2), normal = [sin$1(lambda), -cos$1(lambda), 0], angle2 = 0, winding = 0;
  var sum2 = new Adder();
  if (sinPhi === 1) phi2 = halfPi$1 + epsilon$3;
  else if (sinPhi === -1) phi2 = -halfPi$1 - epsilon$3;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m2 = (ring = polygon[i]).length)) continue;
    var ring, m2, point0 = ring[m2 - 1], lambda02 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin$1(phi02), cosPhi02 = cos$1(phi02);
    for (var j = 0; j < m2; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin$1(phi12), cosPhi1 = cos$1(phi12), delta = lambda12 - lambda02, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi$1, k = sinPhi02 * sinPhi1;
      sum2.add(atan2(k * sign2 * sin$1(absDelta), cosPhi02 * cosPhi1 + k * cos$1(absDelta)));
      angle2 += antimeridian ? delta + sign2 * tau$1 : delta;
      if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
        var arc2 = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc2);
        var intersection2 = cartesianCross(normal, arc2);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc2[0] || arc2[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -1e-6 || angle2 < epsilon$3 && sum2 < -1e-12) ^ winding & 1;
}
function clip$1(pointVisible, clipLine2, interpolate2, start) {
  return function(sink) {
    var line2 = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments2, ring;
    var clip2 = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip2.point = pointRing;
        clip2.lineStart = ringStart;
        clip2.lineEnd = ringEnd;
        segments2 = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip2.point = point2;
        clip2.lineStart = lineStart;
        clip2.lineEnd = lineEnd;
        segments2 = merge$3(segments2);
        var startInside = polygonContains(polygon, start);
        if (segments2.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clipRejoin(segments2, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments2 = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point2(lambda, phi2) {
      if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line2.point(lambda, phi2);
    }
    function lineStart() {
      clip2.point = pointLine;
      line2.lineStart();
    }
    function lineEnd() {
      clip2.point = point2;
      line2.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m2, segment, point22;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m2; ++i) sink.point((point22 = segment[i])[0], point22[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments2.push(ringSegments.filter(validSegment));
    }
    return clip2;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a2, b2) {
  return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi$1 - epsilon$3 : halfPi$1 - a2[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi$1 - epsilon$3 : halfPi$1 - b2[1]);
}
const clipAntimeridian = clip$1(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi$1, -halfPi$1]
);
function clipAntimeridianLine(stream2) {
  var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream2.lineStart();
      clean = 1;
    },
    point: function(lambda12, phi12) {
      var sign1 = lambda12 > 0 ? pi$1 : -pi$1, delta = abs$2(lambda12 - lambda02);
      if (abs$2(delta - pi$1) < epsilon$3) {
        stream2.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi$1 : -halfPi$1);
        stream2.point(sign0, phi02);
        stream2.lineEnd();
        stream2.lineStart();
        stream2.point(sign1, phi02);
        stream2.point(lambda12, phi02);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi$1) {
        if (abs$2(lambda02 - sign0) < epsilon$3) lambda02 -= sign0 * epsilon$3;
        if (abs$2(lambda12 - sign1) < epsilon$3) lambda12 -= sign1 * epsilon$3;
        phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
        stream2.point(sign0, phi02);
        stream2.lineEnd();
        stream2.lineStart();
        stream2.point(sign1, phi02);
        clean = 0;
      }
      stream2.point(lambda02 = lambda12, phi02 = phi12);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream2.lineEnd();
      lambda02 = phi02 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
  var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin$1(lambda02 - lambda12);
  return abs$2(sinLambda0Lambda1) > epsilon$3 ? atan((sin$1(phi02) * (cosPhi1 = cos$1(phi12)) * sin$1(lambda12) - sin$1(phi12) * (cosPhi02 = cos$1(phi02)) * sin$1(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
}
function clipAntimeridianInterpolate(from2, to, direction, stream2) {
  var phi2;
  if (from2 == null) {
    phi2 = direction * halfPi$1;
    stream2.point(-pi$1, phi2);
    stream2.point(0, phi2);
    stream2.point(pi$1, phi2);
    stream2.point(pi$1, 0);
    stream2.point(pi$1, -phi2);
    stream2.point(0, -phi2);
    stream2.point(-pi$1, -phi2);
    stream2.point(-pi$1, 0);
    stream2.point(-pi$1, phi2);
  } else if (abs$2(from2[0] - to[0]) > epsilon$3) {
    var lambda = from2[0] < to[0] ? pi$1 : -pi$1;
    phi2 = direction * lambda / 2;
    stream2.point(-lambda, phi2);
    stream2.point(0, phi2);
    stream2.point(lambda, phi2);
  } else {
    stream2.point(to[0], to[1]);
  }
}
function clipCircle(radius2) {
  var cr2 = cos$1(radius2), delta = 6 * radians, smallRadius = cr2 > 0, notHemisphere = abs$2(cr2) > epsilon$3;
  function interpolate2(from2, to, direction, stream2) {
    circleStream(stream2, radius2, delta, direction, from2, to);
  }
  function visible(lambda, phi2) {
    return cos$1(lambda) * cos$1(phi2) > cr2;
  }
  function clipLine2(stream2) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point2, v = visible(lambda, phi2), c2 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi2) : 0;
        if (!point0 && (v00 = v0 = v)) stream2.lineStart();
        if (v !== v0) {
          point2 = intersect2(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream2.lineStart();
            point2 = intersect2(point1, point0);
            stream2.point(point2[0], point2[1]);
          } else {
            point2 = intersect2(point0, point1);
            stream2.point(point2[0], point2[1], 2);
            stream2.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t4;
          if (!(c2 & c0) && (t4 = intersect2(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream2.lineStart();
              stream2.point(t4[0][0], t4[0][1]);
              stream2.point(t4[1][0], t4[1][1]);
              stream2.lineEnd();
            } else {
              stream2.point(t4[1][0], t4[1][1]);
              stream2.lineEnd();
              stream2.lineStart();
              stream2.point(t4[0][0], t4[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream2.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c2;
      },
      lineEnd: function() {
        if (v0) stream2.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect2(a2, b2, two) {
    var pa2 = cartesian(a2), pb = cartesian(b2);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa2, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a2;
    var c1 = cr2 * n2n2 / determinant, c2 = -cr2 * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
    cartesianAddInPlace(A5, B2);
    var u2 = n1xn2, w2 = cartesianDot(A5, u2), uu = cartesianDot(u2, u2), t22 = w2 * w2 - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0) return;
    var t4 = sqrt$1(t22), q = cartesianScale(u2, (-w2 - t4) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two) return q;
    var lambda02 = a2[0], lambda12 = b2[0], phi02 = a2[1], phi12 = b2[1], z2;
    if (lambda12 < lambda02) z2 = lambda02, lambda02 = lambda12, lambda12 = z2;
    var delta2 = lambda12 - lambda02, polar = abs$2(delta2 - pi$1) < epsilon$3, meridian = polar || delta2 < epsilon$3;
    if (!polar && phi12 < phi02) z2 = phi02, phi02 = phi12, phi12 = z2;
    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs$2(q[0] - lambda02) < epsilon$3 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi$1 ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
      var q1 = cartesianScale(u2, (-w2 + t4) / uu);
      cartesianAddInPlace(q1, A5);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r2 = smallRadius ? radius2 : pi$1 - radius2, code2 = 0;
    if (lambda < -r2) code2 |= 1;
    else if (lambda > r2) code2 |= 2;
    if (phi2 < -r2) code2 |= 4;
    else if (phi2 > r2) code2 |= 8;
    return code2;
  }
  return clip$1(visible, clipLine2, interpolate2, smallRadius ? [0, -radius2] : [-pi$1, radius2 - pi$1]);
}
function clipLine(a2, b2, x02, y02, x12, y12) {
  var ax = a2[0], ay = a2[1], bx = b2[0], by = b2[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x02 - ax;
  if (!dx && r2 > 0) return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t02) return;
    if (r2 < t12) t12 = r2;
  } else if (dx > 0) {
    if (r2 > t12) return;
    if (r2 > t02) t02 = r2;
  }
  r2 = x12 - ax;
  if (!dx && r2 < 0) return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t12) return;
    if (r2 > t02) t02 = r2;
  } else if (dx > 0) {
    if (r2 < t02) return;
    if (r2 < t12) t12 = r2;
  }
  r2 = y02 - ay;
  if (!dy && r2 > 0) return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t02) return;
    if (r2 < t12) t12 = r2;
  } else if (dy > 0) {
    if (r2 > t12) return;
    if (r2 > t02) t02 = r2;
  }
  r2 = y12 - ay;
  if (!dy && r2 < 0) return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t12) return;
    if (r2 > t02) t02 = r2;
  } else if (dy > 0) {
    if (r2 < t02) return;
    if (r2 < t12) t12 = r2;
  }
  if (t02 > 0) a2[0] = ax + t02 * dx, a2[1] = ay + t02 * dy;
  if (t12 < 1) b2[0] = ax + t12 * dx, b2[1] = ay + t12 * dy;
  return true;
}
var clipMax = 1e9, clipMin = -1e9;
function clipRectangle(x02, y02, x12, y12) {
  function visible(x2, y2) {
    return x02 <= x2 && x2 <= x12 && y02 <= y2 && y2 <= y12;
  }
  function interpolate2(from2, to, direction, stream2) {
    var a2 = 0, a1 = 0;
    if (from2 == null || (a2 = corner(from2, direction)) !== (a1 = corner(to, direction)) || comparePoint(from2, to) < 0 ^ direction > 0) {
      do
        stream2.point(a2 === 0 || a2 === 3 ? x02 : x12, a2 > 1 ? y12 : y02);
      while ((a2 = (a2 + direction + 4) % 4) !== a1);
    } else {
      stream2.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs$2(p[0] - x02) < epsilon$3 ? direction > 0 ? 0 : 3 : abs$2(p[0] - x12) < epsilon$3 ? direction > 0 ? 2 : 1 : abs$2(p[1] - y02) < epsilon$3 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a2, b2) {
    return comparePoint(a2.x, b2.x);
  }
  function comparePoint(a2, b2) {
    var ca = corner(a2, 1), cb = corner(b2, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a2[1] : ca === 1 ? a2[0] - b2[0] : ca === 2 ? a2[1] - b2[1] : b2[0] - a2[0];
  }
  return function(stream2) {
    var activeStream = stream2, bufferStream = clipBuffer(), segments2, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point2(x2, y2) {
      if (visible(x2, y2)) activeStream.point(x2, y2);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m2 = ring2.length, point22 = ring2[0], a0, a1, b0 = point22[0], b1 = point22[1]; j < m2; ++j) {
          a0 = b0, a1 = b1, point22 = ring2[j], b0 = point22[0], b1 = point22[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0)) ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments2 = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments2 = merge$3(segments2)).length;
      if (cleanInside || visible2) {
        stream2.polygonStart();
        if (cleanInside) {
          stream2.lineStart();
          interpolate2(null, null, 1, stream2);
          stream2.lineEnd();
        }
        if (visible2) {
          clipRejoin(segments2, compareIntersection2, startInside, interpolate2, stream2);
        }
        stream2.polygonEnd();
      }
      activeStream = stream2, segments2 = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint2;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments2) {
        linePoint2(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments2.push(bufferStream.result());
      }
      clipStream.point = point2;
      if (v_) activeStream.lineEnd();
    }
    function linePoint2(x2, y2) {
      var v = visible(x2, y2);
      if (polygon) ring.push([x2, y2]);
      if (first) {
        x__ = x2, y__ = y2, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x2, y2);
        }
      } else {
        if (v && v_) activeStream.point(x2, y2);
        else {
          var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b2 = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y2 = Math.max(clipMin, Math.min(clipMax, y2))];
          if (clipLine(a2, b2, x02, y02, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a2[0], a2[1]);
            }
            activeStream.point(b2[0], b2[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x2, y2);
            clean = false;
          }
        }
      }
      x_ = x2, y_ = y2, v_ = v;
    }
    return clipStream;
  };
}
function graticuleX(y02, y12, dy) {
  var y2 = range$6(y02, y12 - epsilon$3, dy).concat(y12);
  return function(x2) {
    return y2.map(function(y22) {
      return [x2, y22];
    });
  };
}
function graticuleY(x02, x12, dx) {
  var x2 = range$6(x02, x12 - epsilon$3, dx).concat(x12);
  return function(y2) {
    return x2.map(function(x22) {
      return [x22, y2];
    });
  };
}
function graticule() {
  var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x2, y2, X3, Y3, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range$6(ceil(X02 / DX) * DX, X12, DX).map(X3).concat(range$6(ceil(Y02 / DY) * DY, Y12, DY).map(Y3)).concat(range$6(ceil(x02 / dx) * dx, x12, dx).filter(function(x22) {
      return abs$2(x22 % DX) > epsilon$3;
    }).map(x2)).concat(range$6(ceil(y02 / dy) * dy, y12, dy).filter(function(y22) {
      return abs$2(y22 % DY) > epsilon$3;
    }).map(y2));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X3(X02).concat(
          Y3(Y12).slice(1),
          X3(X12).reverse().slice(1),
          Y3(Y02).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length) return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length) return [[X02, Y02], [X12, Y12]];
    X02 = +_[0][0], X12 = +_[1][0];
    Y02 = +_[0][1], Y12 = +_[1][1];
    if (X02 > X12) _ = X02, X02 = X12, X12 = _;
    if (Y02 > Y12) _ = Y02, Y02 = Y12, Y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length) return [[x02, y02], [x12, y12]];
    x02 = +_[0][0], x12 = +_[1][0];
    y02 = +_[0][1], y12 = +_[1][1];
    if (x02 > x12) _ = x02, x02 = x12, x12 = _;
    if (y02 > y12) _ = y02, y02 = y12, y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length) return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x2 = graticuleX(y02, y12, 90);
    y2 = graticuleY(x02, x12, precision);
    X3 = graticuleX(Y02, Y12, 90);
    Y3 = graticuleY(X02, X12, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon$3], [180, 90 - epsilon$3]]).extentMinor([[-180, -80 - epsilon$3], [180, 80 + epsilon$3]]);
}
const identity = (x2) => x2;
var areaSum = new Adder(), areaRingSum = new Adder(), x00$2, y00$2, x0$3, y0$3;
var areaStream = {
  point: noop$2,
  lineStart: noop$2,
  lineEnd: noop$2,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$2;
    areaSum.add(abs$2(areaRingSum));
    areaRingSum = new Adder();
  },
  result: function() {
    var area2 = areaSum / 2;
    areaSum = new Adder();
    return area2;
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaPointFirst(x2, y2) {
  areaStream.point = areaPoint;
  x00$2 = x0$3 = x2, y00$2 = y0$3 = y2;
}
function areaPoint(x2, y2) {
  areaRingSum.add(y0$3 * x2 - x0$3 * y2);
  x0$3 = x2, y0$3 = y2;
}
function areaRingEnd() {
  areaPoint(x00$2, y00$2);
}
var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop$2,
  lineEnd: noop$2,
  polygonStart: noop$2,
  polygonEnd: noop$2,
  result: function() {
    var bounds2 = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds2;
  }
};
function boundsPoint(x2, y2) {
  if (x2 < x0$2) x0$2 = x2;
  if (x2 > x1) x1 = x2;
  if (y2 < y0$2) y0$2 = y2;
  if (y2 > y1) y1 = y2;
}
var X0 = 0, Y0 = 0, Z0 = 0, X1 = 0, Y1 = 0, Z1 = 0, X2$1 = 0, Y2$1 = 0, Z2 = 0, x00$1, y00$1, x0$1, y0$1;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2$1 / Z2, Y2$1 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2$1 = Y2$1 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x2, y2) {
  X0 += x2;
  Y0 += y2;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x2, y2) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0$1 = x2, y0$1 = y2);
}
function centroidPointLine(x2, y2) {
  var dx = x2 - x0$1, dy = y2 - y0$1, z2 = sqrt$1(dx * dx + dy * dy);
  X1 += z2 * (x0$1 + x2) / 2;
  Y1 += z2 * (y0$1 + y2) / 2;
  Z1 += z2;
  centroidPoint(x0$1 = x2, y0$1 = y2);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x00$1, y00$1);
}
function centroidPointFirstRing(x2, y2) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00$1 = x0$1 = x2, y00$1 = y0$1 = y2);
}
function centroidPointRing(x2, y2) {
  var dx = x2 - x0$1, dy = y2 - y0$1, z2 = sqrt$1(dx * dx + dy * dy);
  X1 += z2 * (x0$1 + x2) / 2;
  Y1 += z2 * (y0$1 + y2) / 2;
  Z1 += z2;
  z2 = y0$1 * x2 - x0$1 * y2;
  X2$1 += z2 * (x0$1 + x2);
  Y2$1 += z2 * (y0$1 + y2);
  Z2 += z2 * 3;
  centroidPoint(x0$1 = x2, y0$1 = y2);
}
function PathContext(context2) {
  this._context = context2;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x2, y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x2, y2);
        break;
      }
      default: {
        this._context.moveTo(x2 + this._radius, y2);
        this._context.arc(x2, y2, this._radius, 0, tau$1);
        break;
      }
    }
  },
  result: noop$2
};
var lengthSum = new Adder(), lengthRing, x00, y00, x0, y0;
var lengthStream = {
  point: noop$2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = noop$2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length2 = +lengthSum;
    lengthSum = new Adder();
    return length2;
  }
};
function lengthPointFirst(x2, y2) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x2, y00 = y0 = y2;
}
function lengthPoint(x2, y2) {
  x0 -= x2, y0 -= y2;
  lengthSum.add(sqrt$1(x0 * x0 + y0 * y0));
  x0 = x2, y0 = y2;
}
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle$1(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x2, ",", y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x2, ",", y2);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle$1(this._radius);
        this._string.push("M", x2, ",", y2, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};
function circle$1(radius2) {
  return "m0," + radius2 + "a" + radius2 + "," + radius2 + " 0 1,1 0," + -2 * radius2 + "a" + radius2 + "," + radius2 + " 0 1,1 0," + 2 * radius2 + "z";
}
function geoPath(projection2, context2) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path2(object2) {
    if (object2) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object2) {
    geoStream(object2, projectionStream(areaStream));
    return areaStream.result();
  };
  path2.measure = function(object2) {
    geoStream(object2, projectionStream(lengthStream));
    return lengthStream.result();
  };
  path2.bounds = function(object2) {
    geoStream(object2, projectionStream(boundsStream));
    return boundsStream.result();
  };
  path2.centroid = function(object2) {
    geoStream(object2, projectionStream(centroidStream));
    return centroidStream.result();
  };
  path2.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection2 = null, identity) : (projection2 = _).stream, path2) : projection2;
  };
  path2.context = function(_) {
    if (!arguments.length) return context2;
    contextStream = _ == null ? (context2 = null, new PathString()) : new PathContext(context2 = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path2;
  };
  return path2.projection(projection2).context(context2);
}
function transformer(methods2) {
  return function(stream2) {
    var s = new TransformStream();
    for (var key2 in methods2) s[key2] = methods2[key2];
    s.stream = stream2;
    return s;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x2, y2) {
    this.stream.point(x2, y2);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function fit$1(projection2, fitBounds, object2) {
  var clip2 = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip2 != null) projection2.clipExtent(null);
  geoStream(object2, projection2.stream(boundsStream));
  fitBounds(boundsStream.result());
  if (clip2 != null) projection2.clipExtent(clip2);
  return projection2;
}
function fitExtent(projection2, extent2, object2) {
  return fit$1(projection2, function(b2) {
    var w2 = extent2[1][0] - extent2[0][0], h2 = extent2[1][1] - extent2[0][1], k = Math.min(w2 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x2 = +extent2[0][0] + (w2 - k * (b2[1][0] + b2[0][0])) / 2, y2 = +extent2[0][1] + (h2 - k * (b2[1][1] + b2[0][1])) / 2;
    projection2.scale(150 * k).translate([x2, y2]);
  }, object2);
}
function fitSize(projection2, size, object2) {
  return fitExtent(projection2, [[0, 0], size], object2);
}
function fitWidth(projection2, width2, object2) {
  return fit$1(projection2, function(b2) {
    var w2 = +width2, k = w2 / (b2[1][0] - b2[0][0]), x2 = (w2 - k * (b2[1][0] + b2[0][0])) / 2, y2 = -k * b2[0][1];
    projection2.scale(150 * k).translate([x2, y2]);
  }, object2);
}
function fitHeight(projection2, height2, object2) {
  return fit$1(projection2, function(b2) {
    var h2 = +height2, k = h2 / (b2[1][1] - b2[0][1]), x2 = -k * b2[0][0], y2 = (h2 - k * (b2[1][1] + b2[0][1])) / 2;
    projection2.scale(150 * k).translate([x2, y2]);
  }, object2);
}
var maxDepth = 16, cosMinDistance = cos$1(30 * radians);
function resample(project2, delta2) {
  return +delta2 ? resample$1(project2, delta2) : resampleNone(project2);
}
function resampleNone(project2) {
  return transformer({
    point: function(x2, y2) {
      x2 = project2(x2, y2);
      this.stream.point(x2[0], x2[1]);
    }
  });
}
function resample$1(project2, delta2) {
  function resampleLineTo(x02, y02, lambda02, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream2) {
    var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a2 = a0 + a1, b2 = b0 + b1, c2 = c0 + c1, m2 = sqrt$1(a2 * a2 + b2 * b2 + c2 * c2), phi2 = asin$1(c2 /= m2), lambda22 = abs$2(abs$2(c2) - 1) < epsilon$3 || abs$2(lambda02 - lambda12) < epsilon$3 ? (lambda02 + lambda12) / 2 : atan2(b2, a2), p = project2(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs$2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x02, y02, lambda02, a0, b0, c0, x2, y2, lambda22, a2 /= m2, b2 /= m2, c2, depth, stream2);
        stream2.point(x2, y2);
        resampleLineTo(x2, y2, lambda22, a2, b2, c2, x12, y12, lambda12, a1, b1, c1, depth, stream2);
      }
    }
  }
  return function(stream2) {
    var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b0, c0;
    var resampleStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream2.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream2.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point2(x2, y2) {
      x2 = project2(x2, y2);
      stream2.point(x2[0], x2[1]);
    }
    function lineStart() {
      x02 = NaN;
      resampleStream.point = linePoint2;
      stream2.lineStart();
    }
    function linePoint2(lambda, phi2) {
      var c2 = cartesian([lambda, phi2]), p = project2(lambda, phi2);
      resampleLineTo(x02, y02, lambda02, a0, b0, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth, stream2);
      stream2.point(x02, y02);
    }
    function lineEnd() {
      resampleStream.point = point2;
      stream2.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint2(lambda002 = lambda, phi2), x002 = x02, y002 = y02, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint2;
    }
    function ringEnd() {
      resampleLineTo(x02, y02, lambda02, a0, b0, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream2);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}
var transformRadians = transformer({
  point: function(x2, y2) {
    this.stream.point(x2 * radians, y2 * radians);
  }
});
function transformRotate(rotate2) {
  return transformer({
    point: function(x2, y2) {
      var r2 = rotate2(x2, y2);
      return this.stream.point(r2[0], r2[1]);
    }
  });
}
function scaleTranslate(k, dx, dy, sx, sy) {
  function transform2(x2, y2) {
    x2 *= sx;
    y2 *= sy;
    return [dx + k * x2, dy - k * y2];
  }
  transform2.invert = function(x2, y2) {
    return [(x2 - dx) / k * sx, (dy - y2) / k * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k, dx, dy, sx, sy, alpha2) {
  if (!alpha2) return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = cos$1(alpha2), sinAlpha = sin$1(alpha2), a2 = cosAlpha * k, b2 = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform2(x2, y2) {
    x2 *= sx;
    y2 *= sy;
    return [a2 * x2 - b2 * y2 + dx, dy - b2 * x2 - a2 * y2];
  }
  transform2.invert = function(x2, y2) {
    return [sx * (ai * x2 - bi * y2 + ci), sy * (fi - bi * x2 - ai * y2)];
  };
  return transform2;
}
function projection$1(project2) {
  return projectionMutator(function() {
    return project2;
  })();
}
function projectionMutator(projectAt) {
  var project2, k = 150, x2 = 480, y2 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate2, alpha2 = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection2(point2) {
    return projectRotateTransform(point2[0] * radians, point2[1] * radians);
  }
  function invert2(point2) {
    point2 = projectRotateTransform.invert(point2[0], point2[1]);
    return point2 && [point2[0] * degrees, point2[1] * degrees];
  }
  projection2.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = transformRadians(transformRotate(rotate2)(preclip(projectResample(postclip(cacheStream = stream2)))));
  };
  projection2.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset3()) : preclip;
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset3()) : postclip;
  };
  projection2.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset3()) : theta * degrees;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset3()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };
  projection2.translate = function(_) {
    return arguments.length ? (x2 = +_[0], y2 = +_[1], recenter()) : [x2, y2];
  };
  projection2.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi2 = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
  };
  projection2.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha2 = _ % 360 * radians, recenter()) : alpha2 * degrees;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset3()) : sqrt$1(delta2);
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width2, object2) {
    return fitWidth(projection2, width2, object2);
  };
  projection2.fitHeight = function(height2, object2) {
    return fitHeight(projection2, height2, object2);
  };
  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha2).apply(null, project2(lambda, phi2)), transform2 = scaleTranslateRotate(k, x2 - center[0], y2 - center[1], sx, sy, alpha2);
    rotate2 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose$1(project2, transform2);
    projectRotateTransform = compose$1(rotate2, projectTransform);
    projectResample = resample(projectTransform, delta2);
    return reset3();
  }
  function reset3() {
    cache2 = cacheStream = null;
    return projection2;
  }
  return function() {
    project2 = projectAt.apply(this, arguments);
    projection2.invert = project2.invert && invert2;
    return recenter();
  };
}
function conicProjection(projectAt) {
  var phi02 = 0, phi12 = pi$1 / 3, m2 = projectionMutator(projectAt), p = m2(phi02, phi12);
  p.parallels = function(_) {
    return arguments.length ? m2(phi02 = _[0] * radians, phi12 = _[1] * radians) : [phi02 * degrees, phi12 * degrees];
  };
  return p;
}
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi02 = cos$1(phi02);
  function forward(lambda, phi2) {
    return [lambda * cosPhi02, sin$1(phi2) / cosPhi02];
  }
  forward.invert = function(x2, y2) {
    return [x2 / cosPhi02, asin$1(y2 * cosPhi02)];
  };
  return forward;
}
function conicEqualAreaRaw(y02, y12) {
  var sy0 = sin$1(y02), n = (sy0 + sin$1(y12)) / 2;
  if (abs$2(n) < epsilon$3) return cylindricalEqualAreaRaw(y02);
  var c2 = 1 + sy0 * (2 * n - sy0), r0 = sqrt$1(c2) / n;
  function project2(x2, y2) {
    var r2 = sqrt$1(c2 - 2 * n * sin$1(y2)) / n;
    return [r2 * sin$1(x2 *= n), r0 - r2 * cos$1(x2)];
  }
  project2.invert = function(x2, y2) {
    var r0y = r0 - y2, l = atan2(x2, abs$2(r0y)) * sign(r0y);
    if (r0y * n < 0)
      l -= pi$1 * sign(x2) * sign(r0y);
    return [l / n, asin$1((c2 - (x2 * x2 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project2;
}
function geoConicEqualArea() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}
function geoAlbers() {
  return geoConicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x2, y2) {
      var i = -1;
      while (++i < n) streams[i].point(x2, y2);
    },
    sphere: function() {
      var i = -1;
      while (++i < n) streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n) streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n) streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n) streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n) streams[i].polygonEnd();
    }
  };
}
function geoAlbersUsa() {
  var cache2, cacheStream, lower48 = geoAlbers(), lower48Point, alaska = geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point2, pointStream = { point: function(x2, y2) {
    point2 = [x2, y2];
  } };
  function albersUsa(coordinates) {
    var x2 = coordinates[0], y2 = coordinates[1];
    return point2 = null, (lower48Point.point(x2, y2), point2) || (alaskaPoint.point(x2, y2), point2) || (hawaiiPoint.point(x2, y2), point2);
  }
  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(), t4 = lower48.translate(), x2 = (coordinates[0] - t4[0]) / k, y2 = (coordinates[1] - t4[1]) / k;
    return (y2 >= 0.12 && y2 < 0.234 && x2 >= -0.425 && x2 < -0.214 ? alaska : y2 >= 0.166 && y2 < 0.234 && x2 >= -0.214 && x2 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream2), alaska.stream(stream2), hawaii.stream(stream2)]);
  };
  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset3();
  };
  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x2 = +_[0], y2 = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x2 - 0.455 * k, y2 - 0.238 * k], [x2 + 0.455 * k, y2 + 0.238 * k]]).stream(pointStream);
    alaskaPoint = alaska.translate([x2 - 0.307 * k, y2 + 0.201 * k]).clipExtent([[x2 - 0.425 * k + epsilon$3, y2 + 0.12 * k + epsilon$3], [x2 - 0.214 * k - epsilon$3, y2 + 0.234 * k - epsilon$3]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x2 - 0.205 * k, y2 + 0.212 * k]).clipExtent([[x2 - 0.214 * k + epsilon$3, y2 + 0.166 * k + epsilon$3], [x2 - 0.115 * k - epsilon$3, y2 + 0.234 * k - epsilon$3]]).stream(pointStream);
    return reset3();
  };
  albersUsa.fitExtent = function(extent2, object2) {
    return fitExtent(albersUsa, extent2, object2);
  };
  albersUsa.fitSize = function(size, object2) {
    return fitSize(albersUsa, size, object2);
  };
  albersUsa.fitWidth = function(width2, object2) {
    return fitWidth(albersUsa, width2, object2);
  };
  albersUsa.fitHeight = function(height2, object2) {
    return fitHeight(albersUsa, height2, object2);
  };
  function reset3() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}
function azimuthalRaw(scale2) {
  return function(x2, y2) {
    var cx = cos$1(x2), cy = cos$1(y2), k = scale2(cx * cy);
    if (k === Infinity) return [2, 0];
    return [
      k * cy * sin$1(x2),
      k * sin$1(y2)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x2, y2) {
    var z2 = sqrt$1(x2 * x2 + y2 * y2), c2 = angle2(z2), sc = sin$1(c2), cc = cos$1(c2);
    return [
      atan2(x2 * sc, z2 * cc),
      asin$1(z2 && y2 * sc / z2)
    ];
  };
}
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt$1(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z2) {
  return 2 * asin$1(z2 / 2);
});
function geoAzimuthalEqualArea() {
  return projection$1(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}
var azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
  return (c2 = acos(c2)) && c2 / sin$1(c2);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z2) {
  return z2;
});
function geoAzimuthalEquidistant() {
  return projection$1(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}
function mercatorRaw(lambda, phi2) {
  return [lambda, log$2(tan((halfPi$1 + phi2) / 2))];
}
mercatorRaw.invert = function(x2, y2) {
  return [x2, 2 * atan(exp(y2)) - halfPi$1];
};
function geoMercator() {
  return mercatorProjection(mercatorRaw).scale(961 / tau$1);
}
function mercatorProjection(project2) {
  var m2 = projection$1(project2), center = m2.center, scale2 = m2.scale, translate2 = m2.translate, clipExtent = m2.clipExtent, x02 = null, y02, x12, y12;
  m2.scale = function(_) {
    return arguments.length ? (scale2(_), reclip()) : scale2();
  };
  m2.translate = function(_) {
    return arguments.length ? (translate2(_), reclip()) : translate2();
  };
  m2.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };
  m2.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x02 = y02 = x12 = y12 = null : (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  function reclip() {
    var k = pi$1 * scale2(), t4 = m2(rotation(m2.rotate()).invert([0, 0]));
    return clipExtent(x02 == null ? [[t4[0] - k, t4[1] - k], [t4[0] + k, t4[1] + k]] : project2 === mercatorRaw ? [[Math.max(t4[0] - k, x02), y02], [Math.min(t4[0] + k, x12), y12]] : [[x02, Math.max(t4[1] - k, y02)], [x12, Math.min(t4[1] + k, y12)]]);
  }
  return reclip();
}
function tany(y2) {
  return tan((halfPi$1 + y2) / 2);
}
function conicConformalRaw(y02, y12) {
  var cy0 = cos$1(y02), n = y02 === y12 ? sin$1(y02) : log$2(cy0 / cos$1(y12)) / log$2(tany(y12) / tany(y02)), f = cy0 * pow$1(tany(y02), n) / n;
  if (!n) return mercatorRaw;
  function project2(x2, y2) {
    if (f > 0) {
      if (y2 < -halfPi$1 + epsilon$3) y2 = -halfPi$1 + epsilon$3;
    } else {
      if (y2 > halfPi$1 - epsilon$3) y2 = halfPi$1 - epsilon$3;
    }
    var r2 = f / pow$1(tany(y2), n);
    return [r2 * sin$1(n * x2), f - r2 * cos$1(n * x2)];
  }
  project2.invert = function(x2, y2) {
    var fy = f - y2, r2 = sign(n) * sqrt$1(x2 * x2 + fy * fy), l = atan2(x2, abs$2(fy)) * sign(fy);
    if (fy * n < 0)
      l -= pi$1 * sign(x2) * sign(fy);
    return [l / n, 2 * atan(pow$1(f / r2, 1 / n)) - halfPi$1];
  };
  return project2;
}
function geoConicConformal() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function geoEquirectangular() {
  return projection$1(equirectangularRaw).scale(152.63);
}
function conicEquidistantRaw(y02, y12) {
  var cy0 = cos$1(y02), n = y02 === y12 ? sin$1(y02) : (cy0 - cos$1(y12)) / (y12 - y02), g = cy0 / n + y02;
  if (abs$2(n) < epsilon$3) return equirectangularRaw;
  function project2(x2, y2) {
    var gy = g - y2, nx = n * x2;
    return [gy * sin$1(nx), g - gy * cos$1(nx)];
  }
  project2.invert = function(x2, y2) {
    var gy = g - y2, l = atan2(x2, abs$2(gy)) * sign(gy);
    if (gy * n < 0)
      l -= pi$1 * sign(x2) * sign(gy);
    return [l / n, g - sign(n) * sqrt$1(x2 * x2 + gy * gy)];
  };
  return project2;
}
function geoConicEquidistant() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}
var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt$1(3) / 2, iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin$1(M * sin$1(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x2, y2) {
  var l = y2, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y2;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs$2(delta) < epsilon2) break;
  }
  return [
    M * x2 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
    asin$1(sin$1(l) / M)
  ];
};
function geoEqualEarth() {
  return projection$1(equalEarthRaw).scale(177.158);
}
function gnomonicRaw(x2, y2) {
  var cy = cos$1(y2), k = cos$1(x2) * cy;
  return [cy * sin$1(x2) / k, sin$1(y2) / k];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function geoGnomonic() {
  return projection$1(gnomonicRaw).scale(144.049).clipAngle(60);
}
function geoIdentity() {
  var k = 1, tx2 = 0, ty = 0, sx = 1, sy = 1, alpha2 = 0, ca, sa2, x02 = null, y02, x12, y12, kx = 1, ky = 1, transform2 = transformer({
    point: function(x2, y2) {
      var p = projection2([x2, y2]);
      this.stream.point(p[0], p[1]);
    }
  }), postclip = identity, cache2, cacheStream;
  function reset3() {
    kx = k * sx;
    ky = k * sy;
    cache2 = cacheStream = null;
    return projection2;
  }
  function projection2(p) {
    var x2 = p[0] * kx, y2 = p[1] * ky;
    if (alpha2) {
      var t4 = y2 * ca - x2 * sa2;
      x2 = x2 * ca + y2 * sa2;
      y2 = t4;
    }
    return [x2 + tx2, y2 + ty];
  }
  projection2.invert = function(p) {
    var x2 = p[0] - tx2, y2 = p[1] - ty;
    if (alpha2) {
      var t4 = y2 * ca + x2 * sa2;
      x2 = x2 * ca - y2 * sa2;
      y2 = t4;
    }
    return [x2 / kx, y2 / ky];
  };
  projection2.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = transform2(postclip(cacheStream = stream2));
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset3()) : postclip;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset3()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k = +_, reset3()) : k;
  };
  projection2.translate = function(_) {
    return arguments.length ? (tx2 = +_[0], ty = +_[1], reset3()) : [tx2, ty];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha2 = _ % 360 * radians, sa2 = sin$1(alpha2), ca = cos$1(alpha2), reset3()) : alpha2 * degrees;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset3()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset3()) : sy < 0;
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width2, object2) {
    return fitWidth(projection2, width2, object2);
  };
  projection2.fitHeight = function(height2, object2) {
    return fitHeight(projection2, height2, object2);
  };
  return projection2;
}
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x2, y2) {
  var phi2 = y2, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y2) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs$2(delta) > epsilon$3 && --i > 0);
  return [
    x2 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function geoNaturalEarth1() {
  return projection$1(naturalEarth1Raw).scale(175.295);
}
function orthographicRaw(x2, y2) {
  return [cos$1(y2) * sin$1(x2), sin$1(y2)];
}
orthographicRaw.invert = azimuthalInvert(asin$1);
function geoOrthographic() {
  return projection$1(orthographicRaw).scale(249.5).clipAngle(90 + epsilon$3);
}
function stereographicRaw(x2, y2) {
  var cy = cos$1(y2), k = 1 + cos$1(x2) * cy;
  return [cy * sin$1(x2) / k, sin$1(y2) / k];
}
stereographicRaw.invert = azimuthalInvert(function(z2) {
  return 2 * atan(z2);
});
function geoStereographic() {
  return projection$1(stereographicRaw).scale(250).clipAngle(142);
}
function transverseMercatorRaw(lambda, phi2) {
  return [log$2(tan((halfPi$1 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x2, y2) {
  return [-y2, 2 * atan(exp(x2)) - halfPi$1];
};
function geoTransverseMercator() {
  var m2 = mercatorProjection(transverseMercatorRaw), center = m2.center, rotate2 = m2.rotate;
  m2.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };
  m2.rotate = function(_) {
    return arguments.length ? rotate2([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate2(), [_[0], _[1], _[2] - 90]);
  };
  return rotate2([0, 0, 90]).scale(159.155);
}
var abs$1 = Math.abs;
var cos = Math.cos;
var sin = Math.sin;
var epsilon$2 = 1e-6;
var pi = Math.PI;
var halfPi = pi / 2;
var sqrt2 = sqrt(2);
function asin(x2) {
  return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
}
function sqrt(x2) {
  return x2 > 0 ? Math.sqrt(x2) : 0;
}
function mollweideBromleyTheta(cp, phi2) {
  var cpsinPhi = cp * sin(phi2), i = 30, delta;
  do
    phi2 -= delta = (phi2 + sin(phi2) - cpsinPhi) / (1 + cos(phi2));
  while (abs$1(delta) > epsilon$2 && --i > 0);
  return phi2 / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi2) {
    return [cx * lambda * cos(phi2 = mollweideBromleyTheta(cp, phi2)), cy * sin(phi2)];
  }
  forward.invert = function(x2, y2) {
    return y2 = asin(y2 / cy), [x2 / (cx * cos(y2)), asin((2 * y2 + sin(2 * y2)) / cp)];
  };
  return forward;
}
var mollweideRaw = mollweideBromleyRaw(sqrt2 / halfPi, sqrt2, pi);
function geoMollweide() {
  return projection$1(mollweideRaw).scale(169.529);
}
const defaultPath = geoPath();
const projectionProperties = [
  // standard properties in d3-geo
  "clipAngle",
  "clipExtent",
  "scale",
  "translate",
  "center",
  "rotate",
  "parallels",
  "precision",
  "reflectX",
  "reflectY",
  // extended properties in d3-geo-projections
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
function create$1(type2, constructor) {
  return function projection2() {
    const p = constructor();
    p.type = type2;
    p.path = geoPath().projection(p);
    p.copy = p.copy || function() {
      const c2 = projection2();
      projectionProperties.forEach((prop) => {
        if (p[prop]) c2[prop](p[prop]());
      });
      c2.path.pointRadius(p.path.pointRadius());
      return c2;
    };
    return p;
  };
}
function projection(type2, proj) {
  if (!type2 || typeof type2 !== "string") {
    throw new Error("Projection type must be a name string.");
  }
  type2 = type2.toLowerCase();
  if (arguments.length > 1) {
    projections[type2] = create$1(type2, proj);
    return this;
  } else {
    return projections[type2] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
const projections = {
  // base d3-geo projection types
  albers: geoAlbers,
  albersusa: geoAlbersUsa,
  azimuthalequalarea: geoAzimuthalEqualArea,
  azimuthalequidistant: geoAzimuthalEquidistant,
  conicconformal: geoConicConformal,
  conicequalarea: geoConicEqualArea,
  conicequidistant: geoConicEquidistant,
  equalEarth: geoEqualEarth,
  equirectangular: geoEquirectangular,
  gnomonic: geoGnomonic,
  identity: geoIdentity,
  mercator: geoMercator,
  mollweide: geoMollweide,
  naturalEarth1: geoNaturalEarth1,
  orthographic: geoOrthographic,
  stereographic: geoStereographic,
  transversemercator: geoTransverseMercator
};
for (const key2 in projections) {
  projection(key2, projections[key2]);
}
function noop$1() {
}
const cases = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
function contours() {
  var dx = 1, dy = 1, smooth = smoothLinear;
  function contours2(values2, tz) {
    return tz.map((value2) => contour(values2, value2));
  }
  function contour(values2, value2) {
    var polygons = [], holes = [];
    isorings(values2, value2, (ring) => {
      smooth(ring, values2, value2);
      if (area$1(ring) > 0) polygons.push([ring]);
      else holes.push(ring);
    });
    holes.forEach((hole) => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains$1((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value: value2,
      coordinates: polygons
    };
  }
  function isorings(values2, value2, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x2, y2, t02, t12, t22, t32;
    x2 = y2 = -1;
    t12 = values2[0] >= value2;
    cases[t12 << 1].forEach(stitch2);
    while (++x2 < dx - 1) {
      t02 = t12, t12 = values2[x2 + 1] >= value2;
      cases[t02 | t12 << 1].forEach(stitch2);
    }
    cases[t12 << 0].forEach(stitch2);
    while (++y2 < dy - 1) {
      x2 = -1;
      t12 = values2[y2 * dx + dx] >= value2;
      t22 = values2[y2 * dx] >= value2;
      cases[t12 << 1 | t22 << 2].forEach(stitch2);
      while (++x2 < dx - 1) {
        t02 = t12, t12 = values2[y2 * dx + dx + x2 + 1] >= value2;
        t32 = t22, t22 = values2[y2 * dx + x2 + 1] >= value2;
        cases[t02 | t12 << 1 | t22 << 2 | t32 << 3].forEach(stitch2);
      }
      cases[t12 | t22 << 3].forEach(stitch2);
    }
    x2 = -1;
    t22 = values2[y2 * dx] >= value2;
    cases[t22 << 2].forEach(stitch2);
    while (++x2 < dx - 1) {
      t32 = t22, t22 = values2[y2 * dx + x2 + 1] >= value2;
      cases[t22 << 2 | t32 << 3].forEach(stitch2);
    }
    cases[t22 << 3].forEach(stitch2);
    function stitch2(line2) {
      var start = [line2[0][0] + x2, line2[0][1] + y2], end = [line2[1][0] + x2, line2[1][1] + y2], startIndex = index2(start), endIndex = index2(end), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }
  function index2(point2) {
    return point2[0] * 2 + point2[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values2, value2) {
    ring.forEach((point2) => {
      var x2 = point2[0], y2 = point2[1], xt = x2 | 0, yt = y2 | 0, v0, v1 = values2[yt * dx + xt];
      if (x2 > 0 && x2 < dx && xt === x2) {
        v0 = values2[yt * dx + xt - 1];
        point2[0] = x2 + (value2 - v0) / (v1 - v0) - 0.5;
      }
      if (y2 > 0 && y2 < dy && yt === y2) {
        v0 = values2[(yt - 1) * dx + xt];
        point2[1] = y2 + (value2 - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours2.contour = contour;
  contours2.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
    if (!(_0 >= 0 && _1 >= 0)) error("invalid size");
    return dx = _0, dy = _1, contours2;
  };
  contours2.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop$1, contours2) : smooth === smoothLinear;
  };
  return contours2;
}
function area$1(ring) {
  var i = 0, n = ring.length, area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area2;
}
function contains$1(ring, hole) {
  var i = -1, n = hole.length, c2;
  while (++i < n) if (c2 = ringContains(ring, hole[i])) return c2;
  return 0;
}
function ringContains(ring, point2) {
  var x2 = point2[0], y2 = point2[1], contains2 = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi2 = ring[i], xi = pi2[0], yi = pi2[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi2, pj, point2)) return 0;
    if (yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi) contains2 = -contains2;
  }
  return contains2;
}
function segmentContains(a2, b2, c2) {
  var i;
  return collinear$1(a2, b2, c2) && within(a2[i = +(a2[0] === b2[0])], c2[i], b2[i]);
}
function collinear$1(a2, b2, c2) {
  return (b2[0] - a2[0]) * (c2[1] - a2[1]) === (c2[0] - a2[0]) * (b2[1] - a2[1]);
}
function within(p, q, r2) {
  return p <= q && q <= r2 || r2 <= q && q <= p;
}
function quantize(k, nice2, zero2) {
  return function(values2) {
    var ex = extent(values2), start = zero2 ? Math.min(ex[0], 0) : ex[0], stop3 = ex[1], span2 = stop3 - start, step = nice2 ? tickStep(start, stop3, k) : span2 / (k + 1);
    return range$6(start + step, stop3, step);
  };
}
function Isocontour(params2) {
  Transform.call(this, null, params2);
}
Isocontour.Definition = {
  "type": "Isocontour",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "thresholds",
    "type": "number",
    "array": true
  }, {
    "name": "levels",
    "type": "number"
  }, {
    "name": "nice",
    "type": "boolean",
    "default": false
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "zero",
    "type": "boolean",
    "default": true
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": true
  }, {
    "name": "scale",
    "type": "number",
    "expr": true
  }, {
    "name": "translate",
    "type": "number",
    "array": true,
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "default": "contour"
  }]
};
inherits(Isocontour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source2 = pulse2.materialize(pulse2.SOURCE).source, field2 = _.field || identity$6, contour = contours().smooth(_.smooth !== false), tz = _.thresholds || levels(source2, field2, _), as = _.as === null ? null : _.as || "contour", values2 = [];
    source2.forEach((t4) => {
      const grid = field2(t4);
      const paths = contour.size([grid.width, grid.height])(grid.values, isArray$1(tz) ? tz : tz(grid.values));
      transformPaths(paths, grid, t4, _);
      paths.forEach((p) => {
        values2.push(rederive(t4, ingest$1(as != null ? {
          [as]: p
        } : p)));
      });
    });
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values2;
    return out;
  }
});
function levels(values2, f, _) {
  const q = quantize(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== "shared" ? q : q(values2.map((t4) => max$2(f(t4).values)));
}
function transformPaths(paths, grid, datum2, _) {
  let s = _.scale || grid.scale, t4 = _.translate || grid.translate;
  if (isFunction$3(s)) s = s(datum2, _);
  if (isFunction$3(t4)) t4 = t4(datum2, _);
  if ((s === 1 || s == null) && !t4) return;
  const sx = (isNumber$1(s) ? s : s[0]) || 1, sy = (isNumber$1(s) ? s : s[1]) || 1, tx2 = t4 && t4[0] || 0, ty = t4 && t4[1] || 0;
  paths.forEach(transform$1(grid, sx, sy, tx2, ty));
}
function transform$1(grid, sx, sy, tx2, ty) {
  const x12 = grid.x1 || 0, y12 = grid.y1 || 0, flip2 = sx * sy < 0;
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    if (flip2) coordinates.reverse();
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x12) * sx + tx2;
    coordinates[1] = (coordinates[1] - y12) * sy + ty;
  }
  return function(geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}
function radius(bw, data2, f) {
  const v = bw >= 0 ? bw : estimateBandwidth(data2, f);
  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
}
function number$3(_) {
  return isFunction$3(_) ? _ : constant$5(+_);
}
function density2D() {
  var x2 = (d) => d[0], y2 = (d) => d[1], weight = one$3, bandwidth2 = [-1, -1], dx = 960, dy = 500, k = 2;
  function density(data2, counts) {
    const rx = radius(bandwidth2[0], data2, x2) >> k, ry = radius(bandwidth2[1], data2, y2) >> k, ox = rx ? rx + 2 : 0, oy = ry ? ry + 2 : 0, n = 2 * ox + (dx >> k), m2 = 2 * oy + (dy >> k), values0 = new Float32Array(n * m2), values1 = new Float32Array(n * m2);
    let values2 = values0;
    data2.forEach((d) => {
      const xi = ox + (+x2(d) >> k), yi = oy + (+y2(d) >> k);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m2) {
        values0[xi + yi * n] += +weight(d);
      }
    });
    if (rx > 0 && ry > 0) {
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m2, values0, values1, rx);
      blurX(n, m2, values1, values0, rx);
      blurX(n, m2, values0, values1, rx);
      values2 = values1;
    } else if (ry > 0) {
      blurY(n, m2, values0, values1, ry);
      blurY(n, m2, values1, values0, ry);
      blurY(n, m2, values0, values1, ry);
      values2 = values1;
    }
    const s = counts ? Math.pow(2, -2 * k) : 1 / sum$1(values2);
    for (let i = 0, sz2 = n * m2; i < sz2; ++i) values2[i] *= s;
    return {
      values: values2,
      scale: 1 << k,
      width: n,
      height: m2,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k),
      y2: oy + (dy >> k)
    };
  }
  density.x = function(_) {
    return arguments.length ? (x2 = number$3(_), density) : x2;
  };
  density.y = function(_) {
    return arguments.length ? (y2 = number$3(_), density) : y2;
  };
  density.weight = function(_) {
    return arguments.length ? (weight = number$3(_), density) : weight;
  };
  density.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = +_[0], _1 = +_[1];
    if (!(_0 >= 0 && _1 >= 0)) error("invalid size");
    return dx = _0, dy = _1, density;
  };
  density.cellSize = function(_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) error("invalid cell size");
    k = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };
  density.bandwidth = function(_) {
    if (!arguments.length) return bandwidth2;
    _ = array$5(_);
    if (_.length === 1) _ = [+_[0], +_[0]];
    if (_.length !== 2) error("invalid bandwidth");
    return bandwidth2 = _, density;
  };
  return density;
}
function blurX(n, m2, source2, target2, r2) {
  const w2 = (r2 << 1) + 1;
  for (let j = 0; j < m2; ++j) {
    for (let i = 0, sr = 0; i < n + r2; ++i) {
      if (i < n) {
        sr += source2[i + j * n];
      }
      if (i >= r2) {
        if (i >= w2) {
          sr -= source2[i - w2 + j * n];
        }
        target2[i - r2 + j * n] = sr / Math.min(i + 1, n - 1 + w2 - i, w2);
      }
    }
  }
}
function blurY(n, m2, source2, target2, r2) {
  const w2 = (r2 << 1) + 1;
  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m2 + r2; ++j) {
      if (j < m2) {
        sr += source2[i + j * n];
      }
      if (j >= r2) {
        if (j >= w2) {
          sr -= source2[i + (j - w2) * n];
        }
        target2[i + (j - r2) * n] = sr / Math.min(j + 1, m2 - 1 + w2 - j, w2);
      }
    }
  }
}
function KDE2D(params2) {
  Transform.call(this, null, params2);
}
KDE2D.Definition = {
  "type": "KDE2D",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "weight",
    "type": "field"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "cellSize",
    "type": "number"
  }, {
    "name": "bandwidth",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "counts",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "default": "grid"
  }]
};
const PARAMS = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
function params(obj, _) {
  PARAMS.forEach((param2) => _[param2] != null ? obj[param2](_[param2]) : 0);
  return obj;
}
inherits(KDE2D, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) return pulse2.StopPropagation;
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$2(source2, _.groupby), names = (_.groupby || []).map(accessorName), kde2 = params(density2D(), _), as = _.as || "grid", values2 = [];
    function set2(t4, vals2) {
      for (let i = 0; i < names.length; ++i) t4[names[i]] = vals2[i];
      return t4;
    }
    values2 = groups.map((g) => ingest$1(set2({
      [as]: kde2(g, _.counts)
    }, g.dims)));
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values2;
    return out;
  }
});
function partition$2(data2, groupby) {
  var groups = [], get2 = (f) => f(t4), map2, i, n, t4, k, g;
  if (groupby == null) {
    groups.push(data2);
  } else {
    for (map2 = {}, i = 0, n = data2.length; i < n; ++i) {
      t4 = data2[i];
      k = groupby.map(get2);
      g = map2[k];
      if (!g) {
        map2[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(t4);
    }
  }
  return groups;
}
function Contour(params2) {
  Transform.call(this, null, params2);
}
Contour.Definition = {
  "type": "Contour",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "values",
    "type": "number",
    "array": true
  }, {
    "name": "x",
    "type": "field"
  }, {
    "name": "y",
    "type": "field"
  }, {
    "name": "weight",
    "type": "field"
  }, {
    "name": "cellSize",
    "type": "number"
  }, {
    "name": "bandwidth",
    "type": "number"
  }, {
    "name": "count",
    "type": "number"
  }, {
    "name": "nice",
    "type": "boolean",
    "default": false
  }, {
    "name": "thresholds",
    "type": "number",
    "array": true
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": true
  }]
};
inherits(Contour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), contour = contours().smooth(_.smooth !== false), values2 = _.values, thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values2), size = _.size, grid, post2;
    if (!values2) {
      values2 = pulse2.materialize(pulse2.SOURCE).source;
      grid = params(density2D(), _)(values2, true);
      post2 = transform$1(grid, grid.scale || 1, grid.scale || 1, 0, 0);
      size = [grid.width, grid.height];
      values2 = grid.values;
    }
    thresh = isArray$1(thresh) ? thresh : thresh(values2);
    values2 = contour.size(size)(values2, thresh);
    if (post2) values2.forEach(post2);
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = (values2 || []).map(ingest$1);
    return out;
  }
});
const Feature = "Feature";
const FeatureCollection = "FeatureCollection";
const MultiPoint = "MultiPoint";
function GeoJSON(params2) {
  Transform.call(this, null, params2);
}
GeoJSON.Definition = {
  "type": "GeoJSON",
  "metadata": {},
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "length": 2
  }, {
    "name": "geojson",
    "type": "field"
  }]
};
inherits(GeoJSON, Transform, {
  transform(_, pulse2) {
    var features = this._features, points2 = this._points, fields = _.fields, lon = fields && fields[0], lat = fields && fields[1], geojson = _.geojson || !fields && identity$6, flag2 = pulse2.ADD, mod;
    mod = _.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(geojson)) || lon && pulse2.modified(accessorFields(lon)) || lat && pulse2.modified(accessorFields(lat));
    if (!this.value || mod) {
      flag2 = pulse2.SOURCE;
      this._features = features = [];
      this._points = points2 = [];
    }
    if (geojson) {
      pulse2.visit(flag2, (t4) => features.push(geojson(t4)));
    }
    if (lon && lat) {
      pulse2.visit(flag2, (t4) => {
        var x2 = lon(t4), y2 = lat(t4);
        if (x2 != null && y2 != null && (x2 = +x2) === x2 && (y2 = +y2) === y2) {
          points2.push([x2, y2]);
        }
      });
      features = features.concat({
        type: Feature,
        geometry: {
          type: MultiPoint,
          coordinates: points2
        }
      });
    }
    this.value = {
      type: FeatureCollection,
      features
    };
  }
});
function GeoPath(params2) {
  Transform.call(this, null, params2);
}
GeoPath.Definition = {
  "type": "GeoPath",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "projection",
    "type": "projection"
  }, {
    "name": "field",
    "type": "field"
  }, {
    "name": "pointRadius",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
inherits(GeoPath, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), path2 = this.value, field2 = _.field || identity$6, as = _.as || "path", flag2 = out.SOURCE;
    if (!path2 || _.modified()) {
      this.value = path2 = getProjectionPath(_.projection);
      out.materialize().reflow();
    } else {
      flag2 = field2 === identity$6 || pulse2.modified(field2.fields) ? out.ADD_MOD : out.ADD;
    }
    const prev2 = initPath(path2, _.pointRadius);
    out.visit(flag2, (t4) => t4[as] = path2(field2(t4)));
    path2.pointRadius(prev2);
    return out.modifies(as);
  }
});
function initPath(path2, pointRadius) {
  const prev2 = path2.pointRadius();
  path2.context(null);
  if (pointRadius != null) {
    path2.pointRadius(pointRadius);
  }
  return prev2;
}
function GeoPoint(params2) {
  Transform.call(this, null, params2);
}
GeoPoint.Definition = {
  "type": "GeoPoint",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "projection",
    "type": "projection",
    "required": true
  }, {
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["x", "y"]
  }]
};
inherits(GeoPoint, Transform, {
  transform(_, pulse2) {
    var proj = _.projection, lon = _.fields[0], lat = _.fields[1], as = _.as || ["x", "y"], x2 = as[0], y2 = as[1], mod;
    function set2(t4) {
      const xy = proj([lon(t4), lat(t4)]);
      if (xy) {
        t4[x2] = xy[0];
        t4[y2] = xy[1];
      } else {
        t4[x2] = void 0;
        t4[y2] = void 0;
      }
    }
    if (_.modified()) {
      pulse2 = pulse2.materialize().reflow(true).visit(pulse2.SOURCE, set2);
    } else {
      mod = pulse2.modified(lon.fields) || pulse2.modified(lat.fields);
      pulse2.visit(mod ? pulse2.ADD_MOD : pulse2.ADD, set2);
    }
    return pulse2.modifies(as);
  }
});
function GeoShape(params2) {
  Transform.call(this, null, params2);
}
GeoShape.Definition = {
  "type": "GeoShape",
  "metadata": {
    "modifies": true,
    "nomod": true
  },
  "params": [{
    "name": "projection",
    "type": "projection"
  }, {
    "name": "field",
    "type": "field",
    "default": "datum"
  }, {
    "name": "pointRadius",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "default": "shape"
  }]
};
inherits(GeoShape, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), shape2 = this.value, as = _.as || "shape", flag2 = out.ADD;
    if (!shape2 || _.modified()) {
      this.value = shape2 = shapeGenerator(getProjectionPath(_.projection), _.field || field$1("datum"), _.pointRadius);
      out.materialize().reflow();
      flag2 = out.SOURCE;
    }
    out.visit(flag2, (t4) => t4[as] = shape2);
    return out.modifies(as);
  }
});
function shapeGenerator(path2, field2, pointRadius) {
  const shape2 = pointRadius == null ? (_) => path2(field2(_)) : (_) => {
    var prev2 = path2.pointRadius(), value2 = path2.pointRadius(pointRadius)(field2(_));
    path2.pointRadius(prev2);
    return value2;
  };
  shape2.context = (_) => {
    path2.context(_);
    return shape2;
  };
  return shape2;
}
function Graticule(params2) {
  Transform.call(this, [], params2);
  this.generator = graticule();
}
Graticule.Definition = {
  "type": "Graticule",
  "metadata": {
    "changes": true,
    "generates": true
  },
  "params": [{
    "name": "extent",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "extentMajor",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "extentMinor",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "step",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "stepMajor",
    "type": "number",
    "array": true,
    "length": 2,
    "default": [90, 360]
  }, {
    "name": "stepMinor",
    "type": "number",
    "array": true,
    "length": 2,
    "default": [10, 10]
  }, {
    "name": "precision",
    "type": "number",
    "default": 2.5
  }]
};
inherits(Graticule, Transform, {
  transform(_, pulse2) {
    var src = this.value, gen = this.generator, t4;
    if (!src.length || _.modified()) {
      for (const prop in _) {
        if (isFunction$3(gen[prop])) {
          gen[prop](_[prop]);
        }
      }
    }
    t4 = gen();
    if (src.length) {
      pulse2.mod.push(replace$2(src[0], t4));
    } else {
      pulse2.add.push(ingest$1(t4));
    }
    src[0] = t4;
    return pulse2;
  }
});
function Heatmap(params2) {
  Transform.call(this, null, params2);
}
Heatmap.Definition = {
  "type": "heatmap",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "color",
    "type": "string",
    "expr": true
  }, {
    "name": "opacity",
    "type": "number",
    "expr": true
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "as",
    "type": "string",
    "default": "image"
  }]
};
inherits(Heatmap, Transform, {
  transform(_, pulse2) {
    if (!pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var source2 = pulse2.materialize(pulse2.SOURCE).source, shared = _.resolve === "shared", field2 = _.field || identity$6, opacity2 = opacity_(_.opacity, _), color2 = color_(_.color, _), as = _.as || "image", obj = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: shared ? max$2(source2.map((t4) => max$2(field2(t4).values))) : 0
    };
    source2.forEach((t4) => {
      const v = field2(t4);
      const o = extend$3({}, t4, obj);
      if (!shared) o.$max = max$2(v.values || []);
      t4[as] = toCanvas(v, o, color2.dep ? color2 : constant$5(color2(o)), opacity2.dep ? opacity2 : constant$5(opacity2(o)));
    });
    return pulse2.reflow(true).modifies(as);
  }
});
function color_(color2, _) {
  let f;
  if (isFunction$3(color2)) {
    f = (obj) => rgb$3(color2(obj, _));
    f.dep = dependency(color2);
  } else {
    f = constant$5(rgb$3(color2 || "#888"));
  }
  return f;
}
function opacity_(opacity2, _) {
  let f;
  if (isFunction$3(opacity2)) {
    f = (obj) => opacity2(obj, _);
    f.dep = dependency(opacity2);
  } else if (opacity2) {
    f = constant$5(opacity2);
  } else {
    f = (obj) => obj.$value / obj.$max || 0;
    f.dep = true;
  }
  return f;
}
function dependency(f) {
  if (!isFunction$3(f)) return false;
  const set2 = toSet(accessorFields(f));
  return set2.$x || set2.$y || set2.$value || set2.$max;
}
function toCanvas(grid, obj, color2, opacity2) {
  const n = grid.width, m2 = grid.height, x12 = grid.x1 || 0, y12 = grid.y1 || 0, x2 = grid.x2 || n, y2 = grid.y2 || m2, val = grid.values, value2 = val ? (i) => val[i] : zero$5, can = domCanvas(x2 - x12, y2 - y12), ctx = can.getContext("2d"), img = ctx.getImageData(0, 0, x2 - x12, y2 - y12), pix = img.data;
  for (let j = y12, k = 0; j < y2; ++j) {
    obj.$y = j - y12;
    for (let i = x12, r2 = j * n; i < x2; ++i, k += 4) {
      obj.$x = i - x12;
      obj.$value = value2(i + r2);
      const v = color2(obj);
      pix[k + 0] = v.r;
      pix[k + 1] = v.g;
      pix[k + 2] = v.b;
      pix[k + 3] = ~~(255 * opacity2(obj));
    }
  }
  ctx.putImageData(img, 0, 0);
  return can;
}
function Projection$1(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Projection$1, Transform, {
  transform(_, pulse2) {
    let proj = this.value;
    if (!proj || _.modified("type")) {
      this.value = proj = create(_.type);
      projectionProperties.forEach((prop) => {
        if (_[prop] != null) set$3(proj, prop, _[prop]);
      });
    } else {
      projectionProperties.forEach((prop) => {
        if (_.modified(prop)) set$3(proj, prop, _[prop]);
      });
    }
    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);
    if (_.fit) fit(proj, _);
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function fit(proj, _) {
  const data2 = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data2) : _.size ? proj.fitSize(_.size, data2) : 0;
}
function create(type2) {
  const constructor = projection((type2 || "mercator").toLowerCase());
  if (!constructor) error("Unrecognized projection type: " + type2);
  return constructor();
}
function set$3(proj, key2, value2) {
  if (isFunction$3(proj[key2])) proj[key2](value2);
}
function collectGeoJSON(data2) {
  data2 = array$5(data2);
  return data2.length === 1 ? data2[0] : {
    type: FeatureCollection,
    features: data2.reduce((a2, f) => a2.concat(featurize(f)), [])
  };
}
function featurize(f) {
  return f.type === FeatureCollection ? f.features : array$5(f).filter((d) => d != null).map((d) => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}
const geo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contour: Contour,
  geojson: GeoJSON,
  geopath: GeoPath,
  geopoint: GeoPoint,
  geoshape: GeoShape,
  graticule: Graticule,
  heatmap: Heatmap,
  isocontour: Isocontour,
  kde2d: KDE2D,
  projection: Projection$1
}, Symbol.toStringTag, { value: "Module" }));
function forceCenter(x2, y2) {
  var nodes, strength = 1;
  if (x2 == null) x2 = 0;
  if (y2 == null) y2 = 0;
  function force2() {
    var i, n = nodes.length, node2, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node2 = nodes[i], sx += node2.x, sy += node2.y;
    }
    for (sx = (sx / n - x2) * strength, sy = (sy / n - y2) * strength, i = 0; i < n; ++i) {
      node2 = nodes[i], node2.x -= sx, node2.y -= sy;
    }
  }
  force2.initialize = function(_) {
    nodes = _;
  };
  force2.x = function(_) {
    return arguments.length ? (x2 = +_, force2) : x2;
  };
  force2.y = function(_) {
    return arguments.length ? (y2 = +_, force2) : y2;
  };
  force2.strength = function(_) {
    return arguments.length ? (strength = +_, force2) : strength;
  };
  return force2;
}
function tree_add(d) {
  const x2 = +this._x.call(null, d), y2 = +this._y.call(null, d);
  return add$1(this.cover(x2, y2), x2, y2, d);
}
function add$1(tree2, x2, y2, d) {
  if (isNaN(x2) || isNaN(y2)) return tree2;
  var parent, node2 = tree2._root, leaf = { data: d }, x02 = tree2._x0, y02 = tree2._y0, x12 = tree2._x1, y12 = tree2._y1, xm, ym, xp, yp, right, bottom, i, j;
  if (!node2) return tree2._root = leaf, tree2;
  while (node2.length) {
    if (right = x2 >= (xm = (x02 + x12) / 2)) x02 = xm;
    else x12 = xm;
    if (bottom = y2 >= (ym = (y02 + y12) / 2)) y02 = ym;
    else y12 = ym;
    if (parent = node2, !(node2 = node2[i = bottom << 1 | right])) return parent[i] = leaf, tree2;
  }
  xp = +tree2._x.call(null, node2.data);
  yp = +tree2._y.call(null, node2.data);
  if (x2 === xp && y2 === yp) return leaf.next = node2, parent ? parent[i] = leaf : tree2._root = leaf, tree2;
  do {
    parent = parent ? parent[i] = new Array(4) : tree2._root = new Array(4);
    if (right = x2 >= (xm = (x02 + x12) / 2)) x02 = xm;
    else x12 = xm;
    if (bottom = y2 >= (ym = (y02 + y12) / 2)) y02 = ym;
    else y12 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node2, parent[i] = leaf, tree2;
}
function addAll(data2) {
  var d, i, n = data2.length, x2, y2, xz = new Array(n), yz = new Array(n), x02 = Infinity, y02 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x2 = +this._x.call(null, d = data2[i])) || isNaN(y2 = +this._y.call(null, d))) continue;
    xz[i] = x2;
    yz[i] = y2;
    if (x2 < x02) x02 = x2;
    if (x2 > x12) x12 = x2;
    if (y2 < y02) y02 = y2;
    if (y2 > y12) y12 = y2;
  }
  if (x02 > x12 || y02 > y12) return this;
  this.cover(x02, y02).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add$1(this, xz[i], yz[i], data2[i]);
  }
  return this;
}
function tree_cover(x2, y2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2)) return this;
  var x02 = this._x0, y02 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x02)) {
    x12 = (x02 = Math.floor(x2)) + 1;
    y12 = (y02 = Math.floor(y2)) + 1;
  } else {
    var z2 = x12 - x02 || 1, node2 = this._root, parent, i;
    while (x02 > x2 || x2 >= x12 || y02 > y2 || y2 >= y12) {
      i = (y2 < y02) << 1 | x2 < x02;
      parent = new Array(4), parent[i] = node2, node2 = parent, z2 *= 2;
      switch (i) {
        case 0:
          x12 = x02 + z2, y12 = y02 + z2;
          break;
        case 1:
          x02 = x12 - z2, y12 = y02 + z2;
          break;
        case 2:
          x12 = x02 + z2, y02 = y12 - z2;
          break;
        case 3:
          x02 = x12 - z2, y02 = y12 - z2;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node2;
  }
  this._x0 = x02;
  this._y0 = y02;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}
function tree_data() {
  var data2 = [];
  this.visit(function(node2) {
    if (!node2.length) do
      data2.push(node2.data);
    while (node2 = node2.next);
  });
  return data2;
}
function tree_extent(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function Quad(node2, x02, y02, x12, y12) {
  this.node = node2;
  this.x0 = x02;
  this.y0 = y02;
  this.x1 = x12;
  this.y1 = y12;
}
function tree_find(x2, y2, radius2) {
  var data2, x02 = this._x0, y02 = this._y0, x12, y12, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node2 = this._root, q, i;
  if (node2) quads.push(new Quad(node2, x02, y02, x3, y3));
  if (radius2 == null) radius2 = Infinity;
  else {
    x02 = x2 - radius2, y02 = y2 - radius2;
    x3 = x2 + radius2, y3 = y2 + radius2;
    radius2 *= radius2;
  }
  while (q = quads.pop()) {
    if (!(node2 = q.node) || (x12 = q.x0) > x3 || (y12 = q.y0) > y3 || (x22 = q.x1) < x02 || (y22 = q.y1) < y02) continue;
    if (node2.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(
        new Quad(node2[3], xm, ym, x22, y22),
        new Quad(node2[2], x12, ym, xm, y22),
        new Quad(node2[1], xm, y12, x22, ym),
        new Quad(node2[0], x12, y12, xm, ym)
      );
      if (i = (y2 >= ym) << 1 | x2 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x2 - +this._x.call(null, node2.data), dy = y2 - +this._y.call(null, node2.data), d2 = dx * dx + dy * dy;
      if (d2 < radius2) {
        var d = Math.sqrt(radius2 = d2);
        x02 = x2 - d, y02 = y2 - d;
        x3 = x2 + d, y3 = y2 + d;
        data2 = node2.data;
      }
    }
  }
  return data2;
}
function tree_remove(d) {
  if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, d))) return this;
  var parent, node2 = this._root, retainer, previous, next2, x02 = this._x0, y02 = this._y0, x12 = this._x1, y12 = this._y1, x2, y2, xm, ym, right, bottom, i, j;
  if (!node2) return this;
  if (node2.length) while (true) {
    if (right = x2 >= (xm = (x02 + x12) / 2)) x02 = xm;
    else x12 = xm;
    if (bottom = y2 >= (ym = (y02 + y12) / 2)) y02 = ym;
    else y12 = ym;
    if (!(parent = node2, node2 = node2[i = bottom << 1 | right])) return this;
    if (!node2.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  }
  while (node2.data !== d) if (!(previous = node2, node2 = node2.next)) return this;
  if (next2 = node2.next) delete node2.next;
  if (previous) return next2 ? previous.next = next2 : delete previous.next, this;
  if (!parent) return this._root = next2, this;
  next2 ? parent[i] = next2 : delete parent[i];
  if ((node2 = parent[0] || parent[1] || parent[2] || parent[3]) && node2 === (parent[3] || parent[2] || parent[1] || parent[0]) && !node2.length) {
    if (retainer) retainer[j] = node2;
    else this._root = node2;
  }
  return this;
}
function removeAll(data2) {
  for (var i = 0, n = data2.length; i < n; ++i) this.remove(data2[i]);
  return this;
}
function tree_root() {
  return this._root;
}
function tree_size() {
  var size = 0;
  this.visit(function(node2) {
    if (!node2.length) do
      ++size;
    while (node2 = node2.next);
  });
  return size;
}
function tree_visit(callback) {
  var quads = [], q, node2 = this._root, child, x02, y02, x12, y12;
  if (node2) quads.push(new Quad(node2, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node2 = q.node, x02 = q.x0, y02 = q.y0, x12 = q.x1, y12 = q.y1) && node2.length) {
      var xm = (x02 + x12) / 2, ym = (y02 + y12) / 2;
      if (child = node2[3]) quads.push(new Quad(child, xm, ym, x12, y12));
      if (child = node2[2]) quads.push(new Quad(child, x02, ym, xm, y12));
      if (child = node2[1]) quads.push(new Quad(child, xm, y02, x12, ym));
      if (child = node2[0]) quads.push(new Quad(child, x02, y02, xm, ym));
    }
  }
  return this;
}
function tree_visitAfter(callback) {
  var quads = [], next2 = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node2 = q.node;
    if (node2.length) {
      var child, x02 = q.x0, y02 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x02 + x12) / 2, ym = (y02 + y12) / 2;
      if (child = node2[0]) quads.push(new Quad(child, x02, y02, xm, ym));
      if (child = node2[1]) quads.push(new Quad(child, xm, y02, x12, ym));
      if (child = node2[2]) quads.push(new Quad(child, x02, ym, xm, y12));
      if (child = node2[3]) quads.push(new Quad(child, xm, ym, x12, y12));
    }
    next2.push(q);
  }
  while (q = next2.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}
function defaultX(d) {
  return d[0];
}
function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}
function defaultY(d) {
  return d[1];
}
function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}
function quadtree(nodes, x2, y2) {
  var tree2 = new Quadtree(x2 == null ? defaultX : x2, y2 == null ? defaultY : y2, NaN, NaN, NaN, NaN);
  return nodes == null ? tree2 : tree2.addAll(nodes);
}
function Quadtree(x2, y2, x02, y02, x12, y12) {
  this._x = x2;
  this._y = y2;
  this._x0 = x02;
  this._y0 = y02;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy2 = { data: leaf.data }, next2 = copy2;
  while (leaf = leaf.next) next2 = next2.next = { data: leaf.data };
  return copy2;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node2 = this._root, nodes, child;
  if (!node2) return copy2;
  if (!node2.length) return copy2._root = leaf_copy(node2), copy2;
  nodes = [{ source: node2, target: copy2._root = new Array(4) }];
  while (node2 = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node2.source[i]) {
        if (child.length) nodes.push({ source: child, target: node2.target[i] = new Array(4) });
        else node2.target[i] = leaf_copy(child);
      }
    }
  }
  return copy2;
};
treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;
function constant$2(x2) {
  return function() {
    return x2;
  };
}
function jiggle(random2) {
  return (random2() - 0.5) * 1e-6;
}
function x$1(d) {
  return d.x + d.vx;
}
function y$1(d) {
  return d.y + d.vy;
}
function forceCollide(radius2) {
  var nodes, radii, random2, strength = 1, iterations2 = 1;
  if (typeof radius2 !== "function") radius2 = constant$2(radius2 == null ? 1 : +radius2);
  function force2() {
    var i, n = nodes.length, tree2, node2, xi, yi, ri, ri2;
    for (var k = 0; k < iterations2; ++k) {
      tree2 = quadtree(nodes, x$1, y$1).visitAfter(prepare2);
      for (i = 0; i < n; ++i) {
        node2 = nodes[i];
        ri = radii[node2.index], ri2 = ri * ri;
        xi = node2.x + node2.vx;
        yi = node2.y + node2.vy;
        tree2.visit(apply2);
      }
    }
    function apply2(quad2, x02, y02, x12, y12) {
      var data2 = quad2.data, rj = quad2.r, r2 = ri + rj;
      if (data2) {
        if (data2.index > node2.index) {
          var x2 = xi - data2.x - data2.vx, y2 = yi - data2.y - data2.vy, l = x2 * x2 + y2 * y2;
          if (l < r2 * r2) {
            if (x2 === 0) x2 = jiggle(random2), l += x2 * x2;
            if (y2 === 0) y2 = jiggle(random2), l += y2 * y2;
            l = (r2 - (l = Math.sqrt(l))) / l * strength;
            node2.vx += (x2 *= l) * (r2 = (rj *= rj) / (ri2 + rj));
            node2.vy += (y2 *= l) * r2;
            data2.vx -= x2 * (r2 = 1 - r2);
            data2.vy -= y2 * r2;
          }
        }
        return;
      }
      return x02 > xi + r2 || x12 < xi - r2 || y02 > yi + r2 || y12 < yi - r2;
    }
  }
  function prepare2(quad2) {
    if (quad2.data) return quad2.r = radii[quad2.data.index];
    for (var i = quad2.r = 0; i < 4; ++i) {
      if (quad2[i] && quad2[i].r > quad2.r) {
        quad2.r = quad2[i].r;
      }
    }
  }
  function initialize2() {
    if (!nodes) return;
    var i, n = nodes.length, node2;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node2 = nodes[i], radii[node2.index] = +radius2(node2, i, nodes);
  }
  force2.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize2();
  };
  force2.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force2) : iterations2;
  };
  force2.strength = function(_) {
    return arguments.length ? (strength = +_, force2) : strength;
  };
  force2.radius = function(_) {
    return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant$2(+_), initialize2(), force2) : radius2;
  };
  return force2;
}
function index$1(d) {
  return d.index;
}
function find$2(nodeById, nodeId) {
  var node2 = nodeById.get(nodeId);
  if (!node2) throw new Error("node not found: " + nodeId);
  return node2;
}
function forceLink(links) {
  var id2 = index$1, strength = defaultStrength, strengths, distance = constant$2(30), distances, nodes, count2, bias, random2, iterations2 = 1;
  if (links == null) links = [];
  function defaultStrength(link2) {
    return 1 / Math.min(count2[link2.source.index], count2[link2.target.index]);
  }
  function force2(alpha2) {
    for (var k = 0, n = links.length; k < iterations2; ++k) {
      for (var i = 0, link2, source2, target2, x2, y2, l, b2; i < n; ++i) {
        link2 = links[i], source2 = link2.source, target2 = link2.target;
        x2 = target2.x + target2.vx - source2.x - source2.vx || jiggle(random2);
        y2 = target2.y + target2.vy - source2.y - source2.vy || jiggle(random2);
        l = Math.sqrt(x2 * x2 + y2 * y2);
        l = (l - distances[i]) / l * alpha2 * strengths[i];
        x2 *= l, y2 *= l;
        target2.vx -= x2 * (b2 = bias[i]);
        target2.vy -= y2 * b2;
        source2.vx += x2 * (b2 = 1 - b2);
        source2.vy += y2 * b2;
      }
    }
  }
  function initialize2() {
    if (!nodes) return;
    var i, n = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link2;
    for (i = 0, count2 = new Array(n); i < m2; ++i) {
      link2 = links[i], link2.index = i;
      if (typeof link2.source !== "object") link2.source = find$2(nodeById, link2.source);
      if (typeof link2.target !== "object") link2.target = find$2(nodeById, link2.target);
      count2[link2.source.index] = (count2[link2.source.index] || 0) + 1;
      count2[link2.target.index] = (count2[link2.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m2); i < m2; ++i) {
      link2 = links[i], bias[i] = count2[link2.source.index] / (count2[link2.source.index] + count2[link2.target.index]);
    }
    strengths = new Array(m2), initializeStrength();
    distances = new Array(m2), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes) return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes) return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }
  force2.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize2();
  };
  force2.links = function(_) {
    return arguments.length ? (links = _, initialize2(), force2) : links;
  };
  force2.id = function(_) {
    return arguments.length ? (id2 = _, force2) : id2;
  };
  force2.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force2) : iterations2;
  };
  force2.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initializeStrength(), force2) : strength;
  };
  force2.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant$2(+_), initializeDistance(), force2) : distance;
  };
  return force2;
}
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t4; i < n; ++i) {
    if (!(t4 = arguments[i] + "") || t4 in _ || /[\s.]/.test(t4)) throw new Error("illegal type: " + t4);
    _[t4] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name = "", i = t4.indexOf(".");
    if (i >= 0) name = t4.slice(i + 1), t4 = t4.slice(0, i);
    if (t4 && !types.hasOwnProperty(t4)) throw new Error("unknown type: " + t4);
    return { type: t4, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t4, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t4 = (typename = T[i]).type) && (t4 = get$1(_[t4], typename.name))) return t4;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t4 = (typename = T[i]).type) _[t4] = set$2(_[t4], typename.name, callback);
      else if (callback == null) for (t4 in _) _[t4] = set$2(_[t4], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t4 in _) copy2[t4] = _[t4].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t4; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
    for (t4 = this._[type2], i = 0, n = t4.length; i < n; ++i) t4[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
    for (var t4 = this._[type2], i = 0, n = t4.length; i < n; ++i) t4[i].value.apply(that, args);
  }
};
function get$1(type2, name) {
  for (var i = 0, n = type2.length, c2; i < n; ++i) {
    if ((c2 = type2[i]).name === name) {
      return c2.value;
    }
  }
}
function set$2(type2, name, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null) type2.push({ name, value: callback });
  return type2;
}
var frame = 0, timeout = 0, interval$2 = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer$1() {
  this._call = this._time = this._next = null;
}
Timer$1.prototype = timer$1.prototype = {
  constructor: Timer$1,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer$1(callback, delay, time2) {
  var t4 = new Timer$1();
  t4.restart(callback, delay, time2);
  return t4;
}
function timerFlush() {
  now();
  ++frame;
  var t4 = taskHead, e3;
  while (t4) {
    if ((e3 = clockNow - t4._time) >= 0) t4._call.call(void 0, e3);
    t4 = t4._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time2 = Infinity;
  while (t12) {
    if (t12._call) {
      if (time2 > t12._time) time2 = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time2);
}
function sleep(time2) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity) timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval$2) interval$2 = clearInterval(interval$2);
  } else {
    if (!interval$2) clockLast = clock.now(), interval$2 = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function interval$1(callback, delay, time2) {
  var t4 = new Timer$1(), total = delay;
  if (delay == null) return t4.restart(callback, delay, time2), t4;
  t4._restart = t4.restart;
  t4.restart = function(callback2, delay2, time22) {
    delay2 = +delay2, time22 = time22 == null ? now() : +time22;
    t4._restart(function tick2(elapsed) {
      elapsed += total;
      t4._restart(tick2, total += delay2, time22);
      callback2(elapsed);
    }, delay2, time22);
  };
  t4.restart(callback, delay, time2);
  return t4;
}
const a$1 = 1664525;
const c$1 = 1013904223;
const m$1 = 4294967296;
function lcg$1() {
  let s = 1;
  return () => (s = (a$1 * s + c$1) % m$1) / m$1;
}
function x(d) {
  return d.x;
}
function y(d) {
  return d.y;
}
var initialRadius = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
function forceSimulation(nodes) {
  var simulation2, alpha2 = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer$1(step), event2 = dispatch("tick", "end"), random2 = lcg$1();
  if (nodes == null) nodes = [];
  function step() {
    tick2();
    event2.call("tick", simulation2);
    if (alpha2 < alphaMin) {
      stepper.stop();
      event2.call("end", simulation2);
    }
  }
  function tick2(iterations2) {
    var i, n = nodes.length, node2;
    if (iterations2 === void 0) iterations2 = 1;
    for (var k = 0; k < iterations2; ++k) {
      alpha2 += (alphaTarget - alpha2) * alphaDecay;
      forces.forEach(function(force2) {
        force2(alpha2);
      });
      for (i = 0; i < n; ++i) {
        node2 = nodes[i];
        if (node2.fx == null) node2.x += node2.vx *= velocityDecay;
        else node2.x = node2.fx, node2.vx = 0;
        if (node2.fy == null) node2.y += node2.vy *= velocityDecay;
        else node2.y = node2.fy, node2.vy = 0;
      }
    }
    return simulation2;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node2; i < n; ++i) {
      node2 = nodes[i], node2.index = i;
      if (node2.fx != null) node2.x = node2.fx;
      if (node2.fy != null) node2.y = node2.fy;
      if (isNaN(node2.x) || isNaN(node2.y)) {
        var radius2 = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;
        node2.x = radius2 * Math.cos(angle2);
        node2.y = radius2 * Math.sin(angle2);
      }
      if (isNaN(node2.vx) || isNaN(node2.vy)) {
        node2.vx = node2.vy = 0;
      }
    }
  }
  function initializeForce(force2) {
    if (force2.initialize) force2.initialize(nodes, random2);
    return force2;
  }
  initializeNodes();
  return simulation2 = {
    tick: tick2,
    restart: function() {
      return stepper.restart(step), simulation2;
    },
    stop: function() {
      return stepper.stop(), simulation2;
    },
    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation2) : nodes;
    },
    alpha: function(_) {
      return arguments.length ? (alpha2 = +_, simulation2) : alpha2;
    },
    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation2) : alphaMin;
    },
    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation2) : +alphaDecay;
    },
    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation2) : alphaTarget;
    },
    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation2) : 1 - velocityDecay;
    },
    randomSource: function(_) {
      return arguments.length ? (random2 = _, forces.forEach(initializeForce), simulation2) : random2;
    },
    force: function(name, _) {
      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation2) : forces.get(name);
    },
    find: function(x2, y2, radius2) {
      var i = 0, n = nodes.length, dx, dy, d2, node2, closest;
      if (radius2 == null) radius2 = Infinity;
      else radius2 *= radius2;
      for (i = 0; i < n; ++i) {
        node2 = nodes[i];
        dx = x2 - node2.x;
        dy = y2 - node2.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius2) closest = node2, radius2 = d2;
      }
      return closest;
    },
    on: function(name, _) {
      return arguments.length > 1 ? (event2.on(name, _), simulation2) : event2.on(name);
    }
  };
}
function forceManyBody() {
  var nodes, node2, random2, alpha2, strength = constant$2(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force2(_) {
    var i, n = nodes.length, tree2 = quadtree(nodes, x, y).visitAfter(accumulate);
    for (alpha2 = _, i = 0; i < n; ++i) node2 = nodes[i], tree2.visit(apply2);
  }
  function initialize2() {
    if (!nodes) return;
    var i, n = nodes.length, node22;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node22 = nodes[i], strengths[node22.index] = +strength(node22, i, nodes);
  }
  function accumulate(quad2) {
    var strength2 = 0, q, c2, weight = 0, x2, y2, i;
    if (quad2.length) {
      for (x2 = y2 = i = 0; i < 4; ++i) {
        if ((q = quad2[i]) && (c2 = Math.abs(q.value))) {
          strength2 += q.value, weight += c2, x2 += c2 * q.x, y2 += c2 * q.y;
        }
      }
      quad2.x = x2 / weight;
      quad2.y = y2 / weight;
    } else {
      q = quad2;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad2.value = strength2;
  }
  function apply2(quad2, x12, _, x2) {
    if (!quad2.value) return true;
    var x3 = quad2.x - node2.x, y2 = quad2.y - node2.y, w2 = x2 - x12, l = x3 * x3 + y2 * y2;
    if (w2 * w2 / theta2 < l) {
      if (l < distanceMax2) {
        if (x3 === 0) x3 = jiggle(random2), l += x3 * x3;
        if (y2 === 0) y2 = jiggle(random2), l += y2 * y2;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node2.vx += x3 * quad2.value * alpha2 / l;
        node2.vy += y2 * quad2.value * alpha2 / l;
      }
      return true;
    } else if (quad2.length || l >= distanceMax2) return;
    if (quad2.data !== node2 || quad2.next) {
      if (x3 === 0) x3 = jiggle(random2), l += x3 * x3;
      if (y2 === 0) y2 = jiggle(random2), l += y2 * y2;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad2.data !== node2) {
        w2 = strengths[quad2.data.index] * alpha2 / l;
        node2.vx += x3 * w2;
        node2.vy += y2 * w2;
      }
    while (quad2 = quad2.next);
  }
  force2.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize2();
  };
  force2.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize2(), force2) : strength;
  };
  force2.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force2) : Math.sqrt(distanceMin2);
  };
  force2.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force2) : Math.sqrt(distanceMax2);
  };
  force2.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force2) : Math.sqrt(theta2);
  };
  return force2;
}
function forceX(x2) {
  var strength = constant$2(0.1), nodes, strengths, xz;
  if (typeof x2 !== "function") x2 = constant$2(x2 == null ? 0 : +x2);
  function force2(alpha2) {
    for (var i = 0, n = nodes.length, node2; i < n; ++i) {
      node2 = nodes[i], node2.vx += (xz[i] - node2.x) * strengths[i] * alpha2;
    }
  }
  function initialize2() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force2.initialize = function(_) {
    nodes = _;
    initialize2();
  };
  force2.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize2(), force2) : strength;
  };
  force2.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant$2(+_), initialize2(), force2) : x2;
  };
  return force2;
}
function forceY(y2) {
  var strength = constant$2(0.1), nodes, strengths, yz;
  if (typeof y2 !== "function") y2 = constant$2(y2 == null ? 0 : +y2);
  function force2(alpha2) {
    for (var i = 0, n = nodes.length, node2; i < n; ++i) {
      node2 = nodes[i], node2.vy += (yz[i] - node2.y) * strengths[i] * alpha2;
    }
  }
  function initialize2() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force2.initialize = function(_) {
    nodes = _;
    initialize2();
  };
  force2.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize2(), force2) : strength;
  };
  force2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant$2(+_), initialize2(), force2) : y2;
  };
  return force2;
}
const ForceMap = {
  center: forceCenter,
  collide: forceCollide,
  nbody: forceManyBody,
  link: forceLink,
  x: forceX,
  y: forceY
};
const Forces = "forces", ForceParams = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"], ForceConfig = ["static", "iterations"], ForceOutput = ["x", "y", "vx", "vy"];
function Force(params2) {
  Transform.call(this, null, params2);
}
Force.Definition = {
  "type": "Force",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "static",
    "type": "boolean",
    "default": false
  }, {
    "name": "restart",
    "type": "boolean",
    "default": false
  }, {
    "name": "iterations",
    "type": "number",
    "default": 300
  }, {
    "name": "alpha",
    "type": "number",
    "default": 1
  }, {
    "name": "alphaMin",
    "type": "number",
    "default": 1e-3
  }, {
    "name": "alphaTarget",
    "type": "number",
    "default": 0
  }, {
    "name": "velocityDecay",
    "type": "number",
    "default": 0.4
  }, {
    "name": "forces",
    "type": "param",
    "array": true,
    "params": [{
      "key": {
        "force": "center"
      },
      "params": [{
        "name": "x",
        "type": "number",
        "default": 0
      }, {
        "name": "y",
        "type": "number",
        "default": 0
      }]
    }, {
      "key": {
        "force": "collide"
      },
      "params": [{
        "name": "radius",
        "type": "number",
        "expr": true
      }, {
        "name": "strength",
        "type": "number",
        "default": 0.7
      }, {
        "name": "iterations",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "force": "nbody"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": -30
      }, {
        "name": "theta",
        "type": "number",
        "default": 0.9
      }, {
        "name": "distanceMin",
        "type": "number",
        "default": 1
      }, {
        "name": "distanceMax",
        "type": "number"
      }]
    }, {
      "key": {
        "force": "link"
      },
      "params": [{
        "name": "links",
        "type": "data"
      }, {
        "name": "id",
        "type": "field"
      }, {
        "name": "distance",
        "type": "number",
        "default": 30,
        "expr": true
      }, {
        "name": "strength",
        "type": "number",
        "expr": true
      }, {
        "name": "iterations",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "force": "x"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": 0.1
      }, {
        "name": "x",
        "type": "field"
      }]
    }, {
      "key": {
        "force": "y"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": 0.1
      }, {
        "name": "y",
        "type": "field"
      }]
    }]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "modify": false,
    "default": ForceOutput
  }]
};
inherits(Force, Transform, {
  transform(_, pulse2) {
    var sim = this.value, change2 = pulse2.changed(pulse2.ADD_REM), params2 = _.modified(ForceParams), iters = _.iterations || 300;
    if (!sim) {
      this.value = sim = simulation(pulse2.source, _);
      sim.on("tick", rerun(pulse2.dataflow, this));
      if (!_.static) {
        change2 = true;
        sim.tick();
      }
      pulse2.modifies("index");
    } else {
      if (change2) {
        pulse2.modifies("index");
        sim.nodes(pulse2.source);
      }
      if (params2 || pulse2.changed(pulse2.MOD)) {
        setup(sim, _, 0, pulse2);
      }
    }
    if (params2 || change2 || _.modified(ForceConfig) || pulse2.changed() && _.restart) {
      sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));
      if (_.static) {
        for (sim.stop(); --iters >= 0; ) sim.tick();
      } else {
        if (sim.stopped()) sim.restart();
        if (!change2) return pulse2.StopPropagation;
      }
    }
    return this.finish(_, pulse2);
  },
  finish(_, pulse2) {
    const dataflow = pulse2.dataflow;
    for (let args = this._argops, j = 0, m2 = args.length, arg; j < m2; ++j) {
      arg = args[j];
      if (arg.name !== Forces || arg.op._argval.force !== "link") {
        continue;
      }
      for (var ops2 = arg.op._argops, i = 0, n = ops2.length, op; i < n; ++i) {
        if (ops2[i].name === "links" && (op = ops2[i].op.source)) {
          dataflow.pulse(op, dataflow.changeset().reflow());
          break;
        }
      }
    }
    return pulse2.reflow(_.modified()).modifies(ForceOutput);
  }
});
function rerun(df, op) {
  return () => df.touch(op).run();
}
function simulation(nodes, _) {
  const sim = forceSimulation(nodes), stop3 = sim.stop, restart = sim.restart;
  let stopped = false;
  sim.stopped = () => stopped;
  sim.restart = () => (stopped = false, restart());
  sim.stop = () => (stopped = true, stop3());
  return setup(sim, _, true).on("end", () => stopped = true);
}
function setup(sim, _, init2, pulse2) {
  var f = array$5(_.forces), i, n, p, name;
  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p)) sim[p](_[p]);
  }
  for (i = 0, n = f.length; i < n; ++i) {
    name = Forces + i;
    p = init2 || _.modified(Forces, i) ? getForce(f[i]) : pulse2 && modified(f[i], pulse2) ? sim.force(name) : null;
    if (p) sim.force(name, p);
  }
  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null);
  }
  sim.numForces = f.length;
  return sim;
}
function modified(f, pulse2) {
  var k, v;
  for (k in f) {
    if (isFunction$3(v = f[k]) && pulse2.modified(accessorFields(v))) return 1;
  }
  return 0;
}
function getForce(_) {
  var f, p;
  if (!has$2(ForceMap, _.force)) {
    error("Unrecognized force: " + _.force);
  }
  f = ForceMap[_.force]();
  for (p in _) {
    if (isFunction$3(f[p])) setForceParam(f[p], _[p], _);
  }
  return f;
}
function setForceParam(f, v, _) {
  f(isFunction$3(v) ? (d) => v(d, _) : v);
}
const force = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  force: Force
}, Symbol.toStringTag, { value: "Module" }));
function defaultSeparation$2(a2, b2) {
  return a2.parent === b2.parent ? 1 : 2;
}
function meanX(children2) {
  return children2.reduce(meanXReduce, 0) / children2.length;
}
function meanXReduce(x2, c2) {
  return x2 + c2.x;
}
function maxY(children2) {
  return 1 + children2.reduce(maxYReduce, 0);
}
function maxYReduce(y2, c2) {
  return Math.max(y2, c2.y);
}
function leafLeft(node2) {
  var children2;
  while (children2 = node2.children) node2 = children2[0];
  return node2;
}
function leafRight(node2) {
  var children2;
  while (children2 = node2.children) node2 = children2[children2.length - 1];
  return node2;
}
function cluster() {
  var separation = defaultSeparation$2, dx = 1, dy = 1, nodeSize = false;
  function cluster2(root2) {
    var previousNode, x2 = 0;
    root2.eachAfter(function(node2) {
      var children2 = node2.children;
      if (children2) {
        node2.x = meanX(children2);
        node2.y = maxY(children2);
      } else {
        node2.x = previousNode ? x2 += separation(node2, previousNode) : 0;
        node2.y = 0;
        previousNode = node2;
      }
    });
    var left = leafLeft(root2), right = leafRight(root2), x02 = left.x - separation(left, right) / 2, x12 = right.x + separation(right, left) / 2;
    return root2.eachAfter(nodeSize ? function(node2) {
      node2.x = (node2.x - root2.x) * dx;
      node2.y = (root2.y - node2.y) * dy;
    } : function(node2) {
      node2.x = (node2.x - x02) / (x12 - x02) * dx;
      node2.y = (1 - (root2.y ? node2.y / root2.y : 1)) * dy;
    });
  }
  cluster2.separation = function(x2) {
    return arguments.length ? (separation = x2, cluster2) : separation;
  };
  cluster2.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? null : [dx, dy];
  };
  cluster2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? [dx, dy] : null;
  };
  return cluster2;
}
function count(node2) {
  var sum2 = 0, children2 = node2.children, i = children2 && children2.length;
  if (!i) sum2 = 1;
  else while (--i >= 0) sum2 += children2[i].value;
  node2.value = sum2;
}
function node_count() {
  return this.eachAfter(count);
}
function node_each(callback, that) {
  let index2 = -1;
  for (const node2 of this) {
    callback.call(that, node2, ++index2, this);
  }
  return this;
}
function node_eachBefore(callback, that) {
  var node2 = this, nodes = [node2], children2, i, index2 = -1;
  while (node2 = nodes.pop()) {
    callback.call(that, node2, ++index2, this);
    if (children2 = node2.children) {
      for (i = children2.length - 1; i >= 0; --i) {
        nodes.push(children2[i]);
      }
    }
  }
  return this;
}
function node_eachAfter(callback, that) {
  var node2 = this, nodes = [node2], next2 = [], children2, i, n, index2 = -1;
  while (node2 = nodes.pop()) {
    next2.push(node2);
    if (children2 = node2.children) {
      for (i = 0, n = children2.length; i < n; ++i) {
        nodes.push(children2[i]);
      }
    }
  }
  while (node2 = next2.pop()) {
    callback.call(that, node2, ++index2, this);
  }
  return this;
}
function node_find(callback, that) {
  let index2 = -1;
  for (const node2 of this) {
    if (callback.call(that, node2, ++index2, this)) {
      return node2;
    }
  }
}
function node_sum(value2) {
  return this.eachAfter(function(node2) {
    var sum2 = +value2(node2.data) || 0, children2 = node2.children, i = children2 && children2.length;
    while (--i >= 0) sum2 += children2[i].value;
    node2.value = sum2;
  });
}
function node_sort(compare2) {
  return this.eachBefore(function(node2) {
    if (node2.children) {
      node2.children.sort(compare2);
    }
  });
}
function node_path(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a2, b2) {
  if (a2 === b2) return a2;
  var aNodes = a2.ancestors(), bNodes = b2.ancestors(), c2 = null;
  a2 = aNodes.pop();
  b2 = bNodes.pop();
  while (a2 === b2) {
    c2 = a2;
    a2 = aNodes.pop();
    b2 = bNodes.pop();
  }
  return c2;
}
function node_ancestors() {
  var node2 = this, nodes = [node2];
  while (node2 = node2.parent) {
    nodes.push(node2);
  }
  return nodes;
}
function node_descendants() {
  return Array.from(this);
}
function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node2) {
    if (!node2.children) {
      leaves.push(node2);
    }
  });
  return leaves;
}
function node_links() {
  var root2 = this, links = [];
  root2.each(function(node2) {
    if (node2 !== root2) {
      links.push({ source: node2.parent, target: node2 });
    }
  });
  return links;
}
function* node_iterator() {
  var node2 = this, current2, next2 = [node2], children2, i, n;
  do {
    current2 = next2.reverse(), next2 = [];
    while (node2 = current2.pop()) {
      yield node2;
      if (children2 = node2.children) {
        for (i = 0, n = children2.length; i < n; ++i) {
          next2.push(children2[i]);
        }
      }
    }
  } while (next2.length);
}
function hierarchy(data2, children2) {
  if (data2 instanceof Map) {
    data2 = [void 0, data2];
    if (children2 === void 0) children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root2 = new Node$3(data2), node2, nodes = [root2], child, childs, i, n;
  while (node2 = nodes.pop()) {
    if ((childs = children2(node2.data)) && (n = (childs = Array.from(childs)).length)) {
      node2.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node$3(childs[i]));
        child.parent = node2;
        child.depth = node2.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node2) {
  if (node2.data.value !== void 0) node2.value = node2.data.value;
  node2.data = node2.data.data;
}
function computeHeight(node2) {
  var height2 = 0;
  do
    node2.height = height2;
  while ((node2 = node2.parent) && node2.height < ++height2);
}
function Node$3(data2) {
  this.data = data2;
  this.depth = this.height = 0;
  this.parent = null;
}
Node$3.prototype = hierarchy.prototype = {
  constructor: Node$3,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  find: node_find,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy,
  [Symbol.iterator]: node_iterator
};
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}
function constantZero() {
  return 0;
}
function constant$1(x2) {
  return function() {
    return x2;
  };
}
const a = 1664525;
const c = 1013904223;
const m = 4294967296;
function lcg() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}
function array$2(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function shuffle(array2, random2) {
  let m2 = array2.length, t4, i;
  while (m2) {
    i = random2() * m2-- | 0;
    t4 = array2[m2];
    array2[m2] = array2[i];
    array2[i] = t4;
  }
  return array2;
}
function packEncloseRandom(circles, random2) {
  var i = 0, n = (circles = shuffle(Array.from(circles), random2)).length, B2 = [], p, e3;
  while (i < n) {
    p = circles[i];
    if (e3 && enclosesWeak(e3, p)) ++i;
    else e3 = encloseBasis(B2 = extendBasis(B2, p)), i = 0;
  }
  return e3;
}
function extendBasis(B2, p) {
  var i, j;
  if (enclosesWeakAll(p, B2)) return [p];
  for (i = 0; i < B2.length; ++i) {
    if (enclosesNot(p, B2[i]) && enclosesWeakAll(encloseBasis2(B2[i], p), B2)) {
      return [B2[i], p];
    }
  }
  for (i = 0; i < B2.length - 1; ++i) {
    for (j = i + 1; j < B2.length; ++j) {
      if (enclosesNot(encloseBasis2(B2[i], B2[j]), p) && enclosesNot(encloseBasis2(B2[i], p), B2[j]) && enclosesNot(encloseBasis2(B2[j], p), B2[i]) && enclosesWeakAll(encloseBasis3(B2[i], B2[j], p), B2)) {
        return [B2[i], B2[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a2, b2) {
  var dr = a2.r - b2.r, dx = b2.x - a2.x, dy = b2.y - a2.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a2, b2) {
  var dr = a2.r - b2.r + Math.max(a2.r, b2.r, 1) * 1e-9, dx = b2.x - a2.x, dy = b2.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a2, B2) {
  for (var i = 0; i < B2.length; ++i) {
    if (!enclosesWeak(a2, B2[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B2) {
  switch (B2.length) {
    case 1:
      return encloseBasis1(B2[0]);
    case 2:
      return encloseBasis2(B2[0], B2[1]);
    case 3:
      return encloseBasis3(B2[0], B2[1], B2[2]);
  }
}
function encloseBasis1(a2) {
  return {
    x: a2.x,
    y: a2.y,
    r: a2.r
  };
}
function encloseBasis2(a2, b2) {
  var x12 = a2.x, y12 = a2.y, r1 = a2.r, x2 = b2.x, y2 = b2.y, r2 = b2.r, x21 = x2 - x12, y21 = y2 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x2 + x21 / l * r21) / 2,
    y: (y12 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a2, b2, c2) {
  var x12 = a2.x, y12 = a2.y, r1 = a2.r, x2 = b2.x, y2 = b2.y, r2 = b2.r, x3 = c2.x, y3 = c2.y, r3 = c2.r, a22 = x12 - x2, a3 = x12 - x3, b22 = y12 - y2, b3 = y12 - y3, c22 = r2 - r1, c3 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b22 - a22 * b3, xa = (b22 * d3 - b3 * d2) / (ab * 2) - x12, xb = (b3 * c22 - b22 * c3) / ab, ya = (a3 * d2 - a22 * d3) / (ab * 2) - y12, yb = (a22 * c3 - a3 * c22) / ab, A5 = xb * xb + yb * yb - 1, B2 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r4 = -(Math.abs(A5) > 1e-6 ? (B2 + Math.sqrt(B2 * B2 - 4 * A5 * C3)) / (2 * A5) : C3 / B2);
  return {
    x: x12 + xa + xb * r4,
    y: y12 + ya + yb * r4,
    r: r4
  };
}
function place(b2, a2, c2) {
  var dx = b2.x - a2.x, x2, a22, dy = b2.y - a2.y, y2, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a2.r + c2.r, a22 *= a22;
    b22 = b2.r + c2.r, b22 *= b22;
    if (a22 > b22) {
      x2 = (d2 + b22 - a22) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, b22 / d2 - x2 * x2));
      c2.x = b2.x - x2 * dx - y2 * dy;
      c2.y = b2.y - x2 * dy + y2 * dx;
    } else {
      x2 = (d2 + a22 - b22) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, a22 / d2 - x2 * x2));
      c2.x = a2.x + x2 * dx - y2 * dy;
      c2.y = a2.y + x2 * dy + y2 * dx;
    }
  } else {
    c2.x = a2.x + c2.r;
    c2.y = a2.y;
  }
}
function intersects(a2, b2) {
  var dr = a2.r + b2.r - 1e-6, dx = b2.x - a2.x, dy = b2.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node2) {
  var a2 = node2._, b2 = node2.next._, ab = a2.r + b2.r, dx = (a2.x * b2.r + b2.x * a2.r) / ab, dy = (a2.y * b2.r + b2.y * a2.r) / ab;
  return dx * dx + dy * dy;
}
function Node$2(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random2) {
  if (!(n = (circles = array$2(circles)).length)) return 0;
  var a2, b2, c2, n, aa, ca, i, j, k, sj, sk;
  a2 = circles[0], a2.x = 0, a2.y = 0;
  if (!(n > 1)) return a2.r;
  b2 = circles[1], a2.x = -b2.r, b2.x = a2.r, b2.y = 0;
  if (!(n > 2)) return a2.r + b2.r;
  place(b2, a2, c2 = circles[2]);
  a2 = new Node$2(a2), b2 = new Node$2(b2), c2 = new Node$2(c2);
  a2.next = c2.previous = b2;
  b2.next = a2.previous = c2;
  c2.next = b2.previous = a2;
  pack: for (i = 3; i < n; ++i) {
    place(a2._, b2._, c2 = circles[i]), c2 = new Node$2(c2);
    j = b2.next, k = a2.previous, sj = b2._.r, sk = a2._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c2._)) {
          b2 = j, a2.next = b2, b2.previous = a2, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c2._)) {
          a2 = k, a2.next = b2, b2.previous = a2, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);
    c2.previous = a2, c2.next = b2, a2.next = b2.previous = b2 = c2;
    aa = score(a2);
    while ((c2 = c2.next) !== b2) {
      if ((ca = score(c2)) < aa) {
        a2 = c2, aa = ca;
      }
    }
    b2 = a2.next;
  }
  a2 = [b2._], c2 = b2;
  while ((c2 = c2.next) !== b2) a2.push(c2._);
  c2 = packEncloseRandom(a2, random2);
  for (i = 0; i < n; ++i) a2 = circles[i], a2.x -= c2.x, a2.y -= c2.y;
  return c2.r;
}
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function pack() {
  var radius2 = null, dx = 1, dy = 1, padding2 = constantZero;
  function pack2(root2) {
    const random2 = lcg();
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius2) {
      root2.eachBefore(radiusLeaf(radius2)).eachAfter(packChildrenRandom(padding2, 0.5, random2)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random2)).eachAfter(packChildrenRandom(padding2, root2.r / Math.min(dx, dy), random2)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack2.radius = function(x2) {
    return arguments.length ? (radius2 = optional(x2), pack2) : radius2;
  };
  pack2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], pack2) : [dx, dy];
  };
  pack2.padding = function(x2) {
    return arguments.length ? (padding2 = typeof x2 === "function" ? x2 : constant$1(+x2), pack2) : padding2;
  };
  return pack2;
}
function radiusLeaf(radius2) {
  return function(node2) {
    if (!node2.children) {
      node2.r = Math.max(0, +radius2(node2) || 0);
    }
  };
}
function packChildrenRandom(padding2, k, random2) {
  return function(node2) {
    if (children2 = node2.children) {
      var children2, i, n = children2.length, r2 = padding2(node2) * k || 0, e3;
      if (r2) for (i = 0; i < n; ++i) children2[i].r += r2;
      e3 = packSiblingsRandom(children2, random2);
      if (r2) for (i = 0; i < n; ++i) children2[i].r -= r2;
      node2.r = e3 + r2;
    }
  };
}
function translateChild(k) {
  return function(node2) {
    var parent = node2.parent;
    node2.r *= k;
    if (parent) {
      node2.x = parent.x + k * node2.x;
      node2.y = parent.y + k * node2.y;
    }
  };
}
function roundNode(node2) {
  node2.x0 = Math.round(node2.x0);
  node2.y0 = Math.round(node2.y0);
  node2.x1 = Math.round(node2.x1);
  node2.y1 = Math.round(node2.y1);
}
function treemapDice(parent, x02, y02, x12, y12) {
  var nodes = parent.children, node2, i = -1, n = nodes.length, k = parent.value && (x12 - x02) / parent.value;
  while (++i < n) {
    node2 = nodes[i], node2.y0 = y02, node2.y1 = y12;
    node2.x0 = x02, node2.x1 = x02 += node2.value * k;
  }
}
function partition$1() {
  var dx = 1, dy = 1, padding2 = 0, round2 = false;
  function partition2(root2) {
    var n = root2.height + 1;
    root2.x0 = root2.y0 = padding2;
    root2.x1 = dx;
    root2.y1 = dy / n;
    root2.eachBefore(positionNode(dy, n));
    if (round2) root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode(dy2, n) {
    return function(node2) {
      if (node2.children) {
        treemapDice(node2, node2.x0, dy2 * (node2.depth + 1) / n, node2.x1, dy2 * (node2.depth + 2) / n);
      }
      var x02 = node2.x0, y02 = node2.y0, x12 = node2.x1 - padding2, y12 = node2.y1 - padding2;
      if (x12 < x02) x02 = x12 = (x02 + x12) / 2;
      if (y12 < y02) y02 = y12 = (y02 + y12) / 2;
      node2.x0 = x02;
      node2.y0 = y02;
      node2.x1 = x12;
      node2.y1 = y12;
    };
  }
  partition2.round = function(x2) {
    return arguments.length ? (round2 = !!x2, partition2) : round2;
  };
  partition2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], partition2) : [dx, dy];
  };
  partition2.padding = function(x2) {
    return arguments.length ? (padding2 = +x2, partition2) : padding2;
  };
  return partition2;
}
var preroot = { depth: -1 }, ambiguous = {}, imputed = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify() {
  var id2 = defaultId, parentId = defaultParentId, path2;
  function stratify2(data2) {
    var nodes = Array.from(data2), currentId = id2, currentParentId = parentId, n, d, i, root2, parent, node2, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path2 != null) {
      const I = nodes.map((d2, i2) => normalize$1(path2(d2, i2, data2)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i2 of P) {
        if (!S.has(i2)) {
          S.add(i2);
          I.push(i2);
          P.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_, i2) => I[i2];
      currentParentId = (_, i2) => P[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d = nodes[i], node2 = nodes[i] = new Node$3(d);
      if ((nodeId = currentId(d, i, data2)) != null && (nodeId += "")) {
        nodeKey = node2.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node2);
      }
      if ((nodeId = currentParentId(d, i, data2)) != null && (nodeId += "")) {
        node2.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node2 = nodes[i];
      if (nodeId = node2.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node2);
        else parent.children = [node2];
        node2.parent = parent;
      } else {
        if (root2) throw new Error("multiple roots");
        root2 = node2;
      }
    }
    if (!root2) throw new Error("no root");
    if (path2 != null) {
      while (root2.data === imputed && root2.children.length === 1) {
        root2 = root2.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node2 = nodes[i2];
        if (node2.data !== imputed) break;
        node2.data = null;
      }
    }
    root2.parent = preroot;
    root2.eachBefore(function(node22) {
      node22.depth = node22.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0) throw new Error("cycle");
    return root2;
  }
  stratify2.id = function(x2) {
    return arguments.length ? (id2 = optional(x2), stratify2) : id2;
  };
  stratify2.parentId = function(x2) {
    return arguments.length ? (parentId = optional(x2), stratify2) : parentId;
  };
  stratify2.path = function(x2) {
    return arguments.length ? (path2 = optional(x2), stratify2) : path2;
  };
  return stratify2;
}
function normalize$1(path2) {
  path2 = `${path2}`;
  let i = path2.length;
  if (slash(path2, i - 1) && !slash(path2, i - 2)) path2 = path2.slice(0, -1);
  return path2[0] === "/" ? path2 : `/${path2}`;
}
function parentof(path2) {
  let i = path2.length;
  if (i < 2) return "";
  while (--i > 1) if (slash(path2, i)) break;
  return path2.slice(0, i);
}
function slash(path2, i) {
  if (path2[i] === "/") {
    let k = 0;
    while (i > 0 && path2[--i] === "\\") ++k;
    if ((k & 1) === 0) return true;
  }
  return false;
}
function defaultSeparation$1(a2, b2) {
  return a2.parent === b2.parent ? 1 : 2;
}
function nextLeft(v) {
  var children2 = v.children;
  return children2 ? children2[0] : v.t;
}
function nextRight(v) {
  var children2 = v.children;
  return children2 ? children2[children2.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift2) {
  var change2 = shift2 / (wp.i - wm.i);
  wp.c -= change2;
  wp.s += shift2;
  wm.c += change2;
  wp.z += shift2;
  wp.m += shift2;
}
function executeShifts(v) {
  var shift2 = 0, change2 = 0, children2 = v.children, i = children2.length, w2;
  while (--i >= 0) {
    w2 = children2[i];
    w2.z += shift2;
    w2.m += shift2;
    shift2 += w2.s + (change2 += w2.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node2, i) {
  this._ = node2;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node$3.prototype);
function treeRoot(root2) {
  var tree2 = new TreeNode(root2, 0), node2, nodes = [tree2], child, children2, i, n;
  while (node2 = nodes.pop()) {
    if (children2 = node2._.children) {
      node2.children = new Array(n = children2.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node2.children[i] = new TreeNode(children2[i], i));
        child.parent = node2;
      }
    }
  }
  (tree2.parent = new TreeNode(null, 0)).children = [tree2];
  return tree2;
}
function tree$1() {
  var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = null;
  function tree2(root2) {
    var t4 = treeRoot(root2);
    t4.eachAfter(firstWalk), t4.parent.m = -t4.z;
    t4.eachBefore(secondWalk);
    if (nodeSize) root2.eachBefore(sizeNode);
    else {
      var left = root2, right = root2, bottom = root2;
      root2.eachBefore(function(node2) {
        if (node2.x < left.x) left = node2;
        if (node2.x > right.x) right = node2;
        if (node2.depth > bottom.depth) bottom = node2;
      });
      var s = left === right ? 1 : separation(left, right) / 2, tx2 = s - left.x, kx = dx / (right.x + s + tx2), ky = dy / (bottom.depth || 1);
      root2.eachBefore(function(node2) {
        node2.x = (node2.x + tx2) * kx;
        node2.y = node2.depth * ky;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children2 = v.children, siblings = v.parent.children, w2 = v.i ? siblings[v.i - 1] : null;
    if (children2) {
      executeShifts(v);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w2) {
        v.z = w2.z + separation(v._, w2._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w2) {
      v.z = w2.z + separation(v._, w2._);
    }
    v.parent.A = apportion(v, w2, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w2, ancestor) {
    if (w2) {
      var vip = v, vop = v, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift2;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift2 = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift2 > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift2);
          sip += shift2;
          sop += shift2;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node2) {
    node2.x *= dx;
    node2.y = node2.depth * dy;
  }
  tree2.separation = function(x2) {
    return arguments.length ? (separation = x2, tree2) : separation;
  };
  tree2.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? null : [dx, dy];
  };
  tree2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? [dx, dy] : null;
  };
  return tree2;
}
function treemapSlice(parent, x02, y02, x12, y12) {
  var nodes = parent.children, node2, i = -1, n = nodes.length, k = parent.value && (y12 - y02) / parent.value;
  while (++i < n) {
    node2 = nodes[i], node2.x0 = x02, node2.x1 = x12;
    node2.y0 = y02, node2.y1 = y02 += node2.value * k;
  }
}
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x02, y02, x12, y12) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha2, beta;
  while (i0 < n) {
    dx = x12 - x02, dy = y12 - y02;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha2 = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha2;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha2;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice) treemapDice(row, x02, y02, x12, value2 ? y02 += dy * sumValue / value2 : y12);
    else treemapSlice(row, x02, y02, value2 ? x02 += dx * sumValue / value2 : x12, y12);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
const treemapSquarify = function custom8(ratio) {
  function squarify(parent, x02, y02, x12, y12) {
    squarifyRatio(ratio, parent, x02, y02, x12, y12);
  }
  squarify.ratio = function(x2) {
    return custom8((x2 = +x2) > 1 ? x2 : 1);
  };
  return squarify;
}(phi);
function treemap() {
  var tile = treemapSquarify, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner2 = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap2(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round2) root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode(node2) {
    var p = paddingStack[node2.depth], x02 = node2.x0 + p, y02 = node2.y0 + p, x12 = node2.x1 - p, y12 = node2.y1 - p;
    if (x12 < x02) x02 = x12 = (x02 + x12) / 2;
    if (y12 < y02) y02 = y12 = (y02 + y12) / 2;
    node2.x0 = x02;
    node2.y0 = y02;
    node2.x1 = x12;
    node2.y1 = y12;
    if (node2.children) {
      p = paddingStack[node2.depth + 1] = paddingInner2(node2) / 2;
      x02 += paddingLeft(node2) - p;
      y02 += paddingTop(node2) - p;
      x12 -= paddingRight(node2) - p;
      y12 -= paddingBottom(node2) - p;
      if (x12 < x02) x02 = x12 = (x02 + x12) / 2;
      if (y12 < y02) y02 = y12 = (y02 + y12) / 2;
      tile(node2, x02, y02, x12, y12);
    }
  }
  treemap2.round = function(x2) {
    return arguments.length ? (round2 = !!x2, treemap2) : round2;
  };
  treemap2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap2) : [dx, dy];
  };
  treemap2.tile = function(x2) {
    return arguments.length ? (tile = required(x2), treemap2) : tile;
  };
  treemap2.padding = function(x2) {
    return arguments.length ? treemap2.paddingInner(x2).paddingOuter(x2) : treemap2.paddingInner();
  };
  treemap2.paddingInner = function(x2) {
    return arguments.length ? (paddingInner2 = typeof x2 === "function" ? x2 : constant$1(+x2), treemap2) : paddingInner2;
  };
  treemap2.paddingOuter = function(x2) {
    return arguments.length ? treemap2.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap2.paddingTop();
  };
  treemap2.paddingTop = function(x2) {
    return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant$1(+x2), treemap2) : paddingTop;
  };
  treemap2.paddingRight = function(x2) {
    return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant$1(+x2), treemap2) : paddingRight;
  };
  treemap2.paddingBottom = function(x2) {
    return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant$1(+x2), treemap2) : paddingBottom;
  };
  treemap2.paddingLeft = function(x2) {
    return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant$1(+x2), treemap2) : paddingLeft;
  };
  return treemap2;
}
function treemapBinary(parent, x02, y02, x12, y12) {
  var nodes = parent.children, i, n = nodes.length, sum2, sums = new Array(n + 1);
  for (sums[0] = sum2 = i = 0; i < n; ++i) {
    sums[i + 1] = sum2 += nodes[i].value;
  }
  partition2(0, n, parent.value, x02, y02, x12, y12);
  function partition2(i2, j, value2, x022, y022, x122, y122) {
    if (i2 >= j - 1) {
      var node2 = nodes[i2];
      node2.x0 = x022, node2.y0 = y022;
      node2.x1 = x122, node2.y1 = y122;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value2 / 2 + valueOffset, k = i2 + 1, hi = j - 1;
    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }
    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k) --k;
    var valueLeft = sums[k] - valueOffset, valueRight = value2 - valueLeft;
    if (x122 - x022 > y122 - y022) {
      var xk = value2 ? (x022 * valueRight + x122 * valueLeft) / value2 : x122;
      partition2(i2, k, valueLeft, x022, y022, xk, y122);
      partition2(k, j, valueRight, xk, y022, x122, y122);
    } else {
      var yk = value2 ? (y022 * valueRight + y122 * valueLeft) / value2 : y122;
      partition2(i2, k, valueLeft, x022, y022, x122, yk);
      partition2(k, j, valueRight, x022, yk, x122, y122);
    }
  }
}
function treemapSliceDice(parent, x02, y02, x12, y12) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x02, y02, x12, y12);
}
const treemapResquarify = function custom9(ratio) {
  function resquarify(parent, x02, y02, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m2 = rows.length, value2 = parent.value;
      while (++j < m2) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) treemapDice(row, x02, y02, x12, value2 ? y02 += (y12 - y02) * row.value / value2 : y12);
        else treemapSlice(row, x02, y02, value2 ? x02 += (x12 - x02) * row.value / value2 : x12, y12);
        value2 -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x02, y02, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x2) {
    return custom9((x2 = +x2) > 1 ? x2 : 1);
  };
  return resquarify;
}(phi);
function lookup$2(tree2, key2, filter2) {
  const map2 = {};
  tree2.each((node2) => {
    const t4 = node2.data;
    if (filter2(t4)) map2[key2(t4)] = node2;
  });
  tree2.lookup = map2;
  return tree2;
}
function Nest(params2) {
  Transform.call(this, null, params2);
}
Nest.Definition = {
  "type": "Nest",
  "metadata": {
    "treesource": true,
    "changes": true
  },
  "params": [{
    "name": "keys",
    "type": "field",
    "array": true
  }, {
    "name": "generate",
    "type": "boolean"
  }]
};
const children$1 = (n) => n.values;
inherits(Nest, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error("Nest transform requires an upstream data source.");
    }
    var gen = _.generate, mod = _.modified(), out = pulse2.clone(), tree2 = this.value;
    if (!tree2 || mod || pulse2.changed()) {
      if (tree2) {
        tree2.each((node2) => {
          if (node2.children && isTuple(node2.data)) {
            out.rem.push(node2.data);
          }
        });
      }
      this.value = tree2 = hierarchy({
        values: array$5(_.keys).reduce((n, k) => {
          n.key(k);
          return n;
        }, nest()).entries(out.source)
      }, children$1);
      if (gen) {
        tree2.each((node2) => {
          if (node2.children) {
            node2 = ingest$1(node2.data);
            out.add.push(node2);
            out.source.push(node2);
          }
        });
      }
      lookup$2(tree2, tupleid, tupleid);
    }
    out.source.root = tree2;
    return out;
  }
});
function nest() {
  const keys2 = [], nest2 = {
    entries: (array2) => entries2(apply2(array2, 0), 0),
    key: (d) => (keys2.push(d), nest2)
  };
  function apply2(array2, depth) {
    if (depth >= keys2.length) {
      return array2;
    }
    const n = array2.length, key2 = keys2[depth++], valuesByKey = {}, result = {};
    let i = -1, keyValue, value2, values2;
    while (++i < n) {
      keyValue = key2(value2 = array2[i]) + "";
      if (values2 = valuesByKey[keyValue]) {
        values2.push(value2);
      } else {
        valuesByKey[keyValue] = [value2];
      }
    }
    for (keyValue in valuesByKey) {
      result[keyValue] = apply2(valuesByKey[keyValue], depth);
    }
    return result;
  }
  function entries2(map2, depth) {
    if (++depth > keys2.length) return map2;
    const array2 = [];
    for (const key2 in map2) {
      array2.push({
        key: key2,
        values: entries2(map2[key2], depth)
      });
    }
    return array2;
  }
  return nest2;
}
function HierarchyLayout(params2) {
  Transform.call(this, null, params2);
}
const defaultSeparation = (a2, b2) => a2.parent === b2.parent ? 1 : 2;
inherits(HierarchyLayout, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source || !pulse2.source.root) {
      error(this.constructor.name + " transform requires a backing tree data source.");
    }
    const layout = this.layout(_.method), fields = this.fields, root2 = pulse2.source.root, as = _.as || fields;
    if (_.field) root2.sum(_.field);
    else root2.count();
    if (_.sort) root2.sort(stableCompare(_.sort, (d) => d.data));
    setParams(layout, this.params, _);
    if (layout.separation) {
      layout.separation(_.separation !== false ? defaultSeparation : one$3);
    }
    try {
      this.value = layout(root2);
    } catch (err) {
      error(err);
    }
    root2.each((node2) => setFields(node2, fields, as));
    return pulse2.reflow(_.modified()).modifies(as).modifies("leaf");
  }
});
function setParams(layout, params2, _) {
  for (let p, i = 0, n = params2.length; i < n; ++i) {
    p = params2[i];
    if (p in _) layout[p](_[p]);
  }
}
function setFields(node2, fields, as) {
  const t4 = node2.data, n = fields.length - 1;
  for (let i = 0; i < n; ++i) {
    t4[as[i]] = node2[fields[i]];
  }
  t4[as[n]] = node2.children ? node2.children.length : 0;
}
const Output$3 = ["x", "y", "r", "depth", "children"];
function Pack(params2) {
  HierarchyLayout.call(this, params2);
}
Pack.Definition = {
  "type": "Pack",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "radius",
    "type": "field",
    "default": null
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$3.length,
    "default": Output$3
  }]
};
inherits(Pack, HierarchyLayout, {
  layout: pack,
  params: ["radius", "size", "padding"],
  fields: Output$3
});
const Output$2 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Partition(params2) {
  HierarchyLayout.call(this, params2);
}
Partition.Definition = {
  "type": "Partition",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "round",
    "type": "boolean",
    "default": false
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$2.length,
    "default": Output$2
  }]
};
inherits(Partition, HierarchyLayout, {
  layout: partition$1,
  params: ["size", "round", "padding"],
  fields: Output$2
});
function Stratify(params2) {
  Transform.call(this, null, params2);
}
Stratify.Definition = {
  "type": "Stratify",
  "metadata": {
    "treesource": true
  },
  "params": [{
    "name": "key",
    "type": "field",
    "required": true
  }, {
    "name": "parentKey",
    "type": "field",
    "required": true
  }]
};
inherits(Stratify, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error("Stratify transform requires an upstream data source.");
    }
    let tree2 = this.value;
    const mod = _.modified(), out = pulse2.fork(pulse2.ALL).materialize(pulse2.SOURCE), run2 = !tree2 || mod || pulse2.changed(pulse2.ADD_REM) || pulse2.modified(_.key.fields) || pulse2.modified(_.parentKey.fields);
    out.source = out.source.slice();
    if (run2) {
      tree2 = out.source.length ? lookup$2(stratify().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup$2(stratify()([{}]), _.key, _.key);
    }
    out.source.root = this.value = tree2;
    return out;
  }
});
const Layouts = {
  tidy: tree$1,
  cluster
};
const Output$1$1 = ["x", "y", "depth", "children"];
function Tree(params2) {
  HierarchyLayout.call(this, params2);
}
Tree.Definition = {
  "type": "Tree",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "method",
    "type": "enum",
    "default": "tidy",
    "values": ["tidy", "cluster"]
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "nodeSize",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "separation",
    "type": "boolean",
    "default": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$1$1.length,
    "default": Output$1$1
  }]
};
inherits(Tree, HierarchyLayout, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(method2) {
    const m2 = method2 || "tidy";
    if (has$2(Layouts, m2)) return Layouts[m2]();
    else error("Unrecognized Tree layout method: " + m2);
  },
  params: ["size", "nodeSize"],
  fields: Output$1$1
});
function TreeLinks(params2) {
  Transform.call(this, [], params2);
}
TreeLinks.Definition = {
  "type": "TreeLinks",
  "metadata": {
    "tree": true,
    "generates": true,
    "changes": true
  },
  "params": []
};
inherits(TreeLinks, Transform, {
  transform(_, pulse2) {
    const links = this.value, tree2 = pulse2.source && pulse2.source.root, out = pulse2.fork(pulse2.NO_SOURCE), lut = {};
    if (!tree2) error("TreeLinks transform requires a tree data source.");
    if (pulse2.changed(pulse2.ADD_REM)) {
      out.rem = links;
      pulse2.visit(pulse2.SOURCE, (t4) => lut[tupleid(t4)] = 1);
      tree2.each((node2) => {
        const t4 = node2.data, p = node2.parent && node2.parent.data;
        if (p && lut[tupleid(t4)] && lut[tupleid(p)]) {
          out.add.push(ingest$1({
            source: p,
            target: t4
          }));
        }
      });
      this.value = out.add;
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t4) => lut[tupleid(t4)] = 1);
      links.forEach((link2) => {
        if (lut[tupleid(link2.source)] || lut[tupleid(link2.target)]) {
          out.mod.push(link2);
        }
      });
    }
    return out;
  }
});
const Tiles = {
  binary: treemapBinary,
  dice: treemapDice,
  slice: treemapSlice,
  slicedice: treemapSliceDice,
  squarify: treemapSquarify,
  resquarify: treemapResquarify
};
const Output$4 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Treemap(params2) {
  HierarchyLayout.call(this, params2);
}
Treemap.Definition = {
  "type": "Treemap",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "method",
    "type": "enum",
    "default": "squarify",
    "values": ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingInner",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingOuter",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingTop",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingRight",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingBottom",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingLeft",
    "type": "number",
    "default": 0
  }, {
    "name": "ratio",
    "type": "number",
    "default": 1.618033988749895
  }, {
    "name": "round",
    "type": "boolean",
    "default": false
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$4.length,
    "default": Output$4
  }]
};
inherits(Treemap, HierarchyLayout, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const x2 = treemap();
    x2.ratio = (_) => {
      const t4 = x2.tile();
      if (t4.ratio) x2.tile(t4.ratio(_));
    };
    x2.method = (_) => {
      if (has$2(Tiles, _)) x2.tile(Tiles[_]);
      else error("Unrecognized Treemap layout method: " + _);
    };
    return x2;
  },
  params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
  fields: Output$4
});
const tree = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  nest: Nest,
  pack: Pack,
  partition: Partition,
  stratify: Stratify,
  tree: Tree,
  treelinks: TreeLinks,
  treemap: Treemap
}, Symbol.toStringTag, { value: "Module" }));
const ALPHA_MASK = 4278190080;
function baseBitmaps($2, data2) {
  const bitmap = $2.bitmap();
  (data2 || []).forEach((d) => bitmap.set($2(d.boundary[0]), $2(d.boundary[3])));
  return [bitmap, void 0];
}
function markBitmaps($2, baseMark, avoidMarks, labelInside, isGroupArea) {
  const width2 = $2.width, height2 = $2.height, border2 = labelInside || isGroupArea, context2 = domCanvas(width2, height2).getContext("2d"), baseMarkContext = domCanvas(width2, height2).getContext("2d"), strokeContext = border2 && domCanvas(width2, height2).getContext("2d");
  avoidMarks.forEach((items) => draw(context2, items, false));
  draw(baseMarkContext, baseMark, false);
  if (border2) {
    draw(strokeContext, baseMark, true);
  }
  const buffer = getBuffer(context2, width2, height2), baseMarkBuffer = getBuffer(baseMarkContext, width2, height2), strokeBuffer = border2 && getBuffer(strokeContext, width2, height2), layer1 = $2.bitmap(), layer2 = border2 && $2.bitmap();
  let x2, y2, u2, v, index2, alpha2, strokeAlpha, baseMarkAlpha;
  for (y2 = 0; y2 < height2; ++y2) {
    for (x2 = 0; x2 < width2; ++x2) {
      index2 = y2 * width2 + x2;
      alpha2 = buffer[index2] & ALPHA_MASK;
      baseMarkAlpha = baseMarkBuffer[index2] & ALPHA_MASK;
      strokeAlpha = border2 && strokeBuffer[index2] & ALPHA_MASK;
      if (alpha2 || strokeAlpha || baseMarkAlpha) {
        u2 = $2(x2);
        v = $2(y2);
        if (!isGroupArea && (alpha2 || baseMarkAlpha)) layer1.set(u2, v);
        if (border2 && (alpha2 || strokeAlpha)) layer2.set(u2, v);
      }
    }
  }
  return [layer1, layer2];
}
function getBuffer(context2, width2, height2) {
  return new Uint32Array(context2.getImageData(0, 0, width2, height2).data.buffer);
}
function draw(context2, items, interior) {
  if (!items.length) return;
  const type2 = items[0].mark.marktype;
  if (type2 === "group") {
    items.forEach((group2) => {
      group2.items.forEach((mark2) => draw(context2, mark2.items, interior));
    });
  } else {
    Marks[type2].draw(context2, {
      items: interior ? items.map(prepare) : items
    });
  }
}
function prepare(source2) {
  const item = rederive(source2, {});
  if (item.stroke && item.strokeOpacity !== 0 || item.fill && item.fillOpacity !== 0) {
    return {
      ...item,
      strokeOpacity: 1,
      stroke: "#000",
      fillOpacity: 0
    };
  }
  return item;
}
const DIV = 5, MOD = 31, SIZE$1 = 32, RIGHT0 = new Uint32Array(SIZE$1 + 1), RIGHT1 = new Uint32Array(SIZE$1 + 1);
RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];
for (let i = 1; i <= SIZE$1; ++i) {
  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
  RIGHT0[i] = ~RIGHT1[i];
}
function Bitmap(w2, h2) {
  const array2 = new Uint32Array(~~((w2 * h2 + SIZE$1) / SIZE$1));
  function _set(index2, mask) {
    array2[index2] |= mask;
  }
  function _clear(index2, mask) {
    array2[index2] &= mask;
  }
  return {
    array: array2,
    get: (x2, y2) => {
      const index2 = y2 * w2 + x2;
      return array2[index2 >>> DIV] & 1 << (index2 & MOD);
    },
    set: (x2, y2) => {
      const index2 = y2 * w2 + x2;
      _set(index2 >>> DIV, 1 << (index2 & MOD));
    },
    clear: (x2, y2) => {
      const index2 = y2 * w2 + x2;
      _clear(index2 >>> DIV, ~(1 << (index2 & MOD)));
    },
    getRange: (x2, y2, x22, y22) => {
      let r2 = y22, start, end, indexStart, indexEnd;
      for (; r2 >= y2; --r2) {
        start = r2 * w2 + x2;
        end = r2 * w2 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          if (array2[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {
            return true;
          }
        } else {
          if (array2[indexStart] & RIGHT0[start & MOD]) return true;
          if (array2[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;
          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array2[i]) return true;
          }
        }
      }
      return false;
    },
    setRange: (x2, y2, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y2 <= y22; ++y2) {
        start = y2 * w2 + x2;
        end = y2 * w2 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD]);
          _set(indexEnd, RIGHT1[(end & MOD) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 4294967295);
        }
      }
    },
    clearRange: (x2, y2, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y2 <= y22; ++y2) {
        start = y2 * w2 + x2;
        end = y2 * w2 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD]);
          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);
        }
      }
    },
    outOfBounds: (x2, y2, x22, y22) => x2 < 0 || y2 < 0 || y22 >= h2 || x22 >= w2
  };
}
function scaler(width2, height2, padding2) {
  const ratio = Math.max(1, Math.sqrt(width2 * height2 / 1e6)), w2 = ~~((width2 + 2 * padding2 + ratio) / ratio), h2 = ~~((height2 + 2 * padding2 + ratio) / ratio), scale2 = (_) => ~~((_ + padding2) / ratio);
  scale2.invert = (_) => _ * ratio - padding2;
  scale2.bitmap = () => Bitmap(w2, h2);
  scale2.ratio = ratio;
  scale2.padding = padding2;
  scale2.width = width2;
  scale2.height = height2;
  return scale2;
}
function placeAreaLabelNaive($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height;
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
    let maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, areaWidth;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
      x3 = (x12 + x2) / 2;
      y3 = (y12 + y2) / 2;
      areaWidth = Math.abs(x2 - x12 + y2 - y12);
      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x3;
        d.y = y3;
      }
    }
    x3 = textWidth / 2;
    y3 = textHeight / 2;
    x12 = d.x - x3;
    x2 = d.x + x3;
    y12 = d.y - y3;
    y2 = d.y + y3;
    d.align = "center";
    if (x12 < 0 && x2 <= width2) {
      d.align = "left";
    } else if (0 <= x12 && width2 < x2) {
      d.align = "right";
    }
    d.baseline = "middle";
    if (y12 < 0 && y2 <= height2) {
      d.baseline = "top";
    } else if (0 <= y12 && height2 < y2) {
      d.baseline = "bottom";
    }
    return true;
  };
}
function outOfBounds(x2, y2, textWidth, textHeight, width2, height2) {
  let r2 = textWidth / 2;
  return x2 - r2 < 0 || x2 + r2 > width2 || y2 - (r2 = textHeight / 2) < 0 || y2 + r2 > height2;
}
function collision($2, x2, y2, textHeight, textWidth, h2, bm0, bm1) {
  const w2 = textWidth * h2 / (textHeight * 2), x12 = $2(x2 - w2), x22 = $2(x2 + w2), y12 = $2(y2 - (h2 = h2 / 2)), y22 = $2(y2 + h2);
  return bm0.outOfBounds(x12, y12, x22, y22) || bm0.getRange(x12, y12, x22, y22) || bm1 && bm1.getRange(x12, y12, x22, y22);
}
function placeAreaLabelReducedSearch($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1];
  function tryLabel(_x3, _y3, maxSize, textWidth, textHeight) {
    const x2 = $2.invert(_x3), y2 = $2.invert(_y3);
    let lo = maxSize, hi = height2, mid;
    if (!outOfBounds(x2, y2, textWidth, textHeight, width2, height2) && !collision($2, x2, y2, textHeight, textWidth, lo, bm0, bm1) && !collision($2, x2, y2, textHeight, textWidth, textHeight, bm0, null)) {
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;
        if (collision($2, x2, y2, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      }
      if (lo > maxSize) {
        return [x2, y2, lo, true];
      }
    }
  }
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, _x3, _y3, _x1, _xMid, _x22, _y1, _yMid, _y22, areaWidth, result, swapTmp;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
      if (x12 > x2) {
        swapTmp = x12;
        x12 = x2;
        x2 = swapTmp;
      }
      if (y12 > y2) {
        swapTmp = y12;
        y12 = y2;
        y2 = swapTmp;
      }
      _x1 = $2(x12);
      _x22 = $2(x2);
      _xMid = ~~((_x1 + _x22) / 2);
      _y1 = $2(y12);
      _y22 = $2(y2);
      _yMid = ~~((_y1 + _y22) / 2);
      for (_x3 = _xMid; _x3 >= _x1; --_x3) {
        for (_y3 = _yMid; _y3 >= _y1; --_y3) {
          result = tryLabel(_x3, _y3, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      for (_x3 = _xMid; _x3 <= _x22; ++_x3) {
        for (_y3 = _yMid; _y3 <= _y22; ++_y3) {
          result = tryLabel(_x3, _y3, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x2 - x12 + y2 - y12);
        x3 = (x12 + x2) / 2;
        y3 = (y12 + y2) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x3;
          d.y = y3;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x3 = textWidth / 2;
      y3 = textHeight / 2;
      bm0.setRange($2(d.x - x3), $2(d.y - y3), $2(d.x + x3), $2(d.y + y3));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
const X_DIR = [-1, -1, 1, 1];
const Y_DIR = [-1, 1, -1, 1];
function placeAreaLabelFloodFill($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1], bm2 = $2.bitmap();
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text), stack2 = [];
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, _x3, _y3, lo, hi, mid, areaWidth;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
      stack2.push([$2((x12 + x2) / 2), $2((y12 + y2) / 2)]);
      while (stack2.length) {
        [_x3, _y3] = stack2.pop();
        if (bm0.get(_x3, _y3) || bm1.get(_x3, _y3) || bm2.get(_x3, _y3)) continue;
        bm2.set(_x3, _y3);
        for (let j = 0; j < 4; ++j) {
          x3 = _x3 + X_DIR[j];
          y3 = _y3 + Y_DIR[j];
          if (!bm2.outOfBounds(x3, y3, x3, y3)) stack2.push([x3, y3]);
        }
        x3 = $2.invert(_x3);
        y3 = $2.invert(_y3);
        lo = maxSize;
        hi = height2;
        if (!outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, lo, bm0, bm1) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;
            if (collision($2, x3, y3, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          }
          if (lo > maxSize) {
            d.x = x3;
            d.y = y3;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x2 - x12 + y2 - y12);
        x3 = (x12 + x2) / 2;
        y3 = (y12 + y2) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x3;
          d.y = y3;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x3 = textWidth / 2;
      y3 = textHeight / 2;
      bm0.setRange($2(d.x - x3), $2(d.y - y3), $2(d.x + x3), $2(d.y + y3));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
const Aligns = ["right", "center", "left"], Baselines = ["bottom", "middle", "top"];
function placeMarkLabel($2, bitmaps, anchors, offsets2) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1], n = offsets2.length;
  return function(d) {
    var _d$textWidth;
    const boundary = d.boundary, textHeight = d.datum.fontSize;
    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width2 || boundary[3] > height2) {
      return false;
    }
    let textWidth = (_d$textWidth = d.textWidth) !== null && _d$textWidth !== void 0 ? _d$textWidth : 0, dx, dy, isInside, sizeFactor, insideFactor, x12, x2, y12, y2, xc, yc, _x1, _x22, _y1, _y22;
    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 3) - 1;
      dy = (anchors[i] >>> 2 & 3) - 1;
      isInside = dx === 0 && dy === 0 || offsets2[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets2[i] < 0 ? -1 : 1;
      x12 = boundary[1 + dx] + offsets2[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets2[i] * dy * sizeFactor;
      y12 = yc - textHeight / 2;
      y2 = yc + textHeight / 2;
      _x1 = $2(x12);
      _y1 = $2(y12);
      _y22 = $2(y2);
      if (!textWidth) {
        if (!test(_x1, _x1, _y1, _y22, bm0, bm1, x12, x12, y12, y2, boundary, isInside)) {
          continue;
        } else {
          textWidth = textMetrics.width(d.datum, d.datum.text);
        }
      }
      xc = x12 + insideFactor * textWidth * dx / 2;
      x12 = xc - textWidth / 2;
      x2 = xc + textWidth / 2;
      _x1 = $2(x12);
      _x22 = $2(x2);
      if (test(_x1, _x22, _y1, _y22, bm0, bm1, x12, x2, y12, y2, boundary, isInside)) {
        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x12;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y12;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x22, _y22);
        return true;
      }
    }
    return false;
  };
}
function test(_x1, _x22, _y1, _y22, bm0, bm1, x12, x2, y12, y2, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x22, _y22) || (isInside && bm1 || bm0).getRange(_x1, _y1, _x22, _y22));
}
const TOP = 0, MIDDLE = 4, BOTTOM = 8, LEFT = 0, CENTER = 1, RIGHT = 2;
const anchorCode = {
  "top-left": TOP + LEFT,
  "top": TOP + CENTER,
  "top-right": TOP + RIGHT,
  "left": MIDDLE + LEFT,
  "middle": MIDDLE + CENTER,
  "right": MIDDLE + RIGHT,
  "bottom-left": BOTTOM + LEFT,
  "bottom": BOTTOM + CENTER,
  "bottom-right": BOTTOM + RIGHT
};
const placeAreaLabel = {
  "naive": placeAreaLabelNaive,
  "reduced-search": placeAreaLabelReducedSearch,
  "floodfill": placeAreaLabelFloodFill
};
function labelLayout(texts, size, compare2, offset2, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding2, method2) {
  if (!texts.length) return texts;
  const positions = Math.max(offset2.length, anchor.length), offsets2 = getOffsets(offset2, positions), anchors = getAnchors(anchor, positions), marktype = markType(texts[0].datum), grouptype = marktype === "group" && texts[0].datum.items[markIndex].marktype, isGroupArea = grouptype === "area", boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex), infPadding = padding2 === null || padding2 === Infinity, isNaiveGroupArea = isGroupArea && method2 === "naive";
  let maxTextWidth = -1, maxTextHeight = -1;
  const data2 = texts.map((d) => {
    const textWidth = infPadding ? textMetrics.width(d, d.text) : void 0;
    maxTextWidth = Math.max(maxTextWidth, textWidth);
    maxTextHeight = Math.max(maxTextHeight, d.fontSize);
    return {
      datum: d,
      opacity: 0,
      x: void 0,
      y: void 0,
      align: void 0,
      baseline: void 0,
      boundary: boundary(d),
      textWidth
    };
  });
  padding2 = padding2 === null || padding2 === Infinity ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset2) : padding2;
  const $2 = scaler(size[0], size[1], padding2);
  let bitmaps;
  if (!isNaiveGroupArea) {
    if (compare2) {
      data2.sort((a2, b2) => compare2(a2.datum, b2.datum));
    }
    let labelInside = false;
    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      labelInside = anchors[i] === 5 || offsets2[i] < 0;
    }
    const baseMark = (marktype && avoidBaseMark || isGroupArea) && texts.map((d) => d.datum);
    bitmaps = avoidMarks.length || baseMark ? markBitmaps($2, baseMark || [], avoidMarks, labelInside, isGroupArea) : baseBitmaps($2, avoidBaseMark && data2);
  }
  const place2 = isGroupArea ? placeAreaLabel[method2]($2, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($2, bitmaps, anchors, offsets2);
  data2.forEach((d) => d.opacity = +place2(d));
  return data2;
}
function getOffsets(_, count2) {
  const offsets2 = new Float64Array(count2), n = _.length;
  for (let i = 0; i < n; ++i) offsets2[i] = _[i] || 0;
  for (let i = n; i < count2; ++i) offsets2[i] = offsets2[n - 1];
  return offsets2;
}
function getAnchors(_, count2) {
  const anchors = new Int8Array(count2), n = _.length;
  for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];
  for (let i = n; i < count2; ++i) anchors[i] = anchors[n - 1];
  return anchors;
}
function markType(item) {
  return item && item.mark && item.mark.marktype;
}
function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = (d) => [d.x, d.x, d.x, d.y, d.y, d.y];
  if (!marktype) {
    return xy;
  } else if (marktype === "line" || marktype === "area") {
    return (d) => xy(d.datum);
  } else if (grouptype === "line") {
    return (d) => {
      const items = d.datum.items[markIndex].items;
      return xy(items.length ? items[lineAnchor === "start" ? 0 : items.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return (d) => {
      const b2 = d.datum.bounds;
      return [b2.x1, (b2.x1 + b2.x2) / 2, b2.x2, b2.y1, (b2.y1 + b2.y2) / 2, b2.y2];
    };
  }
}
const Output$1 = ["x", "y", "opacity", "align", "baseline"];
const Anchors = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
function Label$1(params2) {
  Transform.call(this, null, params2);
}
Label$1.Definition = {
  type: "Label",
  metadata: {
    modifies: true
  },
  params: [{
    name: "size",
    type: "number",
    array: true,
    length: 2,
    required: true
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "anchor",
    type: "string",
    array: true,
    default: Anchors
  }, {
    name: "offset",
    type: "number",
    array: true,
    default: [1]
  }, {
    name: "padding",
    type: "number",
    default: 0,
    null: true
  }, {
    name: "lineAnchor",
    type: "string",
    values: ["start", "end"],
    default: "end"
  }, {
    name: "markIndex",
    type: "number",
    default: 0
  }, {
    name: "avoidBaseMark",
    type: "boolean",
    default: true
  }, {
    name: "avoidMarks",
    type: "data",
    array: true
  }, {
    name: "method",
    type: "string",
    default: "naive"
  }, {
    name: "as",
    type: "string",
    array: true,
    length: Output$1.length,
    default: Output$1
  }]
};
inherits(Label$1, Transform, {
  transform(_, pulse2) {
    function modp(param2) {
      const p = _[param2];
      return isFunction$3(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || modp("sort"))) return;
    if (!_.size || _.size.length !== 2) {
      error("Size parameter should be specified as a [width, height] array.");
    }
    const as = _.as || Output$1;
    labelLayout(pulse2.materialize(pulse2.SOURCE).source || [], _.size, _.sort, array$5(_.offset == null ? 1 : _.offset), array$5(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || "end", _.markIndex || 0, _.padding === void 0 ? 0 : _.padding, _.method || "naive").forEach((l) => {
      const t4 = l.datum;
      t4[as[0]] = l.x;
      t4[as[1]] = l.y;
      t4[as[2]] = l.opacity;
      t4[as[3]] = l.align;
      t4[as[4]] = l.baseline;
    });
    return pulse2.reflow(mod).modifies(as);
  }
});
const label = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  label: Label$1
}, Symbol.toStringTag, { value: "Module" }));
function partition(data2, groupby) {
  var groups = [], get2 = function(f) {
    return f(t4);
  }, map2, i, n, t4, k, g;
  if (groupby == null) {
    groups.push(data2);
  } else {
    for (map2 = {}, i = 0, n = data2.length; i < n; ++i) {
      t4 = data2[i];
      k = groupby.map(get2);
      g = map2[k];
      if (!g) {
        map2[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(t4);
    }
  }
  return groups;
}
function Loess(params2) {
  Transform.call(this, null, params2);
}
Loess.Definition = {
  "type": "Loess",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0.3
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Loess, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition(source2, _.groupby), names = (_.groupby || []).map(accessorName), m2 = names.length, as = _.as || [accessorName(_.x), accessorName(_.y)], values2 = [];
      groups.forEach((g) => {
        loess(g, _.x, _.y, _.bandwidth || 0.3).forEach((p) => {
          const t4 = {};
          for (let i = 0; i < m2; ++i) {
            t4[names[i]] = g.dims[i];
          }
          t4[as[0]] = p[0];
          t4[as[1]] = p[1];
          values2.push(ingest$1(t4));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});
const Methods = {
  linear: linear$3,
  log: log$4,
  exp: exp$1,
  pow: pow$3,
  quad,
  poly
};
const degreesOfFreedom = (method2, order) => method2 === "poly" ? order : method2 === "quad" ? 2 : 1;
function Regression(params2) {
  Transform.call(this, null, params2);
}
Regression.Definition = {
  "type": "Regression",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "method",
    "type": "string",
    "default": "linear",
    "values": Object.keys(Methods)
  }, {
    "name": "order",
    "type": "number",
    "default": 3
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "params",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Regression, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition(source2, _.groupby), names = (_.groupby || []).map(accessorName), method2 = _.method || "linear", order = _.order || 3, dof = degreesOfFreedom(method2, order), as = _.as || [accessorName(_.x), accessorName(_.y)], fit2 = Methods[method2], values2 = [];
      let domain2 = _.extent;
      if (!has$2(Methods, method2)) {
        error("Invalid regression method: " + method2);
      }
      if (domain2 != null) {
        if (method2 === "log" && domain2[0] <= 0) {
          pulse2.dataflow.warn("Ignoring extent with values <= 0 for log regression.");
          domain2 = null;
        }
      }
      groups.forEach((g) => {
        const n = g.length;
        if (n <= dof) {
          pulse2.dataflow.warn("Skipping regression with more parameters than data points.");
          return;
        }
        const model = fit2(g, _.x, _.y, order);
        if (_.params) {
          values2.push(ingest$1({
            keys: g.dims,
            coef: model.coef,
            rSquared: model.rSquared
          }));
          return;
        }
        const dom = domain2 || extent(g, _.x), add2 = (p) => {
          const t4 = {};
          for (let i = 0; i < names.length; ++i) {
            t4[names[i]] = g.dims[i];
          }
          t4[as[0]] = p[0];
          t4[as[1]] = p[1];
          values2.push(ingest$1(t4));
        };
        if (method2 === "linear") {
          dom.forEach((x2) => add2([x2, model.predict(x2)]));
        } else {
          sampleCurve(model.predict, dom, 25, 200).forEach(add2);
        }
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});
const reg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loess: Loess,
  regression: Regression
}, Symbol.toStringTag, { value: "Module" }));
const epsilon$1 = 11102230246251565e-32;
const splitter = 134217729;
const resulterrbound = (3 + 8 * epsilon$1) * epsilon$1;
function sum(elen, e3, flen, f, h2) {
  let Q, Qnew, hh, bvirt;
  let enow = e3[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e3[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e3[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e3[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h2[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e3[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h2[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e3) {
  let Q = e3[0];
  for (let i = 1; i < elen; i++) Q += e3[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}
const ccwerrboundA = (3 + 16 * epsilon$1) * epsilon$1;
const ccwerrboundB = (2 + 12 * epsilon$1) * epsilon$1;
const ccwerrboundC = (9 + 64 * epsilon$1) * epsilon$1 * epsilon$1;
const B = vec(4);
const C1 = vec(8);
const C2 = vec(12);
const D = vec(16);
const u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c2, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t12, t02, u3;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c2 = splitter * acx;
  ahi = c2 - (c2 - acx);
  alo = acx - ahi;
  c2 = splitter * bcy;
  bhi = c2 - (c2 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t12 = acy * bcx;
  c2 = splitter * acy;
  ahi = c2 - (c2 - acy);
  alo = acy - ahi;
  c2 = splitter * bcx;
  bhi = c2 - (c2 - bcx);
  blo = bcx - bhi;
  t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t02;
  bvirt = s0 - _i;
  B[0] = s0 - (_i + bvirt) + (bvirt - t02);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t12;
  bvirt = _0 - _i;
  B[1] = _0 - (_i + bvirt) + (bvirt - t12);
  u3 = _j + _i;
  bvirt = u3 - _j;
  B[2] = _j - (u3 - bvirt) + (_i - bvirt);
  B[3] = u3;
  let det = estimate(4, B);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c2 = splitter * acxtail;
  ahi = c2 - (c2 - acxtail);
  alo = acxtail - ahi;
  c2 = splitter * bcy;
  bhi = c2 - (c2 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t12 = acytail * bcx;
  c2 = splitter * acytail;
  ahi = c2 - (c2 - acytail);
  alo = acytail - ahi;
  c2 = splitter * bcx;
  bhi = c2 - (c2 - bcx);
  blo = bcx - bhi;
  t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t02;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t02);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t12;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t12);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const C1len = sum(4, B, 4, u, C1);
  s1 = acx * bcytail;
  c2 = splitter * acx;
  ahi = c2 - (c2 - acx);
  alo = acx - ahi;
  c2 = splitter * bcytail;
  bhi = c2 - (c2 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t12 = acy * bcxtail;
  c2 = splitter * acy;
  ahi = c2 - (c2 - acy);
  alo = acy - ahi;
  c2 = splitter * bcxtail;
  bhi = c2 - (c2 - bcxtail);
  blo = bcxtail - bhi;
  t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t02;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t02);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t12;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t12);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const C2len = sum(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c2 = splitter * acxtail;
  ahi = c2 - (c2 - acxtail);
  alo = acxtail - ahi;
  c2 = splitter * bcytail;
  bhi = c2 - (c2 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t12 = acytail * bcxtail;
  c2 = splitter * acytail;
  ahi = c2 - (c2 - acytail);
  alo = acytail - ahi;
  c2 = splitter * bcxtail;
  bhi = c2 - (c2 - bcxtail);
  blo = bcxtail - bhi;
  t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t02;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t02);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t12;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t12);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const Dlen = sum(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0) return det;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}
const EPSILON = Math.pow(2, -52);
const EDGE_STACK = new Uint32Array(512);
class Delaunator {
  static from(points2, getX = defaultGetX, getY = defaultGetY) {
    const n = points2.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p = points2[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }
    return new Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize).fill(-1);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY2 = -Infinity;
    for (let i = 0; i < n; i++) {
      const x2 = coords[2 * i];
      const y2 = coords[2 * i + 1];
      if (x2 < minX) minX = x2;
      if (y2 < minY) minY = y2;
      if (x2 > maxX) maxX = x2;
      if (y2 > maxY2) maxY2 = y2;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY2) / 2;
    let minDist = Infinity;
    let i0, i1, i2;
    for (let i = 0; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    minDist = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0) continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1) continue;
      const r2 = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r2 < minRadius) {
        i2 = i;
        minRadius = r2;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id2 = this._ids[i];
        if (this._dists[id2] > d0) {
          hull[j++] = id2;
          d0 = this._dists[id2];
        }
      }
      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i = i1;
      const x2 = i1x;
      const y2 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x2;
      i2y = y2;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k = 0, xp, yp; k < this._ids.length; k++) {
      const i = this._ids[k];
      const x2 = coords[2 * i];
      const y2 = coords[2 * i + 1];
      if (k > 0 && Math.abs(x2 - xp) <= EPSILON && Math.abs(y2 - yp) <= EPSILON) continue;
      xp = x2;
      yp = y2;
      if (i === i0 || i === i1 || i === i2) continue;
      let start = 0;
      for (let j = 0, key2 = this._hashKey(x2, y2); j < this._hashSize; j++) {
        start = hullHash[(key2 + j) % this._hashSize];
        if (start !== -1 && start !== hullNext[start]) break;
      }
      start = hullPrev[start];
      let e3 = start, q;
      while (q = hullNext[e3], orient2d(x2, y2, coords[2 * e3], coords[2 * e3 + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
        e3 = q;
        if (e3 === start) {
          e3 = -1;
          break;
        }
      }
      if (e3 === -1) continue;
      let t4 = this._addTriangle(e3, i, hullNext[e3], -1, -1, hullTri[e3]);
      hullTri[i] = this._legalize(t4 + 2);
      hullTri[e3] = t4;
      hullSize++;
      let n2 = hullNext[e3];
      while (q = hullNext[n2], orient2d(x2, y2, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
        t4 = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t4 + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q;
      }
      if (e3 === start) {
        while (q = hullPrev[e3], orient2d(x2, y2, coords[2 * q], coords[2 * q + 1], coords[2 * e3], coords[2 * e3 + 1]) < 0) {
          t4 = this._addTriangle(q, i, e3, -1, hullTri[e3], hullTri[q]);
          this._legalize(t4 + 2);
          hullTri[q] = t4;
          hullNext[e3] = e3;
          hullSize--;
          e3 = q;
        }
      }
      this._hullStart = hullPrev[i] = e3;
      hullNext[e3] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x2, y2)] = i;
      hullHash[this._hashKey(coords[2 * e3], coords[2 * e3 + 1])] = e3;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e3 = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e3;
      e3 = hullNext[e3];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x2, y2) {
    return Math.floor(pseudoAngle(x2 - this._cx, y2 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a2) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b2 = halfedges[a2];
      const a0 = a2 - a2 % 3;
      ar = a0 + (a2 + 2) % 3;
      if (b2 === -1) {
        if (i === 0) break;
        a2 = EDGE_STACK[--i];
        continue;
      }
      const b0 = b2 - b2 % 3;
      const al = a0 + (a2 + 1) % 3;
      const bl2 = b0 + (b2 + 2) % 3;
      const p02 = triangles[ar];
      const pr = triangles[a2];
      const pl = triangles[al];
      const p1 = triangles[bl2];
      const illegal = inCircle(
        coords[2 * p02],
        coords[2 * p02 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a2] = p1;
        triangles[b2] = p02;
        const hbl = halfedges[bl2];
        if (hbl === -1) {
          let e3 = this._hullStart;
          do {
            if (this._hullTri[e3] === bl2) {
              this._hullTri[e3] = a2;
              break;
            }
            e3 = this._hullPrev[e3];
          } while (e3 !== this._hullStart);
        }
        this._link(a2, hbl);
        this._link(b2, halfedges[ar]);
        this._link(ar, bl2);
        const br2 = b0 + (b2 + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br2;
        }
      } else {
        if (i === 0) break;
        a2 = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a2, b2) {
    this._halfedges[a2] = b2;
    if (b2 !== -1) this._halfedges[b2] = a2;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a2, b2, c2) {
    const t4 = this.trianglesLen;
    this._triangles[t4] = i0;
    this._triangles[t4 + 1] = i1;
    this._triangles[t4 + 2] = i2;
    this._link(t4, a2);
    this._link(t4 + 1, b2);
    this._link(t4 + 2, c2);
    this.trianglesLen += 3;
    return t4;
  }
}
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px2, py2) {
  const dx = ax - px2;
  const dy = ay - py2;
  const ex = bx - px2;
  const ey = by - py2;
  const fx = cx - px2;
  const fy = cy - py2;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl2 = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x2 = (ey * bl2 - dy * cl) * d;
  const y2 = (dx * cl - ex * bl2) * d;
  return x2 * x2 + y2 * y2;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl2 = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x2 = ax + (ey * bl2 - dy * cl) * d;
  const y2 = ay + (dx * cl - ex * bl2) * d;
  return { x: x2, y: y2 };
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i = left + 1; i <= right; i++) {
      const temp2 = ids[i];
      const tempDist = dists[temp2];
      let j = i - 1;
      while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
      ids[j + 1] = temp2;
    }
  } else {
    const median2 = left + right >> 1;
    let i = left + 1;
    let j = right;
    swap(ids, median2, i);
    if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);
    const temp2 = ids[i];
    const tempDist = dists[temp2];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i) break;
      swap(ids, i, j);
    }
    ids[left + 1] = ids[j];
    ids[j] = temp2;
    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}
const epsilon = 1e-6;
class Path2 {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x2, y2) {
    this._ += `M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x2, y2) {
    this._ += `L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  arc(x2, y2, r2) {
    x2 = +x2, y2 = +y2, r2 = +r2;
    const x02 = x2 + r2;
    const y02 = y2;
    if (r2 < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x02},${y02}`;
    else if (Math.abs(this._x1 - x02) > epsilon || Math.abs(this._y1 - y02) > epsilon) this._ += "L" + x02 + "," + y02;
    if (!r2) return;
    this._ += `A${r2},${r2},0,1,1,${x2 - r2},${y2}A${r2},${r2},0,1,1,${this._x1 = x02},${this._y1 = y02}`;
  }
  rect(x2, y2, w2, h2) {
    this._ += `M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${+w2}v${+h2}h${-w2}Z`;
  }
  value() {
    return this._ || null;
  }
}
class Polygon {
  constructor() {
    this._ = [];
  }
  moveTo(x2, y2) {
    this._.push([x2, y2]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x2, y2) {
    this._.push([x2, y2]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}
let Voronoi$1 = class Voronoi {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points: points2, hull, triangles }, vectors } = this;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x2, y2; i < n; i += 3, j += 2) {
      const t12 = triangles[i] * 2;
      const t22 = triangles[i + 1] * 2;
      const t32 = triangles[i + 2] * 2;
      const x122 = points2[t12];
      const y122 = points2[t12 + 1];
      const x22 = points2[t22];
      const y22 = points2[t22 + 1];
      const x3 = points2[t32];
      const y3 = points2[t32 + 1];
      const dx = x22 - x122;
      const dy = y22 - y122;
      const ex = x3 - x122;
      const ey = y3 - y122;
      const ab = (dx * ey - dy * ex) * 2;
      if (Math.abs(ab) < 1e-9) {
        let a2 = 1e9;
        const r2 = triangles[0] * 2;
        a2 *= Math.sign((points2[r2] - x122) * ey - (points2[r2 + 1] - y122) * ex);
        x2 = (x122 + x3) / 2 - a2 * ey;
        y2 = (y122 + y3) / 2 + a2 * ex;
      } else {
        const d = 1 / ab;
        const bl2 = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        x2 = x122 + (ey * bl2 - dy * cl) * d;
        y2 = y122 + (dx * cl - ex * bl2) * d;
      }
      circumcenters[j] = x2;
      circumcenters[j + 1] = y2;
    }
    let h2 = hull[hull.length - 1];
    let p02, p1 = h2 * 4;
    let x02, x12 = points2[2 * h2];
    let y02, y12 = points2[2 * h2 + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h2 = hull[i];
      p02 = p1, x02 = x12, y02 = y12;
      p1 = h2 * 4, x12 = points2[2 * h2], y12 = points2[2 * h2 + 1];
      vectors[p02 + 2] = vectors[p1] = y02 - y12;
      vectors[p02 + 3] = vectors[p1 + 1] = x12 - x02;
    }
  }
  render(context2) {
    const buffer = context2 == null ? context2 = new Path2() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1) return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context2);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t4 = Math.floor(inedges[h1] / 3) * 2;
      const x2 = circumcenters[t4];
      const y2 = circumcenters[t4 + 1];
      const v = h0 * 4;
      const p = this._project(x2, y2, vectors[v + 2], vectors[v + 3]);
      if (p) this._renderSegment(x2, y2, p[0], p[1], context2);
    }
    return buffer && buffer.value();
  }
  renderBounds(context2) {
    const buffer = context2 == null ? context2 = new Path2() : void 0;
    context2.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context2) {
    const buffer = context2 == null ? context2 = new Path2() : void 0;
    const points2 = this._clip(i);
    if (points2 === null || !points2.length) return;
    context2.moveTo(points2[0], points2[1]);
    let n = points2.length;
    while (points2[0] === points2[n - 2] && points2[1] === points2[n - 1] && n > 1) n -= 2;
    for (let i2 = 2; i2 < n; i2 += 2) {
      if (points2[i2] !== points2[i2 - 2] || points2[i2 + 1] !== points2[i2 - 1])
        context2.lineTo(points2[i2], points2[i2 + 1]);
    }
    context2.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points: points2 } } = this;
    for (let i = 0, n = points2.length / 2; i < n; ++i) {
      const cell2 = this.cellPolygon(i);
      if (cell2) cell2.index = i, yield cell2;
    }
  }
  cellPolygon(i) {
    const polygon = new Polygon();
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x02, y02, x12, y12, context2) {
    let S;
    const c0 = this._regioncode(x02, y02);
    const c1 = this._regioncode(x12, y12);
    if (c0 === 0 && c1 === 0) {
      context2.moveTo(x02, y02);
      context2.lineTo(x12, y12);
    } else if (S = this._clipSegment(x02, y02, x12, y12, c0, c1)) {
      context2.moveTo(S[0], S[1]);
      context2.lineTo(S[2], S[3]);
    }
  }
  contains(i, x2, y2) {
    if ((x2 = +x2, x2 !== x2) || (y2 = +y2, y2 !== y2)) return false;
    return this.delaunay._step(i, x2, y2) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci) for (const j of this.delaunay.neighbors(i)) {
      const cj = this._clip(j);
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
            yield j;
            break loop;
          }
        }
      }
    }
  }
  _cell(i) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i];
    if (e0 === -1) return null;
    const points2 = [];
    let e3 = e0;
    do {
      const t4 = Math.floor(e3 / 3);
      points2.push(circumcenters[t4 * 2], circumcenters[t4 * 2 + 1]);
      e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
      if (triangles[e3] !== i) break;
      e3 = halfedges[e3];
    } while (e3 !== e0 && e3 !== -1);
    return points2;
  }
  _clip(i) {
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points2 = this._cell(i);
    if (points2 === null) return null;
    const { vectors: V } = this;
    const v = i * 4;
    return V[v] || V[v + 1] ? this._clipInfinite(i, points2, V[v], V[v + 1], V[v + 2], V[v + 3]) : this._clipFinite(i, points2);
  }
  _clipFinite(i, points2) {
    const n = points2.length;
    let P = null;
    let x02, y02, x12 = points2[n - 2], y12 = points2[n - 1];
    let c0, c1 = this._regioncode(x12, y12);
    let e0, e1 = 0;
    for (let j = 0; j < n; j += 2) {
      x02 = x12, y02 = y12, x12 = points2[j], y12 = points2[j + 1];
      c0 = c1, c1 = this._regioncode(x12, y12);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x12, y12);
        else P = [x12, y12];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x02, y02, x12, y12, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x12, y12, x02, y02, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);
          else P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);
        else P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x02, y02, x12, y12, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0) return [x02, y02, x12, y12];
      if (c0 & c1) return null;
      let x2, y2, c2 = c0 || c1;
      if (c2 & 8) x2 = x02 + (x12 - x02) * (this.ymax - y02) / (y12 - y02), y2 = this.ymax;
      else if (c2 & 4) x2 = x02 + (x12 - x02) * (this.ymin - y02) / (y12 - y02), y2 = this.ymin;
      else if (c2 & 2) y2 = y02 + (y12 - y02) * (this.xmax - x02) / (x12 - x02), x2 = this.xmax;
      else y2 = y02 + (y12 - y02) * (this.xmin - x02) / (x12 - x02), x2 = this.xmin;
      if (c0) x02 = x2, y02 = y2, c0 = this._regioncode(x02, y02);
      else x12 = x2, y12 = y2, c1 = this._regioncode(x12, y12);
    }
  }
  _clipInfinite(i, points2, vx0, vy0, vxn, vyn) {
    let P = Array.from(points2), p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x2, y2;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        // top-left
        case 4:
          e0 = 6, x2 = this.xmax, y2 = this.ymin;
          break;
        // top
        case 6:
          e0 = 2;
          continue;
        // top-right
        case 2:
          e0 = 10, x2 = this.xmax, y2 = this.ymax;
          break;
        // right
        case 10:
          e0 = 8;
          continue;
        // bottom-right
        case 8:
          e0 = 9, x2 = this.xmin, y2 = this.ymax;
          break;
        // bottom
        case 9:
          e0 = 1;
          continue;
        // bottom-left
        case 1:
          e0 = 5, x2 = this.xmin, y2 = this.ymin;
          break;
      }
      if ((P[j] !== x2 || P[j + 1] !== y2) && this.contains(i, x2, y2)) {
        P.splice(j, 0, x2, y2), j += 2;
      }
    }
    if (P.length > 4) {
      for (let i2 = 0; i2 < P.length; i2 += 2) {
        const j2 = (i2 + 2) % P.length, k = (i2 + 4) % P.length;
        if (P[i2] === P[j2] && P[j2] === P[k] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k + 1])
          P.splice(j2, 2), i2 -= 2;
      }
    }
    return j;
  }
  _project(x02, y02, vx, vy) {
    let t4 = Infinity, c2, x2, y2;
    if (vy < 0) {
      if (y02 <= this.ymin) return null;
      if ((c2 = (this.ymin - y02) / vy) < t4) y2 = this.ymin, x2 = x02 + (t4 = c2) * vx;
    } else if (vy > 0) {
      if (y02 >= this.ymax) return null;
      if ((c2 = (this.ymax - y02) / vy) < t4) y2 = this.ymax, x2 = x02 + (t4 = c2) * vx;
    }
    if (vx > 0) {
      if (x02 >= this.xmax) return null;
      if ((c2 = (this.xmax - x02) / vx) < t4) x2 = this.xmax, y2 = y02 + (t4 = c2) * vy;
    } else if (vx < 0) {
      if (x02 <= this.xmin) return null;
      if ((c2 = (this.xmin - x02) / vx) < t4) x2 = this.xmin, y2 = y02 + (t4 = c2) * vy;
    }
    return [x2, y2];
  }
  _edgecode(x2, y2) {
    return (x2 === this.xmin ? 1 : x2 === this.xmax ? 2 : 0) | (y2 === this.ymin ? 4 : y2 === this.ymax ? 8 : 0);
  }
  _regioncode(x2, y2) {
    return (x2 < this.xmin ? 1 : x2 > this.xmax ? 2 : 0) | (y2 < this.ymin ? 4 : y2 > this.ymax ? 8 : 0);
  }
};
const tau = 2 * Math.PI, pow = Math.pow;
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear(d) {
  const { triangles, coords } = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a2 = 2 * triangles[i], b2 = 2 * triangles[i + 1], c2 = 2 * triangles[i + 2], cross2 = (coords[c2] - coords[a2]) * (coords[b2 + 1] - coords[a2 + 1]) - (coords[b2] - coords[a2]) * (coords[c2 + 1] - coords[a2 + 1]);
    if (cross2 > 1e-10) return false;
  }
  return true;
}
function jitter(x2, y2, r2) {
  return [x2 + Math.sin(x2 + y2) * r2, y2 + Math.cos(x2 - y2) * r2];
}
class Delaunay {
  static from(points2, fx = pointX, fy = pointY, that) {
    return new Delaunay("length" in points2 ? flatArray(points2, fx, fy, that) : Float64Array.from(flatIterable(points2, fx, fy, that)));
  }
  constructor(points2) {
    this._delaunator = new Delaunator(points2);
    this.inedges = new Int32Array(points2.length / 2);
    this._hullIndex = new Int32Array(points2.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points2 = this.points;
    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({ length: points2.length / 2 }, (_, i) => i).sort((i, j) => points2[2 * i] - points2[2 * j] || points2[2 * i + 1] - points2[2 * j + 1]);
      const e3 = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds2 = [points2[2 * e3], points2[2 * e3 + 1], points2[2 * f], points2[2 * f + 1]], r2 = 1e-8 * Math.hypot(bounds2[3] - bounds2[1], bounds2[2] - bounds2[0]);
      for (let i = 0, n = points2.length / 2; i < n; ++i) {
        const p = jitter(points2[2 * i], points2[2 * i + 1], r2);
        points2[2 * i] = p[0];
        points2[2 * i + 1] = p[1];
      }
      this._delaunator = new Delaunator(points2);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e3 = 0, n = halfedges.length; e3 < n; ++e3) {
      const p = triangles[e3 % 3 === 2 ? e3 - 2 : e3 + 1];
      if (halfedges[e3] === -1 || inedges[p] === -1) inedges[p] = e3;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      inedges[hull[0]] = 1;
      if (hull.length === 2) {
        inedges[hull[1]] = 0;
        this.triangles[1] = hull[1];
        this.triangles[2] = hull[1];
      }
    }
  }
  voronoi(bounds2) {
    return new Voronoi$1(this, bounds2);
  }
  *neighbors(i) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear2 } = this;
    if (collinear2) {
      const l = collinear2.indexOf(i);
      if (l > 0) yield collinear2[l - 1];
      if (l < collinear2.length - 1) yield collinear2[l + 1];
      return;
    }
    const e0 = inedges[i];
    if (e0 === -1) return;
    let e3 = e0, p02 = -1;
    do {
      yield p02 = triangles[e3];
      e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
      if (triangles[e3] !== i) return;
      e3 = halfedges[e3];
      if (e3 === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p02) yield p;
        return;
      }
    } while (e3 !== e0);
  }
  find(x2, y2, i = 0) {
    if ((x2 = +x2, x2 !== x2) || (y2 = +y2, y2 !== y2)) return -1;
    const i0 = i;
    let c2;
    while ((c2 = this._step(i, x2, y2)) >= 0 && c2 !== i && c2 !== i0) i = c2;
    return c2;
  }
  _step(i, x2, y2) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points: points2 } = this;
    if (inedges[i] === -1 || !points2.length) return (i + 1) % (points2.length >> 1);
    let c2 = i;
    let dc = pow(x2 - points2[i * 2], 2) + pow(y2 - points2[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e3 = e0;
    do {
      let t4 = triangles[e3];
      const dt = pow(x2 - points2[t4 * 2], 2) + pow(y2 - points2[t4 * 2 + 1], 2);
      if (dt < dc) dc = dt, c2 = t4;
      e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
      if (triangles[e3] !== i) break;
      e3 = halfedges[e3];
      if (e3 === -1) {
        e3 = hull[(_hullIndex[i] + 1) % hull.length];
        if (e3 !== t4) {
          if (pow(x2 - points2[e3 * 2], 2) + pow(y2 - points2[e3 * 2 + 1], 2) < dc) return e3;
        }
        break;
      }
    } while (e3 !== e0);
    return c2;
  }
  render(context2) {
    const buffer = context2 == null ? context2 = new Path2() : void 0;
    const { points: points2, halfedges, triangles } = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context2.moveTo(points2[ti], points2[ti + 1]);
      context2.lineTo(points2[tj], points2[tj + 1]);
    }
    this.renderHull(context2);
    return buffer && buffer.value();
  }
  renderPoints(context2, r2) {
    if (r2 === void 0 && (!context2 || typeof context2.moveTo !== "function")) r2 = context2, context2 = null;
    r2 = r2 == void 0 ? 2 : +r2;
    const buffer = context2 == null ? context2 = new Path2() : void 0;
    const { points: points2 } = this;
    for (let i = 0, n = points2.length; i < n; i += 2) {
      const x2 = points2[i], y2 = points2[i + 1];
      context2.moveTo(x2 + r2, y2);
      context2.arc(x2, y2, r2, 0, tau);
    }
    return buffer && buffer.value();
  }
  renderHull(context2) {
    const buffer = context2 == null ? context2 = new Path2() : void 0;
    const { hull, points: points2 } = this;
    const h2 = hull[0] * 2, n = hull.length;
    context2.moveTo(points2[h2], points2[h2 + 1]);
    for (let i = 1; i < n; ++i) {
      const h22 = 2 * hull[i];
      context2.lineTo(points2[h22], points2[h22 + 1]);
    }
    context2.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context2) {
    const buffer = context2 == null ? context2 = new Path2() : void 0;
    const { points: points2, triangles } = this;
    const t02 = triangles[i *= 3] * 2;
    const t12 = triangles[i + 1] * 2;
    const t22 = triangles[i + 2] * 2;
    context2.moveTo(points2[t02], points2[t02 + 1]);
    context2.lineTo(points2[t12], points2[t12 + 1]);
    context2.lineTo(points2[t22], points2[t22 + 1]);
    context2.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new Polygon();
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
}
function flatArray(points2, fx, fy, that) {
  const n = points2.length;
  const array2 = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points2[i];
    array2[i * 2] = fx.call(that, p, i, points2);
    array2[i * 2 + 1] = fy.call(that, p, i, points2);
  }
  return array2;
}
function* flatIterable(points2, fx, fy, that) {
  let i = 0;
  for (const p of points2) {
    yield fx.call(that, p, i, points2);
    yield fy.call(that, p, i, points2);
    ++i;
  }
}
function Voronoi2(params2) {
  Transform.call(this, null, params2);
}
Voronoi2.Definition = {
  "type": "Voronoi",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "extent",
    "type": "array",
    "array": true,
    "length": 2,
    "default": [[-1e5, -1e5], [1e5, 1e5]],
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
const defaultExtent = [-1e5, -1e5, 1e5, 1e5];
inherits(Voronoi2, Transform, {
  transform(_, pulse2) {
    const as = _.as || "path", data2 = pulse2.source;
    if (!data2 || !data2.length) return pulse2;
    let s = _.size;
    s = s ? [0, 0, s[0], s[1]] : (s = _.extent) ? [s[0][0], s[0][1], s[1][0], s[1][1]] : defaultExtent;
    const voronoi2 = this.value = Delaunay.from(data2, _.x, _.y).voronoi(s);
    for (let i = 0, n = data2.length; i < n; ++i) {
      const polygon = voronoi2.cellPolygon(i);
      data2[i][as] = polygon ? toPathString(polygon) : null;
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function toPathString(p) {
  const x2 = p[0][0], y2 = p[0][1];
  let n = p.length - 1;
  for (; p[n][0] === x2 && p[n][1] === y2; --n) ;
  return "M" + p.slice(0, n + 1).join("L") + "Z";
}
const voronoi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  voronoi: Voronoi2
}, Symbol.toStringTag, { value: "Module" }));
var cloudRadians = Math.PI / 180, cw = 1 << 11 >> 5, ch = 1 << 11;
function cloud() {
  var size = [256, 256], text2, font2, fontSize2, fontStyle, fontWeight, rotate2, padding2, spiral = archimedeanSpiral, words = [], random2 = Math.random, cloud2 = {};
  cloud2.layout = function() {
    var contextAndRatio = getContext2(domCanvas()), board = zeroArray((size[0] >> 5) * size[1]), bounds2 = null, n = words.length, i = -1, tags = [], data2 = words.map((d2) => ({
      text: text2(d2),
      font: font2(d2),
      style: fontStyle(d2),
      weight: fontWeight(d2),
      rotate: rotate2(d2),
      size: ~~(fontSize2(d2) + 1e-14),
      padding: padding2(d2),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d2
    })).sort((a2, b2) => b2.size - a2.size);
    while (++i < n) {
      var d = data2[i];
      d.x = size[0] * (random2() + 0.5) >> 1;
      d.y = size[1] * (random2() + 0.5) >> 1;
      cloudSprite(contextAndRatio, d, data2, i);
      if (d.hasText && place2(board, d, bounds2)) {
        tags.push(d);
        if (bounds2) cloudBounds(bounds2, d);
        else bounds2 = [{
          x: d.x + d.x0,
          y: d.y + d.y0
        }, {
          x: d.x + d.x1,
          y: d.y + d.y1
        }];
        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }
    return tags;
  };
  function getContext2(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context2 = canvas.getContext("2d");
    context2.fillStyle = context2.strokeStyle = "red";
    context2.textAlign = "center";
    return {
      context: context2,
      ratio
    };
  }
  function place2(board, tag, bounds2) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = random2() < 0.5 ? 1 : -1, t4 = -dt, dxdy, dx, dy;
    while (dxdy = s(t4 += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;
      if (!bounds2 || !cloudCollide(tag, board, size[0])) {
        if (!bounds2 || collideRects(tag, bounds2)) {
          var sprite = tag.sprite, w2 = tag.width >> 5, sw = size[0] >> 5, lx2 = tag.x - (w2 << 4), sx = lx2 & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0, x2 = (tag.y + tag.y0) * sw + (lx2 >> 5), last;
          for (var j = 0; j < h2; j++) {
            last = 0;
            for (var i = 0; i <= w2; i++) {
              board[x2 + i] |= last << msx | (i < w2 ? (last = sprite[j * w2 + i]) >>> sx : 0);
            }
            x2 += sw;
          }
          tag.sprite = null;
          return true;
        }
      }
    }
    return false;
  }
  cloud2.words = function(_) {
    if (arguments.length) {
      words = _;
      return cloud2;
    } else {
      return words;
    }
  };
  cloud2.size = function(_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud2;
    } else {
      return size;
    }
  };
  cloud2.font = function(_) {
    if (arguments.length) {
      font2 = functor(_);
      return cloud2;
    } else {
      return font2;
    }
  };
  cloud2.fontStyle = function(_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud2;
    } else {
      return fontStyle;
    }
  };
  cloud2.fontWeight = function(_) {
    if (arguments.length) {
      fontWeight = functor(_);
      return cloud2;
    } else {
      return fontWeight;
    }
  };
  cloud2.rotate = function(_) {
    if (arguments.length) {
      rotate2 = functor(_);
      return cloud2;
    } else {
      return rotate2;
    }
  };
  cloud2.text = function(_) {
    if (arguments.length) {
      text2 = functor(_);
      return cloud2;
    } else {
      return text2;
    }
  };
  cloud2.spiral = function(_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud2;
    } else {
      return spiral;
    }
  };
  cloud2.fontSize = function(_) {
    if (arguments.length) {
      fontSize2 = functor(_);
      return cloud2;
    } else {
      return fontSize2;
    }
  };
  cloud2.padding = function(_) {
    if (arguments.length) {
      padding2 = functor(_);
      return cloud2;
    } else {
      return padding2;
    }
  };
  cloud2.random = function(_) {
    if (arguments.length) {
      random2 = _;
      return cloud2;
    } else {
      return random2;
    }
  };
  return cloud2;
}
function cloudSprite(contextAndRatio, d, data2, di) {
  if (d.sprite) return;
  var c2 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c2.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x2 = 0, y2 = 0, maxh = 0, n = data2.length, w2, w32, h2, i, j;
  --di;
  while (++di < n) {
    d = data2[di];
    c2.save();
    c2.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    w2 = c2.measureText(d.text + "m").width * ratio;
    h2 = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr2 = Math.cos(d.rotate * cloudRadians), wcr = w2 * cr2, wsr = w2 * sr, hcr = h2 * cr2, hsr = h2 * sr;
      w2 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w2 = w2 + 31 >> 5 << 5;
    }
    if (h2 > maxh) maxh = h2;
    if (x2 + w2 >= cw << 5) {
      x2 = 0;
      y2 += maxh;
      maxh = 0;
    }
    if (y2 + h2 >= ch) break;
    c2.translate((x2 + (w2 >> 1)) / ratio, (y2 + (h2 >> 1)) / ratio);
    if (d.rotate) c2.rotate(d.rotate * cloudRadians);
    c2.fillText(d.text, 0, 0);
    if (d.padding) {
      c2.lineWidth = 2 * d.padding;
      c2.strokeText(d.text, 0, 0);
    }
    c2.restore();
    d.width = w2;
    d.height = h2;
    d.xoff = x2;
    d.yoff = y2;
    d.x1 = w2 >> 1;
    d.y1 = h2 >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x2 += w2;
  }
  var pixels = c2.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data2[di];
    if (!d.hasText) continue;
    w2 = d.width;
    w32 = w2 >> 5;
    h2 = d.y1 - d.y0;
    for (i = 0; i < h2 * w32; i++) sprite[i] = 0;
    x2 = d.xoff;
    if (x2 == null) return;
    y2 = d.yoff;
    var seen = 0, seenRow = -1;
    for (j = 0; j < h2; j++) {
      for (i = 0; i < w2; i++) {
        var k = w32 * j + (i >> 5), m2 = pixels[(y2 + j) * (cw << 5) + (x2 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m2;
        seen |= m2;
      }
      if (seen) seenRow = j;
      else {
        d.y0++;
        h2--;
        j--;
        y2++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w2 = tag.width >> 5, lx2 = tag.x - (w2 << 4), sx = lx2 & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0, x2 = (tag.y + tag.y0) * sw + (lx2 >> 5), last;
  for (var j = 0; j < h2; j++) {
    last = 0;
    for (var i = 0; i <= w2; i++) {
      if ((last << msx | (i < w2 ? (last = sprite[j * w2 + i]) >>> sx : 0)) & board[x2 + i]) return true;
    }
    x2 += sw;
  }
  return false;
}
function cloudBounds(bounds2, d) {
  var b0 = bounds2[0], b1 = bounds2[1];
  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
}
function collideRects(a2, b2) {
  return a2.x + a2.x1 > b2[0].x && a2.x + a2.x0 < b2[1].x && a2.y + a2.y1 > b2[0].y && a2.y + a2.y0 < b2[1].y;
}
function archimedeanSpiral(size) {
  var e3 = size[0] / size[1];
  return function(t4) {
    return [e3 * (t4 *= 0.1) * Math.cos(t4), t4 * Math.sin(t4)];
  };
}
function rectangularSpiral(size) {
  var dy = 4, dx = dy * size[0] / size[1], x2 = 0, y2 = 0;
  return function(t4) {
    var sign2 = t4 < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign2 * t4) - sign2 & 3) {
      case 0:
        x2 += dx;
        break;
      case 1:
        y2 += dy;
        break;
      case 2:
        x2 -= dx;
        break;
      default:
        y2 -= dy;
        break;
    }
    return [x2, y2];
  };
}
function zeroArray(n) {
  var a2 = [], i = -1;
  while (++i < n) a2[i] = 0;
  return a2;
}
function functor(d) {
  return typeof d === "function" ? d : function() {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
const Output = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"];
const Params$1 = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
function Wordcloud(params2) {
  Transform.call(this, cloud(), params2);
}
Wordcloud.Definition = {
  "type": "Wordcloud",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "font",
    "type": "string",
    "expr": true,
    "default": "sans-serif"
  }, {
    "name": "fontStyle",
    "type": "string",
    "expr": true,
    "default": "normal"
  }, {
    "name": "fontWeight",
    "type": "string",
    "expr": true,
    "default": "normal"
  }, {
    "name": "fontSize",
    "type": "number",
    "expr": true,
    "default": 14
  }, {
    "name": "fontSizeRange",
    "type": "number",
    "array": "nullable",
    "default": [10, 50]
  }, {
    "name": "rotate",
    "type": "number",
    "expr": true,
    "default": 0
  }, {
    "name": "text",
    "type": "field"
  }, {
    "name": "spiral",
    "type": "string",
    "values": ["archimedean", "rectangular"]
  }, {
    "name": "padding",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 7,
    "default": Output
  }]
};
inherits(Wordcloud, Transform, {
  transform(_, pulse2) {
    if (_.size && !(_.size[0] && _.size[1])) {
      error("Wordcloud size dimensions must be non-zero.");
    }
    function modp(param2) {
      const p = _[param2];
      return isFunction$3(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || Params$1.some(modp))) return;
    const data2 = pulse2.materialize(pulse2.SOURCE).source, layout = this.value, as = _.as || Output;
    let fontSize2 = _.fontSize || 14, range2;
    isFunction$3(fontSize2) ? range2 = _.fontSizeRange : fontSize2 = constant$5(fontSize2);
    if (range2) {
      const fsize = fontSize2, sizeScale = scale$4("sqrt")().domain(extent(data2, fsize)).range(range2);
      fontSize2 = (x2) => sizeScale(fsize(x2));
    }
    data2.forEach((t4) => {
      t4[as[0]] = NaN;
      t4[as[1]] = NaN;
      t4[as[3]] = 0;
    });
    const words = layout.words(data2).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || "archimedean").rotate(_.rotate || 0).font(_.font || "sans-serif").fontStyle(_.fontStyle || "normal").fontWeight(_.fontWeight || "normal").fontSize(fontSize2).random(random).layout();
    const size = layout.size(), dx = size[0] >> 1, dy = size[1] >> 1, n = words.length;
    for (let i = 0, w2, t4; i < n; ++i) {
      w2 = words[i];
      t4 = w2.datum;
      t4[as[0]] = w2.x + dx;
      t4[as[1]] = w2.y + dy;
      t4[as[2]] = w2.font;
      t4[as[3]] = w2.size;
      t4[as[4]] = w2.style;
      t4[as[5]] = w2.weight;
      t4[as[6]] = w2.rotate;
    }
    return pulse2.reflow(mod).modifies(as);
  }
});
const wordcloud = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  wordcloud: Wordcloud
}, Symbol.toStringTag, { value: "Module" }));
const array8 = (n) => new Uint8Array(n);
const array16 = (n) => new Uint16Array(n);
const array32 = (n) => new Uint32Array(n);
function Bitmaps() {
  let width2 = 8, data2 = [], seen = array32(0), curr = array$1(0, width2), prev2 = array$1(0, width2);
  return {
    data: () => data2,
    seen: () => seen = lengthen(seen, data2.length),
    add(array2) {
      for (let i = 0, j = data2.length, n = array2.length, t4; i < n; ++i) {
        t4 = array2[i];
        t4._index = j++;
        data2.push(t4);
      }
    },
    remove(num, map2) {
      const n = data2.length, copy2 = Array(n - num), reindex = data2;
      let t4, i, j;
      for (i = 0; !map2[i] && i < n; ++i) {
        copy2[i] = data2[i];
        reindex[i] = i;
      }
      for (j = i; i < n; ++i) {
        t4 = data2[i];
        if (!map2[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev2[j] = prev2[i];
          copy2[j] = t4;
          t4._index = j++;
        } else {
          reindex[i] = -1;
        }
        curr[i] = 0;
      }
      data2 = copy2;
      return reindex;
    },
    size: () => data2.length,
    curr: () => curr,
    prev: () => prev2,
    reset: (k) => prev2[k] = curr[k],
    all: () => width2 < 257 ? 255 : width2 < 65537 ? 65535 : 4294967295,
    set(k, one2) {
      curr[k] |= one2;
    },
    clear(k, one2) {
      curr[k] &= ~one2;
    },
    resize(n, m2) {
      const k = curr.length;
      if (n > k || m2 > width2) {
        width2 = Math.max(m2, width2);
        curr = array$1(n, width2, curr);
        prev2 = array$1(n, width2);
      }
    }
  };
}
function lengthen(array2, length2, copy2) {
  if (array2.length >= length2) return array2;
  copy2 = copy2 || new array2.constructor(length2);
  copy2.set(array2);
  return copy2;
}
function array$1(n, m2, array2) {
  const copy2 = (m2 < 257 ? array8 : m2 < 65537 ? array16 : array32)(n);
  if (array2) copy2.set(array2);
  return copy2;
}
function Dimension(index2, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index2.bisect,
    index: index2.index,
    size: index2.size,
    onAdd(added, curr) {
      const dim = this, range2 = dim.bisect(dim.range, added.value), idx = added.index, lo = range2[0], hi = range2[1], n1 = idx.length;
      let i2;
      for (i2 = 0; i2 < lo; ++i2) curr[idx[i2]] |= bit;
      for (i2 = hi; i2 < n1; ++i2) curr[idx[i2]] |= bit;
      return dim;
    }
  };
}
function SortedIndex() {
  let index2 = array32(0), value2 = [], size = 0;
  function insert2(key2, data2, base2) {
    if (!data2.length) return [];
    const n0 = size, n1 = data2.length, addi = array32(n1);
    let addv = Array(n1), oldv, oldi, i;
    for (i = 0; i < n1; ++i) {
      addv[i] = key2(data2[i]);
      addi[i] = i;
    }
    addv = sort(addv, addi);
    if (n0) {
      oldv = value2;
      oldi = index2;
      value2 = Array(n0 + n1);
      index2 = array32(n0 + n1);
      merge$2(base2, oldv, oldi, n0, addv, addi, n1, value2, index2);
    } else {
      if (base2 > 0) for (i = 0; i < n1; ++i) {
        addi[i] += base2;
      }
      value2 = addv;
      index2 = addi;
    }
    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }
  function remove2(num, map2) {
    const n = size;
    let idx, i, j;
    for (i = 0; !map2[index2[i]] && i < n; ++i) ;
    for (j = i; i < n; ++i) {
      if (!map2[idx = index2[i]]) {
        index2[j] = idx;
        value2[j] = value2[i];
        ++j;
      }
    }
    size = n - num;
  }
  function reindex(map2) {
    for (let i = 0, n = size; i < n; ++i) {
      index2[i] = map2[index2[i]];
    }
  }
  function bisect2(range2, array2) {
    let n;
    if (array2) {
      n = array2.length;
    } else {
      array2 = value2;
      n = size;
    }
    return [bisectLeft$1(array2, range2[0], 0, n), bisectRight$1(array2, range2[1], 0, n)];
  }
  return {
    insert: insert2,
    remove: remove2,
    bisect: bisect2,
    reindex,
    index: () => index2,
    size: () => size
  };
}
function sort(values2, index2) {
  values2.sort.call(index2, (a2, b2) => {
    const x2 = values2[a2], y2 = values2[b2];
    return x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
  });
  return permute(values2, index2);
}
function merge$2(base2, value0, index0, n0, value1, index1, n1, value2, index2) {
  let i0 = 0, i1 = 0, i;
  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value2[i] = value0[i0];
      index2[i] = index0[i0++];
    } else {
      value2[i] = value1[i1];
      index2[i] = index1[i1++] + base2;
    }
  }
  for (; i0 < n0; ++i0, ++i) {
    value2[i] = value0[i0];
    index2[i] = index0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    value2[i] = value1[i1];
    index2[i] = index1[i1] + base2;
  }
}
function CrossFilter(params2) {
  Transform.call(this, Bitmaps(), params2);
  this._indices = null;
  this._dims = null;
}
CrossFilter.Definition = {
  "type": "CrossFilter",
  "metadata": {},
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "query",
    "type": "array",
    "array": true,
    "required": true,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }]
};
inherits(CrossFilter, Transform, {
  transform(_, pulse2) {
    if (!this._dims) {
      return this.init(_, pulse2);
    } else {
      var init2 = _.modified("fields") || _.fields.some((f) => pulse2.modified(f.fields));
      return init2 ? this.reinit(_, pulse2) : this.eval(_, pulse2);
    }
  },
  init(_, pulse2) {
    const fields = _.fields, query = _.query, indices = this._indices = {}, dims = this._dims = [], m2 = query.length;
    let i = 0, key2, index2;
    for (; i < m2; ++i) {
      key2 = fields[i].fname;
      index2 = indices[key2] || (indices[key2] = SortedIndex());
      dims.push(Dimension(index2, i, query[i]));
    }
    return this.eval(_, pulse2);
  },
  reinit(_, pulse2) {
    const output2 = pulse2.materialize().fork(), fields = _.fields, query = _.query, indices = this._indices, dims = this._dims, bits = this.value, curr = bits.curr(), prev2 = bits.prev(), all = bits.all(), out = output2.rem = output2.add, mod = output2.mod, m2 = query.length, adds = {};
    let add2, index2, key2, mods, remMap, modMap, i, n, f;
    prev2.set(curr);
    if (pulse2.rem.length) {
      remMap = this.remove(_, pulse2, output2);
    }
    if (pulse2.add.length) {
      bits.add(pulse2.add);
    }
    if (pulse2.mod.length) {
      modMap = {};
      for (mods = pulse2.mod, i = 0, n = mods.length; i < n; ++i) {
        modMap[mods[i]._index] = 1;
      }
    }
    for (i = 0; i < m2; ++i) {
      f = fields[i];
      if (!dims[i] || _.modified("fields", i) || pulse2.modified(f.fields)) {
        key2 = f.fname;
        if (!(add2 = adds[key2])) {
          indices[key2] = index2 = SortedIndex();
          adds[key2] = add2 = index2.insert(f, pulse2.source, 0);
        }
        dims[i] = Dimension(index2, i, query[i]).onAdd(add2, curr);
      }
    }
    for (i = 0, n = bits.data().length; i < n; ++i) {
      if (remMap[i]) {
        continue;
      } else if (prev2[i] !== curr[i]) {
        out.push(i);
      } else if (modMap[i] && curr[i] !== all) {
        mod.push(i);
      }
    }
    bits.mask = (1 << m2) - 1;
    return output2;
  },
  eval(_, pulse2) {
    const output2 = pulse2.materialize().fork(), m2 = this._dims.length;
    let mask = 0;
    if (pulse2.rem.length) {
      this.remove(_, pulse2, output2);
      mask |= (1 << m2) - 1;
    }
    if (_.modified("query") && !_.modified("fields")) {
      mask |= this.update(_, pulse2, output2);
    }
    if (pulse2.add.length) {
      this.insert(_, pulse2, output2);
      mask |= (1 << m2) - 1;
    }
    if (pulse2.mod.length) {
      this.modify(pulse2, output2);
      mask |= (1 << m2) - 1;
    }
    this.value.mask = mask;
    return output2;
  },
  insert(_, pulse2, output2) {
    const tuples = pulse2.add, bits = this.value, dims = this._dims, indices = this._indices, fields = _.fields, adds = {}, out = output2.add, n = bits.size() + tuples.length, m2 = dims.length;
    let k = bits.size(), j, key2, add2;
    bits.resize(n, m2);
    bits.add(tuples);
    const curr = bits.curr(), prev2 = bits.prev(), all = bits.all();
    for (j = 0; j < m2; ++j) {
      key2 = fields[j].fname;
      add2 = adds[key2] || (adds[key2] = indices[key2].insert(fields[j], tuples, k));
      dims[j].onAdd(add2, curr);
    }
    for (; k < n; ++k) {
      prev2[k] = all;
      if (curr[k] !== all) out.push(k);
    }
  },
  modify(pulse2, output2) {
    const out = output2.mod, bits = this.value, curr = bits.curr(), all = bits.all(), tuples = pulse2.mod;
    let i, n, k;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      if (curr[k] !== all) out.push(k);
    }
  },
  remove(_, pulse2, output2) {
    const indices = this._indices, bits = this.value, curr = bits.curr(), prev2 = bits.prev(), all = bits.all(), map2 = {}, out = output2.rem, tuples = pulse2.rem;
    let i, n, k, f;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      map2[k] = 1;
      prev2[k] = f = curr[k];
      curr[k] = all;
      if (f !== all) out.push(k);
    }
    for (k in indices) {
      indices[k].remove(n, map2);
    }
    this.reindex(pulse2, n, map2);
    return map2;
  },
  // reindex filters and indices after propagation completes
  reindex(pulse2, num, map2) {
    const indices = this._indices, bits = this.value;
    pulse2.runAfter(() => {
      const indexMap = bits.remove(num, map2);
      for (const key2 in indices) indices[key2].reindex(indexMap);
    });
  },
  update(_, pulse2, output2) {
    const dims = this._dims, query = _.query, stamp = pulse2.stamp, m2 = dims.length;
    let mask = 0, i, q;
    output2.filters = 0;
    for (q = 0; q < m2; ++q) {
      if (_.modified("query", q)) {
        i = q;
        ++mask;
      }
    }
    if (mask === 1) {
      mask = dims[i].one;
      this.incrementOne(dims[i], query[i], output2.add, output2.rem);
    } else {
      for (q = 0, mask = 0; q < m2; ++q) {
        if (!_.modified("query", q)) continue;
        mask |= dims[q].one;
        this.incrementAll(dims[q], query[q], stamp, output2.add);
        output2.rem = output2.add;
      }
    }
    return mask;
  },
  incrementAll(dim, query, stamp, out) {
    const bits = this.value, seen = bits.seen(), curr = bits.curr(), prev2 = bits.prev(), index2 = dim.index(), old = dim.bisect(dim.range), range2 = dim.bisect(query), lo1 = range2[0], hi1 = range2[1], lo0 = old[0], hi0 = old[1], one2 = dim.one;
    let i, j, k;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index2[i];
        if (seen[k] !== stamp) {
          prev2[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one2;
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index2[i];
        if (seen[k] !== stamp) {
          prev2[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one2;
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index2[i];
        if (seen[k] !== stamp) {
          prev2[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one2;
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index2[i];
        if (seen[k] !== stamp) {
          prev2[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one2;
      }
    }
    dim.range = query.slice();
  },
  incrementOne(dim, query, add2, rem2) {
    const bits = this.value, curr = bits.curr(), index2 = dim.index(), old = dim.bisect(dim.range), range2 = dim.bisect(query), lo1 = range2[0], hi1 = range2[1], lo0 = old[0], hi0 = old[1], one2 = dim.one;
    let i, j, k;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index2[i];
        curr[k] ^= one2;
        add2.push(k);
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index2[i];
        curr[k] ^= one2;
        rem2.push(k);
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index2[i];
        curr[k] ^= one2;
        add2.push(k);
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index2[i];
        curr[k] ^= one2;
        rem2.push(k);
      }
    }
    dim.range = query.slice();
  }
});
function ResolveFilter(params2) {
  Transform.call(this, null, params2);
}
ResolveFilter.Definition = {
  "type": "ResolveFilter",
  "metadata": {},
  "params": [{
    "name": "ignore",
    "type": "number",
    "required": true,
    "description": "A bit mask indicating which filters to ignore."
  }, {
    "name": "filter",
    "type": "object",
    "required": true,
    "description": "Per-tuple filter bitmaps from a CrossFilter transform."
  }]
};
inherits(ResolveFilter, Transform, {
  transform(_, pulse2) {
    const ignore = ~(_.ignore || 0), bitmap = _.filter, mask = bitmap.mask;
    if ((mask & ignore) === 0) return pulse2.StopPropagation;
    const output2 = pulse2.fork(pulse2.ALL), data2 = bitmap.data(), curr = bitmap.curr(), prev2 = bitmap.prev(), pass = (k) => !(curr[k] & ignore) ? data2[k] : null;
    output2.filter(output2.MOD, pass);
    if (!(mask & mask - 1)) {
      output2.filter(output2.ADD, pass);
      output2.filter(output2.REM, (k) => (curr[k] & ignore) === mask ? data2[k] : null);
    } else {
      output2.filter(output2.ADD, (k) => {
        const c2 = curr[k] & ignore, f = !c2 && c2 ^ prev2[k] & ignore;
        return f ? data2[k] : null;
      });
      output2.filter(output2.REM, (k) => {
        const c2 = curr[k] & ignore, f = c2 && !(c2 ^ (c2 ^ prev2[k] & ignore));
        return f ? data2[k] : null;
      });
    }
    return output2.filter(output2.SOURCE, (t4) => pass(t4._index));
  }
});
const xf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  crossfilter: CrossFilter,
  resolvefilter: ResolveFilter
}, Symbol.toStringTag, { value: "Module" }));
const RawCode = "RawCode";
const Literal = "Literal";
const Property = "Property";
const Identifier = "Identifier";
const ArrayExpression = "ArrayExpression";
const BinaryExpression = "BinaryExpression";
const CallExpression = "CallExpression";
const ConditionalExpression = "ConditionalExpression";
const LogicalExpression = "LogicalExpression";
const MemberExpression = "MemberExpression";
const ObjectExpression = "ObjectExpression";
const UnaryExpression = "UnaryExpression";
function ASTNode(type2) {
  this.type = type2;
}
ASTNode.prototype.visit = function(visitor) {
  let c2, i, n;
  if (visitor(this)) return 1;
  for (c2 = children(this), i = 0, n = c2.length; i < n; ++i) {
    if (c2[i].visit(visitor)) return 1;
  }
};
function children(node2) {
  switch (node2.type) {
    case ArrayExpression:
      return node2.elements;
    case BinaryExpression:
    case LogicalExpression:
      return [node2.left, node2.right];
    case CallExpression:
      return [node2.callee].concat(node2.arguments);
    case ConditionalExpression:
      return [node2.test, node2.consequent, node2.alternate];
    case MemberExpression:
      return [node2.object, node2.property];
    case ObjectExpression:
      return node2.properties;
    case Property:
      return [node2.key, node2.value];
    case UnaryExpression:
      return [node2.argument];
    case Identifier:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}
var TokenName, source, index, length$1, lookahead;
var TokenBooleanLiteral = 1, TokenEOF = 2, TokenIdentifier = 3, TokenKeyword = 4, TokenNullLiteral = 5, TokenNumericLiteral = 6, TokenPunctuator = 7, TokenStringLiteral = 8, TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = "Boolean";
TokenName[TokenEOF] = "<end>";
TokenName[TokenIdentifier] = "Identifier";
TokenName[TokenKeyword] = "Keyword";
TokenName[TokenNullLiteral] = "Null";
TokenName[TokenNumericLiteral] = "Numeric";
TokenName[TokenPunctuator] = "Punctuator";
TokenName[TokenStringLiteral] = "String";
TokenName[TokenRegularExpression] = "RegularExpression";
var SyntaxArrayExpression = "ArrayExpression", SyntaxBinaryExpression = "BinaryExpression", SyntaxCallExpression = "CallExpression", SyntaxConditionalExpression = "ConditionalExpression", SyntaxIdentifier = "Identifier", SyntaxLiteral = "Literal", SyntaxLogicalExpression = "LogicalExpression", SyntaxMemberExpression = "MemberExpression", SyntaxObjectExpression = "ObjectExpression", SyntaxProperty = "Property", SyntaxUnaryExpression = "UnaryExpression";
var MessageUnexpectedToken = "Unexpected token %0", MessageUnexpectedNumber = "Unexpected number", MessageUnexpectedString = "Unexpected string", MessageUnexpectedIdentifier = "Unexpected identifier", MessageUnexpectedReserved = "Unexpected reserved word", MessageUnexpectedEOS = "Unexpected end of input", MessageInvalidRegExp = "Invalid regular expression", MessageUnterminatedRegExp = "Invalid regular expression: missing /", MessageStrictOctalLiteral = "Octal literals are not allowed in strict mode.", MessageStrictDuplicateProperty = "Duplicate data property in object literal not allowed in strict mode";
var ILLEGAL$1 = "ILLEGAL", DISABLED = "Disabled.";
var RegexNonAsciiIdentifierStart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"), RegexNonAsciiIdentifierPart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function assert$1(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit(ch2) {
  return "0123456789abcdefABCDEF".indexOf(ch2) >= 0;
}
function isOctalDigit(ch2) {
  return "01234567".indexOf(ch2) >= 0;
}
function isWhiteSpace(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch2) >= 0;
}
function isLineTerminator(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch2));
}
function isIdentifierPart(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 >= 48 && ch2 <= 57 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch2));
}
const keywords = {
  "if": 1,
  "in": 1,
  "do": 1,
  "var": 1,
  "for": 1,
  "new": 1,
  "try": 1,
  "let": 1,
  "this": 1,
  "else": 1,
  "case": 1,
  "void": 1,
  "with": 1,
  "enum": 1,
  "while": 1,
  "break": 1,
  "catch": 1,
  "throw": 1,
  "const": 1,
  "yield": 1,
  "class": 1,
  "super": 1,
  "return": 1,
  "typeof": 1,
  "delete": 1,
  "switch": 1,
  "export": 1,
  "import": 1,
  "public": 1,
  "static": 1,
  "default": 1,
  "finally": 1,
  "extends": 1,
  "package": 1,
  "private": 1,
  "function": 1,
  "continue": 1,
  "debugger": 1,
  "interface": 1,
  "protected": 1,
  "instanceof": 1,
  "implements": 1
};
function skipComment() {
  while (index < length$1) {
    const ch2 = source.charCodeAt(index);
    if (isWhiteSpace(ch2) || isLineTerminator(ch2)) {
      ++index;
    } else {
      break;
    }
  }
}
function scanHexEscape(prefix2) {
  var i, len, ch2, code = 0;
  len = prefix2 === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index < length$1 && isHexDigit(source[index])) {
      ch2 = source[index++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL$1);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape() {
  var ch2, code, cu1, cu2;
  ch2 = source[index];
  code = 0;
  if (ch2 === "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL$1);
  }
  while (index < length$1) {
    ch2 = source[index++];
    if (!isHexDigit(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL$1);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier() {
  var ch2, id2;
  ch2 = source.charCodeAt(index++);
  id2 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source.charCodeAt(index) !== 117) {
      throwError({}, MessageUnexpectedToken, ILLEGAL$1);
    }
    ++index;
    ch2 = scanHexEscape("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart(ch2.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL$1);
    }
    id2 = ch2;
  }
  while (index < length$1) {
    ch2 = source.charCodeAt(index);
    if (!isIdentifierPart(ch2)) {
      break;
    }
    ++index;
    id2 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id2 = id2.substr(0, id2.length - 1);
      if (source.charCodeAt(index) !== 117) {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
      ++index;
      ch2 = scanHexEscape("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
      id2 += ch2;
    }
  }
  return id2;
}
function getIdentifier() {
  var start, ch2;
  start = index++;
  while (index < length$1) {
    ch2 = source.charCodeAt(index);
    if (ch2 === 92) {
      index = start;
      return getEscapedIdentifier();
    }
    if (isIdentifierPart(ch2)) {
      ++index;
    } else {
      break;
    }
  }
  return source.slice(start, index);
}
function scanIdentifier() {
  var start, id2, type2;
  start = index;
  id2 = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
  if (id2.length === 1) {
    type2 = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id2)) {
    type2 = TokenKeyword;
  } else if (id2 === "null") {
    type2 = TokenNullLiteral;
  } else if (id2 === "true" || id2 === "false") {
    type2 = TokenBooleanLiteral;
  } else {
    type2 = TokenIdentifier;
  }
  return {
    type: type2,
    value: id2,
    start,
    end: index
  };
}
function scanPunctuator() {
  var start = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;
  switch (code) {
    // Check for most common single-character punctuators.
    case 46:
    // . dot
    case 40:
    // ( open bracket
    case 41:
    // ) close bracket
    case 59:
    // ; semicolon
    case 44:
    // , comma
    case 123:
    // { open curly brace
    case 125:
    // } close curly brace
    case 91:
    // [
    case 93:
    // ]
    case 58:
    // :
    case 63:
    // ?
    case 126:
      ++index;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start,
        end: index
      };
    default:
      code2 = source.charCodeAt(index + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          // +
          case 45:
          // -
          case 47:
          // /
          case 60:
          // <
          case 62:
          // >
          case 94:
          // ^
          case 124:
          // |
          case 37:
          // %
          case 38:
          // &
          case 42:
            index += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index
            };
          case 33:
          // !
          case 61:
            index += 2;
            if (source.charCodeAt(index) === 61) {
              ++index;
            }
            return {
              type: TokenPunctuator,
              value: source.slice(start, index),
              start,
              end: index
            };
        }
      }
  }
  ch4 = source.substr(index, 4);
  if (ch4 === ">>>=") {
    index += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start,
      end: index
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start,
      end: index
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start,
      end: index
    };
  }
  if (ch2 === "//") {
    throwError({}, MessageUnexpectedToken, ILLEGAL$1);
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index;
    return {
      type: TokenPunctuator,
      value: ch1,
      start,
      end: index
    };
  }
  throwError({}, MessageUnexpectedToken, ILLEGAL$1);
}
function scanHexLiteral(start) {
  let number2 = "";
  while (index < length$1) {
    if (!isHexDigit(source[index])) {
      break;
    }
    number2 += source[index++];
  }
  if (number2.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL$1);
  }
  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL$1);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt("0x" + number2, 16),
    start,
    end: index
  };
}
function scanOctalLiteral(start) {
  let number2 = "0" + source[index++];
  while (index < length$1) {
    if (!isOctalDigit(source[index])) {
      break;
    }
    number2 += source[index++];
  }
  if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL$1);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt(number2, 8),
    octal: true,
    start,
    end: index
  };
}
function scanNumericLiteral() {
  var number2, start, ch2;
  ch2 = source[index];
  assert$1(isDecimalDigit(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index;
  number2 = "";
  if (ch2 !== ".") {
    number2 = source[index++];
    ch2 = source[index];
    if (number2 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index;
        return scanHexLiteral(start);
      }
      if (isOctalDigit(ch2)) {
        return scanOctalLiteral(start);
      }
      if (ch2 && isDecimalDigit(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
    }
    while (isDecimalDigit(source.charCodeAt(index))) {
      number2 += source[index++];
    }
    ch2 = source[index];
  }
  if (ch2 === ".") {
    number2 += source[index++];
    while (isDecimalDigit(source.charCodeAt(index))) {
      number2 += source[index++];
    }
    ch2 = source[index];
  }
  if (ch2 === "e" || ch2 === "E") {
    number2 += source[index++];
    ch2 = source[index];
    if (ch2 === "+" || ch2 === "-") {
      number2 += source[index++];
    }
    if (isDecimalDigit(source.charCodeAt(index))) {
      while (isDecimalDigit(source.charCodeAt(index))) {
        number2 += source[index++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL$1);
    }
  }
  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL$1);
  }
  return {
    type: TokenNumericLiteral,
    value: parseFloat(number2),
    start,
    end: index
  };
}
function scanStringLiteral() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source[index];
  assert$1(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index;
  ++index;
  while (index < length$1) {
    ch2 = source[index++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source[index++];
      if (!ch2 || !isLineTerminator(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source[index] === "{") {
              ++index;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index < length$1 && isOctalDigit(source[index])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source[index++]);
                if ("0123".indexOf(ch2) >= 0 && index < length$1 && isOctalDigit(source[index])) {
                  code = code * 8 + "01234567".indexOf(source[index++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source[index] === "\n") {
          ++index;
        }
      }
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError({}, MessageUnexpectedToken, ILLEGAL$1);
  }
  return {
    type: TokenStringLiteral,
    value: str,
    octal,
    start,
    end: index
  };
}
function testRegExp(pattern, flags) {
  let tmp = pattern;
  if (flags.indexOf("u") >= 0) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e3) {
    throwError({}, MessageInvalidRegExp);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source[index];
  assert$1(ch2 === "/", "Regular expression literal must start with a slash");
  str = source[index++];
  classMarker = false;
  terminated = false;
  while (index < length$1) {
    ch2 = source[index++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source[index++];
      if (isLineTerminator(ch2.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }
      str += ch2;
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index < length$1) {
    ch2 = source[index];
    if (!isIdentifierPart(ch2.charCodeAt(0))) {
      break;
    }
    ++index;
    if (ch2 === "\\" && index < length$1) {
      throwError({}, MessageUnexpectedToken, ILLEGAL$1);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp() {
  var start, body, flags, value2;
  lookahead = null;
  skipComment();
  start = index;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value2 = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value2,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index
  };
}
function isIdentifierName(token2) {
  return token2.type === TokenIdentifier || token2.type === TokenKeyword || token2.type === TokenBooleanLiteral || token2.type === TokenNullLiteral;
}
function advance() {
  skipComment();
  if (index >= length$1) {
    return {
      type: TokenEOF,
      start: index,
      end: index
    };
  }
  const ch2 = source.charCodeAt(index);
  if (isIdentifierStart(ch2)) {
    return scanIdentifier();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral();
  }
  if (ch2 === 46) {
    if (isDecimalDigit(source.charCodeAt(index + 1))) {
      return scanNumericLiteral();
    }
    return scanPunctuator();
  }
  if (isDecimalDigit(ch2)) {
    return scanNumericLiteral();
  }
  return scanPunctuator();
}
function lex() {
  const token2 = lookahead;
  index = token2.end;
  lookahead = advance();
  index = token2.end;
  return token2;
}
function peek$1() {
  const pos = index;
  lookahead = advance();
  index = pos;
}
function finishArrayExpression(elements) {
  const node2 = new ASTNode(SyntaxArrayExpression);
  node2.elements = elements;
  return node2;
}
function finishBinaryExpression(operator2, left, right) {
  const node2 = new ASTNode(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node2.operator = operator2;
  node2.left = left;
  node2.right = right;
  return node2;
}
function finishCallExpression(callee, args) {
  const node2 = new ASTNode(SyntaxCallExpression);
  node2.callee = callee;
  node2.arguments = args;
  return node2;
}
function finishConditionalExpression(test2, consequent, alternate) {
  const node2 = new ASTNode(SyntaxConditionalExpression);
  node2.test = test2;
  node2.consequent = consequent;
  node2.alternate = alternate;
  return node2;
}
function finishIdentifier(name) {
  const node2 = new ASTNode(SyntaxIdentifier);
  node2.name = name;
  return node2;
}
function finishLiteral(token2) {
  const node2 = new ASTNode(SyntaxLiteral);
  node2.value = token2.value;
  node2.raw = source.slice(token2.start, token2.end);
  if (token2.regex) {
    if (node2.raw === "//") {
      node2.raw = "/(?:)/";
    }
    node2.regex = token2.regex;
  }
  return node2;
}
function finishMemberExpression(accessor2, object2, property2) {
  const node2 = new ASTNode(SyntaxMemberExpression);
  node2.computed = accessor2 === "[";
  node2.object = object2;
  node2.property = property2;
  if (!node2.computed) property2.member = true;
  return node2;
}
function finishObjectExpression(properties2) {
  const node2 = new ASTNode(SyntaxObjectExpression);
  node2.properties = properties2;
  return node2;
}
function finishProperty(kind, key2, value2) {
  const node2 = new ASTNode(SyntaxProperty);
  node2.key = key2;
  node2.value = value2;
  node2.kind = kind;
  return node2;
}
function finishUnaryExpression(operator2, argument) {
  const node2 = new ASTNode(SyntaxUnaryExpression);
  node2.operator = operator2;
  node2.argument = argument;
  node2.prefix = true;
  return node2;
}
function throwError(token2, messageFormat) {
  var error2, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index2) => {
    assert$1(index2 < args.length, "Message reference must be in range");
    return args[index2];
  });
  error2 = new Error(msg);
  error2.index = index;
  error2.description = msg;
  throw error2;
}
function throwUnexpected(token2) {
  if (token2.type === TokenEOF) {
    throwError(token2, MessageUnexpectedEOS);
  }
  if (token2.type === TokenNumericLiteral) {
    throwError(token2, MessageUnexpectedNumber);
  }
  if (token2.type === TokenStringLiteral) {
    throwError(token2, MessageUnexpectedString);
  }
  if (token2.type === TokenIdentifier) {
    throwError(token2, MessageUnexpectedIdentifier);
  }
  if (token2.type === TokenKeyword) {
    throwError(token2, MessageUnexpectedReserved);
  }
  throwError(token2, MessageUnexpectedToken, token2.value);
}
function expect(value2) {
  const token2 = lex();
  if (token2.type !== TokenPunctuator || token2.value !== value2) {
    throwUnexpected(token2);
  }
}
function match$1(value2) {
  return lookahead.type === TokenPunctuator && lookahead.value === value2;
}
function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
}
function parseArrayInitialiser() {
  const elements = [];
  index = lookahead.start;
  expect("[");
  while (!match$1("]")) {
    if (match$1(",")) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());
      if (!match$1("]")) {
        expect(",");
      }
    }
  }
  lex();
  return finishArrayExpression(elements);
}
function parseObjectPropertyKey() {
  index = lookahead.start;
  const token2 = lex();
  if (token2.type === TokenStringLiteral || token2.type === TokenNumericLiteral) {
    if (token2.octal) {
      throwError(token2, MessageStrictOctalLiteral);
    }
    return finishLiteral(token2);
  }
  return finishIdentifier(token2.value);
}
function parseObjectProperty() {
  var token2, key2, id2, value2;
  index = lookahead.start;
  token2 = lookahead;
  if (token2.type === TokenIdentifier) {
    id2 = parseObjectPropertyKey();
    expect(":");
    value2 = parseConditionalExpression();
    return finishProperty("init", id2, value2);
  }
  if (token2.type === TokenEOF || token2.type === TokenPunctuator) {
    throwUnexpected(token2);
  } else {
    key2 = parseObjectPropertyKey();
    expect(":");
    value2 = parseConditionalExpression();
    return finishProperty("init", key2, value2);
  }
}
function parseObjectInitialiser() {
  var properties2 = [], property2, name, key2, map2 = {}, toString2 = String;
  index = lookahead.start;
  expect("{");
  while (!match$1("}")) {
    property2 = parseObjectProperty();
    if (property2.key.type === SyntaxIdentifier) {
      name = property2.key.name;
    } else {
      name = toString2(property2.key.value);
    }
    key2 = "$" + name;
    if (Object.prototype.hasOwnProperty.call(map2, key2)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map2[key2] = true;
    }
    properties2.push(property2);
    if (!match$1("}")) {
      expect(",");
    }
  }
  expect("}");
  return finishObjectExpression(properties2);
}
function parseGroupExpression() {
  expect("(");
  const expr2 = parseExpression$1();
  expect(")");
  return expr2;
}
const legalKeywords = {
  "if": 1
};
function parsePrimaryExpression() {
  var type2, token2, expr2;
  if (match$1("(")) {
    return parseGroupExpression();
  }
  if (match$1("[")) {
    return parseArrayInitialiser();
  }
  if (match$1("{")) {
    return parseObjectInitialiser();
  }
  type2 = lookahead.type;
  index = lookahead.start;
  if (type2 === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr2 = finishIdentifier(lex().value);
  } else if (type2 === TokenStringLiteral || type2 === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }
    expr2 = finishLiteral(lex());
  } else if (type2 === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type2 === TokenBooleanLiteral) {
    token2 = lex();
    token2.value = token2.value === "true";
    expr2 = finishLiteral(token2);
  } else if (type2 === TokenNullLiteral) {
    token2 = lex();
    token2.value = null;
    expr2 = finishLiteral(token2);
  } else if (match$1("/") || match$1("/=")) {
    expr2 = finishLiteral(scanRegExp());
    peek$1();
  } else {
    throwUnexpected(lex());
  }
  return expr2;
}
function parseArguments() {
  const args = [];
  expect("(");
  if (!match$1(")")) {
    while (index < length$1) {
      args.push(parseConditionalExpression());
      if (match$1(")")) {
        break;
      }
      expect(",");
    }
  }
  expect(")");
  return args;
}
function parseNonComputedProperty() {
  index = lookahead.start;
  const token2 = lex();
  if (!isIdentifierName(token2)) {
    throwUnexpected(token2);
  }
  return finishIdentifier(token2.value);
}
function parseNonComputedMember() {
  expect(".");
  return parseNonComputedProperty();
}
function parseComputedMember() {
  expect("[");
  const expr2 = parseExpression$1();
  expect("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression();
  for (; ; ) {
    if (match$1(".")) {
      property2 = parseNonComputedMember();
      expr2 = finishMemberExpression(".", expr2, property2);
    } else if (match$1("(")) {
      args = parseArguments();
      expr2 = finishCallExpression(expr2, args);
    } else if (match$1("[")) {
      property2 = parseComputedMember();
      expr2 = finishMemberExpression("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression() {
  const expr2 = parseLeftHandSideExpressionAllowCall();
  if (lookahead.type === TokenPunctuator) {
    if (match$1("++") || match$1("--")) {
      throw new Error(DISABLED);
    }
  }
  return expr2;
}
function parseUnaryExpression() {
  var token2, expr2;
  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr2 = parsePostfixExpression();
  } else if (match$1("++") || match$1("--")) {
    throw new Error(DISABLED);
  } else if (match$1("+") || match$1("-") || match$1("~") || match$1("!")) {
    token2 = lex();
    expr2 = parseUnaryExpression();
    expr2 = finishUnaryExpression(token2.value, expr2);
  } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
    throw new Error(DISABLED);
  } else {
    expr2 = parsePostfixExpression();
  }
  return expr2;
}
function binaryPrecedence(token2) {
  let prec = 0;
  if (token2.type !== TokenPunctuator && token2.type !== TokenKeyword) {
    return 0;
  }
  switch (token2.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
  }
  return prec;
}
function parseBinaryExpression() {
  var marker, markers, expr2, token2, prec, stack2, right, operator2, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token2 = lookahead;
  prec = binaryPrecedence(token2);
  if (prec === 0) {
    return left;
  }
  token2.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack2 = [left, token2, right];
  while ((prec = binaryPrecedence(lookahead)) > 0) {
    while (stack2.length > 2 && prec <= stack2[stack2.length - 2].prec) {
      right = stack2.pop();
      operator2 = stack2.pop().value;
      left = stack2.pop();
      markers.pop();
      expr2 = finishBinaryExpression(operator2, left, right);
      stack2.push(expr2);
    }
    token2 = lex();
    token2.prec = prec;
    stack2.push(token2);
    markers.push(lookahead);
    expr2 = parseUnaryExpression();
    stack2.push(expr2);
  }
  i = stack2.length - 1;
  expr2 = stack2[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression(stack2[i - 1].value, stack2[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression();
  if (match$1("?")) {
    lex();
    consequent = parseConditionalExpression();
    expect(":");
    alternate = parseConditionalExpression();
    expr2 = finishConditionalExpression(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression$1() {
  const expr2 = parseConditionalExpression();
  if (match$1(",")) {
    throw new Error(DISABLED);
  }
  return expr2;
}
function parser$1(code) {
  source = code;
  index = 0;
  length$1 = source.length;
  lookahead = null;
  peek$1();
  const expr2 = parseExpression$1();
  if (lookahead.type !== TokenEOF) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}
var Constants$1 = {
  NaN: "NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2",
  MIN_VALUE: "Number.MIN_VALUE",
  MAX_VALUE: "Number.MAX_VALUE"
};
function Functions$1(codegen2) {
  function fncall(name, args, cast, type2) {
    let obj = codegen2(args[0]);
    if (cast) {
      obj = cast + "(" + obj + ")";
      if (cast.lastIndexOf("new ", 0) === 0) obj = "(" + obj + ")";
    }
    return obj + "." + name + (type2 < 0 ? "" : type2 === 0 ? "()" : "(" + args.slice(1).map(codegen2).join(",") + ")");
  }
  function fn(name, cast, type2) {
    return (args) => fncall(name, args, cast, type2);
  }
  const DATE2 = "new Date", STRING = "String", REGEXP = "RegExp";
  return {
    // MATH functions
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(args) {
      if (args.length < 3) error("Missing arguments to clamp function.");
      if (args.length > 3) error("Too many arguments to clamp function.");
      const a2 = args.map(codegen2);
      return "Math.max(" + a2[1] + ", Math.min(" + a2[2] + "," + a2[0] + "))";
    },
    // DATE functions
    now: "Date.now",
    utc: "Date.UTC",
    datetime: DATE2,
    date: fn("getDate", DATE2, 0),
    day: fn("getDay", DATE2, 0),
    year: fn("getFullYear", DATE2, 0),
    month: fn("getMonth", DATE2, 0),
    hours: fn("getHours", DATE2, 0),
    minutes: fn("getMinutes", DATE2, 0),
    seconds: fn("getSeconds", DATE2, 0),
    milliseconds: fn("getMilliseconds", DATE2, 0),
    time: fn("getTime", DATE2, 0),
    timezoneoffset: fn("getTimezoneOffset", DATE2, 0),
    utcdate: fn("getUTCDate", DATE2, 0),
    utcday: fn("getUTCDay", DATE2, 0),
    utcyear: fn("getUTCFullYear", DATE2, 0),
    utcmonth: fn("getUTCMonth", DATE2, 0),
    utchours: fn("getUTCHours", DATE2, 0),
    utcminutes: fn("getUTCMinutes", DATE2, 0),
    utcseconds: fn("getUTCSeconds", DATE2, 0),
    utcmilliseconds: fn("getUTCMilliseconds", DATE2, 0),
    // sequence functions
    length: fn("length", null, -1),
    // STRING functions
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: fn("toUpperCase", STRING, 0),
    lower: fn("toLowerCase", STRING, 0),
    substring: fn("substring", STRING),
    split: fn("split", STRING),
    trim: fn("trim", STRING, 0),
    // REGEXP functions
    regexp: REGEXP,
    test: fn("test", REGEXP),
    // Control Flow functions
    if: function(args) {
      if (args.length < 3) error("Missing arguments to if function.");
      if (args.length > 3) error("Too many arguments to if function.");
      const a2 = args.map(codegen2);
      return "(" + a2[0] + "?" + a2[1] + ":" + a2[2] + ")";
    }
  };
}
function stripQuotes(s) {
  const n = s && s.length - 1;
  return n && (s[0] === '"' && s[n] === '"' || s[0] === "'" && s[n] === "'") ? s.slice(1, -1) : s;
}
function codegen(opt) {
  opt = opt || {};
  const allowed = opt.allowed ? toSet(opt.allowed) : {}, forbidden = opt.forbidden ? toSet(opt.forbidden) : {}, constants2 = opt.constants || Constants$1, functions = (opt.functions || Functions$1)(visit2), globalvar = opt.globalvar, fieldvar = opt.fieldvar, outputGlobal = isFunction$3(globalvar) ? globalvar : (id2) => `${globalvar}["${id2}"]`;
  let globals = {}, fields = {}, memberDepth = 0;
  function visit2(ast) {
    if (isString(ast)) return ast;
    const generator = Generators[ast.type];
    if (generator == null) error("Unsupported type: " + ast.type);
    return generator(ast);
  }
  const Generators = {
    Literal: (n) => n.raw,
    Identifier: (n) => {
      const id2 = n.name;
      if (memberDepth > 0) {
        return id2;
      } else if (has$2(forbidden, id2)) {
        return error("Illegal identifier: " + id2);
      } else if (has$2(constants2, id2)) {
        return constants2[id2];
      } else if (has$2(allowed, id2)) {
        return id2;
      } else {
        globals[id2] = 1;
        return outputGlobal(id2);
      }
    },
    MemberExpression: (n) => {
      const d = !n.computed, o = visit2(n.object);
      if (d) memberDepth += 1;
      const p = visit2(n.property);
      if (o === fieldvar) {
        fields[stripQuotes(p)] = 1;
      }
      if (d) memberDepth -= 1;
      return o + (d ? "." + p : "[" + p + "]");
    },
    CallExpression: (n) => {
      if (n.callee.type !== "Identifier") {
        error("Illegal callee type: " + n.callee.type);
      }
      const callee = n.callee.name, args = n.arguments, fn = has$2(functions, callee) && functions[callee];
      if (!fn) error("Unrecognized function: " + callee);
      return isFunction$3(fn) ? fn(args) : fn + "(" + args.map(visit2).join(",") + ")";
    },
    ArrayExpression: (n) => "[" + n.elements.map(visit2).join(",") + "]",
    BinaryExpression: (n) => "(" + visit2(n.left) + " " + n.operator + " " + visit2(n.right) + ")",
    UnaryExpression: (n) => "(" + n.operator + visit2(n.argument) + ")",
    ConditionalExpression: (n) => "(" + visit2(n.test) + "?" + visit2(n.consequent) + ":" + visit2(n.alternate) + ")",
    LogicalExpression: (n) => "(" + visit2(n.left) + n.operator + visit2(n.right) + ")",
    ObjectExpression: (n) => "{" + n.properties.map(visit2).join(",") + "}",
    Property: (n) => {
      memberDepth += 1;
      const k = visit2(n.key);
      memberDepth -= 1;
      return k + ":" + visit2(n.value);
    }
  };
  function codegen2(ast) {
    const result = {
      code: visit2(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }
  codegen2.functions = functions;
  codegen2.constants = constants2;
  return codegen2;
}
function ascending(a2, b2) {
  return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function bisector(f) {
  let delta = f;
  let compare12 = f;
  let compare2 = f;
  if (f.length !== 2) {
    delta = (d, x2) => f(d) - x2;
    compare12 = ascending;
    compare2 = (d, x2) => ascending(f(d), x2);
  }
  function left(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare12(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare12(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a2, x2, lo = 0, hi = a2.length) {
    const i = left(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left, center, right };
}
function intersection(values2, ...others) {
  values2 = new InternSet(values2);
  others = others.map(set$1);
  out: for (const value2 of values2) {
    for (const other of others) {
      if (!other.has(value2)) {
        values2.delete(value2);
        continue out;
      }
    }
  }
  return values2;
}
function set$1(values2) {
  return values2 instanceof InternSet ? values2 : new InternSet(values2);
}
function union(...others) {
  const set2 = new InternSet();
  for (const other of others) {
    for (const o of other) {
      set2.add(o);
    }
  }
  return set2;
}
const Intersect = "intersect";
const Union = "union";
const VlMulti = "vlMulti";
const VlPoint = "vlPoint";
const Or = "or";
const And = "and";
const SelectionId = "_vgsid_";
const $selectionId = field$1(SelectionId);
const TYPE_ENUM = "E", TYPE_RANGE_INC = "R", TYPE_RANGE_EXC = "R-E", TYPE_RANGE_LE = "R-LE", TYPE_RANGE_RE = "R-RE", UNIT_INDEX = "index:unit";
function testPoint(datum2, entry2) {
  var fields = entry2.fields, values2 = entry2.values, n = fields.length, i = 0, dval, f;
  for (; i < n; ++i) {
    f = fields[i];
    f.getter = field$1.getter || field$1(f.field);
    dval = f.getter(datum2);
    if (isDate$1(dval)) dval = toNumber(dval);
    if (isDate$1(values2[i])) values2[i] = toNumber(values2[i]);
    if (isDate$1(values2[i][0])) values2[i] = values2[i].map(toNumber);
    if (f.type === TYPE_ENUM) {
      if (isArray$1(values2[i]) ? values2[i].indexOf(dval) < 0 : dval !== values2[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!inrange(dval, values2[i])) return false;
      } else if (f.type === TYPE_RANGE_RE) {
        if (!inrange(dval, values2[i], true, false)) return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        if (!inrange(dval, values2[i], false, false)) return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!inrange(dval, values2[i], false, true)) return false;
      }
    }
  }
  return true;
}
function selectionTest(name, datum2, op) {
  var data2 = this.context.data[name], entries2 = data2 ? data2.values.value : [], unitIdx = data2 ? data2[UNIT_INDEX] && data2[UNIT_INDEX].value : void 0, intersect2 = op === Intersect, n = entries2.length, i = 0, entry2, miss, count2, unit2, b2;
  for (; i < n; ++i) {
    entry2 = entries2[i];
    if (unitIdx && intersect2) {
      miss = miss || {};
      count2 = miss[unit2 = entry2.unit] || 0;
      if (count2 === -1) continue;
      b2 = testPoint(datum2, entry2);
      miss[unit2] = b2 ? -1 : ++count2;
      if (b2 && unitIdx.size === 1) return true;
      if (!b2 && count2 === unitIdx.get(unit2).count) return false;
    } else {
      b2 = testPoint(datum2, entry2);
      if (intersect2 ^ b2) return b2;
    }
  }
  return n && intersect2;
}
const bisect = bisector($selectionId), bisectLeft = bisect.left, bisectRight = bisect.right;
function selectionIdTest(name, datum2, op) {
  const data2 = this.context.data[name], entries2 = data2 ? data2.values.value : [], unitIdx = data2 ? data2[UNIT_INDEX] && data2[UNIT_INDEX].value : void 0, intersect2 = op === Intersect, value2 = $selectionId(datum2), index2 = bisectLeft(entries2, value2);
  if (index2 === entries2.length) return false;
  if ($selectionId(entries2[index2]) !== value2) return false;
  if (unitIdx && intersect2) {
    if (unitIdx.size === 1) return true;
    if (bisectRight(entries2, value2) - index2 < unitIdx.size) return false;
  }
  return true;
}
function selectionTuples(array2, base2) {
  return array2.map((x2) => extend$3(base2.fields ? {
    values: base2.fields.map((f) => (f.getter || (f.getter = field$1(f.field)))(x2.datum))
  } : {
    [SelectionId]: $selectionId(x2.datum)
  }, base2));
}
function selectionResolve(name, op, isMulti, vl5) {
  var data2 = this.context.data[name], entries2 = data2 ? data2.values.value : [], resolved = {}, multiRes = {}, types = {}, entry2, fields, values2, unit2, field2, value2, res, resUnit, type2, union2, n = entries2.length, i = 0, j, m2;
  for (; i < n; ++i) {
    entry2 = entries2[i];
    unit2 = entry2.unit;
    fields = entry2.fields;
    values2 = entry2.values;
    if (fields && values2) {
      for (j = 0, m2 = fields.length; j < m2; ++j) {
        field2 = fields[j];
        res = resolved[field2.field] || (resolved[field2.field] = {});
        resUnit = res[unit2] || (res[unit2] = []);
        types[field2.field] = type2 = field2.type.charAt(0);
        union2 = ops["".concat(type2, "_union")];
        res[unit2] = union2(resUnit, array$5(values2[j]));
      }
      if (isMulti) {
        resUnit = multiRes[unit2] || (multiRes[unit2] = []);
        resUnit.push(array$5(values2).reduce((obj, curr, j2) => (obj[fields[j2].field] = curr, obj), {}));
      }
    } else {
      field2 = SelectionId;
      value2 = $selectionId(entry2);
      res = resolved[field2] || (resolved[field2] = {});
      resUnit = res[unit2] || (res[unit2] = []);
      resUnit.push(value2);
      if (isMulti) {
        resUnit = multiRes[unit2] || (multiRes[unit2] = []);
        resUnit.push({
          [SelectionId]: value2
        });
      }
    }
  }
  op = op || Union;
  if (resolved[SelectionId]) {
    resolved[SelectionId] = ops["".concat(SelectionId, "_").concat(op)](...Object.values(resolved[SelectionId]));
  } else {
    Object.keys(resolved).forEach((field3) => {
      resolved[field3] = Object.keys(resolved[field3]).map((unit3) => resolved[field3][unit3]).reduce((acc, curr) => acc === void 0 ? curr : ops["".concat(types[field3], "_").concat(op)](acc, curr));
    });
  }
  entries2 = Object.keys(multiRes);
  if (isMulti && entries2.length) {
    const key2 = vl5 ? VlPoint : VlMulti;
    resolved[key2] = op === Union ? {
      [Or]: entries2.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])
    } : {
      [And]: entries2.map((k) => ({
        [Or]: multiRes[k]
      }))
    };
  }
  return resolved;
}
var ops = {
  ["".concat(SelectionId, "_union")]: union,
  ["".concat(SelectionId, "_intersect")]: intersection,
  E_union: function(base2, value2) {
    if (!base2.length) return value2;
    var i = 0, n = value2.length;
    for (; i < n; ++i) if (base2.indexOf(value2[i]) < 0) base2.push(value2[i]);
    return base2;
  },
  E_intersect: function(base2, value2) {
    return !base2.length ? value2 : base2.filter((v) => value2.indexOf(v) >= 0);
  },
  R_union: function(base2, value2) {
    var lo = toNumber(value2[0]), hi = toNumber(value2[1]);
    if (lo > hi) {
      lo = value2[1];
      hi = value2[0];
    }
    if (!base2.length) return [lo, hi];
    if (base2[0] > lo) base2[0] = lo;
    if (base2[1] < hi) base2[1] = hi;
    return base2;
  },
  R_intersect: function(base2, value2) {
    var lo = toNumber(value2[0]), hi = toNumber(value2[1]);
    if (lo > hi) {
      lo = value2[1];
      hi = value2[0];
    }
    if (!base2.length) return [lo, hi];
    if (hi < base2[0] || base2[1] < lo) {
      return [];
    } else {
      if (base2[0] < lo) base2[0] = lo;
      if (base2[1] > hi) base2[1] = hi;
    }
    return base2;
  }
};
const DataPrefix$1 = ":", IndexPrefix$1 = "@";
function selectionVisitor(name, args, scope, params2) {
  if (args[0].type !== Literal) error("First argument to selection functions must be a string literal.");
  const data2 = args[0].value, op = args.length >= 2 && peek$2(args).value, field2 = "unit", indexName = IndexPrefix$1 + field2, dataName = DataPrefix$1 + data2;
  if (op === Intersect && !has$2(params2, indexName)) {
    params2[indexName] = scope.getData(data2).indataRef(scope, field2);
  }
  if (!has$2(params2, dataName)) {
    params2[dataName] = scope.getData(data2).tuplesRef();
  }
}
function data$1(name) {
  const data2 = this.context.data[name];
  return data2 ? data2.values.value : [];
}
function indata(name, field2, value2) {
  const index2 = this.context.data[name]["index:" + field2], entry2 = index2 ? index2.value.get(value2) : void 0;
  return entry2 ? entry2.count : entry2;
}
function setdata(name, tuples) {
  const df = this.context.dataflow, data2 = this.context.data[name], input = data2.input;
  df.pulse(input, df.changeset().remove(truthy).insert(tuples));
  return 1;
}
function encode(item, name, retval) {
  if (item) {
    const df = this.context.dataflow, target2 = item.mark.source;
    df.pulse(target2, df.changeset().encode(item, name));
  }
  return retval !== void 0 ? retval : item;
}
const wrap$1 = (method2) => function(value2, spec) {
  const locale2 = this.context.dataflow.locale();
  return locale2[method2](spec)(value2);
};
const format = wrap$1("format");
const timeFormat$1 = wrap$1("timeFormat");
const utcFormat = wrap$1("utcFormat");
const timeParse = wrap$1("timeParse");
const utcParse = wrap$1("utcParse");
const dateObj = new Date(2e3, 0, 1);
function time(month2, day2, specifier) {
  if (!Number.isInteger(month2) || !Number.isInteger(day2)) return "";
  dateObj.setYear(2e3);
  dateObj.setMonth(month2);
  dateObj.setDate(day2);
  return timeFormat$1.call(this, dateObj, specifier);
}
function monthFormat(month2) {
  return time.call(this, month2, 1, "%B");
}
function monthAbbrevFormat(month2) {
  return time.call(this, month2, 1, "%b");
}
function dayFormat(day2) {
  return time.call(this, 0, 2 + day2, "%A");
}
function dayAbbrevFormat(day2) {
  return time.call(this, 0, 2 + day2, "%a");
}
const DataPrefix = ":";
const IndexPrefix = "@";
const ScalePrefix = "%";
const SignalPrefix = "$";
function dataVisitor(name, args, scope, params2) {
  if (args[0].type !== Literal) {
    error("First argument to data functions must be a string literal.");
  }
  const data2 = args[0].value, dataName = DataPrefix + data2;
  if (!has$2(dataName, params2)) {
    try {
      params2[dataName] = scope.getData(data2).tuplesRef();
    } catch (err) {
    }
  }
}
function indataVisitor(name, args, scope, params2) {
  if (args[0].type !== Literal) error("First argument to indata must be a string literal.");
  if (args[1].type !== Literal) error("Second argument to indata must be a string literal.");
  const data2 = args[0].value, field2 = args[1].value, indexName = IndexPrefix + field2;
  if (!has$2(indexName, params2)) {
    params2[indexName] = scope.getData(data2).indataRef(scope, field2);
  }
}
function scaleVisitor(name, args, scope, params2) {
  if (args[0].type === Literal) {
    addScaleDependency(scope, params2, args[0].value);
  } else {
    for (name in scope.scales) {
      addScaleDependency(scope, params2, name);
    }
  }
}
function addScaleDependency(scope, params2, name) {
  const scaleName = ScalePrefix + name;
  if (!has$2(params2, scaleName)) {
    try {
      params2[scaleName] = scope.scaleRef(name);
    } catch (err) {
    }
  }
}
function getScale(name, ctx) {
  let s;
  return isFunction$3(name) ? name : isString(name) ? (s = ctx.scales[name]) && s.value : void 0;
}
function internalScaleFunctions(codegen2, fnctx, visitors) {
  fnctx.__bandwidth = (s) => s && s.bandwidth ? s.bandwidth() : 0;
  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor;
  const ref2 = (arg) => "_[" + (arg.type === Literal ? $(ScalePrefix + arg.value) : $(ScalePrefix) + "+" + codegen2(arg)) + "]";
  return {
    _bandwidth: (args) => "this.__bandwidth(".concat(ref2(args[0]), ")"),
    _range: (args) => "".concat(ref2(args[0]), ".range()"),
    _scale: (args) => "".concat(ref2(args[0]), "(").concat(codegen2(args[1]), ")")
  };
}
function geoMethod(methodName, globalMethod) {
  return function(projection2, geojson, group2) {
    if (projection2) {
      const p = getScale(projection2, (group2 || this).context);
      return p && p.path[methodName](geojson);
    } else {
      return globalMethod(geojson);
    }
  };
}
const geoArea = geoMethod("area", geoArea$1);
const geoBounds = geoMethod("bounds", geoBounds$1);
const geoCentroid = geoMethod("centroid", geoCentroid$1);
function inScope(item) {
  const group2 = this.context.group;
  let value2 = false;
  if (group2) while (item) {
    if (item === group2) {
      value2 = true;
      break;
    }
    item = item.mark.group;
  }
  return value2;
}
function log$1(df, method2, args) {
  try {
    df[method2].apply(df, ["EXPRESSION"].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }
  return args[args.length - 1];
}
function warn$1() {
  return log$1(this.context.dataflow, "warn", arguments);
}
function info() {
  return log$1(this.context.dataflow, "info", arguments);
}
function debug$3() {
  return log$1(this.context.dataflow, "debug", arguments);
}
function channel_luminance_value(channelValue) {
  const val = channelValue / 255;
  if (val <= 0.03928) {
    return val / 12.92;
  }
  return Math.pow((val + 0.055) / 1.055, 2.4);
}
function luminance(color2) {
  const c2 = rgb$3(color2), r2 = channel_luminance_value(c2.r), g = channel_luminance_value(c2.g), b2 = channel_luminance_value(c2.b);
  return 0.2126 * r2 + 0.7152 * g + 0.0722 * b2;
}
function contrast(color1, color2) {
  const lum1 = luminance(color1), lum2 = luminance(color2), lumL = Math.max(lum1, lum2), lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}
function merge$1() {
  const args = [].slice.call(arguments);
  args.unshift({});
  return extend$3(...args);
}
function equal$1(a2, b2) {
  return a2 === b2 || a2 !== a2 && b2 !== b2 ? true : isArray$1(a2) ? isArray$1(b2) && a2.length === b2.length ? equalArray(a2, b2) : false : isObject$1(a2) && isObject$1(b2) ? equalObject(a2, b2) : false;
}
function equalArray(a2, b2) {
  for (let i = 0, n = a2.length; i < n; ++i) {
    if (!equal$1(a2[i], b2[i])) return false;
  }
  return true;
}
function equalObject(a2, b2) {
  for (const key2 in a2) {
    if (!equal$1(a2[key2], b2[key2])) return false;
  }
  return true;
}
function removePredicate(props) {
  return (_) => equalObject(props, _);
}
function modify(name, insert2, remove2, toggle2, modify2, values2) {
  const df = this.context.dataflow, data2 = this.context.data[name], input = data2.input, stamp = df.stamp();
  let changes = data2.changes, predicate, key2;
  if (df._trigger === false || !(input.value.length || insert2 || toggle2)) {
    return 0;
  }
  if (!changes || changes.stamp < stamp) {
    data2.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data2.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }
  if (remove2) {
    predicate = remove2 === true ? truthy : isArray$1(remove2) || isTuple(remove2) ? remove2 : removePredicate(remove2);
    changes.remove(predicate);
  }
  if (insert2) {
    changes.insert(insert2);
  }
  if (toggle2) {
    predicate = removePredicate(toggle2);
    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle2);
    }
  }
  if (modify2) {
    for (key2 in values2) {
      changes.modify(modify2, key2, values2[key2]);
    }
  }
  return 1;
}
function pinchDistance(event2) {
  const t4 = event2.touches, dx = t4[0].clientX - t4[1].clientX, dy = t4[0].clientY - t4[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function pinchAngle(event2) {
  const t4 = event2.touches;
  return Math.atan2(t4[0].clientY - t4[1].clientY, t4[0].clientX - t4[1].clientX);
}
const accessors = {};
function pluck(data2, name) {
  const accessor2 = accessors[name] || (accessors[name] = field$1(name));
  return isArray$1(data2) ? data2.map(accessor2) : accessor2(data2);
}
function array(seq) {
  return isArray$1(seq) || ArrayBuffer.isView(seq) ? seq : null;
}
function sequence(seq) {
  return array(seq) || (isString(seq) ? seq : null);
}
function join(seq) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return array(seq).join(...args);
}
function indexof$1(seq) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return sequence(seq).indexOf(...args);
}
function lastindexof(seq) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return sequence(seq).lastIndexOf(...args);
}
function slice$2(seq) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  return sequence(seq).slice(...args);
}
function replace$1(str, pattern, repl) {
  if (isFunction$3(repl)) error("Function argument passed to replace.");
  return String(str).replace(pattern, repl);
}
function reverse$1(seq) {
  return array(seq).slice().reverse();
}
function bandspace(count2, paddingInner2, paddingOuter2) {
  return bandSpace(count2 || 0, paddingInner2 || 0, paddingOuter2 || 0);
}
function bandwidth(name, group2) {
  const s = getScale(name, (group2 || this).context);
  return s && s.bandwidth ? s.bandwidth() : 0;
}
function copy$1(name, group2) {
  const s = getScale(name, (group2 || this).context);
  return s ? s.copy() : void 0;
}
function domain$2(name, group2) {
  const s = getScale(name, (group2 || this).context);
  return s ? s.domain() : [];
}
function invert(name, range2, group2) {
  const s = getScale(name, (group2 || this).context);
  return !s ? void 0 : isArray$1(range2) ? (s.invertRange || s.invert)(range2) : (s.invert || s.invertExtent)(range2);
}
function range$4(name, group2) {
  const s = getScale(name, (group2 || this).context);
  return s && s.range ? s.range() : [];
}
function scale$2(name, value2, group2) {
  const s = getScale(name, (group2 || this).context);
  return s ? s(value2) : void 0;
}
function scaleGradient(scale2, p02, p1, count2, group2) {
  scale2 = getScale(scale2, (group2 || this).context);
  const gradient2 = Gradient$1(p02, p1);
  let stops = scale2.domain(), min2 = stops[0], max2 = peek$2(stops), fraction = identity$6;
  if (!(max2 - min2)) {
    scale2 = (scale2.interpolator ? scale$4("sequential")().interpolator(scale2.interpolator()) : scale$4("linear")().interpolate(scale2.interpolate()).range(scale2.range())).domain([min2 = 0, max2 = 1]);
  } else {
    fraction = scaleFraction(scale2, min2, max2);
  }
  if (scale2.ticks) {
    stops = scale2.ticks(+count2 || 15);
    if (min2 !== stops[0]) stops.unshift(min2);
    if (max2 !== peek$2(stops)) stops.push(max2);
  }
  stops.forEach((_) => gradient2.stop(fraction(_), scale2(_)));
  return gradient2;
}
function geoShape(projection2, geojson, group2) {
  const p = getScale(projection2, (group2 || this).context);
  return function(context2) {
    return p ? p.path.context(context2)(geojson) : "";
  };
}
function pathShape(path2) {
  let p = null;
  return function(context2) {
    return context2 ? pathRender(context2, p = p || parse$4(path2)) : path2;
  };
}
const datum = (d) => d.data;
function treeNodes(name, context2) {
  const tree2 = data$1.call(context2, name);
  return tree2.root && tree2.root.lookup || {};
}
function treePath(name, source2, target2) {
  const nodes = treeNodes(name, this), s = nodes[source2], t4 = nodes[target2];
  return s && t4 ? s.path(t4).map(datum) : void 0;
}
function treeAncestors(name, node2) {
  const n = treeNodes(name, this)[node2];
  return n ? n.ancestors().map(datum) : void 0;
}
const _window = () => typeof window !== "undefined" && window || null;
function screen() {
  const w2 = _window();
  return w2 ? w2.screen : {};
}
function windowSize() {
  const w2 = _window();
  return w2 ? [w2.innerWidth, w2.innerHeight] : [void 0, void 0];
}
function containerSize() {
  const view = this.context.dataflow, el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [void 0, void 0];
}
function intersect(b2, opt, group2) {
  if (!b2) return [];
  const [u2, v] = b2, box = new Bounds().set(u2[0], u2[1], v[0], v[1]), scene = group2 || this.context.dataflow.scenegraph().root;
  return intersect$2(scene, box, filter(opt));
}
function filter(opt) {
  let p = null;
  if (opt) {
    const types = array$5(opt.marktype), names = array$5(opt.markname);
    p = (_) => (!types.length || types.some((t4) => _.marktype === t4)) && (!names.length || names.some((s) => _.name === s));
  }
  return p;
}
function lassoAppend(lasso, x2, y2) {
  let minDist = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
  const last = lasso[lasso.length - 1];
  if (last === void 0 || Math.sqrt((last[0] - x2) ** 2 + (last[1] - y2) ** 2) > minDist) {
    lasso.push([x2, y2]);
    return [...lasso];
  }
  return lasso;
}
function lassoPath(lasso) {
  return (lasso !== null && lasso !== void 0 ? lasso : []).reduce((svg, _ref, i) => {
    let [x2, y2] = _ref;
    return svg += i == 0 ? "M ".concat(x2, ",").concat(y2, " ") : i === lasso.length - 1 ? " Z" : "L ".concat(x2, ",").concat(y2, " ");
  }, "");
}
function intersectLasso(markname, pixelLasso, unit2) {
  const {
    x: x2,
    y: y2,
    mark: mark2
  } = unit2;
  const bb = new Bounds().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
  for (const [px2, py2] of pixelLasso) {
    if (px2 < bb.x1) bb.x1 = px2;
    if (px2 > bb.x2) bb.x2 = px2;
    if (py2 < bb.y1) bb.y1 = py2;
    if (py2 > bb.y2) bb.y2 = py2;
  }
  bb.translate(x2, y2);
  const intersection2 = intersect([[bb.x1, bb.y1], [bb.x2, bb.y2]], markname, mark2);
  return intersection2.filter((tuple) => pointInPolygon$1(tuple.x, tuple.y, pixelLasso));
}
function pointInPolygon$1(testx, testy, polygon) {
  let intersections = 0;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const [prevX, prevY] = polygon[j];
    const [x2, y2] = polygon[i];
    if (y2 > testy != prevY > testy && testx < (prevX - x2) * (testy - y2) / (prevY - y2) + x2) {
      intersections++;
    }
  }
  return intersections & 1;
}
const functionContext = {
  random() {
    return random();
  },
  // override default
  cumulativeNormal,
  cumulativeLogNormal,
  cumulativeUniform,
  densityNormal,
  densityLogNormal,
  densityUniform,
  quantileNormal,
  quantileLogNormal,
  quantileUniform,
  sampleNormal,
  sampleLogNormal,
  sampleUniform,
  isArray: isArray$1,
  isBoolean: isBoolean$2,
  isDate: isDate$1,
  isDefined(_) {
    return _ !== void 0;
  },
  isNumber: isNumber$1,
  isObject: isObject$1,
  isRegExp,
  isString,
  isTuple,
  isValid(_) {
    return _ != null && _ === _;
  },
  toBoolean,
  toDate(_) {
    return toDate(_);
  },
  // suppress extra arguments
  toNumber,
  toString,
  indexof: indexof$1,
  join,
  lastindexof,
  replace: replace$1,
  reverse: reverse$1,
  slice: slice$2,
  flush,
  lerp,
  merge: merge$1,
  pad: pad$2,
  peek: peek$2,
  pluck,
  span,
  inrange,
  truncate: truncate$1,
  rgb: rgb$3,
  lab: lab$1,
  hcl: hcl$2,
  hsl: hsl$4,
  luminance,
  contrast,
  sequence: range$6,
  format,
  utcFormat,
  utcParse,
  utcOffset,
  utcSequence,
  timeFormat: timeFormat$1,
  timeParse,
  timeOffset,
  timeSequence,
  timeUnitSpecifier,
  monthFormat,
  monthAbbrevFormat,
  dayFormat,
  dayAbbrevFormat,
  quarter,
  utcquarter,
  week,
  utcweek,
  dayofyear,
  utcdayofyear,
  warn: warn$1,
  info,
  debug: debug$3,
  extent(_) {
    return extent(_);
  },
  // suppress extra arguments
  inScope,
  intersect,
  clampRange,
  pinchDistance,
  pinchAngle,
  screen,
  containerSize,
  windowSize,
  bandspace,
  setdata,
  pathShape,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog,
  encode,
  modify,
  lassoAppend,
  lassoPath,
  intersectLasso
};
const eventFunctions = ["view", "item", "group", "xy", "x", "y"], eventPrefix = "event.vega.", thisPrefix = "this.", astVisitors = {};
const codegenParams = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (id2) => "_[".concat($(SignalPrefix + id2), "]"),
  functions: buildFunctions,
  constants: Constants$1,
  visitors: astVisitors
};
const codeGenerator = codegen(codegenParams);
function buildFunctions(codegen2) {
  const fn = Functions$1(codegen2);
  eventFunctions.forEach((name) => fn[name] = eventPrefix + name);
  for (const name in functionContext) {
    fn[name] = thisPrefix + name;
  }
  extend$3(fn, internalScaleFunctions(codegen2, functionContext, astVisitors));
  return fn;
}
function expressionFunction(name, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name];
  }
  functionContext[name] = fn;
  if (visitor) astVisitors[name] = visitor;
  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;
  return this;
}
expressionFunction("bandwidth", bandwidth, scaleVisitor);
expressionFunction("copy", copy$1, scaleVisitor);
expressionFunction("domain", domain$2, scaleVisitor);
expressionFunction("range", range$4, scaleVisitor);
expressionFunction("invert", invert, scaleVisitor);
expressionFunction("scale", scale$2, scaleVisitor);
expressionFunction("gradient", scaleGradient, scaleVisitor);
expressionFunction("geoArea", geoArea, scaleVisitor);
expressionFunction("geoBounds", geoBounds, scaleVisitor);
expressionFunction("geoCentroid", geoCentroid, scaleVisitor);
expressionFunction("geoShape", geoShape, scaleVisitor);
expressionFunction("indata", indata, indataVisitor);
expressionFunction("data", data$1, dataVisitor);
expressionFunction("treePath", treePath, dataVisitor);
expressionFunction("treeAncestors", treeAncestors, dataVisitor);
expressionFunction("vlSelectionTest", selectionTest, selectionVisitor);
expressionFunction("vlSelectionIdTest", selectionIdTest, selectionVisitor);
expressionFunction("vlSelectionResolve", selectionResolve, selectionVisitor);
expressionFunction("vlSelectionTuples", selectionTuples);
function parser(expr2, scope) {
  const params2 = {};
  let ast;
  try {
    expr2 = isString(expr2) ? expr2 : $(expr2) + "";
    ast = parser$1(expr2);
  } catch (err) {
    error("Expression parse error: " + expr2);
  }
  ast.visit((node2) => {
    if (node2.type !== CallExpression) return;
    const name = node2.callee.name, visit2 = codegenParams.visitors[name];
    if (visit2) visit2(name, node2.arguments, scope, params2);
  });
  const gen = codeGenerator(ast);
  gen.globals.forEach((name) => {
    const signalName = SignalPrefix + name;
    if (!has$2(params2, signalName) && scope.getSignal(name)) {
      params2[signalName] = scope.signalRef(name);
    }
  });
  return {
    $expr: extend$3({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params2
  };
}
function parse$3(spec) {
  const ctx = this, operators = spec.operators || [];
  if (spec.background) {
    ctx.background = spec.background;
  }
  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  }
  if (spec.locale) {
    ctx.locale = spec.locale;
  }
  operators.forEach((entry2) => ctx.parseOperator(entry2));
  operators.forEach((entry2) => ctx.parseOperatorParameters(entry2));
  (spec.streams || []).forEach((entry2) => ctx.parseStream(entry2));
  (spec.updates || []).forEach((entry2) => ctx.parseUpdate(entry2));
  return ctx.resolve();
}
const Skip$2 = toSet(["rule"]), Swap = toSet(["group", "image", "rect"]);
function adjustSpatial$1(encode2, marktype) {
  let code = "";
  if (Skip$2[marktype]) return code;
  if (encode2.x2) {
    if (encode2.x) {
      if (Swap[marktype]) {
        code += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;";
      }
      code += "o.width=o.x2-o.x;";
    } else {
      code += "o.x=o.x2-(o.width||0);";
    }
  }
  if (encode2.xc) {
    code += "o.x=o.xc-(o.width||0)/2;";
  }
  if (encode2.y2) {
    if (encode2.y) {
      if (Swap[marktype]) {
        code += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;";
      }
      code += "o.height=o.y2-o.y;";
    } else {
      code += "o.y=o.y2-(o.height||0);";
    }
  }
  if (encode2.yc) {
    code += "o.y=o.yc-(o.height||0)/2;";
  }
  return code;
}
function canonicalType(type2) {
  return (type2 + "").toLowerCase();
}
function isOperator(type2) {
  return canonicalType(type2) === "operator";
}
function isCollect(type2) {
  return canonicalType(type2) === "collect";
}
function expression$2(ctx, args, code) {
  if (code[code.length - 1] !== ";") {
    code = "return(" + code + ");";
  }
  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
}
function _compare(u2, v, lt2, gt2) {
  return "((u = ".concat(u2, ") < (v = ").concat(v, ") || u == null) && v != null ? ").concat(lt2, "\n  : (u > v || v == null) && u != null ? ").concat(gt2, "\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ").concat(lt2, "\n  : v !== v && u === u ? ").concat(gt2, " : ");
}
var expressionCodegen = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (ctx, expr2) => expression$2(ctx, ["_"], expr2.code),
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (ctx, expr2) => expression$2(ctx, ["datum", "_"], expr2.code),
  /**
   * Parse an expression applied to an event stream.
   */
  event: (ctx, expr2) => expression$2(ctx, ["event"], expr2.code),
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (ctx, expr2) => {
    const code = "var datum=event.item&&event.item.datum;return ".concat(expr2.code, ";");
    return expression$2(ctx, ["_", "event"], code);
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (ctx, encode2) => {
    const {
      marktype,
      channels
    } = encode2;
    let code = "var o=item,datum=o.datum,m=0,$;";
    for (const name in channels) {
      const o = "o[" + $(name) + "]";
      code += "$=".concat(channels[name].code, ";if(").concat(o, "!==$)").concat(o, "=$,m=1;");
    }
    code += adjustSpatial$1(channels, marktype);
    code += "return m;";
    return expression$2(ctx, ["item", "_"], code);
  },
  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(path2) {
      const ref2 = "[".concat(path2.map($).join("]["), "]");
      const get2 = Function("_", "return _".concat(ref2, ";"));
      get2.path = ref2;
      return get2;
    },
    comparator(fields, orders) {
      let t4;
      const map2 = (f, i) => {
        const o = orders[i];
        let u2, v;
        if (f.path) {
          u2 = "a".concat(f.path);
          v = "b".concat(f.path);
        } else {
          (t4 = t4 || {})["f" + i] = f;
          u2 = "this.f".concat(i, "(a)");
          v = "this.f".concat(i, "(b)");
        }
        return _compare(u2, v, -o, o);
      };
      const fn = Function("a", "b", "var u, v; return " + fields.map(map2).join("") + "0;");
      return t4 ? fn.bind(t4) : fn;
    }
  }
};
function parseOperator(spec) {
  const ctx = this;
  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}
function parseOperatorParameters(spec) {
  const ctx = this;
  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op) error("Invalid operator id: " + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}
function parseParameters$1(spec, params2) {
  params2 = params2 || {};
  const ctx = this;
  for (const key2 in spec) {
    const value2 = spec[key2];
    params2[key2] = isArray$1(value2) ? value2.map((v) => parseParameter$2(v, ctx, params2)) : parseParameter$2(value2, ctx, params2);
  }
  return params2;
}
function parseParameter$2(spec, ctx, params2) {
  if (!spec || !isObject$1(spec)) return spec;
  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];
    if (has$2(spec, p.key)) {
      return p.parse(spec, ctx, params2);
    }
  }
  return spec;
}
var PARSERS = [{
  key: "$ref",
  parse: getOperator
}, {
  key: "$key",
  parse: getKey
}, {
  key: "$expr",
  parse: getExpression
}, {
  key: "$field",
  parse: getField
}, {
  key: "$encode",
  parse: getEncode
}, {
  key: "$compare",
  parse: getCompare
}, {
  key: "$context",
  parse: getContext
}, {
  key: "$subflow",
  parse: getSubflow
}, {
  key: "$tupleid",
  parse: getTupleId
}];
function getOperator(_, ctx) {
  return ctx.get(_.$ref) || error("Operator not defined: " + _.$ref);
}
function getExpression(_, ctx, params2) {
  if (_.$params) {
    ctx.parseParameters(_.$params, params2);
  }
  const k = "e:" + _.$expr.code + "_" + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields, _.$name));
}
function getKey(_, ctx) {
  const k = "k:" + _.$key + "_" + !!_.$flat;
  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));
}
function getField(_, ctx) {
  if (!_.$field) return null;
  const k = "f:" + _.$field + "_" + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = field$1(_.$field, _.$name, ctx.expr.codegen));
}
function getCompare(_, ctx) {
  const k = "c:" + _.$compare + "_" + _.$order, c2 = array$5(_.$compare).map((_2) => _2 && _2.$tupleid ? tupleid : _2);
  return ctx.fn[k] || (ctx.fn[k] = compare$9(c2, _.$order, ctx.expr.codegen));
}
function getEncode(_, ctx) {
  const spec = _.$encode, encode2 = {};
  for (const name in spec) {
    const enc = spec[name];
    encode2[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode2[name].output = enc.$output;
  }
  return encode2;
}
function getContext(_, ctx) {
  return ctx;
}
function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function(dataflow, key2, parent) {
    const subctx = ctx.fork().parse(spec), op = subctx.get(spec.operators[0].id), p = subctx.signals.parent;
    if (p) p.set(parent);
    op.detachSubflow = () => ctx.detach(subctx);
    return op;
  };
}
function getTupleId() {
  return tupleid;
}
function parseStream$2(spec) {
  var ctx = this, filter2 = spec.filter != null ? ctx.eventExpression(spec.filter) : void 0, stream2 = spec.stream != null ? ctx.get(spec.stream) : void 0, args;
  if (spec.source) {
    stream2 = ctx.events(spec.source, spec.type, filter2);
  } else if (spec.merge) {
    args = spec.merge.map((_) => ctx.get(_));
    stream2 = args[0].merge.apply(args[0], args.slice(1));
  }
  if (spec.between) {
    args = spec.between.map((_) => ctx.get(_));
    stream2 = stream2.between(args[0], args[1]);
  }
  if (spec.filter) {
    stream2 = stream2.filter(filter2);
  }
  if (spec.throttle != null) {
    stream2 = stream2.throttle(+spec.throttle);
  }
  if (spec.debounce != null) {
    stream2 = stream2.debounce(+spec.debounce);
  }
  if (stream2 == null) {
    error("Invalid stream definition: " + JSON.stringify(spec));
  }
  if (spec.consume) stream2.consume(true);
  ctx.stream(spec, stream2);
}
function parseUpdate$1(spec) {
  var ctx = this, srcid = isObject$1(srcid = spec.source) ? srcid.$ref : srcid, source2 = ctx.get(srcid), target2 = null, update2 = spec.update, params2 = void 0;
  if (!source2) error("Source not defined: " + spec.source);
  target2 = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);
  if (update2 && update2.$expr) {
    if (update2.$params) {
      params2 = ctx.parseParameters(update2.$params);
    }
    update2 = ctx.handlerExpression(update2.$expr);
  }
  ctx.update(spec, source2, target2, update2, params2);
}
const SKIP = {
  skip: true
};
function getState$1(options) {
  var ctx = this, state = {};
  if (options.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach((key2) => {
      const op = ctx.signals[key2];
      if (options.signals(key2, op)) {
        signals[key2] = op.value;
      }
    });
  }
  if (options.data) {
    var data2 = state.data = {};
    Object.keys(ctx.data).forEach((key2) => {
      const dataset = ctx.data[key2];
      if (options.data(key2, dataset)) {
        data2[key2] = dataset.input.value;
      }
    });
  }
  if (ctx.subcontext && options.recurse !== false) {
    state.subcontext = ctx.subcontext.map((ctx2) => ctx2.getState(options));
  }
  return state;
}
function setState$1(state) {
  var ctx = this, df = ctx.dataflow, data2 = state.data, signals = state.signals;
  Object.keys(signals || {}).forEach((key2) => {
    df.update(ctx.signals[key2], signals[key2], SKIP);
  });
  Object.keys(data2 || {}).forEach((key2) => {
    df.pulse(ctx.data[key2].input, df.changeset().remove(truthy).insert(data2[key2]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx) subctx.setState(substate);
  });
}
function context(df, transforms2, functions, expr2) {
  return new Context$1(df, transforms2, functions, expr2);
}
function Context$1(df, transforms2, functions, expr2) {
  this.dataflow = df;
  this.transforms = transforms2;
  this.events = df.events.bind(df);
  this.expr = expr2 || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};
  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}
function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);
  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}
Context$1.prototype = Subcontext.prototype = {
  fork() {
    const ctx = new Subcontext(this);
    (this.subcontext || (this.subcontext = [])).push(ctx);
    return ctx;
  },
  detach(ctx) {
    this.subcontext = this.subcontext.filter((c2) => c2 !== ctx);
    const keys2 = Object.keys(ctx.nodes);
    for (const key2 of keys2) ctx.nodes[key2]._targets = null;
    for (const key2 of keys2) ctx.nodes[key2].detach();
    ctx.nodes = null;
  },
  get(id2) {
    return this.nodes[id2];
  },
  set(id2, node2) {
    return this.nodes[id2] = node2;
  },
  add(spec, op) {
    const ctx = this, df = ctx.dataflow, data2 = spec.value;
    ctx.set(spec.id, op);
    if (isCollect(spec.type) && data2) {
      if (data2.$ingest) {
        df.ingest(op, data2.$ingest, data2.$format);
      } else if (data2.$request) {
        df.preload(op, data2.$request, data2.$format);
      } else {
        df.pulse(op, df.changeset().insert(data2));
      }
    }
    if (spec.root) {
      ctx.root = op;
    }
    if (spec.parent) {
      let p = ctx.get(spec.parent.$ref);
      if (p) {
        df.connect(p, [op]);
        op.targets().add(p);
      } else {
        (ctx.unresolved = ctx.unresolved || []).push(() => {
          p = ctx.get(spec.parent.$ref);
          df.connect(p, [op]);
          op.targets().add(p);
        });
      }
    }
    if (spec.signal) {
      ctx.signals[spec.signal] = op;
    }
    if (spec.scale) {
      ctx.scales[spec.scale] = op;
    }
    if (spec.data) {
      for (const name in spec.data) {
        const data3 = ctx.data[name] || (ctx.data[name] = {});
        spec.data[name].forEach((role) => data3[role] = op);
      }
    }
  },
  resolve() {
    (this.unresolved || []).forEach((fn) => fn());
    delete this.unresolved;
    return this;
  },
  operator(spec, update2) {
    this.add(spec, this.dataflow.add(spec.value, update2));
  },
  transform(spec, type2) {
    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type2)]));
  },
  stream(spec, stream2) {
    this.set(spec.id, stream2);
  },
  update(spec, stream2, target2, update2, params2) {
    this.dataflow.on(stream2, target2, update2, params2, spec.options);
  },
  // expression parsing
  operatorExpression(expr2) {
    return this.expr.operator(this, expr2);
  },
  parameterExpression(expr2) {
    return this.expr.parameter(this, expr2);
  },
  eventExpression(expr2) {
    return this.expr.event(this, expr2);
  },
  handlerExpression(expr2) {
    return this.expr.handler(this, expr2);
  },
  encodeExpression(encode2) {
    return this.expr.encode(this, encode2);
  },
  // parse methods
  parse: parse$3,
  parseOperator,
  parseOperatorParameters,
  parseParameters: parseParameters$1,
  parseStream: parseStream$2,
  parseUpdate: parseUpdate$1,
  // state methods
  getState: getState$1,
  setState: setState$1
};
function initializeAria(view) {
  const el = view.container();
  if (el) {
    el.setAttribute("role", "graphics-document");
    el.setAttribute("aria-roleDescription", "visualization");
    ariaLabel(el, view.description());
  }
}
function ariaLabel(el, desc) {
  if (el) desc == null ? el.removeAttribute("aria-label") : el.setAttribute("aria-label", desc);
}
function background(view) {
  view.add(null, (_) => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}
const Default = "default";
function cursor$2(view) {
  const cursor2 = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  }));
  view.on(view.events("view", "mousemove"), cursor2, (_, event2) => {
    const value2 = cursor2.value, user = value2 ? isString(value2) ? value2 : value2.user : Default, item = event2.item && event2.item.cursor || null;
    return value2 && user === value2.user && item == value2.item ? value2 : {
      user,
      item
    };
  });
  view.add(null, function(_) {
    let user = _.cursor, item = this.value;
    if (!isString(user)) {
      item = user.item;
      user = user.user;
    }
    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor2
  });
}
function setCursor(view, cursor2) {
  const el = view.globalCursor() ? typeof document !== "undefined" && document.body : view.container();
  if (el) {
    return cursor2 == null ? el.style.removeProperty("cursor") : el.style.cursor = cursor2;
  }
}
function dataref(view, name) {
  var data2 = view._runtime.data;
  if (!has$2(data2, name)) {
    error("Unrecognized data set: " + name);
  }
  return data2[name];
}
function data(name, values2) {
  return arguments.length < 2 ? dataref(this, name).values.value : change.call(this, name, changeset().remove(truthy).insert(values2));
}
function change(name, changes) {
  if (!isChangeSet(changes)) {
    error("Second argument to changes must be a changeset.");
  }
  const dataset = dataref(this, name);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert$1(name, _) {
  return change.call(this, name, changeset().insert(_));
}
function remove(name, _) {
  return change.call(this, name, changeset().remove(_));
}
function width$1(view) {
  var padding2 = view.padding();
  return Math.max(0, view._viewWidth + padding2.left + padding2.right);
}
function height$1(view) {
  var padding2 = view.padding();
  return Math.max(0, view._viewHeight + padding2.top + padding2.bottom);
}
function offset$1(view) {
  var padding2 = view.padding(), origin = view._origin;
  return [padding2.left + origin[0], padding2.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset$1(view), w2 = width$1(view), h2 = height$1(view);
  view._renderer.background(view.background());
  view._renderer.resize(w2, h2, origin);
  view._handler.origin(origin);
  view._resizeListeners.forEach((handler) => {
    try {
      handler(w2, h2);
    } catch (error2) {
      view.error(error2);
    }
  });
}
function eventExtend(view, event2, item) {
  var r2 = view._renderer, el = r2 && r2.canvas(), p, e3, translate2;
  if (el) {
    translate2 = offset$1(view);
    e3 = event2.changedTouches ? event2.changedTouches[0] : event2;
    p = point$2(e3, el);
    p[0] -= translate2[0];
    p[1] -= translate2[1];
  }
  event2.dataflow = view;
  event2.item = item;
  event2.vega = extension(view, item, p);
  return event2;
}
function extension(view, item, point2) {
  const itemGroup = item ? item.mark.marktype === "group" ? item : item.mark.group : null;
  function group2(name) {
    var g = itemGroup, i;
    if (name) for (i = item; i; i = i.mark.group) {
      if (i.mark.name === name) {
        g = i;
        break;
      }
    }
    return g && g.mark && g.mark.interactive ? g : {};
  }
  function xy(item2) {
    if (!item2) return point2;
    if (isString(item2)) item2 = group2(item2);
    const p = point2.slice();
    while (item2) {
      p[0] -= item2.x || 0;
      p[1] -= item2.y || 0;
      item2 = item2.mark && item2.mark.group;
    }
    return p;
  }
  return {
    view: constant$5(view),
    item: constant$5(item || {}),
    group: group2,
    xy,
    x: (item2) => xy(item2)[0],
    y: (item2) => xy(item2)[1]
  };
}
const VIEW$1 = "view", TIMER = "timer", WINDOW = "window", NO_TRAP = {
  trap: false
};
function initializeEventConfig(config) {
  const events2 = extend$3({
    defaults: {}
  }, config);
  const unpack = (obj, keys2) => {
    keys2.forEach((k) => {
      if (isArray$1(obj[k])) obj[k] = toSet(obj[k]);
    });
  };
  unpack(events2.defaults, ["prevent", "allow"]);
  unpack(events2, ["view", "window", "selector"]);
  return events2;
}
function trackEventListener(view, sources, type2, handler) {
  view._eventListeners.push({
    type: type2,
    sources: array$5(sources),
    handler
  });
}
function prevent(view, type2) {
  var def2 = view._eventConfig.defaults, prevent2 = def2.prevent, allow = def2.allow;
  return prevent2 === false || allow === true ? false : prevent2 === true || allow === false ? true : prevent2 ? prevent2[type2] : allow ? !allow[type2] : view.preventDefault();
}
function permit(view, key2, type2) {
  const rule2 = view._eventConfig && view._eventConfig[key2];
  if (rule2 === false || isObject$1(rule2) && !rule2[type2]) {
    view.warn("Blocked ".concat(key2, " ").concat(type2, " event listener."));
    return false;
  }
  return true;
}
function events$1(source2, type2, filter2) {
  var view = this, s = new EventStream(filter2), send = function(e3, item) {
    view.runAsync(null, () => {
      if (source2 === VIEW$1 && prevent(view, type2)) {
        e3.preventDefault();
      }
      s.receive(eventExtend(view, e3, item));
    });
  }, sources;
  if (source2 === TIMER) {
    if (permit(view, "timer", type2)) {
      view.timer(send, type2);
    }
  } else if (source2 === VIEW$1) {
    if (permit(view, "view", type2)) {
      view.addEventListener(type2, send, NO_TRAP);
    }
  } else {
    if (source2 === WINDOW) {
      if (permit(view, "window", type2) && typeof window !== "undefined") {
        sources = [window];
      }
    } else if (typeof document !== "undefined") {
      if (permit(view, "selector", type2)) {
        sources = document.querySelectorAll(source2);
      }
    }
    if (!sources) {
      view.warn("Can not resolve event source: " + source2);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type2, send);
      }
      trackEventListener(view, sources, type2, send);
    }
  }
  return s;
}
function itemFilter(event2) {
  return event2.item;
}
function markTarget(event2) {
  return event2.item.mark.source;
}
function invoke(name) {
  return function(_, event2) {
    return event2.vega.view().changeset().encode(event2.item, name);
  };
}
function hover(hoverSet, leaveSet) {
  hoverSet = [hoverSet || "hover"];
  leaveSet = [leaveSet || "update", hoverSet[0]];
  this.on(this.events("view", "mouseover", itemFilter), markTarget, invoke(hoverSet));
  this.on(this.events("view", "mouseout", itemFilter), markTarget, invoke(leaveSet));
  return this;
}
function finalize() {
  var tooltip2 = this._tooltip, timers = this._timers, listeners = this._eventListeners, n, m2, e3;
  n = timers.length;
  while (--n >= 0) {
    timers[n].stop();
  }
  n = listeners.length;
  while (--n >= 0) {
    e3 = listeners[n];
    m2 = e3.sources.length;
    while (--m2 >= 0) {
      e3.sources[m2].removeEventListener(e3.type, e3.handler);
    }
  }
  if (tooltip2) {
    tooltip2.call(this, this._handler, null, null, null);
  }
  return this;
}
function element(tag, attr2, text2) {
  const el = document.createElement(tag);
  for (const key2 in attr2) el.setAttribute(key2, attr2[key2]);
  if (text2 != null) el.textContent = text2;
  return el;
}
const BindClass = "vega-bind", NameClass = "vega-bind-name", RadioClass = "vega-bind-radio";
function bind(view, el, binding) {
  if (!el) return;
  const param2 = binding.param;
  let bind2 = binding.state;
  if (!bind2) {
    bind2 = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: (value2) => {
        if (value2 != view.signal(param2.signal)) {
          view.runAsync(null, () => {
            bind2.source = true;
            view.signal(param2.signal, value2);
          });
        }
      }
    };
    if (param2.debounce) {
      bind2.update = debounce$1(param2.debounce, bind2.update);
    }
  }
  const create2 = param2.input == null && param2.element ? target : generate$1;
  create2(bind2, el, param2, view);
  if (!bind2.active) {
    view.on(view._signals[param2.signal], null, () => {
      bind2.source ? bind2.source = false : bind2.set(view.signal(param2.signal));
    });
    bind2.active = true;
  }
  return bind2;
}
function target(bind2, node2, param2, view) {
  const type2 = param2.event || "input";
  const handler = () => bind2.update(node2.value);
  view.signal(param2.signal, node2.value);
  node2.addEventListener(type2, handler);
  trackEventListener(view, node2, type2, handler);
  bind2.set = (value2) => {
    node2.value = value2;
    node2.dispatchEvent(event(type2));
  };
}
function event(type2) {
  return typeof Event !== "undefined" ? new Event(type2) : {
    type: type2
  };
}
function generate$1(bind2, el, param2, view) {
  const value2 = view.signal(param2.signal);
  const div = element("div", {
    "class": BindClass
  });
  const wrapper = param2.input === "radio" ? div : div.appendChild(element("label"));
  wrapper.appendChild(element("span", {
    "class": NameClass
  }, param2.name || param2.signal));
  el.appendChild(div);
  let input = form;
  switch (param2.input) {
    case "checkbox":
      input = checkbox;
      break;
    case "select":
      input = select;
      break;
    case "radio":
      input = radio;
      break;
    case "range":
      input = range$3;
      break;
  }
  input(bind2, wrapper, param2, value2);
}
function form(bind2, el, param2, value2) {
  const node2 = element("input");
  for (const key2 in param2) {
    if (key2 !== "signal" && key2 !== "element") {
      node2.setAttribute(key2 === "input" ? "type" : key2, param2[key2]);
    }
  }
  node2.setAttribute("name", param2.signal);
  node2.value = value2;
  el.appendChild(node2);
  node2.addEventListener("input", () => bind2.update(node2.value));
  bind2.elements = [node2];
  bind2.set = (value3) => node2.value = value3;
}
function checkbox(bind2, el, param2, value2) {
  const attr2 = {
    type: "checkbox",
    name: param2.signal
  };
  if (value2) attr2.checked = true;
  const node2 = element("input", attr2);
  el.appendChild(node2);
  node2.addEventListener("change", () => bind2.update(node2.checked));
  bind2.elements = [node2];
  bind2.set = (value3) => node2.checked = !!value3 || null;
}
function select(bind2, el, param2, value2) {
  const node2 = element("select", {
    name: param2.signal
  }), labels2 = param2.labels || [];
  param2.options.forEach((option, i) => {
    const attr2 = {
      value: option
    };
    if (valuesEqual(option, value2)) attr2.selected = true;
    node2.appendChild(element("option", attr2, (labels2[i] || option) + ""));
  });
  el.appendChild(node2);
  node2.addEventListener("change", () => {
    bind2.update(param2.options[node2.selectedIndex]);
  });
  bind2.elements = [node2];
  bind2.set = (value3) => {
    for (let i = 0, n = param2.options.length; i < n; ++i) {
      if (valuesEqual(param2.options[i], value3)) {
        node2.selectedIndex = i;
        return;
      }
    }
  };
}
function radio(bind2, el, param2, value2) {
  const group2 = element("span", {
    "class": RadioClass
  }), labels2 = param2.labels || [];
  el.appendChild(group2);
  bind2.elements = param2.options.map((option, i) => {
    const attr2 = {
      type: "radio",
      name: param2.signal,
      value: option
    };
    if (valuesEqual(option, value2)) attr2.checked = true;
    const input = element("input", attr2);
    input.addEventListener("change", () => bind2.update(option));
    const label2 = element("label", {}, (labels2[i] || option) + "");
    label2.prepend(input);
    group2.appendChild(label2);
    return input;
  });
  bind2.set = (value3) => {
    const nodes = bind2.elements, n = nodes.length;
    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value3)) nodes[i].checked = true;
    }
  };
}
function range$3(bind2, el, param2, value2) {
  value2 = value2 !== void 0 ? value2 : (+param2.max + +param2.min) / 2;
  const max2 = param2.max != null ? param2.max : Math.max(100, +value2) || 100, min2 = param2.min || Math.min(0, max2, +value2) || 0, step = param2.step || tickStep(min2, max2, 100);
  const node2 = element("input", {
    type: "range",
    name: param2.signal,
    min: min2,
    max: max2,
    step
  });
  node2.value = value2;
  const span2 = element("span", {}, +value2);
  el.appendChild(node2);
  el.appendChild(span2);
  const update2 = () => {
    span2.textContent = node2.value;
    bind2.update(+node2.value);
  };
  node2.addEventListener("input", update2);
  node2.addEventListener("change", update2);
  bind2.elements = [node2];
  bind2.set = (value3) => {
    node2.value = value3;
    span2.textContent = value3;
  };
}
function valuesEqual(a2, b2) {
  return a2 === b2 || a2 + "" === b2 + "";
}
function initializeRenderer(view, r2, el, constructor, scaleFactor, opt) {
  r2 = r2 || new constructor(view.loader());
  return r2.initialize(el, width$1(view), height$1(view), offset$1(view), scaleFactor, opt).background(view.background());
}
function trap(view, fn) {
  return !fn ? null : function() {
    try {
      fn.apply(this, arguments);
    } catch (error2) {
      view.error(error2);
    }
  };
}
function initializeHandler(view, prevHandler, el, constructor) {
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset$1(view), view);
  if (prevHandler) {
    prevHandler.handlers().forEach((h2) => {
      handler.on(h2.type, h2.handler);
    });
  }
  return handler;
}
function initialize(el, elBind) {
  const view = this, type2 = view._renderType, config = view._eventConfig.bind, module2 = renderModule(type2);
  el = view._el = el ? lookup$1(view, el, true) : null;
  initializeAria(view);
  if (!module2) view.error("Unrecognized renderer type: " + type2);
  const Handler3 = module2.handler || CanvasHandler, Renderer2 = el ? module2.renderer : module2.headless;
  view._renderer = !Renderer2 ? null : initializeRenderer(view, view._renderer, el, Renderer2);
  view._handler = initializeHandler(view, view._handler, el, Handler3);
  view._redraw = true;
  if (el && config !== "none") {
    elBind = elBind ? view._elBind = lookup$1(view, elBind, true) : el.appendChild(element("form", {
      "class": "vega-bindings"
    }));
    view._bind.forEach((_) => {
      if (_.param.element && config !== "container") {
        _.element = lookup$1(view, _.param.element, !!_.param.input);
      }
    });
    view._bind.forEach((_) => {
      bind(view, _.element || elBind, _);
    });
  }
  return view;
}
function lookup$1(view, el, clear2) {
  if (typeof el === "string") {
    if (typeof document !== "undefined") {
      el = document.querySelector(el);
      if (!el) {
        view.error("Signal bind element not found: " + el);
        return null;
      }
    } else {
      view.error("DOM document instance not found.");
      return null;
    }
  }
  if (el && clear2) {
    try {
      el.textContent = "";
    } catch (e3) {
      el = null;
      view.error(e3);
    }
  }
  return el;
}
const number$2 = (_) => +_ || 0;
const paddingObject$1 = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function padding$2(_) {
  return isObject$1(_) ? {
    top: number$2(_.top),
    bottom: number$2(_.bottom),
    left: number$2(_.left),
    right: number$2(_.right)
  } : paddingObject$1(number$2(_));
}
async function renderHeadless(view, type2, scaleFactor, opt) {
  const module2 = renderModule(type2), ctr = module2 && module2.headless;
  if (!ctr) error("Unrecognized renderer type: " + type2);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}
async function renderToImageURL(type2, scaleFactor) {
  if (type2 !== RenderType.Canvas && type2 !== RenderType.SVG && type2 !== RenderType.PNG) {
    error("Unrecognized image type: " + type2);
  }
  const r2 = await renderHeadless(this, type2, scaleFactor);
  return type2 === RenderType.SVG ? toBlobURL(r2.svg(), "image/svg+xml") : r2.canvas().toDataURL("image/png");
}
function toBlobURL(data2, mime) {
  const blob = new Blob([data2], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}
async function renderToCanvas(scaleFactor, opt) {
  const r2 = await renderHeadless(this, RenderType.Canvas, scaleFactor, opt);
  return r2.canvas();
}
async function renderToSVG(scaleFactor) {
  const r2 = await renderHeadless(this, RenderType.SVG, scaleFactor);
  return r2.svg();
}
function runtime(view, spec, expr2) {
  return context(view, transforms, functionContext, expr2).parse(spec);
}
function scale$1(name) {
  var scales2 = this._runtime.scales;
  if (!has$2(scales2, name)) {
    error("Unrecognized scale or projection: " + name);
  }
  return scales2[name].value;
}
var Width = "width", Height = "height", Padding = "padding", Skip$1 = {
  skip: true
};
function viewWidth(view, width2) {
  var a2 = view.autosize(), p = view.padding();
  return width2 - (a2 && a2.contains === Padding ? p.left + p.right : 0);
}
function viewHeight(view, height2) {
  var a2 = view.autosize(), p = view.padding();
  return height2 - (a2 && a2.contains === Padding ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s = view._signals, w2 = s[Width], h2 = s[Height], p = s[Padding];
  function resetSize() {
    view._autosize = view._resize = 1;
  }
  view._resizeWidth = view.add(null, (_) => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w2
  });
  view._resizeHeight = view.add(null, (_) => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h2
  });
  const resizePadding = view.add(null, resetSize, {
    pad: p
  });
  view._resizeWidth.rank = w2.rank + 1;
  view._resizeHeight.rank = h2.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth2, viewHeight2, width2, height2, origin, auto) {
  this.runAfter((view) => {
    let rerun2 = 0;
    view._autosize = 0;
    if (view.width() !== width2) {
      rerun2 = 1;
      view.signal(Width, width2, Skip$1);
      view._resizeWidth.skip(true);
    }
    if (view.height() !== height2) {
      rerun2 = 1;
      view.signal(Height, height2, Skip$1);
      view._resizeHeight.skip(true);
    }
    if (view._viewWidth !== viewWidth2) {
      view._resize = 1;
      view._viewWidth = viewWidth2;
    }
    if (view._viewHeight !== viewHeight2) {
      view._resize = 1;
      view._viewHeight = viewHeight2;
    }
    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    }
    if (rerun2) view.run("enter");
    if (auto) view.runAfter((v) => v.resize());
  }, false, 1);
}
function getState(options) {
  return this._runtime.getState(options || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}
function dataTest(name, data2) {
  return data2.modified && isArray$1(data2.input.value) && name.indexOf("_:vega:_");
}
function signalTest(name, op) {
  return !(name === "parent" || op instanceof transforms.proxy);
}
function setState(state) {
  this.runAsync(null, (v) => {
    v._trigger = false;
    v._runtime.setState(state);
  }, (v) => {
    v._trigger = true;
  });
  return this;
}
function timer(callback, delay) {
  function tick2(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed
    });
  }
  this._timers.push(interval$1(tick2, delay));
}
function defaultTooltip(handler, event2, item, value2) {
  const el = handler.element();
  if (el) el.setAttribute("title", formatTooltip(value2));
}
function formatTooltip(value2) {
  return value2 == null ? "" : isArray$1(value2) ? formatArray(value2) : isObject$1(value2) && !isDate$1(value2) ? formatObject(value2) : value2 + "";
}
function formatObject(obj) {
  return Object.keys(obj).map((key2) => {
    const v = obj[key2];
    return key2 + ": " + (isArray$1(v) ? formatArray(v) : formatValue$1(v));
  }).join("\n");
}
function formatArray(value2) {
  return "[" + value2.map(formatValue$1).join(", ") + "]";
}
function formatValue$1(value2) {
  return isArray$1(value2) ? "[…]" : isObject$1(value2) && !isDate$1(value2) ? "{…}" : value2;
}
function View$1(spec, options) {
  const view = this;
  options = options || {};
  Dataflow.call(view);
  if (options.loader) view.loader(options.loader);
  if (options.logger) view.logger(options.logger);
  if (options.logLevel != null) view.logLevel(options.logLevel);
  if (options.locale || spec.locale) {
    const loc = extend$3({}, spec.locale, options.locale);
    view.locale(locale(loc.number, loc.time));
  }
  view._el = null;
  view._elBind = null;
  view._renderType = options.renderer || RenderType.Canvas;
  view._scenegraph = new Scenegraph();
  const root2 = view._scenegraph.root;
  view._renderer = null;
  view._tooltip = options.tooltip || defaultTooltip, view._redraw = true;
  view._handler = new CanvasHandler().scene(root2);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = [];
  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor);
  const ctx = runtime(view, spec, options.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map((_) => ({
    state: null,
    param: extend$3({}, _)
  }));
  if (ctx.root) ctx.root.set(root2);
  root2.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root2.items));
  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view);
  background(view);
  cursor$2(view);
  view.description(spec.description);
  if (options.hover) view.hover();
  if (options.container) view.initialize(options.container, options.bind);
}
function lookupSignal(view, name) {
  return has$2(view._signals, name) ? view._signals[name] : error("Unrecognized signal name: " + $(name));
}
function findOperatorHandler(op, handler) {
  const h2 = (op._targets || []).filter((op2) => op2._update && op2._update.handler === handler);
  return h2.length ? h2[0] : null;
}
function addOperatorListener(view, name, op, handler) {
  let h2 = findOperatorHandler(op, handler);
  if (!h2) {
    h2 = trap(view, () => handler(name, op.value));
    h2.handler = handler;
    view.on(op, null, h2);
  }
  return view;
}
function removeOperatorListener(view, op, handler) {
  const h2 = findOperatorHandler(op, handler);
  if (h2) op._targets.remove(h2);
  return view;
}
inherits(View$1, Dataflow, {
  // -- DATAFLOW / RENDERING ----
  async evaluate(encode2, prerun, postrun) {
    await Dataflow.prototype.evaluate.call(this, encode2, prerun);
    if (this._redraw || this._resize) {
      try {
        if (this._renderer) {
          if (this._resize) {
            this._resize = 0;
            resizeRenderer(this);
          }
          await this._renderer.renderAsync(this._scenegraph.root);
        }
        this._redraw = false;
      } catch (e3) {
        this.error(e3);
      }
    }
    if (postrun) asyncCallback(this, postrun);
    return this;
  },
  dirty(item) {
    this._redraw = true;
    this._renderer && this._renderer.dirty(item);
  },
  // -- GET / SET ----
  description(text2) {
    if (arguments.length) {
      const desc = text2 != null ? text2 + "" : null;
      if (desc !== this._desc) ariaLabel(this._el, this._desc = desc);
      return this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(name, value2, options) {
    const op = lookupSignal(this, name);
    return arguments.length === 1 ? op.value : this.update(op, value2, options);
  },
  width(_) {
    return arguments.length ? this.signal("width", _) : this.signal("width");
  },
  height(_) {
    return arguments.length ? this.signal("height", _) : this.signal("height");
  },
  padding(_) {
    return arguments.length ? this.signal("padding", padding$2(_)) : padding$2(this.signal("padding"));
  },
  autosize(_) {
    return arguments.length ? this.signal("autosize", _) : this.signal("autosize");
  },
  background(_) {
    return arguments.length ? this.signal("background", _) : this.signal("background");
  },
  renderer(type2) {
    if (!arguments.length) return this._renderType;
    if (!renderModule(type2)) error("Unrecognized renderer type: " + type2);
    if (type2 !== this._renderType) {
      this._renderType = type2;
      this._resetRenderer();
    }
    return this;
  },
  tooltip(handler) {
    if (!arguments.length) return this._tooltip;
    if (handler !== this._tooltip) {
      this._tooltip = handler;
      this._resetRenderer();
    }
    return this;
  },
  loader(loader2) {
    if (!arguments.length) return this._loader;
    if (loader2 !== this._loader) {
      Dataflow.prototype.loader.call(this, loader2);
      this._resetRenderer();
    }
    return this;
  },
  resize() {
    this._autosize = 1;
    return this.touch(lookupSignal(this, "autosize"));
  },
  _resetRenderer() {
    if (this._renderer) {
      this._renderer = null;
      this.initialize(this._el, this._elBind);
    }
  },
  // -- SIZING ----
  _resizeView: resizeView,
  // -- EVENT HANDLING ----
  addEventListener(type2, handler, options) {
    let callback = handler;
    if (!(options && options.trap === false)) {
      callback = trap(this, handler);
      callback.raw = handler;
    }
    this._handler.on(type2, callback);
    return this;
  },
  removeEventListener(type2, handler) {
    var handlers = this._handler.handlers(type2), i = handlers.length, h2, t4;
    while (--i >= 0) {
      t4 = handlers[i].type;
      h2 = handlers[i].handler;
      if (type2 === t4 && (handler === h2 || handler === h2.raw)) {
        this._handler.off(t4, h2);
        break;
      }
    }
    return this;
  },
  addResizeListener(handler) {
    const l = this._resizeListeners;
    if (l.indexOf(handler) < 0) {
      l.push(handler);
    }
    return this;
  },
  removeResizeListener(handler) {
    var l = this._resizeListeners, i = l.indexOf(handler);
    if (i >= 0) {
      l.splice(i, 1);
    }
    return this;
  },
  addSignalListener(name, handler) {
    return addOperatorListener(this, name, lookupSignal(this, name), handler);
  },
  removeSignalListener(name, handler) {
    return removeOperatorListener(this, lookupSignal(this, name), handler);
  },
  addDataListener(name, handler) {
    return addOperatorListener(this, name, dataref(this, name).values, handler);
  },
  removeDataListener(name, handler) {
    return removeOperatorListener(this, dataref(this, name).values, handler);
  },
  globalCursor(_) {
    if (arguments.length) {
      if (this._globalCursor !== !!_) {
        const prev2 = setCursor(this, null);
        this._globalCursor = !!_;
        if (prev2) setCursor(this, prev2);
      }
      return this;
    } else {
      return this._globalCursor;
    }
  },
  preventDefault(_) {
    if (arguments.length) {
      this._preventDefault = _;
      return this;
    } else {
      return this._preventDefault;
    }
  },
  timer,
  events: events$1,
  finalize,
  hover,
  // -- DATA ----
  data,
  change,
  insert: insert$1,
  remove,
  // -- SCALES --
  scale: scale$1,
  // -- INITIALIZATION ----
  initialize,
  // -- HEADLESS RENDERING ----
  toImageURL: renderToImageURL,
  toCanvas: renderToCanvas,
  toSVG: renderToSVG,
  // -- SAVE / RESTORE STATE ----
  getState,
  setState
});
const VIEW = "view", LBRACK = "[", RBRACK = "]", LBRACE = "{", RBRACE = "}", COLON = ":", COMMA = ",", NAME = "@", GT = ">", ILLEGAL = /[[\]{}]/, DEFAULT_MARKS = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
let DEFAULT_SOURCE, MARKS;
function eventSelector(selector, source2, marks) {
  DEFAULT_SOURCE = source2 || VIEW;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}
function isMarkType(type2) {
  return MARKS[type2];
}
function find$1(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count2 = 0, c2;
  for (; i < n; ++i) {
    c2 = s[i];
    if (!count2 && c2 === endChar) return i;
    else if (popChar && popChar.indexOf(c2) >= 0) --count2;
    else if (pushChar && pushChar.indexOf(c2) >= 0) ++count2;
  }
  return i;
}
function parseMerge(s) {
  const output2 = [], n = s.length;
  let start = 0, i = 0;
  while (i < n) {
    i = find$1(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output2.push(s.substring(start, i).trim());
    start = ++i;
  }
  if (output2.length === 0) {
    throw "Empty event selector: " + s;
  }
  return output2;
}
function parseSelector(s) {
  return s[0] === "[" ? parseBetween(s) : parseStream$1(s);
}
function parseBetween(s) {
  const n = s.length;
  let i = 1, b2;
  i = find$1(s, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw "Empty between selector: " + s;
  }
  b2 = parseMerge(s.substring(1, i));
  if (b2.length !== 2) {
    throw "Between selector must have two elements: " + s;
  }
  s = s.slice(i + 1).trim();
  if (s[0] !== GT) {
    throw "Expected '>' after between selector: " + s;
  }
  b2 = b2.map(parseSelector);
  const stream2 = parseSelector(s.slice(1).trim());
  if (stream2.between) {
    return {
      between: b2,
      stream: stream2
    };
  } else {
    stream2.between = b2;
  }
  return stream2;
}
function parseStream$1(s) {
  const stream2 = {
    source: DEFAULT_SOURCE
  }, source2 = [];
  let throttle = [0, 0], markname = 0, start = 0, n = s.length, i = 0, j, filter2;
  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e3) {
        throw "Invalid throttle specification: " + s;
      }
      s = s.slice(0, i).trim();
      n = s.length;
    } else throw "Unmatched right brace: " + s;
    i = 0;
  }
  if (!n) throw s;
  if (s[0] === NAME) markname = ++i;
  j = find$1(s, i, COLON);
  if (j < n) {
    source2.push(s.substring(start, j).trim());
    start = i = ++j;
  }
  i = find$1(s, i, LBRACK);
  if (i === n) {
    source2.push(s.substring(start, n).trim());
  } else {
    source2.push(s.substring(start, i).trim());
    filter2 = [];
    start = ++i;
    if (start === n) throw "Unmatched left bracket: " + s;
  }
  while (i < n) {
    i = find$1(s, i, RBRACK);
    if (i === n) throw "Unmatched left bracket: " + s;
    filter2.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK) throw "Expected left bracket: " + s;
    start = ++i;
  }
  if (!(n = source2.length) || ILLEGAL.test(source2[n - 1])) {
    throw "Invalid event selector: " + s;
  }
  if (n > 1) {
    stream2.type = source2[1];
    if (markname) {
      stream2.markname = source2[0].slice(1);
    } else if (isMarkType(source2[0])) {
      stream2.marktype = source2[0];
    } else {
      stream2.source = source2[0];
    }
  } else {
    stream2.type = source2[0];
  }
  if (stream2.type.slice(-1) === "!") {
    stream2.consume = true;
    stream2.type = stream2.type.slice(0, -1);
  }
  if (filter2 != null) stream2.filter = filter2;
  if (throttle[0]) stream2.throttle = throttle[0];
  if (throttle[1]) stream2.debounce = throttle[1];
  return stream2;
}
function parseThrottle(s) {
  const a2 = s.split(COMMA);
  if (!s.length || a2.length > 2) throw s;
  return a2.map((_) => {
    const x2 = +_;
    if (x2 !== x2) throw s;
    return x2;
  });
}
function parseAutosize(spec) {
  return isObject$1(spec) ? spec : {
    type: spec || "pad"
  };
}
const number$1 = (_) => +_ || 0;
const paddingObject = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function parsePadding(spec) {
  return !isObject$1(spec) ? paddingObject(number$1(spec)) : spec.signal ? spec : {
    top: number$1(spec.top),
    bottom: number$1(spec.bottom),
    left: number$1(spec.left),
    right: number$1(spec.right)
  };
}
const encoder = (_) => isObject$1(_) && !isArray$1(_) ? extend$3({}, _) : {
  value: _
};
function addEncode(object2, name, value2, set2) {
  if (value2 != null) {
    const isEncoder = isObject$1(value2) && !isArray$1(value2) || isArray$1(value2) && value2.length && isObject$1(value2[0]);
    if (isEncoder) {
      object2.update[name] = value2;
    } else {
      object2[set2 || "enter"][name] = {
        value: value2
      };
    }
    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object2, enter, update2) {
  for (const name in enter) {
    addEncode(object2, name, enter[name]);
  }
  for (const name in update2) {
    addEncode(object2, name, update2[name], "update");
  }
}
function extendEncode(encode2, extra, skip) {
  for (const name in extra) {
    if (skip && has$2(skip, name)) continue;
    encode2[name] = extend$3(encode2[name] || {}, extra[name]);
  }
  return encode2;
}
function has$1(key2, encode2) {
  return encode2 && (encode2.enter && encode2.enter[key2] || encode2.update && encode2.update[key2]);
}
const MarkRole = "mark";
const FrameRole = "frame";
const ScopeRole = "scope";
const AxisRole = "axis";
const AxisDomainRole = "axis-domain";
const AxisGridRole = "axis-grid";
const AxisLabelRole = "axis-label";
const AxisTickRole = "axis-tick";
const AxisTitleRole = "axis-title";
const LegendRole = "legend";
const LegendBandRole = "legend-band";
const LegendEntryRole = "legend-entry";
const LegendGradientRole = "legend-gradient";
const LegendLabelRole = "legend-label";
const LegendSymbolRole = "legend-symbol";
const LegendTitleRole = "legend-title";
const TitleRole = "title";
const TitleTextRole = "title-text";
const TitleSubtitleRole = "title-subtitle";
function applyDefaults(encode2, type2, role, style2, config) {
  const defaults2 = {}, enter = {};
  let update2, key2, skip, props;
  key2 = "lineBreak";
  if (type2 === "text" && config[key2] != null && !has$1(key2, encode2)) {
    applyDefault(defaults2, key2, config[key2]);
  }
  if (role == "legend" || String(role).startsWith("axis")) {
    role = null;
  }
  props = role === FrameRole ? config.group : role === MarkRole ? extend$3({}, config.mark, config[type2]) : null;
  for (key2 in props) {
    skip = has$1(key2, encode2) || (key2 === "fill" || key2 === "stroke") && (has$1("fill", encode2) || has$1("stroke", encode2));
    if (!skip) applyDefault(defaults2, key2, props[key2]);
  }
  array$5(style2).forEach((name) => {
    const props2 = config.style && config.style[name];
    for (const key3 in props2) {
      if (!has$1(key3, encode2)) {
        applyDefault(defaults2, key3, props2[key3]);
      }
    }
  });
  encode2 = extend$3({}, encode2);
  for (key2 in defaults2) {
    props = defaults2[key2];
    if (props.signal) {
      (update2 = update2 || {})[key2] = props;
    } else {
      enter[key2] = props;
    }
  }
  encode2.enter = extend$3(enter, encode2.enter);
  if (update2) encode2.update = extend$3(update2, encode2.update);
  return encode2;
}
function applyDefault(defaults2, key2, value2) {
  defaults2[key2] = value2 && value2.signal ? {
    signal: value2.signal
  } : {
    value: value2
  };
}
const scaleRef = (scale2) => isString(scale2) ? $(scale2) : scale2.signal ? `(${scale2.signal})` : field(scale2);
function entry$1(enc) {
  if (enc.gradient != null) {
    return gradient$1(enc);
  }
  let value2 = enc.signal ? `(${enc.signal})` : enc.color ? color$4(enc.color) : enc.field != null ? field(enc.field) : enc.value !== void 0 ? $(enc.value) : void 0;
  if (enc.scale != null) {
    value2 = scale(enc, value2);
  }
  if (value2 === void 0) {
    value2 = null;
  }
  if (enc.exponent != null) {
    value2 = `pow(${value2},${property(enc.exponent)})`;
  }
  if (enc.mult != null) {
    value2 += `*${property(enc.mult)}`;
  }
  if (enc.offset != null) {
    value2 += `+${property(enc.offset)}`;
  }
  if (enc.round) {
    value2 = `round(${value2})`;
  }
  return value2;
}
const _color = (type2, x2, y2, z2) => `(${type2}(${[x2, y2, z2].map(entry$1).join(",")})+'')`;
function color$4(enc) {
  return enc.c ? _color("hcl", enc.h, enc.c, enc.l) : enc.h || enc.s ? _color("hsl", enc.h, enc.s, enc.l) : enc.l || enc.a ? _color("lab", enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color("rgb", enc.r, enc.g, enc.b) : null;
}
function gradient$1(enc) {
  const args = [enc.start, enc.stop, enc.count].map((_) => _ == null ? null : $(_));
  while (args.length && peek$2(args) == null) args.pop();
  args.unshift(scaleRef(enc.gradient));
  return `gradient(${args.join(",")})`;
}
function property(property2) {
  return isObject$1(property2) ? "(" + entry$1(property2) + ")" : property2;
}
function field(ref2) {
  return resolveField(isObject$1(ref2) ? ref2 : {
    datum: ref2
  });
}
function resolveField(ref2) {
  let object2, level, field2;
  if (ref2.signal) {
    object2 = "datum";
    field2 = ref2.signal;
  } else if (ref2.group || ref2.parent) {
    level = Math.max(1, ref2.level || 1);
    object2 = "item";
    while (level-- > 0) {
      object2 += ".mark.group";
    }
    if (ref2.parent) {
      field2 = ref2.parent;
      object2 += ".datum";
    } else {
      field2 = ref2.group;
    }
  } else if (ref2.datum) {
    object2 = "datum";
    field2 = ref2.datum;
  } else {
    error("Invalid field reference: " + $(ref2));
  }
  if (!ref2.signal) {
    field2 = isString(field2) ? splitAccessPath(field2).map($).join("][") : resolveField(field2);
  }
  return object2 + "[" + field2 + "]";
}
function scale(enc, value2) {
  const scale2 = scaleRef(enc.scale);
  if (enc.range != null) {
    value2 = `lerp(_range(${scale2}), ${+enc.range})`;
  } else {
    if (value2 !== void 0) value2 = `_scale(${scale2}, ${value2})`;
    if (enc.band) {
      value2 = (value2 ? value2 + "+" : "") + `_bandwidth(${scale2})` + (+enc.band === 1 ? "" : "*" + property(enc.band));
      if (enc.extra) {
        value2 = `(datum.extra ? _scale(${scale2}, datum.extra.value) : ${value2})`;
      }
    }
    if (value2 == null) value2 = "0";
  }
  return value2;
}
function rule$1(enc) {
  let code = "";
  enc.forEach((rule2) => {
    const value2 = entry$1(rule2);
    code += rule2.test ? `(${rule2.test})?${value2}:` : value2;
  });
  if (peek$2(code) === ":") {
    code += "null";
  }
  return code;
}
function parseEncode(encode2, type2, role, style2, scope, params2) {
  const enc = {};
  params2 = params2 || {};
  params2.encoders = {
    $encode: enc
  };
  encode2 = applyDefaults(encode2, type2, role, style2, scope.config);
  for (const key2 in encode2) {
    enc[key2] = parseBlock(encode2[key2], type2, params2, scope);
  }
  return params2;
}
function parseBlock(block, marktype, params2, scope) {
  const channels = {}, fields = {};
  for (const name in block) {
    if (block[name] != null) {
      channels[name] = parse$1(expr(block[name]), scope, params2, fields);
    }
  }
  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}
function expr(enc) {
  return isArray$1(enc) ? rule$1(enc) : entry$1(enc);
}
function parse$1(code, scope, params2, fields) {
  const expr2 = parser(code, scope);
  expr2.$fields.forEach((name) => fields[name] = 1);
  extend$3(params2, expr2.$params);
  return expr2.$expr;
}
const OUTER = "outer", OUTER_INVALID = ["value", "update", "init", "react", "bind"];
function outerError(prefix2, name) {
  error(prefix2 + ' for "outer" push: ' + $(name));
}
function parseSignal(signal, scope) {
  const name = signal.name;
  if (signal.push === OUTER) {
    if (!scope.signals[name]) outerError("No prior signal definition", name);
    OUTER_INVALID.forEach((prop) => {
      if (signal[prop] !== void 0) outerError("Invalid property ", prop);
    });
  } else {
    const op = scope.addSignal(name, signal.value);
    if (signal.react === false) op.react = false;
    if (signal.bind) scope.addBinding(name, signal.bind);
  }
}
function Entry$1(type2, value2, params2, parent) {
  this.id = -1;
  this.type = type2;
  this.value = value2;
  this.params = params2;
  if (parent) this.parent = parent;
}
function entry(type2, value2, params2, parent) {
  return new Entry$1(type2, value2, params2, parent);
}
function operator(value2, params2) {
  return entry("operator", value2, params2);
}
function ref(op) {
  const ref2 = {
    $ref: op.id
  };
  if (op.id < 0) (op.refs = op.refs || []).push(ref2);
  return ref2;
}
function fieldRef$1(field2, name) {
  return name ? {
    $field: field2,
    $name: name
  } : {
    $field: field2
  };
}
const keyFieldRef = fieldRef$1("key");
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat2) {
  const ref2 = {
    $key: fields
  };
  if (flat2) ref2.$flat = true;
  return ref2;
}
const Ascending = "ascending";
const Descending = "descending";
function sortKey(sort2) {
  return !isObject$1(sort2) ? "" : (sort2.order === Descending ? "-" : "+") + aggrField(sort2.op, sort2.field);
}
function aggrField(op, field2) {
  return (op && op.signal ? "$" + op.signal : op || "") + (op && field2 ? "_" : "") + (field2 && field2.signal ? "$" + field2.signal : field2 || "");
}
const Scope$1 = "scope";
const View = "view";
function isSignal(_) {
  return _ && _.signal;
}
function isExpr$1(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_)) return true;
  if (isObject$1(_)) for (const key2 in _) {
    if (hasSignal(_[key2])) return true;
  }
  return false;
}
function value(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v) {
  return v && v.signal || v;
}
const Timer = "timer";
function parseStream(stream2, scope) {
  const method2 = stream2.merge ? mergeStream : stream2.stream ? nestedStream : stream2.type ? eventStream : error("Invalid stream specification: " + $(stream2));
  return method2(stream2, scope);
}
function eventSource(source2) {
  return source2 === Scope$1 ? View : source2 || View;
}
function mergeStream(stream2, scope) {
  const list = stream2.merge.map((s) => parseStream(s, scope)), entry2 = streamParameters({
    merge: list
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function nestedStream(stream2, scope) {
  const id2 = parseStream(stream2.stream, scope), entry2 = streamParameters({
    stream: id2
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function eventStream(stream2, scope) {
  let id2;
  if (stream2.type === Timer) {
    id2 = scope.event(Timer, stream2.throttle);
    stream2 = {
      between: stream2.between,
      filter: stream2.filter
    };
  } else {
    id2 = scope.event(eventSource(stream2.source), stream2.type);
  }
  const entry2 = streamParameters({
    stream: id2
  }, stream2, scope);
  return Object.keys(entry2).length === 1 ? id2 : scope.addStream(entry2).id;
}
function streamParameters(entry2, stream2, scope) {
  let param2 = stream2.between;
  if (param2) {
    if (param2.length !== 2) {
      error('Stream "between" parameter must have 2 entries: ' + $(stream2));
    }
    entry2.between = [parseStream(param2[0], scope), parseStream(param2[1], scope)];
  }
  param2 = stream2.filter ? [].concat(stream2.filter) : [];
  if (stream2.marktype || stream2.markname || stream2.markrole) {
    param2.push(filterMark(stream2.marktype, stream2.markname, stream2.markrole));
  }
  if (stream2.source === Scope$1) {
    param2.push("inScope(event.item)");
  }
  if (param2.length) {
    entry2.filter = parser("(" + param2.join(")&&(") + ")", scope).$expr;
  }
  if ((param2 = stream2.throttle) != null) {
    entry2.throttle = +param2;
  }
  if ((param2 = stream2.debounce) != null) {
    entry2.debounce = +param2;
  }
  if (stream2.consume) {
    entry2.consume = true;
  }
  return entry2;
}
function filterMark(type2, name, role) {
  const item = "event.item";
  return item + (type2 && type2 !== "*" ? "&&" + item + ".mark.marktype==='" + type2 + "'" : "") + (role ? "&&" + item + ".mark.role==='" + role + "'" : "") + (name ? "&&" + item + ".mark.name==='" + name + "'" : "");
}
const OP_VALUE_EXPR = {
  code: "_.$value",
  ast: {
    type: "Identifier",
    value: "value"
  }
};
function parseUpdate(spec, scope, target2) {
  const encode2 = spec.encode, entry2 = {
    target: target2
  };
  let events2 = spec.events, update2 = spec.update, sources = [];
  if (!events2) {
    error("Signal update missing events specification.");
  }
  if (isString(events2)) {
    events2 = eventSelector(events2, scope.isSubscope() ? Scope$1 : View);
  }
  events2 = array$5(events2).filter((s) => s.signal || s.scale ? (sources.push(s), 0) : 1);
  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  }
  if (events2.length) {
    sources.push(events2.length > 1 ? {
      merge: events2
    } : events2[0]);
  }
  if (encode2 != null) {
    if (update2) error("Signal encode and update are mutually exclusive.");
    update2 = "encode(item()," + $(encode2) + ")";
  }
  entry2.update = isString(update2) ? parser(update2, scope) : update2.expr != null ? parser(update2.expr, scope) : update2.value != null ? update2.value : update2.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update2.signal)
    }
  } : error("Invalid signal update specification.");
  if (spec.force) {
    entry2.options = {
      force: true
    };
  }
  sources.forEach((source2) => scope.addUpdate(extend$3(streamSource(source2, scope), entry2)));
}
function streamSource(stream2, scope) {
  return {
    source: stream2.signal ? scope.signalRef(stream2.signal) : stream2.scale ? scope.scaleRef(stream2.scale) : parseStream(stream2, scope)
  };
}
function mergeSources(sources) {
  return {
    signal: "[" + sources.map((s) => s.scale ? 'scale("' + s.scale + '")' : s.signal) + "]"
  };
}
function parseSignalUpdates(signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr2 = signal.update;
  if (signal.init) {
    if (expr2) {
      error("Signals can not include both init and update expressions.");
    } else {
      expr2 = signal.init;
      op.initonly = true;
    }
  }
  if (expr2) {
    expr2 = parser(expr2, scope);
    op.update = expr2.$expr;
    op.params = expr2.$params;
  }
  if (signal.on) {
    signal.on.forEach((_) => parseUpdate(_, scope, op.id));
  }
}
const transform = (name) => (params2, value2, parent) => entry(name, value2, params2 || void 0, parent);
const Aggregate = transform("aggregate");
const AxisTicks = transform("axisticks");
const Bound = transform("bound");
const Collect = transform("collect");
const Compare = transform("compare");
const DataJoin = transform("datajoin");
const Encode = transform("encode");
const Expression = transform("expression");
const Facet = transform("facet");
const Field = transform("field");
const Key = transform("key");
const LegendEntries = transform("legendentries");
const Load = transform("load");
const Mark$1 = transform("mark");
const MultiExtent = transform("multiextent");
const MultiValues = transform("multivalues");
const Overlap = transform("overlap");
const Params = transform("params");
const PreFacet = transform("prefacet");
const Projection = transform("projection");
const Proxy$1 = transform("proxy");
const Relay = transform("relay");
const Render = transform("render");
const Scale = transform("scale");
const Sieve = transform("sieve");
const SortItems = transform("sortitems");
const ViewLayout = transform("viewlayout");
const Values = transform("values");
let FIELD_REF_ID = 0;
const MULTIDOMAIN_SORT_OPS = {
  min: "min",
  max: "max",
  count: "sum"
};
function initScale(spec, scope) {
  const type2 = spec.type || "linear";
  if (!isValidScaleType(type2)) {
    error("Unrecognized scale type: " + $(type2));
  }
  scope.addScale(spec.name, {
    type: type2,
    domain: void 0
  });
}
function parseScale(spec, scope) {
  const params2 = scope.getScale(spec.name).params;
  let key2;
  params2.domain = parseScaleDomain$1(spec.domain, spec, scope);
  if (spec.range != null) {
    params2.range = parseScaleRange$1(spec, scope, params2);
  }
  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params2);
  }
  if (spec.nice != null) {
    params2.nice = parseScaleNice(spec.nice);
  }
  if (spec.bins != null) {
    params2.bins = parseScaleBins(spec.bins, scope);
  }
  for (key2 in spec) {
    if (has$2(params2, key2) || key2 === "name") continue;
    params2[key2] = parseLiteral(spec[key2], scope);
  }
}
function parseLiteral(v, scope) {
  return !isObject$1(v) ? v : v.signal ? scope.signalRef(v.signal) : error("Unsupported object: " + $(v));
}
function parseArray(v, scope) {
  return v.signal ? scope.signalRef(v.signal) : v.map((v2) => parseLiteral(v2, scope));
}
function dataLookupError(name) {
  error("Can not find data set: " + $(name));
}
function parseScaleDomain$1(domain2, spec, scope) {
  if (!domain2) {
    if (spec.domainMin != null || spec.domainMax != null) {
      error("No scale domain defined for domainMin/domainMax to override.");
    }
    return;
  }
  return domain2.signal ? scope.signalRef(domain2.signal) : (isArray$1(domain2) ? explicitDomain : domain2.fields ? multipleDomain : singularDomain)(domain2, spec, scope);
}
function explicitDomain(domain2, spec, scope) {
  return domain2.map((v) => parseLiteral(v, scope));
}
function singularDomain(domain2, spec, scope) {
  const data2 = scope.getData(domain2.data);
  if (!data2) dataLookupError(domain2.data);
  return isDiscrete$2(spec.type) ? data2.valuesRef(scope, domain2.field, parseSort(domain2.sort, false)) : isQuantile$1(spec.type) ? data2.domainRef(scope, domain2.field) : data2.extentRef(scope, domain2.field);
}
function multipleDomain(domain2, spec, scope) {
  const data2 = domain2.data, fields = domain2.fields.reduce((dom, d) => {
    d = isString(d) ? {
      data: data2,
      field: d
    } : isArray$1(d) || d.signal ? fieldRef(d, scope) : d;
    dom.push(d);
    return dom;
  }, []);
  return (isDiscrete$2(spec.type) ? ordinalMultipleDomain : isQuantile$1(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain2, scope, fields);
}
function fieldRef(data2, scope) {
  const name = "_:vega:_" + FIELD_REF_ID++, coll = Collect({});
  if (isArray$1(data2)) {
    coll.value = {
      $ingest: data2
    };
  } else if (data2.signal) {
    const code = "setdata(" + $(name) + "," + data2.signal + ")";
    coll.params.input = scope.signalRef(code);
  }
  scope.addDataPipeline(name, [coll, Sieve({})]);
  return {
    data: name,
    field: "data"
  };
}
function ordinalMultipleDomain(domain2, scope, fields) {
  const sort2 = parseSort(domain2.sort, true);
  let a2, v;
  const counts = fields.map((f) => {
    const data2 = scope.getData(f.data);
    if (!data2) dataLookupError(f.data);
    return data2.countsRef(scope, f.field, sort2);
  });
  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };
  if (sort2) {
    a2 = sort2.op || "count";
    v = sort2.field ? aggrField(a2, sort2.field) : "count";
    p.ops = [MULTIDOMAIN_SORT_OPS[a2]];
    p.fields = [scope.fieldRef(v)];
    p.as = [v];
  }
  a2 = scope.add(Aggregate(p));
  const c2 = scope.add(Collect({
    pulse: ref(a2)
  }));
  v = scope.add(Values({
    field: keyFieldRef,
    sort: scope.sortRef(sort2),
    pulse: ref(c2)
  }));
  return ref(v);
}
function parseSort(sort2, multidomain) {
  if (sort2) {
    if (!sort2.field && !sort2.op) {
      if (isObject$1(sort2)) sort2.field = "key";
      else sort2 = {
        field: "key"
      };
    } else if (!sort2.field && sort2.op !== "count") {
      error("No field provided for sort aggregate op: " + sort2.op);
    } else if (multidomain && sort2.field) {
      if (sort2.op && !MULTIDOMAIN_SORT_OPS[sort2.op]) {
        error("Multiple domain scales can not be sorted using " + sort2.op);
      }
    }
  }
  return sort2;
}
function quantileMultipleDomain(domain2, scope, fields) {
  const values2 = fields.map((f) => {
    const data2 = scope.getData(f.data);
    if (!data2) dataLookupError(f.data);
    return data2.domainRef(scope, f.field);
  });
  return ref(scope.add(MultiValues({
    values: values2
  })));
}
function numericMultipleDomain(domain2, scope, fields) {
  const extents = fields.map((f) => {
    const data2 = scope.getData(f.data);
    if (!data2) dataLookupError(f.data);
    return data2.extentRef(scope, f.field);
  });
  return ref(scope.add(MultiExtent({
    extents
  })));
}
function parseScaleBins(v, scope) {
  return v.signal || isArray$1(v) ? parseArray(v, scope) : scope.objectProperty(v);
}
function parseScaleNice(nice2) {
  return isObject$1(nice2) ? {
    interval: parseLiteral(nice2.interval),
    step: parseLiteral(nice2.step)
  } : parseLiteral(nice2);
}
function parseScaleInterpolate(interpolate2, params2) {
  params2.interpolate = parseLiteral(interpolate2.type || interpolate2);
  if (interpolate2.gamma != null) {
    params2.interpolateGamma = parseLiteral(interpolate2.gamma);
  }
}
function parseScaleRange$1(spec, scope, params2) {
  const config = scope.config.range;
  let range2 = spec.range;
  if (range2.signal) {
    return scope.signalRef(range2.signal);
  } else if (isString(range2)) {
    if (config && has$2(config, range2)) {
      spec = extend$3({}, spec, {
        range: config[range2]
      });
      return parseScaleRange$1(spec, scope, params2);
    } else if (range2 === "width") {
      range2 = [0, {
        signal: "width"
      }];
    } else if (range2 === "height") {
      range2 = isDiscrete$2(spec.type) ? [0, {
        signal: "height"
      }] : [{
        signal: "height"
      }, 0];
    } else {
      error("Unrecognized scale range value: " + $(range2));
    }
  } else if (range2.scheme) {
    params2.scheme = isArray$1(range2.scheme) ? parseArray(range2.scheme, scope) : parseLiteral(range2.scheme, scope);
    if (range2.extent) params2.schemeExtent = parseArray(range2.extent, scope);
    if (range2.count) params2.schemeCount = parseLiteral(range2.count, scope);
    return;
  } else if (range2.step) {
    params2.rangeStep = parseLiteral(range2.step, scope);
    return;
  } else if (isDiscrete$2(spec.type) && !isArray$1(range2)) {
    return parseScaleDomain$1(range2, spec, scope);
  } else if (!isArray$1(range2)) {
    error("Unsupported range type: " + $(range2));
  }
  return range2.map((v) => (isArray$1(v) ? parseArray : parseLiteral)(v, scope));
}
function parseProjection$1(proj, scope) {
  const config = scope.config.projection || {}, params2 = {};
  for (const name in proj) {
    if (name === "name") continue;
    params2[name] = parseParameter$1(proj[name], name, scope);
  }
  for (const name in config) {
    if (params2[name] == null) {
      params2[name] = parseParameter$1(config[name], name, scope);
    }
  }
  scope.addProjection(proj.name, params2);
}
function parseParameter$1(_, name, scope) {
  return isArray$1(_) ? _.map((_2) => parseParameter$1(_2, name, scope)) : !isObject$1(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === "fit" ? _ : error("Unsupported parameter object: " + $(_));
}
const Top = "top";
const Left = "left";
const Right = "right";
const Bottom = "bottom";
const Center = "center";
const Vertical = "vertical";
const Start = "start";
const Middle = "middle";
const End = "end";
const Index = "index";
const Label = "label";
const Offset = "offset";
const Perc = "perc";
const Perc2 = "perc2";
const Value = "value";
const GuideLabelStyle = "guide-label";
const GuideTitleStyle = "guide-title";
const GroupTitleStyle = "group-title";
const GroupSubtitleStyle = "group-subtitle";
const Symbols = "symbol";
const Gradient = "gradient";
const Discrete = "discrete";
const Size = "size";
const Shape = "shape";
const Fill = "fill";
const Stroke = "stroke";
const StrokeWidth = "strokeWidth";
const StrokeDash = "strokeDash";
const Opacity = "opacity";
const LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
const Skip = {
  name: 1,
  style: 1,
  interactive: 1
};
const zero$2 = {
  value: 0
};
const one$1 = {
  value: 1
};
const GroupMark = "group";
const RectMark = "rect";
const RuleMark = "rule";
const SymbolMark = "symbol";
const TextMark = "text";
function guideGroup(mark2) {
  mark2.type = GroupMark;
  mark2.interactive = mark2.interactive || false;
  return mark2;
}
function lookup(spec, config) {
  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));
  _.isVertical = (s) => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));
  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);
  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);
  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));
  return _;
}
function getEncoding(name, encode2) {
  const v = encode2 && (encode2.update && encode2.update[name] || encode2.enter && encode2.enter[name]);
  return v && v.signal ? v : v ? v.value : null;
}
function getStyle(name, scope, style2) {
  const s = scope.config.style[style2];
  return s && s[name];
}
function anchorExpr(s, e3, m2) {
  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e3} : ${m2}`;
}
const alignExpr$1 = anchorExpr($(Left), $(Right), $(Center));
function tickBand(_) {
  const v = _("tickBand");
  let offset2 = _("tickOffset"), band2, extra;
  if (!v) {
    band2 = _("bandPosition");
    extra = _("tickExtra");
  } else if (v.signal) {
    band2 = {
      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`
    };
    extra = {
      signal: `(${v.signal}) === 'extent'`
    };
    if (!isObject$1(offset2)) {
      offset2 = {
        signal: `(${v.signal}) === 'extent' ? 0 : ${offset2}`
      };
    }
  } else if (v === "extent") {
    band2 = 1;
    extra = true;
    offset2 = 0;
  } else {
    band2 = 0.5;
    extra = false;
  }
  return {
    extra,
    band: band2,
    offset: offset2
  };
}
function extendOffset(value2, offset2) {
  return !offset2 ? value2 : !value2 ? offset2 : !isObject$1(value2) ? {
    value: value2,
    offset: offset2
  } : Object.assign({}, value2, {
    offset: extendOffset(value2.offset, offset2)
  });
}
function guideMark(mark2, extras) {
  if (extras) {
    mark2.name = extras.name;
    mark2.style = extras.style || mark2.style;
    mark2.interactive = !!extras.interactive;
    mark2.encode = extendEncode(mark2.encode, extras, Skip);
  } else {
    mark2.interactive = false;
  }
  return mark2;
}
function legendGradient(spec, scale2, config, userEncode) {
  const _ = lookup(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length2 = _.gradientLength();
  let enter, start, stop3, width2, height2;
  if (vertical) {
    start = [0, 1];
    stop3 = [0, 0];
    width2 = thickness;
    height2 = length2;
  } else {
    start = [0, 0];
    stop3 = [1, 0];
    width2 = length2;
    height2 = thickness;
  }
  const encode2 = {
    enter: enter = {
      opacity: zero$2,
      x: zero$2,
      y: zero$2,
      width: encoder(width2),
      height: encoder(height2)
    },
    update: extend$3({}, enter, {
      opacity: one$1,
      fill: {
        gradient: scale2,
        start,
        stop: stop3
      }
    }),
    exit: {
      opacity: zero$2
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    // update
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode: encode2
  }, userEncode);
}
function legendGradientDiscrete(spec, scale2, config, userEncode, dataRef) {
  const _ = lookup(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length2 = _.gradientLength();
  let u2, v, uu, vv, adjust = "";
  vertical ? (u2 = "y", uu = "y2", v = "x", vv = "width", adjust = "1-") : (u2 = "x", uu = "x2", v = "y", vv = "height");
  const enter = {
    opacity: zero$2,
    fill: {
      scale: scale2,
      field: Value
    }
  };
  enter[u2] = {
    signal: adjust + "datum." + Perc,
    mult: length2
  };
  enter[v] = zero$2;
  enter[uu] = {
    signal: adjust + "datum." + Perc2,
    mult: length2
  };
  enter[vv] = encoder(thickness);
  const encode2 = {
    enter,
    update: extend$3({}, enter, {
      opacity: one$1
    }),
    exit: {
      opacity: zero$2
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    // update
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
const alignExpr = `datum.${Perc}<=0?"${Left}":datum.${Perc}>=1?"${Right}":"${Center}"`, baselineExpr = `datum.${Perc}<=0?"${Bottom}":datum.${Perc}>=1?"${Top}":"${Middle}"`;
function legendGradientLabels(spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config), vertical = _.isVertical(), thickness = encoder(_.gradientThickness()), length2 = _.gradientLength();
  let overlap = _("labelOverlap"), enter, update2, u2, v, adjust = "";
  const encode2 = {
    enter: enter = {
      opacity: zero$2
    },
    update: update2 = {
      opacity: one$1,
      text: {
        field: Label
      }
    },
    exit: {
      opacity: zero$2
    }
  };
  addEncoders(encode2, {
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: value(spec.labelLimit, config.gradientLabelLimit)
  });
  if (vertical) {
    enter.align = {
      value: "left"
    };
    enter.baseline = update2.baseline = {
      signal: baselineExpr
    };
    u2 = "y";
    v = "x";
    adjust = "1-";
  } else {
    enter.align = update2.align = {
      signal: alignExpr
    };
    enter.baseline = {
      value: "top"
    };
    u2 = "x";
    v = "y";
  }
  enter[u2] = update2[u2] = {
    signal: adjust + "datum." + Perc,
    mult: length2
  };
  enter[v] = update2[v] = thickness;
  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum." + Index
  } : void 0;
  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function legendSymbolGroups(spec, config, userEncode, dataRef, columns) {
  const _ = lookup(spec, config), entries2 = userEncode.entries, interactive2 = !!(entries2 && entries2.interactive), name = entries2 ? entries2.name : void 0, height2 = _("clipHeight"), symbolOffset = _("symbolOffset"), valueRef = {
    data: "value"
  }, xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`, yEncode = height2 ? encoder(height2) : {
    field: Size
  }, index2 = `datum.${Index}`, ncols = `max(1, ${columns})`;
  let encode2, enter, update2, nrows, sort2;
  yEncode.mult = 0.5;
  encode2 = {
    enter: enter = {
      opacity: zero$2,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update2 = {
      opacity: one$1,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero$2
    }
  };
  let baseFill = null, baseStroke = null;
  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }
  addEncoders(encode2, {
    fill: _("symbolFillColor", baseFill),
    shape: _("symbolType"),
    size: _("symbolSize"),
    stroke: _("symbolStrokeColor", baseStroke),
    strokeDash: _("symbolDash"),
    strokeDashOffset: _("symbolDashOffset"),
    strokeWidth: _("symbolStrokeWidth")
  }, {
    // update
    opacity: _("symbolOpacity")
  });
  LegendScales.forEach((scale2) => {
    if (spec[scale2]) {
      update2[scale2] = enter[scale2] = {
        scale: spec[scale2],
        field: Value
      };
    }
  });
  const symbols2 = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height2 ? true : void 0,
    encode: encode2
  }, userEncode.symbols);
  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _("labelOffset");
  encode2 = {
    enter: enter = {
      opacity: zero$2,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update2 = {
      opacity: one$1,
      text: {
        field: Label
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero$2
    }
  };
  addEncoders(encode2, {
    align: _("labelAlign"),
    baseline: _("labelBaseline"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: _("labelLimit")
  });
  const labels2 = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode: encode2
  }, userEncode.labels);
  encode2 = {
    enter: {
      noBound: {
        value: !height2
      },
      // ignore width/height in bounds calc
      width: zero$2,
      height: height2 ? encoder(height2) : zero$2,
      opacity: zero$2
    },
    exit: {
      opacity: zero$2
    },
    update: update2 = {
      opacity: one$1,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  };
  if (_.isVertical(true)) {
    nrows = `ceil(item.mark.items.length / ${ncols})`;
    update2.row.signal = `${index2}%${nrows}`;
    update2.column.signal = `floor(${index2} / ${nrows})`;
    sort2 = {
      field: ["row", index2]
    };
  } else {
    update2.row.signal = `floor(${index2} / ${ncols})`;
    update2.column.signal = `${index2} % ${ncols}`;
    sort2 = {
      field: index2
    };
  }
  update2.column.signal = `(${columns})?${update2.column.signal}:${index2}`;
  dataRef = {
    facet: {
      data: dataRef,
      name: "value",
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole,
    from: dataRef,
    encode: extendEncode(encode2, entries2, Skip),
    marks: [symbols2, labels2],
    name,
    interactive: interactive2,
    sort: sort2
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup(spec, config);
  return {
    align: _("gridAlign"),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _("rowPadding"),
      column: _("columnPadding")
    }
  };
}
const isL = 'item.orient === "left"', isR = 'item.orient === "right"', isLR = `(${isL} || ${isR})`, isVG = `datum.vgrad && ${isLR}`, baseline$1 = anchorExpr('"top"', '"bottom"', '"middle"'), alignFlip = anchorExpr('"right"', '"left"', '"center"'), exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`, exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`, exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`, exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline$1}) : "top"`;
function legendTitle(spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config);
  const encode2 = {
    enter: {
      opacity: zero$2
    },
    update: {
      opacity: one$1,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: zero$2
    }
  };
  addEncoders(encode2, {
    orient: _("titleOrient"),
    _anchor: _("titleAnchor"),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    // require update
    align: _("titleAlign"),
    baseline: _("titleBaseline")
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function clip(clip2, scope) {
  let expr2;
  if (isObject$1(clip2)) {
    if (clip2.signal) {
      expr2 = clip2.signal;
    } else if (clip2.path) {
      expr2 = "pathShape(" + param(clip2.path) + ")";
    } else if (clip2.sphere) {
      expr2 = "geoShape(" + param(clip2.sphere) + ', {type: "Sphere"})';
    }
  }
  return expr2 ? scope.signalRef(expr2) : !!clip2;
}
function param(value2) {
  return isObject$1(value2) && value2.signal ? value2.signal : $(value2);
}
function getRole(spec) {
  const role = spec.role || "";
  return !role.indexOf("axis") || !role.indexOf("legend") || !role.indexOf("title") ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;
}
function definition(spec) {
  return {
    marktype: spec.type,
    name: spec.name || void 0,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || void 0,
    aria: spec.aria,
    description: spec.description
  };
}
function interactive(spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}
function parseTransform(spec, scope) {
  const def2 = definition$1(spec.type);
  if (!def2) error("Unrecognized transform type: " + $(spec.type));
  const t4 = entry(def2.type.toLowerCase(), null, parseParameters(def2, spec, scope));
  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t4));
  t4.metadata = def2.metadata || {};
  return t4;
}
function parseParameters(def2, spec, scope) {
  const params2 = {}, n = def2.params.length;
  for (let i = 0; i < n; ++i) {
    const pdef = def2.params[i];
    params2[pdef.name] = parseParameter(pdef, spec, scope);
  }
  return params2;
}
function parseParameter(def2, spec, scope) {
  const type2 = def2.type, value2 = spec[def2.name];
  if (type2 === "index") {
    return parseIndexParameter(def2, spec, scope);
  } else if (value2 === void 0) {
    if (def2.required) {
      error("Missing required " + $(spec.type) + " parameter: " + $(def2.name));
    }
    return;
  } else if (type2 === "param") {
    return parseSubParameters(def2, spec, scope);
  } else if (type2 === "projection") {
    return scope.projectionRef(spec[def2.name]);
  }
  return def2.array && !isSignal(value2) ? value2.map((v) => parameterValue(def2, v, scope)) : parameterValue(def2, value2, scope);
}
function parameterValue(def2, value2, scope) {
  const type2 = def2.type;
  if (isSignal(value2)) {
    return isExpr(type2) ? error("Expression references can not be signals.") : isField(type2) ? scope.fieldRef(value2) : isCompare(type2) ? scope.compareRef(value2) : scope.signalRef(value2.signal);
  } else {
    const expr2 = def2.expr || isField(type2);
    return expr2 && outerExpr(value2) ? scope.exprRef(value2.expr, value2.as) : expr2 && outerField(value2) ? fieldRef$1(value2.field, value2.as) : isExpr(type2) ? parser(value2, scope) : isData(type2) ? ref(scope.getData(value2).values) : isField(type2) ? fieldRef$1(value2) : isCompare(type2) ? scope.compareRef(value2) : value2;
  }
}
function parseIndexParameter(def2, spec, scope) {
  if (!isString(spec.from)) {
    error('Lookup "from" parameter must be a string literal.');
  }
  return scope.getData(spec.from).lookupRef(scope, spec.key);
}
function parseSubParameters(def2, spec, scope) {
  const value2 = spec[def2.name];
  if (def2.array) {
    if (!isArray$1(value2)) {
      error("Expected an array of sub-parameters. Instead: " + $(value2));
    }
    return value2.map((v) => parseSubParameter(def2, v, scope));
  } else {
    return parseSubParameter(def2, value2, scope);
  }
}
function parseSubParameter(def2, value2, scope) {
  const n = def2.params.length;
  let pdef;
  for (let i = 0; i < n; ++i) {
    pdef = def2.params[i];
    for (const k in pdef.key) {
      if (pdef.key[k] !== value2[k]) {
        pdef = null;
        break;
      }
    }
    if (pdef) break;
  }
  if (!pdef) error("Unsupported parameter: " + $(value2));
  const params2 = extend$3(parseParameters(pdef, value2, scope), pdef.key);
  return ref(scope.add(Params(params2)));
}
const outerExpr = (_) => _ && _.expr;
const outerField = (_) => _ && _.field;
const isData = (_) => _ === "data";
const isExpr = (_) => _ === "expr";
const isField = (_) => _ === "field";
const isCompare = (_) => _ === "compare";
function parseData$1(from2, group2, scope) {
  let facet, key2, op, dataRef, parent;
  if (!from2) {
    dataRef = ref(scope.add(Collect(null, [{}])));
  } else if (facet = from2.facet) {
    if (!group2) error("Only group marks can be faceted.");
    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      if (!from2.data) {
        op = parseTransform(extend$3({
          type: "aggregate",
          groupby: array$5(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from2.data).aggregate);
      }
      key2 = scope.keyRef(facet.groupby, true);
    }
  }
  if (!dataRef) {
    dataRef = getDataRef(from2, scope);
  }
  return {
    key: key2,
    pulse: dataRef,
    parent
  };
}
function getDataRef(from2, scope) {
  return from2.$ref ? from2 : from2.data && from2.data.$ref ? from2.data : ref(scope.getData(from2.data).output);
}
function DataScope(scope, input, output2, values2, aggr) {
  this.scope = scope;
  this.input = input;
  this.output = output2;
  this.values = values2;
  this.aggregate = aggr;
  this.index = {};
}
DataScope.fromEntries = function(scope, entries2) {
  const n = entries2.length, values2 = entries2[n - 1], output2 = entries2[n - 2];
  let input = entries2[0], aggr = null, i = 1;
  if (input && input.type === "load") {
    input = entries2[1];
  }
  scope.add(entries2[0]);
  for (; i < n; ++i) {
    entries2[i].params.pulse = ref(entries2[i - 1]);
    scope.add(entries2[i]);
    if (entries2[i].type === "aggregate") aggr = entries2[i];
  }
  return new DataScope(scope, input, output2, values2, aggr);
};
function fieldKey(field2) {
  return isString(field2) ? field2 : null;
}
function addSortField(scope, p, sort2) {
  const as = aggrField(sort2.op, sort2.field);
  let s;
  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as) return;
    }
  } else {
    p.ops = ["count"];
    p.fields = [null];
    p.as = ["count"];
  }
  if (sort2.op) {
    p.ops.push((s = sort2.op.signal) ? scope.signalRef(s) : sort2.op);
    p.fields.push(scope.fieldRef(sort2.field));
    p.as.push(as);
  }
}
function cache(scope, ds, name, optype, field2, counts, index2) {
  const cache2 = ds[name] || (ds[name] = {}), sort2 = sortKey(counts);
  let k = fieldKey(field2), v, op;
  if (k != null) {
    scope = ds.scope;
    k = k + (sort2 ? "|" + sort2 : "");
    v = cache2[k];
  }
  if (!v) {
    const params2 = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field2, counts)
    } : {
      field: scope.fieldRef(field2),
      pulse: ref(ds.output)
    };
    if (sort2) params2.sort = scope.sortRef(counts);
    op = scope.add(entry(optype, void 0, params2));
    if (index2) ds.index[field2] = op;
    v = ref(op);
    if (k != null) cache2[k] = v;
  }
  return v;
}
DataScope.prototype = {
  countsRef(scope, field2, sort2) {
    const ds = this, cache2 = ds.counts || (ds.counts = {}), k = fieldKey(field2);
    let v, a2, p;
    if (k != null) {
      scope = ds.scope;
      v = cache2[k];
    }
    if (!v) {
      p = {
        groupby: scope.fieldRef(field2, "key"),
        pulse: ref(ds.output)
      };
      if (sort2 && sort2.field) addSortField(scope, p, sort2);
      a2 = scope.add(Aggregate(p));
      v = scope.add(Collect({
        pulse: ref(a2)
      }));
      v = {
        agg: a2,
        ref: ref(v)
      };
      if (k != null) cache2[k] = v;
    } else if (sort2 && sort2.field) {
      addSortField(scope, v.agg.params, sort2);
    }
    return v.ref;
  },
  tuplesRef() {
    return ref(this.values);
  },
  extentRef(scope, field2) {
    return cache(scope, this, "extent", "extent", field2, false);
  },
  domainRef(scope, field2) {
    return cache(scope, this, "domain", "values", field2, false);
  },
  valuesRef(scope, field2, sort2) {
    return cache(scope, this, "vals", "values", field2, sort2 || true);
  },
  lookupRef(scope, field2) {
    return cache(scope, this, "lookup", "tupleindex", field2, false);
  },
  indataRef(scope, field2) {
    return cache(scope, this, "indata", "tupleindex", field2, true, true);
  }
};
function parseFacet(spec, scope, group2) {
  const facet = spec.from.facet, name = facet.name, data2 = getDataRef(facet, scope);
  let op;
  if (!facet.name) {
    error("Facet must have a name: " + $(facet));
  }
  if (!facet.data) {
    error("Facet must reference a data set: " + $(facet));
  }
  if (facet.field) {
    op = scope.add(PreFacet({
      field: scope.fieldRef(facet.field),
      pulse: data2
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group2.parent)),
      pulse: data2
    }));
  } else {
    error("Facet must specify groupby or field: " + $(facet));
  }
  const subscope = scope.fork(), source2 = subscope.add(Collect()), values2 = subscope.add(Sieve({
    pulse: ref(source2)
  }));
  subscope.addData(name, new DataScope(subscope, source2, source2, values2));
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseSubflow(spec, scope, input) {
  const op = scope.add(PreFacet({
    pulse: input.pulse
  })), subscope = scope.fork();
  subscope.add(Sieve());
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseTrigger(spec, scope, name) {
  const remove2 = spec.remove, insert2 = spec.insert, toggle2 = spec.toggle, modify2 = spec.modify, values2 = spec.values, op = scope.add(operator());
  const update2 = "if(" + spec.trigger + ',modify("' + name + '",' + [insert2, remove2, toggle2, modify2, values2].map((_) => _ == null ? "null" : _).join(",") + "),0)";
  const expr2 = parser(update2, scope);
  op.update = expr2.$expr;
  op.params = expr2.$params;
}
function parseMark(spec, scope) {
  const role = getRole(spec), group2 = spec.type === GroupMark, facet = spec.from && spec.from.facet, overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole || role === FrameRole, ops2, op, store, enc, name, layoutRef, boundRef;
  const nested2 = role === MarkRole || layout || facet;
  const input = parseData$1(spec.from, group2, scope);
  op = scope.add(DataJoin({
    key: input.key || (spec.key ? fieldRef$1(spec.key) : void 0),
    pulse: input.pulse,
    clean: !group2
  }));
  const joinRef = ref(op);
  op = store = scope.add(Collect({
    pulse: joinRef
  }));
  op = scope.add(Mark$1({
    markdef: definition(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef("parent") : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op);
  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  })));
  op.params.parent = scope.encode();
  if (spec.transform) {
    spec.transform.forEach((_) => {
      const tx2 = parseTransform(_, scope), md2 = tx2.metadata;
      if (md2.generates || md2.changes) {
        error("Mark transforms should not generate new data.");
      }
      if (!md2.nomod) enc.params.mod = true;
      tx2.params.pulse = ref(op);
      scope.add(op = tx2);
    });
  }
  if (spec.sort) {
    op = scope.add(SortItems({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }
  const encodeRef = ref(op);
  if (facet || layout) {
    layout = scope.add(ViewLayout({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  }
  const bound2 = scope.add(Bound({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound2);
  if (group2) {
    if (nested2) {
      ops2 = scope.operators;
      ops2.pop();
      if (layout) ops2.pop();
    }
    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) : nested2 ? parseSubflow(spec, scope, input) : scope.parse(spec);
    scope.popState();
    if (nested2) {
      if (layout) ops2.push(layout);
      ops2.push(bound2);
    }
  }
  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  }
  const render = scope.add(Render({
    pulse: boundRef
  })), sieve = scope.add(Sieve({
    pulse: ref(render)
  }, void 0, scope.parent()));
  if (spec.name != null) {
    name = spec.name;
    scope.addData(name, new DataScope(scope, store, render, sieve));
    if (spec.on) spec.on.forEach((on2) => {
      if (on2.insert || on2.remove || on2.toggle) {
        error("Marks only support modify triggers.");
      }
      parseTrigger(on2, scope, name);
    });
  }
}
function parseOverlap(overlap, source2, scope) {
  const method2 = overlap.method, bound2 = overlap.bound, sep = overlap.separation;
  const params2 = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method2) ? scope.signalRef(method2.signal) : method2,
    pulse: source2
  };
  if (overlap.order) {
    params2.sort = scope.compareRef({
      field: overlap.order
    });
  }
  if (bound2) {
    const tol = bound2.tolerance;
    params2.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params2.boundScale = scope.scaleRef(bound2.scale);
    params2.boundOrient = bound2.orient;
  }
  return ref(scope.add(Overlap(params2)));
}
function parseLegend$1(spec, scope) {
  const config = scope.config.legend, encode2 = spec.encode || {}, _ = lookup(spec, config), legendEncode = encode2.legend || {}, name = legendEncode.name || void 0, interactive2 = legendEncode.interactive, style2 = legendEncode.style, scales2 = {};
  let scale2 = 0, entryLayout, params2, children2;
  LegendScales.forEach((s) => spec[s] ? (scales2[s] = spec[s], scale2 = scale2 || spec[s]) : 0);
  if (!scale2) error("Missing valid scale for legend.");
  const type2 = legendType(spec, scope.scaleType(scale2));
  const datum2 = {
    title: spec.title != null,
    scales: scales2,
    type: type2,
    vgrad: type2 !== "symbol" && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect(null, [datum2])));
  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  };
  const entryRef = ref(scope.add(LegendEntries(params2 = {
    type: type2,
    scale: scope.scaleRef(scale2),
    count: scope.objectProperty(_("tickCount")),
    limit: scope.property(_("symbolLimit")),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  if (type2 === Gradient) {
    children2 = [legendGradient(spec, scale2, config, encode2.gradient), legendGradientLabels(spec, config, encode2.labels, entryRef)];
    params2.count = params2.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);
  } else if (type2 === Discrete) {
    children2 = [legendGradientDiscrete(spec, scale2, config, encode2.gradient, entryRef), legendGradientLabels(spec, config, encode2.labels, entryRef)];
  } else {
    entryLayout = legendSymbolLayout(spec, config);
    children2 = [legendSymbolGroups(spec, config, encode2, entryRef, deref(entryLayout.columns))];
    params2.size = sizeExpression(spec, scope, children2[0].marks);
  }
  children2 = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children2,
    layout: entryLayout,
    interactive: interactive2
  })];
  if (datum2.title) {
    children2.push(legendTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: LegendRole,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),
    marks: children2,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name,
    interactive: interactive2,
    style: style2
  }), scope);
}
function legendType(spec, scaleType2) {
  let type2 = spec.type || Symbols;
  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type2 = isContinuous$1(scaleType2) ? Gradient : isDiscretizing$1(scaleType2) ? Discrete : Symbols;
  }
  return type2 !== Gradient ? type2 : isDiscretizing$1(scaleType2) ? Discrete : Gradient;
}
function scaleCount(spec) {
  return LegendScales.reduce((count2, type2) => count2 + (spec[type2] ? 1 : 0), 0);
}
function buildLegendEncode(_, spec, config) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset"),
    padding: _("padding"),
    titlePadding: _("titlePadding"),
    cornerRadius: _("cornerRadius"),
    fill: _("fillColor"),
    stroke: _("strokeColor"),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _("legendX"),
    y: _("legendY"),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel("size", spec, marks)), strokeWidth = deref(getChannel("strokeWidth", spec, marks)), fontSize2 = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return parser(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize2})`, scope);
}
function getChannel(name, spec, marks) {
  return spec[name] ? `scale("${spec[name]}",datum)` : getEncoding(name, marks[0].encode);
}
function getFontSize(encode2, scope, style2) {
  return getEncoding("fontSize", encode2) || getStyle("fontSize", scope, style2);
}
const angleExpr = `item.orient==="${Left}"?-90:item.orient==="${Right}"?90:0`;
function parseTitle(spec, scope) {
  spec = isString(spec) ? {
    text: spec
  } : spec;
  const _ = lookup(spec, scope.config.title), encode2 = spec.encode || {}, userEncode = encode2.group || {}, name = userEncode.name || void 0, interactive2 = userEncode.interactive, style2 = userEncode.style, children2 = [];
  const datum2 = {}, dataRef = ref(scope.add(Collect(null, [datum2])));
  children2.push(buildTitle(spec, _, titleEncode(spec), dataRef));
  if (spec.subtitle) {
    children2.push(buildSubTitle(spec, _, encode2.subtitle, dataRef));
  }
  return parseMark(guideGroup({
    role: TitleRole,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children2,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name,
    interactive: interactive2,
    style: style2
  }), scope);
}
function titleEncode(spec) {
  const encode2 = spec.encode;
  return encode2 && encode2.title || extend$3({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode2);
}
function groupEncode(_, userEncode) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    anchor: _("anchor"),
    align: {
      signal: alignExpr$1
    },
    angle: {
      signal: angleExpr
    },
    limit: _("limit"),
    frame: _("frame"),
    offset: _("offset") || 0,
    padding: _("subtitlePadding")
  });
  return extendEncode(encode2, userEncode, Skip);
}
function buildTitle(spec, _, userEncode, dataRef) {
  const zero2 = {
    value: 0
  }, text2 = spec.text, encode2 = {
    enter: {
      opacity: zero2
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    text: text2,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("color"),
    font: _("font"),
    fontSize: _("fontSize"),
    fontStyle: _("fontStyle"),
    fontWeight: _("fontWeight"),
    lineHeight: _("lineHeight")
  }, {
    // update
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero2 = {
    value: 0
  }, text2 = spec.subtitle, encode2 = {
    enter: {
      opacity: zero2
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    text: text2,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("subtitleColor"),
    font: _("subtitleFont"),
    fontSize: _("subtitleFontSize"),
    fontStyle: _("subtitleFontStyle"),
    fontWeight: _("subtitleFontWeight"),
    lineHeight: _("subtitleLineHeight")
  }, {
    // update
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function parseData$2(data2, scope) {
  const transforms2 = [];
  if (data2.transform) {
    data2.transform.forEach((tx2) => {
      transforms2.push(parseTransform(tx2, scope));
    });
  }
  if (data2.on) {
    data2.on.forEach((on2) => {
      parseTrigger(on2, scope, data2.name);
    });
  }
  scope.addDataPipeline(data2.name, analyze(data2, scope, transforms2));
}
function analyze(data2, scope, ops2) {
  const output2 = [];
  let source2 = null, modify2 = false, generate2 = false, upstream, i, n, t4, m2;
  if (data2.values) {
    if (isSignal(data2.values) || hasSignal(data2.format)) {
      output2.push(load(scope, data2));
      output2.push(source2 = collect());
    } else {
      output2.push(source2 = collect({
        $ingest: data2.values,
        $format: data2.format
      }));
    }
  } else if (data2.url) {
    if (hasSignal(data2.url) || hasSignal(data2.format)) {
      output2.push(load(scope, data2));
      output2.push(source2 = collect());
    } else {
      output2.push(source2 = collect({
        $request: data2.url,
        $format: data2.format
      }));
    }
  } else if (data2.source) {
    source2 = upstream = array$5(data2.source).map((d) => ref(scope.getData(d).output));
    output2.push(null);
  }
  for (i = 0, n = ops2.length; i < n; ++i) {
    t4 = ops2[i];
    m2 = t4.metadata;
    if (!source2 && !m2.source) {
      output2.push(source2 = collect());
    }
    output2.push(t4);
    if (m2.generates) generate2 = true;
    if (m2.modifies && !generate2) modify2 = true;
    if (m2.source) source2 = t4;
    else if (m2.changes) source2 = null;
  }
  if (upstream) {
    n = upstream.length - 1;
    output2[0] = Relay({
      derive: modify2,
      pulse: n ? upstream : upstream[0]
    });
    if (modify2 || n) {
      output2.splice(1, 0, collect());
    }
  }
  if (!source2) output2.push(collect());
  output2.push(Sieve({}));
  return output2;
}
function collect(values2) {
  const s = Collect({}, values2);
  s.metadata = {
    source: true
  };
  return s;
}
function load(scope, data2) {
  return Load({
    url: data2.url ? scope.property(data2.url) : void 0,
    async: data2.async ? scope.property(data2.async) : void 0,
    values: data2.values ? scope.property(data2.values) : void 0,
    format: scope.objectProperty(data2.format)
  });
}
const isX = (orient2) => orient2 === Bottom || orient2 === Top;
const getSign = (orient2, a2, b2) => isSignal(orient2) ? ifLeftTopExpr(orient2.signal, a2, b2) : orient2 === Left || orient2 === Top ? a2 : b2;
const ifX = (orient2, a2, b2) => isSignal(orient2) ? ifXEnc(orient2.signal, a2, b2) : isX(orient2) ? a2 : b2;
const ifY = (orient2, a2, b2) => isSignal(orient2) ? ifYEnc(orient2.signal, a2, b2) : isX(orient2) ? b2 : a2;
const ifTop = (orient2, a2, b2) => isSignal(orient2) ? ifTopExpr(orient2.signal, a2, b2) : orient2 === Top ? {
  value: a2
} : {
  value: b2
};
const ifRight = (orient2, a2, b2) => isSignal(orient2) ? ifRightExpr(orient2.signal, a2, b2) : orient2 === Right ? {
  value: a2
} : {
  value: b2
};
const ifXEnc = ($orient, a2, b2) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a2, b2);
const ifYEnc = ($orient, a2, b2) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a2, b2);
const ifLeftTopExpr = ($orient, a2, b2) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a2, b2);
const ifTopExpr = ($orient, a2, b2) => ifExpr(`${$orient} === '${Top}'`, a2, b2);
const ifRightExpr = ($orient, a2, b2) => ifExpr(`${$orient} === '${Right}'`, a2, b2);
const ifEnc = (test2, a2, b2) => {
  a2 = a2 != null ? encoder(a2) : a2;
  b2 = b2 != null ? encoder(b2) : b2;
  if (isSimple(a2) && isSimple(b2)) {
    a2 = a2 ? a2.signal || $(a2.value) : null;
    b2 = b2 ? b2.signal || $(b2.value) : null;
    return {
      signal: `${test2} ? (${a2}) : (${b2})`
    };
  } else {
    return [extend$3({
      test: test2
    }, a2)].concat(b2 || []);
  }
};
const isSimple = (enc) => enc == null || Object.keys(enc).length === 1;
const ifExpr = (test2, a2, b2) => ({
  signal: `${test2} ? (${toExpr(a2)}) : (${toExpr(b2)})`
});
const ifOrient = ($orient, t4, b2, l, r2) => ({
  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : "") + (b2 != null ? `${$orient} === '${Bottom}' ? (${toExpr(b2)}) : ` : "") + (r2 != null ? `${$orient} === '${Right}' ? (${toExpr(r2)}) : ` : "") + (t4 != null ? `${$orient} === '${Top}' ? (${toExpr(t4)}) : ` : "") + "(null)"
});
const toExpr = (v) => isSignal(v) ? v.signal : v == null ? null : $(v);
const mult = (sign2, value2) => value2 === 0 ? 0 : isSignal(sign2) ? {
  signal: `(${sign2.signal}) * ${value2}`
} : {
  value: sign2 * value2
};
const patch = (value2, base2) => {
  const s = value2.signal;
  return s && s.endsWith("(null)") ? {
    signal: s.slice(0, -6) + base2.signal
  } : value2;
};
function fallback(prop, config, axisConfig2, style2) {
  let styleProp;
  if (config && has$2(config, prop)) {
    return config[prop];
  } else if (has$2(axisConfig2, prop)) {
    return axisConfig2[prop];
  } else if (prop.startsWith("title")) {
    switch (prop) {
      case "titleColor":
        styleProp = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style2[GuideTitleStyle][styleProp];
  } else if (prop.startsWith("label")) {
    switch (prop) {
      case "labelColor":
        styleProp = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style2[GuideLabelStyle][styleProp];
  }
  return null;
}
function keys$3(objects) {
  const map2 = {};
  for (const obj of objects) {
    if (!obj) continue;
    for (const key2 in obj) map2[key2] = 1;
  }
  return Object.keys(map2);
}
function axisConfig(spec, scope) {
  var config = scope.config, style2 = config.style, axis = config.axis, band2 = scope.scaleType(spec.scale) === "band" && config.axisBand, orient2 = spec.orient, xy, or2, key2;
  if (isSignal(orient2)) {
    const xyKeys = keys$3([config.axisX, config.axisY]), orientKeys = keys$3([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};
    for (key2 of xyKeys) {
      xy[key2] = ifX(orient2, fallback(key2, config.axisX, axis, style2), fallback(key2, config.axisY, axis, style2));
    }
    or2 = {};
    for (key2 of orientKeys) {
      or2[key2] = ifOrient(orient2.signal, fallback(key2, config.axisTop, axis, style2), fallback(key2, config.axisBottom, axis, style2), fallback(key2, config.axisLeft, axis, style2), fallback(key2, config.axisRight, axis, style2));
    }
  } else {
    xy = orient2 === Top || orient2 === Bottom ? config.axisX : config.axisY;
    or2 = config["axis" + orient2[0].toUpperCase() + orient2.slice(1)];
  }
  const result = xy || or2 || band2 ? extend$3({}, axis, xy, or2, band2) : axis;
  return result;
}
function axisDomain(spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config), orient2 = spec.orient;
  let enter, update2;
  const encode2 = {
    enter: enter = {
      opacity: zero$2
    },
    update: update2 = {
      opacity: one$1
    },
    exit: {
      opacity: zero$2
    }
  };
  addEncoders(encode2, {
    stroke: _("domainColor"),
    strokeCap: _("domainCap"),
    strokeDash: _("domainDash"),
    strokeDashOffset: _("domainDashOffset"),
    strokeWidth: _("domainWidth"),
    strokeOpacity: _("domainOpacity")
  });
  const pos0 = position$1(spec, 0);
  const pos1 = position$1(spec, 1);
  enter.x = update2.x = ifX(orient2, pos0, zero$2);
  enter.x2 = update2.x2 = ifX(orient2, pos1);
  enter.y = update2.y = ifY(orient2, pos0, zero$2);
  enter.y2 = update2.y2 = ifY(orient2, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function position$1(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}
function axisGrid(spec, config, userEncode, dataRef, band2) {
  const _ = lookup(spec, config), orient2 = spec.orient, vscale = spec.gridScale, sign2 = getSign(orient2, 1, -1), offset2 = offsetValue(spec.offset, sign2);
  let enter, exit, update2;
  const encode2 = {
    enter: enter = {
      opacity: zero$2
    },
    update: update2 = {
      opacity: one$1
    },
    exit: exit = {
      opacity: zero$2
    }
  };
  addEncoders(encode2, {
    stroke: _("gridColor"),
    strokeCap: _("gridCap"),
    strokeDash: _("gridDash"),
    strokeDashOffset: _("gridDashOffset"),
    strokeOpacity: _("gridOpacity"),
    strokeWidth: _("gridWidth")
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band2.band,
    extra: band2.extra,
    offset: band2.offset,
    round: _("tickRound")
  };
  const sz2 = ifX(orient2, {
    signal: "height"
  }, {
    signal: "width"
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign2,
    offset: offset2
  } : {
    value: 0,
    offset: offset2
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign2,
    offset: offset2
  } : extend$3(sz2, {
    mult: sign2,
    offset: offset2
  });
  enter.x = update2.x = ifX(orient2, tickPos, gridStart);
  enter.y = update2.y = ifY(orient2, tickPos, gridStart);
  enter.x2 = update2.x2 = ifY(orient2, gridEnd);
  enter.y2 = update2.y2 = ifX(orient2, gridEnd);
  exit.x = ifX(orient2, tickPos);
  exit.y = ifY(orient2, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function offsetValue(offset2, sign2) {
  if (sign2 === 1) ;
  else if (!isObject$1(offset2)) {
    offset2 = isSignal(sign2) ? {
      signal: `(${sign2.signal}) * (${offset2 || 0})`
    } : sign2 * (offset2 || 0);
  } else {
    let entry2 = offset2 = extend$3({}, offset2);
    while (entry2.mult != null) {
      if (!isObject$1(entry2.mult)) {
        entry2.mult = isSignal(sign2) ? {
          signal: `(${entry2.mult}) * (${sign2.signal})`
        } : entry2.mult * sign2;
        return offset2;
      } else {
        entry2 = entry2.mult = extend$3({}, entry2.mult);
      }
    }
    entry2.mult = sign2;
  }
  return offset2;
}
function axisTicks(spec, config, userEncode, dataRef, size, band2) {
  const _ = lookup(spec, config), orient2 = spec.orient, sign2 = getSign(orient2, -1, 1);
  let enter, exit, update2;
  const encode2 = {
    enter: enter = {
      opacity: zero$2
    },
    update: update2 = {
      opacity: one$1
    },
    exit: exit = {
      opacity: zero$2
    }
  };
  addEncoders(encode2, {
    stroke: _("tickColor"),
    strokeCap: _("tickCap"),
    strokeDash: _("tickDash"),
    strokeDashOffset: _("tickDashOffset"),
    strokeOpacity: _("tickOpacity"),
    strokeWidth: _("tickWidth")
  });
  const tickSize = encoder(size);
  tickSize.mult = sign2;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band2.band,
    extra: band2.extra,
    offset: band2.offset,
    round: _("tickRound")
  };
  update2.y = enter.y = ifX(orient2, zero$2, tickPos);
  update2.y2 = enter.y2 = ifX(orient2, tickSize);
  exit.x = ifX(orient2, tickPos);
  update2.x = enter.x = ifY(orient2, zero$2, tickPos);
  update2.x2 = enter.x2 = ifY(orient2, tickSize);
  exit.y = ifY(orient2, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function flushExpr(scale2, threshold2, a2, b2, c2) {
  return {
    signal: 'flush(range("' + scale2 + '"), scale("' + scale2 + '", datum.value), ' + threshold2 + "," + a2 + "," + b2 + "," + c2 + ")"
  };
}
function axisLabels(spec, config, userEncode, dataRef, size, band2) {
  const _ = lookup(spec, config), orient2 = spec.orient, scale2 = spec.scale, sign2 = getSign(orient2, -1, 1), flush2 = deref(_("labelFlush")), flushOffset = deref(_("labelFlushOffset")), labelAlign = _("labelAlign"), labelBaseline = _("labelBaseline");
  let flushOn = flush2 === 0 || !!flush2, update2;
  const tickSize = encoder(size);
  tickSize.mult = sign2;
  tickSize.offset = encoder(_("labelPadding") || 0);
  tickSize.offset.mult = sign2;
  const tickPos = {
    scale: scale2,
    field: Value,
    band: 0.5,
    offset: extendOffset(band2.offset, _("labelOffset"))
  };
  const align2 = ifX(orient2, flushOn ? flushExpr(scale2, flush2, '"left"', '"right"', '"center"') : {
    value: "center"
  }, ifRight(orient2, "left", "right"));
  const baseline2 = ifX(orient2, ifTop(orient2, "bottom", "top"), flushOn ? flushExpr(scale2, flush2, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  });
  const offsetExpr = flushExpr(scale2, flush2, `-(${flushOffset})`, flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero$2,
    x: ifX(orient2, tickPos, tickSize),
    y: ifY(orient2, tickPos, tickSize)
  };
  const encode2 = {
    enter,
    update: update2 = {
      opacity: one$1,
      text: {
        field: Label
      },
      x: enter.x,
      y: enter.y,
      align: align2,
      baseline: baseline2
    },
    exit: {
      opacity: zero$2,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode2, {
    dx: !labelAlign && flushOn ? ifX(orient2, offsetExpr) : null,
    dy: !labelBaseline && flushOn ? ifY(orient2, offsetExpr) : null
  });
  addEncoders(encode2, {
    angle: _("labelAngle"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontWeight: _("labelFontWeight"),
    fontStyle: _("labelFontStyle"),
    limit: _("labelLimit"),
    lineHeight: _("labelLineHeight")
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });
  const bound2 = _("labelBound");
  let overlap = _("labelOverlap");
  overlap = overlap || bound2 ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum.index",
    bound: bound2 ? {
      scale: scale2,
      orient: orient2,
      tolerance: bound2
    } : null
  } : void 0;
  if (update2.align !== align2) {
    update2.align = patch(update2.align, align2);
  }
  if (update2.baseline !== baseline2) {
    update2.baseline = patch(update2.baseline, baseline2);
  }
  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function axisTitle(spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config), orient2 = spec.orient, sign2 = getSign(orient2, -1, 1);
  let enter, update2;
  const encode2 = {
    enter: enter = {
      opacity: zero$2,
      anchor: encoder(_("titleAnchor", null)),
      align: {
        signal: alignExpr$1
      }
    },
    update: update2 = extend$3({}, enter, {
      opacity: one$1,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero$2
    }
  };
  const titlePos = {
    signal: `lerp(range("${spec.scale}"), ${anchorExpr(0, 1, 0.5)})`
  };
  update2.x = ifX(orient2, titlePos);
  update2.y = ifY(orient2, titlePos);
  enter.angle = ifX(orient2, zero$2, mult(sign2, 90));
  enter.baseline = ifX(orient2, ifTop(orient2, Bottom, Top), {
    value: Bottom
  });
  update2.angle = enter.angle;
  update2.baseline = enter.baseline;
  addEncoders(encode2, {
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    // require update
    align: _("titleAlign"),
    angle: _("titleAngle"),
    baseline: _("titleBaseline")
  });
  autoLayout(_, orient2, encode2, userEncode);
  encode2.update.align = patch(encode2.update.align, enter.align);
  encode2.update.angle = patch(encode2.update.angle, enter.angle);
  encode2.update.baseline = patch(encode2.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function autoLayout(_, orient2, encode2, userEncode) {
  const auto = (value2, dim) => value2 != null ? (encode2.update[dim] = patch(encoder(value2), encode2.update[dim]), false) : !has$1(dim, userEncode) ? true : false;
  const autoY = auto(_("titleX"), "x"), autoX = auto(_("titleY"), "y");
  encode2.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient2, encoder(autoX), encoder(autoY));
}
function parseAxis$1(spec, scope) {
  const config = axisConfig(spec, scope), encode2 = spec.encode || {}, axisEncode = encode2.axis || {}, name = axisEncode.name || void 0, interactive2 = axisEncode.interactive, style2 = axisEncode.style, _ = lookup(spec, config), band2 = tickBand(_);
  const datum2 = {
    scale: spec.scale,
    ticks: !!_("ticks"),
    labels: !!_("labels"),
    grid: !!_("grid"),
    domain: !!_("domain"),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect({}, [datum2])));
  const ticksRef = ref(scope.add(AxisTicks({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band2.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  const children2 = [];
  let size;
  if (datum2.grid) {
    children2.push(axisGrid(spec, config, encode2.grid, ticksRef, band2));
  }
  if (datum2.ticks) {
    size = _("tickSize");
    children2.push(axisTicks(spec, config, encode2.ticks, ticksRef, size, band2));
  }
  if (datum2.labels) {
    size = datum2.ticks ? size : 0;
    children2.push(axisLabels(spec, config, encode2.labels, ticksRef, size, band2));
  }
  if (datum2.domain) {
    children2.push(axisDomain(spec, config, encode2.domain, dataRef));
  }
  if (datum2.title) {
    children2.push(axisTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: AxisRole,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),
    marks: children2,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name,
    interactive: interactive2,
    style: style2
  }), scope);
}
function buildAxisEncode(_, spec) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset") || 0,
    position: value(spec.position, 0),
    titlePadding: _("titlePadding"),
    minExtent: _("minExtent"),
    maxExtent: _("maxExtent"),
    range: {
      signal: `abs(span(range("${spec.scale}")))`
    },
    translate: _("translate"),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function parseScope(spec, scope, preprocessed) {
  const signals = array$5(spec.signals), scales2 = array$5(spec.scales);
  if (!preprocessed) signals.forEach((_) => parseSignal(_, scope));
  array$5(spec.projections).forEach((_) => parseProjection$1(_, scope));
  scales2.forEach((_) => initScale(_, scope));
  array$5(spec.data).forEach((_) => parseData$2(_, scope));
  scales2.forEach((_) => parseScale(_, scope));
  (preprocessed || signals).forEach((_) => parseSignalUpdates(_, scope));
  array$5(spec.axes).forEach((_) => parseAxis$1(_, scope));
  array$5(spec.marks).forEach((_) => parseMark(_, scope));
  array$5(spec.legends).forEach((_) => parseLegend$1(_, scope));
  if (spec.title) parseTitle(spec.title, scope);
  scope.parseLambdas();
  return scope;
}
const rootEncode = (spec) => extendEncode({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: "width"
    },
    height: {
      signal: "height"
    }
  }
}, spec);
function parseView(spec, scope) {
  const config = scope.config;
  const root2 = ref(scope.root = scope.add(operator()));
  const signals = collectSignals(spec, config);
  signals.forEach((_) => parseSignal(_, scope));
  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale;
  const input = scope.add(Collect());
  const encode2 = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {
    pulse: ref(input)
  })));
  const parent = scope.add(ViewLayout({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef("autosize"),
    mark: root2,
    pulse: ref(encode2)
  }));
  scope.operators.pop();
  scope.pushState(ref(encode2), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent);
  let op = scope.add(Bound({
    mark: root2,
    pulse: ref(parent)
  }));
  op = scope.add(Render({
    pulse: ref(op)
  }));
  op = scope.add(Sieve({
    pulse: ref(op)
  }));
  scope.addData("root", new DataScope(scope, input, input, op));
  return scope;
}
function signalObject(name, value2) {
  return value2 && value2.signal ? {
    name,
    update: value2.signal
  } : {
    name,
    value: value2
  };
}
function collectSignals(spec, config) {
  const _ = (name) => value(spec[name], config[name]), signals = [signalObject("background", _("background")), signalObject("autosize", parseAutosize(_("autosize"))), signalObject("padding", parsePadding(_("padding"))), signalObject("width", _("width") || 0), signalObject("height", _("height") || 0)], pre = signals.reduce((p, s) => (p[s.name] = s, p), {}), map2 = {};
  array$5(spec.signals).forEach((s) => {
    if (has$2(pre, s.name)) {
      s = extend$3(pre[s.name], s);
    } else {
      signals.push(s);
    }
    map2[s.name] = s;
  });
  array$5(config.signals).forEach((s) => {
    if (!has$2(map2, s.name) && !has$2(pre, s.name)) {
      signals.push(s);
    }
  });
  return signals;
}
function Scope(config, options) {
  this.config = config || {};
  this.options = options || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}
function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}
Scope.prototype = Subscope.prototype = {
  parse(spec) {
    return parseScope(spec, this);
  },
  fork() {
    return new Subscope(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    this.finish();
    return {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ":" : 0) + this._id++;
  },
  add(op) {
    this.operators.push(op);
    op.id = this.id();
    if (op.refs) {
      op.refs.forEach((ref2) => {
        ref2.$ref = op.id;
      });
      op.refs = null;
    }
    return op;
  },
  proxy(op) {
    const vref = op instanceof Entry$1 ? ref(op) : op;
    return this.add(Proxy$1({
      value: vref
    }));
  },
  addStream(stream2) {
    this.streams.push(stream2);
    stream2.id = this.id();
    return stream2;
  },
  addUpdate(update2) {
    this.updates.push(update2);
    return update2;
  },
  // Apply metadata
  finish() {
    let name, ds;
    if (this.root) this.root.root = true;
    for (name in this.signals) {
      this.signals[name].signal = name;
    }
    for (name in this.scales) {
      this.scales[name].scale = name;
    }
    function annotate(op, name2, type2) {
      let data2, list;
      if (op) {
        data2 = op.data || (op.data = {});
        list = data2[name2] || (data2[name2] = []);
        list.push(type2);
      }
    }
    for (name in this.data) {
      ds = this.data[name];
      annotate(ds.input, name, "input");
      annotate(ds.output, name, "output");
      annotate(ds.values, name, "values");
      for (const field2 in ds.index) {
        annotate(ds.index[field2], name, "index:" + field2);
      }
    }
    return this;
  },
  // ----
  pushState(encode2, parent, lookup2) {
    this._encode.push(ref(this.add(Sieve({
      pulse: encode2
    }))));
    this._parent.push(parent);
    this._lookup.push(lookup2 ? ref(this.proxy(lookup2)) : null);
    this._markpath.push(-1);
  },
  popState() {
    this._encode.pop();
    this._parent.pop();
    this._lookup.pop();
    this._markpath.pop();
  },
  parent() {
    return peek$2(this._parent);
  },
  encode() {
    return peek$2(this._encode);
  },
  lookup() {
    return peek$2(this._lookup);
  },
  markpath() {
    const p = this._markpath;
    return ++p[p.length - 1];
  },
  // ----
  fieldRef(field2, name) {
    if (isString(field2)) return fieldRef$1(field2, name);
    if (!field2.signal) {
      error("Unsupported field reference: " + $(field2));
    }
    const s = field2.signal;
    let f = this.field[s];
    if (!f) {
      const params2 = {
        name: this.signalRef(s)
      };
      if (name) params2.as = name;
      this.field[s] = f = ref(this.add(Field(params2)));
    }
    return f;
  },
  compareRef(cmp2) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;
    const fields = array$5(cmp2.field).map(check), orders = array$5(cmp2.order).map(check);
    return signal ? ref(this.add(Compare({
      fields,
      orders
    }))) : compareRef(fields, orders);
  },
  keyRef(fields, flat2) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;
    const sig = this.signals;
    fields = array$5(fields).map(check);
    return signal ? ref(this.add(Key({
      fields,
      flat: flat2
    }))) : keyRef(fields, flat2);
  },
  sortRef(sort2) {
    if (!sort2) return sort2;
    const a2 = aggrField(sort2.op, sort2.field), o = sort2.order || Ascending;
    return o.signal ? ref(this.add(Compare({
      fields: a2,
      orders: this.signalRef(o.signal)
    }))) : compareRef(a2, o);
  },
  // ----
  event(source2, type2) {
    const key2 = source2 + ":" + type2;
    if (!this.events[key2]) {
      const id2 = this.id();
      this.streams.push({
        id: id2,
        source: source2,
        type: type2
      });
      this.events[key2] = id2;
    }
    return this.events[key2];
  },
  // ----
  hasOwnSignal(name) {
    return has$2(this.signals, name);
  },
  addSignal(name, value2) {
    if (this.hasOwnSignal(name)) {
      error("Duplicate signal name: " + $(name));
    }
    const op = value2 instanceof Entry$1 ? value2 : this.add(operator(value2));
    return this.signals[name] = op;
  },
  getSignal(name) {
    if (!this.signals[name]) {
      error("Unrecognized signal name: " + $(name));
    }
    return this.signals[name];
  },
  signalRef(s) {
    if (this.signals[s]) {
      return ref(this.signals[s]);
    } else if (!has$2(this.lambdas, s)) {
      this.lambdas[s] = this.add(operator(null));
    }
    return ref(this.lambdas[s]);
  },
  parseLambdas() {
    const code = Object.keys(this.lambdas);
    for (let i = 0, n = code.length; i < n; ++i) {
      const s = code[i], e3 = parser(s, this), op = this.lambdas[s];
      op.params = e3.$params;
      op.update = e3.$expr;
    }
  },
  property(spec) {
    return spec && spec.signal ? this.signalRef(spec.signal) : spec;
  },
  objectProperty(spec) {
    return !spec || !isObject$1(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
  },
  exprRef(code, name) {
    const params2 = {
      expr: parser(code, this)
    };
    if (name) params2.expr.$name = name;
    return ref(this.add(Expression(params2)));
  },
  addBinding(name, bind2) {
    if (!this.bindings) {
      error("Nested signals do not support binding: " + $(name));
    }
    this.bindings.push(extend$3({
      signal: name
    }, bind2));
  },
  // ----
  addScaleProj(name, transform2) {
    if (has$2(this.scales, name)) {
      error("Duplicate scale or projection name: " + $(name));
    }
    this.scales[name] = this.add(transform2);
  },
  addScale(name, params2) {
    this.addScaleProj(name, Scale(params2));
  },
  addProjection(name, params2) {
    this.addScaleProj(name, Projection(params2));
  },
  getScale(name) {
    if (!this.scales[name]) {
      error("Unrecognized scale name: " + $(name));
    }
    return this.scales[name];
  },
  scaleRef(name) {
    return ref(this.getScale(name));
  },
  scaleType(name) {
    return this.getScale(name).params.type;
  },
  projectionRef(name) {
    return this.scaleRef(name);
  },
  projectionType(name) {
    return this.scaleType(name);
  },
  // ----
  addData(name, dataScope) {
    if (has$2(this.data, name)) {
      error("Duplicate data set name: " + $(name));
    }
    return this.data[name] = dataScope;
  },
  getData(name) {
    if (!this.data[name]) {
      error("Undefined data set name: " + $(name));
    }
    return this.data[name];
  },
  addDataPipeline(name, entries2) {
    if (has$2(this.data, name)) {
      error("Duplicate data set name: " + $(name));
    }
    return this.addData(name, DataScope.fromEntries(this, entries2));
  }
};
function propertyLambda(spec) {
  return (isArray$1(spec) ? arrayLambda : objectLambda)(spec);
}
function arrayLambda(array2) {
  const n = array2.length;
  let code = "[";
  for (let i = 0; i < n; ++i) {
    const value2 = array2[i];
    code += (i > 0 ? "," : "") + (isObject$1(value2) ? value2.signal || propertyLambda(value2) : $(value2));
  }
  return code + "]";
}
function objectLambda(obj) {
  let code = "{", i = 0, key2, value2;
  for (key2 in obj) {
    value2 = obj[key2];
    code += (++i > 1 ? "," : "") + $(key2) + ":" + (isObject$1(value2) ? value2.signal || propertyLambda(value2) : $(value2));
  }
  return code + "}";
}
function defaults() {
  const defaultFont2 = "sans-serif", defaultSymbolSize = 30, defaultStrokeWidth = 2, defaultColor = "#4c78a8", black = "#000", gray = "#888", lightGray = "#ddd";
  return {
    // default visualization description
    description: "Vega visualization",
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: "pad",
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont2,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    // style definitions
    style: {
      // axis & legend labels
      "guide-label": {
        fill: black,
        font: defaultFont2,
        fontSize: 10
      },
      // axis & legend titles
      "guide-title": {
        fill: black,
        font: defaultFont2,
        fontSize: 11,
        fontWeight: "bold"
      },
      // headers, including chart title
      "group-title": {
        fill: black,
        font: defaultFont2,
        fontSize: 13,
        fontWeight: "bold"
      },
      // chart subtitle
      "group-subtitle": {
        fill: black,
        font: defaultFont2,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "circle"
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "square"
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: "transparent",
        stroke: lightGray
      }
    },
    // defaults for title
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: "mercator"
    },
    // defaults for legends
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: gray,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function parse$2(spec, config, options) {
  if (!isObject$1(spec)) {
    error("Input Vega specification must be an object.");
  }
  config = mergeConfig(defaults(), config, spec.config);
  return parseView(spec, new Scope(config, options)).toRuntime();
}
var version$4 = "5.22.1";
extend$3(transforms, tx, vtx, encode$1, geo, force, label, tree, reg, voronoi, wordcloud, xf);
const vegaImport = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bounds,
  CanvasHandler,
  CanvasRenderer,
  DATE,
  DAY,
  DAYOFYEAR,
  Dataflow,
  Debug,
  Error: Error$1,
  EventStream,
  Gradient: Gradient$1,
  GroupItem,
  HOURS,
  Handler: Handler$1,
  Info,
  Item,
  MILLISECONDS,
  MINUTES,
  MONTH,
  Marks,
  MultiPulse,
  None: None$2,
  Operator,
  Parameters,
  Pulse,
  QUARTER,
  RenderType,
  Renderer,
  ResourceLoader,
  SECONDS,
  SVGHandler,
  SVGRenderer,
  SVGStringRenderer,
  Scenegraph,
  TIME_UNITS,
  Transform,
  View: View$1,
  WEEK,
  Warn,
  YEAR,
  accessor,
  accessorFields,
  accessorName,
  array: array$5,
  ascending: ascending$3,
  bandwidthNRD: estimateBandwidth,
  bin,
  bootstrapCI,
  boundClip,
  boundContext,
  boundItem: boundItem$1,
  boundMark,
  boundStroke,
  changeset,
  clampRange,
  codegenExpression: codegen,
  compare: compare$9,
  constant: constant$5,
  cumulativeLogNormal,
  cumulativeNormal,
  cumulativeUniform,
  dayofyear,
  debounce: debounce$1,
  defaultLocale,
  definition: definition$1,
  densityLogNormal,
  densityNormal,
  densityUniform,
  domChild,
  domClear,
  domCreate,
  domFind,
  dotbin,
  error,
  expressionFunction,
  extend: extend$3,
  extent,
  extentIndex,
  falsy,
  fastmap,
  field: field$1,
  flush,
  font: font$1,
  fontFamily,
  fontSize,
  format: format$2,
  formatLocale: numberFormatDefaultLocale,
  formats: formats$1,
  hasOwnProperty: has$2,
  id,
  identity: identity$6,
  inferType,
  inferTypes,
  ingest: ingest$1,
  inherits,
  inrange,
  interpolate: interpolate$2,
  interpolateColors,
  interpolateRange: interpolateRange$1,
  intersect: intersect$2,
  intersectBoxLine,
  intersectPath,
  intersectPoint,
  intersectRule,
  isArray: isArray$1,
  isBoolean: isBoolean$2,
  isDate: isDate$1,
  isFunction: isFunction$3,
  isIterable,
  isNumber: isNumber$1,
  isObject: isObject$1,
  isRegExp,
  isString,
  isTuple,
  key,
  lerp,
  lineHeight,
  loader,
  locale,
  logger,
  lruCache: lruCache$1,
  markup,
  merge: merge$4,
  mergeConfig,
  multiLineOffset,
  one: one$3,
  pad: pad$2,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  parse: parse$2,
  parseExpression: parser$1,
  parseSelector: eventSelector,
  path: path$3,
  pathCurves: curves,
  pathEqual,
  pathParse: parse$4,
  pathRectangle: vg_rect,
  pathRender,
  pathSymbols: symbols$1,
  pathTrail: vg_trail,
  peek: peek$2,
  point: point$2,
  projection,
  quantileLogNormal,
  quantileNormal,
  quantileUniform,
  quantiles,
  quantizeInterpolator,
  quarter,
  quartiles,
  get random() {
    return random;
  },
  randomInteger: integer,
  randomKDE: kde,
  randomLCG: lcg$2,
  randomLogNormal: lognormal,
  randomMixture: mixture$1,
  randomNormal: gaussian,
  randomUniform: uniform,
  read,
  regressionExp: exp$1,
  regressionLinear: linear$3,
  regressionLoess: loess,
  regressionLog: log$4,
  regressionPoly: poly,
  regressionPow: pow$3,
  regressionQuad: quad,
  renderModule,
  repeat,
  resetDefaultLocale,
  resetSVGClipId,
  resetSVGDefIds,
  responseType,
  runtimeContext: context,
  sampleCurve,
  sampleLogNormal,
  sampleNormal,
  sampleUniform,
  scale: scale$4,
  sceneEqual,
  sceneFromJSON,
  scenePickVisit: pickVisit,
  sceneToJSON,
  sceneVisit: visit,
  sceneZOrder: zorder,
  scheme: scheme$1,
  serializeXML,
  setRandom,
  span,
  splitAccessPath,
  stringValue: $,
  textMetrics,
  timeBin: bin$1,
  timeFloor,
  timeFormatLocale: timeFormatDefaultLocale,
  timeInterval,
  timeOffset,
  timeSequence,
  timeUnitSpecifier,
  timeUnits,
  toBoolean,
  toDate,
  toNumber,
  toSet,
  toString,
  transform: transform$2,
  transforms,
  truncate: truncate$1,
  truthy,
  tupleid,
  typeParsers,
  utcFloor,
  utcInterval,
  utcOffset,
  utcSequence,
  utcdayofyear,
  utcquarter,
  utcweek,
  version: version$4,
  visitArray,
  week,
  writeConfig,
  zero: zero$5,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog
}, Symbol.toStringTag, { value: "Module" }));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a2.prototype = f.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_development = {};
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    (function() {
      var React2 = React__default;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error2(format2) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack2 = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack2 !== "") {
            format2 += "%s";
            args = args.concat([stack2]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type2) {
        if (typeof type2 === "string" || typeof type2 === "function") {
          return true;
        }
        if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type2 === "object" && type2 !== null) {
          if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type2) {
        return type2.displayName || "Context";
      }
      function getComponentNameFromType(type2) {
        if (type2 == null) {
          return null;
        }
        {
          if (typeof type2.tag === "number") {
            error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type2 === "function") {
          return type2.displayName || type2.name || null;
        }
        if (typeof type2 === "string") {
          return type2;
        }
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type2 === "object") {
          switch (type2.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context2 = type2;
              return getContextName(context2) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type2;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type2, type2.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type2.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x2) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign2 = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign2({}, props, {
                value: prevLog
              }),
              info: assign2({}, props, {
                value: prevInfo
              }),
              warn: assign2({}, props, {
                value: prevWarn
              }),
              error: assign2({}, props, {
                value: prevError
              }),
              group: assign2({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign2({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign2({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix2;
      function describeBuiltInComponentFrame(name, source2, ownerFn) {
        {
          if (prefix2 === void 0) {
            try {
              throw Error();
            } catch (x2) {
              var match2 = x2.stack.trim().match(/\n( *(at )?)/);
              prefix2 = match2 && match2[1] || "";
            }
          }
          return "\n" + prefix2 + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame2 = componentFrameCache.get(fn);
          if (frame2 !== void 0) {
            return frame2;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
              c2--;
            }
            for (; s >= 1 && c2 >= 0; s--, c2--) {
              if (sampleLines[s] !== controlLines[c2]) {
                if (s !== 1 || c2 !== 1) {
                  do {
                    s--;
                    c2--;
                    if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source2, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype2 = Component.prototype;
        return !!(prototype2 && prototype2.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type2, source2, ownerFn) {
        if (type2 == null) {
          return "";
        }
        if (typeof type2 === "function") {
          {
            return describeNativeComponentFrame(type2, shouldConstruct(type2));
          }
        }
        if (typeof type2 === "string") {
          return describeBuiltInComponentFrame(type2);
        }
        switch (type2) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type2 === "object") {
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type2.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type2.type, source2, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source2, ownerFn);
              } catch (x2) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element2) {
        {
          if (element2) {
            var owner = element2._owner;
            var stack2 = describeUnknownElementTypeFrameInDEV(element2.type, element2._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack2);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element2) {
        {
          var has2 = Function.call.bind(hasOwnProperty2);
          for (var typeSpecName in typeSpecs) {
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element2);
                error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element2);
                error2("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray2(a2) {
        return isArrayImpl(a2);
      }
      function typeName(value2) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
          return type2;
        }
      }
      function willCoercionThrow(value2) {
        {
          try {
            testStringCoercion(value2);
            return false;
          } catch (e3) {
            return true;
          }
        }
      }
      function testStringCoercion(value2) {
        return "" + value2;
      }
      function checkKeyStringCoercion(value2) {
        {
          if (willCoercionThrow(value2)) {
            error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
            return testStringCoercion(value2);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      function hasValidRef(config) {
        {
          if (hasOwnProperty2.call(config, "ref")) {
            var getter2 = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter2 && getter2.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty2.call(config, "key")) {
            var getter2 = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter2 && getter2.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2) ;
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type2, key2, ref2, self2, source2, owner, props) {
        var element2 = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type: type2,
          key: key2,
          ref: ref2,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element2._store = {};
          Object.defineProperty(element2._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element2, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element2, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source2
          });
          if (Object.freeze) {
            Object.freeze(element2.props);
            Object.freeze(element2);
          }
        }
        return element2;
      };
      function jsxDEV(type2, config, maybeKey, source2, self2) {
        {
          var propName;
          var props = {};
          var key2 = null;
          var ref2 = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key2 = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key2 = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref2 = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type2 && type2.defaultProps) {
            var defaultProps = type2.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key2 || ref2) {
            var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
            if (key2) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref2) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type2, key2, ref2, self2, source2, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element2) {
        {
          if (element2) {
            var owner = element2._owner;
            var stack2 = describeUnknownElementTypeFrameInDEV(element2.type, element2._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack2);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object2) {
        {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source2) {
        {
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info2 = getDeclarationErrorAddendum();
          if (!info2) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info2 = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info2;
        }
      }
      function validateExplicitKey(element2, parentType) {
        {
          if (!element2._store || element2._store.validated || element2.key != null) {
            return;
          }
          element2._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element2 && element2._owner && element2._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element2._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element2);
          error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node2, parentType) {
        {
          if (typeof node2 !== "object") {
            return;
          }
          if (isArray2(node2)) {
            for (var i = 0; i < node2.length; i++) {
              var child = node2[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node2)) {
            if (node2._store) {
              node2._store.validated = true;
            }
          } else if (node2) {
            var iteratorFn = getIteratorFn(node2);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node2.entries) {
                var iterator = iteratorFn.call(node2);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element2) {
        {
          var type2 = element2.type;
          if (type2 === null || type2 === void 0 || typeof type2 === "string") {
            return;
          }
          var propTypes2;
          if (typeof type2 === "function") {
            propTypes2 = type2.propTypes;
          } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type2.$$typeof === REACT_MEMO_TYPE)) {
            propTypes2 = type2.propTypes;
          } else {
            return;
          }
          if (propTypes2) {
            var name = getComponentNameFromType(type2);
            checkPropTypes(propTypes2, element2.props, "prop", name, element2);
          } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type2);
            error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
            error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys2 = Object.keys(fragment.props);
          for (var i = 0; i < keys2.length; i++) {
            var key2 = keys2[i];
            if (key2 !== "children" && key2 !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error2("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type2, props, key2, isStaticChildren, source2, self2) {
        {
          var validType = isValidElementType(type2);
          if (!validType) {
            var info2 = "";
            if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
              info2 += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum();
            if (sourceInfo) {
              info2 += sourceInfo;
            } else {
              info2 += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type2 === null) {
              typeString = "null";
            } else if (isArray2(type2)) {
              typeString = "array";
            } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />";
              info2 = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type2;
            }
            error2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info2);
          }
          var element2 = jsxDEV(type2, props, key2, source2, self2);
          if (element2 == null) {
            return element2;
          }
          if (validType) {
            var children2 = props.children;
            if (children2 !== void 0) {
              if (isStaticChildren) {
                if (isArray2(children2)) {
                  for (var i = 0; i < children2.length; i++) {
                    validateChildKeys(children2[i], type2);
                  }
                  if (Object.freeze) {
                    Object.freeze(children2);
                  }
                } else {
                  error2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children2, type2);
              }
            }
          }
          {
            if (hasOwnProperty2.call(props, "key")) {
              var componentName = getComponentNameFromType(type2);
              var keys2 = Object.keys(props).filter(function(k) {
                return k !== "key";
              });
              var beforeExample = keys2.length > 0 ? "{key: someKey, " + keys2.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys2.length > 0 ? "{" + keys2.join(": ..., ") + ": ...}" : "{}";
                error2('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type2 === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element2);
          } else {
            validatePropTypes(element2);
          }
          return element2;
        }
      }
      function jsxWithValidationStatic(type2, props, key2) {
        {
          return jsxWithValidation(type2, props, key2, true);
        }
      }
      function jsxWithValidationDynamic(type2, props, key2) {
        {
          return jsxWithValidation(type2, props, key2, false);
        }
      }
      var jsx3 = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_development.jsx = jsx3;
      reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  return reactJsxRuntime_development;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_development();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert2(rule2) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule2, sheet.cssRules.length);
      } catch (e3) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule2));
    }
    this.ctr++;
  };
  _proto.flush = function flush2() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$1(value2, length2) {
  return charat(value2, 0) ^ 45 ? (((length2 << 2 ^ charat(value2, 0)) << 2 ^ charat(value2, 1)) << 2 ^ charat(value2, 2)) << 2 ^ charat(value2, 3) : 0;
}
function trim$1(value2) {
  return value2.trim();
}
function match(value2, pattern) {
  return (value2 = pattern.exec(value2)) ? value2[0] : value2;
}
function replace(value2, pattern, replacement) {
  return value2.replace(pattern, replacement);
}
function indexof(value2, search) {
  return value2.indexOf(search);
}
function charat(value2, index2) {
  return value2.charCodeAt(index2) | 0;
}
function substr(value2, begin, end) {
  return value2.slice(begin, end);
}
function strlen(value2) {
  return value2.length;
}
function sizeof(value2) {
  return value2.length;
}
function append(value2, array2) {
  return array2.push(value2), value2;
}
function combine(array2, callback) {
  return array2.map(callback).join("");
}
var line$1 = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value2, root2, parent, type2, props, children2, length2) {
  return { value: value2, root: root2, parent, type: type2, props, children: children2, line: line$1, column, length: length2, return: "" };
}
function copy(root2, props) {
  return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line$1--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line$1++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice$1(begin, end) {
  return substr(characters, begin, end);
}
function token(type2) {
  switch (type2) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value2) {
  return line$1 = column = 1, length = strlen(characters = value2), position = 0, [];
}
function dealloc(value2) {
  return characters = "", value2;
}
function delimit(type2) {
  return trim$1(slice$1(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice$1(index2, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      // ] ) " '
      case type2:
        return position;
      // " '
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type2, index2) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice$1(index2, position - 1) + "*" + from(type2 === 47 ? type2 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice$1(index2, position);
}
function compile$1(value2) {
  return dealloc(parse("", null, null, null, [""], value2 = alloc(value2), 0, [0], value2));
}
function parse(value2, root2, parent, rule2, rules, rulesets, pseudo, points2, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property2 = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children2 = rulesets;
  var reference = rule2;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points2[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property2 > 0 && strlen(characters2) - length2)
              append(property2 > 32 ? declaration(characters2 + ";", rule2, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule2, parent, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset2, rules, points2, type2, props = [], children2 = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points2, children2);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value2, reference, reference, rule2 && append(ruleset(value2, reference, reference, 0, 0, rules, points2, type2, rules, props = [], length2), children2), rules, children2, length2, points2, rule2 ? props : children2);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children2, 0, points2, children2);
                }
        }
        index2 = offset2 = property2 = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property2 = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points2[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value2, root2, parent, index2, offset2, rules, points2, type2, props, children2, length2) {
  var post2 = offset2 - 1;
  var rule2 = offset2 === 0 ? rules : [""];
  var size = sizeof(rule2);
  for (var i = 0, j = 0, k = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value2, post2 + 1, post2 = abs(j = points2[i])), z2 = value2; x2 < size; ++x2)
      if (z2 = trim$1(j > 0 ? rule2[x2] + " " + y2 : replace(y2, /&\f/g, rule2[x2])))
        props[k++] = z2;
  return node(value2, root2, parent, offset2 === 0 ? RULESET : type2, props, children2, length2);
}
function comment(value2, root2, parent) {
  return node(value2, root2, parent, COMMENT, from(char()), substr(value2, 2, -2), 0);
}
function declaration(value2, root2, parent, length2) {
  return node(value2, root2, parent, DECLARATION, substr(value2, 0, length2), substr(value2, length2 + 1, -1), length2);
}
function serialize(children2, callback) {
  var output2 = "";
  var length2 = sizeof(children2);
  for (var i = 0; i < length2; i++)
    output2 += callback(children2[i], i, children2, callback) || "";
  return output2;
}
function stringify$3(element2, index2, children2, callback) {
  switch (element2.type) {
    case LAYER:
      if (element2.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element2.return = element2.return || element2.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element2.return = element2.value + "{" + serialize(element2.children, callback) + "}";
    case RULESET:
      element2.value = element2.props.join(",");
  }
  return strlen(children2 = serialize(element2.children, callback)) ? element2.return = element2.value + "{" + children2 + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element2, index2, children2, callback) {
    var output2 = "";
    for (var i = 0; i < length2; i++)
      output2 += collection[i](element2, index2, children2, callback) || "";
    return output2;
  };
}
function rulesheet(callback) {
  return function(element2) {
    if (!element2.root) {
      if (element2 = element2.return)
        callback(element2);
    }
  };
}
function memoize$1(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points2, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points2[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice$1(begin, position);
};
var toRules = function toRules2(parsed, points2) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points2[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points2, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points2[index2] = parsed[index2].length;
          break;
        }
      // fallthrough
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value2, points2) {
  return dealloc(toRules(alloc(value2), points2));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element2) {
  if (element2.type !== "rule" || !element2.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element2.length < 1) {
    return;
  }
  var value2 = element2.value;
  var parent = element2.parent;
  var isImplicitRule = element2.column === parent.column && element2.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element2.props.length === 1 && value2.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element2, true);
  var points2 = [];
  var rules = getRules(value2, points2);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element2.props[k] = points2[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element2) {
  if (element2.type === "decl") {
    var value2 = element2.value;
    if (
      // charcode for l
      value2.charCodeAt(0) === 108 && // charcode for b
      value2.charCodeAt(2) === 98
    ) {
      element2["return"] = "";
      element2.value = "";
    }
  }
};
function prefix(value2, length2) {
  switch (hash$1(value2, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value2 + value2;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value2 + value2;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value2 + MOZ + value2 + MS + value2 + value2;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value2 + MS + value2 + value2;
    // order
    case 6165:
      return WEBKIT + value2 + MS + "flex-" + value2 + value2;
    // align-items
    case 5187:
      return WEBKIT + value2 + replace(value2, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value2;
    // align-self
    case 5443:
      return WEBKIT + value2 + MS + "flex-item-" + replace(value2, /flex-|-self/, "") + value2;
    // align-content
    case 4675:
      return WEBKIT + value2 + MS + "flex-line-pack" + replace(value2, /align-content|flex-|-self/, "") + value2;
    // flex-shrink
    case 5548:
      return WEBKIT + value2 + MS + replace(value2, "shrink", "negative") + value2;
    // flex-basis
    case 5292:
      return WEBKIT + value2 + MS + replace(value2, "basis", "preferred-size") + value2;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value2, "-grow", "") + WEBKIT + value2 + MS + replace(value2, "grow", "positive") + value2;
    // transition
    case 4554:
      return WEBKIT + replace(value2, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value2;
    // cursor
    case 6187:
      return replace(replace(replace(value2, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value2, "") + value2;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value2, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value2, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value2 + value2;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value2, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value2;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value2) - 1 - length2 > 6) switch (charat(value2, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value2, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value2, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value2, length2 + 3) == 108 ? "$3" : "$2-$3")) + value2;
        // (s)tretch
        case 115:
          return ~indexof(value2, "stretch") ? prefix(replace(value2, "stretch", "fill-available"), length2) + value2 : value2;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value2, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value2, strlen(value2) - 3 - (~indexof(value2, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value2, ":", ":" + WEBKIT) + value2;
        // (inline-)?fl(e)x
        case 101:
          return replace(value2, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value2, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value2;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value2, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb") + value2;
        // vertical-r(l)
        case 108:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb-rl") + value2;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "lr") + value2;
      }
      return WEBKIT + value2 + MS + value2 + value2;
  }
  return value2;
}
var prefixer = function prefixer2(element2, index2, children2, callback) {
  if (element2.length > -1) {
    if (!element2["return"]) switch (element2.type) {
      case DECLARATION:
        element2["return"] = prefix(element2.value, element2.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element2, {
          value: replace(element2.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element2.length) return combine(element2.props, function(value2) {
          switch (match(value2, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize([copy(element2, {
                props: [replace(value2, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize([copy(element2, {
                props: [replace(value2, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element2, {
                props: [replace(value2, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element2, {
                props: [replace(value2, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key2 = options.key;
  if (key2 === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key2 + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$3, rulesheet(function(rule2) {
      currentSheet.insert(rule2);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile$1(styles), serializer);
    };
    _insert = function insert2(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key: key2,
    sheet: new StyleSheet({
      key: key2,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
var reactIs$1 = { exports: {} };
var reactIs_development$1 = {};
var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
  if (hasRequiredReactIs_development$1) return reactIs_development$1;
  hasRequiredReactIs_development$1 = 1;
  /** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    (function() {
      var hasSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type2) {
        return typeof type2 === "string" || typeof type2 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 === "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object2) {
        if (typeof object2 === "object" && object2 !== null) {
          var $$typeof = object2.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type2 = object2.type;
              switch (type2) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type2;
                default:
                  var $$typeofType = type2 && type2.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return void 0;
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal3 = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense2 = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      function isAsyncMode(object2) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
          }
        }
        return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object2) {
        return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object2) {
        return typeOf(object2) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object2) {
        return typeOf(object2) === REACT_PROVIDER_TYPE;
      }
      function isElement(object2) {
        return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object2) {
        return typeOf(object2) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object2) {
        return typeOf(object2) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object2) {
        return typeOf(object2) === REACT_LAZY_TYPE;
      }
      function isMemo(object2) {
        return typeOf(object2) === REACT_MEMO_TYPE;
      }
      function isPortal(object2) {
        return typeOf(object2) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object2) {
        return typeOf(object2) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object2) {
        return typeOf(object2) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object2) {
        return typeOf(object2) === REACT_SUSPENSE_TYPE;
      }
      reactIs_development$1.AsyncMode = AsyncMode;
      reactIs_development$1.ConcurrentMode = ConcurrentMode;
      reactIs_development$1.ContextConsumer = ContextConsumer;
      reactIs_development$1.ContextProvider = ContextProvider;
      reactIs_development$1.Element = Element;
      reactIs_development$1.ForwardRef = ForwardRef;
      reactIs_development$1.Fragment = Fragment;
      reactIs_development$1.Lazy = Lazy;
      reactIs_development$1.Memo = Memo;
      reactIs_development$1.Portal = Portal3;
      reactIs_development$1.Profiler = Profiler;
      reactIs_development$1.StrictMode = StrictMode;
      reactIs_development$1.Suspense = Suspense2;
      reactIs_development$1.isAsyncMode = isAsyncMode;
      reactIs_development$1.isConcurrentMode = isConcurrentMode;
      reactIs_development$1.isContextConsumer = isContextConsumer;
      reactIs_development$1.isContextProvider = isContextProvider;
      reactIs_development$1.isElement = isElement;
      reactIs_development$1.isForwardRef = isForwardRef;
      reactIs_development$1.isFragment = isFragment;
      reactIs_development$1.isLazy = isLazy;
      reactIs_development$1.isMemo = isMemo;
      reactIs_development$1.isPortal = isPortal;
      reactIs_development$1.isProfiler = isProfiler;
      reactIs_development$1.isStrictMode = isStrictMode;
      reactIs_development$1.isSuspense = isSuspense;
      reactIs_development$1.isValidElementType = isValidElementType;
      reactIs_development$1.typeOf = typeOf;
    })();
  }
  return reactIs_development$1;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  {
    reactIs$1.exports = requireReactIs_development$1();
  }
  return reactIs$1.exports;
}
var hoistNonReactStatics_cjs;
var hasRequiredHoistNonReactStatics_cjs;
function requireHoistNonReactStatics_cjs() {
  if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
  hasRequiredHoistNonReactStatics_cjs = 1;
  var reactIs2 = requireReactIs$1();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs2.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty2 = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys2 = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i = 0; i < keys2.length; ++i) {
        var key2 = keys2[i];
        if (!KNOWN_STATICS[key2] && !(blacklist && blacklist[key2]) && !(sourceStatics && sourceStatics[key2]) && !(targetStatics && targetStatics[key2])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key2);
          try {
            defineProperty2(targetComponent, key2, descriptor);
          } catch (e3) {
          }
        }
      }
    }
    return targetComponent;
  }
  hoistNonReactStatics_cjs = hoistNonReactStatics;
  return hoistNonReactStatics_cjs;
}
requireHoistNonReactStatics_cjs();
var isBrowser$1 = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current2 = serialized;
    do {
      cache2.insert(serialized === current2 ? "." + className : "", current2, cache2.sheet, true);
      current2 = current2.next;
    } while (current2 !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h2 = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property2) {
  return property2.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value2) {
  return value2 != null && typeof value2 !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key2, value2) {
  switch (key2) {
    case "animation":
    case "animationName": {
      if (typeof value2 === "string") {
        return value2.replace(animationRegex, function(match2, p1, p2) {
          cursor$1 = {
            name: p1,
            styles: p2,
            next: cursor$1
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key2] !== 1 && !isCustomProperty(key2) && typeof value2 === "number" && value2 !== 0) {
    return value2 + "px";
  }
  return value2;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes = interpolation;
      if (keyframes.anim === 1) {
        cursor$1 = {
          name: keyframes.name,
          styles: keyframes.styles,
          next: cursor$1
        };
        return keyframes.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor$1 = {
              name: next2.name,
              styles: next2.styles,
              next: cursor$1
            };
            next2 = next2.next;
          }
        }
        var styles = serializedStyles.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor$1;
        var result = interpolation(mergedProps);
        cursor$1 = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key2 in obj) {
      var value2 = obj[key2];
      if (typeof value2 !== "object") {
        var asString = value2;
        if (registered != null && registered[asString] !== void 0) {
          string2 += key2 + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string2 += processStyleName(key2) + ":" + processStyleValue(key2, asString) + ";";
        }
      } else {
        if (Array.isArray(value2) && typeof value2[0] === "string" && (registered == null || registered[value2[0]] === void 0)) {
          for (var _i = 0; _i < value2.length; _i++) {
            if (isProcessableValue(value2[_i])) {
              string2 += processStyleName(key2) + ":" + processStyleValue(key2, value2[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value2);
          switch (key2) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(key2) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += key2 + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor$1;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor$1 = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles) + identifierName;
  return {
    name,
    styles,
    next: cursor$1
  };
}
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || React$1.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ React$1.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var __unsafe_useEmotionCache = function useEmotionCache() {
  return useContext(EmotionCacheContext);
};
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ forwardRef(function(props, ref2) {
    var cache2 = useContext(EmotionCacheContext);
    return func(props, cache2, ref2);
  });
};
var ThemeContext = /* @__PURE__ */ React$1.createContext({});
var hasOwn$1 = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type2, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn$1.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type2;
  return newProps;
};
var Insertion = function Insertion2(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache2, ref2) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
    cssProp = cache2.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React$1.useContext(ThemeContext));
  className += cache2.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn$1.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref2) {
    newProps.ref = ref2;
  }
  return /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement(Insertion, {
    cache: cache2,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ React$1.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type2, props) {
  var args = arguments;
  if (props == null || !hasOwn$1.call(props, "css")) {
    return React$1.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type2, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return React$1.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles = props.styles;
  var serialized = serializeStyles([styles], void 0, React$1.useContext(ThemeContext));
  var sheetRef = React$1.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key2 = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key: key2,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key2 + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key2);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element2 = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element2;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
const objectFromEntries = !Object.fromEntries ? (entries2) => {
  if (!entries2 || !entries2[Symbol.iterator]) {
    throw new Error("Object.fromEntries() requires a single iterable argument");
  }
  const o = {};
  Object.keys(entries2).forEach((key2) => {
    const [k, v] = entries2[key2];
    o[k] = v;
  });
  return o;
} : Object.fromEntries;
function objectKeys(o) {
  return Object.keys(o);
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
function typeGuard(_value, isMatched) {
  return isMatched;
}
const classnames = (args) => {
  const len = args.length;
  let i = 0;
  let cls = "";
  for (; i < len; i++) {
    const arg = args[i];
    if (arg == null)
      continue;
    let toAdd;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames(arg);
        } else {
          assert(!typeGuard(arg, false));
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (const k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function useGuaranteedMemo(fn, deps) {
  var _a;
  const ref2 = useRef();
  if (!ref2.current || deps.length !== ((_a = ref2.current.prevDeps) === null || _a === void 0 ? void 0 : _a.length) || ref2.current.prevDeps.map((v, i) => v === deps[i]).indexOf(false) >= 0) {
    ref2.current = {
      "v": fn(),
      "prevDeps": [...deps]
    };
  }
  return ref2.current.v;
}
function matchCSSObject(arg) {
  return arg instanceof Object && !("styles" in arg) && !("length" in arg) && !("__emotion_styles" in arg);
}
const { createCssAndCx } = /* @__PURE__ */ (() => {
  function merge2(registered, css2, className) {
    const registeredStyles = [];
    const rawClassName = getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css2(registeredStyles);
  }
  function createCssAndCx2(params2) {
    const { cache: cache2 } = params2;
    const css2 = (...args) => {
      const serialized = serializeStyles(args, cache2.registered);
      insertStyles(cache2, serialized, false);
      const className = `${cache2.key}-${serialized.name}`;
      scope: {
        const arg = args[0];
        if (!matchCSSObject(arg)) {
          break scope;
        }
        increaseSpecificityToTakePrecedenceOverMediaQueries.saveClassNameCSSObjectMapping(cache2, className, arg);
      }
      return className;
    };
    const cx = (...args) => {
      const className = classnames(args);
      const feat27FixedClassnames = increaseSpecificityToTakePrecedenceOverMediaQueries.fixClassName(cache2, className, css2);
      return merge2(cache2.registered, css2, feat27FixedClassnames);
    };
    return { css: css2, cx };
  }
  return { createCssAndCx: createCssAndCx2 };
})();
function createUseCssAndCx(params2) {
  const { useCache } = params2;
  function useCssAndCx() {
    const cache2 = useCache();
    const { css: css2, cx } = useGuaranteedMemo(() => createCssAndCx({ cache: cache2 }), [cache2]);
    return { css: css2, cx };
  }
  return { useCssAndCx };
}
const increaseSpecificityToTakePrecedenceOverMediaQueries = /* @__PURE__ */ (() => {
  const cssObjectMapByCache = /* @__PURE__ */ new WeakMap();
  return {
    "saveClassNameCSSObjectMapping": (cache2, className, cssObject) => {
      let cssObjectMap = cssObjectMapByCache.get(cache2);
      if (cssObjectMap === void 0) {
        cssObjectMap = /* @__PURE__ */ new Map();
        cssObjectMapByCache.set(cache2, cssObjectMap);
      }
      cssObjectMap.set(className, cssObject);
    },
    "fixClassName": /* @__PURE__ */ (() => {
      function fix(classNameCSSObjects) {
        let isThereAnyMediaQueriesInPreviousClasses = false;
        return classNameCSSObjects.map(([className, cssObject]) => {
          if (cssObject === void 0) {
            return className;
          }
          let out;
          if (!isThereAnyMediaQueriesInPreviousClasses) {
            out = className;
            for (const key2 in cssObject) {
              if (key2.startsWith("@media")) {
                isThereAnyMediaQueriesInPreviousClasses = true;
                break;
              }
            }
          } else {
            out = {
              "&&": cssObject
            };
          }
          return out;
        });
      }
      return (cache2, className, css2) => {
        const cssObjectMap = cssObjectMapByCache.get(cache2);
        return classnames(fix(className.split(" ").map((className2) => [
          className2,
          cssObjectMap === null || cssObjectMap === void 0 ? void 0 : cssObjectMap.get(className2)
        ])).map((classNameOrCSSObject) => typeof classNameOrCSSObject === "string" ? classNameOrCSSObject : css2(classNameOrCSSObject)));
      };
    })()
  };
})();
function getDependencyArrayRef(obj) {
  if (!(obj instanceof Object) || typeof obj === "function") {
    return obj;
  }
  const arr = [];
  for (const key2 in obj) {
    const value2 = obj[key2];
    const typeofValue = typeof value2;
    if (!(typeofValue === "string" || typeofValue === "number" && !isNaN(value2) || typeofValue === "boolean" || value2 === void 0 || value2 === null)) {
      return obj;
    }
    arr.push(`${key2}:${typeofValue}_${value2}`);
  }
  return "xSqLiJdLMd9s" + arr.join("|");
}
function mergeClasses(classesFromUseStyles, classesOverrides, cx) {
  if (!(classesOverrides instanceof Object)) {
    return classesFromUseStyles;
  }
  const out = {};
  objectKeys(classesFromUseStyles).forEach((ruleName) => out[ruleName] = cx(classesFromUseStyles[ruleName], classesOverrides[ruleName]));
  objectKeys(classesOverrides).forEach((ruleName) => {
    if (ruleName in classesFromUseStyles) {
      return;
    }
    const className = classesOverrides[ruleName];
    if (typeof className !== "string") {
      return;
    }
    out[ruleName] = className;
  });
  return out;
}
const useMuiThemeStyleOverridesPlugin = ({ classes, theme, muiStyleOverridesParams, css: css2, cx, name }) => {
  var _a, _b;
  require_named: {
    if (name === "makeStyle no name") {
      name = void 0;
      break require_named;
    }
    if (muiStyleOverridesParams !== void 0 && name === void 0) {
      throw new Error("To use muiStyleOverridesParams, you must specify a name using .withName('MyComponent')");
    }
  }
  let styleOverrides = void 0;
  try {
    styleOverrides = name === void 0 ? void 0 : ((_b = (_a = theme.components) === null || _a === void 0 ? void 0 : _a[
      name
      /*example*/
    ]) === null || _b === void 0 ? void 0 : _b.styleOverrides) || void 0;
  } catch (_c2) {
  }
  const classesFromThemeStyleOverrides = useMemo(() => {
    if (styleOverrides === void 0) {
      return void 0;
    }
    const themeClasses = {};
    for (const ruleName in styleOverrides) {
      const cssObjectOrGetCssObject = styleOverrides[ruleName];
      if (!(cssObjectOrGetCssObject instanceof Object)) {
        continue;
      }
      themeClasses[ruleName] = css2(typeof cssObjectOrGetCssObject === "function" ? cssObjectOrGetCssObject({
        theme,
        "ownerState": muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.ownerState,
        ...muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.props
      }) : cssObjectOrGetCssObject);
    }
    return themeClasses;
  }, [
    styleOverrides,
    getDependencyArrayRef(muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.props),
    getDependencyArrayRef(muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.ownerState),
    css2
  ]);
  classes = useMemo(() => mergeClasses(classes, classesFromThemeStyleOverrides, cx), [classes, classesFromThemeStyleOverrides, cx]);
  return { classes };
};
const useContextualCache = __unsafe_useEmotionCache;
let counter$1 = 0;
function createMakeStyles(params2) {
  const { useTheme: useTheme2, cache: cacheProvidedAtInception } = params2;
  const { useCache } = createUseCache({ cacheProvidedAtInception });
  const { useCssAndCx } = createUseCssAndCx({ useCache });
  function makeStyles2(params3) {
    const { name: nameOrWrappedName, uniqId = `${counter$1++}` } = params3 !== null && params3 !== void 0 ? params3 : {};
    const name = typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0];
    return function(cssObjectByRuleNameOrGetCssObjectByRuleName) {
      const getCssObjectByRuleName = typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? cssObjectByRuleNameOrGetCssObjectByRuleName : () => cssObjectByRuleNameOrGetCssObjectByRuleName;
      return function useStyles3(params4, muiStyleOverridesParams) {
        const theme = useTheme2();
        let { css: css2, cx } = useCssAndCx();
        const cache2 = useCache();
        let classes = useMemo(() => {
          const refClassesCache = {};
          const refClasses = typeof Proxy !== "undefined" && new Proxy({}, {
            "get": (_target, propertyKey) => {
              if (typeof propertyKey === "symbol") {
                assert(false);
              }
              return refClassesCache[propertyKey] = `${cache2.key}-${uniqId}${name !== void 0 ? `-${name}` : ""}-${propertyKey}-ref`;
            }
          });
          const cssObjectByRuleName = getCssObjectByRuleName(theme, params4, refClasses || {});
          const classes2 = objectFromEntries(objectKeys(cssObjectByRuleName).map((ruleName) => {
            const cssObject = cssObjectByRuleName[ruleName];
            if (!cssObject.label) {
              cssObject.label = `${name !== void 0 ? `${name}-` : ""}${ruleName}`;
            }
            return [
              ruleName,
              `${css2(cssObject)}${typeGuard(ruleName, ruleName in refClassesCache) ? ` ${refClassesCache[ruleName]}` : ""}`
            ];
          }));
          objectKeys(refClassesCache).forEach((ruleName) => {
            if (ruleName in classes2) {
              return;
            }
            classes2[ruleName] = refClassesCache[ruleName];
          });
          return classes2;
        }, [cache2, css2, cx, theme, getDependencyArrayRef(params4)]);
        {
          const propsClasses = muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.props.classes;
          classes = useMemo(() => mergeClasses(classes, propsClasses, cx), [classes, getDependencyArrayRef(propsClasses), cx]);
        }
        {
          const pluginResultWrap = useMuiThemeStyleOverridesPlugin({
            classes,
            css: css2,
            cx,
            "name": name !== null && name !== void 0 ? name : "makeStyle no name",
            muiStyleOverridesParams,
            // NOTE: If it's not a Mui Theme the plugin is resilient, it will not crash
            "theme": theme
          });
          if (pluginResultWrap.classes !== void 0) {
            classes = pluginResultWrap.classes;
          }
          if (pluginResultWrap.css !== void 0) {
            css2 = pluginResultWrap.css;
          }
          if (pluginResultWrap.cx !== void 0) {
            cx = pluginResultWrap.cx;
          }
        }
        return {
          classes,
          theme,
          css: css2,
          cx
        };
      };
    };
  }
  function useStyles2() {
    const theme = useTheme2();
    const { css: css2, cx } = useCssAndCx();
    return { theme, css: css2, cx };
  }
  return { makeStyles: makeStyles2, useStyles: useStyles2 };
}
const reactContext = createContext(void 0);
const { createUseCache } = /* @__PURE__ */ (() => {
  function useCacheProvidedByProvider() {
    const cacheExplicitlyProvidedForTss = useContext(reactContext);
    return cacheExplicitlyProvidedForTss;
  }
  function createUseCache2(params2) {
    const { cacheProvidedAtInception } = params2;
    function useCache() {
      var _a;
      const contextualCache = useContextualCache();
      const cacheExplicitlyProvidedForTss = useCacheProvidedByProvider();
      const cacheToBeUsed = (_a = cacheProvidedAtInception !== null && cacheProvidedAtInception !== void 0 ? cacheProvidedAtInception : cacheExplicitlyProvidedForTss) !== null && _a !== void 0 ? _a : contextualCache;
      if (cacheToBeUsed === null) {
        throw new Error([
          "In order to get SSR working with tss-react you need to explicitly provide an Emotion cache.",
          "MUI users be aware: This is not an error strictly related to tss-react, with or without tss-react,",
          "MUI needs an Emotion cache to be provided for SSR to work.",
          "Here is the MUI documentation related to SSR setup: https://mui.com/material-ui/guides/server-rendering/",
          "TSS provides helper that makes the process of setting up SSR easier: https://docs.tss-react.dev/ssr"
        ].join("\n"));
      }
      return cacheToBeUsed;
    }
    return { useCache };
  }
  return { createUseCache: createUseCache2 };
})();
function capitalize$2(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function createWithStyles(params2) {
  const { useTheme: useTheme2, cache: cache2 } = params2;
  const { makeStyles: makeStyles2 } = createMakeStyles({ useTheme: useTheme2, cache: cache2 });
  function withStyles(Component, cssObjectByRuleNameOrGetCssObjectByRuleName, params3) {
    const Component_ = typeof Component === "string" ? (() => {
      const tag = Component;
      const Out2 = function({ children: children2, ...props }) {
        return createElement(tag, props, children2);
      };
      Object.defineProperty(Out2, "name", {
        "value": capitalize$2(tag)
      });
      return Out2;
    })() : Component;
    const name = (() => {
      {
        const { name: nameOrWrappedName } = params3 !== null && params3 !== void 0 ? params3 : {};
        if (nameOrWrappedName !== void 0) {
          return typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0];
        }
      }
      let name2 = void 0;
      displayName: {
        const displayName = Component_.displayName;
        if (typeof displayName !== "string" || displayName === "") {
          break displayName;
        }
        name2 = displayName;
      }
      functionName: {
        if (name2 !== void 0) {
          break functionName;
        }
        const functionName = Component_.name;
        if (typeof functionName !== "string" || functionName === "") {
          break functionName;
        }
        name2 = functionName;
      }
      if (name2 === void 0) {
        return void 0;
      }
      name2 = name2.replace(/\$/g, "usd");
      name2 = name2.replace(/\(/g, "_").replace(/\)/g, "_");
      name2 = name2.replace(/[^a-zA-Z0-9-_]/g, "_");
      return name2;
    })();
    const useStyles2 = makeStyles2({ ...params3, name })(typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? (theme, props, classes) => incorporateMediaQueries(cssObjectByRuleNameOrGetCssObjectByRuleName(theme, props, classes)) : incorporateMediaQueries(cssObjectByRuleNameOrGetCssObjectByRuleName));
    function getHasNonRootClasses(classes) {
      for (const name2 in classes) {
        if (name2 === "root") {
          continue;
        }
        return true;
      }
      return false;
    }
    const Out = forwardRef(function(props, ref2) {
      const { className, classes: _classes, ...rest } = props;
      const { classes, cx } = useStyles2(props, { props });
      const rootClassName = cx(classes.root, className);
      fixedClassesByClasses.set(classes, {
        ...classes,
        "root": rootClassName
      });
      return React__default.createElement(Component_, { ref: ref2, className: getHasNonRootClasses(classes) ? className : rootClassName, ...typeof Component === "string" ? {} : { classes }, ...rest });
    });
    if (name !== void 0) {
      Out.displayName = `${capitalize$2(name)}WithStyles`;
      Object.defineProperty(Out, "name", { "value": Out.displayName });
    }
    return Out;
  }
  withStyles.getClasses = getClasses;
  return { withStyles };
}
const fixedClassesByClasses = /* @__PURE__ */ new WeakMap();
const errorMessageGetClasses = "getClasses should only be used in conjunction with withStyles";
function getClasses(props) {
  const classesIn = props.classes;
  if (classesIn === void 0) {
    throw new Error(errorMessageGetClasses);
  }
  const classes = fixedClassesByClasses.get(classesIn);
  if (classes === void 0) {
    throw new Error(errorMessageGetClasses);
  }
  return classes;
}
function incorporateMediaQueries(cssObjectByRuleNameWithMediaQueries) {
  const cssObjectByRuleName = {};
  const cssObjectByRuleNameWithMediaQueriesByMediaQuery = {};
  Object.keys(cssObjectByRuleNameWithMediaQueries).forEach((ruleNameOrMediaQuery) => (ruleNameOrMediaQuery.startsWith("@media") ? cssObjectByRuleNameWithMediaQueriesByMediaQuery : cssObjectByRuleName)[ruleNameOrMediaQuery] = cssObjectByRuleNameWithMediaQueries[ruleNameOrMediaQuery]);
  Object.keys(cssObjectByRuleNameWithMediaQueriesByMediaQuery).forEach((mediaQuery) => {
    const cssObjectByRuleNameBis = cssObjectByRuleNameWithMediaQueriesByMediaQuery[mediaQuery];
    Object.keys(cssObjectByRuleNameBis).forEach((ruleName) => {
      var _a;
      return cssObjectByRuleName[ruleName] = {
        ...(_a = cssObjectByRuleName[ruleName]) !== null && _a !== void 0 ? _a : {},
        [mediaQuery]: cssObjectByRuleNameBis[ruleName]
      };
    });
  });
  return cssObjectByRuleName;
}
const isSSR = (() => {
  const isBrowser2 = typeof document === "object" && typeof (document === null || document === void 0 ? void 0 : document.getElementById) === "function";
  const isJest = typeof jest !== "undefined";
  const isMocha = typeof mocha !== "undefined";
  const isVitest = typeof __vitest_worker__ !== "undefined";
  return !isBrowser2 && !isJest && !isMocha && !isVitest;
})();
function createTss(params2) {
  counter = 0;
  nestedSelectorUsageTrackRecord.splice(0, nestedSelectorUsageTrackRecord.length);
  const { useContext: useContext3, usePlugin, cache: cacheProvidedAtInception } = params2;
  const { useCache } = createUseCache({ cacheProvidedAtInception });
  const { useCssAndCx } = createUseCssAndCx({ useCache });
  const usePluginDefault = ({ classes, cx, css: css2 }) => ({ classes, cx, css: css2 });
  const tss2 = createTss_internal({
    useContext: useContext3,
    useCache,
    useCssAndCx,
    "usePlugin": usePlugin !== null && usePlugin !== void 0 ? usePlugin : usePluginDefault,
    "name": void 0,
    "doesUseNestedSelectors": false
  });
  return { tss: tss2 };
}
let counter = 0;
const nestedSelectorUsageTrackRecord = [];
function createTss_internal(params2) {
  const { useContext: useContext3, useCache, useCssAndCx, usePlugin, name, doesUseNestedSelectors } = params2;
  return {
    "withParams": () => createTss_internal({ ...params2 }),
    "withName": (nameOrWrappedName) => createTss_internal({
      ...params2,
      "name": typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0]
    }),
    "withNestedSelectors": () => createTss_internal({
      ...params2,
      "doesUseNestedSelectors": true
    }),
    "create": (cssObjectByRuleNameOrGetCssObjectByRuleName) => {
      const idOfUseStyles = `x${counter++}`;
      if (name !== void 0) {
        while (true) {
          const wrap2 = nestedSelectorUsageTrackRecord.find((wrap3) => wrap3.name === name);
          if (wrap2 === void 0) {
            break;
          }
          nestedSelectorUsageTrackRecord.splice(nestedSelectorUsageTrackRecord.indexOf(wrap2), 1);
        }
      }
      const getCssObjectByRuleName = typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? cssObjectByRuleNameOrGetCssObjectByRuleName : () => cssObjectByRuleNameOrGetCssObjectByRuleName;
      return function useStyles2(params3) {
        var _a, _b, _c2;
        const { classesOverrides, ...paramsAndPluginParams } = params3 !== null && params3 !== void 0 ? params3 : {};
        const context2 = useContext3();
        const { css: css2, cx } = useCssAndCx();
        const cache2 = useCache();
        const getClasses2 = () => {
          const refClassesCache = {};
          const cssObjectByRuleName = getCssObjectByRuleName({
            ...params3,
            ...context2,
            ...!doesUseNestedSelectors ? {} : {
              "classes": typeof Proxy === "undefined" ? {} : new Proxy({}, {
                "get": (_target, ruleName) => {
                  if (typeof ruleName === "symbol") {
                    assert(false);
                  }
                  if (isSSR && name === void 0) {
                    throw new Error([
                      `tss-react: In SSR setups, in order to use nested selectors, you must also give a unique name to the useStyle function.`,
                      `Solution: Use tss.withName("ComponentName").withNestedSelectors<...>()... to set a name.`
                    ].join("\n"));
                  }
                  update_nested_selector_usage_track_record: {
                    if (name === void 0) {
                      break update_nested_selector_usage_track_record;
                    }
                    let wrap2 = nestedSelectorUsageTrackRecord.find((wrap3) => wrap3.name === name && wrap3.idOfUseStyles === idOfUseStyles);
                    if (wrap2 === void 0) {
                      wrap2 = { name, idOfUseStyles, "nestedSelectorRuleNames": /* @__PURE__ */ new Set() };
                      nestedSelectorUsageTrackRecord.push(wrap2);
                    }
                    wrap2.nestedSelectorRuleNames.add(ruleName);
                  }
                  detect_potential_conflicts: {
                    if (name === void 0) {
                      break detect_potential_conflicts;
                    }
                    const hasPotentialConflict = nestedSelectorUsageTrackRecord.find((wrap2) => wrap2.name === name && wrap2.idOfUseStyles !== idOfUseStyles && wrap2.nestedSelectorRuleNames.has(ruleName)) !== void 0;
                    if (!hasPotentialConflict) {
                      break detect_potential_conflicts;
                    }
                    throw new Error([
                      `tss-react: There are in your codebase two different useStyles named "${name}" that`,
                      `both use use the nested selector ${ruleName}.
`,
                      `This may lead to CSS class name collisions, causing nested selectors to target elements outside of the intended scope.
`,
                      `Solution: Ensure each useStyles using nested selectors has a unique name.
`,
                      `Use: tss.withName("UniqueName").withNestedSelectors<...>()...`
                    ].join(" "));
                  }
                  return refClassesCache[ruleName] = `${cache2.key}-${name !== void 0 ? name : idOfUseStyles}-${ruleName}-ref`;
                }
              })
            }
          });
          let classes2 = objectFromEntries(objectKeys(cssObjectByRuleName).map((ruleName) => {
            const cssObject = cssObjectByRuleName[ruleName];
            if (!cssObject.label) {
              cssObject.label = `${name !== void 0 ? `${name}-` : ""}${ruleName}`;
            }
            return [
              ruleName,
              `${css2(cssObject)}${typeGuard(ruleName, ruleName in refClassesCache) ? ` ${refClassesCache[ruleName]}` : ""}`
            ];
          }));
          objectKeys(refClassesCache).forEach((ruleName) => {
            if (ruleName in classes2) {
              return;
            }
            classes2[ruleName] = refClassesCache[ruleName];
          });
          classes2 = mergeClasses(classes2, classesOverrides, cx);
          return classes2;
        };
        const classes = runGetClassesOrUseCache({
          cache: cache2,
          cssObjectByRuleNameOrGetCssObjectByRuleName,
          "classesOverridesRef": getDependencyArrayRef(classesOverrides),
          "paramsAndPluginParamsRef": getDependencyArrayRef(paramsAndPluginParams),
          idOfUseStyles,
          context: context2,
          getClasses: getClasses2
        });
        const pluginResultWrap = usePlugin({
          classes,
          css: css2,
          cx,
          idOfUseStyles,
          name,
          ...context2,
          ...paramsAndPluginParams
        });
        return {
          "classes": (_a = pluginResultWrap.classes) !== null && _a !== void 0 ? _a : classes,
          "css": (_b = pluginResultWrap.css) !== null && _b !== void 0 ? _b : css2,
          "cx": (_c2 = pluginResultWrap.cx) !== null && _c2 !== void 0 ? _c2 : cx,
          ...context2
        };
      };
    }
  };
}
const mapCache = /* @__PURE__ */ new WeakMap();
function runGetClassesOrUseCache(params2) {
  const { cache: cache2, cssObjectByRuleNameOrGetCssObjectByRuleName, classesOverridesRef, paramsAndPluginParamsRef, idOfUseStyles, context: context2, getClasses: getClasses2 } = params2;
  use_cache: {
    const mapCache_in = mapCache.get(cache2);
    if (mapCache_in === void 0) {
      break use_cache;
    }
    const mapCache_in_in = mapCache_in.get(cssObjectByRuleNameOrGetCssObjectByRuleName);
    if (mapCache_in_in === void 0) {
      break use_cache;
    }
    const mapCache_in_in_in = mapCache_in_in.get(classesOverridesRef);
    if (mapCache_in_in_in === void 0) {
      break use_cache;
    }
    const arr = mapCache_in_in_in.get(paramsAndPluginParamsRef);
    if (arr === void 0) {
      break use_cache;
    }
    const entry2 = arr.find(({ context: context_i }) => {
      if (context_i === context2) {
        return true;
      }
      if (objectKeys(context_i).length !== objectKeys(context2).length) {
        return false;
      }
      for (const key2 in context_i) {
        if (getDependencyArrayRef(context_i[key2]) !== getDependencyArrayRef(context2[key2])) {
          return false;
        }
      }
      return true;
    });
    if (entry2 === void 0) {
      break use_cache;
    }
    if ((entry2 === null || entry2 === void 0 ? void 0 : entry2.idOfUseStyles) !== idOfUseStyles) {
      arr.splice(arr.indexOf(entry2), 1);
      break use_cache;
    }
    return entry2.result;
  }
  const result = getClasses2();
  {
    if (!mapCache.has(cache2)) {
      mapCache.set(cache2, /* @__PURE__ */ new WeakMap());
    }
    const mapCache_in = mapCache.get(cache2);
    assert(mapCache_in !== void 0);
    if (!mapCache_in.has(cssObjectByRuleNameOrGetCssObjectByRuleName)) {
      mapCache_in.set(cssObjectByRuleNameOrGetCssObjectByRuleName, /* @__PURE__ */ new Map());
    }
    const mapCache_in_in = mapCache_in.get(cssObjectByRuleNameOrGetCssObjectByRuleName);
    assert(mapCache_in_in !== void 0);
    if (!mapCache_in_in.has(classesOverridesRef)) {
      if (mapCache_in_in.size > 200) {
        mapCache_in_in.clear();
      }
      mapCache_in_in.set(classesOverridesRef, /* @__PURE__ */ new Map());
    }
    const mapCache_in_in_in = mapCache_in_in.get(classesOverridesRef);
    assert(mapCache_in_in_in !== void 0);
    if (!mapCache_in_in_in.has(paramsAndPluginParamsRef)) {
      clear_cache: {
        const threshold2 = typeof paramsAndPluginParamsRef === "string" ? 257 : 5;
        if (mapCache_in_in_in.size < threshold2) {
          break clear_cache;
        }
        mapCache_in_in_in.clear();
      }
      mapCache_in_in_in.set(paramsAndPluginParamsRef, []);
    }
    let arr = mapCache_in_in_in.get(paramsAndPluginParamsRef);
    assert(arr !== void 0);
    if (arr.length > 5) {
      arr = [];
    }
    arr.push({ idOfUseStyles, context: context2, result });
  }
  return result;
}
function GlobalStyles(props) {
  const { styles } = props;
  return React__default.createElement(Global, { styles: css(styles) });
}
function createMakeAndWithStyles(params2) {
  return {
    ...createMakeStyles(params2),
    ...createWithStyles(params2)
  };
}
const { tss: tss$1 } = createTss({
  "useContext": () => ({})
});
tss$1.create({});
const THEME_ID = "$$material";
var propTypes = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target2, source2) {
    var from2;
    var to = toObject(target2);
    var symbols2;
    for (var s = 1; s < arguments.length; s++) {
      from2 = Object(arguments[s]);
      for (var key2 in from2) {
        if (hasOwnProperty2.call(from2, key2)) {
          to[key2] = from2[key2];
        }
      }
      if (getOwnPropertySymbols) {
        symbols2 = getOwnPropertySymbols(from2);
        for (var i = 0; i < symbols2.length; i++) {
          if (propIsEnumerable.call(from2, symbols2[i])) {
            to[symbols2[i]] = from2[symbols2[i]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var has;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas) return has;
  hasRequiredHas = 1;
  has = Function.call.bind(Object.prototype.hasOwnProperty);
  return has;
}
var checkPropTypes_1;
var hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes) return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var printWarning = function() {
  };
  {
    var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
    var loggedTypeFailures = {};
    var has2 = /* @__PURE__ */ requireHas();
    printWarning = function(text2) {
      var message = "Warning: " + text2;
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x2) {
      }
    };
  }
  function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
    {
      for (var typeSpecName in typeSpecs) {
        if (has2(typeSpecs, typeSpecName)) {
          var error2;
          try {
            if (typeof typeSpecs[typeSpecName] !== "function") {
              var err = Error(
                (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              err.name = "Invariant Violation";
              throw err;
            }
            error2 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error2 = ex;
          }
          if (error2 && !(error2 instanceof Error)) {
            printWarning(
              (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
            );
          }
          if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
            loggedTypeFailures[error2.message] = true;
            var stack2 = getStack ? getStack() : "";
            printWarning(
              "Failed " + location + " type: " + error2.message + (stack2 != null ? stack2 : "")
            );
          }
        }
      }
    }
  }
  checkPropTypes.resetWarningCache = function() {
    {
      loggedTypeFailures = {};
    }
  };
  checkPropTypes_1 = checkPropTypes;
  return checkPropTypes_1;
}
var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var ReactIs = requireReactIs$1();
  var assign2 = requireObjectAssign();
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  var has2 = /* @__PURE__ */ requireHas();
  var checkPropTypes = /* @__PURE__ */ requireCheckPropTypes();
  var printWarning = function() {
  };
  {
    printWarning = function(text2) {
      var message = "Warning: " + text2;
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x2) {
      }
    };
  }
  function emptyFunctionThatReturnsNull() {
    return null;
  }
  factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    var ANONYMOUS = "<<anonymous>>";
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker("array"),
      bigint: createPrimitiveTypeChecker("bigint"),
      bool: createPrimitiveTypeChecker("boolean"),
      func: createPrimitiveTypeChecker("function"),
      number: createPrimitiveTypeChecker("number"),
      object: createPrimitiveTypeChecker("object"),
      string: createPrimitiveTypeChecker("string"),
      symbol: createPrimitiveTypeChecker("symbol"),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };
    function is(x2, y2) {
      if (x2 === y2) {
        return x2 !== 0 || 1 / x2 === 1 / y2;
      } else {
        return x2 !== x2 && y2 !== y2;
      }
    }
    function PropTypeError(message, data2) {
      this.message = message;
      this.data = data2 && typeof data2 === "object" ? data2 : {};
      this.stack = "";
    }
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate2) {
      {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;
        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            var err = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            err.name = "Invariant Violation";
            throw err;
          } else if (typeof console !== "undefined") {
            var cacheKey = componentName + ":" + propName;
            if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3) {
              printWarning(
                "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
            }
            return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
          }
          return null;
        } else {
          return validate2(props, propName, componentName, location, propFullName);
        }
      }
      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
      function validate2(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          var preciseType = getPreciseType(propValue);
          return new PropTypeError(
            "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
            { expectedType }
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate2);
    }
    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
      function validate2(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
        }
        for (var i = 0; i < propValue.length; i++) {
          var error2 = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
          if (error2 instanceof Error) {
            return error2;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate2);
    }
    function createElementTypeChecker() {
      function validate2(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
        }
        return null;
      }
      return createChainableTypeChecker(validate2);
    }
    function createElementTypeTypeChecker() {
      function validate2(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!ReactIs.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return createChainableTypeChecker(validate2);
    }
    function createInstanceTypeChecker(expectedClass) {
      function validate2(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
        }
        return null;
      }
      return createChainableTypeChecker(validate2);
    }
    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        {
          if (arguments.length > 1) {
            printWarning(
              "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
            );
          } else {
            printWarning("Invalid argument supplied to oneOf, expected an array.");
          }
        }
        return emptyFunctionThatReturnsNull;
      }
      function validate2(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }
        var valuesString = JSON.stringify(expectedValues, function replacer2(key2, value2) {
          var type2 = getPreciseType(value2);
          if (type2 === "symbol") {
            return String(value2);
          }
          return value2;
        });
        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
      }
      return createChainableTypeChecker(validate2);
    }
    function createObjectOfTypeChecker(typeChecker) {
      function validate2(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
        }
        for (var key2 in propValue) {
          if (has2(propValue, key2)) {
            var error2 = typeChecker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
            if (error2 instanceof Error) {
              return error2;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate2);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        printWarning("Invalid argument supplied to oneOfType, expected an instance of array.");
        return emptyFunctionThatReturnsNull;
      }
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (typeof checker !== "function") {
          printWarning(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
          );
          return emptyFunctionThatReturnsNull;
        }
      }
      function validate2(props, propName, componentName, location, propFullName) {
        var expectedTypes = [];
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker2 = arrayOfTypeCheckers[i2];
          var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
          if (checkerResult == null) {
            return null;
          }
          if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
            expectedTypes.push(checkerResult.data.expectedType);
          }
        }
        var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
        return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
      }
      return createChainableTypeChecker(validate2);
    }
    function createNodeChecker() {
      function validate2(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
        }
        return null;
      }
      return createChainableTypeChecker(validate2);
    }
    function invalidValidatorError(componentName, location, propFullName, key2, type2) {
      return new PropTypeError(
        (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key2 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type2 + "`."
      );
    }
    function createShapeTypeChecker(shapeTypes) {
      function validate2(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        for (var key2 in shapeTypes) {
          var checker = shapeTypes[key2];
          if (typeof checker !== "function") {
            return invalidValidatorError(componentName, location, propFullName, key2, getPreciseType(checker));
          }
          var error2 = checker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
          if (error2) {
            return error2;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate2);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
      function validate2(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        var allKeys = assign2({}, props[propName], shapeTypes);
        for (var key2 in allKeys) {
          var checker = shapeTypes[key2];
          if (has2(shapeTypes, key2) && typeof checker !== "function") {
            return invalidValidatorError(componentName, location, propFullName, key2, getPreciseType(checker));
          }
          if (!checker) {
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` key `" + key2 + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
            );
          }
          var error2 = checker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
          if (error2) {
            return error2;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate2);
    }
    function isNode(propValue) {
      switch (typeof propValue) {
        case "number":
        case "string":
        case "undefined":
          return true;
        case "boolean":
          return !propValue;
        case "object":
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }
          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              while (!(step = iterator.next()).done) {
                var entry2 = step.value;
                if (entry2) {
                  if (!isNode(entry2[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }
          return true;
        default:
          return false;
      }
    }
    function isSymbol(propType, propValue) {
      if (propType === "symbol") {
        return true;
      }
      if (!propValue) {
        return false;
      }
      if (propValue["@@toStringTag"] === "Symbol") {
        return true;
      }
      if (typeof Symbol === "function" && propValue instanceof Symbol) {
        return true;
      }
      return false;
    }
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return "array";
      }
      if (propValue instanceof RegExp) {
        return "object";
      }
      if (isSymbol(propType, propValue)) {
        return "symbol";
      }
      return propType;
    }
    function getPreciseType(propValue) {
      if (typeof propValue === "undefined" || propValue === null) {
        return "" + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === "object") {
        if (propValue instanceof Date) {
          return "date";
        } else if (propValue instanceof RegExp) {
          return "regexp";
        }
      }
      return propType;
    }
    function getPostfixForTypeWarning(value2) {
      var type2 = getPreciseType(value2);
      switch (type2) {
        case "array":
        case "object":
          return "an " + type2;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + type2;
        default:
          return type2;
      }
    }
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithTypeCheckers;
}
var hasRequiredPropTypes;
function requirePropTypes() {
  if (hasRequiredPropTypes) return propTypes.exports;
  hasRequiredPropTypes = 1;
  {
    var ReactIs = requireReactIs$1();
    var throwOnDirectAccess = true;
    propTypes.exports = /* @__PURE__ */ requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
  }
  return propTypes.exports;
}
var propTypesExports = /* @__PURE__ */ requirePropTypes();
const _pt = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var reactIs = { exports: {} };
var reactIs_development = {};
var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development) return reactIs_development;
  hasRequiredReactIs_development = 1;
  /**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function() {
    function typeOf(object2) {
      if ("object" === typeof object2 && null !== object2) {
        var $$typeof = object2.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            switch (object2 = object2.type, object2) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
              case REACT_VIEW_TRANSITION_TYPE:
                return object2;
              default:
                switch (object2 = object2 && object2.$$typeof, object2) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                    return object2;
                  case REACT_CONSUMER_TYPE:
                    return object2;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    reactIs_development.ContextConsumer = REACT_CONSUMER_TYPE;
    reactIs_development.ContextProvider = REACT_CONTEXT_TYPE;
    reactIs_development.Element = REACT_ELEMENT_TYPE;
    reactIs_development.ForwardRef = REACT_FORWARD_REF_TYPE;
    reactIs_development.Fragment = REACT_FRAGMENT_TYPE;
    reactIs_development.Lazy = REACT_LAZY_TYPE;
    reactIs_development.Memo = REACT_MEMO_TYPE;
    reactIs_development.Portal = REACT_PORTAL_TYPE;
    reactIs_development.Profiler = REACT_PROFILER_TYPE;
    reactIs_development.StrictMode = REACT_STRICT_MODE_TYPE;
    reactIs_development.Suspense = REACT_SUSPENSE_TYPE;
    reactIs_development.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
    reactIs_development.isContextConsumer = function(object2) {
      return typeOf(object2) === REACT_CONSUMER_TYPE;
    };
    reactIs_development.isContextProvider = function(object2) {
      return typeOf(object2) === REACT_CONTEXT_TYPE;
    };
    reactIs_development.isElement = function(object2) {
      return "object" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE;
    };
    reactIs_development.isForwardRef = function(object2) {
      return typeOf(object2) === REACT_FORWARD_REF_TYPE;
    };
    reactIs_development.isFragment = function(object2) {
      return typeOf(object2) === REACT_FRAGMENT_TYPE;
    };
    reactIs_development.isLazy = function(object2) {
      return typeOf(object2) === REACT_LAZY_TYPE;
    };
    reactIs_development.isMemo = function(object2) {
      return typeOf(object2) === REACT_MEMO_TYPE;
    };
    reactIs_development.isPortal = function(object2) {
      return typeOf(object2) === REACT_PORTAL_TYPE;
    };
    reactIs_development.isProfiler = function(object2) {
      return typeOf(object2) === REACT_PROFILER_TYPE;
    };
    reactIs_development.isStrictMode = function(object2) {
      return typeOf(object2) === REACT_STRICT_MODE_TYPE;
    };
    reactIs_development.isSuspense = function(object2) {
      return typeOf(object2) === REACT_SUSPENSE_TYPE;
    };
    reactIs_development.isSuspenseList = function(object2) {
      return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
    };
    reactIs_development.isValidElementType = function(type2) {
      return "string" === typeof type2 || "function" === typeof type2 || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type2 && null !== type2 && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_CONSUMER_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type2.getModuleId) ? true : false;
    };
    reactIs_development.typeOf = typeOf;
  })();
  return reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = /* @__PURE__ */ requireReactIs_development();
  }
  return reactIs.exports;
}
var reactIsExports = /* @__PURE__ */ requireReactIs();
function isPlainObject(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(item);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone$1(source2) {
  if (/* @__PURE__ */ React$1.isValidElement(source2) || reactIsExports.isValidElementType(source2) || !isPlainObject(source2)) {
    return source2;
  }
  const output2 = {};
  Object.keys(source2).forEach((key2) => {
    output2[key2] = deepClone$1(source2[key2]);
  });
  return output2;
}
function deepmerge(target2, source2, options = {
  clone: true
}) {
  const output2 = options.clone ? {
    ...target2
  } : target2;
  if (isPlainObject(target2) && isPlainObject(source2)) {
    Object.keys(source2).forEach((key2) => {
      if (/* @__PURE__ */ React$1.isValidElement(source2[key2]) || reactIsExports.isValidElementType(source2[key2])) {
        output2[key2] = source2[key2];
      } else if (isPlainObject(source2[key2]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target2, key2) && isPlainObject(target2[key2])) {
        output2[key2] = deepmerge(target2[key2], source2[key2], options);
      } else if (options.clone) {
        output2[key2] = isPlainObject(source2[key2]) ? deepClone$1(source2[key2]) : source2[key2];
      } else {
        output2[key2] = source2[key2];
      }
    });
  }
  return output2;
}
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key2) => ({
    key: key2,
    val: values2[key2]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return {
      ...acc,
      [obj.key]: obj.val
    };
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: unit2 = "px",
    step = 5,
    ...other
  } = breakpoints;
  const sortedValues = sortBreakpointsValues(values2);
  const keys2 = Object.keys(sortedValues);
  function up(key2) {
    const value2 = typeof values2[key2] === "number" ? values2[key2] : key2;
    return `@media (min-width:${value2}${unit2})`;
  }
  function down(key2) {
    const value2 = typeof values2[key2] === "number" ? values2[key2] : key2;
    return `@media (max-width:${value2 - step / 100}${unit2})`;
  }
  function between(start, end) {
    const endIndex = keys2.indexOf(end);
    return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit2}) and (max-width:${(endIndex !== -1 && typeof values2[keys2[endIndex]] === "number" ? values2[keys2[endIndex]] : end) - step / 100}${unit2})`;
  }
  function only(key2) {
    if (keys2.indexOf(key2) + 1 < keys2.length) {
      return between(key2, keys2[keys2.indexOf(key2) + 1]);
    }
    return up(key2);
  }
  function not(key2) {
    const keyIndex = keys2.indexOf(key2);
    if (keyIndex === 0) {
      return up(keys2[1]);
    }
    if (keyIndex === keys2.length - 1) {
      return down(keys2[keyIndex]);
    }
    return between(key2, keys2[keys2.indexOf(key2) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: keys2,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit: unit2,
    ...other
  };
}
function sortContainerQueries(theme, css2) {
  if (!theme.containerQueries) {
    return css2;
  }
  const sorted = Object.keys(css2).filter((key2) => key2.startsWith("@container")).sort((a2, b2) => {
    var _a, _b;
    const regex = /min-width:\s*([0-9.]+)/;
    return +(((_a = a2.match(regex)) == null ? void 0 : _a[1]) || 0) - +(((_b = b2.match(regex)) == null ? void 0 : _b[1]) || 0);
  });
  if (!sorted.length) {
    return css2;
  }
  return sorted.reduce((acc, key2) => {
    const value2 = css2[key2];
    delete acc[key2];
    acc[key2] = value2;
    return acc;
  }, {
    ...css2
  });
}
function isCqShorthand(breakpointKeys, value2) {
  return value2 === "@" || value2.startsWith("@") && (breakpointKeys.some((key2) => value2.startsWith(`@${key2}`)) || !!value2.match(/^@\d/));
}
function getContainerQuery(theme, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    {
      throw new Error(`MUI: The provided shorthand ${`(${shorthand})`} is invalid. The format should be \`@<breakpoint | number>\` or \`@<breakpoint | number>/<container>\`.
For example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.`);
    }
  }
  const [, containerQuery, containerName] = matches;
  const value2 = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme.containerQueries(containerName).up(value2);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
  function attachCq(node22, name) {
    node22.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
    node22.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
    node22.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
    node22.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
    node22.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node2 = {};
  const containerQueries = (name) => {
    attachCq(node2, name);
    return node2;
  };
  attachCq(containerQueries);
  return {
    ...themeInput,
    containerQueries
  };
}
const shape = {
  borderRadius: 4
};
const responsivePropType = _pt.oneOfType([_pt.number, _pt.string, _pt.object, _pt.array]);
function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$3 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key2) => `@media (min-width:${values$3[key2]}px)`
};
const defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key2) => {
      let result = typeof key2 === "number" ? key2 : values$3[key2] || key2;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values$3).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output2 = styleFromPropValue(propValue);
  return output2;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _a;
  const breakpointsInOrder = (_a = breakpointsInput.keys) == null ? void 0 : _a.reduce((acc, key2) => {
    const breakpointStyleKey = breakpointsInput.up(key2);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key2) => {
    const breakpointOutput = acc[key2];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key2];
    }
    return acc;
  }, style2);
}
function capitalize$1(string2) {
  if (typeof string2 !== "string") {
    throw new Error("MUI: `capitalize(string)` expects a string argument.");
  }
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
function getPath(obj, path2, checkVars = true) {
  if (!path2 || typeof path2 !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path2}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path2.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform2, propValueFinal, userValue = propValueFinal) {
  let value2;
  if (typeof themeMapping === "function") {
    value2 = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value2 = themeMapping[propValueFinal] || userValue;
  } else {
    value2 = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform2) {
    value2 = transform2(value2, userValue, themeMapping);
  }
  return value2;
}
function style$1(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform: transform2
  } = options;
  const fn = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value2 = getStyleValue(themeMapping, transform2, propValueFinal);
      if (propValueFinal === value2 && typeof propValueFinal === "string") {
        value2 = getStyleValue(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value2;
      }
      return {
        [cssProperty]: value2
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn.propTypes = {
    [prop]: responsivePropType
  };
  fn.filterProps = [prop];
  return fn;
}
function memoize(fn) {
  const cache2 = {};
  return (arg) => {
    if (cache2[arg] === void 0) {
      cache2[arg] = fn(arg);
    }
    return cache2[arg];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a2, b2] = prop.split("");
  const property2 = properties[a2];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property2 + dir) : [property2 + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
const spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      {
        if (typeof val !== "number") {
          console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${val}.`);
        }
      }
      if (typeof themeSpacing === "string") {
        if (themeSpacing.startsWith("var(") && val === 0) {
          return 0;
        }
        if (themeSpacing.startsWith("var(") && val === 1) {
          return themeSpacing;
        }
        return `calc(${val} * ${themeSpacing})`;
      }
      return themeSpacing * val;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      const abs2 = Math.abs(val);
      {
        if (!Number.isInteger(abs2)) {
          console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join("\n"));
        } else if (abs2 > themeSpacing.length - 1) {
          console.error([`MUI: The value provided (${abs2}) overflows.`, `The supported values are: ${JSON.stringify(themeSpacing)}.`, `${abs2} > ${themeSpacing.length - 1}, you need to add the missing values.`].join("\n"));
        }
      }
      const transformed = themeSpacing[abs2];
      if (val >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      if (typeof transformed === "string" && transformed.startsWith("var(")) {
        return `calc(-1 * ${transformed})`;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  {
    console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, "It should be a number, an array or a function."].join("\n"));
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8, "spacing");
}
function getValue$1(transformer2, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer2(propValue);
}
function getStyleFromPropValue(cssProperties, transformer2) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue$1(transformer2, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys2, prop, transformer2) {
  if (!keys2.includes(prop)) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer2);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys2) {
  const transformer2 = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys2, prop, transformer2)).reduce(merge, {});
}
function margin(props) {
  return style(props, marginKeys);
}
margin.propTypes = marginKeys.reduce((obj, key2) => {
  obj[key2] = responsivePropType;
  return obj;
}, {});
margin.filterProps = marginKeys;
function padding$1(props) {
  return style(props, paddingKeys);
}
padding$1.propTypes = paddingKeys.reduce((obj, key2) => {
  obj[key2] = responsivePropType;
  return obj;
}, {});
padding$1.filterProps = paddingKeys;
spacingKeys.reduce((obj, key2) => {
  obj[key2] = responsivePropType;
  return obj;
}, {});
function createSpacing(spacingInput = 8, transform2 = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing = (...argsInput) => {
    {
      if (!(argsInput.length <= 4)) {
        console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
      }
    }
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output2 = transform2(argument);
      return typeof output2 === "number" ? `${output2}px` : output2;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose(...styles) {
  const handlers = styles.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes = styles.reduce((acc, style2) => Object.assign(acc, style2.propTypes), {});
  fn.filterProps = styles.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn;
}
function borderTransform(value2) {
  if (typeof value2 !== "number") {
    return value2;
  }
  return `${value2}px solid`;
}
function createBorderStyle(prop, transform2) {
  return style$1({
    prop,
    themeKey: "borders",
    transform: transform2
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer2 = createUnaryUnit(props.theme, "shape.borderRadius", 4, "borderRadius");
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue$1(transformer2, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {
  borderRadius: responsivePropType
};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer2 = createUnaryUnit(props.theme, "spacing", 8, "gap");
    const styleFromPropValue = (propValue) => ({
      gap: getValue$1(transformer2, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {
  gap: responsivePropType
};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer2 = createUnaryUnit(props.theme, "spacing", 8, "columnGap");
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue$1(transformer2, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {
  columnGap: responsivePropType
};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer2 = createUnaryUnit(props.theme, "spacing", 8, "rowGap");
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue$1(transformer2, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {
  rowGap: responsivePropType
};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
});
const gridRow = style$1({
  prop: "gridRow"
});
const gridAutoFlow = style$1({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$1({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$1({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$1({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
});
const gridArea = style$1({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value2, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value2;
}
const color$3 = style$1({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$1({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor$3 = style$1({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color$3, bgcolor, backgroundColor$3);
function sizingTransform(value2) {
  return value2 <= 1 && value2 !== 0 ? `${value2 * 100}%` : value2;
}
const width = style$1({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _a, _b, _c2, _d2, _e;
      const breakpoint = ((_c2 = (_b = (_a = props.theme) == null ? void 0 : _a.breakpoints) == null ? void 0 : _b.values) == null ? void 0 : _c2[propValue]) || values$3[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_e = (_d2 = props.theme) == null ? void 0 : _d2.breakpoints) == null ? void 0 : _e.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$1({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$1({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$1({
  prop: "minHeight",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$1({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding$1
  },
  pt: {
    style: padding$1
  },
  pr: {
    style: padding$1
  },
  pb: {
    style: padding$1
  },
  pl: {
    style: padding$1
  },
  px: {
    style: padding$1
  },
  py: {
    style: padding$1
  },
  padding: {
    style: padding$1
  },
  paddingTop: {
    style: padding$1
  },
  paddingRight: {
    style: padding$1
  },
  paddingBottom: {
    style: padding$1
  },
  paddingLeft: {
    style: padding$1
  },
  paddingX: {
    style: padding$1
  },
  paddingY: {
    style: padding$1
  },
  paddingInline: {
    style: padding$1
  },
  paddingInlineStart: {
    style: padding$1
  },
  paddingInlineEnd: {
    style: padding$1
  },
  paddingBlock: {
    style: padding$1
  },
  paddingBlockStart: {
    style: padding$1
  },
  paddingBlockEnd: {
    style: padding$1
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value2) => ({
      "@media print": {
        display: value2
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys2, object2) => keys2.concat(Object.keys(object2)), []);
  const union2 = new Set(allKeys);
  return objects.every((object2) => union2.size === Object.keys(object2).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform: transform2,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value2 = getStyleValue(themeMapping, transform2, propValueFinal);
      if (propValueFinal === value2 && typeof propValueFinal === "string") {
        value2 = getStyleValue(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value2;
      }
      return {
        [cssProperty]: value2
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config = theme.unstable_sxConfig ?? defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value2 = callIfFn(sxObject[styleKey], theme);
        if (value2 !== null && value2 !== void 0) {
          if (typeof value2 === "object") {
            if (config[styleKey]) {
              css2 = merge(css2, getThemeValue(styleKey, value2, theme, config));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value2, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value2)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value2,
                  theme
                });
              } else {
                css2 = merge(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge(css2, getThemeValue(styleKey, value2, theme, config));
          }
        }
      });
      return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css2));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
function applyStyles(key2, styles) {
  var _a;
  const theme = this;
  if (theme.vars) {
    if (!((_a = theme.colorSchemes) == null ? void 0 : _a[key2]) || typeof theme.getColorSchemeSelector !== "function") {
      return {};
    }
    let selector = theme.getColorSchemeSelector(key2);
    if (selector === "&") {
      return styles;
    }
    if (selector.includes("data-") || selector.includes(".")) {
      selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
    }
    return {
      [selector]: styles
    };
  }
  if (theme.palette.mode === key2) {
    return styles;
  }
  return {};
}
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {},
    ...other
  } = options;
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...paletteInput
    },
    spacing,
    shape: {
      ...shape,
      ...shapeInput
    }
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
  const contextTheme = React$1.useContext(ThemeContext);
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme = createTheme$1();
function useTheme$1(defaultTheme2 = systemDefaultTheme) {
  return useTheme$2(defaultTheme2);
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate2 = defaultGenerator;
  return {
    configure(generator) {
      generate2 = generator;
    },
    generate(componentName) {
      return generate2(componentName);
    },
    reset() {
      generate2 = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
const useEnhancedEffect$1 = typeof window !== "undefined" ? React$1.useLayoutEffect : React$1.useEffect;
function clamp(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min2, Math.min(val, max2));
}
function clampWrapper(value2, min2 = 0, max2 = 1) {
  {
    if (value2 < min2 || value2 > max2) {
      console.error(`MUI: The value provided ${value2} is out of range [${min2}, ${max2}].`);
    }
  }
  return clamp(value2, min2, max2);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors2 = color2.match(re2);
  if (colors2 && colors2[0].length === 1) {
    colors2 = colors2.map((n) => n + n);
  }
  {
    if (color2.length !== color2.trim().length) {
      console.error(`MUI: The color: "${color2}" is invalid. Make sure the color input doesn't contain leading/trailing space.`);
    }
  }
  return colors2 ? `rgb${colors2.length === 4 ? "a" : ""}(${colors2.map((n, index2) => {
    return index2 < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type2 = color2.substring(0, marker);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type2)) {
    throw new Error(`MUI: Unsupported \`${color2}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().`);
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type2 === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
      throw new Error(`MUI: unsupported \`${colorSpace}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.`);
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value2) => parseFloat(value2));
  return {
    type: type2,
    values: values2,
    colorSpace
  };
}
const colorChannel = (color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
const private_safeColorChannel = (color2, warning) => {
  try {
    return colorChannel(color2);
  } catch (error2) {
    if (warning && true) {
      console.warn(warning);
    }
    return color2;
  }
};
function recomposeColor(color2) {
  const {
    type: type2,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type2.includes("rgb")) {
    values2 = values2.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type2.includes("hsl")) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type2.includes("color")) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type2}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h2 = values2[0];
  const s = values2[1] / 100;
  const l = values2[2] / 100;
  const a2 = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h2 / 30) % 12) => l - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  let type2 = "rgb";
  const rgb2 = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  if (color2.type === "hsla") {
    type2 += "a";
    rgb2.push(values2[3]);
  }
  return recomposeColor({
    type: type2,
    values: rgb2
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb2 = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb2 = rgb2.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb2[0] + 0.7152 * rgb2[1] + 0.0722 * rgb2[2]).toFixed(3));
}
function getContrastRatio(foreground2, background2) {
  const lumA = getLuminance(foreground2);
  const lumB = getLuminance(background2);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value2) {
  color2 = decomposeColor(color2);
  value2 = clampWrapper(value2);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value2}`;
  } else {
    color2.values[3] = value2;
  }
  return recomposeColor(color2);
}
function private_safeAlpha(color2, value2, warning) {
  try {
    return alpha(color2, value2);
  } catch (error2) {
    return color2;
  }
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.includes("rgb") || color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeDarken(color2, coefficient, warning) {
  try {
    return darken(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.includes("rgb")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (255 - color2.values[i]) * coefficient;
    }
  } else if (color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (1 - color2.values[i]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeLighten(color2, coefficient, warning) {
  try {
    return lighten(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
function private_safeEmphasize(color2, coefficient, warning) {
  try {
    return emphasize(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
const specialProperty = "exact-prop: ​";
function exactProp(propTypes2) {
  return {
    ...propTypes2,
    [specialProperty]: (props) => {
      const unsupportedProps = Object.keys(props).filter((prop) => !propTypes2.hasOwnProperty(prop));
      if (unsupportedProps.length > 0) {
        return new Error(`The following props are not supported: ${unsupportedProps.map((prop) => `\`${prop}\``).join(", ")}. Please remove them.`);
      }
      return null;
    }
  };
}
function createGetCssVar$1(prefix2 = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value2 = vars[0];
    if (typeof value2 === "string" && !value2.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
      return `, var(--${prefix2 ? `${prefix2}-` : ""}${value2}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value2}`;
  }
  const getCssVar = (field2, ...fallbacks) => {
    return `var(--${prefix2 ? `${prefix2}-` : ""}${field2}${appendVar(...fallbacks)})`;
  };
  return getCssVar;
}
const assignNestedKeys = (obj, keys2, value2, arrayKeys = []) => {
  let temp2 = obj;
  keys2.forEach((k, index2) => {
    if (index2 === keys2.length - 1) {
      if (Array.isArray(temp2)) {
        temp2[Number(k)] = value2;
      } else if (temp2 && typeof temp2 === "object") {
        temp2[k] = value2;
      }
    } else if (temp2 && typeof temp2 === "object") {
      if (!temp2[k]) {
        temp2[k] = arrayKeys.includes(k) ? [] : {};
      }
      temp2 = temp2[k];
    }
  });
};
const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
  function recurse2(object2, parentKeys = [], arrayKeys = []) {
    Object.entries(object2).forEach(([key2, value2]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key2])) {
        if (value2 !== void 0 && value2 !== null) {
          if (typeof value2 === "object" && Object.keys(value2).length > 0) {
            recurse2(value2, [...parentKeys, key2], Array.isArray(value2) ? [...arrayKeys, key2] : arrayKeys);
          } else {
            callback([...parentKeys, key2], value2, arrayKeys);
          }
        }
      }
    });
  }
  recurse2(obj);
};
const getCssValue = (keys2, value2) => {
  if (typeof value2 === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys2.includes(prop))) {
      return value2;
    }
    const lastKey = keys2[keys2.length - 1];
    if (lastKey.toLowerCase().includes("opacity")) {
      return value2;
    }
    return `${value2}px`;
  }
  return value2;
};
function cssVarsParser(theme, options) {
  const {
    prefix: prefix2,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css2 = {};
  const vars = {};
  const varsWithDefaults = {};
  walkObjectDeep(
    theme,
    (keys2, value2, arrayKeys) => {
      if (typeof value2 === "string" || typeof value2 === "number") {
        if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys2, value2)) {
          const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys2.join("-")}`;
          const resolvedValue = getCssValue(keys2, value2);
          Object.assign(css2, {
            [cssVar]: resolvedValue
          });
          assignNestedKeys(vars, keys2, `var(${cssVar})`, arrayKeys);
          assignNestedKeys(varsWithDefaults, keys2, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
        }
      }
    },
    (keys2) => keys2[0] === "vars"
    // skip 'vars/*' paths
  );
  return {
    css: css2,
    vars,
    varsWithDefaults
  };
}
function prepareCssVars(theme, parserConfig = {}) {
  const {
    getSelector = defaultGetSelector2,
    disableCssColorScheme,
    colorSchemeSelector: selector
  } = parserConfig;
  const {
    colorSchemes: colorSchemes2 = {},
    components,
    defaultColorScheme = "light",
    ...otherTheme
  } = theme;
  const {
    vars: rootVars,
    css: rootCss,
    varsWithDefaults: rootVarsWithDefaults
  } = cssVarsParser(otherTheme, parserConfig);
  let themeVars = rootVarsWithDefaults;
  const colorSchemesMap = {};
  const {
    [defaultColorScheme]: defaultScheme,
    ...otherColorSchemes
  } = colorSchemes2;
  Object.entries(otherColorSchemes || {}).forEach(([key2, scheme2]) => {
    const {
      vars,
      css: css2,
      varsWithDefaults
    } = cssVarsParser(scheme2, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[key2] = {
      css: css2,
      vars
    };
  });
  if (defaultScheme) {
    const {
      css: css2,
      vars,
      varsWithDefaults
    } = cssVarsParser(defaultScheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[defaultColorScheme] = {
      css: css2,
      vars
    };
  }
  function defaultGetSelector2(colorScheme, cssObject) {
    var _a, _b;
    let rule2 = selector;
    if (selector === "class") {
      rule2 = ".%s";
    }
    if (selector === "data") {
      rule2 = "[data-%s]";
    }
    if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
      rule2 = `[${selector}="%s"]`;
    }
    if (colorScheme) {
      if (rule2 === "media") {
        if (theme.defaultColorScheme === colorScheme) {
          return ":root";
        }
        const mode = ((_b = (_a = colorSchemes2[colorScheme]) == null ? void 0 : _a.palette) == null ? void 0 : _b.mode) || colorScheme;
        return {
          [`@media (prefers-color-scheme: ${mode})`]: {
            ":root": cssObject
          }
        };
      }
      if (rule2) {
        if (theme.defaultColorScheme === colorScheme) {
          return `:root, ${rule2.replace("%s", String(colorScheme))}`;
        }
        return rule2.replace("%s", String(colorScheme));
      }
    }
    return ":root";
  }
  const generateThemeVars = () => {
    let vars = {
      ...rootVars
    };
    Object.entries(colorSchemesMap).forEach(([, {
      vars: schemeVars
    }]) => {
      vars = deepmerge(vars, schemeVars);
    });
    return vars;
  };
  const generateStyleSheets = () => {
    var _a, _b;
    const stylesheets = [];
    const colorScheme = theme.defaultColorScheme || "light";
    function insertStyleSheet(key2, css2) {
      if (Object.keys(css2).length) {
        stylesheets.push(typeof key2 === "string" ? {
          [key2]: {
            ...css2
          }
        } : key2);
      }
    }
    insertStyleSheet(getSelector(void 0, {
      ...rootCss
    }), rootCss);
    const {
      [colorScheme]: defaultSchemeVal,
      ...other
    } = colorSchemesMap;
    if (defaultSchemeVal) {
      const {
        css: css2
      } = defaultSchemeVal;
      const cssColorSheme = (_b = (_a = colorSchemes2[colorScheme]) == null ? void 0 : _a.palette) == null ? void 0 : _b.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(colorScheme, {
        ...finalCss
      }), finalCss);
    }
    Object.entries(other).forEach(([key2, {
      css: css2
    }]) => {
      var _a2, _b2;
      const cssColorSheme = (_b2 = (_a2 = colorSchemes2[key2]) == null ? void 0 : _a2.palette) == null ? void 0 : _b2.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(key2, {
        ...finalCss
      }), finalCss);
    });
    return stylesheets;
  };
  return {
    vars: themeVars,
    generateThemeVars,
    generateStyleSheets
  };
}
function createGetColorSchemeSelector(selector) {
  return function getColorSchemeSelector(colorScheme) {
    if (selector === "media") {
      {
        if (colorScheme !== "light" && colorScheme !== "dark") {
          console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${colorScheme}'.`);
        }
      }
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    if (selector) {
      if (selector.startsWith("data-") && !selector.includes("%s")) {
        return `[${selector}="${colorScheme}"] &`;
      }
      if (selector === "class") {
        return `.${colorScheme} &`;
      }
      if (selector === "data") {
        return `[data-${colorScheme}] &`;
      }
      return `${selector.replace("%s", colorScheme)} &`;
    }
    return "&";
  };
}
const common = {
  black: "#000",
  white: "#fff"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const purple = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
};
const red = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
};
const orange = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
};
const blue = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
};
const lightBlue = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
};
const green = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function getLight() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common.white,
      default: common.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const light = getLight();
function getDark() {
  return {
    text: {
      primary: common.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2,
    ...other
  } = palette;
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error2 = palette.error || getDefaultError(mode);
  const info2 = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode);
  function getContrastText(background2) {
    const contrastText = getContrastRatio(background2, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    {
      const contrast2 = getContrastRatio(background2, contrastText);
      if (contrast2 < 3) {
        console.error([`MUI: The contrast ratio of ${contrast2}:1 for ${contrastText} on ${background2}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join("\n"));
      }
    }
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = {
      ...color2
    };
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(`MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.`);
    }
    if (typeof color2.main !== "string") {
      throw new Error(`MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color2.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });`);
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  let modeHydrated;
  if (mode === "light") {
    modeHydrated = getLight();
  } else if (mode === "dark") {
    modeHydrated = getDark();
  }
  {
    if (!modeHydrated) {
      console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
    }
  }
  const paletteOutput = deepmerge({
    // A collection of common colors.
    common: {
      ...common
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error2,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info2,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset,
    // The light and dark mode object.
    ...modeHydrated
  }, other);
  return paletteOutput;
}
function prepareTypographyVars(typography) {
  const vars = {};
  const entries2 = Object.entries(typography);
  entries2.forEach((entry2) => {
    const [key2, value2] = entry2;
    if (typeof value2 === "object") {
      vars[key2] = `${value2.fontStyle ? `${value2.fontStyle} ` : ""}${value2.fontVariant ? `${value2.fontVariant} ` : ""}${value2.fontWeight ? `${value2.fontWeight} ` : ""}${value2.fontStretch ? `${value2.fontStretch} ` : ""}${value2.fontSize || ""}${value2.lineHeight ? `/${value2.lineHeight} ` : ""}${value2.fontFamily || ""}`;
    }
  });
  return vars;
}
function createMixins(breakpoints, mixins) {
  return {
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    },
    ...mixins
  };
}
function round(value2) {
  return Math.round(value2 * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const {
    fontFamily: fontFamily2 = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize: fontSize2 = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2,
    ...other
  } = typeof typography === "function" ? typography(palette) : typography;
  {
    if (typeof fontSize2 !== "number") {
      console.error("MUI: `fontSize` is required to be a number.");
    }
    if (typeof htmlFontSize !== "number") {
      console.error("MUI: `htmlFontSize` is required to be a number.");
    }
  }
  const coef = fontSize2 / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight2, letterSpacing, casing) => ({
    fontFamily: fontFamily2,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: lineHeight2,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...fontFamily2 === defaultFontFamily ? {
      letterSpacing: `${round(letterSpacing / size)}em`
    } : {},
    ...casing,
    ...allVariants
  });
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge({
    htmlFontSize,
    pxToRem,
    fontFamily: fontFamily2,
    fontSize: fontSize2,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold,
    ...variants
  }, other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px2) {
  return [`${px2[0]}px ${px2[1]}px ${px2[2]}px ${px2[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px2[4]}px ${px2[5]}px ${px2[6]}px ${px2[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px2[8]}px ${px2[9]}px ${px2[10]}px ${px2[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant2 = height2 / 36;
  return Math.min(Math.round((4 + 15 * constant2 ** 0.25 + constant2 / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
  const mergedEasing = {
    ...easing,
    ...inputTransitions.easing
  };
  const mergedDuration = {
    ...duration,
    ...inputTransitions.duration
  };
  const create2 = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0,
      ...other
    } = options;
    {
      const isString2 = (value2) => typeof value2 === "string";
      const isNumber2 = (value2) => !Number.isNaN(parseFloat(value2));
      if (!isString2(props) && !Array.isArray(props)) {
        console.error('MUI: Argument "props" must be a string or Array.');
      }
      if (!isNumber2(durationOption) && !isString2(durationOption)) {
        console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
      }
      if (!isString2(easingOption)) {
        console.error('MUI: Argument "easing" must be a string.');
      }
      if (!isNumber2(delay) && !isString2(delay)) {
        console.error('MUI: Argument "delay" must be a number or a string.');
      }
      if (typeof options !== "object") {
        console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join("\n"));
      }
      if (Object.keys(other).length !== 0) {
        console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(",")}].`);
      }
    }
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return {
    getAutoHeightDuration,
    create: create2,
    ...inputTransitions,
    easing: mergedEasing,
    duration: mergedDuration
  };
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function isSerializable(val) {
  return isPlainObject(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
function stringifyTheme(baseTheme = {}) {
  const serializableTheme = {
    ...baseTheme
  };
  function serializeTheme(object2) {
    const array2 = Object.entries(object2);
    for (let index2 = 0; index2 < array2.length; index2++) {
      const [key2, value2] = array2[index2];
      if (!isSerializable(value2) || key2.startsWith("unstable_")) {
        delete object2[key2];
      } else if (isPlainObject(value2)) {
        object2[key2] = {
          ...value2
        };
        serializeTheme(object2[key2]);
      }
    }
  }
  serializeTheme(serializableTheme);
  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function createThemeNoVars(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput,
    mixins: mixinsInput = {},
    spacing: spacingInput,
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {},
    shape: shapeInput,
    ...other
  } = options;
  if (options.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  options.generateThemeVars === void 0) {
    throw new Error("MUI: `vars` is a private field used for CSS variables support.\nPlease use another name or follow the [docs](https://mui.com/material-ui/customization/css-theme-variables/usage/) to enable the feature.");
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: {
      ...zIndex
    }
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  {
    const stateClasses = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"];
    const traverse = (node2, component) => {
      let key2;
      for (key2 in node2) {
        const child = node2[key2];
        if (stateClasses.includes(key2) && Object.keys(child).length > 0) {
          {
            const stateClass = generateUtilityClass("", key2);
            console.error([`MUI: The \`${component}\` component increases the CSS specificity of the \`${key2}\` internal state.`, "You can not override it like this: ", JSON.stringify(node2, null, 2), "", `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
              root: {
                [`&.${stateClass}`]: child
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join("\n"));
          }
          node2[key2] = {};
        }
      }
    };
    Object.keys(muiTheme.components).forEach((component) => {
      const styleOverrides = muiTheme.components[component].styleOverrides;
      if (styleOverrides && component.startsWith("Mui")) {
        traverse(styleOverrides, component);
      }
    });
  }
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  muiTheme.toRuntimeSource = stringifyTheme;
  return muiTheme;
}
function getOverlayAlpha(elevation) {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return Math.round(alphaValue * 10) / 1e3;
}
const defaultDarkOverlays = [...Array(25)].map((_, index2) => {
  if (index2 === 0) {
    return "none";
  }
  const overlay = getOverlayAlpha(index2);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode) {
  return {
    inputPlaceholder: mode === "dark" ? 0.5 : 0.42,
    inputUnderline: mode === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: mode === "dark" ? 0.2 : 0.12,
    switchTrack: mode === "dark" ? 0.3 : 0.38
  };
}
function getOverlays(mode) {
  return mode === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
  const {
    palette: paletteInput = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: opacity2,
    overlays,
    ...rest
  } = options;
  const palette = createPalette(paletteInput);
  return {
    palette,
    opacity: {
      ...getOpacity(palette.mode),
      ...opacity2
    },
    overlays: overlays || getOverlays(palette.mode),
    ...rest
  };
}
function shouldSkipGeneratingVar(keys2) {
  var _a;
  return !!keys2[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys2[0].match(/sxConfig$/) || // ends with sxConfig
  keys2[0] === "palette" && !!((_a = keys2[1]) == null ? void 0 : _a.match(/(mode|contrastThreshold|tonalOffset)/));
}
const excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_, index2) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index2}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
const defaultGetSelector = (theme) => (colorScheme, css2) => {
  const root2 = theme.rootSelector || ":root";
  const selector = theme.colorSchemeSelector;
  let rule2 = selector;
  if (selector === "class") {
    rule2 = ".%s";
  }
  if (selector === "data") {
    rule2 = "[data-%s]";
  }
  if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
    rule2 = `[${selector}="%s"]`;
  }
  if (theme.defaultColorScheme === colorScheme) {
    if (colorScheme === "dark") {
      const excludedVariables = {};
      excludeVariablesFromRoot(theme.cssVarPrefix).forEach((cssVar) => {
        excludedVariables[cssVar] = css2[cssVar];
        delete css2[cssVar];
      });
      if (rule2 === "media") {
        return {
          [root2]: css2,
          [`@media (prefers-color-scheme: dark)`]: {
            [root2]: excludedVariables
          }
        };
      }
      if (rule2) {
        return {
          [rule2.replace("%s", colorScheme)]: excludedVariables,
          [`${root2}, ${rule2.replace("%s", colorScheme)}`]: css2
        };
      }
      return {
        [root2]: {
          ...css2,
          ...excludedVariables
        }
      };
    }
    if (rule2 && rule2 !== "media") {
      return `${root2}, ${rule2.replace("%s", String(colorScheme))}`;
    }
  } else if (colorScheme) {
    if (rule2 === "media") {
      return {
        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
          [root2]: css2
        }
      };
    }
    if (rule2) {
      return rule2.replace("%s", String(colorScheme));
    }
  }
  return root2;
};
function assignNode(obj, keys2) {
  keys2.forEach((k) => {
    if (!obj[k]) {
      obj[k] = {};
    }
  });
}
function setColor(obj, key2, defaultValue) {
  if (!obj[key2] && defaultValue) {
    obj[key2] = defaultValue;
  }
}
function toRgb(color2) {
  if (typeof color2 !== "string" || !color2.startsWith("hsl")) {
    return color2;
  }
  return hslToRgb(color2);
}
function setColorChannel(obj, key2) {
  if (!(`${key2}Channel` in obj)) {
    obj[`${key2}Channel`] = private_safeColorChannel(toRgb(obj[key2]), `MUI: Can't create \`palette.${key2}Channel\` because \`palette.${key2}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${key2}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`);
  }
}
function getSpacingVal(spacingInput) {
  if (typeof spacingInput === "number") {
    return `${spacingInput}px`;
  }
  if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
    return spacingInput;
  }
  return "8px";
}
const silent = (fn) => {
  try {
    return fn();
  } catch (error2) {
  }
  return void 0;
};
const createGetCssVar = (cssVarPrefix = "mui") => createGetCssVar$1(cssVarPrefix);
function attachColorScheme$1(colorSchemes2, scheme2, restTheme, colorScheme) {
  if (!scheme2) {
    return void 0;
  }
  scheme2 = scheme2 === true ? {} : scheme2;
  const mode = colorScheme === "dark" ? "dark" : "light";
  if (!restTheme) {
    colorSchemes2[colorScheme] = createColorScheme({
      ...scheme2,
      palette: {
        mode,
        ...scheme2 == null ? void 0 : scheme2.palette
      }
    });
    return void 0;
  }
  const {
    palette,
    ...muiTheme
  } = createThemeNoVars({
    ...restTheme,
    palette: {
      mode,
      ...scheme2 == null ? void 0 : scheme2.palette
    }
  });
  colorSchemes2[colorScheme] = {
    ...scheme2,
    palette,
    opacity: {
      ...getOpacity(mode),
      ...scheme2 == null ? void 0 : scheme2.opacity
    },
    overlays: (scheme2 == null ? void 0 : scheme2.overlays) || getOverlays(mode)
  };
  return muiTheme;
}
function createThemeWithVars(options = {}, ...args) {
  const {
    colorSchemes: colorSchemesInput = {
      light: true
    },
    defaultColorScheme: defaultColorSchemeInput,
    disableCssColorScheme = false,
    cssVarPrefix = "mui",
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
    rootSelector = ":root",
    ...input
  } = options;
  const firstColorScheme = Object.keys(colorSchemesInput)[0];
  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
  const getCssVar = createGetCssVar(cssVarPrefix);
  const {
    [defaultColorScheme]: defaultSchemeInput,
    light: builtInLight,
    dark: builtInDark,
    ...customColorSchemes
  } = colorSchemesInput;
  const colorSchemes2 = {
    ...customColorSchemes
  };
  let defaultScheme = defaultSchemeInput;
  if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
    defaultScheme = true;
  }
  if (!defaultScheme) {
    throw new Error(`MUI: The \`colorSchemes.${defaultColorScheme}\` option is either missing or invalid.`);
  }
  const muiTheme = attachColorScheme$1(colorSchemes2, defaultScheme, input, defaultColorScheme);
  if (builtInLight && !colorSchemes2.light) {
    attachColorScheme$1(colorSchemes2, builtInLight, void 0, "light");
  }
  if (builtInDark && !colorSchemes2.dark) {
    attachColorScheme$1(colorSchemes2, builtInDark, void 0, "dark");
  }
  let theme = {
    defaultColorScheme,
    ...muiTheme,
    cssVarPrefix,
    colorSchemeSelector: selector,
    rootSelector,
    getCssVar,
    colorSchemes: colorSchemes2,
    font: {
      ...prepareTypographyVars(muiTheme.typography),
      ...muiTheme.font
    },
    spacing: getSpacingVal(input.spacing)
  };
  Object.keys(theme.colorSchemes).forEach((key2) => {
    const palette = theme.colorSchemes[key2].palette;
    const setCssVarColor = (cssVar) => {
      const tokens = cssVar.split("-");
      const color2 = tokens[1];
      const colorToken = tokens[2];
      return getCssVar(cssVar, palette[color2][colorToken]);
    };
    if (palette.mode === "light") {
      setColor(palette.common, "background", "#fff");
      setColor(palette.common, "onBackground", "#000");
    }
    if (palette.mode === "dark") {
      setColor(palette.common, "background", "#000");
      setColor(palette.common, "onBackground", "#fff");
    }
    assignNode(palette, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (palette.mode === "light") {
      setColor(palette.Alert, "errorColor", private_safeDarken(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeDarken(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeDarken(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeDarken(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.main)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.main)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.main)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.main)));
      setColor(palette.Alert, "errorStandardBg", private_safeLighten(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeLighten(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeLighten(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeLighten(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
      setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.LinearProgress, "secondaryBg", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.LinearProgress, "errorBg", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.LinearProgress, "infoBg", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.LinearProgress, "successBg", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.LinearProgress, "warningBg", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette.Slider, "primaryTrack", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Slider, "secondaryTrack", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Slider, "errorTrack", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Slider, "infoTrack", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Slider, "successTrack", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Slider, "warningTrack", private_safeLighten(palette.warning.main, 0.62));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.8);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Switch, "errorDisabledColor", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Switch, "infoDisabledColor", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Switch, "successDisabledColor", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Switch, "warningDisabledColor", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.TableCell, "border", private_safeLighten(private_safeAlpha(palette.divider, 1), 0.88));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    if (palette.mode === "dark") {
      setColor(palette.Alert, "errorColor", private_safeLighten(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeLighten(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeLighten(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeLighten(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.dark)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.dark)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.dark)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.dark)));
      setColor(palette.Alert, "errorStandardBg", private_safeDarken(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeDarken(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeDarken(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeDarken(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
      setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
      setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
      setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.LinearProgress, "secondaryBg", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.LinearProgress, "errorBg", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.LinearProgress, "infoBg", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.LinearProgress, "successBg", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.LinearProgress, "warningBg", private_safeDarken(palette.warning.main, 0.5));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette.Slider, "primaryTrack", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.Slider, "secondaryTrack", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.Slider, "errorTrack", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.Slider, "infoTrack", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.Slider, "successTrack", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.Slider, "warningTrack", private_safeDarken(palette.warning.main, 0.5));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.98);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeDarken(palette.primary.main, 0.55));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeDarken(palette.secondary.main, 0.55));
      setColor(palette.Switch, "errorDisabledColor", private_safeDarken(palette.error.main, 0.55));
      setColor(palette.Switch, "infoDisabledColor", private_safeDarken(palette.info.main, 0.55));
      setColor(palette.Switch, "successDisabledColor", private_safeDarken(palette.success.main, 0.55));
      setColor(palette.Switch, "warningDisabledColor", private_safeDarken(palette.warning.main, 0.55));
      setColor(palette.TableCell, "border", private_safeDarken(private_safeAlpha(palette.divider, 1), 0.68));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    setColorChannel(palette.background, "default");
    setColorChannel(palette.background, "paper");
    setColorChannel(palette.common, "background");
    setColorChannel(palette.common, "onBackground");
    setColorChannel(palette, "divider");
    Object.keys(palette).forEach((color2) => {
      const colors2 = palette[color2];
      if (color2 !== "tonalOffset" && colors2 && typeof colors2 === "object") {
        if (colors2.main) {
          setColor(palette[color2], "mainChannel", private_safeColorChannel(toRgb(colors2.main)));
        }
        if (colors2.light) {
          setColor(palette[color2], "lightChannel", private_safeColorChannel(toRgb(colors2.light)));
        }
        if (colors2.dark) {
          setColor(palette[color2], "darkChannel", private_safeColorChannel(toRgb(colors2.dark)));
        }
        if (colors2.contrastText) {
          setColor(palette[color2], "contrastTextChannel", private_safeColorChannel(toRgb(colors2.contrastText)));
        }
        if (color2 === "text") {
          setColorChannel(palette[color2], "primary");
          setColorChannel(palette[color2], "secondary");
        }
        if (color2 === "action") {
          if (colors2.active) {
            setColorChannel(palette[color2], "active");
          }
          if (colors2.selected) {
            setColorChannel(palette[color2], "selected");
          }
        }
      }
    });
  });
  theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
  const parserConfig = {
    prefix: cssVarPrefix,
    disableCssColorScheme,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
    getSelector: defaultGetSelector(theme)
  };
  const {
    vars,
    generateThemeVars,
    generateStyleSheets
  } = prepareCssVars(theme, parserConfig);
  theme.vars = vars;
  Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key2, value2]) => {
    theme[key2] = value2;
  });
  theme.generateThemeVars = generateThemeVars;
  theme.generateStyleSheets = generateStyleSheets;
  theme.generateSpacing = function generateSpacing() {
    return createSpacing(input.spacing, createUnarySpacing(this));
  };
  theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
  theme.spacing = theme.generateSpacing();
  theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
  theme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...input == null ? void 0 : input.unstable_sxConfig
  };
  theme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  theme.toRuntimeSource = stringifyTheme;
  return theme;
}
function attachColorScheme(theme, scheme2, colorScheme) {
  if (!theme.colorSchemes) {
    return void 0;
  }
  if (colorScheme) {
    theme.colorSchemes[scheme2] = {
      ...colorScheme !== true && colorScheme,
      palette: createPalette({
        ...colorScheme === true ? {} : colorScheme.palette,
        mode: scheme2
      })
      // cast type to skip module augmentation test
    };
  }
}
function createTheme(options = {}, ...args) {
  const {
    palette,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette ? {
      light: true
    } : void 0,
    defaultColorScheme: initialDefaultColorScheme = palette == null ? void 0 : palette.mode,
    ...rest
  } = options;
  const defaultColorSchemeInput = initialDefaultColorScheme || "light";
  const defaultScheme = initialColorSchemes == null ? void 0 : initialColorSchemes[defaultColorSchemeInput];
  const colorSchemesInput = {
    ...initialColorSchemes,
    ...palette ? {
      [defaultColorSchemeInput]: {
        ...typeof defaultScheme !== "boolean" && defaultScheme,
        palette
      }
    } : void 0
  };
  if (cssVariables === false) {
    if (!("colorSchemes" in options)) {
      return createThemeNoVars(options, ...args);
    }
    let paletteOptions = palette;
    if (!("palette" in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === "dark") {
          paletteOptions = {
            mode: "dark"
          };
        }
      }
    }
    const theme = createThemeNoVars({
      ...options,
      palette: paletteOptions
    }, ...args);
    theme.defaultColorScheme = defaultColorSchemeInput;
    theme.colorSchemes = colorSchemesInput;
    if (theme.palette.mode === "light") {
      theme.colorSchemes.light = {
        ...colorSchemesInput.light !== true && colorSchemesInput.light,
        palette: theme.palette
      };
      attachColorScheme(theme, "dark", colorSchemesInput.dark);
    }
    if (theme.palette.mode === "dark") {
      theme.colorSchemes.dark = {
        ...colorSchemesInput.dark !== true && colorSchemesInput.dark,
        palette: theme.palette
      };
      attachColorScheme(theme, "light", colorSchemesInput.light);
    }
    return theme;
  }
  if (!palette && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
    colorSchemesInput.light = true;
  }
  return createThemeWithVars({
    ...rest,
    colorSchemes: colorSchemesInput,
    defaultColorScheme: defaultColorSchemeInput,
    ...typeof cssVariables !== "boolean" && cssVariables
  }, ...args);
}
const defaultTheme = createTheme();
function useTheme() {
  const theme = useTheme$1(defaultTheme);
  {
    React$1.useDebugValue(theme);
  }
  return theme[THEME_ID] || theme;
}
const { makeStyles } = createMakeAndWithStyles({
  useTheme
});
const { tss } = createTss({
  "useContext": function useContext2() {
    const theme = useTheme();
    return { theme };
  },
  "usePlugin": useMuiThemeStyleOverridesPlugin
});
const useStyles$1 = tss.create({});
function setRef$1(ref2, value2) {
  if (typeof ref2 === "function") {
    ref2(value2);
  } else if (ref2) {
    ref2.current = value2;
  }
}
function useForkRef$1(...refs) {
  const cleanupRef = React$1.useRef(void 0);
  const refEffect = React$1.useCallback((instance) => {
    const cleanups = refs.map((ref2) => {
      if (ref2 == null) {
        return null;
      }
      if (typeof ref2 === "function") {
        const refCallback = ref2;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref2.current = instance;
      return () => {
        ref2.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return React$1.useMemo(() => {
    if (refs.every((ref2) => ref2 == null)) {
      return null;
    }
    return (value2) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value2 != null) {
        cleanupRef.current = refEffect(value2);
      }
    };
  }, refs);
}
function HTMLElementType(props, propName, componentName, location, propFullName) {
  const propValue = props[propName];
  const safePropName = propFullName || propName;
  if (propValue == null) {
    return null;
  }
  if (propValue && propValue.nodeType !== 1) {
    return new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. Expected an HTMLElement.`);
  }
  return null;
}
function getReactElementRef(element2) {
  var _a;
  if (parseInt(React$1.version, 10) >= 19) {
    return ((_a = element2 == null ? void 0 : element2.props) == null ? void 0 : _a.ref) || null;
  }
  return (element2 == null ? void 0 : element2.ref) || null;
}
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ React$1.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children: children2,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = React$1.useState(null);
  const handleRef = useForkRef$1(/* @__PURE__ */ React$1.isValidElement(children2) ? getReactElementRef(children2) : null, forwardedRef);
  useEnhancedEffect$1(() => {
    if (!disablePortal) {
      setMountNode(getContainer(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect$1(() => {
    if (mountNode && !disablePortal) {
      setRef$1(forwardedRef, mountNode);
      return () => {
        setRef$1(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ React$1.isValidElement(children2)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ React$1.cloneElement(children2, newProps);
    }
    return children2;
  }
  return mountNode ? /* @__PURE__ */ ReactDOM.createPortal(children2, mountNode) : mountNode;
});
Portal.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The children to render into the `container`.
   */
  children: _pt.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: _pt.oneOfType([HTMLElementType, _pt.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: _pt.bool
};
{
  Portal["propTypes"] = exactProp(Portal.propTypes);
}
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
var timeoutDuration = function() {
  var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();
function microtaskDebounce(fn) {
  var called = false;
  return function() {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function() {
      called = false;
      fn();
    });
  };
}
function taskDebounce(fn) {
  var scheduled = false;
  return function() {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function() {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}
var supportsMicroTasks = isBrowser && window.Promise;
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
function isFunction$2(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
}
function getStyleComputedProperty(element2, property2) {
  if (element2.nodeType !== 1) {
    return [];
  }
  var window2 = element2.ownerDocument.defaultView;
  var css2 = window2.getComputedStyle(element2, null);
  return property2 ? css2[property2] : css2;
}
function getParentNode(element2) {
  if (element2.nodeName === "HTML") {
    return element2;
  }
  return element2.parentNode || element2.host;
}
function getScrollParent(element2) {
  if (!element2) {
    return document.body;
  }
  switch (element2.nodeName) {
    case "HTML":
    case "BODY":
      return element2.ownerDocument.body;
    case "#document":
      return element2.body;
  }
  var _getStyleComputedProp = getStyleComputedProperty(element2), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element2;
  }
  return getScrollParent(getParentNode(element2));
}
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}
var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
function isIE(version2) {
  if (version2 === 11) {
    return isIE11;
  }
  if (version2 === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}
function getOffsetParent(element2) {
  if (!element2) {
    return document.documentElement;
  }
  var noOffsetParent = isIE(10) ? document.body : null;
  var offsetParent = element2.offsetParent || null;
  while (offsetParent === noOffsetParent && element2.nextElementSibling) {
    offsetParent = (element2 = element2.nextElementSibling).offsetParent;
  }
  var nodeName = offsetParent && offsetParent.nodeName;
  if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
    return element2 ? element2.ownerDocument.documentElement : document.documentElement;
  }
  if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
    return getOffsetParent(offsetParent);
  }
  return offsetParent;
}
function isOffsetContainer(element2) {
  var nodeName = element2.nodeName;
  if (nodeName === "BODY") {
    return false;
  }
  return nodeName === "HTML" || getOffsetParent(element2.firstElementChild) === element2;
}
function getRoot$1(node2) {
  if (node2.parentNode !== null) {
    return getRoot$1(node2.parentNode);
  }
  return node2;
}
function findCommonOffsetParent(element1, element2) {
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;
  var range2 = document.createRange();
  range2.setStart(start, 0);
  range2.setEnd(end, 0);
  var commonAncestorContainer = range2.commonAncestorContainer;
  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }
    return getOffsetParent(commonAncestorContainer);
  }
  var element1root = getRoot$1(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot$1(element2).host);
  }
}
function getScroll(element2) {
  var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
  var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
  var nodeName = element2.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    var html = element2.ownerDocument.documentElement;
    var scrollingElement = element2.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }
  return element2[upperSide];
}
function includeScroll(rect2, element2) {
  var subtract = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var scrollTop = getScroll(element2, "top");
  var scrollLeft = getScroll(element2, "left");
  var modifier = subtract ? -1 : 1;
  rect2.top += scrollTop * modifier;
  rect2.bottom += scrollTop * modifier;
  rect2.left += scrollLeft * modifier;
  rect2.right += scrollLeft * modifier;
  return rect2;
}
function getBordersSize(styles, axis) {
  var sideA = axis === "x" ? "Left" : "Top";
  var sideB = sideA === "Left" ? "Right" : "Bottom";
  return parseFloat(styles["border" + sideA + "Width"]) + parseFloat(styles["border" + sideB + "Width"]);
}
function getSize(axis, body, html, computedStyle) {
  return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0);
}
function getWindowSizes(document2) {
  var body = document2.body;
  var html = document2.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize("Height", body, html, computedStyle),
    width: getSize("Width", body, html, computedStyle)
  };
}
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = /* @__PURE__ */ function() {
  function defineProperties(target2, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target2, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var defineProperty$1 = function(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value2;
  }
  return obj;
};
var _extends$1 = Object.assign || function(target2) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = arguments[i];
    for (var key2 in source2) {
      if (Object.prototype.hasOwnProperty.call(source2, key2)) {
        target2[key2] = source2[key2];
      }
    }
  }
  return target2;
};
function getClientRect(offsets2) {
  return _extends$1({}, offsets2, {
    right: offsets2.left + offsets2.width,
    bottom: offsets2.top + offsets2.height
  });
}
function getBoundingClientRect(element2) {
  var rect2 = {};
  try {
    if (isIE(10)) {
      rect2 = element2.getBoundingClientRect();
      var scrollTop = getScroll(element2, "top");
      var scrollLeft = getScroll(element2, "left");
      rect2.top += scrollTop;
      rect2.left += scrollLeft;
      rect2.bottom += scrollTop;
      rect2.right += scrollLeft;
    } else {
      rect2 = element2.getBoundingClientRect();
    }
  } catch (e3) {
  }
  var result = {
    left: rect2.left,
    top: rect2.top,
    width: rect2.right - rect2.left,
    height: rect2.bottom - rect2.top
  };
  var sizes = element2.nodeName === "HTML" ? getWindowSizes(element2.ownerDocument) : {};
  var width2 = sizes.width || element2.clientWidth || result.width;
  var height2 = sizes.height || element2.clientHeight || result.height;
  var horizScrollbar = element2.offsetWidth - width2;
  var vertScrollbar = element2.offsetHeight - height2;
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element2);
    horizScrollbar -= getBordersSize(styles, "x");
    vertScrollbar -= getBordersSize(styles, "y");
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }
  return getClientRect(result);
}
function getOffsetRectRelativeToArbitraryNode(children2, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isIE102 = isIE(10);
  var isHTML = parent.nodeName === "HTML";
  var childrenRect = getBoundingClientRect(children2);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children2);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets2 = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets2.marginTop = 0;
  offsets2.marginLeft = 0;
  if (!isIE102 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets2.top -= borderTopWidth - marginTop;
    offsets2.bottom -= borderTopWidth - marginTop;
    offsets2.left -= borderLeftWidth - marginLeft;
    offsets2.right -= borderLeftWidth - marginLeft;
    offsets2.marginTop = marginTop;
    offsets2.marginLeft = marginLeft;
  }
  if (isIE102 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") {
    offsets2 = includeScroll(offsets2, parent);
  }
  return offsets2;
}
function getViewportOffsetRectRelativeToArtbitraryNode(element2) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var html = element2.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element2, html);
  var width2 = Math.max(html.clientWidth, window.innerWidth || 0);
  var height2 = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
  var offset2 = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width2,
    height: height2
  };
  return getClientRect(offset2);
}
function isFixed(element2) {
  var nodeName = element2.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    return false;
  }
  if (getStyleComputedProperty(element2, "position") === "fixed") {
    return true;
  }
  var parentNode = getParentNode(element2);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}
function getFixedPositionOffsetParent(element2) {
  if (!element2 || !element2.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element2.parentElement;
  while (el && getStyleComputedProperty(el, "transform") === "none") {
    el = el.parentElement;
  }
  return el || document.documentElement;
}
function getBoundaries(popper, reference, padding2, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  if (boundariesElement === "viewport") {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    var boundariesNode = void 0;
    if (boundariesElement === "scrollParent") {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === "BODY") {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === "window") {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }
    var offsets2 = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
    if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument), height2 = _getWindowSizes.height, width2 = _getWindowSizes.width;
      boundaries.top += offsets2.top - offsets2.marginTop;
      boundaries.bottom = height2 + offsets2.top;
      boundaries.left += offsets2.left - offsets2.marginLeft;
      boundaries.right = width2 + offsets2.left;
    } else {
      boundaries = offsets2;
    }
  }
  padding2 = padding2 || 0;
  var isPaddingNumber = typeof padding2 === "number";
  boundaries.left += isPaddingNumber ? padding2 : padding2.left || 0;
  boundaries.top += isPaddingNumber ? padding2 : padding2.top || 0;
  boundaries.right -= isPaddingNumber ? padding2 : padding2.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding2 : padding2.bottom || 0;
  return boundaries;
}
function getArea(_ref) {
  var width2 = _ref.width, height2 = _ref.height;
  return width2 * height2;
}
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
  if (placement.indexOf("auto") === -1) {
    return placement;
  }
  var boundaries = getBoundaries(popper, reference, padding2, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function(key2) {
    return _extends$1({
      key: key2
    }, rects[key2], {
      area: getArea(rects[key2])
    });
  }).sort(function(a2, b2) {
    return b2.area - a2.area;
  });
  var filteredAreas = sortedAreas.filter(function(_ref2) {
    var width2 = _ref2.width, height2 = _ref2.height;
    return width2 >= popper.clientWidth && height2 >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split("-")[1];
  return computedPlacement + (variation ? "-" + variation : "");
}
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
function getOuterSizes(element2) {
  var window2 = element2.ownerDocument.defaultView;
  var styles = window2.getComputedStyle(element2);
  var x2 = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y2 = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element2.offsetWidth + y2,
    height: element2.offsetHeight + x2
  };
  return result;
}
function getOppositePlacement(placement) {
  var hash2 = { left: "right", right: "left", bottom: "top", top: "bottom" };
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash2[matched];
  });
}
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split("-")[0];
  var popperRect = getOuterSizes(popper);
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };
  var isHoriz = ["right", "left"].indexOf(placement) !== -1;
  var mainSide = isHoriz ? "top" : "left";
  var secondarySide = isHoriz ? "left" : "top";
  var measurement = isHoriz ? "height" : "width";
  var secondaryMeasurement = !isHoriz ? "height" : "width";
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }
  return popperOffsets;
}
function find(arr, check) {
  if (Array.prototype.find) {
    return arr.find(check);
  }
  return arr.filter(check)[0];
}
function findIndex(arr, prop, value2) {
  if (Array.prototype.findIndex) {
    return arr.findIndex(function(cur) {
      return cur[prop] === value2;
    });
  }
  var match2 = find(arr, function(obj) {
    return obj[prop] === value2;
  });
  return arr.indexOf(match2);
}
function runModifiers(modifiers2, data2, ends) {
  var modifiersToRun = ends === void 0 ? modifiers2 : modifiers2.slice(0, findIndex(modifiers2, "name", ends));
  modifiersToRun.forEach(function(modifier) {
    if (modifier["function"]) {
      console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
    }
    var fn = modifier["function"] || modifier.fn;
    if (modifier.enabled && isFunction$2(fn)) {
      data2.offsets.popper = getClientRect(data2.offsets.popper);
      data2.offsets.reference = getClientRect(data2.offsets.reference);
      data2 = fn(data2, modifier);
    }
  });
  return data2;
}
function update() {
  if (this.state.isDestroyed) {
    return;
  }
  var data2 = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };
  data2.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
  data2.placement = computeAutoPlacement(this.options.placement, data2.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
  data2.originalPlacement = data2.placement;
  data2.positionFixed = this.options.positionFixed;
  data2.offsets.popper = getPopperOffsets(this.popper, data2.offsets.reference, data2.placement);
  data2.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
  data2 = runModifiers(this.modifiers, data2);
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data2);
  } else {
    this.options.onUpdate(data2);
  }
}
function isModifierEnabled(modifiers2, modifierName) {
  return modifiers2.some(function(_ref) {
    var name = _ref.name, enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
function getSupportedPropertyName(property2) {
  var prefixes2 = [false, "ms", "Webkit", "Moz", "O"];
  var upperProp = property2.charAt(0).toUpperCase() + property2.slice(1);
  for (var i = 0; i < prefixes2.length; i++) {
    var prefix2 = prefixes2[i];
    var toCheck = prefix2 ? "" + prefix2 + upperProp : property2;
    if (typeof document.body.style[toCheck] !== "undefined") {
      return toCheck;
    }
  }
  return null;
}
function destroy() {
  this.state.isDestroyed = true;
  if (isModifierEnabled(this.modifiers, "applyStyle")) {
    this.popper.removeAttribute("x-placement");
    this.popper.style.position = "";
    this.popper.style.top = "";
    this.popper.style.left = "";
    this.popper.style.right = "";
    this.popper.style.bottom = "";
    this.popper.style.willChange = "";
    this.popper.style[getSupportedPropertyName("transform")] = "";
  }
  this.disableEventListeners();
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}
function getWindow(element2) {
  var ownerDocument = element2.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}
function attachToScrollParents(scrollParent, event2, callback, scrollParents) {
  var isBody = scrollParent.nodeName === "BODY";
  var target2 = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target2.addEventListener(event2, callback, { passive: true });
  if (!isBody) {
    attachToScrollParents(getScrollParent(target2.parentNode), event2, callback, scrollParents);
  }
  scrollParents.push(target2);
}
function setupEventListeners(reference, options, state, updateBound) {
  state.updateBound = updateBound;
  getWindow(reference).addEventListener("resize", state.updateBound, { passive: true });
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
function removeEventListeners(reference, state) {
  getWindow(reference).removeEventListener("resize", state.updateBound);
  state.scrollParents.forEach(function(target2) {
    target2.removeEventListener("scroll", state.updateBound);
  });
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
function isNumeric$1(n) {
  return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
}
function setStyles(element2, styles) {
  Object.keys(styles).forEach(function(prop) {
    var unit2 = "";
    if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !== -1 && isNumeric$1(styles[prop])) {
      unit2 = "px";
    }
    element2.style[prop] = styles[prop] + unit2;
  });
}
function setAttributes(element2, attributes) {
  Object.keys(attributes).forEach(function(prop) {
    var value2 = attributes[prop];
    if (value2 !== false) {
      element2.setAttribute(prop, attributes[prop]);
    } else {
      element2.removeAttribute(prop);
    }
  });
}
function applyStyle(data2) {
  setStyles(data2.instance.popper, data2.styles);
  setAttributes(data2.instance.popper, data2.attributes);
  if (data2.arrowElement && Object.keys(data2.arrowStyles).length) {
    setStyles(data2.arrowElement, data2.arrowStyles);
  }
  return data2;
}
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute("x-placement", placement);
  setStyles(popper, { position: options.positionFixed ? "fixed" : "absolute" });
  return options;
}
function getRoundedOffsets(data2, shouldRound) {
  var _data$offsets = data2.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var round2 = Math.round, floor2 = Math.floor;
  var noRound = function noRound2(v) {
    return v;
  };
  var referenceWidth = round2(reference.width);
  var popperWidth = round2(popper.width);
  var isVertical = ["left", "right"].indexOf(data2.placement) !== -1;
  var isVariation = data2.placement.indexOf("-") !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round2 : floor2;
  var verticalToInteger = !shouldRound ? noRound : round2;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}
var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
function computeStyle(data2, options) {
  var x2 = options.x, y2 = options.y;
  var popper = data2.offsets.popper;
  var legacyGpuAccelerationOption = find(data2.instance.modifiers, function(modifier) {
    return modifier.name === "applyStyle";
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== void 0) {
    console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== void 0 ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data2.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);
  var styles = {
    position: popper.position
  };
  var offsets2 = getRoundedOffsets(data2, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x2 === "bottom" ? "top" : "bottom";
  var sideB = y2 === "right" ? "left" : "right";
  var prefixedProperty = getSupportedPropertyName("transform");
  var left = void 0, top = void 0;
  if (sideA === "bottom") {
    if (offsetParent.nodeName === "HTML") {
      top = -offsetParent.clientHeight + offsets2.bottom;
    } else {
      top = -offsetParentRect.height + offsets2.bottom;
    }
  } else {
    top = offsets2.top;
  }
  if (sideB === "right") {
    if (offsetParent.nodeName === "HTML") {
      left = -offsetParent.clientWidth + offsets2.right;
    } else {
      left = -offsetParentRect.width + offsets2.right;
    }
  } else {
    left = offsets2.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = "transform";
  } else {
    var invertTop = sideA === "bottom" ? -1 : 1;
    var invertLeft = sideB === "right" ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ", " + sideB;
  }
  var attributes = {
    "x-placement": data2.placement
  };
  data2.attributes = _extends$1({}, attributes, data2.attributes);
  data2.styles = _extends$1({}, styles, data2.styles);
  data2.arrowStyles = _extends$1({}, data2.offsets.arrow, data2.arrowStyles);
  return data2;
}
function isModifierRequired(modifiers2, requestingName, requestedName) {
  var requesting = find(modifiers2, function(_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers2.some(function(modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });
  if (!isRequired) {
    var _requesting = "`" + requestingName + "`";
    var requested = "`" + requestedName + "`";
    console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
  }
  return isRequired;
}
function arrow(data2, options) {
  var _data$offsets$arrow;
  if (!isModifierRequired(data2.instance.modifiers, "arrow", "keepTogether")) {
    return data2;
  }
  var arrowElement = options.element;
  if (typeof arrowElement === "string") {
    arrowElement = data2.instance.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return data2;
    }
  } else {
    if (!data2.instance.popper.contains(arrowElement)) {
      console.warn("WARNING: `arrow.element` must be child of its popper element!");
      return data2;
    }
  }
  var placement = data2.placement.split("-")[0];
  var _data$offsets = data2.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var isVertical = ["left", "right"].indexOf(placement) !== -1;
  var len = isVertical ? "height" : "width";
  var sideCapitalized = isVertical ? "Top" : "Left";
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? "left" : "top";
  var opSide = isVertical ? "bottom" : "right";
  var arrowElementSize = getOuterSizes(arrowElement)[len];
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data2.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data2.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data2.offsets.popper = getClientRect(data2.offsets.popper);
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
  var css2 = getStyleComputedProperty(data2.instance.popper);
  var popperMarginSide = parseFloat(css2["margin" + sideCapitalized]);
  var popperBorderSide = parseFloat(css2["border" + sideCapitalized + "Width"]);
  var sideValue = center - data2.offsets.popper[side] - popperMarginSide - popperBorderSide;
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data2.arrowElement = arrowElement;
  data2.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$1(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$1(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
  return data2;
}
function getOppositeVariation(variation) {
  if (variation === "end") {
    return "start";
  } else if (variation === "start") {
    return "end";
  }
  return variation;
}
var placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
var validPlacements = placements.slice(3);
function clockwise(placement) {
  var counter2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var index2 = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index2 + 1).concat(validPlacements.slice(0, index2));
  return counter2 ? arr.reverse() : arr;
}
var BEHAVIORS = {
  FLIP: "flip",
  CLOCKWISE: "clockwise",
  COUNTERCLOCKWISE: "counterclockwise"
};
function flip(data2, options) {
  if (isModifierEnabled(data2.instance.modifiers, "inner")) {
    return data2;
  }
  if (data2.flipped && data2.placement === data2.originalPlacement) {
    return data2;
  }
  var boundaries = getBoundaries(data2.instance.popper, data2.instance.reference, options.padding, options.boundariesElement, data2.positionFixed);
  var placement = data2.placement.split("-")[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data2.placement.split("-")[1] || "";
  var flipOrder = [];
  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }
  flipOrder.forEach(function(step, index2) {
    if (placement !== step || flipOrder.length === index2 + 1) {
      return data2;
    }
    placement = data2.placement.split("-")[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data2.offsets.popper;
    var refOffsets = data2.offsets.reference;
    var floor2 = Math.floor;
    var overlapsRef = placement === "left" && floor2(popperOffsets.right) > floor2(refOffsets.left) || placement === "right" && floor2(popperOffsets.left) < floor2(refOffsets.right) || placement === "top" && floor2(popperOffsets.bottom) > floor2(refOffsets.top) || placement === "bottom" && floor2(popperOffsets.top) < floor2(refOffsets.bottom);
    var overflowsLeft = floor2(popperOffsets.left) < floor2(boundaries.left);
    var overflowsRight = floor2(popperOffsets.right) > floor2(boundaries.right);
    var overflowsTop = floor2(popperOffsets.top) < floor2(boundaries.top);
    var overflowsBottom = floor2(popperOffsets.bottom) > floor2(boundaries.bottom);
    var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
    var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === "start" && overflowsRight || isVertical && variation === "end" && overflowsLeft || !isVertical && variation === "start" && overflowsBottom || !isVertical && variation === "end" && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      data2.flipped = true;
      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index2 + 1];
      }
      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }
      data2.placement = placement + (variation ? "-" + variation : "");
      data2.offsets.popper = _extends$1({}, data2.offsets.popper, getPopperOffsets(data2.instance.popper, data2.offsets.reference, data2.placement));
      data2 = runModifiers(data2.instance.modifiers, data2, "flip");
    }
  });
  return data2;
}
function keepTogether(data2) {
  var _data$offsets = data2.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var placement = data2.placement.split("-")[0];
  var floor2 = Math.floor;
  var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
  var side = isVertical ? "right" : "bottom";
  var opSide = isVertical ? "left" : "top";
  var measurement = isVertical ? "width" : "height";
  if (popper[side] < floor2(reference[opSide])) {
    data2.offsets.popper[opSide] = floor2(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor2(reference[side])) {
    data2.offsets.popper[opSide] = floor2(reference[side]);
  }
  return data2;
}
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value2 = +split[1];
  var unit2 = split[2];
  if (!value2) {
    return str;
  }
  if (unit2.indexOf("%") === 0) {
    var element2 = void 0;
    switch (unit2) {
      case "%p":
        element2 = popperOffsets;
        break;
      case "%":
      case "%r":
      default:
        element2 = referenceOffsets;
    }
    var rect2 = getClientRect(element2);
    return rect2[measurement] / 100 * value2;
  } else if (unit2 === "vh" || unit2 === "vw") {
    var size = void 0;
    if (unit2 === "vh") {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value2;
  } else {
    return value2;
  }
}
function parseOffset(offset2, popperOffsets, referenceOffsets, basePlacement) {
  var offsets2 = [0, 0];
  var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;
  var fragments = offset2.split(/(\+|\-)/).map(function(frag) {
    return frag.trim();
  });
  var divider = fragments.indexOf(find(fragments, function(frag) {
    return frag.search(/,|\s/) !== -1;
  }));
  if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
    console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
  }
  var splitRegex = /\s*,\s*|\s+/;
  var ops2 = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
  ops2 = ops2.map(function(op, index2) {
    var measurement = (index2 === 1 ? !useHeight : useHeight) ? "height" : "width";
    var mergeWithPrevious = false;
    return op.reduce(function(a2, b2) {
      if (a2[a2.length - 1] === "" && ["+", "-"].indexOf(b2) !== -1) {
        a2[a2.length - 1] = b2;
        mergeWithPrevious = true;
        return a2;
      } else if (mergeWithPrevious) {
        a2[a2.length - 1] += b2;
        mergeWithPrevious = false;
        return a2;
      } else {
        return a2.concat(b2);
      }
    }, []).map(function(str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });
  ops2.forEach(function(op, index2) {
    op.forEach(function(frag, index22) {
      if (isNumeric$1(frag)) {
        offsets2[index2] += frag * (op[index22 - 1] === "-" ? -1 : 1);
      }
    });
  });
  return offsets2;
}
function offset(data2, _ref) {
  var offset2 = _ref.offset;
  var placement = data2.placement, _data$offsets = data2.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var basePlacement = placement.split("-")[0];
  var offsets2 = void 0;
  if (isNumeric$1(+offset2)) {
    offsets2 = [+offset2, 0];
  } else {
    offsets2 = parseOffset(offset2, popper, reference, basePlacement);
  }
  if (basePlacement === "left") {
    popper.top += offsets2[0];
    popper.left -= offsets2[1];
  } else if (basePlacement === "right") {
    popper.top += offsets2[0];
    popper.left += offsets2[1];
  } else if (basePlacement === "top") {
    popper.left += offsets2[0];
    popper.top -= offsets2[1];
  } else if (basePlacement === "bottom") {
    popper.left += offsets2[0];
    popper.top += offsets2[1];
  }
  data2.popper = popper;
  return data2;
}
function preventOverflow(data2, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data2.instance.popper);
  if (data2.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }
  var transformProp = getSupportedPropertyName("transform");
  var popperStyles = data2.instance.popper.style;
  var top = popperStyles.top, left = popperStyles.left, transform2 = popperStyles[transformProp];
  popperStyles.top = "";
  popperStyles.left = "";
  popperStyles[transformProp] = "";
  var boundaries = getBoundaries(data2.instance.popper, data2.instance.reference, options.padding, boundariesElement, data2.positionFixed);
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform2;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data2.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value2 = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value2 = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty$1({}, placement, value2);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === "right" ? "left" : "top";
      var value2 = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value2 = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
      }
      return defineProperty$1({}, mainSide, value2);
    }
  };
  order.forEach(function(placement) {
    var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
    popper = _extends$1({}, popper, check[side](placement));
  });
  data2.offsets.popper = popper;
  return data2;
}
function shift(data2) {
  var placement = data2.placement;
  var basePlacement = placement.split("-")[0];
  var shiftvariation = placement.split("-")[1];
  if (shiftvariation) {
    var _data$offsets = data2.offsets, reference = _data$offsets.reference, popper = _data$offsets.popper;
    var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
    var side = isVertical ? "left" : "top";
    var measurement = isVertical ? "width" : "height";
    var shiftOffsets = {
      start: defineProperty$1({}, side, reference[side]),
      end: defineProperty$1({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data2.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);
  }
  return data2;
}
function hide(data2) {
  if (!isModifierRequired(data2.instance.modifiers, "hide", "preventOverflow")) {
    return data2;
  }
  var refRect = data2.offsets.reference;
  var bound2 = find(data2.instance.modifiers, function(modifier) {
    return modifier.name === "preventOverflow";
  }).boundaries;
  if (refRect.bottom < bound2.top || refRect.left > bound2.right || refRect.top > bound2.bottom || refRect.right < bound2.left) {
    if (data2.hide === true) {
      return data2;
    }
    data2.hide = true;
    data2.attributes["x-out-of-boundaries"] = "";
  } else {
    if (data2.hide === false) {
      return data2;
    }
    data2.hide = false;
    data2.attributes["x-out-of-boundaries"] = false;
  }
  return data2;
}
function inner(data2) {
  var placement = data2.placement;
  var basePlacement = placement.split("-")[0];
  var _data$offsets = data2.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
  var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
  popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
  data2.placement = getOppositePlacement(placement);
  data2.offsets.popper = getClientRect(popper);
  return data2;
}
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },
  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },
  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ["left", "right", "top", "bottom"],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: "scrollParent"
  },
  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },
  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: "[x-arrow]"
  },
  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: "flip",
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: "viewport",
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },
  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },
  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },
  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: "bottom",
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: "right"
  },
  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: void 0
  }
};
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: "bottom",
  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,
  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,
  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,
  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {
  },
  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {
  },
  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers
};
var Popper = function() {
  function Popper2(reference, popper) {
    var _this = this;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    classCallCheck(this, Popper2);
    this.scheduleUpdate = function() {
      return requestAnimationFrame(_this.update);
    };
    this.update = debounce(this.update.bind(this));
    this.options = _extends$1({}, Popper2.Defaults, options);
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;
    this.options.modifiers = {};
    Object.keys(_extends$1({}, Popper2.Defaults.modifiers, options.modifiers)).forEach(function(name) {
      _this.options.modifiers[name] = _extends$1({}, Popper2.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });
    this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
      return _extends$1({
        name
      }, _this.options.modifiers[name]);
    }).sort(function(a2, b2) {
      return a2.order - b2.order;
    });
    this.modifiers.forEach(function(modifierOptions) {
      if (modifierOptions.enabled && isFunction$2(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });
    this.update();
    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      this.enableEventListeners();
    }
    this.state.eventsEnabled = eventsEnabled;
  }
  createClass(Popper2, [{
    key: "update",
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: "destroy",
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: "enableEventListeners",
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: "disableEventListeners",
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */
  }]);
  return Popper2;
}();
Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    {
      if (typeof func !== "function") {
        console.error("Material-UI: Invalid Argument Type, must only provide functions, undefined, or null.");
      }
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function setRef(ref2, value2) {
  if (typeof ref2 === "function") {
    ref2(value2);
  } else if (ref2) {
    ref2.current = value2;
  }
}
function useForkRef(refA, refB) {
  return useMemo(() => {
    if (refA == null && refB == null) {
      return null;
    }
    return (refValue) => {
      setRef(refA, refValue);
      setRef(refB, refValue);
    };
  }, [refA, refB]);
}
function flipPlacement(placement, theme) {
  const direction = theme && theme.direction || "ltr";
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
function getAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useEnhancedEffect = typeof window !== "undefined" ? React$1.useLayoutEffect : React$1.useEffect;
const defaultPopperOptions = {};
React$1.forwardRef((props, ref2) => {
  const { anchorEl, children: children2, container, disablePortal = false, keepMounted = false, modifiers: modifiers2, open, placement: initialPlacement = "bottom", popperOptions = defaultPopperOptions, popperRef: popperRefProp, style: style2, transition = false, ...other } = props;
  const tooltipRef = React$1.useRef(null);
  const ownRef = useForkRef(tooltipRef, ref2);
  const popperRef = React$1.useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = React$1.useRef(handlePopperRef);
  useEnhancedEffect(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  React$1.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const [exited, setExited] = React$1.useState(true);
  const { theme } = useStyles$1();
  const rtlPlacement = flipPlacement(initialPlacement, theme);
  const [placement, setPlacement] = React$1.useState(rtlPlacement);
  React$1.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.update();
    }
  });
  const handleOpen = React$1.useCallback(() => {
    if (!tooltipRef.current || !anchorEl || !open) {
      return;
    }
    if (popperRef.current) {
      popperRef.current.destroy();
      handlePopperRefRef.current(null);
    }
    const handlePopperUpdate = (data2) => {
      setPlacement(data2.placement);
    };
    const resolvedAnchorEl = getAnchorEl(anchorEl);
    {
      if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
        const box = resolvedAnchorEl.getBoundingClientRect();
        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          console.warn([
            "Material-UI: The `anchorEl` prop provided to the component is invalid.",
            "The anchor element should be part of the document layout.",
            "Make sure the element is present in the document or that it's not display none."
          ].join("\n"));
        }
      }
    }
    const popper = new Popper(getAnchorEl(anchorEl), tooltipRef.current, {
      placement: rtlPlacement,
      ...popperOptions,
      modifiers: {
        ...disablePortal ? {} : {
          // It's using scrollParent by default, we can use the viewport when using a portal.
          preventOverflow: {
            boundariesElement: "window"
          }
        },
        ...modifiers2,
        ...popperOptions.modifiers
      },
      // We could have been using a custom modifier like react-popper is doing.
      // But it seems this is the best public API for this use case.
      onCreate: createChainedFunction(handlePopperUpdate, popperOptions.onCreate),
      onUpdate: createChainedFunction(handlePopperUpdate, popperOptions.onUpdate)
    });
    handlePopperRefRef.current(popper);
  }, [anchorEl, disablePortal, modifiers2, open, rtlPlacement, popperOptions]);
  const handleRef = React$1.useCallback((node2) => {
    setRef(ownRef, node2);
    handleOpen();
  }, [ownRef, handleOpen]);
  const handleEnter = () => {
    setExited(false);
  };
  const handleClose = () => {
    if (!popperRef.current) {
      return;
    }
    popperRef.current.destroy();
    handlePopperRefRef.current(null);
  };
  const handleExited = () => {
    setExited(true);
    handleClose();
  };
  React$1.useEffect(() => () => {
    handleClose();
  }, []);
  React$1.useEffect(() => {
    if (!open && !transition) {
      handleClose();
    }
  }, [open, transition]);
  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  }
  const childProps = { placement };
  if (transition) {
    childProps.TransitionProps = {
      in: open,
      onEnter: handleEnter,
      onExited: handleExited
    };
  }
  return jsxRuntimeExports.jsx(Portal, { disablePortal, container, children: jsxRuntimeExports.jsx("div", { ref: handleRef, role: "tooltip", ...other, style: {
    // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
    position: "fixed",
    // Fix Popper.js display issue
    top: 0,
    left: 0,
    display: !open && keepMounted && !transition ? "none" : null,
    ...style2
  }, children: typeof children2 === "function" ? children2(childProps) : children2 }) });
});
const useStyles = makeStyles()((theme) => ({
  tooltipAnchor: {
    position: "relative",
    width: "0px",
    height: "0px",
    pointerEvents: "none",
    userSelect: "none"
  },
  tooltipContent: {
    opacity: 0.9,
    padding: "5px",
    pointerEvents: "none",
    "& table > tbody > tr > th, & table > tbody > tr > td": {
      border: "none",
      fontSize: "12px",
      lineHeight: 1.43,
      opacity: 0.8,
      outline: 0,
      padding: "0 2px !important",
      textAlign: "left",
      color: theme.palette.tooltipText
    },
    "& table": {
      borderCollapse: "collapse",
      marginBottom: "0px"
    }
  }
}));
makeStyles()((theme) => ({
  cellEmphasisCrosshair: {
    zIndex: 50,
    position: "absolute",
    pointerEvents: "none",
    boxSizing: "border-box",
    backgroundColor: theme.palette.secondaryForeground
  }
}));
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pluralize$1 = { exports: {} };
var pluralize = pluralize$1.exports;
var hasRequiredPluralize;
function requirePluralize() {
  if (hasRequiredPluralize) return pluralize$1.exports;
  hasRequiredPluralize = 1;
  (function(module2, exports2) {
    (function(root2, pluralize2) {
      if (typeof commonjsRequire === "function" && true && true) {
        module2.exports = pluralize2();
      } else {
        root2.pluralize = pluralize2();
      }
    })(pluralize, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule2) {
        if (typeof rule2 === "string") {
          return new RegExp("^" + rule2 + "$", "i");
        }
        return rule2;
      }
      function restoreCase(word, token2) {
        if (word === token2) return token2;
        if (word === word.toLowerCase()) return token2.toLowerCase();
        if (word === word.toUpperCase()) return token2.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token2.charAt(0).toUpperCase() + token2.substr(1).toLowerCase();
        }
        return token2.toLowerCase();
      }
      function interpolate2(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match2, index2) {
          return args[index2] || "";
        });
      }
      function replace2(word, rule2) {
        return word.replace(rule2[0], function(match2, index2) {
          var result = interpolate2(rule2[1], arguments);
          if (match2 === "") {
            return restoreCase(word[index2 - 1], result);
          }
          return restoreCase(match2, result);
        });
      }
      function sanitizeWord(token2, word, rules) {
        if (!token2.length || uncountables.hasOwnProperty(token2)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule2 = rules[len];
          if (rule2[0].test(word)) return replace2(word, rule2);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) {
            return restoreCase(word, token2);
          }
          if (replaceMap.hasOwnProperty(token2)) {
            return restoreCase(word, replaceMap[token2]);
          }
          return sanitizeWord(token2, word, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) return true;
          if (replaceMap.hasOwnProperty(token2)) return false;
          return sanitizeWord(token2, token2, rules) === token2;
        };
      }
      function pluralize2(word, count2, inclusive) {
        var pluralized = count2 === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
        return (inclusive ? count2 + " " : "") + pluralized;
      }
      pluralize2.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.addPluralRule = function(rule2, replacement) {
        pluralRules.push([sanitizeRule(rule2), replacement]);
      };
      pluralize2.addSingularRule = function(rule2, replacement) {
        singularRules.push([sanitizeRule(rule2), replacement]);
      };
      pluralize2.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize2.addPluralRule(word, "$0");
        pluralize2.addSingularRule(word, "$0");
      };
      pluralize2.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule2) {
        return pluralize2.addIrregularRule(rule2[0], rule2[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule2) {
        return pluralize2.addPluralRule(rule2[0], rule2[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule2) {
        return pluralize2.addSingularRule(rule2[0], rule2[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eé]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize2.addUncountableRule);
      return pluralize2;
    });
  })(pluralize$1);
  return pluralize$1.exports;
}
var pluralizeExports = requirePluralize();
const plur = /* @__PURE__ */ getDefaultExportFromCjs(pluralizeExports);
plur.addPluralRule("glomerulus", "glomeruli");
plur.addPluralRule("interstitium", "interstitia");
function capitalize(word) {
  return word ? word.charAt(0).toUpperCase() + word.slice(1) : "";
}
function getNextScope(prevScopes) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const nextCharIndices = [0];
  function next2() {
    const r2 = [];
    nextCharIndices.forEach((charIndex) => {
      r2.unshift(chars[charIndex]);
    });
    let increment2 = true;
    for (let i = 0; i < nextCharIndices.length; i++) {
      const val = ++nextCharIndices[i];
      if (val >= chars.length) {
        nextCharIndices[i] = 0;
      } else {
        increment2 = false;
        break;
      }
    }
    if (increment2) {
      nextCharIndices.push(0);
    }
    return r2.join("");
  }
  let nextScope;
  do {
    nextScope = next2();
  } while (prevScopes.includes(nextScope));
  return nextScope;
}
var loglevel$1 = { exports: {} };
var loglevel = loglevel$1.exports;
var hasRequiredLoglevel;
function requireLoglevel() {
  if (hasRequiredLoglevel) return loglevel$1.exports;
  hasRequiredLoglevel = 1;
  (function(module2) {
    (function(root2, definition2) {
      if (module2.exports) {
        module2.exports = definition2();
      } else {
        root2.log = definition2();
      }
    })(loglevel, function() {
      var noop2 = function() {
      };
      var undefinedType2 = "undefined";
      var isIE2 = typeof window !== undefinedType2 && typeof window.navigator !== undefinedType2 && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      var _loggersByName = {};
      var defaultLogger = null;
      function bindMethod(obj, methodName) {
        var method2 = obj[methodName];
        if (typeof method2.bind === "function") {
          return method2.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method2, obj);
          } catch (e3) {
            return function() {
              return Function.prototype.apply.apply(method2, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace) console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType2) {
          return false;
        } else if (methodName === "trace" && isIE2) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop2;
        }
      }
      function replaceLoggingMethods() {
        var level = this.getLevel();
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop2 : this.methodFactory(methodName, level, this.name);
        }
        this.log = this.debug;
        if (typeof console === undefinedType2 && level < this.levels.SILENT) {
          return "No console available for logging";
        }
      }
      function enableLoggingWhenConsoleArrives(methodName) {
        return function() {
          if (typeof console !== undefinedType2) {
            replaceLoggingMethods.call(this);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, _level, _loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, factory) {
        var self2 = this;
        var inheritedLevel;
        var defaultLevel;
        var userLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType2 || !storageKey) return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType2 || !storageKey) return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType2) {
            try {
              var cookie = window.document.cookie;
              var cookieName = encodeURIComponent(storageKey);
              var location = cookie.indexOf(cookieName + "=");
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(
                  cookie.slice(location + cookieName.length + 1)
                )[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType2 || !storageKey) return;
          try {
            window.localStorage.removeItem(storageKey);
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            return level;
          } else {
            throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
        };
        self2.setLevel = function(level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {
            persistLevelIfPossible(userLevel);
          }
          return replaceLoggingMethods.call(self2);
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self2);
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        self2.rebuild = function() {
          if (defaultLogger !== self2) {
            inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self2);
          if (defaultLogger === self2) {
            for (var childName in _loggersByName) {
              _loggersByName[childName].rebuild();
            }
          }
        };
        inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
        );
        var initialLevel = getPersistedLevel();
        if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
        }
        replaceLoggingMethods.call(self2);
      }
      defaultLogger = new Logger();
      defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger2 = _loggersByName[name];
        if (!logger2) {
          logger2 = _loggersByName[name] = new Logger(
            name,
            defaultLogger.methodFactory
          );
        }
        return logger2;
      };
      var _log = typeof window !== undefinedType2 ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType2 && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  })(loglevel$1);
  return loglevel$1.exports;
}
var loglevelExports = requireLoglevel();
const log = /* @__PURE__ */ getDefaultExportFromCjs(loglevelExports);
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var Symbol$1 = root.Symbol;
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var nativeObjectToString$1 = objectProto$b.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty$9.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$a = Object.prototype;
var nativeObjectToString = objectProto$a.toString;
function objectToString(value2) {
  return nativeObjectToString.call(value2);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
var isArray = Array.isArray;
function isObject(value2) {
  var type2 = typeof value2;
  return value2 != null && (type2 == "object" || type2 == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value2) {
  if (!isObject(value2)) {
    return false;
  }
  var tag = baseGetTag(value2);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$9 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value2) {
  if (!isObject(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction$1(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
function getValue(object2, key2) {
  return object2 == null ? void 0 : object2[key2];
}
function getNative(object2, key2) {
  var value2 = getValue(object2, key2);
  return baseIsNative(value2) ? value2 : void 0;
}
var WeakMap$1 = getNative(root, "WeakMap");
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object2() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object2.prototype = proto;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
}();
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e3) {
  }
}();
function arrayEach(array2, iteratee) {
  var index2 = -1, length2 = array2 == null ? 0 : array2.length;
  while (++index2 < length2) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length2) {
  var type2 = typeof value2;
  length2 = length2 == null ? MAX_SAFE_INTEGER$3 : length2;
  return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
}
function baseAssignValue(object2, key2, value2) {
  if (key2 == "__proto__" && defineProperty) {
    defineProperty(object2, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object2[key2] = value2;
  }
}
function eq$2(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function assignValue(object2, key2, value2) {
  var objValue = object2[key2];
  if (!(hasOwnProperty$7.call(object2, key2) && eq$2(objValue, value2)) || value2 === void 0 && !(key2 in object2)) {
    baseAssignValue(object2, key2, value2);
  }
}
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER$2;
}
function isArrayLike(value2) {
  return value2 != null && isLength(value2.length) && !isFunction$1(value2);
}
var objectProto$7 = Object.prototype;
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$7;
  return value2 === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike(value2) && baseGetTag(value2) == argsTag$2;
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike(value2) && hasOwnProperty$6.call(value2, "callee") && !propertyIsEnumerable$1.call(value2, "callee");
};
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value2) {
  return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
}
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e3) {
  }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length2 = result.length;
  for (var key2 in value2) {
    if (hasOwnProperty$5.call(value2, key2) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
    isIndex(key2, length2)))) {
      result.push(key2);
    }
  }
  return result;
}
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function baseKeys(object2) {
  if (!isPrototype(object2)) {
    return nativeKeys(object2);
  }
  var result = [];
  for (var key2 in Object(object2)) {
    if (hasOwnProperty$4.call(object2, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
function keys$2(object2) {
  return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function hashGet(key2) {
  var data2 = this.__data__;
  if (nativeCreate) {
    var result = data2[key2];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$3.call(data2, key2) ? data2[key2] : void 0;
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function hashHas(key2) {
  var data2 = this.__data__;
  return nativeCreate ? data2[key2] !== void 0 : hasOwnProperty$2.call(data2, key2);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key2, value2) {
  var data2 = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data2[key2] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED : value2;
  return this;
}
function Hash(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry2 = entries2[index2];
    this.set(entry2[0], entry2[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array2, key2) {
  var length2 = array2.length;
  while (length2--) {
    if (eq$2(array2[length2][0], key2)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key2) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
  return index2 < 0 ? void 0 : data2[index2][1];
}
function listCacheHas(key2) {
  return assocIndexOf(this.__data__, key2) > -1;
}
function listCacheSet(key2, value2) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
  if (index2 < 0) {
    ++this.size;
    data2.push([key2, value2]);
  } else {
    data2[index2][1] = value2;
  }
  return this;
}
function ListCache(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry2 = entries2[index2];
    this.set(entry2[0], entry2[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value2) {
  var type2 = typeof value2;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function getMapData(map2, key2) {
  var data2 = map2.__data__;
  return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
}
function mapCacheDelete(key2) {
  var result = getMapData(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key2) {
  return getMapData(this, key2).get(key2);
}
function mapCacheHas(key2) {
  return getMapData(this, key2).has(key2);
}
function mapCacheSet(key2, value2) {
  var data2 = getMapData(this, key2), size = data2.size;
  data2.set(key2, value2);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
function MapCache(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry2 = entries2[index2];
    this.set(entry2[0], entry2[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function arrayPush(array2, values2) {
  var index2 = -1, length2 = values2.length, offset2 = array2.length;
  while (++index2 < length2) {
    array2[offset2 + index2] = values2[index2];
  }
  return array2;
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key2) {
  var data2 = this.__data__, result = data2["delete"](key2);
  this.size = data2.size;
  return result;
}
function stackGet(key2) {
  return this.__data__.get(key2);
}
function stackHas(key2) {
  return this.__data__.has(key2);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key2, value2) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache) {
    var pairs = data2.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key2, value2]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache(pairs);
  }
  data2.set(key2, value2);
  this.size = data2.size;
  return this;
}
function Stack(entries2) {
  var data2 = this.__data__ = new ListCache(entries2);
  this.size = data2.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root.Buffer : void 0;
Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  {
    return buffer.slice();
  }
}
function arrayFilter(array2, predicate) {
  var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value2 = array2[index2];
    if (predicate(value2, index2, array2)) {
      result[resIndex++] = value2;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$1 = Object.prototype;
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter(nativeGetSymbols(object2), function(symbol2) {
    return propertyIsEnumerable.call(object2, symbol2);
  });
};
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
}
function getAllKeys(object2) {
  return baseGetAllKeys(object2, keys$2, getSymbols);
}
var DataView$1 = getNative(root, "DataView");
var Promise$1 = getNative(root, "Promise");
var Set$1 = getNative(root, "Set");
var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
  getTag = function(value2) {
    var result = baseGetTag(value2), Ctor = result == objectTag$1 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function initCloneArray(array2) {
  var length2 = array2.length, result = new array2.constructor(length2);
  if (length2 && typeof array2[0] == "string" && hasOwnProperty$1.call(array2, "index")) {
    result.index = array2.index;
    result.input = array2.input;
  }
  return result;
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = cloneArrayBuffer(dataView.buffer);
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol(symbol2) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol2)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = cloneArrayBuffer(typedArray.buffer);
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object2, tag, isDeep) {
  var Ctor = object2.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object2);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object2);
    case dataViewTag$1:
      return cloneDataView(object2);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object2);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object2);
    case regexpTag$1:
      return cloneRegExp(object2);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object2);
  }
}
function initCloneObject(object2) {
  return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
}
var mapTag$1 = "[object Map]";
function baseIsMap(value2) {
  return isObjectLike(value2) && getTag(value2) == mapTag$1;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var setTag$1 = "[object Set]";
function baseIsSet(value2) {
  return isObjectLike(value2) && getTag(value2) == setTag$1;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value2, bitmask, customizer, key2, object2, stack2) {
  var result;
  if (result !== void 0) {
    return result;
  }
  if (!isObject(value2)) {
    return value2;
  }
  var isArr = isArray(value2);
  if (isArr) {
    result = initCloneArray(value2);
  } else {
    var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer(value2)) {
      return cloneBuffer(value2);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object2) {
      result = isFunc ? {} : initCloneObject(value2);
    } else {
      if (!cloneableTags[tag]) {
        return object2 ? value2 : {};
      }
      result = initCloneByTag(value2, tag);
    }
  }
  stack2 || (stack2 = new Stack());
  var stacked = stack2.get(value2);
  if (stacked) {
    return stacked;
  }
  stack2.set(value2, result);
  if (isSet(value2)) {
    value2.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack2));
    });
  } else if (isMap(value2)) {
    value2.forEach(function(subValue, key3) {
      result.set(key3, baseClone(subValue, bitmask, customizer, key3, value2, stack2));
    });
  }
  var keysFunc = getAllKeys;
  var props = isArr ? void 0 : keysFunc(value2);
  arrayEach(props || value2, function(subValue, key3) {
    if (props) {
      key3 = subValue;
      subValue = value2[key3];
    }
    assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value2, stack2));
  });
  return result;
}
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value2) {
  return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
function define$1(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend$1(parent, definition2) {
  var prototype2 = Object.create(parent.prototype);
  for (var key2 in definition2) prototype2[key2] = definition2[key2];
  return prototype2;
}
function Color$1() {
}
var darker$1 = 0.7;
var brighter$1 = 1 / darker$1;
var reI$1 = "\\s*([+-]?\\d+)\\s*", reN$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex$1 = /^#([0-9a-f]{3,8})$/, reRgbInteger$1 = new RegExp("^rgb\\(" + [reI$1, reI$1, reI$1] + "\\)$"), reRgbPercent$1 = new RegExp("^rgb\\(" + [reP$1, reP$1, reP$1] + "\\)$"), reRgbaInteger$1 = new RegExp("^rgba\\(" + [reI$1, reI$1, reI$1, reN$1] + "\\)$"), reRgbaPercent$1 = new RegExp("^rgba\\(" + [reP$1, reP$1, reP$1, reN$1] + "\\)$"), reHslPercent$1 = new RegExp("^hsl\\(" + [reN$1, reP$1, reP$1] + "\\)$"), reHslaPercent$1 = new RegExp("^hsla\\(" + [reN$1, reP$1, reP$1, reN$1] + "\\)$");
var named$1 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define$1(Color$1, color$2, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex$1,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex$1,
  formatHsl: color_formatHsl$1,
  formatRgb: color_formatRgb$1,
  toString: color_formatRgb$1
});
function color_formatHex$1() {
  return this.rgb().formatHex();
}
function color_formatHsl$1() {
  return hslConvert$1(this).formatHsl();
}
function color_formatRgb$1() {
  return this.rgb().formatRgb();
}
function color$2(format2) {
  var m2, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex$1.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn$1(m2) : l === 3 ? new Rgb$1(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba$1(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba$1(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger$1.exec(format2)) ? new Rgb$1(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent$1.exec(format2)) ? new Rgb$1(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger$1.exec(format2)) ? rgba$1(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent$1.exec(format2)) ? rgba$1(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent$1.exec(format2)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent$1.exec(format2)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named$1.hasOwnProperty(format2) ? rgbn$1(named$1[format2]) : format2 === "transparent" ? new Rgb$1(NaN, NaN, NaN, 0) : null;
}
function rgbn$1(n) {
  return new Rgb$1(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba$1(r2, g, b2, a2) {
  if (a2 <= 0) r2 = g = b2 = NaN;
  return new Rgb$1(r2, g, b2, a2);
}
function rgbConvert$1(o) {
  if (!(o instanceof Color$1)) o = color$2(o);
  if (!o) return new Rgb$1();
  o = o.rgb();
  return new Rgb$1(o.r, o.g, o.b, o.opacity);
}
function rgb$1(r2, g, b2, opacity2) {
  return arguments.length === 1 ? rgbConvert$1(r2) : new Rgb$1(r2, g, b2, opacity2 == null ? 1 : opacity2);
}
function Rgb$1(r2, g, b2, opacity2) {
  this.r = +r2;
  this.g = +g;
  this.b = +b2;
  this.opacity = +opacity2;
}
define$1(Rgb$1, rgb$1, extend$1(Color$1, {
  brighter: function(k) {
    k = k == null ? brighter$1 : Math.pow(brighter$1, k);
    return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker$1 : Math.pow(darker$1, k);
    return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex$1,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex$1,
  formatRgb: rgb_formatRgb$1,
  toString: rgb_formatRgb$1
}));
function rgb_formatHex$1() {
  return "#" + hex$1(this.r) + hex$1(this.g) + hex$1(this.b);
}
function rgb_formatRgb$1() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex$1(value2) {
  value2 = Math.max(0, Math.min(255, Math.round(value2) || 0));
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla$1(h2, s, l, a2) {
  if (a2 <= 0) h2 = s = l = NaN;
  else if (l <= 0 || l >= 1) h2 = s = NaN;
  else if (s <= 0) h2 = NaN;
  return new Hsl$1(h2, s, l, a2);
}
function hslConvert$1(o) {
  if (o instanceof Hsl$1) return new Hsl$1(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color$1)) o = color$2(o);
  if (!o) return new Hsl$1();
  if (o instanceof Hsl$1) return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b2 = o.b / 255, min2 = Math.min(r2, g, b2), max2 = Math.max(r2, g, b2), h2 = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r2 === max2) h2 = (g - b2) / s + (g < b2) * 6;
    else if (g === max2) h2 = (b2 - r2) / s + 2;
    else h2 = (r2 - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl$1(h2, s, l, o.opacity);
}
function hsl$1(h2, s, l, opacity2) {
  return arguments.length === 1 ? hslConvert$1(h2) : new Hsl$1(h2, s, l, opacity2 == null ? 1 : opacity2);
}
function Hsl$1(h2, s, l, opacity2) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity2;
}
define$1(Hsl$1, hsl$1, extend$1(Color$1, {
  brighter: function(k) {
    k = k == null ? brighter$1 : Math.pow(brighter$1, k);
    return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker$1 : Math.pow(darker$1, k);
    return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb$1(
      hsl2rgb$1(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb$1(h2, m1, m2),
      hsl2rgb$1(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb$1(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant = (x2) => () => x2;
function linear(a2, d) {
  return function(t4) {
    return a2 + t4 * d;
  };
}
function exponential(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t4) {
    return Math.pow(a2 + t4 * b2, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y2) : constant(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d = b2 - a2;
  return d ? linear(a2, d) : constant(isNaN(a2) ? b2 : a2);
}
const interpolateRgb = function rgbGamma2(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r2 = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g = color2(start.g, end.g), b2 = color2(start.b, end.b), opacity2 = nogamma(start.opacity, end.opacity);
    return function(t4) {
      start.r = r2(t4);
      start.g = g(t4);
      start.b = b2(t4);
      start.opacity = opacity2(t4);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma2;
  return rgb2;
}(1);
function numberArray(a2, b2) {
  if (!b2) b2 = [];
  var n = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i;
  return function(t4) {
    for (i = 0; i < n; ++i) c2[i] = a2[i] * (1 - t4) + b2[i] * t4;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a2, b2) {
  var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i) x2[i] = interpolate$1(a2[i], b2[i]);
  for (; i < nb; ++i) c2[i] = b2[i];
  return function(t4) {
    for (i = 0; i < na; ++i) c2[i] = x2[i](t4);
    return c2;
  };
}
function date(a2, b2) {
  var d = /* @__PURE__ */ new Date();
  return a2 = +a2, b2 = +b2, function(t4) {
    return d.setTime(a2 * (1 - t4) + b2 * t4), d;
  };
}
function number(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t4) {
    return a2 * (1 - t4) + b2 * t4;
  };
}
function object(a2, b2) {
  var i = {}, c2 = {}, k;
  if (a2 === null || typeof a2 !== "object") a2 = {};
  if (b2 === null || typeof b2 !== "object") b2 = {};
  for (k in b2) {
    if (k in a2) {
      i[k] = interpolate$1(a2[k], b2[k]);
    } else {
      c2[k] = b2[k];
    }
  }
  return function(t4) {
    for (k in i) c2[k] = i[k](t4);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero$1(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t4) {
    return b2(t4) + "";
  };
}
function string(a2, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero$1(b2) : (b2 = q.length, function(t4) {
    for (var i2 = 0, o; i2 < b2; ++i2) s[(o = q[i2]).i] = o.x(t4);
    return s.join("");
  });
}
function interpolate$1(a2, b2) {
  var t4 = typeof b2, c2;
  return b2 == null || t4 === "boolean" ? constant(b2) : (t4 === "number" ? number : t4 === "string" ? (c2 = color$2(b2)) ? (b2 = c2, interpolateRgb) : string : b2 instanceof color$2 ? interpolateRgb : b2 instanceof Date ? date : isNumberArray(b2) ? numberArray : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object : number)(a2, b2);
}
function piecewise(interpolate2, values2) {
  if (values2 === void 0) values2 = interpolate2, interpolate2 = interpolate$1;
  var i = 0, n = values2.length - 1, v = values2[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate2(v, v = values2[++i]);
  return function(t4) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t4 *= n)));
    return I[i2](t4 - i2);
  };
}
function define(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend(parent, definition2) {
  var prototype2 = Object.create(parent.prototype);
  for (var key2 in definition2) prototype2[key2] = definition2[key2];
  return prototype2;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color$1, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$1(format2) {
  var m2, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r2, g, b2, a2) {
  if (a2 <= 0) r2 = g = b2 = NaN;
  return new Rgb(r2, g, b2, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color$1(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r2, g, b2, opacity2) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b2, opacity2 == null ? 1 : opacity2);
}
function Rgb(r2, g, b2, opacity2) {
  this.r = +r2;
  this.g = +g;
  this.b = +b2;
  this.opacity = +opacity2;
}
define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex(value2) {
  value2 = Math.max(0, Math.min(255, Math.round(value2) || 0));
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h2, s, l, a2) {
  if (a2 <= 0) h2 = s = l = NaN;
  else if (l <= 0 || l >= 1) h2 = s = NaN;
  else if (s <= 0) h2 = NaN;
  return new Hsl(h2, s, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color$1(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b2 = o.b / 255, min2 = Math.min(r2, g, b2), max2 = Math.max(r2, g, b2), h2 = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r2 === max2) h2 = (g - b2) / s + (g < b2) * 6;
    else if (g === max2) h2 = (b2 - r2) / s + 2;
    else h2 = (r2 - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl(h2, s, l, o.opacity);
}
function hsl(h2, s, l, opacity2) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity2 == null ? 1 : opacity2);
}
function Hsl(h2, s, l, opacity2) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity2;
}
define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
var colorScale;
var hasRequiredColorScale;
function requireColorScale() {
  if (hasRequiredColorScale) return colorScale;
  hasRequiredColorScale = 1;
  colorScale = {
    "jet": [{ "index": 0, "rgb": [0, 0, 131] }, { "index": 0.125, "rgb": [0, 60, 170] }, { "index": 0.375, "rgb": [5, 255, 255] }, { "index": 0.625, "rgb": [255, 255, 0] }, { "index": 0.875, "rgb": [250, 0, 0] }, { "index": 1, "rgb": [128, 0, 0] }],
    "hsv": [{ "index": 0, "rgb": [255, 0, 0] }, { "index": 0.169, "rgb": [253, 255, 2] }, { "index": 0.173, "rgb": [247, 255, 2] }, { "index": 0.337, "rgb": [0, 252, 4] }, { "index": 0.341, "rgb": [0, 252, 10] }, { "index": 0.506, "rgb": [1, 249, 255] }, { "index": 0.671, "rgb": [2, 0, 253] }, { "index": 0.675, "rgb": [8, 0, 253] }, { "index": 0.839, "rgb": [255, 0, 251] }, { "index": 0.843, "rgb": [255, 0, 245] }, { "index": 1, "rgb": [255, 0, 6] }],
    "hot": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.3, "rgb": [230, 0, 0] }, { "index": 0.6, "rgb": [255, 210, 0] }, { "index": 1, "rgb": [255, 255, 255] }],
    "spring": [{ "index": 0, "rgb": [255, 0, 255] }, { "index": 1, "rgb": [255, 255, 0] }],
    "summer": [{ "index": 0, "rgb": [0, 128, 102] }, { "index": 1, "rgb": [255, 255, 102] }],
    "autumn": [{ "index": 0, "rgb": [255, 0, 0] }, { "index": 1, "rgb": [255, 255, 0] }],
    "winter": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 1, "rgb": [0, 255, 128] }],
    "bone": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.376, "rgb": [84, 84, 116] }, { "index": 0.753, "rgb": [169, 200, 200] }, { "index": 1, "rgb": [255, 255, 255] }],
    "copper": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.804, "rgb": [255, 160, 102] }, { "index": 1, "rgb": [255, 199, 127] }],
    "greys": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 1, "rgb": [255, 255, 255] }],
    "yignbu": [{ "index": 0, "rgb": [8, 29, 88] }, { "index": 0.125, "rgb": [37, 52, 148] }, { "index": 0.25, "rgb": [34, 94, 168] }, { "index": 0.375, "rgb": [29, 145, 192] }, { "index": 0.5, "rgb": [65, 182, 196] }, { "index": 0.625, "rgb": [127, 205, 187] }, { "index": 0.75, "rgb": [199, 233, 180] }, { "index": 0.875, "rgb": [237, 248, 217] }, { "index": 1, "rgb": [255, 255, 217] }],
    "greens": [{ "index": 0, "rgb": [0, 68, 27] }, { "index": 0.125, "rgb": [0, 109, 44] }, { "index": 0.25, "rgb": [35, 139, 69] }, { "index": 0.375, "rgb": [65, 171, 93] }, { "index": 0.5, "rgb": [116, 196, 118] }, { "index": 0.625, "rgb": [161, 217, 155] }, { "index": 0.75, "rgb": [199, 233, 192] }, { "index": 0.875, "rgb": [229, 245, 224] }, { "index": 1, "rgb": [247, 252, 245] }],
    "yiorrd": [{ "index": 0, "rgb": [128, 0, 38] }, { "index": 0.125, "rgb": [189, 0, 38] }, { "index": 0.25, "rgb": [227, 26, 28] }, { "index": 0.375, "rgb": [252, 78, 42] }, { "index": 0.5, "rgb": [253, 141, 60] }, { "index": 0.625, "rgb": [254, 178, 76] }, { "index": 0.75, "rgb": [254, 217, 118] }, { "index": 0.875, "rgb": [255, 237, 160] }, { "index": 1, "rgb": [255, 255, 204] }],
    "bluered": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 1, "rgb": [255, 0, 0] }],
    "rdbu": [{ "index": 0, "rgb": [5, 10, 172] }, { "index": 0.35, "rgb": [106, 137, 247] }, { "index": 0.5, "rgb": [190, 190, 190] }, { "index": 0.6, "rgb": [220, 170, 132] }, { "index": 0.7, "rgb": [230, 145, 90] }, { "index": 1, "rgb": [178, 10, 28] }],
    "picnic": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 0.1, "rgb": [51, 153, 255] }, { "index": 0.2, "rgb": [102, 204, 255] }, { "index": 0.3, "rgb": [153, 204, 255] }, { "index": 0.4, "rgb": [204, 204, 255] }, { "index": 0.5, "rgb": [255, 255, 255] }, { "index": 0.6, "rgb": [255, 204, 255] }, { "index": 0.7, "rgb": [255, 153, 255] }, { "index": 0.8, "rgb": [255, 102, 204] }, { "index": 0.9, "rgb": [255, 102, 102] }, { "index": 1, "rgb": [255, 0, 0] }],
    "rainbow": [{ "index": 0, "rgb": [150, 0, 90] }, { "index": 0.125, "rgb": [0, 0, 200] }, { "index": 0.25, "rgb": [0, 25, 255] }, { "index": 0.375, "rgb": [0, 152, 255] }, { "index": 0.5, "rgb": [44, 255, 150] }, { "index": 0.625, "rgb": [151, 255, 0] }, { "index": 0.75, "rgb": [255, 234, 0] }, { "index": 0.875, "rgb": [255, 111, 0] }, { "index": 1, "rgb": [255, 0, 0] }],
    "portland": [{ "index": 0, "rgb": [12, 51, 131] }, { "index": 0.25, "rgb": [10, 136, 186] }, { "index": 0.5, "rgb": [242, 211, 56] }, { "index": 0.75, "rgb": [242, 143, 56] }, { "index": 1, "rgb": [217, 30, 30] }],
    "blackbody": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.2, "rgb": [230, 0, 0] }, { "index": 0.4, "rgb": [230, 210, 0] }, { "index": 0.7, "rgb": [255, 255, 255] }, { "index": 1, "rgb": [160, 200, 255] }],
    "earth": [{ "index": 0, "rgb": [0, 0, 130] }, { "index": 0.1, "rgb": [0, 180, 180] }, { "index": 0.2, "rgb": [40, 210, 40] }, { "index": 0.4, "rgb": [230, 230, 50] }, { "index": 0.6, "rgb": [120, 70, 20] }, { "index": 1, "rgb": [255, 255, 255] }],
    "electric": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.15, "rgb": [30, 0, 100] }, { "index": 0.4, "rgb": [120, 0, 100] }, { "index": 0.6, "rgb": [160, 90, 0] }, { "index": 0.8, "rgb": [230, 200, 0] }, { "index": 1, "rgb": [255, 250, 220] }],
    "alpha": [{ "index": 0, "rgb": [255, 255, 255, 0] }, { "index": 1, "rgb": [255, 255, 255, 1] }],
    "viridis": [{ "index": 0, "rgb": [68, 1, 84] }, { "index": 0.13, "rgb": [71, 44, 122] }, { "index": 0.25, "rgb": [59, 81, 139] }, { "index": 0.38, "rgb": [44, 113, 142] }, { "index": 0.5, "rgb": [33, 144, 141] }, { "index": 0.63, "rgb": [39, 173, 129] }, { "index": 0.75, "rgb": [92, 200, 99] }, { "index": 0.88, "rgb": [170, 220, 50] }, { "index": 1, "rgb": [253, 231, 37] }],
    "inferno": [{ "index": 0, "rgb": [0, 0, 4] }, { "index": 0.13, "rgb": [31, 12, 72] }, { "index": 0.25, "rgb": [85, 15, 109] }, { "index": 0.38, "rgb": [136, 34, 106] }, { "index": 0.5, "rgb": [186, 54, 85] }, { "index": 0.63, "rgb": [227, 89, 51] }, { "index": 0.75, "rgb": [249, 140, 10] }, { "index": 0.88, "rgb": [249, 201, 50] }, { "index": 1, "rgb": [252, 255, 164] }],
    "magma": [{ "index": 0, "rgb": [0, 0, 4] }, { "index": 0.13, "rgb": [28, 16, 68] }, { "index": 0.25, "rgb": [79, 18, 123] }, { "index": 0.38, "rgb": [129, 37, 129] }, { "index": 0.5, "rgb": [181, 54, 122] }, { "index": 0.63, "rgb": [229, 80, 100] }, { "index": 0.75, "rgb": [251, 135, 97] }, { "index": 0.88, "rgb": [254, 194, 135] }, { "index": 1, "rgb": [252, 253, 191] }],
    "plasma": [{ "index": 0, "rgb": [13, 8, 135] }, { "index": 0.13, "rgb": [75, 3, 161] }, { "index": 0.25, "rgb": [125, 3, 168] }, { "index": 0.38, "rgb": [168, 34, 150] }, { "index": 0.5, "rgb": [203, 70, 121] }, { "index": 0.63, "rgb": [229, 107, 93] }, { "index": 0.75, "rgb": [248, 148, 65] }, { "index": 0.88, "rgb": [253, 195, 40] }, { "index": 1, "rgb": [240, 249, 33] }],
    "warm": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.13, "rgb": [172, 0, 187] }, { "index": 0.25, "rgb": [219, 0, 170] }, { "index": 0.38, "rgb": [255, 0, 130] }, { "index": 0.5, "rgb": [255, 63, 74] }, { "index": 0.63, "rgb": [255, 123, 0] }, { "index": 0.75, "rgb": [234, 176, 0] }, { "index": 0.88, "rgb": [190, 228, 0] }, { "index": 1, "rgb": [147, 255, 0] }],
    "cool": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.13, "rgb": [116, 0, 218] }, { "index": 0.25, "rgb": [98, 74, 237] }, { "index": 0.38, "rgb": [68, 146, 231] }, { "index": 0.5, "rgb": [0, 204, 197] }, { "index": 0.63, "rgb": [0, 247, 146] }, { "index": 0.75, "rgb": [0, 255, 88] }, { "index": 0.88, "rgb": [40, 255, 8] }, { "index": 1, "rgb": [147, 255, 0] }],
    "rainbow-soft": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.1, "rgb": [199, 0, 180] }, { "index": 0.2, "rgb": [255, 0, 121] }, { "index": 0.3, "rgb": [255, 108, 0] }, { "index": 0.4, "rgb": [222, 194, 0] }, { "index": 0.5, "rgb": [150, 255, 0] }, { "index": 0.6, "rgb": [0, 255, 55] }, { "index": 0.7, "rgb": [0, 246, 150] }, { "index": 0.8, "rgb": [50, 167, 222] }, { "index": 0.9, "rgb": [103, 51, 235] }, { "index": 1, "rgb": [124, 0, 186] }],
    "bathymetry": [{ "index": 0, "rgb": [40, 26, 44] }, { "index": 0.13, "rgb": [59, 49, 90] }, { "index": 0.25, "rgb": [64, 76, 139] }, { "index": 0.38, "rgb": [63, 110, 151] }, { "index": 0.5, "rgb": [72, 142, 158] }, { "index": 0.63, "rgb": [85, 174, 163] }, { "index": 0.75, "rgb": [120, 206, 163] }, { "index": 0.88, "rgb": [187, 230, 172] }, { "index": 1, "rgb": [253, 254, 204] }],
    "cdom": [{ "index": 0, "rgb": [47, 15, 62] }, { "index": 0.13, "rgb": [87, 23, 86] }, { "index": 0.25, "rgb": [130, 28, 99] }, { "index": 0.38, "rgb": [171, 41, 96] }, { "index": 0.5, "rgb": [206, 67, 86] }, { "index": 0.63, "rgb": [230, 106, 84] }, { "index": 0.75, "rgb": [242, 149, 103] }, { "index": 0.88, "rgb": [249, 193, 135] }, { "index": 1, "rgb": [254, 237, 176] }],
    "chlorophyll": [{ "index": 0, "rgb": [18, 36, 20] }, { "index": 0.13, "rgb": [25, 63, 41] }, { "index": 0.25, "rgb": [24, 91, 59] }, { "index": 0.38, "rgb": [13, 119, 72] }, { "index": 0.5, "rgb": [18, 148, 80] }, { "index": 0.63, "rgb": [80, 173, 89] }, { "index": 0.75, "rgb": [132, 196, 122] }, { "index": 0.88, "rgb": [175, 221, 162] }, { "index": 1, "rgb": [215, 249, 208] }],
    "density": [{ "index": 0, "rgb": [54, 14, 36] }, { "index": 0.13, "rgb": [89, 23, 80] }, { "index": 0.25, "rgb": [110, 45, 132] }, { "index": 0.38, "rgb": [120, 77, 178] }, { "index": 0.5, "rgb": [120, 113, 213] }, { "index": 0.63, "rgb": [115, 151, 228] }, { "index": 0.75, "rgb": [134, 185, 227] }, { "index": 0.88, "rgb": [177, 214, 227] }, { "index": 1, "rgb": [230, 241, 241] }],
    "freesurface-blue": [{ "index": 0, "rgb": [30, 4, 110] }, { "index": 0.13, "rgb": [47, 14, 176] }, { "index": 0.25, "rgb": [41, 45, 236] }, { "index": 0.38, "rgb": [25, 99, 212] }, { "index": 0.5, "rgb": [68, 131, 200] }, { "index": 0.63, "rgb": [114, 156, 197] }, { "index": 0.75, "rgb": [157, 181, 203] }, { "index": 0.88, "rgb": [200, 208, 216] }, { "index": 1, "rgb": [241, 237, 236] }],
    "freesurface-red": [{ "index": 0, "rgb": [60, 9, 18] }, { "index": 0.13, "rgb": [100, 17, 27] }, { "index": 0.25, "rgb": [142, 20, 29] }, { "index": 0.38, "rgb": [177, 43, 27] }, { "index": 0.5, "rgb": [192, 87, 63] }, { "index": 0.63, "rgb": [205, 125, 105] }, { "index": 0.75, "rgb": [216, 162, 148] }, { "index": 0.88, "rgb": [227, 199, 193] }, { "index": 1, "rgb": [241, 237, 236] }],
    "oxygen": [{ "index": 0, "rgb": [64, 5, 5] }, { "index": 0.13, "rgb": [106, 6, 15] }, { "index": 0.25, "rgb": [144, 26, 7] }, { "index": 0.38, "rgb": [168, 64, 3] }, { "index": 0.5, "rgb": [188, 100, 4] }, { "index": 0.63, "rgb": [206, 136, 11] }, { "index": 0.75, "rgb": [220, 174, 25] }, { "index": 0.88, "rgb": [231, 215, 44] }, { "index": 1, "rgb": [248, 254, 105] }],
    "par": [{ "index": 0, "rgb": [51, 20, 24] }, { "index": 0.13, "rgb": [90, 32, 35] }, { "index": 0.25, "rgb": [129, 44, 34] }, { "index": 0.38, "rgb": [159, 68, 25] }, { "index": 0.5, "rgb": [182, 99, 19] }, { "index": 0.63, "rgb": [199, 134, 22] }, { "index": 0.75, "rgb": [212, 171, 35] }, { "index": 0.88, "rgb": [221, 210, 54] }, { "index": 1, "rgb": [225, 253, 75] }],
    "phase": [{ "index": 0, "rgb": [145, 105, 18] }, { "index": 0.13, "rgb": [184, 71, 38] }, { "index": 0.25, "rgb": [186, 58, 115] }, { "index": 0.38, "rgb": [160, 71, 185] }, { "index": 0.5, "rgb": [110, 97, 218] }, { "index": 0.63, "rgb": [50, 123, 164] }, { "index": 0.75, "rgb": [31, 131, 110] }, { "index": 0.88, "rgb": [77, 129, 34] }, { "index": 1, "rgb": [145, 105, 18] }],
    "salinity": [{ "index": 0, "rgb": [42, 24, 108] }, { "index": 0.13, "rgb": [33, 50, 162] }, { "index": 0.25, "rgb": [15, 90, 145] }, { "index": 0.38, "rgb": [40, 118, 137] }, { "index": 0.5, "rgb": [59, 146, 135] }, { "index": 0.63, "rgb": [79, 175, 126] }, { "index": 0.75, "rgb": [120, 203, 104] }, { "index": 0.88, "rgb": [193, 221, 100] }, { "index": 1, "rgb": [253, 239, 154] }],
    "temperature": [{ "index": 0, "rgb": [4, 35, 51] }, { "index": 0.13, "rgb": [23, 51, 122] }, { "index": 0.25, "rgb": [85, 59, 157] }, { "index": 0.38, "rgb": [129, 79, 143] }, { "index": 0.5, "rgb": [175, 95, 130] }, { "index": 0.63, "rgb": [222, 112, 101] }, { "index": 0.75, "rgb": [249, 146, 66] }, { "index": 0.88, "rgb": [249, 196, 65] }, { "index": 1, "rgb": [232, 250, 91] }],
    "turbidity": [{ "index": 0, "rgb": [34, 31, 27] }, { "index": 0.13, "rgb": [65, 50, 41] }, { "index": 0.25, "rgb": [98, 69, 52] }, { "index": 0.38, "rgb": [131, 89, 57] }, { "index": 0.5, "rgb": [161, 112, 59] }, { "index": 0.63, "rgb": [185, 140, 66] }, { "index": 0.75, "rgb": [202, 174, 88] }, { "index": 0.88, "rgb": [216, 209, 126] }, { "index": 1, "rgb": [233, 246, 171] }],
    "velocity-blue": [{ "index": 0, "rgb": [17, 32, 64] }, { "index": 0.13, "rgb": [35, 52, 116] }, { "index": 0.25, "rgb": [29, 81, 156] }, { "index": 0.38, "rgb": [31, 113, 162] }, { "index": 0.5, "rgb": [50, 144, 169] }, { "index": 0.63, "rgb": [87, 173, 176] }, { "index": 0.75, "rgb": [149, 196, 189] }, { "index": 0.88, "rgb": [203, 221, 211] }, { "index": 1, "rgb": [254, 251, 230] }],
    "velocity-green": [{ "index": 0, "rgb": [23, 35, 19] }, { "index": 0.13, "rgb": [24, 64, 38] }, { "index": 0.25, "rgb": [11, 95, 45] }, { "index": 0.38, "rgb": [39, 123, 35] }, { "index": 0.5, "rgb": [95, 146, 12] }, { "index": 0.63, "rgb": [152, 165, 18] }, { "index": 0.75, "rgb": [201, 186, 69] }, { "index": 0.88, "rgb": [233, 216, 137] }, { "index": 1, "rgb": [255, 253, 205] }],
    "cubehelix": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.07, "rgb": [22, 5, 59] }, { "index": 0.13, "rgb": [60, 4, 105] }, { "index": 0.2, "rgb": [109, 1, 135] }, { "index": 0.27, "rgb": [161, 0, 147] }, { "index": 0.33, "rgb": [210, 2, 142] }, { "index": 0.4, "rgb": [251, 11, 123] }, { "index": 0.47, "rgb": [255, 29, 97] }, { "index": 0.53, "rgb": [255, 54, 69] }, { "index": 0.6, "rgb": [255, 85, 46] }, { "index": 0.67, "rgb": [255, 120, 34] }, { "index": 0.73, "rgb": [255, 157, 37] }, { "index": 0.8, "rgb": [241, 191, 57] }, { "index": 0.87, "rgb": [224, 220, 93] }, { "index": 0.93, "rgb": [218, 241, 142] }, { "index": 1, "rgb": [227, 253, 198] }]
  };
  return colorScale;
}
var colorScaleExports = requireColorScale();
const colormaps = /* @__PURE__ */ getDefaultExportFromCjs(colorScaleExports);
function getInterpolateFunction(cmap) {
  const colormapData = colormaps[cmap].map((d) => d.rgb);
  const colormapRgb = colormapData.map((x2) => rgb(...x2));
  return piecewise(interpolateRgb, colormapRgb);
}
makeStyles()(() => ({
  legend: {
    top: "2px",
    right: "2px",
    fontSize: "10px !important",
    flexDirection: "column",
    backgroundColor: "rgba(215, 215, 215, 0.7)",
    borderRadius: "4px",
    padding: "2px",
    lineHeight: "10px !important",
    "& svg": {
      top: 0,
      left: 0,
      position: "relative"
    }
  },
  legendAbsolute: {
    position: "absolute",
    display: "inline-block"
  },
  legendRelative: {
    position: "relative",
    marginBottom: "2px",
    display: "block"
  },
  legendHighContrast: {
    backgroundColor: "rgba(215, 215, 215, 0.7)"
  },
  legendLowContrast: {
    backgroundColor: "rgba(215, 215, 215, 0.2)"
  },
  legendInvisible: {
    display: "none"
  }
}));
makeStyles()(() => ({
  multiLegend: {
    position: "absolute",
    top: "0px",
    right: "0px"
  }
}));
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]];
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset2) {
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
var concaveman = { exports: {} };
var rbush_min$1 = { exports: {} };
var rbush_min = rbush_min$1.exports;
var hasRequiredRbush_min;
function requireRbush_min() {
  if (hasRequiredRbush_min) return rbush_min$1.exports;
  hasRequiredRbush_min = 1;
  (function(module2, exports2) {
    !function(t4, i) {
      module2.exports = i();
    }(rbush_min, function() {
      function t4(t5, r3, e4, a3, h3) {
        !function t6(n2, r4, e6, a4, h4) {
          for (; a4 > e6; ) {
            if (a4 - e6 > 600) {
              var o2 = a4 - e6 + 1, s2 = r4 - e6 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u3 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m3 = Math.max(e6, Math.floor(r4 - s2 * f2 / o2 + u3)), c3 = Math.min(a4, Math.floor(r4 + (o2 - s2) * f2 / o2 + u3));
              t6(n2, r4, m3, c3, h4);
            }
            var p2 = n2[r4], d2 = e6, x2 = a4;
            for (i(n2, e6, r4), h4(n2[a4], p2) > 0 && i(n2, e6, a4); d2 < x2; ) {
              for (i(n2, d2, x2), d2++, x2--; h4(n2[d2], p2) < 0; ) d2++;
              for (; h4(n2[x2], p2) > 0; ) x2--;
            }
            0 === h4(n2[e6], p2) ? i(n2, e6, x2) : i(n2, ++x2, a4), x2 <= r4 && (e6 = x2 + 1), r4 <= x2 && (a4 = x2 - 1);
          }
        }(t5, r3, e4 || 0, a3 || t5.length - 1, h3 || n);
      }
      function i(t5, i2, n2) {
        var r3 = t5[i2];
        t5[i2] = t5[n2], t5[n2] = r3;
      }
      function n(t5, i2) {
        return t5 < i2 ? -1 : t5 > i2 ? 1 : 0;
      }
      var r2 = function(t5) {
        void 0 === t5 && (t5 = 9), this._maxEntries = Math.max(4, t5), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
      };
      function e3(t5, i2, n2) {
        if (!n2) return i2.indexOf(t5);
        for (var r3 = 0; r3 < i2.length; r3++) if (n2(t5, i2[r3])) return r3;
        return -1;
      }
      function a2(t5, i2) {
        h2(t5, 0, t5.children.length, i2, t5);
      }
      function h2(t5, i2, n2, r3, e4) {
        e4 || (e4 = p(null)), e4.minX = 1 / 0, e4.minY = 1 / 0, e4.maxX = -1 / 0, e4.maxY = -1 / 0;
        for (var a3 = i2; a3 < n2; a3++) {
          var h3 = t5.children[a3];
          o(e4, t5.leaf ? r3(h3) : h3);
        }
        return e4;
      }
      function o(t5, i2) {
        return t5.minX = Math.min(t5.minX, i2.minX), t5.minY = Math.min(t5.minY, i2.minY), t5.maxX = Math.max(t5.maxX, i2.maxX), t5.maxY = Math.max(t5.maxY, i2.maxY), t5;
      }
      function s(t5, i2) {
        return t5.minX - i2.minX;
      }
      function l(t5, i2) {
        return t5.minY - i2.minY;
      }
      function f(t5) {
        return (t5.maxX - t5.minX) * (t5.maxY - t5.minY);
      }
      function u2(t5) {
        return t5.maxX - t5.minX + (t5.maxY - t5.minY);
      }
      function m2(t5, i2) {
        return t5.minX <= i2.minX && t5.minY <= i2.minY && i2.maxX <= t5.maxX && i2.maxY <= t5.maxY;
      }
      function c2(t5, i2) {
        return i2.minX <= t5.maxX && i2.minY <= t5.maxY && i2.maxX >= t5.minX && i2.maxY >= t5.minY;
      }
      function p(t5) {
        return { children: t5, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function d(i2, n2, r3, e4, a3) {
        for (var h3 = [n2, r3]; h3.length; ) if (!((r3 = h3.pop()) - (n2 = h3.pop()) <= e4)) {
          var o2 = n2 + Math.ceil((r3 - n2) / e4 / 2) * e4;
          t4(i2, o2, n2, r3, a3), h3.push(n2, o2, o2, r3);
        }
      }
      return r2.prototype.all = function() {
        return this._all(this.data, []);
      }, r2.prototype.search = function(t5) {
        var i2 = this.data, n2 = [];
        if (!c2(t5, i2)) return n2;
        for (var r3 = this.toBBox, e4 = []; i2; ) {
          for (var a3 = 0; a3 < i2.children.length; a3++) {
            var h3 = i2.children[a3], o2 = i2.leaf ? r3(h3) : h3;
            c2(t5, o2) && (i2.leaf ? n2.push(h3) : m2(t5, o2) ? this._all(h3, n2) : e4.push(h3));
          }
          i2 = e4.pop();
        }
        return n2;
      }, r2.prototype.collides = function(t5) {
        var i2 = this.data;
        if (!c2(t5, i2)) return false;
        for (var n2 = []; i2; ) {
          for (var r3 = 0; r3 < i2.children.length; r3++) {
            var e4 = i2.children[r3], a3 = i2.leaf ? this.toBBox(e4) : e4;
            if (c2(t5, a3)) {
              if (i2.leaf || m2(t5, a3)) return true;
              n2.push(e4);
            }
          }
          i2 = n2.pop();
        }
        return false;
      }, r2.prototype.load = function(t5) {
        if (!t5 || !t5.length) return this;
        if (t5.length < this._minEntries) {
          for (var i2 = 0; i2 < t5.length; i2++) this.insert(t5[i2]);
          return this;
        }
        var n2 = this._build(t5.slice(), 0, t5.length - 1, 0);
        if (this.data.children.length) if (this.data.height === n2.height) this._splitRoot(this.data, n2);
        else {
          if (this.data.height < n2.height) {
            var r3 = this.data;
            this.data = n2, n2 = r3;
          }
          this._insert(n2, this.data.height - n2.height - 1, true);
        }
        else this.data = n2;
        return this;
      }, r2.prototype.insert = function(t5) {
        return t5 && this._insert(t5, this.data.height - 1), this;
      }, r2.prototype.clear = function() {
        return this.data = p([]), this;
      }, r2.prototype.remove = function(t5, i2) {
        if (!t5) return this;
        for (var n2, r3, a3, h3 = this.data, o2 = this.toBBox(t5), s2 = [], l2 = []; h3 || s2.length; ) {
          if (h3 || (h3 = s2.pop(), r3 = s2[s2.length - 1], n2 = l2.pop(), a3 = true), h3.leaf) {
            var f2 = e3(t5, h3.children, i2);
            if (-1 !== f2) return h3.children.splice(f2, 1), s2.push(h3), this._condense(s2), this;
          }
          a3 || h3.leaf || !m2(h3, o2) ? r3 ? (n2++, h3 = r3.children[n2], a3 = false) : h3 = null : (s2.push(h3), l2.push(n2), n2 = 0, r3 = h3, h3 = h3.children[0]);
        }
        return this;
      }, r2.prototype.toBBox = function(t5) {
        return t5;
      }, r2.prototype.compareMinX = function(t5, i2) {
        return t5.minX - i2.minX;
      }, r2.prototype.compareMinY = function(t5, i2) {
        return t5.minY - i2.minY;
      }, r2.prototype.toJSON = function() {
        return this.data;
      }, r2.prototype.fromJSON = function(t5) {
        return this.data = t5, this;
      }, r2.prototype._all = function(t5, i2) {
        for (var n2 = []; t5; ) t5.leaf ? i2.push.apply(i2, t5.children) : n2.push.apply(n2, t5.children), t5 = n2.pop();
        return i2;
      }, r2.prototype._build = function(t5, i2, n2, r3) {
        var e4, h3 = n2 - i2 + 1, o2 = this._maxEntries;
        if (h3 <= o2) return a2(e4 = p(t5.slice(i2, n2 + 1)), this.toBBox), e4;
        r3 || (r3 = Math.ceil(Math.log(h3) / Math.log(o2)), o2 = Math.ceil(h3 / Math.pow(o2, r3 - 1))), (e4 = p([])).leaf = false, e4.height = r3;
        var s2 = Math.ceil(h3 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
        d(t5, i2, n2, l2, this.compareMinX);
        for (var f2 = i2; f2 <= n2; f2 += l2) {
          var u3 = Math.min(f2 + l2 - 1, n2);
          d(t5, f2, u3, s2, this.compareMinY);
          for (var m3 = f2; m3 <= u3; m3 += s2) {
            var c3 = Math.min(m3 + s2 - 1, u3);
            e4.children.push(this._build(t5, m3, c3, r3 - 1));
          }
        }
        return a2(e4, this.toBBox), e4;
      }, r2.prototype._chooseSubtree = function(t5, i2, n2, r3) {
        for (; r3.push(i2), !i2.leaf && r3.length - 1 !== n2; ) {
          for (var e4 = 1 / 0, a3 = 1 / 0, h3 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
            var s2 = i2.children[o2], l2 = f(s2), u3 = (m3 = t5, c3 = s2, (Math.max(c3.maxX, m3.maxX) - Math.min(c3.minX, m3.minX)) * (Math.max(c3.maxY, m3.maxY) - Math.min(c3.minY, m3.minY)) - l2);
            u3 < a3 ? (a3 = u3, e4 = l2 < e4 ? l2 : e4, h3 = s2) : u3 === a3 && l2 < e4 && (e4 = l2, h3 = s2);
          }
          i2 = h3 || i2.children[0];
        }
        var m3, c3;
        return i2;
      }, r2.prototype._insert = function(t5, i2, n2) {
        var r3 = n2 ? t5 : this.toBBox(t5), e4 = [], a3 = this._chooseSubtree(r3, this.data, i2, e4);
        for (a3.children.push(t5), o(a3, r3); i2 >= 0 && e4[i2].children.length > this._maxEntries; ) this._split(e4, i2), i2--;
        this._adjustParentBBoxes(r3, e4, i2);
      }, r2.prototype._split = function(t5, i2) {
        var n2 = t5[i2], r3 = n2.children.length, e4 = this._minEntries;
        this._chooseSplitAxis(n2, e4, r3);
        var h3 = this._chooseSplitIndex(n2, e4, r3), o2 = p(n2.children.splice(h3, n2.children.length - h3));
        o2.height = n2.height, o2.leaf = n2.leaf, a2(n2, this.toBBox), a2(o2, this.toBBox), i2 ? t5[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
      }, r2.prototype._splitRoot = function(t5, i2) {
        this.data = p([t5, i2]), this.data.height = t5.height + 1, this.data.leaf = false, a2(this.data, this.toBBox);
      }, r2.prototype._chooseSplitIndex = function(t5, i2, n2) {
        for (var r3, e4, a3, o2, s2, l2, u3, m3 = 1 / 0, c3 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
          var d2 = h2(t5, 0, p2, this.toBBox), x2 = h2(t5, p2, n2, this.toBBox), v = (e4 = d2, a3 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u3 = void 0, o2 = Math.max(e4.minX, a3.minX), s2 = Math.max(e4.minY, a3.minY), l2 = Math.min(e4.maxX, a3.maxX), u3 = Math.min(e4.maxY, a3.maxY), Math.max(0, l2 - o2) * Math.max(0, u3 - s2)), M2 = f(d2) + f(x2);
          v < m3 ? (m3 = v, r3 = p2, c3 = M2 < c3 ? M2 : c3) : v === m3 && M2 < c3 && (c3 = M2, r3 = p2);
        }
        return r3 || n2 - i2;
      }, r2.prototype._chooseSplitAxis = function(t5, i2, n2) {
        var r3 = t5.leaf ? this.compareMinX : s, e4 = t5.leaf ? this.compareMinY : l;
        this._allDistMargin(t5, i2, n2, r3) < this._allDistMargin(t5, i2, n2, e4) && t5.children.sort(r3);
      }, r2.prototype._allDistMargin = function(t5, i2, n2, r3) {
        t5.children.sort(r3);
        for (var e4 = this.toBBox, a3 = h2(t5, 0, i2, e4), s2 = h2(t5, n2 - i2, n2, e4), l2 = u2(a3) + u2(s2), f2 = i2; f2 < n2 - i2; f2++) {
          var m3 = t5.children[f2];
          o(a3, t5.leaf ? e4(m3) : m3), l2 += u2(a3);
        }
        for (var c3 = n2 - i2 - 1; c3 >= i2; c3--) {
          var p2 = t5.children[c3];
          o(s2, t5.leaf ? e4(p2) : p2), l2 += u2(s2);
        }
        return l2;
      }, r2.prototype._adjustParentBBoxes = function(t5, i2, n2) {
        for (var r3 = n2; r3 >= 0; r3--) o(i2[r3], t5);
      }, r2.prototype._condense = function(t5) {
        for (var i2 = t5.length - 1, n2 = void 0; i2 >= 0; i2--) 0 === t5[i2].children.length ? i2 > 0 ? (n2 = t5[i2 - 1].children).splice(n2.indexOf(t5[i2]), 1) : this.clear() : a2(t5[i2], this.toBBox);
      }, r2;
    });
  })(rbush_min$1);
  return rbush_min$1.exports;
}
class TinyQueue {
  constructor(data2 = [], compare2 = defaultCompare) {
    this.data = data2;
    this.length = this.data.length;
    this.compare = compare2;
    if (this.length > 0) {
      for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
  }
  push(item) {
    this.data.push(item);
    this.length++;
    this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return void 0;
    const top = this.data[0];
    const bottom = this.data.pop();
    this.length--;
    if (this.length > 0) {
      this.data[0] = bottom;
      this._down(0);
    }
    return top;
  }
  peek() {
    return this.data[0];
  }
  _up(pos) {
    const { data: data2, compare: compare2 } = this;
    const item = data2[pos];
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const current2 = data2[parent];
      if (compare2(item, current2) >= 0) break;
      data2[pos] = current2;
      pos = parent;
    }
    data2[pos] = item;
  }
  _down(pos) {
    const { data: data2, compare: compare2 } = this;
    const halfLength = this.length >> 1;
    const item = data2[pos];
    while (pos < halfLength) {
      let left = (pos << 1) + 1;
      let best = data2[left];
      const right = left + 1;
      if (right < this.length && compare2(data2[right], best) < 0) {
        left = right;
        best = data2[right];
      }
      if (compare2(best, item) >= 0) break;
      data2[pos] = best;
      pos = left;
    }
    data2[pos] = item;
  }
}
function defaultCompare(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
}
const tinyqueue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: TinyQueue
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(tinyqueue);
var pointInPolygon = { exports: {} };
var flat;
var hasRequiredFlat;
function requireFlat() {
  if (hasRequiredFlat) return flat;
  hasRequiredFlat = 1;
  flat = function pointInPolygonFlat(point2, vs, start, end) {
    var x2 = point2[0], y2 = point2[1];
    var inside = false;
    if (start === void 0) start = 0;
    if (end === void 0) end = vs.length;
    var len = (end - start) / 2;
    for (var i = 0, j = len - 1; i < len; j = i++) {
      var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
      var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
      var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
      if (intersect2) inside = !inside;
    }
    return inside;
  };
  return flat;
}
var nested;
var hasRequiredNested;
function requireNested() {
  if (hasRequiredNested) return nested;
  hasRequiredNested = 1;
  nested = function pointInPolygonNested(point2, vs, start, end) {
    var x2 = point2[0], y2 = point2[1];
    var inside = false;
    if (start === void 0) start = 0;
    if (end === void 0) end = vs.length;
    var len = end - start;
    for (var i = 0, j = len - 1; i < len; j = i++) {
      var xi = vs[i + start][0], yi = vs[i + start][1];
      var xj = vs[j + start][0], yj = vs[j + start][1];
      var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
      if (intersect2) inside = !inside;
    }
    return inside;
  };
  return nested;
}
var hasRequiredPointInPolygon;
function requirePointInPolygon() {
  if (hasRequiredPointInPolygon) return pointInPolygon.exports;
  hasRequiredPointInPolygon = 1;
  var pointInPolygonFlat = requireFlat();
  var pointInPolygonNested = requireNested();
  pointInPolygon.exports = function pointInPolygon2(point2, vs, start, end) {
    if (vs.length > 0 && Array.isArray(vs[0])) {
      return pointInPolygonNested(point2, vs, start, end);
    } else {
      return pointInPolygonFlat(point2, vs, start, end);
    }
  };
  pointInPolygon.exports.nested = pointInPolygonNested;
  pointInPolygon.exports.flat = pointInPolygonFlat;
  return pointInPolygon.exports;
}
var orient2d_min$1 = { exports: {} };
var orient2d_min = orient2d_min$1.exports;
var hasRequiredOrient2d_min;
function requireOrient2d_min() {
  if (hasRequiredOrient2d_min) return orient2d_min$1.exports;
  hasRequiredOrient2d_min = 1;
  (function(module2, exports2) {
    !function(t4, e3) {
      e3(exports2);
    }(orient2d_min, function(t4) {
      const e3 = 134217729, n = 33306690738754706e-32;
      function r2(t5, e4, n2, r3, o2) {
        let f2, i2, u3, c3, s2 = e4[0], a3 = r3[0], d2 = 0, l2 = 0;
        a3 > s2 == a3 > -s2 ? (f2 = s2, s2 = e4[++d2]) : (f2 = a3, a3 = r3[++l2]);
        let p = 0;
        if (d2 < t5 && l2 < n2) for (a3 > s2 == a3 > -s2 ? (u3 = f2 - ((i2 = s2 + f2) - s2), s2 = e4[++d2]) : (u3 = f2 - ((i2 = a3 + f2) - a3), a3 = r3[++l2]), f2 = i2, 0 !== u3 && (o2[p++] = u3); d2 < t5 && l2 < n2; ) a3 > s2 == a3 > -s2 ? (u3 = f2 - ((i2 = f2 + s2) - (c3 = i2 - f2)) + (s2 - c3), s2 = e4[++d2]) : (u3 = f2 - ((i2 = f2 + a3) - (c3 = i2 - f2)) + (a3 - c3), a3 = r3[++l2]), f2 = i2, 0 !== u3 && (o2[p++] = u3);
        for (; d2 < t5; ) u3 = f2 - ((i2 = f2 + s2) - (c3 = i2 - f2)) + (s2 - c3), s2 = e4[++d2], f2 = i2, 0 !== u3 && (o2[p++] = u3);
        for (; l2 < n2; ) u3 = f2 - ((i2 = f2 + a3) - (c3 = i2 - f2)) + (a3 - c3), a3 = r3[++l2], f2 = i2, 0 !== u3 && (o2[p++] = u3);
        return 0 === f2 && 0 !== p || (o2[p++] = f2), p;
      }
      function o(t5) {
        return new Float64Array(t5);
      }
      const f = 33306690738754716e-32, i = 22204460492503146e-32, u2 = 11093356479670487e-47, c2 = o(4), s = o(8), a2 = o(12), d = o(16), l = o(4);
      t4.orient2d = function(t5, o2, p, b2, y2, h2) {
        const M2 = (o2 - h2) * (p - y2), x2 = (t5 - y2) * (b2 - h2), j = M2 - x2;
        if (0 === M2 || 0 === x2 || M2 > 0 != x2 > 0) return j;
        const m2 = Math.abs(M2 + x2);
        return Math.abs(j) >= f * m2 ? j : -function(t6, o3, f2, p2, b3, y3, h3) {
          let M3, x3, j2, m3, _, v, w2, A5, F, O, P, g, k, q, z2, B2, C3, D2;
          const E2 = t6 - b3, G = f2 - b3, H = o3 - y3, I = p2 - y3;
          _ = (z2 = (A5 = E2 - (w2 = (v = e3 * E2) - (v - E2))) * (O = I - (F = (v = e3 * I) - (v - I))) - ((q = E2 * I) - w2 * F - A5 * F - w2 * O)) - (P = z2 - (C3 = (A5 = H - (w2 = (v = e3 * H) - (v - H))) * (O = G - (F = (v = e3 * G) - (v - G))) - ((B2 = H * G) - w2 * F - A5 * F - w2 * O))), c2[0] = z2 - (P + _) + (_ - C3), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), c2[1] = k - (P + _) + (_ - B2), _ = (D2 = g + P) - g, c2[2] = g - (D2 - _) + (P - _), c2[3] = D2;
          let J = function(t7, e4) {
            let n2 = e4[0];
            for (let r3 = 1; r3 < t7; r3++) n2 += e4[r3];
            return n2;
          }(4, c2), K2 = i * h3;
          if (J >= K2 || -J >= K2) return J;
          if (M3 = t6 - (E2 + (_ = t6 - E2)) + (_ - b3), j2 = f2 - (G + (_ = f2 - G)) + (_ - b3), x3 = o3 - (H + (_ = o3 - H)) + (_ - y3), m3 = p2 - (I + (_ = p2 - I)) + (_ - y3), 0 === M3 && 0 === x3 && 0 === j2 && 0 === m3) return J;
          if (K2 = u2 * h3 + n * Math.abs(J), (J += E2 * m3 + I * M3 - (H * j2 + G * x3)) >= K2 || -J >= K2) return J;
          _ = (z2 = (A5 = M3 - (w2 = (v = e3 * M3) - (v - M3))) * (O = I - (F = (v = e3 * I) - (v - I))) - ((q = M3 * I) - w2 * F - A5 * F - w2 * O)) - (P = z2 - (C3 = (A5 = x3 - (w2 = (v = e3 * x3) - (v - x3))) * (O = G - (F = (v = e3 * G) - (v - G))) - ((B2 = x3 * G) - w2 * F - A5 * F - w2 * O))), l[0] = z2 - (P + _) + (_ - C3), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D2 = g + P) - g, l[2] = g - (D2 - _) + (P - _), l[3] = D2;
          const L = r2(4, c2, 4, l, s);
          _ = (z2 = (A5 = E2 - (w2 = (v = e3 * E2) - (v - E2))) * (O = m3 - (F = (v = e3 * m3) - (v - m3))) - ((q = E2 * m3) - w2 * F - A5 * F - w2 * O)) - (P = z2 - (C3 = (A5 = H - (w2 = (v = e3 * H) - (v - H))) * (O = j2 - (F = (v = e3 * j2) - (v - j2))) - ((B2 = H * j2) - w2 * F - A5 * F - w2 * O))), l[0] = z2 - (P + _) + (_ - C3), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D2 = g + P) - g, l[2] = g - (D2 - _) + (P - _), l[3] = D2;
          const N = r2(L, s, 4, l, a2);
          _ = (z2 = (A5 = M3 - (w2 = (v = e3 * M3) - (v - M3))) * (O = m3 - (F = (v = e3 * m3) - (v - m3))) - ((q = M3 * m3) - w2 * F - A5 * F - w2 * O)) - (P = z2 - (C3 = (A5 = x3 - (w2 = (v = e3 * x3) - (v - x3))) * (O = j2 - (F = (v = e3 * j2) - (v - j2))) - ((B2 = x3 * j2) - w2 * F - A5 * F - w2 * O))), l[0] = z2 - (P + _) + (_ - C3), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D2 = g + P) - g, l[2] = g - (D2 - _) + (P - _), l[3] = D2;
          const Q = r2(N, a2, 4, l, d);
          return d[Q - 1];
        }(t5, o2, p, b2, y2, h2, m2);
      }, t4.orient2dfast = function(t5, e4, n2, r3, o2, f2) {
        return (e4 - f2) * (n2 - o2) - (t5 - o2) * (r3 - f2);
      }, Object.defineProperty(t4, "__esModule", { value: true });
    });
  })(orient2d_min$1, orient2d_min$1.exports);
  return orient2d_min$1.exports;
}
var hasRequiredConcaveman;
function requireConcaveman() {
  if (hasRequiredConcaveman) return concaveman.exports;
  hasRequiredConcaveman = 1;
  var RBush = requireRbush_min();
  var Queue = require$$1;
  var pointInPolygon2 = requirePointInPolygon();
  var orient2 = requireOrient2d_min().orient2d;
  if (Queue.default) {
    Queue = Queue.default;
  }
  concaveman.exports = concaveman$1;
  concaveman.exports.default = concaveman$1;
  function concaveman$1(points2, concavity, lengthThreshold) {
    concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
    lengthThreshold = lengthThreshold || 0;
    var hull = fastConvexHull(points2);
    var tree2 = new RBush(16);
    tree2.toBBox = function(a3) {
      return {
        minX: a3[0],
        minY: a3[1],
        maxX: a3[0],
        maxY: a3[1]
      };
    };
    tree2.compareMinX = function(a3, b3) {
      return a3[0] - b3[0];
    };
    tree2.compareMinY = function(a3, b3) {
      return a3[1] - b3[1];
    };
    tree2.load(points2);
    var queue = [];
    for (var i = 0, last; i < hull.length; i++) {
      var p = hull[i];
      tree2.remove(p);
      last = insertNode(p, last);
      queue.push(last);
    }
    var segTree = new RBush(16);
    for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));
    var sqConcavity = concavity * concavity;
    var sqLenThreshold = lengthThreshold * lengthThreshold;
    while (queue.length) {
      var node2 = queue.shift();
      var a2 = node2.p;
      var b2 = node2.next.p;
      var sqLen = getSqDist(a2, b2);
      if (sqLen < sqLenThreshold) continue;
      var maxSqLen = sqLen / sqConcavity;
      p = findCandidate(tree2, node2.prev.p, a2, b2, node2.next.next.p, maxSqLen, segTree);
      if (p && Math.min(getSqDist(p, a2), getSqDist(p, b2)) <= maxSqLen) {
        queue.push(node2);
        queue.push(insertNode(p, node2));
        tree2.remove(p);
        segTree.remove(node2);
        segTree.insert(updateBBox(node2));
        segTree.insert(updateBBox(node2.next));
      }
    }
    node2 = last;
    var concave = [];
    do {
      concave.push(node2.p);
      node2 = node2.next;
    } while (node2 !== last);
    concave.push(node2.p);
    return concave;
  }
  function findCandidate(tree2, a2, b2, c2, d, maxDist, segTree) {
    var queue = new Queue([], compareDist);
    var node2 = tree2.data;
    while (node2) {
      for (var i = 0; i < node2.children.length; i++) {
        var child = node2.children[i];
        var dist2 = node2.leaf ? sqSegDist(child, b2, c2) : sqSegBoxDist(b2, c2, child);
        if (dist2 > maxDist) continue;
        queue.push({
          node: child,
          dist: dist2
        });
      }
      while (queue.length && !queue.peek().node.children) {
        var item = queue.pop();
        var p = item.node;
        var d0 = sqSegDist(p, a2, b2);
        var d1 = sqSegDist(p, c2, d);
        if (item.dist < d0 && item.dist < d1 && noIntersections(b2, p, segTree) && noIntersections(c2, p, segTree)) return p;
      }
      node2 = queue.pop();
      if (node2) node2 = node2.node;
    }
    return null;
  }
  function compareDist(a2, b2) {
    return a2.dist - b2.dist;
  }
  function sqSegBoxDist(a2, b2, bbox) {
    if (inside(a2, bbox) || inside(b2, bbox)) return 0;
    var d1 = sqSegSegDist(a2[0], a2[1], b2[0], b2[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);
    if (d1 === 0) return 0;
    var d2 = sqSegSegDist(a2[0], a2[1], b2[0], b2[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);
    if (d2 === 0) return 0;
    var d3 = sqSegSegDist(a2[0], a2[1], b2[0], b2[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);
    if (d3 === 0) return 0;
    var d4 = sqSegSegDist(a2[0], a2[1], b2[0], b2[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);
    if (d4 === 0) return 0;
    return Math.min(d1, d2, d3, d4);
  }
  function inside(a2, bbox) {
    return a2[0] >= bbox.minX && a2[0] <= bbox.maxX && a2[1] >= bbox.minY && a2[1] <= bbox.maxY;
  }
  function noIntersections(a2, b2, segTree) {
    var minX = Math.min(a2[0], b2[0]);
    var minY = Math.min(a2[1], b2[1]);
    var maxX = Math.max(a2[0], b2[0]);
    var maxY2 = Math.max(a2[1], b2[1]);
    var edges = segTree.search({ minX, minY, maxX, maxY: maxY2 });
    for (var i = 0; i < edges.length; i++) {
      if (intersects2(edges[i].p, edges[i].next.p, a2, b2)) return false;
    }
    return true;
  }
  function cross2(p1, p2, p3) {
    return orient2(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
  }
  function intersects2(p1, q1, p2, q2) {
    return p1 !== q2 && q1 !== p2 && cross2(p1, q1, p2) > 0 !== cross2(p1, q1, q2) > 0 && cross2(p2, q2, p1) > 0 !== cross2(p2, q2, q1) > 0;
  }
  function updateBBox(node2) {
    var p1 = node2.p;
    var p2 = node2.next.p;
    node2.minX = Math.min(p1[0], p2[0]);
    node2.minY = Math.min(p1[1], p2[1]);
    node2.maxX = Math.max(p1[0], p2[0]);
    node2.maxY = Math.max(p1[1], p2[1]);
    return node2;
  }
  function fastConvexHull(points2) {
    var left = points2[0];
    var top = points2[0];
    var right = points2[0];
    var bottom = points2[0];
    for (var i = 0; i < points2.length; i++) {
      var p = points2[i];
      if (p[0] < left[0]) left = p;
      if (p[0] > right[0]) right = p;
      if (p[1] < top[1]) top = p;
      if (p[1] > bottom[1]) bottom = p;
    }
    var cull = [left, top, right, bottom];
    var filtered = cull.slice();
    for (i = 0; i < points2.length; i++) {
      if (!pointInPolygon2(points2[i], cull)) filtered.push(points2[i]);
    }
    return convexHull(filtered);
  }
  function insertNode(p, prev2) {
    var node2 = {
      p,
      prev: null,
      next: null,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0
    };
    if (!prev2) {
      node2.prev = node2;
      node2.next = node2;
    } else {
      node2.next = prev2.next;
      node2.prev = prev2;
      prev2.next.prev = node2;
      prev2.next = node2;
    }
    return node2;
  }
  function getSqDist(p1, p2) {
    var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
    return dx * dx + dy * dy;
  }
  function sqSegDist(p, p1, p2) {
    var x2 = p1[0], y2 = p1[1], dx = p2[0] - x2, dy = p2[1] - y2;
    if (dx !== 0 || dy !== 0) {
      var t4 = ((p[0] - x2) * dx + (p[1] - y2) * dy) / (dx * dx + dy * dy);
      if (t4 > 1) {
        x2 = p2[0];
        y2 = p2[1];
      } else if (t4 > 0) {
        x2 += dx * t4;
        y2 += dy * t4;
      }
    }
    dx = p[0] - x2;
    dy = p[1] - y2;
    return dx * dx + dy * dy;
  }
  function sqSegSegDist(x02, y02, x12, y12, x2, y2, x3, y3) {
    var ux = x12 - x02;
    var uy = y12 - y02;
    var vx = x3 - x2;
    var vy = y3 - y2;
    var wx = x02 - x2;
    var wy = y02 - y2;
    var a2 = ux * ux + uy * uy;
    var b2 = ux * vx + uy * vy;
    var c2 = vx * vx + vy * vy;
    var d = ux * wx + uy * wy;
    var e3 = vx * wx + vy * wy;
    var D2 = a2 * c2 - b2 * b2;
    var sc, sN, tc, tN;
    var sD = D2;
    var tD = D2;
    if (D2 === 0) {
      sN = 0;
      sD = 1;
      tN = e3;
      tD = c2;
    } else {
      sN = b2 * e3 - c2 * d;
      tN = a2 * e3 - b2 * d;
      if (sN < 0) {
        sN = 0;
        tN = e3;
        tD = c2;
      } else if (sN > sD) {
        sN = sD;
        tN = e3 + b2;
        tD = c2;
      }
    }
    if (tN < 0) {
      tN = 0;
      if (-d < 0) sN = 0;
      else if (-d > a2) sN = sD;
      else {
        sN = -d;
        sD = a2;
      }
    } else if (tN > tD) {
      tN = tD;
      if (-d + b2 < 0) sN = 0;
      else if (-d + b2 > a2) sN = sD;
      else {
        sN = -d + b2;
        sD = a2;
      }
    }
    sc = sN === 0 ? 0 : sN / sD;
    tc = tN === 0 ? 0 : tN / tD;
    var cx = (1 - sc) * x02 + sc * x12;
    var cy = (1 - sc) * y02 + sc * y12;
    var cx2 = (1 - tc) * x2 + tc * x3;
    var cy2 = (1 - tc) * y2 + tc * y3;
    var dx = cx2 - cx;
    var dy = cy2 - cy;
    return dx * dx + dy * dy;
  }
  function compareByX(a2, b2) {
    return a2[0] === b2[0] ? a2[1] - b2[1] : a2[0] - b2[0];
  }
  function convexHull(points2) {
    points2.sort(compareByX);
    var lower = [];
    for (var i = 0; i < points2.length; i++) {
      while (lower.length >= 2 && cross2(lower[lower.length - 2], lower[lower.length - 1], points2[i]) <= 0) {
        lower.pop();
      }
      lower.push(points2[i]);
    }
    var upper = [];
    for (var ii = points2.length - 1; ii >= 0; ii--) {
      while (upper.length >= 2 && cross2(upper[upper.length - 2], upper[upper.length - 1], points2[ii]) <= 0) {
        upper.pop();
      }
      upper.push(points2[ii]);
    }
    upper.pop();
    lower.pop();
    return lower.concat(upper);
  }
  return concaveman.exports;
}
requireConcaveman();
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x3) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e3) {
      return obj[e3];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys2 = [];
    for (const key2 in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key2)) {
        keys2.push(key2);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value2) => {
    if (typeof value2 === "bigint") {
      return value2.toString();
    }
    return value2;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second2) => {
    return {
      ...first,
      ...second2
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data2) => {
  const t4 = typeof data2;
  switch (t4) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data2)) {
        return ZodParsedType.array;
      }
      if (data2 === null) {
        return ZodParsedType.null;
      }
      if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data2 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data2 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data2 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error2 = new ZodError(issues);
  return error2;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params2) => {
  const { data: data2, path: path2, errorMaps, issueData } = params2;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data: data2, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key2, value: value2 } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value2.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value2.status === "dirty")
        status.dirty();
      if (key2.value !== "__proto__" && (typeof value2.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key2.value] = value2.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value2) => ({ status: "dirty", value: value2 });
const OK = (value2) => ({ status: "valid", value: value2 });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value2, path2, key2) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value2;
    this._path = path2;
    this._key = key2;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
};
function processCreateParams(params2) {
  if (!params2)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description: description2 } = params2;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description: description2 };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description: description2 };
}
class ZodType {
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data2, params2) {
    const result = this.safeParse(data2, params2);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data2, params2) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap
      },
      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data2, params2) {
    const result = await this.safeParseAsync(data2, params2);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data2, params2) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,
        async: true
      },
      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data2) => {
          if (!data2) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description2) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description: description2
    });
  }
  pipe(target2) {
    return ZodPipeline.create(this, target2);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data2) => regex.test(data2), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value2, options) {
    return this._addCheck({
      kind: "includes",
      value: value2,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value2, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value2,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value2, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value2,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get minLength() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params2) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params2)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value2, message) {
    return this.setLimit("min", value2, true, errorUtil.toString(message));
  }
  gt(value2, message) {
    return this.setLimit("min", value2, false, errorUtil.toString(message));
  }
  lte(value2, message) {
    return this.setLimit("max", value2, true, errorUtil.toString(message));
  }
  lt(value2, message) {
    return this.setLimit("max", value2, false, errorUtil.toString(message));
  }
  setLimit(kind, value2, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value2, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      } else if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params2) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    ...processCreateParams(params2)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value2, message) {
    return this.setLimit("min", value2, true, errorUtil.toString(message));
  }
  gt(value2, message) {
    return this.setLimit("min", value2, false, errorUtil.toString(message));
  }
  lte(value2, message) {
    return this.setLimit("max", value2, true, errorUtil.toString(message));
  }
  lt(value2, message) {
    return this.setLimit("max", value2, false, errorUtil.toString(message));
  }
  setLimit(kind, value2, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value2, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params2) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params2)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params2) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    ...processCreateParams(params2)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params2) => {
  return new ZodDate({
    checks: [],
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params2)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params2) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params2)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params2) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params2)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params2) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params2)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params2) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params2)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params2) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params2)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params2) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params2)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params2) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params2)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params2) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params2)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape2 = this._def.shape();
    const keys2 = util.objectKeys(shape2);
    return this._cached = { shape: shape2, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape: shape2, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key2 in ctx.data) {
        if (!shapeKeys.includes(key2)) {
          extraKeys.push(key2);
        }
      }
    }
    const pairs = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape2[key2];
      const value2 = ctx.data[key2];
      pairs.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value2, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value2 = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value2, ctx.path, key2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          syncPairs.push({
            key: key2,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c2, _d2;
          const defaultError = (_c2 = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape2 = {};
    util.objectKeys(mask).forEach((key2) => {
      if (mask[key2] && this.shape[key2]) {
        shape2[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape2
    });
  }
  omit(mask) {
    const shape2 = {};
    util.objectKeys(this.shape).forEach((key2) => {
      if (!mask[key2]) {
        shape2[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape2
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key2) => {
      const fieldSchema = this.shape[key2];
      if (mask && !mask[key2]) {
        newShape[key2] = fieldSchema;
      } else {
        newShape[key2] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key2) => {
      if (mask && !mask[key2]) {
        newShape[key2] = this.shape[key2];
      } else {
        const fieldSchema = this.shape[key2];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key2] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape2, params2) => {
  return new ZodObject({
    shape: () => shape2,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
ZodObject.strictCreate = (shape2, params2) => {
  return new ZodObject({
    shape: () => shape2,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
ZodObject.lazycreate = (shape2, params2) => {
  return new ZodObject({
    shape: shape2,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params2) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params2)
  });
};
const getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return Object.keys(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params2) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value2 of discriminatorValues) {
        if (optionsMap.has(value2)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value2)}`);
        }
        optionsMap.set(value2, type2);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params2)
    });
  }
}
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a2[key2], b2[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params2) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params2)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params2) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params2)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second2, third) {
    if (second2 instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second2,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second2)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key2, value2], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value2, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value2 = await pair.value;
          if (key2.status === "aborted" || value2.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value2.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value2.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key2 = pair.key;
        const value2 = pair.value;
        if (key2.status === "aborted" || value2.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value2.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value2.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params2) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params2)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element2 of elements2) {
        if (element2.status === "aborted")
          return INVALID;
        if (element2.status === "dirty")
          status.dirty();
        parsedSet.add(element2.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params2) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params2)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    const params2 = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error2 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params2).catch((e3) => {
          error2.addIssue(makeArgsIssue(args, e3));
          throw error2;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params2).catch((e3) => {
          error2.addIssue(makeReturnsIssue(result, e3));
          throw error2;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params2);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params2);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params2) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params2)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter2, params2) => {
  return new ZodLazy({
    getter: getter2,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params2)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value2, params2) => {
  return new ZodLiteral({
    value: value2,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params2)
  });
};
function createZodEnum(values2, params2) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params2)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2) {
    return ZodEnum.create(values2);
  }
  exclude(values2) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values2, params2) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params2)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data2) => {
      return this._def.type.parseAsync(data2, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params2) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params2)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner2.status === "aborted")
          return INVALID;
        if (inner2.status === "dirty")
          status.dirty();
        executeRefinement(inner2.value);
        return { status: status.value, value: inner2.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner2) => {
          if (inner2.status === "aborted")
            return INVALID;
          if (inner2.status === "dirty")
            status.dirty();
          return executeRefinement(inner2.value).then(() => {
            return { status: status.value, value: inner2.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base2))
          return base2;
        const result = effect.transform(base2.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
          if (!isValid(base2))
            return base2;
          return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params2) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params2)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params2) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params2)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type2, params2) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params2)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type2, params2) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params2)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data2 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data2 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type2, params2) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default,
    ...processCreateParams(params2)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type2, params2) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch,
    ...processCreateParams(params2)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params2) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params2)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data2 = ctx.data;
    return this._def.type._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type2, params2) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params2)
  });
};
const custom10 = (check, params2 = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data2, ctx) => {
      var _a, _b;
      if (!check(data2)) {
        const p = typeof params2 === "function" ? params2(data2) : typeof params2 === "string" ? { message: params2 } : params2;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params2 = {
  message: `Input not instance of ${cls.name}`
}) => custom10((data2) => data2 instanceof cls, params2);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom: custom10,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const coordinationTypeName = z.string();
const coordinationScopeName = z.string();
const stringOrStringArray = z.union([
  z.string(),
  z.array(z.string())
]);
const oneOrMoreCoordinationScopeNames = stringOrStringArray;
const componentCoordinationScopes = z.record(coordinationTypeName, oneOrMoreCoordinationScopeNames);
const componentCoordinationScopesBy = z.record(coordinationTypeName, z.record(coordinationTypeName, z.record(coordinationScopeName, oneOrMoreCoordinationScopeNames)));
const rgbArray = z.array(z.number()).length(3);
const treeNodeBase = z.object({
  name: z.string(),
  color: rgbArray.optional()
});
const treeNodeLeaf = treeNodeBase.extend({
  set: z.array(z.string())
});
const treeNodeNonLeaf = treeNodeBase.extend({
  children: z.lazy(() => z.array(z.union([treeNodeNonLeaf, treeNodeLeaf])))
});
const cellSets2 = z.object({
  version: z.literal("0.1.2"),
  tree: z.array(treeNodeNonLeaf)
});
const treeNodeLeafProbabilistic = treeNodeBase.extend({
  set: z.array(z.tuple([z.string(), z.number().nullable()]))
});
const treeNodeNonLeafProbabilistic = treeNodeBase.extend({
  children: z.lazy(() => z.array(z.union([treeNodeNonLeafProbabilistic, treeNodeLeafProbabilistic])))
});
const cellSets3 = z.object({
  version: z.literal("0.1.3"),
  tree: z.array(treeNodeNonLeafProbabilistic)
});
function nodeTransform(node2, predicate, transform2, transformedPaths, currPath = null) {
  let newPath;
  if (!currPath) {
    newPath = [node2.name];
  } else {
    newPath = [...currPath];
  }
  if (predicate(node2, newPath)) {
    transformedPaths.push(newPath);
    return transform2(node2, newPath);
  }
  if ("children" in node2) {
    return {
      ...node2,
      children: node2.children.map((child) => nodeTransform(child, predicate, transform2, transformedPaths, newPath.concat([child.name])))
    };
  }
  return node2;
}
z.union([cellSets3, cellSets2]).transform((v) => {
  if (v.version === "0.1.3")
    return v;
  return {
    ...v,
    version: "0.1.3",
    tree: v.tree.map((levelZeroNode) => nodeTransform(levelZeroNode, (n) => !("children" in n) && Array.isArray(n.set), (n) => ({ ...n, set: n.set.map((itemId) => [itemId, null]) }), []))
  };
});
z.array(z.object({
  groupName: z.string(),
  setName: z.string(),
  setColor: rgbArray.optional(),
  obsId: z.string(),
  predictionScore: z.number().nullable().optional()
}));
z.array(z.string());
const requestInit = z.object({
  method: z.string().optional(),
  headers: z.record(z.any()).optional(),
  body: z.string().optional(),
  mode: z.string().optional(),
  credentials: z.string().optional(),
  cache: z.string().optional(),
  redirect: z.string().optional(),
  referrer: z.string().optional(),
  integrity: z.string().optional()
});
const nameSchema = z.string();
const publicFlagSchema = z.boolean().optional();
const descriptionSchema = z.string().optional();
const configSchema0_1_0 = z.object({
  version: z.literal("0.1.0"),
  name: nameSchema,
  public: publicFlagSchema,
  description: descriptionSchema,
  layers: z.array(z.object({
    name: z.string(),
    type: z.string(),
    fileType: z.string(),
    url: z.string()
  })),
  staticLayout: z.array(z.object({
    component: z.string(),
    props: z.record(z.any()).optional(),
    x: z.number().int(),
    y: z.number().int(),
    w: z.number().int().optional(),
    h: z.number().int().optional()
  }))
});
const fileOptionsSchema = z.any();
const coordinationSpaceSchema = z.object({}).catchall(z.record(coordinationScopeName, z.any()));
const initStrategySchema = z.enum(["none", "auto"]);
const layoutSchema1_0_0 = z.array(z.object({
  component: z.string(),
  props: z.record(z.any()).optional(),
  x: z.number().int(),
  y: z.number().int(),
  w: z.number().int().optional(),
  h: z.number().int().optional(),
  coordinationScopes: z.record(z.string()).optional()
}));
const datasetsSchema1_0_0 = z.array(z.object({
  uid: z.string(),
  name: z.string().optional(),
  description: z.string().optional(),
  files: z.array(z.object({
    name: z.string().optional(),
    fileType: z.string(),
    url: z.string().optional(),
    options: fileOptionsSchema.optional(),
    requestInit: requestInit.optional()
  }))
}));
const configSchema1_0_0 = z.object({
  version: z.literal("1.0.0"),
  name: nameSchema,
  public: publicFlagSchema,
  description: descriptionSchema,
  datasets: datasetsSchema1_0_0,
  coordinationSpace: coordinationSpaceSchema.optional(),
  layout: layoutSchema1_0_0,
  initStrategy: initStrategySchema
});
const configSchema1_0_1 = configSchema1_0_0.extend({
  version: z.literal("1.0.1")
});
const configSchema1_0_2 = configSchema1_0_0.extend({
  version: z.literal("1.0.2")
});
const configSchema1_0_3 = configSchema1_0_0.extend({
  version: z.literal("1.0.3")
});
const configSchema1_0_4 = configSchema1_0_0.extend({
  version: z.literal("1.0.4")
});
const configSchema1_0_5 = configSchema1_0_0.extend({
  version: z.literal("1.0.5")
});
const configSchema1_0_6 = configSchema1_0_0.extend({
  version: z.literal("1.0.6")
});
const configSchema1_0_7 = configSchema1_0_0.extend({
  version: z.literal("1.0.7")
});
const polyphonyStyleCoordinationScopes = z.record(z.union([
  z.string(),
  z.array(z.string()),
  z.record(z.string())
]));
const layoutSchema1_0_8 = z.array(z.object({
  component: z.string(),
  props: z.record(z.any()).optional(),
  x: z.number().int(),
  y: z.number().int(),
  w: z.number().int().optional(),
  h: z.number().int().optional(),
  // New: can be one of
  // - coordinationType: string
  // - dataset: string[]
  // - coordinationType: { datasetA: string, datasetB: string }
  coordinationScopes: polyphonyStyleCoordinationScopes.optional()
}));
const configSchema1_0_8 = configSchema1_0_0.extend({
  version: z.literal("1.0.8"),
  layout: layoutSchema1_0_8
});
const configSchema1_0_9 = configSchema1_0_8.extend({
  version: z.literal("1.0.9")
});
const layoutSchema1_0_10 = z.array(z.object({
  // New: uid property allowed.
  uid: z.string().optional(),
  component: z.string(),
  props: z.record(z.any()).optional(),
  x: z.number().int(),
  y: z.number().int(),
  w: z.number().int().optional(),
  h: z.number().int().optional(),
  coordinationScopes: polyphonyStyleCoordinationScopes.optional()
}));
const configSchema1_0_10 = configSchema1_0_8.extend({
  version: z.literal("1.0.10"),
  layout: layoutSchema1_0_10
});
const configSchema1_0_11 = configSchema1_0_10.extend({
  version: z.literal("1.0.11")
});
const configSchema1_0_12 = configSchema1_0_10.extend({
  version: z.literal("1.0.12")
});
const latestFileDefSchema = z.object({
  name: z.string().optional(),
  fileType: z.string(),
  url: z.string().optional(),
  options: fileOptionsSchema.optional(),
  requestInit: requestInit.optional(),
  // New: file def can have coordinationValues.
  coordinationValues: z.record(z.string()).optional()
});
const datasetsSchema1_0_13 = z.array(z.object({
  uid: z.string(),
  name: z.string().optional(),
  description: z.string().optional(),
  files: z.array(latestFileDefSchema)
}));
const configSchema1_0_13 = configSchema1_0_10.extend({
  version: z.literal("1.0.13"),
  datasets: datasetsSchema1_0_13
});
const configSchema1_0_14 = configSchema1_0_13.extend({
  version: z.literal("1.0.14")
});
const configSchema1_0_15 = configSchema1_0_13.extend({
  version: z.literal("1.0.15")
});
const configSchema1_0_16 = configSchema1_0_13.extend({
  version: z.literal("1.0.16"),
  uid: z.string().optional(),
  layout: z.array(z.object({
    uid: z.string().optional(),
    component: z.string(),
    props: z.record(z.any()).optional(),
    x: z.number().int(),
    y: z.number().int(),
    w: z.number().int().optional(),
    h: z.number().int().optional(),
    // Updates coordinationScopes and coordinationScopesBy
    coordinationScopes: componentCoordinationScopes.optional(),
    coordinationScopesBy: componentCoordinationScopesBy.optional()
  }))
});
const configSchema1_0_17 = configSchema1_0_16.extend({
  version: z.literal("1.0.17")
});
configSchema1_0_0.shape.coordinationSpace.unwrap();
configSchema1_0_0.shape.layout.element.shape.coordinationScopes.unwrap();
function upgradeReplaceViewProp(prefix2, view, coordinationSpace) {
  const prevZScopes = Object.keys(coordinationSpace[`${prefix2}Zoom`]);
  const prevTXScopes = Object.keys(coordinationSpace[`${prefix2}TargetX`]);
  const prevTYScopes = Object.keys(coordinationSpace[`${prefix2}TargetY`]);
  const nextZScope = getNextScope(prevZScopes);
  const nextTXScope = getNextScope(prevTXScopes);
  const nextTYScope = getNextScope(prevTYScopes);
  const { zoom: zoom2, target: [targetX2, targetY2] } = view;
  coordinationSpace[`${prefix2}Zoom`][nextZScope] = zoom2;
  coordinationSpace[`${prefix2}TargetX`][nextTXScope] = targetX2;
  coordinationSpace[`${prefix2}TargetY`][nextTYScope] = targetY2;
  return {
    [`${prefix2}Zoom`]: nextZScope,
    [`${prefix2}TargetX`]: nextTXScope,
    [`${prefix2}TargetY`]: nextTYScope
  };
}
function upgradeFrom0_1_0(config, datasetUid = null) {
  const coordinationSpace = {
    embeddingType: {},
    embeddingZoom: {},
    embeddingTargetX: {},
    embeddingTargetY: {},
    spatialZoom: {},
    spatialTargetX: {},
    spatialTargetY: {}
  };
  const layout = [];
  config.staticLayout.forEach((componentDef) => {
    var _a, _b, _c2;
    let newComponentDef = {
      ...componentDef,
      coordinationScopes: {}
    };
    if (componentDef.component === "scatterplot") {
      if (((_a = componentDef.props) == null ? void 0 : _a.mapping) && typeof componentDef.props.mapping === "string") {
        coordinationSpace.embeddingType[componentDef.props.mapping] = componentDef.props.mapping;
        newComponentDef = {
          ...newComponentDef,
          coordinationScopes: {
            ...newComponentDef.coordinationScopes,
            embeddingType: componentDef.props.mapping
          }
        };
      }
      if ((_b = componentDef.props) == null ? void 0 : _b.view) {
        const newScopeValues = upgradeReplaceViewProp("embedding", componentDef.props.view, coordinationSpace);
        newComponentDef = {
          ...newComponentDef,
          coordinationScopes: {
            ...newComponentDef.coordinationScopes,
            ...newScopeValues
          }
        };
      }
    }
    if (componentDef.component === "spatial") {
      if ((_c2 = componentDef == null ? void 0 : componentDef.props) == null ? void 0 : _c2.view) {
        const newScopeValues = upgradeReplaceViewProp("spatial", componentDef.props.view, coordinationSpace);
        newComponentDef = {
          ...newComponentDef,
          coordinationScopes: {
            ...newComponentDef.coordinationScopes,
            ...newScopeValues
          }
        };
      }
    }
    layout.push(newComponentDef);
  });
  const lcDef = layout.find((c2) => c2.component === "layerController");
  const spatialDef = layout.find((c2) => c2.component === "spatial");
  if (lcDef && spatialDef && "coordinationScopes" in spatialDef) {
    lcDef.coordinationScopes = spatialDef.coordinationScopes;
  }
  const newDatasetUid = datasetUid || v4();
  return {
    version: "1.0.0",
    name: config.name,
    description: config.description,
    public: config.public,
    datasets: [
      {
        uid: newDatasetUid,
        name: newDatasetUid,
        files: config.layers.map((layer) => ({
          fileType: layer.fileType,
          url: layer.url
        }))
      }
    ],
    initStrategy: "auto",
    coordinationSpace,
    layout
  };
}
function upgradeFrom1_0_0(config) {
  const newConfig = cloneDeep(config);
  const { coordinationSpace } = newConfig;
  function replaceLayerType(layerType, cSpace) {
    const isRaster = layerType === "raster";
    cSpace[`spatial${capitalize(layerType)}Layer${isRaster ? "s" : ""}`] = {};
    Object.entries(cSpace.spatialLayers).forEach(([scope, layers]) => {
      if (Array.isArray(layers) && layers.find((layer) => layer.type === layerType)) {
        const typedLayers = layers.filter((layer) => layer.type === layerType).map((layer) => {
          const newLayer = { ...layer };
          delete newLayer.type;
          return newLayer;
        });
        cSpace[`spatial${capitalize(layerType)}Layer${isRaster ? "s" : ""}`][scope] = isRaster ? typedLayers : typedLayers[0];
      } else {
        cSpace[`spatial${capitalize(layerType)}Layer${isRaster ? "s" : ""}`][scope] = null;
      }
    });
  }
  if (coordinationSpace && "spatialLayers" in coordinationSpace) {
    replaceLayerType("raster", coordinationSpace);
    replaceLayerType("cells", coordinationSpace);
    replaceLayerType("molecules", coordinationSpace);
    replaceLayerType("neighborhoods", coordinationSpace);
    delete coordinationSpace.spatialLayers;
  }
  const layout = newConfig.layout.map((component) => {
    const newComponent = { ...component };
    function replaceCoordinationScope(layerType, cScopes) {
      const isRaster = layerType === "raster";
      if (["spatial", "layerController"].includes(newComponent.component) || newComponent.component === "description" && isRaster) {
        cScopes[`spatial${capitalize(layerType)}Layer${isRaster ? "s" : ""}`] = cScopes.spatialLayers;
      }
    }
    if (newComponent.coordinationScopes && newComponent.coordinationScopes.spatialLayers) {
      replaceCoordinationScope("raster", newComponent.coordinationScopes);
      replaceCoordinationScope("cells", newComponent.coordinationScopes);
      replaceCoordinationScope("molecules", newComponent.coordinationScopes);
      replaceCoordinationScope("neighborhoods", newComponent.coordinationScopes);
      delete newComponent.coordinationScopes.spatialLayers;
    }
    return newComponent;
  });
  return {
    ...newConfig,
    coordinationSpace,
    layout,
    version: "1.0.1"
  };
}
function upgradeFrom1_0_1(config) {
  var _a;
  const layout = config.layout.map((component) => {
    const newComponent = { ...component };
    if (newComponent.component === "layerController") {
      newComponent.props = {
        ...newComponent.props,
        globalDisable3d: true
      };
    }
    return newComponent;
  });
  const newConfig = cloneDeep(config);
  Object.keys(((_a = newConfig == null ? void 0 : newConfig.coordinationSpace) == null ? void 0 : _a.spatialRasterLayers) || {}).forEach((key2) => {
    var _a2, _b;
    if ((_b = (_a2 = newConfig.coordinationSpace) == null ? void 0 : _a2.spatialRasterLayers) == null ? void 0 : _b[key2]) {
      newConfig.coordinationSpace.spatialRasterLayers[key2].forEach((layer, index2) => {
        if (newConfig.coordinationSpace) {
          newConfig.coordinationSpace.spatialRasterLayers[key2][index2].type = ["bitmask", "raster"].includes(layer.type) ? layer.type : "raster";
        }
      });
    }
  });
  return {
    ...newConfig,
    layout,
    version: "1.0.2"
  };
}
function upgradeFrom1_0_2(config) {
  const layout = config.layout.map((component) => {
    const newComponent = { ...component };
    if (newComponent.component === "layerController") {
      newComponent.props = {
        ...newComponent.props,
        disableChannelsIfRgbDetected: true
      };
    }
    return newComponent;
  });
  const newConfig = cloneDeep(config);
  return {
    ...newConfig,
    layout,
    version: "1.0.3"
  };
}
function upgradeFrom1_0_3(config) {
  const newConfig = cloneDeep(config);
  return {
    ...newConfig,
    version: "1.0.4"
  };
}
function upgradeFrom1_0_4(config) {
  const newConfig = cloneDeep(config);
  return {
    ...newConfig,
    version: "1.0.5"
  };
}
function upgradeFrom1_0_5(config) {
  const newConfig = cloneDeep(config);
  return {
    ...newConfig,
    version: "1.0.6"
  };
}
function upgradeFrom1_0_6(config) {
  const newConfig = cloneDeep(config);
  return {
    ...newConfig,
    version: "1.0.7"
  };
}
function upgradeFrom1_0_7(config) {
  const newConfig = cloneDeep(config);
  return {
    ...newConfig,
    version: "1.0.8"
  };
}
function upgradeFrom1_0_8(config) {
  const newConfig = cloneDeep(config);
  return {
    ...newConfig,
    version: "1.0.9"
  };
}
function upgradeFrom1_0_9(config) {
  const newConfig = cloneDeep(config);
  return {
    ...newConfig,
    version: "1.0.10"
  };
}
function upgradeFrom1_0_10(config) {
  const coordinationSpace = { ...config.coordinationSpace };
  const scopeAnalogies = {
    // Spatial layer types
    spatialRasterLayers: "spatialImageLayer",
    spatialCellsLayer: "spatialSegmentationLayer",
    spatialMoleculesLayer: "spatialPointLayer",
    spatialNeighborhoodsLayer: "spatialNeighborhoodLayer",
    // Other types
    cellFilter: "obsFilter",
    cellHighlight: "obsHighlight",
    cellSelection: "obsSelection",
    cellSetSelection: "obsSetSelection",
    cellSetHighlight: "obsSetHighlight",
    cellSetColor: "obsSetColor",
    geneFilter: "featureFilter",
    geneHighlight: "featureHighlight",
    geneSelection: "featureSelection",
    geneExpressionColormap: "featureValueColormap",
    geneExpressionColormapRange: "featureValueColormapRange",
    cellColorEncoding: "obsColorEncoding",
    additionalCellSets: "additionalObsSets",
    embeddingCellSetPolygonsVisible: "embeddingObsSetPolygonsVisible",
    embeddingCellSetLabelsVisible: "embeddingObsSetLabelsVisible",
    embeddingCellSetLabelSize: "embeddingObsSetLabelSize",
    embeddingCellRadius: "embeddingObsRadius",
    embeddingCellRadiusMode: "embeddingObsRadiusMode",
    embeddingCellOpacity: "embeddingObsOpacity",
    embeddingCellOpacityMode: "embeddingObsOpacityMode"
  };
  Object.entries(scopeAnalogies).forEach(([oldKey, newKey]) => {
    if (coordinationSpace[oldKey]) {
      coordinationSpace[newKey] = coordinationSpace[oldKey];
      delete coordinationSpace[oldKey];
    }
  });
  const layout = config.layout.map((component) => {
    const newComponent = { ...component };
    const { coordinationScopes = {} } = newComponent;
    Object.entries(scopeAnalogies).forEach(([oldKey, newKey]) => {
      if (coordinationScopes[oldKey]) {
        coordinationScopes[newKey] = coordinationScopes[oldKey];
        delete coordinationScopes[oldKey];
      }
    });
    return {
      ...newComponent,
      coordinationScopes
    };
  });
  return {
    ...config,
    coordinationSpace,
    layout,
    version: "1.0.11"
  };
}
function upgradeFrom1_0_11(config) {
  const newConfig = cloneDeep(config);
  const { datasets, coordinationSpace } = newConfig;
  if (coordinationSpace == null ? void 0 : coordinationSpace.embeddingType) {
    const embeddingTypes = Object.values(coordinationSpace.embeddingType);
    datasets.forEach((dataset, i) => {
      const { files } = dataset;
      files.forEach((fileDef, j) => {
        const { fileType } = fileDef;
        if (fileType === "cells.json") {
          datasets[i].files[j].options = {
            embeddingTypes
          };
        }
      });
    });
  }
  return {
    ...newConfig,
    datasets,
    version: "1.0.12"
  };
}
function upgradeFrom1_0_12(config) {
  const newConfig = cloneDeep(config);
  const { datasets, coordinationSpace, layout } = newConfig;
  const newCoordinationSpace = coordinationSpace || {};
  const datasetUidToObsLabelsTypeScopes = {};
  datasets.forEach((dataset) => {
    const { files, uid } = dataset;
    files.forEach((fileDef) => {
      const { fileType, options } = fileDef;
      if (fileType === "anndata-cells.zarr") {
        if (options && "factors" in options && Array.isArray(options.factors)) {
          const obsLabelsTypeScopes = [];
          options.factors.forEach((olt) => {
            const nextScope = getNextScope(Object.keys((coordinationSpace == null ? void 0 : coordinationSpace.obsLabelsType) || {}));
            newCoordinationSpace.obsLabelsType = {
              ...newCoordinationSpace.obsLabelsType,
              // Need to remove the obs/ prefix.
              [nextScope]: olt.split("/").at(-1)
            };
            obsLabelsTypeScopes.push(nextScope);
          });
          datasetUidToObsLabelsTypeScopes[uid] = obsLabelsTypeScopes;
        }
      }
    });
  });
  function getDatasetUidForView(viewDef) {
    var _a, _b;
    if (((_a = viewDef.coordinationScopes) == null ? void 0 : _a.dataset) && typeof ((_b = viewDef.coordinationScopes) == null ? void 0 : _b.dataset) === "string") {
      return newCoordinationSpace.dataset[viewDef.coordinationScopes.dataset];
    }
    if (datasets.length > 0) {
      return datasets[0].uid;
    }
    return null;
  }
  const newLayout = layout.map((viewDef) => {
    const viewDatasetUid = getDatasetUidForView(viewDef);
    if (typeof viewDatasetUid === "string") {
      const datasetObsLabelsTypeScopes = datasetUidToObsLabelsTypeScopes[viewDatasetUid];
      if (datasetObsLabelsTypeScopes) {
        return {
          ...viewDef,
          coordinationScopes: {
            ...viewDef.coordinationScopes,
            obsLabelsType: datasetObsLabelsTypeScopes
          }
        };
      }
    }
    return viewDef;
  });
  return {
    ...newConfig,
    coordinationSpace: newCoordinationSpace,
    layout: newLayout,
    version: "1.0.13"
  };
}
function upgradeFrom1_0_13(config) {
  const newConfig = cloneDeep(config);
  return {
    ...newConfig,
    version: "1.0.14"
  };
}
function upgradeFrom1_0_14(config) {
  const newConfig = cloneDeep(config);
  const { layout } = newConfig;
  const viewTypeAnalogies = {
    genes: "featureList",
    cellSets: "obsSets",
    cellSetSizes: "obsSetSizes",
    cellSetExpression: "obsSetFeatureValueDistribution",
    expressionHistogram: "featureValueHistogram"
  };
  const newLayout = layout.map((viewDef) => {
    if (viewTypeAnalogies[viewDef.component]) {
      return {
        ...viewDef,
        component: viewTypeAnalogies[viewDef.component]
      };
    }
    return viewDef;
  });
  const propAnalogies = {
    variablesLabelOverride: "featureType",
    observationsLabelOverride: "obsType"
  };
  newLayout.forEach((viewDef) => {
    Object.entries(propAnalogies).forEach(([oldProp, newType]) => {
      var _a;
      if ((_a = viewDef.props) == null ? void 0 : _a[oldProp]) {
        log.warn(`Warning: the '${oldProp}' prop on the ${viewDef.component} view is deprecated. Please use the '${newType}' coordination type instead.`);
      }
    });
  });
  return {
    ...newConfig,
    version: "1.0.15",
    layout: newLayout
  };
}
function upgradeFrom1_0_15(config) {
  const newConfig = cloneDeep(config);
  const { layout } = newConfig;
  const newLayout = layout.map((view) => {
    const { coordinationScopes } = view;
    const newCoordinationScopes = {};
    if ((coordinationScopes == null ? void 0 : coordinationScopes.dataset) && Array.isArray(coordinationScopes.dataset)) {
      const coordinationScopesBy = {
        dataset: {}
      };
      Object.entries(coordinationScopes).forEach(([coordinationType, coordinationScope]) => {
        if (!Array.isArray(coordinationScope) && typeof coordinationScope === "object") {
          if (coordinationType === "dataset") {
            log.error("Expected coordinationScopes.dataset value to be either string or string[], but got object.");
          }
          coordinationScopesBy.dataset[coordinationType] = coordinationScope;
        } else if (Array.isArray(coordinationScope) || typeof coordinationScope === "string") {
          newCoordinationScopes[coordinationType] = coordinationScope;
        }
      });
      return {
        ...view,
        coordinationScopes: newCoordinationScopes,
        coordinationScopesBy
      };
    }
    if (coordinationScopes) {
      Object.entries(coordinationScopes).forEach(([coordinationType, coordinationScope]) => {
        if (Array.isArray(coordinationScope) || typeof coordinationScope === "string") {
          newCoordinationScopes[coordinationType] = coordinationScope;
        }
      });
    }
    return {
      ...view,
      coordinationScopes: newCoordinationScopes
    };
  });
  return {
    ...newConfig,
    layout: newLayout,
    version: "1.0.16"
  };
}
function upgradeFrom1_0_16(config) {
  const newConfig = cloneDeep(config);
  const { datasets } = newConfig;
  const newDatasets = datasets.map((datasetDef) => {
    const { files } = datasetDef;
    const newFiles = files.map((fileDef) => {
      const { fileType, options } = fileDef;
      if (fileType === "obsSets.anndata.zarr") {
        return {
          ...fileDef,
          options: {
            obsSets: options
          }
        };
      }
      if (fileType === "obsFeatureColumns.anndata.zarr") {
        return {
          ...fileDef,
          options: {
            obsFeatureColumns: options
          }
        };
      }
      return fileDef;
    });
    return {
      ...datasetDef,
      files: newFiles
    };
  });
  return {
    ...newConfig,
    datasets: newDatasets,
    version: "1.0.17"
  };
}
const latestConfigSchema = configSchema1_0_17;
const SCHEMA_HANDLERS = [
  [configSchema0_1_0, upgradeFrom0_1_0],
  [configSchema1_0_0, upgradeFrom1_0_0],
  [configSchema1_0_1, upgradeFrom1_0_1],
  [configSchema1_0_2, upgradeFrom1_0_2],
  [configSchema1_0_3, upgradeFrom1_0_3],
  [configSchema1_0_4, upgradeFrom1_0_4],
  [configSchema1_0_5, upgradeFrom1_0_5],
  [configSchema1_0_6, upgradeFrom1_0_6],
  [configSchema1_0_7, upgradeFrom1_0_7],
  [configSchema1_0_8, upgradeFrom1_0_8],
  [configSchema1_0_9, upgradeFrom1_0_9],
  [configSchema1_0_10, upgradeFrom1_0_10],
  [configSchema1_0_11, upgradeFrom1_0_11],
  [configSchema1_0_12, upgradeFrom1_0_12],
  [configSchema1_0_13, upgradeFrom1_0_13],
  [configSchema1_0_14, upgradeFrom1_0_14],
  [configSchema1_0_15, upgradeFrom1_0_15],
  [configSchema1_0_16, upgradeFrom1_0_16]
];
var re$2 = { exports: {} };
var constants$1;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants$1;
  hasRequiredConstants = 1;
  const SEMVER_SPEC_VERSION = "2.0.0";
  const MAX_LENGTH2 = 256;
  const MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  const MAX_SAFE_COMPONENT_LENGTH2 = 16;
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH2 - 6;
  const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  constants$1 = {
    MAX_LENGTH: MAX_LENGTH2,
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  return constants$1;
}
var debug_1$1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug_1$1;
  hasRequiredDebug = 1;
  const debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  debug_1$1 = debug2;
  return debug_1$1;
}
var hasRequiredRe;
function requireRe() {
  if (hasRequiredRe) return re$2.exports;
  hasRequiredRe = 1;
  (function(module2, exports2) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH: MAX_LENGTH2
    } = requireConstants();
    const debug2 = requireDebug();
    exports2 = module2.exports = {};
    const re2 = exports2.re = [];
    const safeRe = exports2.safeRe = [];
    const src = exports2.src = [];
    const t4 = exports2.t = {};
    let R = 0;
    const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    const safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH2],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    const makeSafeRegex = (value2) => {
      for (const [token2, max2] of safeRegexReplacements) {
        value2 = value2.split(`${token2}*`).join(`${token2}{0,${max2}}`).split(`${token2}+`).join(`${token2}{1,${max2}}`);
      }
      return value2;
    };
    const createToken = (name, value2, isGlobal) => {
      const safe = makeSafeRegex(value2);
      const index2 = R++;
      debug2(name, index2, value2);
      t4[name] = index2;
      src[index2] = value2;
      re2[index2] = new RegExp(value2, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t4.NUMERICIDENTIFIER]})\\.(${src[t4.NUMERICIDENTIFIER]})\\.(${src[t4.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t4.NUMERICIDENTIFIERLOOSE]})\\.(${src[t4.NUMERICIDENTIFIERLOOSE]})\\.(${src[t4.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t4.NUMERICIDENTIFIER]}|${src[t4.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t4.NUMERICIDENTIFIERLOOSE]}|${src[t4.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t4.PRERELEASEIDENTIFIER]}(?:\\.${src[t4.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t4.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t4.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t4.BUILDIDENTIFIER]}(?:\\.${src[t4.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t4.MAINVERSION]}${src[t4.PRERELEASE]}?${src[t4.BUILD]}?`);
    createToken("FULL", `^${src[t4.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t4.MAINVERSIONLOOSE]}${src[t4.PRERELEASELOOSE]}?${src[t4.BUILD]}?`);
    createToken("LOOSE", `^${src[t4.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t4.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t4.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t4.XRANGEIDENTIFIER]})(?:\\.(${src[t4.XRANGEIDENTIFIER]})(?:\\.(${src[t4.XRANGEIDENTIFIER]})(?:${src[t4.PRERELEASE]})?${src[t4.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t4.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t4.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t4.XRANGEIDENTIFIERLOOSE]})(?:${src[t4.PRERELEASELOOSE]})?${src[t4.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t4.GTLT]}\\s*${src[t4.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t4.GTLT]}\\s*${src[t4.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
    createToken("COERCE", `${src[t4.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t4.COERCEPLAIN] + `(?:${src[t4.PRERELEASE]})?(?:${src[t4.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t4.COERCE], true);
    createToken("COERCERTLFULL", src[t4.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t4.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t4.LONETILDE]}${src[t4.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t4.LONETILDE]}${src[t4.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t4.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t4.LONECARET]}${src[t4.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t4.LONECARET]}${src[t4.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t4.GTLT]}\\s*(${src[t4.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t4.GTLT]}\\s*(${src[t4.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t4.GTLT]}\\s*(${src[t4.LOOSEPLAIN]}|${src[t4.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t4.XRANGEPLAIN]})\\s+-\\s+(${src[t4.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t4.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t4.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(re$2, re$2.exports);
  return re$2.exports;
}
var parseOptions_1$1;
var hasRequiredParseOptions;
function requireParseOptions() {
  if (hasRequiredParseOptions) return parseOptions_1$1;
  hasRequiredParseOptions = 1;
  const looseOption = Object.freeze({ loose: true });
  const emptyOpts = Object.freeze({});
  const parseOptions2 = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  parseOptions_1$1 = parseOptions2;
  return parseOptions_1$1;
}
var identifiers$1;
var hasRequiredIdentifiers;
function requireIdentifiers() {
  if (hasRequiredIdentifiers) return identifiers$1;
  hasRequiredIdentifiers = 1;
  const numeric2 = /^[0-9]+$/;
  const compareIdentifiers2 = (a2, b2) => {
    const anum = numeric2.test(a2);
    const bnum = numeric2.test(b2);
    if (anum && bnum) {
      a2 = +a2;
      b2 = +b2;
    }
    return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
  };
  const rcompareIdentifiers = (a2, b2) => compareIdentifiers2(b2, a2);
  identifiers$1 = {
    compareIdentifiers: compareIdentifiers2,
    rcompareIdentifiers
  };
  return identifiers$1;
}
var semver$2;
var hasRequiredSemver$1;
function requireSemver$1() {
  if (hasRequiredSemver$1) return semver$2;
  hasRequiredSemver$1 = 1;
  const debug2 = requireDebug();
  const { MAX_LENGTH: MAX_LENGTH2, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = requireConstants();
  const { safeRe: re2, t: t4 } = requireRe();
  const parseOptions2 = requireParseOptions();
  const { compareIdentifiers: compareIdentifiers2 } = requireIdentifiers();
  class SemVer2 {
    constructor(version2, options) {
      options = parseOptions2(options);
      if (version2 instanceof SemVer2) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
      }
      if (version2.length > MAX_LENGTH2) {
        throw new TypeError(
          `version is longer than ${MAX_LENGTH2} characters`
        );
      }
      debug2("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m2 = version2.trim().match(options.loose ? re2[t4.LOOSE] : re2[t4.FULL]);
      if (!m2) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map((id2) => {
          if (/^[0-9]+$/.test(id2)) {
            const num = +id2;
            if (num >= 0 && num < MAX_SAFE_INTEGER2) {
              return num;
            }
          }
          return id2;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer2)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer2(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer2)) {
        other = new SemVer2(other, this.options);
      }
      return compareIdentifiers2(this.major, other.major) || compareIdentifiers2(this.minor, other.minor) || compareIdentifiers2(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer2)) {
        other = new SemVer2(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a2 = this.prerelease[i];
        const b2 = other.prerelease[i];
        debug2("prerelease compare", i, a2, b2);
        if (a2 === void 0 && b2 === void 0) {
          return 0;
        } else if (b2 === void 0) {
          return 1;
        } else if (a2 === void 0) {
          return -1;
        } else if (a2 === b2) {
          continue;
        } else {
          return compareIdentifiers2(a2, b2);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer2)) {
        other = new SemVer2(other, this.options);
      }
      let i = 0;
      do {
        const a2 = this.build[i];
        const b2 = other.build[i];
        debug2("build compare", i, a2, b2);
        if (a2 === void 0 && b2 === void 0) {
          return 0;
        } else if (b2 === void 0) {
          return 1;
        } else if (a2 === void 0) {
          return -1;
        } else if (a2 === b2) {
          continue;
        } else {
          return compareIdentifiers2(a2, b2);
        }
      } while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier2, identifierBase) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier2, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier2, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier2, identifierBase);
          this.inc("pre", identifier2, identifierBase);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier2, identifierBase);
          }
          this.inc("pre", identifier2, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const base2 = Number(identifierBase) ? 1 : 0;
          if (!identifier2 && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [base2];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier2 === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base2);
            }
          }
          if (identifier2) {
            let prerelease = [identifier2, base2];
            if (identifierBase === false) {
              prerelease = [identifier2];
            }
            if (compareIdentifiers2(this.prerelease[0], identifier2) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  semver$2 = SemVer2;
  return semver$2;
}
var parse_1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  const SemVer2 = requireSemver$1();
  const parse2 = (version2, options, throwErrors = false) => {
    if (version2 instanceof SemVer2) {
      return version2;
    }
    try {
      return new SemVer2(version2, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  parse_1 = parse2;
  return parse_1;
}
var valid_1;
var hasRequiredValid$1;
function requireValid$1() {
  if (hasRequiredValid$1) return valid_1;
  hasRequiredValid$1 = 1;
  const parse2 = requireParse();
  const valid2 = (version2, options) => {
    const v = parse2(version2, options);
    return v ? v.version : null;
  };
  valid_1 = valid2;
  return valid_1;
}
var clean_1;
var hasRequiredClean;
function requireClean() {
  if (hasRequiredClean) return clean_1;
  hasRequiredClean = 1;
  const parse2 = requireParse();
  const clean = (version2, options) => {
    const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  clean_1 = clean;
  return clean_1;
}
var inc_1;
var hasRequiredInc;
function requireInc() {
  if (hasRequiredInc) return inc_1;
  hasRequiredInc = 1;
  const SemVer2 = requireSemver$1();
  const inc = (version2, release, options, identifier2, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier2;
      identifier2 = options;
      options = void 0;
    }
    try {
      return new SemVer2(
        version2 instanceof SemVer2 ? version2.version : version2,
        options
      ).inc(release, identifier2, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  inc_1 = inc;
  return inc_1;
}
var diff_1;
var hasRequiredDiff;
function requireDiff() {
  if (hasRequiredDiff) return diff_1;
  hasRequiredDiff = 1;
  const parse2 = requireParse();
  const diff = (version1, version2) => {
    const v1 = parse2(version1, null, true);
    const v2 = parse2(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix2 = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix2 + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix2 + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix2 + "patch";
    }
    return "prerelease";
  };
  diff_1 = diff;
  return diff_1;
}
var major_1;
var hasRequiredMajor;
function requireMajor() {
  if (hasRequiredMajor) return major_1;
  hasRequiredMajor = 1;
  const SemVer2 = requireSemver$1();
  const major = (a2, loose) => new SemVer2(a2, loose).major;
  major_1 = major;
  return major_1;
}
var minor_1;
var hasRequiredMinor;
function requireMinor() {
  if (hasRequiredMinor) return minor_1;
  hasRequiredMinor = 1;
  const SemVer2 = requireSemver$1();
  const minor = (a2, loose) => new SemVer2(a2, loose).minor;
  minor_1 = minor;
  return minor_1;
}
var patch_1;
var hasRequiredPatch;
function requirePatch() {
  if (hasRequiredPatch) return patch_1;
  hasRequiredPatch = 1;
  const SemVer2 = requireSemver$1();
  const patch2 = (a2, loose) => new SemVer2(a2, loose).patch;
  patch_1 = patch2;
  return patch_1;
}
var prerelease_1;
var hasRequiredPrerelease;
function requirePrerelease() {
  if (hasRequiredPrerelease) return prerelease_1;
  hasRequiredPrerelease = 1;
  const parse2 = requireParse();
  const prerelease = (version2, options) => {
    const parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  prerelease_1 = prerelease;
  return prerelease_1;
}
var compare_1$1;
var hasRequiredCompare;
function requireCompare() {
  if (hasRequiredCompare) return compare_1$1;
  hasRequiredCompare = 1;
  const SemVer2 = requireSemver$1();
  const compare2 = (a2, b2, loose) => new SemVer2(a2, loose).compare(new SemVer2(b2, loose));
  compare_1$1 = compare2;
  return compare_1$1;
}
var rcompare_1;
var hasRequiredRcompare;
function requireRcompare() {
  if (hasRequiredRcompare) return rcompare_1;
  hasRequiredRcompare = 1;
  const compare2 = requireCompare();
  const rcompare = (a2, b2, loose) => compare2(b2, a2, loose);
  rcompare_1 = rcompare;
  return rcompare_1;
}
var compareLoose_1;
var hasRequiredCompareLoose;
function requireCompareLoose() {
  if (hasRequiredCompareLoose) return compareLoose_1;
  hasRequiredCompareLoose = 1;
  const compare2 = requireCompare();
  const compareLoose = (a2, b2) => compare2(a2, b2, true);
  compareLoose_1 = compareLoose;
  return compareLoose_1;
}
var compareBuild_1;
var hasRequiredCompareBuild;
function requireCompareBuild() {
  if (hasRequiredCompareBuild) return compareBuild_1;
  hasRequiredCompareBuild = 1;
  const SemVer2 = requireSemver$1();
  const compareBuild = (a2, b2, loose) => {
    const versionA = new SemVer2(a2, loose);
    const versionB = new SemVer2(b2, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  compareBuild_1 = compareBuild;
  return compareBuild_1;
}
var sort_1;
var hasRequiredSort;
function requireSort() {
  if (hasRequiredSort) return sort_1;
  hasRequiredSort = 1;
  const compareBuild = requireCompareBuild();
  const sort2 = (list, loose) => list.sort((a2, b2) => compareBuild(a2, b2, loose));
  sort_1 = sort2;
  return sort_1;
}
var rsort_1;
var hasRequiredRsort;
function requireRsort() {
  if (hasRequiredRsort) return rsort_1;
  hasRequiredRsort = 1;
  const compareBuild = requireCompareBuild();
  const rsort = (list, loose) => list.sort((a2, b2) => compareBuild(b2, a2, loose));
  rsort_1 = rsort;
  return rsort_1;
}
var gt_1$1;
var hasRequiredGt;
function requireGt() {
  if (hasRequiredGt) return gt_1$1;
  hasRequiredGt = 1;
  const compare2 = requireCompare();
  const gt2 = (a2, b2, loose) => compare2(a2, b2, loose) > 0;
  gt_1$1 = gt2;
  return gt_1$1;
}
var lt_1$1;
var hasRequiredLt;
function requireLt() {
  if (hasRequiredLt) return lt_1$1;
  hasRequiredLt = 1;
  const compare2 = requireCompare();
  const lt2 = (a2, b2, loose) => compare2(a2, b2, loose) < 0;
  lt_1$1 = lt2;
  return lt_1$1;
}
var eq_1$1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1$1;
  hasRequiredEq = 1;
  const compare2 = requireCompare();
  const eq2 = (a2, b2, loose) => compare2(a2, b2, loose) === 0;
  eq_1$1 = eq2;
  return eq_1$1;
}
var neq_1$1;
var hasRequiredNeq;
function requireNeq() {
  if (hasRequiredNeq) return neq_1$1;
  hasRequiredNeq = 1;
  const compare2 = requireCompare();
  const neq2 = (a2, b2, loose) => compare2(a2, b2, loose) !== 0;
  neq_1$1 = neq2;
  return neq_1$1;
}
var gte_1$1;
var hasRequiredGte;
function requireGte() {
  if (hasRequiredGte) return gte_1$1;
  hasRequiredGte = 1;
  const compare2 = requireCompare();
  const gte2 = (a2, b2, loose) => compare2(a2, b2, loose) >= 0;
  gte_1$1 = gte2;
  return gte_1$1;
}
var lte_1$1;
var hasRequiredLte;
function requireLte() {
  if (hasRequiredLte) return lte_1$1;
  hasRequiredLte = 1;
  const compare2 = requireCompare();
  const lte2 = (a2, b2, loose) => compare2(a2, b2, loose) <= 0;
  lte_1$1 = lte2;
  return lte_1$1;
}
var cmp_1$1;
var hasRequiredCmp;
function requireCmp() {
  if (hasRequiredCmp) return cmp_1$1;
  hasRequiredCmp = 1;
  const eq2 = requireEq();
  const neq2 = requireNeq();
  const gt2 = requireGt();
  const gte2 = requireGte();
  const lt2 = requireLt();
  const lte2 = requireLte();
  const cmp2 = (a2, op, b2, loose) => {
    switch (op) {
      case "===":
        if (typeof a2 === "object") {
          a2 = a2.version;
        }
        if (typeof b2 === "object") {
          b2 = b2.version;
        }
        return a2 === b2;
      case "!==":
        if (typeof a2 === "object") {
          a2 = a2.version;
        }
        if (typeof b2 === "object") {
          b2 = b2.version;
        }
        return a2 !== b2;
      case "":
      case "=":
      case "==":
        return eq2(a2, b2, loose);
      case "!=":
        return neq2(a2, b2, loose);
      case ">":
        return gt2(a2, b2, loose);
      case ">=":
        return gte2(a2, b2, loose);
      case "<":
        return lt2(a2, b2, loose);
      case "<=":
        return lte2(a2, b2, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  cmp_1$1 = cmp2;
  return cmp_1$1;
}
var coerce_1;
var hasRequiredCoerce;
function requireCoerce() {
  if (hasRequiredCoerce) return coerce_1;
  hasRequiredCoerce = 1;
  const SemVer2 = requireSemver$1();
  const parse2 = requireParse();
  const { safeRe: re2, t: t4 } = requireRe();
  const coerce2 = (version2, options) => {
    if (version2 instanceof SemVer2) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match2 = null;
    if (!options.rtl) {
      match2 = version2.match(options.includePrerelease ? re2[t4.COERCEFULL] : re2[t4.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re2[t4.COERCERTLFULL] : re2[t4.COERCERTL];
      let next2;
      while ((next2 = coerceRtlRegex.exec(version2)) && (!match2 || match2.index + match2[0].length !== version2.length)) {
        if (!match2 || next2.index + next2[0].length !== match2.index + match2[0].length) {
          match2 = next2;
        }
        coerceRtlRegex.lastIndex = next2.index + next2[1].length + next2[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match2 === null) {
      return null;
    }
    const major = match2[2];
    const minor = match2[3] || "0";
    const patch2 = match2[4] || "0";
    const prerelease = options.includePrerelease && match2[5] ? `-${match2[5]}` : "";
    const build = options.includePrerelease && match2[6] ? `+${match2[6]}` : "";
    return parse2(`${major}.${minor}.${patch2}${prerelease}${build}`, options);
  };
  coerce_1 = coerce2;
  return coerce_1;
}
var lrucache;
var hasRequiredLrucache;
function requireLrucache() {
  if (hasRequiredLrucache) return lrucache;
  hasRequiredLrucache = 1;
  class LRUCache2 {
    constructor() {
      this.max = 1e3;
      this.map = /* @__PURE__ */ new Map();
    }
    get(key2) {
      const value2 = this.map.get(key2);
      if (value2 === void 0) {
        return void 0;
      } else {
        this.map.delete(key2);
        this.map.set(key2, value2);
        return value2;
      }
    }
    delete(key2) {
      return this.map.delete(key2);
    }
    set(key2, value2) {
      const deleted = this.delete(key2);
      if (!deleted && value2 !== void 0) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key2, value2);
      }
      return this;
    }
  }
  lrucache = LRUCache2;
  return lrucache;
}
var range$2;
var hasRequiredRange$1;
function requireRange$1() {
  if (hasRequiredRange$1) return range$2;
  hasRequiredRange$1 = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c2) => c2.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c2) => !isNullSet(c2[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c2 of this.set) {
            if (c2.length === 1 && isAny(c2[0])) {
              this.set = [c2];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache2.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t4.HYPHENRANGELOOSE] : re2[t4.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t4.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t4.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t4.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t4.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache2.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer2(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range$2 = Range2;
  const LRU = requireLrucache();
  const cache2 = new LRU();
  const parseOptions2 = requireParseOptions();
  const Comparator = requireComparator$1();
  const debug2 = requireDebug();
  const SemVer2 = requireSemver$1();
  const {
    safeRe: re2,
    t: t4,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = requireRe();
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();
  const isNullSet = (c2) => c2.value === "<0.0.0-0";
  const isAny = (c2) => c2.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX2 = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r2 = options.loose ? re2[t4.TILDELOOSE] : re2[t4.TILDE];
    return comp.replace(r2, (_, M2, m2, p, pr) => {
      debug2("tilde", comp, _, M2, m2, p, pr);
      let ret;
      if (isX2(M2)) {
        ret = "";
      } else if (isX2(m2)) {
        ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
      } else if (isX2(p)) {
        ret = `>=${M2}.${m2}.0 <${M2}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M2}.${m2}.${p} <${M2}.${+m2 + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r2 = options.loose ? re2[t4.CARETLOOSE] : re2[t4.CARET];
    const z2 = options.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_, M2, m2, p, pr) => {
      debug2("caret", comp, _, M2, m2, p, pr);
      let ret;
      if (isX2(M2)) {
        ret = "";
      } else if (isX2(m2)) {
        ret = `>=${M2}.0.0${z2} <${+M2 + 1}.0.0-0`;
      } else if (isX2(p)) {
        if (M2 === "0") {
          ret = `>=${M2}.${m2}.0${z2} <${M2}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m2}.0${z2} <${+M2 + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p}-${pr} <${+M2 + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p}${z2} <${M2}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p}${z2} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p} <${+M2 + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r2 = options.loose ? re2[t4.XRANGELOOSE] : re2[t4.XRANGE];
    return comp.replace(r2, (ret, gtlt, M2, m2, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M2, m2, p, pr);
      const xM = isX2(M2);
      const xm = xM || isX2(m2);
      const xp = xm || isX2(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M2 = +M2 + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M2 = +M2 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M2}.${m2}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M2}.${m2}.0${pr} <${M2}.${+m2 + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t4.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t4.GTE0PRE : t4.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from2, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX2(fM)) {
      from2 = "";
    } else if (isX2(fm)) {
      from2 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX2(fp)) {
      from2 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from2 = `>=${from2}`;
    } else {
      from2 = `>=${from2}${incPr ? "-0" : ""}`;
    }
    if (isX2(tM)) {
      to = "";
    } else if (isX2(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX2(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from2} ${to}`.trim();
  };
  const testSet = (set2, version2, options) => {
    for (let i = 0; i < set2.length; i++) {
      if (!set2[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set2.length; i++) {
        debug2(set2[i].semver);
        if (set2[i].semver === Comparator.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range$2;
}
var comparator$1;
var hasRequiredComparator$1;
function requireComparator$1() {
  if (hasRequiredComparator$1) return comparator$1;
  hasRequiredComparator$1 = 1;
  const ANY = Symbol("SemVer ANY");
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r2 = this.options.loose ? re2[t4.COMPARATORLOOSE] : re2[t4.COMPARATOR];
      const m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer2(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer2(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator$1 = Comparator;
  const parseOptions2 = requireParseOptions();
  const { safeRe: re2, t: t4 } = requireRe();
  const cmp2 = requireCmp();
  const debug2 = requireDebug();
  const SemVer2 = requireSemver$1();
  const Range2 = requireRange$1();
  return comparator$1;
}
var satisfies_1$1;
var hasRequiredSatisfies;
function requireSatisfies() {
  if (hasRequiredSatisfies) return satisfies_1$1;
  hasRequiredSatisfies = 1;
  const Range2 = requireRange$1();
  const satisfies2 = (version2, range2, options) => {
    try {
      range2 = new Range2(range2, options);
    } catch (er) {
      return false;
    }
    return range2.test(version2);
  };
  satisfies_1$1 = satisfies2;
  return satisfies_1$1;
}
var toComparators_1;
var hasRequiredToComparators;
function requireToComparators() {
  if (hasRequiredToComparators) return toComparators_1;
  hasRequiredToComparators = 1;
  const Range2 = requireRange$1();
  const toComparators = (range2, options) => new Range2(range2, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
  toComparators_1 = toComparators;
  return toComparators_1;
}
var maxSatisfying_1;
var hasRequiredMaxSatisfying;
function requireMaxSatisfying() {
  if (hasRequiredMaxSatisfying) return maxSatisfying_1;
  hasRequiredMaxSatisfying = 1;
  const SemVer2 = requireSemver$1();
  const Range2 = requireRange$1();
  const maxSatisfying = (versions, range2, options) => {
    let max2 = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range2(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max2 || maxSV.compare(v) === -1) {
          max2 = v;
          maxSV = new SemVer2(max2, options);
        }
      }
    });
    return max2;
  };
  maxSatisfying_1 = maxSatisfying;
  return maxSatisfying_1;
}
var minSatisfying_1;
var hasRequiredMinSatisfying;
function requireMinSatisfying() {
  if (hasRequiredMinSatisfying) return minSatisfying_1;
  hasRequiredMinSatisfying = 1;
  const SemVer2 = requireSemver$1();
  const Range2 = requireRange$1();
  const minSatisfying = (versions, range2, options) => {
    let min2 = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range2(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min2 || minSV.compare(v) === 1) {
          min2 = v;
          minSV = new SemVer2(min2, options);
        }
      }
    });
    return min2;
  };
  minSatisfying_1 = minSatisfying;
  return minSatisfying_1;
}
var minVersion_1;
var hasRequiredMinVersion;
function requireMinVersion() {
  if (hasRequiredMinVersion) return minVersion_1;
  hasRequiredMinVersion = 1;
  const SemVer2 = requireSemver$1();
  const Range2 = requireRange$1();
  const gt2 = requireGt();
  const minVersion = (range2, loose) => {
    range2 = new Range2(range2, loose);
    let minver = new SemVer2("0.0.0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = new SemVer2("0.0.0-0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let setMin = null;
      comparators.forEach((comparator2) => {
        const compver = new SemVer2(comparator2.semver.version);
        switch (comparator2.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          /* fallthrough */
          case "":
          case ">=":
            if (!setMin || gt2(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${comparator2.operator}`);
        }
      });
      if (setMin && (!minver || gt2(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range2.test(minver)) {
      return minver;
    }
    return null;
  };
  minVersion_1 = minVersion;
  return minVersion_1;
}
var valid;
var hasRequiredValid;
function requireValid() {
  if (hasRequiredValid) return valid;
  hasRequiredValid = 1;
  const Range2 = requireRange$1();
  const validRange = (range2, options) => {
    try {
      return new Range2(range2, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  valid = validRange;
  return valid;
}
var outside_1;
var hasRequiredOutside;
function requireOutside() {
  if (hasRequiredOutside) return outside_1;
  hasRequiredOutside = 1;
  const SemVer2 = requireSemver$1();
  const Comparator = requireComparator$1();
  const { ANY } = Comparator;
  const Range2 = requireRange$1();
  const satisfies2 = requireSatisfies();
  const gt2 = requireGt();
  const lt2 = requireLt();
  const lte2 = requireLte();
  const gte2 = requireGte();
  const outside = (version2, range2, hilo, options) => {
    version2 = new SemVer2(version2, options);
    range2 = new Range2(range2, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt2;
        ltefn = lte2;
        ltfn = lt2;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt2;
        ltefn = gte2;
        ltfn = gt2;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies2(version2, range2, options)) {
      return false;
    }
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator2) => {
        if (comparator2.semver === ANY) {
          comparator2 = new Comparator(">=0.0.0");
        }
        high = high || comparator2;
        low = low || comparator2;
        if (gtfn(comparator2.semver, high.semver, options)) {
          high = comparator2;
        } else if (ltfn(comparator2.semver, low.semver, options)) {
          low = comparator2;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  outside_1 = outside;
  return outside_1;
}
var gtr_1;
var hasRequiredGtr;
function requireGtr() {
  if (hasRequiredGtr) return gtr_1;
  hasRequiredGtr = 1;
  const outside = requireOutside();
  const gtr = (version2, range2, options) => outside(version2, range2, ">", options);
  gtr_1 = gtr;
  return gtr_1;
}
var ltr_1;
var hasRequiredLtr;
function requireLtr() {
  if (hasRequiredLtr) return ltr_1;
  hasRequiredLtr = 1;
  const outside = requireOutside();
  const ltr = (version2, range2, options) => outside(version2, range2, "<", options);
  ltr_1 = ltr;
  return ltr_1;
}
var intersects_1;
var hasRequiredIntersects;
function requireIntersects() {
  if (hasRequiredIntersects) return intersects_1;
  hasRequiredIntersects = 1;
  const Range2 = requireRange$1();
  const intersects2 = (r1, r2, options) => {
    r1 = new Range2(r1, options);
    r2 = new Range2(r2, options);
    return r1.intersects(r2, options);
  };
  intersects_1 = intersects2;
  return intersects_1;
}
var simplify;
var hasRequiredSimplify;
function requireSimplify() {
  if (hasRequiredSimplify) return simplify;
  hasRequiredSimplify = 1;
  const satisfies2 = requireSatisfies();
  const compare2 = requireCompare();
  simplify = (versions, range2, options) => {
    const set2 = [];
    let first = null;
    let prev2 = null;
    const v = versions.sort((a2, b2) => compare2(a2, b2, options));
    for (const version2 of v) {
      const included = satisfies2(version2, range2, options);
      if (included) {
        prev2 = version2;
        if (!first) {
          first = version2;
        }
      } else {
        if (prev2) {
          set2.push([first, prev2]);
        }
        prev2 = null;
        first = null;
      }
    }
    if (first) {
      set2.push([first, null]);
    }
    const ranges2 = [];
    for (const [min2, max2] of set2) {
      if (min2 === max2) {
        ranges2.push(min2);
      } else if (!max2 && min2 === v[0]) {
        ranges2.push("*");
      } else if (!max2) {
        ranges2.push(`>=${min2}`);
      } else if (min2 === v[0]) {
        ranges2.push(`<=${max2}`);
      } else {
        ranges2.push(`${min2} - ${max2}`);
      }
    }
    const simplified = ranges2.join(" || ");
    const original = typeof range2.raw === "string" ? range2.raw : String(range2);
    return simplified.length < original.length ? simplified : range2;
  };
  return simplify;
}
var subset_1;
var hasRequiredSubset;
function requireSubset() {
  if (hasRequiredSubset) return subset_1;
  hasRequiredSubset = 1;
  const Range2 = requireRange$1();
  const Comparator = requireComparator$1();
  const { ANY } = Comparator;
  const satisfies2 = requireSatisfies();
  const compare2 = requireCompare();
  const subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range2(sub, options);
    dom = new Range2(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
    return true;
  };
  const minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  const minimumVersion = [new Comparator(">=0.0.0")];
  const simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = /* @__PURE__ */ new Set();
    let gt2, lt2;
    for (const c2 of sub) {
      if (c2.operator === ">" || c2.operator === ">=") {
        gt2 = higherGT(gt2, c2, options);
      } else if (c2.operator === "<" || c2.operator === "<=") {
        lt2 = lowerLT(lt2, c2, options);
      } else {
        eqSet.add(c2.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt2 && lt2) {
      gtltComp = compare2(gt2.semver, lt2.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
        return null;
      }
    }
    for (const eq2 of eqSet) {
      if (gt2 && !satisfies2(eq2, String(gt2), options)) {
        return null;
      }
      if (lt2 && !satisfies2(eq2, String(lt2), options)) {
        return null;
      }
      for (const c2 of dom) {
        if (!satisfies2(eq2, String(c2), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
    let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c2 of dom) {
      hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
      hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
      if (gt2) {
        if (needDomGTPre) {
          if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c2.operator === ">" || c2.operator === ">=") {
          higher = higherGT(gt2, c2, options);
          if (higher === c2 && higher !== gt2) {
            return false;
          }
        } else if (gt2.operator === ">=" && !satisfies2(gt2.semver, String(c2), options)) {
          return false;
        }
      }
      if (lt2) {
        if (needDomLTPre) {
          if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c2.operator === "<" || c2.operator === "<=") {
          lower = lowerLT(lt2, c2, options);
          if (lower === c2 && lower !== lt2) {
            return false;
          }
        } else if (lt2.operator === "<=" && !satisfies2(lt2.semver, String(c2), options)) {
          return false;
        }
      }
      if (!c2.operator && (lt2 || gt2) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
      return false;
    }
    if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  const higherGT = (a2, b2, options) => {
    if (!a2) {
      return b2;
    }
    const comp = compare2(a2.semver, b2.semver, options);
    return comp > 0 ? a2 : comp < 0 ? b2 : b2.operator === ">" && a2.operator === ">=" ? b2 : a2;
  };
  const lowerLT = (a2, b2, options) => {
    if (!a2) {
      return b2;
    }
    const comp = compare2(a2.semver, b2.semver, options);
    return comp < 0 ? a2 : comp > 0 ? b2 : b2.operator === "<" && a2.operator === "<=" ? b2 : a2;
  };
  subset_1 = subset;
  return subset_1;
}
var semver$1;
var hasRequiredSemver;
function requireSemver() {
  if (hasRequiredSemver) return semver$1;
  hasRequiredSemver = 1;
  const internalRe = requireRe();
  const constants2 = requireConstants();
  const SemVer2 = requireSemver$1();
  const identifiers2 = requireIdentifiers();
  const parse2 = requireParse();
  const valid2 = requireValid$1();
  const clean = requireClean();
  const inc = requireInc();
  const diff = requireDiff();
  const major = requireMajor();
  const minor = requireMinor();
  const patch2 = requirePatch();
  const prerelease = requirePrerelease();
  const compare2 = requireCompare();
  const rcompare = requireRcompare();
  const compareLoose = requireCompareLoose();
  const compareBuild = requireCompareBuild();
  const sort2 = requireSort();
  const rsort = requireRsort();
  const gt2 = requireGt();
  const lt2 = requireLt();
  const eq2 = requireEq();
  const neq2 = requireNeq();
  const gte2 = requireGte();
  const lte2 = requireLte();
  const cmp2 = requireCmp();
  const coerce2 = requireCoerce();
  const Comparator = requireComparator$1();
  const Range2 = requireRange$1();
  const satisfies2 = requireSatisfies();
  const toComparators = requireToComparators();
  const maxSatisfying = requireMaxSatisfying();
  const minSatisfying = requireMinSatisfying();
  const minVersion = requireMinVersion();
  const validRange = requireValid();
  const outside = requireOutside();
  const gtr = requireGtr();
  const ltr = requireLtr();
  const intersects2 = requireIntersects();
  const simplifyRange = requireSimplify();
  const subset = requireSubset();
  semver$1 = {
    parse: parse2,
    valid: valid2,
    clean,
    inc,
    diff,
    major,
    minor,
    patch: patch2,
    prerelease,
    compare: compare2,
    rcompare,
    compareLoose,
    compareBuild,
    sort: sort2,
    rsort,
    gt: gt2,
    lt: lt2,
    eq: eq2,
    neq: neq2,
    gte: gte2,
    lte: lte2,
    cmp: cmp2,
    coerce: coerce2,
    Comparator,
    Range: Range2,
    satisfies: satisfies2,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects: intersects2,
    simplifyRange,
    subset,
    SemVer: SemVer2,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants2.RELEASE_TYPES,
    compareIdentifiers: identifiers2.compareIdentifiers,
    rcompareIdentifiers: identifiers2.rcompareIdentifiers
  };
  return semver$1;
}
requireSemver();
const ViewType$1 = {
  DESCRIPTION: "description",
  STATUS: "status",
  SCATTERPLOT: "scatterplot",
  SPATIAL: "spatial",
  SPATIAL_BETA: "spatialBeta",
  HEATMAP: "heatmap",
  LAYER_CONTROLLER: "layerController",
  LAYER_CONTROLLER_BETA: "layerControllerBeta",
  GENOMIC_PROFILES: "genomicProfiles",
  GATING: "gating",
  FEATURE_LIST: "featureList",
  OBS_SETS: "obsSets",
  OBS_SET_SIZES: "obsSetSizes",
  OBS_SET_FEATURE_VALUE_DISTRIBUTION: "obsSetFeatureValueDistribution",
  FEATURE_VALUE_HISTOGRAM: "featureValueHistogram",
  DOT_PLOT: "dotPlot",
  FEATURE_BAR_PLOT: "featureBarPlot",
  VOLCANO_PLOT: "volcanoPlot",
  OBS_SET_COMPOSITION_BAR_PLOT: "obsSetCompositionBarPlot",
  FEATURE_SET_ENRICHMENT_BAR_PLOT: "featureSetEnrichmentBarPlot",
  BIOMARKER_SELECT: "biomarkerSelect",
  COMPARATIVE_HEADING: "comparativeHeading",
  LINK_CONTROLLER: "linkController",
  NEUROGLANCER: "neuroglancer",
  DUAL_SCATTERPLOT: "dualScatterplot",
  TREEMAP: "treemap",
  SAMPLE_SET_PAIR_MANAGER: "sampleSetPairManager",
  FEATURE_STATS_TABLE: "featureStatsTable"
};
const DataType$1 = {
  OBS_LABELS: "obsLabels",
  OBS_EMBEDDING: "obsEmbedding",
  OBS_FEATURE_MATRIX: "obsFeatureMatrix",
  OBS_SETS: "obsSets",
  FEATURE_LABELS: "featureLabels",
  IMAGE: "image",
  OBS_SEGMENTATIONS: "obsSegmentations",
  NEIGHBORHOODS: "neighborhoods",
  GENOMIC_PROFILES: "genomic-profiles",
  OBS_SPOTS: "obsSpots",
  OBS_POINTS: "obsPoints",
  OBS_LOCATIONS: "obsLocations",
  SAMPLE_SETS: "sampleSets",
  SAMPLE_EDGES: "sampleEdges",
  COMPARISON_METADATA: "comparisonMetadata",
  FEATURE_STATS: "featureStats",
  FEATURE_SET_STATS: "featureSetStats",
  OBS_SET_STATS: "obsSetStats"
};
const FileType$1 = {
  // Joint file types
  ANNDATA_ZARR: "anndata.zarr",
  ANNDATA_ZARR_ZIP: "anndata.zarr.zip",
  ANNDATA_H5AD: "anndata.h5ad",
  SPATIALDATA_ZARR: "spatialdata.zarr",
  // Atomic file types
  OBS_EMBEDDING_CSV: "obsEmbedding.csv",
  OBS_SPOTS_CSV: "obsSpots.csv",
  OBS_POINTS_CSV: "obsPoints.csv",
  OBS_LOCATIONS_CSV: "obsLocations.csv",
  OBS_LABELS_CSV: "obsLabels.csv",
  FEATURE_LABELS_CSV: "featureLabels.csv",
  OBS_FEATURE_MATRIX_CSV: "obsFeatureMatrix.csv",
  OBS_SEGMENTATIONS_JSON: "obsSegmentations.json",
  OBS_SETS_CSV: "obsSets.csv",
  OBS_SETS_JSON: "obsSets.json",
  SAMPLE_SETS_CSV: "sampleSets.csv",
  // OME-Zarr
  IMAGE_OME_ZARR: "image.ome-zarr",
  OBS_SEGMENTATIONS_OME_ZARR: "obsSegmentations.ome-zarr",
  // OME-Zarr - Zipped
  IMAGE_OME_ZARR_ZIP: "image.ome-zarr.zip",
  OBS_SEGMENTATIONS_OME_ZARR_ZIP: "obsSegmentations.ome-zarr.zip",
  // AnnData
  OBS_FEATURE_MATRIX_ANNDATA_ZARR: "obsFeatureMatrix.anndata.zarr",
  OBS_FEATURE_COLUMNS_ANNDATA_ZARR: "obsFeatureColumns.anndata.zarr",
  OBS_SETS_ANNDATA_ZARR: "obsSets.anndata.zarr",
  OBS_EMBEDDING_ANNDATA_ZARR: "obsEmbedding.anndata.zarr",
  OBS_SPOTS_ANNDATA_ZARR: "obsSpots.anndata.zarr",
  OBS_POINTS_ANNDATA_ZARR: "obsPoints.anndata.zarr",
  OBS_LOCATIONS_ANNDATA_ZARR: "obsLocations.anndata.zarr",
  OBS_SEGMENTATIONS_ANNDATA_ZARR: "obsSegmentations.anndata.zarr",
  OBS_LABELS_ANNDATA_ZARR: "obsLabels.anndata.zarr",
  FEATURE_LABELS_ANNDATA_ZARR: "featureLabels.anndata.zarr",
  SAMPLE_EDGES_ANNDATA_ZARR: "sampleEdges.anndata.zarr",
  SAMPLE_SETS_ANNDATA_ZARR: "sampleSets.anndata.zarr",
  COMPARISON_METADATA_ANNDATA_ZARR: "comparisonMetadata.anndata.zarr",
  COMPARATIVE_FEATURE_STATS_ANNDATA_ZARR: "comparativeFeatureStats.anndata.zarr",
  COMPARATIVE_FEATURE_SET_STATS_ANNDATA_ZARR: "comparativeFeatureSetStats.anndata.zarr",
  COMPARATIVE_OBS_SET_STATS_ANNDATA_ZARR: "comparativeObsSetStats.anndata.zarr",
  // AnnData - zipped
  OBS_FEATURE_MATRIX_ANNDATA_ZARR_ZIP: "obsFeatureMatrix.anndata.zarr.zip",
  OBS_FEATURE_COLUMNS_ANNDATA_ZARR_ZIP: "obsFeatureColumns.anndata.zarr.zip",
  OBS_SETS_ANNDATA_ZARR_ZIP: "obsSets.anndata.zarr.zip",
  OBS_EMBEDDING_ANNDATA_ZARR_ZIP: "obsEmbedding.anndata.zarr.zip",
  OBS_SPOTS_ANNDATA_ZARR_ZIP: "obsSpots.anndata.zarr.zip",
  OBS_POINTS_ANNDATA_ZARR_ZIP: "obsPoints.anndata.zarr.zip",
  OBS_LOCATIONS_ANNDATA_ZARR_ZIP: "obsLocations.anndata.zarr.zip",
  OBS_SEGMENTATIONS_ANNDATA_ZARR_ZIP: "obsSegmentations.anndata.zarr.zip",
  OBS_LABELS_ANNDATA_ZARR_ZIP: "obsLabels.anndata.zarr.zip",
  FEATURE_LABELS_ANNDATA_ZARR_ZIP: "featureLabels.anndata.zarr.zip",
  SAMPLE_EDGES_ANNDATA_ZARR_ZIP: "sampleEdges.anndata.zarr.zip",
  SAMPLE_SETS_ANNDATA_ZARR_ZIP: "sampleSets.anndata.zarr.zip",
  COMPARISON_METADATA_ANNDATA_ZARR_ZIP: "comparisonMetadata.anndata.zarr.zip",
  COMPARATIVE_FEATURE_STATS_ANNDATA_ZARR_ZIP: "comparativeFeatureStats.anndata.zarr.zip",
  COMPARATIVE_FEATURE_SET_STATS_ANNDATA_ZARR_ZIP: "comparativeFeatureSetStats.anndata.zarr.zip",
  COMPARATIVE_OBS_SET_STATS_ANNDATA_ZARR_ZIP: "comparativeObsSetStats.anndata.zarr.zip",
  // AnnData - h5ad via reference spec
  OBS_FEATURE_MATRIX_ANNDATA_H5AD: "obsFeatureMatrix.anndata.h5ad",
  OBS_FEATURE_COLUMNS_ANNDATA_H5AD: "obsFeatureColumns.anndata.h5ad",
  OBS_SETS_ANNDATA_H5AD: "obsSets.anndata.h5ad",
  OBS_EMBEDDING_ANNDATA_H5AD: "obsEmbedding.anndata.h5ad",
  OBS_SPOTS_ANNDATA_H5AD: "obsSpots.anndata.h5ad",
  OBS_POINTS_ANNDATA_H5AD: "obsPoints.anndata.h5ad",
  OBS_LOCATIONS_ANNDATA_H5AD: "obsLocations.anndata.h5ad",
  OBS_SEGMENTATIONS_ANNDATA_H5AD: "obsSegmentations.anndata.h5ad",
  OBS_LABELS_ANNDATA_H5AD: "obsLabels.anndata.h5ad",
  FEATURE_LABELS_ANNDATA_H5AD: "featureLabels.anndata.h5ad",
  SAMPLE_EDGES_ANNDATA_H5AD: "sampleEdges.anndata.h5ad",
  SAMPLE_SETS_ANNDATA_H5AD: "sampleSets.anndata.h5ad",
  COMPARISON_METADATA_ANNDATA_H5AD: "comparisonMetadata.anndata.h5ad",
  COMPARATIVE_FEATURE_STATS_ANNDATA_H5AD: "comparativeFeatureStats.anndata.h5ad",
  COMPARATIVE_FEATURE_SET_STATS_ANNDATA_H5AD: "comparativeFeatureSetStats.anndata.h5ad",
  COMPARATIVE_OBS_SET_STATS_ANNDATA_H5AD: "comparativeObsSetStats.anndata.h5ad",
  // SpatialData
  IMAGE_SPATIALDATA_ZARR: "image.spatialdata.zarr",
  LABELS_SPATIALDATA_ZARR: "labels.spatialdata.zarr",
  SHAPES_SPATIALDATA_ZARR: "shapes.spatialdata.zarr",
  OBS_FEATURE_MATRIX_SPATIALDATA_ZARR: "obsFeatureMatrix.spatialdata.zarr",
  OBS_SETS_SPATIALDATA_ZARR: "obsSets.spatialdata.zarr",
  OBS_SPOTS_SPATIALDATA_ZARR: "obsSpots.spatialdata.zarr",
  FEATURE_LABELS_SPATIALDATA_ZARR: "featureLabels.spatialdata.zarr",
  // TODO:
  // OBS_POINTS_SPATIALDATA_ZARR: 'obsPoints.spatialdata.zarr',
  // OBS_LOCATIONS_SPATIALDATA_ZARR: 'obsLocations.spatialdata.zarr',
  // MuData
  OBS_FEATURE_MATRIX_MUDATA_ZARR: "obsFeatureMatrix.mudata.zarr",
  OBS_SETS_MUDATA_ZARR: "obsSets.mudata.zarr",
  OBS_EMBEDDING_MUDATA_ZARR: "obsEmbedding.mudata.zarr",
  OBS_SPOTS_MUDATA_ZARR: "obsSpots.mudata.zarr",
  OBS_POINTS_MUDATA_ZARR: "obsPoints.mudata.zarr",
  OBS_LOCATIONS_MUDATA_ZARR: "obsLocations.mudata.zarr",
  OBS_SEGMENTATIONS_MUDATA_ZARR: "obsSegmentations.mudata.zarr",
  OBS_LABELS_MUDATA_ZARR: "obsLabels.mudata.zarr",
  FEATURE_LABELS_MUDATA_ZARR: "featureLabels.mudata.zarr",
  GENOMIC_PROFILES_ZARR: "genomic-profiles.zarr",
  NEIGHBORHOODS_JSON: "neighborhoods.json",
  // OME-TIFF
  IMAGE_OME_TIFF: "image.ome-tiff",
  OBS_SEGMENTATIONS_OME_TIFF: "obsSegmentations.ome-tiff",
  // GLB
  OBS_SEGMENTATIONS_GLB: "obsSegmentations.glb",
  // New file types to support old file types:
  // - cells.json
  OBS_EMBEDDING_CELLS_JSON: "obsEmbedding.cells.json",
  OBS_SEGMENTATIONS_CELLS_JSON: "obsSegmentations.cells.json",
  OBS_LOCATIONS_CELLS_JSON: "obsLocations.cells.json",
  OBS_LABELS_CELLS_JSON: "obsLabels.cells.json",
  // - cell-sets.json
  OBS_SETS_CELL_SETS_JSON: "obsSets.cell-sets.json",
  // - genes.json
  OBS_FEATURE_MATRIX_GENES_JSON: "obsFeatureMatrix.genes.json",
  // - clusters.json
  OBS_FEATURE_MATRIX_CLUSTERS_JSON: "obsFeatureMatrix.clusters.json",
  // - expression-matrix.zarr
  OBS_FEATURE_MATRIX_EXPRESSION_MATRIX_ZARR: "obsFeatureMatrix.expression-matrix.zarr",
  // - raster.json
  IMAGE_RASTER_JSON: "image.raster.json",
  OBS_SEGMENTATIONS_RASTER_JSON: "obsSegmentations.raster.json",
  // - molecules.json
  OBS_LOCATIONS_MOLECULES_JSON: "obsLocations.molecules.json",
  OBS_LABELS_MOLECULES_JSON: "obsLabels.molecules.json",
  // Legacy joint file types
  CELLS_JSON: "cells.json",
  CELL_SETS_JSON: "cell-sets.json",
  ANNDATA_CELL_SETS_ZARR: "anndata-cell-sets.zarr",
  ANNDATA_CELLS_ZARR: "anndata-cells.zarr",
  EXPRESSION_MATRIX_ZARR: "expression-matrix.zarr",
  MOLECULES_JSON: "molecules.json",
  RASTER_JSON: "raster.json",
  RASTER_OME_ZARR: "raster.ome-zarr",
  CLUSTERS_JSON: "clusters.json",
  GENES_JSON: "genes.json",
  ANNDATA_EXPRESSION_MATRIX_ZARR: "anndata-expression-matrix.zarr"
};
const CoordinationType$1 = {
  META_COORDINATION_SCOPES: "metaCoordinationScopes",
  META_COORDINATION_SCOPES_BY: "metaCoordinationScopesBy",
  DATASET: "dataset",
  // Entity types
  OBS_TYPE: "obsType",
  FEATURE_TYPE: "featureType",
  FEATURE_VALUE_TYPE: "featureValueType",
  OBS_LABELS_TYPE: "obsLabelsType",
  FEATURE_LABELS_TYPE: "featureLabelsType",
  // Other types
  EMBEDDING_TYPE: "embeddingType",
  EMBEDDING_ZOOM: "embeddingZoom",
  EMBEDDING_ROTATION: "embeddingRotation",
  EMBEDDING_TARGET_X: "embeddingTargetX",
  EMBEDDING_TARGET_Y: "embeddingTargetY",
  EMBEDDING_TARGET_Z: "embeddingTargetZ",
  EMBEDDING_OBS_SET_POLYGONS_VISIBLE: "embeddingObsSetPolygonsVisible",
  EMBEDDING_OBS_SET_LABELS_VISIBLE: "embeddingObsSetLabelsVisible",
  EMBEDDING_OBS_SET_LABEL_SIZE: "embeddingObsSetLabelSize",
  EMBEDDING_OBS_RADIUS: "embeddingObsRadius",
  EMBEDDING_OBS_RADIUS_MODE: "embeddingObsRadiusMode",
  EMBEDDING_OBS_OPACITY: "embeddingObsOpacity",
  EMBEDDING_OBS_OPACITY_MODE: "embeddingObsOpacityMode",
  SPATIAL_ZOOM: "spatialZoom",
  SPATIAL_ROTATION: "spatialRotation",
  SPATIAL_TARGET_X: "spatialTargetX",
  SPATIAL_TARGET_Y: "spatialTargetY",
  SPATIAL_TARGET_Z: "spatialTargetZ",
  SPATIAL_TARGET_T: "spatialTargetT",
  SPATIAL_ROTATION_X: "spatialRotationX",
  SPATIAL_ROTATION_Y: "spatialRotationY",
  SPATIAL_ROTATION_Z: "spatialRotationZ",
  SPATIAL_ROTATION_ORBIT: "spatialRotationOrbit",
  SPATIAL_ORBIT_AXIS: "spatialOrbitAxis",
  SPATIAL_AXIS_FIXED: "spatialAxisFixed",
  HEATMAP_ZOOM_X: "heatmapZoomX",
  HEATMAP_ZOOM_Y: "heatmapZoomY",
  HEATMAP_TARGET_X: "heatmapTargetX",
  HEATMAP_TARGET_Y: "heatmapTargetY",
  OBS_HIGHLIGHT: "obsHighlight",
  OBS_SELECTION: "obsSelection",
  OBS_SET_SELECTION: "obsSetSelection",
  OBS_SELECTION_MODE: "obsSelectionMode",
  OBS_FILTER: "obsFilter",
  OBS_SET_FILTER: "obsSetFilter",
  OBS_FILTER_MODE: "obsFilterMode",
  OBS_SET_HIGHLIGHT: "obsSetHighlight",
  OBS_SET_EXPANSION: "obsSetExpansion",
  OBS_SET_COLOR: "obsSetColor",
  FEATURE_HIGHLIGHT: "featureHighlight",
  FEATURE_SELECTION: "featureSelection",
  FEATURE_SET_SELECTION: "featureSetSelection",
  FEATURE_SELECTION_MODE: "featureSelectionMode",
  FEATURE_FILTER: "featureFilter",
  FEATURE_SET_FILTER: "featureSetFilter",
  FEATURE_FILTER_MODE: "featureFilterMode",
  FEATURE_VALUE_COLORMAP: "featureValueColormap",
  FEATURE_VALUE_TRANSFORM: "featureValueTransform",
  FEATURE_VALUE_COLORMAP_RANGE: "featureValueColormapRange",
  FEATURE_AGGREGATION_STRATEGY: "featureAggregationStrategy",
  OBS_COLOR_ENCODING: "obsColorEncoding",
  SPATIAL_IMAGE_LAYER: "spatialImageLayer",
  SPATIAL_SEGMENTATION_LAYER: "spatialSegmentationLayer",
  SPATIAL_POINT_LAYER: "spatialPointLayer",
  SPATIAL_NEIGHBORHOOD_LAYER: "spatialNeighborhoodLayer",
  GENOMIC_ZOOM_X: "genomicZoomX",
  GENOMIC_ZOOM_Y: "genomicZoomY",
  GENOMIC_TARGET_X: "genomicTargetX",
  GENOMIC_TARGET_Y: "genomicTargetY",
  ADDITIONAL_OBS_SETS: "additionalObsSets",
  // TODO: use obsHighlight rather than moleculeHighlight.
  MOLECULE_HIGHLIGHT: "moleculeHighlight",
  GATING_FEATURE_SELECTION_X: "gatingFeatureSelectionX",
  GATING_FEATURE_SELECTION_Y: "gatingFeatureSelectionY",
  FEATURE_VALUE_TRANSFORM_COEFFICIENT: "featureValueTransformCoefficient",
  FEATURE_VALUE_POSITIVITY_THRESHOLD: "featureValuePositivityThreshold",
  TOOLTIPS_VISIBLE: "tooltipsVisible",
  FILE_UID: "fileUid",
  IMAGE_LAYER: "imageLayer",
  IMAGE_CHANNEL: "imageChannel",
  SEGMENTATION_LAYER: "segmentationLayer",
  SEGMENTATION_CHANNEL: "segmentationChannel",
  SPATIAL_TARGET_C: "spatialTargetC",
  SPATIAL_LAYER_VISIBLE: "spatialLayerVisible",
  SPATIAL_LAYER_OPACITY: "spatialLayerOpacity",
  SPATIAL_LAYER_COLORMAP: "spatialLayerColormap",
  SPATIAL_LAYER_TRANSPARENT_COLOR: "spatialLayerTransparentColor",
  SPATIAL_LAYER_MODEL_MATRIX: "spatialLayerModelMatrix",
  SPATIAL_SEGMENTATION_FILLED: "spatialSegmentationFilled",
  SPATIAL_SEGMENTATION_STROKE_WIDTH: "spatialSegmentationStrokeWidth",
  SPATIAL_CHANNEL_COLOR: "spatialChannelColor",
  SPATIAL_CHANNEL_VISIBLE: "spatialChannelVisible",
  SPATIAL_CHANNEL_OPACITY: "spatialChannelOpacity",
  SPATIAL_CHANNEL_WINDOW: "spatialChannelWindow",
  PHOTOMETRIC_INTERPRETATION: "photometricInterpretation",
  // For 3D volume rendering
  SPATIAL_RENDERING_MODE: "spatialRenderingMode",
  // For whole spatial view
  VOLUMETRIC_RENDERING_ALGORITHM: "volumetricRenderingAlgorithm",
  // Could be per-image-layer
  SPATIAL_TARGET_RESOLUTION: "spatialTargetResolution",
  // Per-spatial-layer
  // For clipping plane sliders
  SPATIAL_SLICE_X: "spatialSliceX",
  SPATIAL_SLICE_Y: "spatialSliceY",
  SPATIAL_SLICE_Z: "spatialSliceZ",
  // For spatial spot and point layers
  SPOT_LAYER: "spotLayer",
  POINT_LAYER: "pointLayer",
  SPATIAL_SPOT_RADIUS: "spatialSpotRadius",
  // In micrometers?
  SPATIAL_SPOT_FILLED: "spatialSpotFilled",
  SPATIAL_SPOT_STROKE_WIDTH: "spatialSpotStrokeWidth",
  SPATIAL_LAYER_COLOR: "spatialLayerColor",
  PIXEL_HIGHLIGHT: "pixelHighlight",
  // Per-image-layer
  TOOLTIP_CROSSHAIRS_VISIBLE: "tooltipCrosshairsVisible",
  LEGEND_VISIBLE: "legendVisible",
  SPATIAL_CHANNEL_LABELS_VISIBLE: "spatialChannelLabelsVisible",
  SPATIAL_CHANNEL_LABELS_ORIENTATION: "spatialChannelLabelsOrientation",
  SPATIAL_CHANNEL_LABEL_SIZE: "spatialChannelLabelSize",
  // Multi-sample / comparative
  SAMPLE_TYPE: "sampleType",
  SAMPLE_SELECTION: "sampleSelection",
  SAMPLE_SET_SELECTION: "sampleSetSelection",
  SAMPLE_SELECTION_MODE: "sampleSelectionMode",
  SAMPLE_FILTER: "sampleFilter",
  SAMPLE_SET_FILTER: "sampleSetFilter",
  SAMPLE_FILTER_MODE: "sampleFilterMode",
  SAMPLE_SET_COLOR: "sampleSetColor",
  SAMPLE_HIGHLIGHT: "sampleHighlight",
  EMBEDDING_POINTS_VISIBLE: "embeddingPointsVisible",
  EMBEDDING_CONTOURS_VISIBLE: "embeddingContoursVisible",
  EMBEDDING_CONTOURS_FILLED: "embeddingContoursFilled",
  EMBEDDING_CONTOUR_PERCENTILES: "embeddingContourPercentiles",
  CONTOUR_COLOR_ENCODING: "contourColorEncoding",
  CONTOUR_COLOR: "contourColor",
  // For volcano plot:
  FEATURE_POINT_SIGNIFICANCE_THRESHOLD: "featurePointSignificanceThreshold",
  FEATURE_LABEL_SIGNIFICANCE_THRESHOLD: "featureLabelSignificanceThreshold",
  FEATURE_POINT_FOLD_CHANGE_THRESHOLD: "featurePointFoldChangeThreshold",
  FEATURE_LABEL_FOLD_CHANGE_THRESHOLD: "featureLabelFoldChangeThreshold",
  // Treemap
  HIERARCHY_LEVELS: "hierarchyLevels"
};
({
  // For new file types
  [FileType$1.OBS_EMBEDDING_CSV]: DataType$1.OBS_EMBEDDING,
  [FileType$1.OBS_SPOTS_CSV]: DataType$1.OBS_SPOTS,
  [FileType$1.OBS_POINTS_CSV]: DataType$1.OBS_POINTS,
  [FileType$1.OBS_LOCATIONS_CSV]: DataType$1.OBS_LOCATIONS,
  [FileType$1.OBS_LABELS_CSV]: DataType$1.OBS_LABELS,
  [FileType$1.FEATURE_LABELS_CSV]: DataType$1.FEATURE_LABELS,
  [FileType$1.SAMPLE_SETS_CSV]: DataType$1.SAMPLE_SETS,
  [FileType$1.OBS_FEATURE_MATRIX_CSV]: DataType$1.OBS_FEATURE_MATRIX,
  [FileType$1.OBS_SEGMENTATIONS_JSON]: DataType$1.OBS_SEGMENTATIONS,
  [FileType$1.OBS_SETS_CSV]: DataType$1.OBS_SETS,
  [FileType$1.OBS_SETS_JSON]: DataType$1.OBS_SETS,
  [FileType$1.IMAGE_OME_ZARR]: DataType$1.IMAGE,
  [FileType$1.OBS_SEGMENTATIONS_OME_ZARR]: DataType$1.OBS_SEGMENTATIONS,
  [FileType$1.OBS_FEATURE_MATRIX_ANNDATA_ZARR]: DataType$1.OBS_FEATURE_MATRIX,
  [FileType$1.OBS_FEATURE_COLUMNS_ANNDATA_ZARR]: DataType$1.OBS_FEATURE_MATRIX,
  [FileType$1.OBS_SETS_ANNDATA_ZARR]: DataType$1.OBS_SETS,
  [FileType$1.OBS_EMBEDDING_ANNDATA_ZARR]: DataType$1.OBS_EMBEDDING,
  [FileType$1.OBS_SPOTS_ANNDATA_ZARR]: DataType$1.OBS_SPOTS,
  [FileType$1.OBS_POINTS_ANNDATA_ZARR]: DataType$1.OBS_POINTS,
  [FileType$1.OBS_LOCATIONS_ANNDATA_ZARR]: DataType$1.OBS_LOCATIONS,
  [FileType$1.OBS_SEGMENTATIONS_ANNDATA_ZARR]: DataType$1.OBS_SEGMENTATIONS,
  [FileType$1.OBS_LABELS_ANNDATA_ZARR]: DataType$1.OBS_LABELS,
  [FileType$1.FEATURE_LABELS_ANNDATA_ZARR]: DataType$1.FEATURE_LABELS,
  [FileType$1.SAMPLE_EDGES_ANNDATA_ZARR]: DataType$1.SAMPLE_EDGES,
  [FileType$1.SAMPLE_SETS_ANNDATA_ZARR]: DataType$1.SAMPLE_SETS,
  [FileType$1.COMPARISON_METADATA_ANNDATA_ZARR]: DataType$1.COMPARISON_METADATA,
  [FileType$1.COMPARATIVE_FEATURE_STATS_ANNDATA_ZARR]: DataType$1.FEATURE_STATS,
  [FileType$1.COMPARATIVE_FEATURE_SET_STATS_ANNDATA_ZARR]: DataType$1.FEATURE_SET_STATS,
  [FileType$1.COMPARATIVE_OBS_SET_STATS_ANNDATA_ZARR]: DataType$1.OBS_SET_STATS,
  [FileType$1.IMAGE_OME_TIFF]: DataType$1.IMAGE,
  [FileType$1.OBS_SEGMENTATIONS_OME_TIFF]: DataType$1.OBS_SEGMENTATIONS,
  [FileType$1.OBS_FEATURE_MATRIX_MUDATA_ZARR]: DataType$1.OBS_FEATURE_MATRIX,
  [FileType$1.OBS_SETS_MUDATA_ZARR]: DataType$1.OBS_SETS,
  [FileType$1.OBS_EMBEDDING_MUDATA_ZARR]: DataType$1.OBS_EMBEDDING,
  [FileType$1.OBS_SPOTS_MUDATA_ZARR]: DataType$1.OBS_SPOTS,
  [FileType$1.OBS_POINTS_MUDATA_ZARR]: DataType$1.OBS_POINTS,
  [FileType$1.OBS_LOCATIONS_MUDATA_ZARR]: DataType$1.OBS_LOCATIONS,
  [FileType$1.OBS_SEGMENTATIONS_MUDATA_ZARR]: DataType$1.OBS_SEGMENTATIONS,
  [FileType$1.OBS_LABELS_MUDATA_ZARR]: DataType$1.OBS_LABELS,
  [FileType$1.FEATURE_LABELS_MUDATA_ZARR]: DataType$1.FEATURE_LABELS,
  [FileType$1.OBS_SEGMENTATIONS_GLB]: DataType$1.OBS_SEGMENTATIONS,
  [FileType$1.IMAGE_SPATIALDATA_ZARR]: DataType$1.IMAGE,
  [FileType$1.LABELS_SPATIALDATA_ZARR]: DataType$1.OBS_SEGMENTATIONS,
  [FileType$1.SHAPES_SPATIALDATA_ZARR]: DataType$1.OBS_SEGMENTATIONS,
  [FileType$1.OBS_SPOTS_SPATIALDATA_ZARR]: DataType$1.OBS_SPOTS,
  [FileType$1.OBS_FEATURE_MATRIX_SPATIALDATA_ZARR]: DataType$1.OBS_FEATURE_MATRIX,
  [FileType$1.OBS_SETS_SPATIALDATA_ZARR]: DataType$1.OBS_SETS,
  [FileType$1.FEATURE_LABELS_SPATIALDATA_ZARR]: DataType$1.FEATURE_LABELS,
  // For new file types to support old file types
  [FileType$1.OBS_EMBEDDING_CELLS_JSON]: DataType$1.OBS_EMBEDDING,
  [FileType$1.OBS_LOCATIONS_CELLS_JSON]: DataType$1.OBS_LOCATIONS,
  [FileType$1.OBS_SEGMENTATIONS_CELLS_JSON]: DataType$1.OBS_SEGMENTATIONS,
  [FileType$1.OBS_LABELS_CELLS_JSON]: DataType$1.OBS_LABELS,
  [FileType$1.OBS_SETS_CELL_SETS_JSON]: DataType$1.OBS_SETS,
  [FileType$1.OBS_FEATURE_MATRIX_GENES_JSON]: DataType$1.OBS_FEATURE_MATRIX,
  [FileType$1.OBS_FEATURE_MATRIX_CLUSTERS_JSON]: DataType$1.OBS_FEATURE_MATRIX,
  [FileType$1.OBS_FEATURE_MATRIX_EXPRESSION_MATRIX_ZARR]: DataType$1.OBS_FEATURE_MATRIX,
  [FileType$1.IMAGE_RASTER_JSON]: DataType$1.IMAGE,
  [FileType$1.OBS_SEGMENTATIONS_RASTER_JSON]: DataType$1.OBS_SEGMENTATIONS,
  [FileType$1.OBS_LOCATIONS_MOLECULES_JSON]: DataType$1.OBS_LOCATIONS,
  [FileType$1.OBS_LABELS_MOLECULES_JSON]: DataType$1.OBS_LABELS,
  // For old file types
  [FileType$1.GENOMIC_PROFILES_ZARR]: DataType$1.GENOMIC_PROFILES,
  [FileType$1.NEIGHBORHOODS_JSON]: DataType$1.NEIGHBORHOODS
});
({
  [DataType$1.OBS_SEGMENTATIONS]: [
    CoordinationType$1.FILE_UID,
    CoordinationType$1.OBS_TYPE
  ],
  [DataType$1.OBS_EMBEDDING]: [
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.EMBEDDING_TYPE
  ],
  [DataType$1.OBS_SPOTS]: [
    CoordinationType$1.OBS_TYPE
  ],
  [DataType$1.OBS_POINTS]: [
    CoordinationType$1.OBS_TYPE
  ],
  [DataType$1.OBS_LOCATIONS]: [
    CoordinationType$1.OBS_TYPE
  ],
  [DataType$1.OBS_LABELS]: [
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.OBS_LABELS_TYPE
  ],
  [DataType$1.FEATURE_LABELS]: [
    CoordinationType$1.FEATURE_TYPE
  ],
  [DataType$1.OBS_SETS]: [
    CoordinationType$1.OBS_TYPE
  ],
  [DataType$1.OBS_FEATURE_MATRIX]: [
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE
  ],
  [DataType$1.GENOMIC_PROFILES]: [],
  [DataType$1.IMAGE]: [
    CoordinationType$1.FILE_UID
  ],
  [DataType$1.NEIGHBORHOODS]: [],
  [DataType$1.SAMPLE_SETS]: [
    CoordinationType$1.SAMPLE_TYPE
  ],
  [DataType$1.SAMPLE_EDGES]: [
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.SAMPLE_TYPE
  ],
  [DataType$1.COMPARISON_METADATA]: [
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.SAMPLE_TYPE
  ],
  [DataType$1.FEATURE_STATS]: [
    CoordinationType$1.FEATURE_TYPE
    // TODO: should sampleType, obsSetSelection, and/or sampleSetSelection be used here?
  ],
  [DataType$1.FEATURE_SET_STATS]: [
    CoordinationType$1.FEATURE_TYPE
    // TODO: should sampleType, obsSetSelection, and/or sampleSetSelection be used here?
  ],
  [DataType$1.OBS_SET_STATS]: [
    CoordinationType$1.OBS_TYPE
    // TODO: should sampleType, obsSetSelection, and/or sampleSetSelection be used here?
  ]
});
({
  // For AnnData:
  [FileType$1.OBS_FEATURE_MATRIX_ANNDATA_ZARR]: {
    zip: FileType$1.OBS_FEATURE_MATRIX_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.OBS_FEATURE_MATRIX_ANNDATA_H5AD
  },
  [FileType$1.OBS_FEATURE_COLUMNS_ANNDATA_ZARR]: {
    zip: FileType$1.OBS_FEATURE_COLUMNS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.OBS_FEATURE_COLUMNS_ANNDATA_H5AD
  },
  [FileType$1.OBS_SETS_ANNDATA_ZARR]: {
    zip: FileType$1.OBS_SETS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.OBS_SETS_ANNDATA_H5AD
  },
  [FileType$1.OBS_EMBEDDING_ANNDATA_ZARR]: {
    zip: FileType$1.OBS_EMBEDDING_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.OBS_EMBEDDING_ANNDATA_H5AD
  },
  [FileType$1.OBS_SPOTS_ANNDATA_ZARR]: {
    zip: FileType$1.OBS_SPOTS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.OBS_SPOTS_ANNDATA_H5AD
  },
  [FileType$1.OBS_POINTS_ANNDATA_ZARR]: {
    zip: FileType$1.OBS_POINTS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.OBS_POINTS_ANNDATA_H5AD
  },
  [FileType$1.OBS_LOCATIONS_ANNDATA_ZARR]: {
    zip: FileType$1.OBS_LOCATIONS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.OBS_LOCATIONS_ANNDATA_H5AD
  },
  [FileType$1.OBS_SEGMENTATIONS_ANNDATA_ZARR]: {
    zip: FileType$1.OBS_SEGMENTATIONS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.OBS_SEGMENTATIONS_ANNDATA_H5AD
  },
  [FileType$1.OBS_LABELS_ANNDATA_ZARR]: {
    zip: FileType$1.OBS_LABELS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.OBS_LABELS_ANNDATA_H5AD
  },
  [FileType$1.FEATURE_LABELS_ANNDATA_ZARR]: {
    zip: FileType$1.FEATURE_LABELS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.FEATURE_LABELS_ANNDATA_H5AD
  },
  [FileType$1.SAMPLE_EDGES_ANNDATA_ZARR]: {
    zip: FileType$1.SAMPLE_EDGES_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.SAMPLE_EDGES_ANNDATA_H5AD
  },
  [FileType$1.SAMPLE_SETS_ANNDATA_ZARR]: {
    zip: FileType$1.SAMPLE_SETS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.SAMPLE_SETS_ANNDATA_H5AD
  },
  [FileType$1.COMPARISON_METADATA_ANNDATA_ZARR]: {
    zip: FileType$1.COMPARISON_METADATA_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.COMPARISON_METADATA_ANNDATA_H5AD
  },
  [FileType$1.COMPARATIVE_FEATURE_STATS_ANNDATA_ZARR]: {
    zip: FileType$1.COMPARATIVE_FEATURE_STATS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.COMPARATIVE_FEATURE_STATS_ANNDATA_H5AD
  },
  [FileType$1.COMPARATIVE_FEATURE_SET_STATS_ANNDATA_ZARR]: {
    zip: FileType$1.COMPARATIVE_FEATURE_SET_STATS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.COMPARATIVE_FEATURE_SET_STATS_ANNDATA_H5AD
  },
  [FileType$1.COMPARATIVE_OBS_SET_STATS_ANNDATA_ZARR]: {
    zip: FileType$1.COMPARATIVE_OBS_SET_STATS_ANNDATA_ZARR_ZIP,
    h5ad: FileType$1.COMPARATIVE_OBS_SET_STATS_ANNDATA_H5AD
  },
  // For OME-Zarr:
  [FileType$1.IMAGE_OME_ZARR]: {
    zip: FileType$1.IMAGE_OME_ZARR_ZIP
  },
  [FileType$1.OBS_SEGMENTATIONS_OME_ZARR]: {
    zip: FileType$1.OBS_SEGMENTATIONS_OME_ZARR_ZIP
  }
});
[
  CoordinationType$1.HEATMAP_ZOOM_X,
  CoordinationType$1.HEATMAP_ZOOM_Y,
  CoordinationType$1.HEATMAP_TARGET_X,
  CoordinationType$1.HEATMAP_TARGET_Y,
  CoordinationType$1.EMBEDDING_ZOOM,
  CoordinationType$1.EMBEDDING_TARGET_X,
  CoordinationType$1.EMBEDDING_TARGET_Y,
  CoordinationType$1.EMBEDDING_TARGET_Z,
  CoordinationType$1.EMBEDDING_OBS_SET_POLYGONS_VISIBLE,
  CoordinationType$1.EMBEDDING_OBS_SET_LABELS_VISIBLE,
  CoordinationType$1.EMBEDDING_OBS_SET_LABEL_SIZE,
  CoordinationType$1.EMBEDDING_OBS_RADIUS,
  CoordinationType$1.EMBEDDING_OBS_OPACITY,
  CoordinationType$1.SPATIAL_ZOOM,
  CoordinationType$1.SPATIAL_ROTATION,
  CoordinationType$1.SPATIAL_ROTATION_X,
  CoordinationType$1.SPATIAL_ROTATION_Y,
  CoordinationType$1.SPATIAL_ROTATION_Z,
  CoordinationType$1.SPATIAL_ROTATION_ORBIT,
  CoordinationType$1.SPATIAL_TARGET_X,
  CoordinationType$1.SPATIAL_TARGET_Y,
  CoordinationType$1.SPATIAL_TARGET_Z,
  CoordinationType$1.SPATIAL_AXIS_FIXED,
  CoordinationType$1.SPATIAL_ORBIT_AXIS,
  CoordinationType$1.FEATURE_AGGREGATION_STRATEGY
];
({
  [ViewType$1.NEUROGLANCER]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.SPATIAL_TARGET_X,
    CoordinationType$1.SPATIAL_TARGET_Y,
    CoordinationType$1.SPATIAL_TARGET_Z,
    CoordinationType$1.SPATIAL_ROTATION_X,
    CoordinationType$1.SPATIAL_ROTATION_Y,
    CoordinationType$1.SPATIAL_ROTATION_Z,
    CoordinationType$1.SPATIAL_AXIS_FIXED,
    CoordinationType$1.SPATIAL_ORBIT_AXIS,
    CoordinationType$1.SPATIAL_ZOOM,
    CoordinationType$1.OBS_FILTER,
    CoordinationType$1.OBS_HIGHLIGHT,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.EMBEDDING_TYPE,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.TOOLTIPS_VISIBLE
  ],
  [ViewType$1.SCATTERPLOT]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.OBS_LABELS_TYPE,
    CoordinationType$1.EMBEDDING_TYPE,
    CoordinationType$1.EMBEDDING_ZOOM,
    CoordinationType$1.EMBEDDING_ROTATION,
    CoordinationType$1.EMBEDDING_TARGET_X,
    CoordinationType$1.EMBEDDING_TARGET_Y,
    CoordinationType$1.EMBEDDING_TARGET_Z,
    CoordinationType$1.EMBEDDING_OBS_SET_POLYGONS_VISIBLE,
    CoordinationType$1.EMBEDDING_OBS_SET_LABELS_VISIBLE,
    CoordinationType$1.EMBEDDING_OBS_SET_LABEL_SIZE,
    CoordinationType$1.EMBEDDING_OBS_RADIUS,
    CoordinationType$1.EMBEDDING_OBS_RADIUS_MODE,
    CoordinationType$1.EMBEDDING_OBS_OPACITY,
    CoordinationType$1.EMBEDDING_OBS_OPACITY_MODE,
    CoordinationType$1.OBS_FILTER,
    CoordinationType$1.OBS_HIGHLIGHT,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_VALUE_COLORMAP,
    CoordinationType$1.FEATURE_VALUE_COLORMAP_RANGE,
    CoordinationType$1.FEATURE_AGGREGATION_STRATEGY,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.TOOLTIPS_VISIBLE,
    CoordinationType$1.SAMPLE_TYPE,
    CoordinationType$1.SAMPLE_SET_SELECTION,
    CoordinationType$1.SAMPLE_SET_FILTER,
    CoordinationType$1.SAMPLE_SET_COLOR,
    CoordinationType$1.EMBEDDING_POINTS_VISIBLE,
    CoordinationType$1.EMBEDDING_CONTOURS_VISIBLE,
    CoordinationType$1.EMBEDDING_CONTOURS_FILLED,
    CoordinationType$1.EMBEDDING_CONTOUR_PERCENTILES,
    CoordinationType$1.CONTOUR_COLOR_ENCODING,
    CoordinationType$1.CONTOUR_COLOR
  ],
  [ViewType$1.DUAL_SCATTERPLOT]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.OBS_LABELS_TYPE,
    CoordinationType$1.EMBEDDING_TYPE,
    CoordinationType$1.EMBEDDING_ZOOM,
    CoordinationType$1.EMBEDDING_ROTATION,
    CoordinationType$1.EMBEDDING_TARGET_X,
    CoordinationType$1.EMBEDDING_TARGET_Y,
    CoordinationType$1.EMBEDDING_TARGET_Z,
    CoordinationType$1.EMBEDDING_OBS_SET_POLYGONS_VISIBLE,
    CoordinationType$1.EMBEDDING_OBS_SET_LABELS_VISIBLE,
    CoordinationType$1.EMBEDDING_OBS_SET_LABEL_SIZE,
    CoordinationType$1.EMBEDDING_OBS_RADIUS,
    CoordinationType$1.EMBEDDING_OBS_RADIUS_MODE,
    CoordinationType$1.EMBEDDING_OBS_OPACITY,
    CoordinationType$1.EMBEDDING_OBS_OPACITY_MODE,
    CoordinationType$1.OBS_FILTER,
    CoordinationType$1.OBS_HIGHLIGHT,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_VALUE_COLORMAP,
    CoordinationType$1.FEATURE_VALUE_COLORMAP_RANGE,
    CoordinationType$1.FEATURE_AGGREGATION_STRATEGY,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.TOOLTIPS_VISIBLE,
    CoordinationType$1.SAMPLE_TYPE,
    CoordinationType$1.SAMPLE_SET_SELECTION,
    CoordinationType$1.SAMPLE_SET_FILTER,
    CoordinationType$1.SAMPLE_SET_COLOR,
    CoordinationType$1.EMBEDDING_POINTS_VISIBLE,
    CoordinationType$1.EMBEDDING_CONTOURS_VISIBLE,
    CoordinationType$1.EMBEDDING_CONTOURS_FILLED,
    CoordinationType$1.EMBEDDING_CONTOUR_PERCENTILES,
    CoordinationType$1.CONTOUR_COLOR_ENCODING,
    CoordinationType$1.CONTOUR_COLOR
  ],
  [ViewType$1.GATING]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.EMBEDDING_TYPE,
    CoordinationType$1.EMBEDDING_ZOOM,
    CoordinationType$1.EMBEDDING_ROTATION,
    CoordinationType$1.EMBEDDING_TARGET_X,
    CoordinationType$1.EMBEDDING_TARGET_Y,
    CoordinationType$1.EMBEDDING_TARGET_Z,
    CoordinationType$1.EMBEDDING_OBS_SET_POLYGONS_VISIBLE,
    CoordinationType$1.EMBEDDING_OBS_SET_LABELS_VISIBLE,
    CoordinationType$1.EMBEDDING_OBS_SET_LABEL_SIZE,
    CoordinationType$1.EMBEDDING_OBS_RADIUS,
    CoordinationType$1.EMBEDDING_OBS_RADIUS_MODE,
    CoordinationType$1.EMBEDDING_OBS_OPACITY,
    CoordinationType$1.EMBEDDING_OBS_OPACITY_MODE,
    CoordinationType$1.OBS_FILTER,
    CoordinationType$1.OBS_HIGHLIGHT,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_VALUE_COLORMAP,
    CoordinationType$1.FEATURE_VALUE_COLORMAP_RANGE,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.FEATURE_VALUE_TRANSFORM,
    CoordinationType$1.FEATURE_VALUE_TRANSFORM_COEFFICIENT,
    CoordinationType$1.GATING_FEATURE_SELECTION_X,
    CoordinationType$1.GATING_FEATURE_SELECTION_Y
  ],
  [ViewType$1.SPATIAL]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.OBS_LABELS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.SPATIAL_ZOOM,
    CoordinationType$1.SPATIAL_ROTATION,
    CoordinationType$1.SPATIAL_IMAGE_LAYER,
    CoordinationType$1.SPATIAL_SEGMENTATION_LAYER,
    CoordinationType$1.SPATIAL_POINT_LAYER,
    CoordinationType$1.SPATIAL_NEIGHBORHOOD_LAYER,
    CoordinationType$1.SPATIAL_TARGET_X,
    CoordinationType$1.SPATIAL_TARGET_Y,
    CoordinationType$1.SPATIAL_TARGET_Z,
    CoordinationType$1.SPATIAL_ROTATION_X,
    CoordinationType$1.SPATIAL_ROTATION_Y,
    CoordinationType$1.SPATIAL_ROTATION_Z,
    CoordinationType$1.SPATIAL_ROTATION_ORBIT,
    CoordinationType$1.SPATIAL_ORBIT_AXIS,
    CoordinationType$1.SPATIAL_AXIS_FIXED,
    CoordinationType$1.OBS_FILTER,
    CoordinationType$1.OBS_HIGHLIGHT,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_VALUE_COLORMAP,
    CoordinationType$1.FEATURE_VALUE_COLORMAP_RANGE,
    CoordinationType$1.FEATURE_AGGREGATION_STRATEGY,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.MOLECULE_HIGHLIGHT,
    CoordinationType$1.TOOLTIPS_VISIBLE,
    CoordinationType$1.PHOTOMETRIC_INTERPRETATION
  ],
  [ViewType$1.SPATIAL_BETA]: [
    CoordinationType$1.META_COORDINATION_SCOPES,
    CoordinationType$1.META_COORDINATION_SCOPES_BY,
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.OBS_LABELS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.SPATIAL_ZOOM,
    CoordinationType$1.SPATIAL_ROTATION,
    CoordinationType$1.SPATIAL_POINT_LAYER,
    CoordinationType$1.SPATIAL_NEIGHBORHOOD_LAYER,
    CoordinationType$1.SPATIAL_TARGET_X,
    CoordinationType$1.SPATIAL_TARGET_Y,
    CoordinationType$1.SPATIAL_TARGET_Z,
    CoordinationType$1.SPATIAL_TARGET_T,
    CoordinationType$1.SPATIAL_ROTATION_X,
    CoordinationType$1.SPATIAL_ROTATION_Y,
    CoordinationType$1.SPATIAL_ROTATION_Z,
    CoordinationType$1.SPATIAL_ROTATION_ORBIT,
    CoordinationType$1.SPATIAL_ORBIT_AXIS,
    CoordinationType$1.SPATIAL_AXIS_FIXED,
    CoordinationType$1.OBS_FILTER,
    CoordinationType$1.OBS_HIGHLIGHT,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_VALUE_COLORMAP,
    CoordinationType$1.FEATURE_VALUE_COLORMAP_RANGE,
    CoordinationType$1.FEATURE_AGGREGATION_STRATEGY,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.MOLECULE_HIGHLIGHT,
    CoordinationType$1.TOOLTIPS_VISIBLE,
    CoordinationType$1.FILE_UID,
    CoordinationType$1.SPATIAL_TARGET_C,
    CoordinationType$1.SPATIAL_LAYER_VISIBLE,
    CoordinationType$1.SPATIAL_LAYER_OPACITY,
    CoordinationType$1.SPATIAL_LAYER_COLORMAP,
    CoordinationType$1.SPATIAL_LAYER_TRANSPARENT_COLOR,
    CoordinationType$1.SPATIAL_LAYER_MODEL_MATRIX,
    CoordinationType$1.SPATIAL_CHANNEL_COLOR,
    CoordinationType$1.SPATIAL_SEGMENTATION_FILLED,
    CoordinationType$1.SPATIAL_SEGMENTATION_STROKE_WIDTH,
    CoordinationType$1.IMAGE_LAYER,
    CoordinationType$1.SEGMENTATION_LAYER,
    CoordinationType$1.IMAGE_CHANNEL,
    CoordinationType$1.SEGMENTATION_CHANNEL,
    CoordinationType$1.SPATIAL_CHANNEL_VISIBLE,
    CoordinationType$1.SPATIAL_CHANNEL_OPACITY,
    CoordinationType$1.SPATIAL_CHANNEL_WINDOW,
    CoordinationType$1.SPATIAL_RENDERING_MODE,
    CoordinationType$1.VOLUMETRIC_RENDERING_ALGORITHM,
    CoordinationType$1.SPATIAL_TARGET_RESOLUTION,
    CoordinationType$1.SPATIAL_SLICE_X,
    CoordinationType$1.SPATIAL_SLICE_Y,
    CoordinationType$1.SPATIAL_SLICE_Z,
    CoordinationType$1.SPOT_LAYER,
    CoordinationType$1.POINT_LAYER,
    CoordinationType$1.SPATIAL_SPOT_RADIUS,
    CoordinationType$1.SPATIAL_SPOT_FILLED,
    CoordinationType$1.SPATIAL_SPOT_STROKE_WIDTH,
    CoordinationType$1.SPATIAL_LAYER_COLOR,
    CoordinationType$1.PIXEL_HIGHLIGHT,
    CoordinationType$1.TOOLTIP_CROSSHAIRS_VISIBLE,
    CoordinationType$1.LEGEND_VISIBLE,
    CoordinationType$1.SPATIAL_CHANNEL_LABELS_VISIBLE,
    CoordinationType$1.SPATIAL_CHANNEL_LABELS_ORIENTATION,
    CoordinationType$1.SPATIAL_CHANNEL_LABEL_SIZE,
    CoordinationType$1.PHOTOMETRIC_INTERPRETATION
  ],
  [ViewType$1.HEATMAP]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.OBS_LABELS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.HEATMAP_ZOOM_X,
    CoordinationType$1.HEATMAP_ZOOM_Y,
    CoordinationType$1.HEATMAP_TARGET_X,
    CoordinationType$1.HEATMAP_TARGET_Y,
    CoordinationType$1.OBS_FILTER,
    CoordinationType$1.OBS_HIGHLIGHT,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.FEATURE_FILTER,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_VALUE_COLORMAP,
    CoordinationType$1.FEATURE_VALUE_COLORMAP_RANGE,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.TOOLTIPS_VISIBLE
  ],
  [ViewType$1.OBS_SETS]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SET_EXPANSION,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.FEATURE_SELECTION
  ],
  [ViewType$1.OBS_SET_SIZES]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SET_EXPANSION,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.ADDITIONAL_OBS_SETS
  ],
  [ViewType$1.STATUS]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_HIGHLIGHT,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.MOLECULE_HIGHLIGHT
  ],
  [ViewType$1.FEATURE_LIST]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.FEATURE_FILTER,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.OBS_SET_SELECTION
  ],
  [ViewType$1.OBS_SET_FEATURE_VALUE_DISTRIBUTION]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_VALUE_TRANSFORM,
    CoordinationType$1.FEATURE_VALUE_TRANSFORM_COEFFICIENT,
    CoordinationType$1.FEATURE_AGGREGATION_STRATEGY,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.SAMPLE_TYPE,
    CoordinationType$1.SAMPLE_SET_SELECTION,
    CoordinationType$1.SAMPLE_SET_COLOR
  ],
  [ViewType$1.FEATURE_VALUE_HISTOGRAM]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_AGGREGATION_STRATEGY,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER
  ],
  [ViewType$1.LAYER_CONTROLLER]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.SPATIAL_IMAGE_LAYER,
    CoordinationType$1.SPATIAL_SEGMENTATION_LAYER,
    CoordinationType$1.SPATIAL_POINT_LAYER,
    CoordinationType$1.SPATIAL_NEIGHBORHOOD_LAYER,
    CoordinationType$1.SPATIAL_ZOOM,
    CoordinationType$1.SPATIAL_TARGET_X,
    CoordinationType$1.SPATIAL_TARGET_Y,
    CoordinationType$1.SPATIAL_TARGET_Z,
    CoordinationType$1.SPATIAL_ROTATION_X,
    CoordinationType$1.SPATIAL_ROTATION_Y,
    CoordinationType$1.SPATIAL_ROTATION_Z,
    CoordinationType$1.SPATIAL_ROTATION_ORBIT,
    CoordinationType$1.SPATIAL_ORBIT_AXIS,
    CoordinationType$1.PHOTOMETRIC_INTERPRETATION
  ],
  [ViewType$1.LAYER_CONTROLLER_BETA]: [
    CoordinationType$1.META_COORDINATION_SCOPES,
    CoordinationType$1.META_COORDINATION_SCOPES_BY,
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.SPATIAL_POINT_LAYER,
    CoordinationType$1.SPATIAL_NEIGHBORHOOD_LAYER,
    CoordinationType$1.SPATIAL_ZOOM,
    CoordinationType$1.SPATIAL_TARGET_X,
    CoordinationType$1.SPATIAL_TARGET_Y,
    CoordinationType$1.SPATIAL_TARGET_Z,
    CoordinationType$1.SPATIAL_TARGET_T,
    CoordinationType$1.SPATIAL_ROTATION_X,
    CoordinationType$1.SPATIAL_ROTATION_Y,
    CoordinationType$1.SPATIAL_ROTATION_Z,
    CoordinationType$1.SPATIAL_ROTATION_ORBIT,
    CoordinationType$1.SPATIAL_ORBIT_AXIS,
    CoordinationType$1.FILE_UID,
    CoordinationType$1.SPATIAL_TARGET_C,
    CoordinationType$1.SPATIAL_LAYER_VISIBLE,
    CoordinationType$1.SPATIAL_LAYER_OPACITY,
    CoordinationType$1.SPATIAL_LAYER_COLORMAP,
    CoordinationType$1.SPATIAL_LAYER_TRANSPARENT_COLOR,
    CoordinationType$1.SPATIAL_LAYER_MODEL_MATRIX,
    CoordinationType$1.SPATIAL_CHANNEL_COLOR,
    CoordinationType$1.SPATIAL_SEGMENTATION_FILLED,
    CoordinationType$1.SPATIAL_SEGMENTATION_STROKE_WIDTH,
    CoordinationType$1.IMAGE_CHANNEL,
    CoordinationType$1.IMAGE_LAYER,
    CoordinationType$1.SEGMENTATION_CHANNEL,
    CoordinationType$1.SEGMENTATION_LAYER,
    CoordinationType$1.SPATIAL_CHANNEL_VISIBLE,
    CoordinationType$1.SPATIAL_CHANNEL_OPACITY,
    CoordinationType$1.SPATIAL_CHANNEL_WINDOW,
    CoordinationType$1.PHOTOMETRIC_INTERPRETATION,
    CoordinationType$1.SPATIAL_RENDERING_MODE,
    CoordinationType$1.VOLUMETRIC_RENDERING_ALGORITHM,
    CoordinationType$1.SPATIAL_TARGET_RESOLUTION,
    CoordinationType$1.SPATIAL_SLICE_X,
    CoordinationType$1.SPATIAL_SLICE_Y,
    CoordinationType$1.SPATIAL_SLICE_Z,
    CoordinationType$1.SPOT_LAYER,
    CoordinationType$1.POINT_LAYER,
    CoordinationType$1.SPATIAL_SPOT_RADIUS,
    CoordinationType$1.SPATIAL_SPOT_FILLED,
    CoordinationType$1.SPATIAL_SPOT_STROKE_WIDTH,
    CoordinationType$1.SPATIAL_LAYER_COLOR,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.FEATURE_VALUE_COLORMAP,
    CoordinationType$1.FEATURE_VALUE_COLORMAP_RANGE,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_AGGREGATION_STRATEGY,
    CoordinationType$1.TOOLTIPS_VISIBLE,
    CoordinationType$1.TOOLTIP_CROSSHAIRS_VISIBLE,
    CoordinationType$1.LEGEND_VISIBLE,
    CoordinationType$1.SPATIAL_CHANNEL_LABELS_VISIBLE,
    CoordinationType$1.SPATIAL_CHANNEL_LABELS_ORIENTATION,
    CoordinationType$1.SPATIAL_CHANNEL_LABEL_SIZE
  ],
  [ViewType$1.GENOMIC_PROFILES]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.GENOMIC_ZOOM_X,
    CoordinationType$1.GENOMIC_ZOOM_Y,
    CoordinationType$1.GENOMIC_TARGET_X,
    CoordinationType$1.GENOMIC_TARGET_Y,
    CoordinationType$1.FEATURE_FILTER,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.ADDITIONAL_OBS_SETS
  ],
  [ViewType$1.DESCRIPTION]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.SPATIAL_IMAGE_LAYER
  ],
  [ViewType$1.DOT_PLOT]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_FILTER,
    CoordinationType$1.FEATURE_VALUE_TRANSFORM,
    CoordinationType$1.FEATURE_VALUE_TRANSFORM_COEFFICIENT,
    CoordinationType$1.FEATURE_VALUE_POSITIVITY_THRESHOLD,
    CoordinationType$1.FEATURE_VALUE_COLORMAP,
    CoordinationType$1.FEATURE_AGGREGATION_STRATEGY,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.SAMPLE_TYPE,
    CoordinationType$1.SAMPLE_SET_SELECTION,
    CoordinationType$1.SAMPLE_SET_FILTER,
    CoordinationType$1.SAMPLE_SET_COLOR
  ],
  higlass: [
    CoordinationType$1.DATASET,
    CoordinationType$1.GENOMIC_ZOOM_X,
    CoordinationType$1.GENOMIC_ZOOM_Y,
    CoordinationType$1.GENOMIC_TARGET_X,
    CoordinationType$1.GENOMIC_TARGET_Y,
    CoordinationType$1.FEATURE_FILTER,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION
  ],
  [ViewType$1.FEATURE_BAR_PLOT]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_VALUE_TRANSFORM,
    CoordinationType$1.FEATURE_VALUE_TRANSFORM_COEFFICIENT,
    CoordinationType$1.FEATURE_AGGREGATION_STRATEGY,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.ADDITIONAL_OBS_SETS
  ],
  [ViewType$1.VOLCANO_PLOT]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.SAMPLE_TYPE,
    // For selection of case-control sets of samples:
    CoordinationType$1.SAMPLE_SET_SELECTION,
    // For selection of one-vs-others sets of observations:
    CoordinationType$1.OBS_SET_SELECTION,
    // TODO: CoordinationType.FEATURE_SET_SELECTION,
    // TODO: CoordinationType.FEATURE_SET_HIGHLIGHT,
    // TODO: CoordinationType.FEATURE_SET_COLOR,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_VALUE_COLORMAP,
    CoordinationType$1.FEATURE_VALUE_COLORMAP_RANGE,
    // TODO: CoordinationType.FEATURE_COLOR_ENCODING,
    // TODO: CoordinationType.ADDITIONAL_FEATURE_SETS,
    CoordinationType$1.TOOLTIPS_VISIBLE,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.SAMPLE_SET_COLOR,
    CoordinationType$1.FEATURE_POINT_SIGNIFICANCE_THRESHOLD,
    CoordinationType$1.FEATURE_LABEL_SIGNIFICANCE_THRESHOLD,
    CoordinationType$1.FEATURE_POINT_FOLD_CHANGE_THRESHOLD,
    CoordinationType$1.FEATURE_LABEL_FOLD_CHANGE_THRESHOLD
  ],
  [ViewType$1.FEATURE_STATS_TABLE]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.SAMPLE_TYPE,
    // For selection of case-control sets of samples:
    CoordinationType$1.SAMPLE_SET_SELECTION,
    // For selection of one-vs-others sets of observations:
    CoordinationType$1.OBS_SET_SELECTION,
    // TODO: CoordinationType.FEATURE_SET_SELECTION,
    // TODO: CoordinationType.FEATURE_SET_HIGHLIGHT,
    // TODO: CoordinationType.FEATURE_SET_COLOR,
    CoordinationType$1.FEATURE_HIGHLIGHT,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_VALUE_COLORMAP,
    CoordinationType$1.FEATURE_VALUE_COLORMAP_RANGE,
    // TODO: CoordinationType.FEATURE_COLOR_ENCODING,
    // TODO: CoordinationType.ADDITIONAL_FEATURE_SETS,
    CoordinationType$1.TOOLTIPS_VISIBLE,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.SAMPLE_SET_COLOR,
    CoordinationType$1.FEATURE_POINT_SIGNIFICANCE_THRESHOLD,
    CoordinationType$1.FEATURE_LABEL_SIGNIFICANCE_THRESHOLD,
    CoordinationType$1.FEATURE_POINT_FOLD_CHANGE_THRESHOLD,
    CoordinationType$1.FEATURE_LABEL_FOLD_CHANGE_THRESHOLD
  ],
  [ViewType$1.OBS_SET_COMPOSITION_BAR_PLOT]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.SAMPLE_TYPE,
    // For selection of case-control sets of samples:
    CoordinationType$1.SAMPLE_SET_SELECTION,
    // For selection of one-vs-others sets of observations:
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.SAMPLE_SET_COLOR
  ],
  [ViewType$1.FEATURE_SET_ENRICHMENT_BAR_PLOT]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.SAMPLE_TYPE,
    // For selection of case-control sets of samples:
    CoordinationType$1.SAMPLE_SET_SELECTION,
    // For selection of one-vs-others sets of observations:
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.SAMPLE_SET_COLOR,
    CoordinationType$1.FEATURE_SELECTION
  ],
  [ViewType$1.LINK_CONTROLLER]: [],
  [ViewType$1.BIOMARKER_SELECT]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.SAMPLE_TYPE,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.SAMPLE_SET_SELECTION,
    CoordinationType$1.SAMPLE_SET_FILTER,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER
    // TODO: create coordination types for internal state of the biomarker selection view?
  ],
  [ViewType$1.COMPARATIVE_HEADING]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.SAMPLE_TYPE,
    CoordinationType$1.FEATURE_SELECTION,
    CoordinationType$1.FEATURE_AGGREGATION_STRATEGY,
    CoordinationType$1.SAMPLE_SET_SELECTION,
    CoordinationType$1.SAMPLE_SET_FILTER,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER
  ],
  [ViewType$1.SAMPLE_SET_PAIR_MANAGER]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.SAMPLE_TYPE,
    CoordinationType$1.SAMPLE_SET_SELECTION,
    CoordinationType$1.SAMPLE_SET_FILTER
  ],
  [ViewType$1.TREEMAP]: [
    CoordinationType$1.DATASET,
    CoordinationType$1.OBS_TYPE,
    CoordinationType$1.FEATURE_TYPE,
    CoordinationType$1.FEATURE_VALUE_TYPE,
    CoordinationType$1.OBS_FILTER,
    CoordinationType$1.OBS_HIGHLIGHT,
    CoordinationType$1.OBS_SET_SELECTION,
    CoordinationType$1.OBS_SET_FILTER,
    CoordinationType$1.OBS_SELECTION,
    CoordinationType$1.OBS_SELECTION_MODE,
    CoordinationType$1.OBS_SET_HIGHLIGHT,
    CoordinationType$1.OBS_SET_COLOR,
    CoordinationType$1.OBS_COLOR_ENCODING,
    CoordinationType$1.ADDITIONAL_OBS_SETS,
    CoordinationType$1.SAMPLE_TYPE,
    CoordinationType$1.SAMPLE_SET_SELECTION,
    CoordinationType$1.SAMPLE_SET_FILTER,
    CoordinationType$1.SAMPLE_SET_COLOR,
    CoordinationType$1.SAMPLE_SELECTION,
    CoordinationType$1.SAMPLE_SELECTION_MODE,
    CoordinationType$1.SAMPLE_FILTER,
    CoordinationType$1.SAMPLE_FILTER_MODE,
    CoordinationType$1.SAMPLE_HIGHLIGHT,
    CoordinationType$1.HIERARCHY_LEVELS
  ]
});
const ViewType = {
  GENES: [
    "genes",
    "This view type was renamed to featureList in schema version 1.0.15."
  ],
  CELL_SETS: [
    "cellSets",
    "This view type was renamed to obsSets in schema version 1.0.15."
  ],
  CELL_SET_SIZES: [
    "cellSetSizes",
    "This view type was renamed to obsSetSizes in schema version 1.0.15."
  ],
  CELL_SET_EXPRESSION: [
    "cellSetExpression",
    "This view type was renamed to obsSetFeatureValueDistribution in schema version 1.0.15."
  ],
  EXPRESSION_HISTOGRAM: [
    "expressionHistogram",
    "This view type was renamed to featureValueHistogram in schema version 1.0.15."
  ]
};
const DataType = {
  CELLS: [
    "cells",
    "This data type was removed. Associated file types were re-implemented as joint file types. See obsEmbedding instead."
  ],
  CELL_SETS: [
    "cell-sets",
    "This data type was removed. Associated file types were re-implemented as joint file types. See obsSets instead."
  ],
  EXPRESSION_MATRIX: [
    "expression-matrix",
    "This data type was removed. Associated file types were re-implemented as joint file types. See obsFeatureMatrix instead."
  ],
  MOLECULES: [
    "molecules",
    "This data type was removed. Associated file types were re-implemented as joint file types. See obsLocations instead."
  ],
  RASTER: [
    "raster",
    "This data type was removed. Associated file types were re-implemented as joint file types. See image and obsSegmentations instead."
  ]
};
const FileType = {};
function makeChangeMessage(newTypeName, newVersion) {
  return [
    `This coordination type was changed to ${newTypeName} in view config schema version ${newVersion}`,
    newVersion,
    newTypeName
  ];
}
const CoordinationType = {
  SPATIAL_LAYERS: [
    "spatialLayers",
    "This coordination type was split into multiple coordination types in view config schema version 1.0.1",
    "1.0.1",
    "multiple"
    // Not used for spatialLayers (since it was split into multiple).
  ],
  // Spatial layers
  SPATIAL_RASTER_LAYERS: [
    "spatialRasterLayers",
    ...makeChangeMessage("spatialImageLayer", "1.0.11")
  ],
  SPATIAL_CELLS_LAYER: [
    "spatialCellsLayer",
    ...makeChangeMessage("spatialSegmentationLayer", "1.0.11")
  ],
  SPATIAL_MOLECULES_LAYER: [
    "spatialMoleculesLayer",
    ...makeChangeMessage("spatialPointLayer", "1.0.11")
  ],
  SPATIAL_NEIGHBORHOODS_LAYER: [
    "spatialNeighborhoodsLayer",
    ...makeChangeMessage("spatialNeighborhoodLayer", "1.0.11")
  ],
  // Cell -> Obs
  EMBEDDING_CELL_SET_POLYGONS_VISIBLE: [
    "embeddingCellSetPolygonsVisible",
    ...makeChangeMessage("embeddingObsSetPolygonsVisible", "1.0.11")
  ],
  EMBEDDING_CELL_SET_LABELS_VISIBLE: [
    "embeddingCellSetLabelsVisible",
    ...makeChangeMessage("embeddingObsSetLabelsVisible", "1.0.11")
  ],
  EMBEDDING_CELL_SET_LABEL_SIZE: [
    "embeddingCellSetLabelSize",
    ...makeChangeMessage("embeddingObsSetLabelSize", "1.0.11")
  ],
  EMBEDDING_CELL_RADIUS: [
    "embeddingCellRadius",
    ...makeChangeMessage("embeddingObsRadius", "1.0.11")
  ],
  EMBEDDING_CELL_RADIUS_MODE: [
    "embeddingCellRadiusMode",
    ...makeChangeMessage("embeddingObsRadiusMode", "1.0.11")
  ],
  EMBEDDING_CELL_OPACITY: [
    "embeddingCellOpacity",
    ...makeChangeMessage("embeddingObsOpacity", "1.0.11")
  ],
  EMBEDDING_CELL_OPACITY_MODE: [
    "embeddingCellOpacityMode",
    ...makeChangeMessage("embeddingObsOpacityMode", "1.0.11")
  ],
  CELL_FILTER: [
    "cellFilter",
    ...makeChangeMessage("obsFilter", "1.0.11")
  ],
  CELL_HIGHLIGHT: [
    "cellHighlight",
    ...makeChangeMessage("obsHighlight", "1.0.11")
  ],
  CELL_SET_SELECTION: [
    "cellSetSelection",
    ...makeChangeMessage("obsSetSelection", "1.0.11")
  ],
  CELL_SET_HIGHLIGHT: [
    "cellSetHighlight",
    ...makeChangeMessage("obsSetHighlight", "1.0.11")
  ],
  CELL_SET_COLOR: [
    "cellSetColor",
    ...makeChangeMessage("obsSetColor", "1.0.11")
  ],
  CELL_COLOR_ENCODING: [
    "cellColorEncoding",
    ...makeChangeMessage("obsColorEncoding", "1.0.11")
  ],
  ADDITIONAL_CELL_SETS: [
    "additionalCellSets",
    ...makeChangeMessage("additionalObsSets", "1.0.11")
  ],
  // Gene -> Feature
  GENE_FILTER: [
    "geneFilter",
    ...makeChangeMessage("featureFilter", "1.0.11")
  ],
  GENE_HIGHLIGHT: [
    "geneHighlight",
    ...makeChangeMessage("featureHighlight", "1.0.11")
  ],
  GENE_SELECTION: [
    "geneSelection",
    ...makeChangeMessage("featureSelection", "1.0.11")
  ],
  GENE_EXPRESSION_COLORMAP: [
    "geneExpressionColormap",
    ...makeChangeMessage("featureValueColormap", "1.0.11")
  ],
  GENE_EXPRESSION_TRANSFORM: [
    "geneExpressionTransform",
    ...makeChangeMessage("featureValueTransform", "1.0.11")
  ],
  GENE_EXPRESSION_COLORMAP_RANGE: [
    "geneExpressionColormapRange",
    ...makeChangeMessage("featureValueColormapRange", "1.0.11")
  ]
};
function makeConstantWithDeprecationMessage(currObj, oldObj) {
  const handler = {
    get(obj, prop) {
      const oldKeys = Object.keys(oldObj);
      const propKey = String(prop);
      if (oldKeys.includes(propKey)) {
        log.warn(`Notice about the constant mapping ${propKey}: '${oldObj[propKey][0]}':
${oldObj[propKey][1]}`);
        return oldObj[propKey];
      }
      return obj[prop];
    }
  };
  const objWithMessage = new Proxy(currObj, handler);
  return objWithMessage;
}
makeConstantWithDeprecationMessage(ViewType$1, ViewType);
makeConstantWithDeprecationMessage(DataType$1, DataType);
makeConstantWithDeprecationMessage(FileType$1, FileType);
makeConstantWithDeprecationMessage(CoordinationType$1, CoordinationType);
function configSchemaToVersion(zodSchema) {
  return zodSchema.shape.version._def.value;
}
({
  ...Object.fromEntries(SCHEMA_HANDLERS.map(([zodSchema]) => {
    const version2 = configSchemaToVersion(zodSchema);
    return [version2, zodSchema];
  })),
  // eslint-disable-next-line no-underscore-dangle
  [latestConfigSchema.shape.version._def.value]: latestConfigSchema
});
const image$1 = z.object({
  name: z.string(),
  url: z.string(),
  type: z.string(),
  metadata: z.object({
    dimensions: z.array(z.object({
      field: z.string(),
      type: z.enum(["quantitative", "nominal", "ordinal", "temporal"]),
      values: z.array(z.string()).nullable()
    })).optional(),
    isPyramid: z.boolean().optional(),
    transform: z.union([
      z.object({
        scale: z.number(),
        translate: z.object({
          y: z.number(),
          x: z.number()
        })
      }),
      z.object({
        matrix: z.array(z.number()).length(16)
      })
    ]).optional(),
    isBitmask: z.boolean().optional(),
    omeTiffOffsetsUrl: z.string().optional()
  }).optional(),
  requestInit: requestInit.optional()
});
z.object({
  schemaVersion: z.literal("0.0.2"),
  usePhysicalSizeScaling: z.boolean().optional(),
  renderLayers: z.array(z.string()).optional(),
  images: z.array(image$1)
});
const annDataObs = z.object({
  path: z.string()
});
const annDataObsm = z.object({
  path: z.string(),
  dims: z.array(z.number()).optional()
});
const annDataConvenienceObsLabelsItem = z.object({
  path: z.string(),
  obsLabelsType: z.string()
});
const annDataConvenienceFeatureLabelsItem = z.object({
  path: z.string(),
  featureLabelsType: z.string()
});
const annDataConvenienceObsEmbeddingItem = z.object({
  path: z.string(),
  dims: z.array(z.number()).optional(),
  embeddingType: z.string()
});
z.object({
  path: z.string().describe("Path to the comparison metadata, such as /uns/comparison_metadata")
});
z.object({
  // TODO: implement a featureStats.anndata.zarr loader
  // which does not depend on comparisonMetadata
  // (instead, would point directly to the root of
  // the dataframe containing a set of diff exp results)
  // path: z.string().describe('Path to the dataframe containing the results.'),
  metadataPath: z.string().describe("Path to the comparison metadata."),
  indexColumn: z.string().optional().describe("Provide a column to use for the feature index, if different than the default dataframe index."),
  pValueColumn: z.string(),
  foldChangeColumn: z.string(),
  pValueTransformation: z.enum(["minuslog10"]).optional(),
  pValueAdjusted: z.boolean().optional(),
  foldChangeTransformation: z.enum(["log2"]).optional()
});
z.object({
  metadataPath: z.string().describe("Path to the comparison metadata."),
  indexColumn: z.string().optional().describe("Provide a column to use for the feature set index, if different than the default dataframe index."),
  termColumn: z.string().optional(),
  pValueColumn: z.string(),
  pValueAdjusted: z.boolean().optional(),
  featureSetLibrary: z.string().optional().describe("Optionally, provide a feature set library name. By default, Reactome_2022."),
  analysisType: z.string().optional().describe("Optionally, provide an analysis_type name. By default, pertpy_hypergeometric.")
});
z.object({
  metadataPath: z.string().describe("Path to the comparison metadata."),
  indexColumn: z.string().optional().describe("Provide a column to use for the obs set index, if different than the default dataframe index."),
  interceptExpectedSampleColumn: z.string().describe("If we had a new sample (with no active covariates) with a total number of cells equal to the mean sampling depth of the dataset, then this distribution over the cell types would be most likely."),
  effectExpectedSampleColumn: z.string().describe("If we had a new sample (with no active covariates) with a total number of cells equal to the mean sampling depth of the dataset, then this distribution over the cell types would be most likely."),
  foldChangeColumn: z.string().describe("The log-fold change is then calculated between this expected sample and the expected sample with no active covariates from the intercept section."),
  foldChangeTransformation: z.enum(["log2"]).optional(),
  isCredibleEffectColumn: z.string().describe("Column which annotates effects as being credible or not (boolean)."),
  analysisType: z.string().optional().describe("Optionally, provide an analysis_type name. By default, sccoda_df.")
});
const annDataObsLabels = annDataObs;
const annDataFeatureLabels = annDataObs;
const annDataSampleEdges = annDataObs;
const annDataObsFeatureMatrix = z.object({
  path: z.string(),
  featureFilterPath: z.string().optional().describe("If the feature index should be filtered, put a boolean column here (analogous to the previous geneFilter option). e.g., var/in_obsm_X_small_matrix"),
  initialFeatureFilterPath: z.string().optional().describe("If only a subset of the matrix should be loaded initially, put a boolean column along the feature axis here (analogous to the previous matrixGeneFilter option). e.g., var/highly_variable")
});
const annDataObsSetsArr = z.array(z.object({
  name: z.string().describe("The display name for the set, like 'Cell Type' or 'Louvain.'"),
  path: z.union([
    z.string().describe("The location in the AnnData store for the set, like 'obs/louvain' or 'obs/celltype.'"),
    z.array(z.string()).describe("An array of locations in the AnnData store for a hierarchy of set names, from coarse to fine levels.")
  ]),
  scorePath: z.string().optional().describe("The location in the AnnData store for the set confidence scores, like 'obs/celltype_prediction_score.'")
}));
z.object({
  obsSets: annDataObsSetsArr
});
z.object({
  sampleSets: annDataObsSetsArr
});
const annDataObsFeatureColumnsArr = z.array(z.object({
  path: z.string()
}));
z.object({
  obsFeatureColumns: annDataObsFeatureColumnsArr
});
const annDataObsSpots = annDataObsm;
const annDataObsPoints = annDataObsm;
const annDataObsLocations = annDataObsm;
const annDataObsEmbedding = annDataObsm;
const annDataObsSegmentations = annDataObs;
const omeCoordinateTransformations = z.array(z.union([
  z.object({
    type: z.literal("identity")
  }),
  z.object({
    type: z.literal("translation"),
    translation: z.array(z.number())
  }),
  z.object({
    type: z.literal("scale"),
    scale: z.array(z.number())
  })
]));
const imageOmeTiffSchema = z.object({
  offsetsUrl: z.string().optional(),
  coordinateTransformations: omeCoordinateTransformations.optional()
});
imageOmeTiffSchema.extend({
  obsTypesFromChannelNames: z.boolean().optional()
});
const imageOmeZarrSchema = z.object({
  coordinateTransformations: omeCoordinateTransformations.optional()
});
imageOmeZarrSchema.extend({
  obsTypesFromChannelNames: z.boolean().optional()
});
const imageSpatialdataSchema = z.object({
  path: z.string(),
  coordinateSystem: z.string().optional().describe('The name of a coordinate transformation output used to transform the image. If not provided, the "global" coordinate system is assumed.')
});
const obsSegmentationsSpatialdataSchema = z.object({
  // TODO: should this be renamed labelsSpatialdataSchema?
  // TODO: support obsTypesFromChannelNames?
  path: z.string(),
  tablePath: z.string().optional().describe("The path to a table which annotates the labels. If available but not specified, the spot identifiers may not be aligned with associated tabular data as expected."),
  coordinateSystem: z.string().optional().describe('The name of a coordinate transformation output used to transform the image. If not provided, the "global" coordinate system is assumed.')
});
z.object({
  path: z.string(),
  coordinateSystem: z.string().optional().describe('The name of a coordinate transformation output used to transform the coordinates. If not provided, the "global" coordinate system is assumed.')
});
const obsSpotsSpatialdataSchema = z.object({
  path: z.string(),
  tablePath: z.string().optional().describe("The path to a table which annotates the spots. If available but not specified, the spot identifiers may not be aligned with associated tabular data as expected."),
  coordinateSystem: z.string().optional().describe('The name of a coordinate transformation output used to transform the coordinates and radii. If not provided, the "global" coordinate system is assumed.')
});
const obsFeatureMatrixSpatialdataSchema = annDataObsFeatureMatrix.extend({
  region: z.string().describe("The name of a region to use to filter instances (i.e., rows) in the table").optional(),
  coordinateSystem: z.string().optional().describe('The name of a coordinate transformation output used to transform the image. If not provided, the "global" coordinate system is assumed.')
});
const obsSetsSpatialdataSchema = z.object({
  region: z.string().describe("The name of a region to use to filter instances (i.e., rows) in the table").optional(),
  tablePath: z.string().optional().describe("The path to a table which contains the index for the set values."),
  obsSets: annDataObsSetsArr
});
z.object({
  targetX: z.number(),
  targetY: z.number(),
  targetZ: z.number(),
  rotationX: z.number(),
  rotationY: z.number(),
  rotationZ: z.number(),
  scaleX: z.number(),
  scaleY: z.number(),
  scaleZ: z.number(),
  sceneRotationX: z.number(),
  sceneRotationY: z.number(),
  sceneRotationZ: z.number(),
  sceneScaleX: z.number(),
  sceneScaleY: z.number(),
  sceneScaleZ: z.number(),
  materialSide: z.enum(["front", "back"])
}).partial().nullable();
z.object({
  obsIndex: z.string(),
  obsEmbedding: z.array(z.string()).length(2)
  // TODO: support 3D?
});
z.object({
  obsIndex: z.string(),
  obsSpots: z.array(z.string()).length(2)
  // TODO: support 3D?
});
z.object({
  obsIndex: z.string(),
  obsPoints: z.array(z.string()).length(3)
});
z.object({
  obsIndex: z.string(),
  obsLocations: z.array(z.string()).length(2)
  // TODO: support 3D?
});
z.object({
  obsIndex: z.string(),
  obsLabels: z.string()
});
z.object({
  featureIndex: z.string(),
  featureLabels: z.string()
});
z.object({
  obsIndex: z.string(),
  obsSets: z.array(z.object({
    name: z.string(),
    column: z.union([
      z.string(),
      z.array(z.string())
    ]),
    scoreColumn: z.string().optional()
  }))
});
z.object({
  sampleIndex: z.string(),
  sampleSets: z.array(z.object({
    name: z.string(),
    column: z.union([
      z.string(),
      z.array(z.string())
    ]),
    scoreColumn: z.string().optional()
  }))
});
const anndataZarrSchema = z.object({
  obsLabels: z.union([
    annDataObsLabels,
    z.array(annDataConvenienceObsLabelsItem)
  ]),
  featureLabels: z.union([
    annDataFeatureLabels,
    z.array(annDataConvenienceFeatureLabelsItem)
  ]),
  obsFeatureMatrix: annDataObsFeatureMatrix,
  obsSets: annDataObsSetsArr,
  obsSpots: annDataObsSpots,
  obsPoints: annDataObsPoints,
  obsLocations: annDataObsLocations,
  obsSegmentations: annDataObsSegmentations,
  obsEmbedding: z.union([
    annDataObsEmbedding,
    z.array(annDataConvenienceObsEmbeddingItem)
  ]),
  sampleEdges: annDataSampleEdges
}).partial();
anndataZarrSchema.extend({
  refSpecUrl: z.string()
});
z.object({
  // TODO: should `image` be a special schema
  // to allow specifying fileUid (like for embeddingType)?
  // TODO: allow multiple images
  image: imageSpatialdataSchema,
  // TODO: should this be a special schema
  // to allow specifying fileUid (like for embeddingType)?
  // TODO: allow multiple labels
  labels: obsSegmentationsSpatialdataSchema,
  obsFeatureMatrix: obsFeatureMatrixSpatialdataSchema,
  obsSpots: obsSpotsSpatialdataSchema,
  // TODO: obsPoints
  // TODO: obsLocations
  obsSets: obsSetsSpatialdataSchema,
  // TODO: obsEmbedding
  // TODO: obsLabels
  // TODO: featureLabels
  coordinateSystem: z.string().optional().describe("The name of a coordinate transformation output used to transform all elements which lack a per-element coordinateSystem property.")
}).partial();
z.object({
  obsLabelsTypes: z.array(z.string()).optional(),
  embeddingTypes: z.array(z.string()).optional()
}).optional();
z.object({
  xy: z.string().optional(),
  poly: z.string().optional(),
  factors: z.array(z.string()).optional(),
  mappings: z.record(z.object({
    key: z.string(),
    dims: z.array(z.number()).length(2)
  })).optional()
});
z.array(z.object({
  groupName: z.string(),
  setName: z.union([
    z.string(),
    z.array(z.string())
  ]),
  scoreName: z.string().optional()
}));
z.object({
  matrix: z.string(),
  geneFilter: z.string().optional(),
  matrixGeneFilter: z.string().optional(),
  geneAlias: z.string().optional()
});
z.array(z.object({
  channels: z.array(z.object({
    color: z.array(z.number()).describe("The color to use when rendering this channel under the null colormap.").optional(),
    selection: z.record(z.any()).describe("Determines the channel selection, e.g. some Z and time slice."),
    slider: z.array(z.number()).describe("Determines the range for color mapping.").optional(),
    visible: z.boolean().describe("Determines whether this channel of the layer will be rendered in the spatial component.").optional()
  }).strict()),
  colormap: z.string().nullable(),
  transparentColor: z.array(z.number().describe("One of R G or B (0 - 255).")).length(3).describe("Determines the color to be set to opacity 0").nullable().optional(),
  index: z.number().describe("The index of the layer among the array of layers available in the image file."),
  opacity: z.number(),
  modelMatrix: z.array(z.number()).length(16).describe("transformation matrix for this layer").optional(),
  domainType: z.enum(["Full", "Min/Max"]).describe("Determines the extent of the channel slider input element in the layer controller.").optional(),
  resolution: z.number().describe("Resolution of 3D volumetric rendering").optional(),
  xSlice: z.array(z.any()).length(2).describe("Slice bounds").nullable().optional(),
  renderingMode: z.string().describe("Rendering mode of 3D volumetric rendering").optional(),
  ySlice: z.array(z.any()).length(2).describe("Slice bounds").nullable().optional(),
  zSlice: z.array(z.any()).length(2).describe("Slice bounds").nullable().optional(),
  type: z.enum(["raster", "bitmask"]).optional(),
  use3d: z.boolean().optional(),
  visible: z.boolean().describe("Determines whether this entire layer will be rendered in the spatial component.").optional()
}).strict().describe("The properties of this object are the rendering settings for the raster layer."));
z.object({
  visible: z.boolean(),
  stroked: z.boolean(),
  radius: z.number(),
  opacity: z.number()
});
z.object({
  visible: z.boolean()
});
z.object({
  visible: z.boolean(),
  radius: z.number(),
  opacity: z.number()
});
var tinycolor = { exports: {} };
var hasRequiredTinycolor;
function requireTinycolor() {
  if (hasRequiredTinycolor) return tinycolor.exports;
  hasRequiredTinycolor = 1;
  (function(module2) {
    (function(Math2) {
      var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
      function tinycolor2(color2, opts2) {
        color2 = color2 ? color2 : "";
        opts2 = opts2 || {};
        if (color2 instanceof tinycolor2) {
          return color2;
        }
        if (!(this instanceof tinycolor2)) {
          return new tinycolor2(color2, opts2);
        }
        var rgb2 = inputToRGB(color2);
        this._originalInput = color2, this._r = rgb2.r, this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts2.format || rgb2.format;
        this._gradientType = opts2.gradientType;
        if (this._r < 1) {
          this._r = mathRound(this._r);
        }
        if (this._g < 1) {
          this._g = mathRound(this._g);
        }
        if (this._b < 1) {
          this._b = mathRound(this._b);
        }
        this._ok = rgb2.ok;
        this._tc_id = tinyCounter++;
      }
      tinycolor2.prototype = {
        isDark: function() {
          return this.getBrightness() < 128;
        },
        isLight: function() {
          return !this.isDark();
        },
        isValid: function() {
          return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
          return this._format;
        },
        getAlpha: function() {
          return this._a;
        },
        getBrightness: function() {
          var rgb2 = this.toRgb();
          return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
        },
        getLuminance: function() {
          var rgb2 = this.toRgb();
          var RsRGB, GsRGB, BsRGB, R, G, B2;
          RsRGB = rgb2.r / 255;
          GsRGB = rgb2.g / 255;
          BsRGB = rgb2.b / 255;
          if (RsRGB <= 0.03928) {
            R = RsRGB / 12.92;
          } else {
            R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G = GsRGB / 12.92;
          } else {
            G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B2 = BsRGB / 12.92;
          } else {
            B2 = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R + 0.7152 * G + 0.0722 * B2;
        },
        setAlpha: function(value2) {
          this._a = boundAlpha(value2);
          this._roundA = mathRound(100 * this._a) / 100;
          return this;
        },
        toHsv: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          var h2 = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
          return this._a == 1 ? "hsv(" + h2 + ", " + s + "%, " + v + "%)" : "hsva(" + h2 + ", " + s + "%, " + v + "%, " + this._roundA + ")";
        },
        toHsl: function() {
          var hsl2 = rgbToHsl(this._r, this._g, this._b);
          return { h: hsl2.h * 360, s: hsl2.s, l: hsl2.l, a: this._a };
        },
        toHslString: function() {
          var hsl2 = rgbToHsl(this._r, this._g, this._b);
          var h2 = mathRound(hsl2.h * 360), s = mathRound(hsl2.s * 100), l = mathRound(hsl2.l * 100);
          return this._a == 1 ? "hsl(" + h2 + ", " + s + "%, " + l + "%)" : "hsla(" + h2 + ", " + s + "%, " + l + "%, " + this._roundA + ")";
        },
        toHex: function(allow3Char) {
          return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
          return "#" + this.toHex(allow3Char);
        },
        toHex8: function(allow4Char) {
          return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function(allow4Char) {
          return "#" + this.toHex8(allow4Char);
        },
        toRgb: function() {
          return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
          return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
          if (this._a === 0) {
            return "transparent";
          }
          if (this._a < 1) {
            return false;
          }
          return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
          var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
          var secondHex8String = hex8String;
          var gradientType = this._gradientType ? "GradientType = 1, " : "";
          if (secondColor) {
            var s = tinycolor2(secondColor);
            secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
          }
          return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
        },
        toString: function(format2) {
          var formatSet = !!format2;
          format2 = format2 || this._format;
          var formattedString = false;
          var hasAlpha = this._a < 1 && this._a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this._a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        },
        clone: function() {
          return tinycolor2(this.toString());
        },
        _applyModification: function(fn, args) {
          var color2 = fn.apply(null, [this].concat([].slice.call(args)));
          this._r = color2._r;
          this._g = color2._g;
          this._b = color2._b;
          this.setAlpha(color2._a);
          return this;
        },
        lighten: function() {
          return this._applyModification(lighten2, arguments);
        },
        brighten: function() {
          return this._applyModification(brighten, arguments);
        },
        darken: function() {
          return this._applyModification(darken2, arguments);
        },
        desaturate: function() {
          return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
          return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
          return this._applyModification(greyscale, arguments);
        },
        spin: function() {
          return this._applyModification(spin, arguments);
        },
        _applyCombination: function(fn, args) {
          return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
          return this._applyCombination(analogous, arguments);
        },
        complement: function() {
          return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
          return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
          return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
          return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
          return this._applyCombination(tetrad, arguments);
        }
      };
      tinycolor2.fromRatio = function(color2, opts2) {
        if (typeof color2 == "object") {
          var newColor = {};
          for (var i in color2) {
            if (color2.hasOwnProperty(i)) {
              if (i === "a") {
                newColor[i] = color2[i];
              } else {
                newColor[i] = convertToPercentage(color2[i]);
              }
            }
          }
          color2 = newColor;
        }
        return tinycolor2(color2, opts2);
      };
      function inputToRGB(color2) {
        var rgb2 = { r: 0, g: 0, b: 0 };
        var a2 = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format2 = false;
        if (typeof color2 == "string") {
          color2 = stringInputToObject(color2);
        }
        if (typeof color2 == "object") {
          if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
            rgb2 = rgbToRgb(color2.r, color2.g, color2.b);
            ok = true;
            format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
            s = convertToPercentage(color2.s);
            v = convertToPercentage(color2.v);
            rgb2 = hsvToRgb(color2.h, s, v);
            ok = true;
            format2 = "hsv";
          } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
            s = convertToPercentage(color2.s);
            l = convertToPercentage(color2.l);
            rgb2 = hslToRgb2(color2.h, s, l);
            ok = true;
            format2 = "hsl";
          }
          if (color2.hasOwnProperty("a")) {
            a2 = color2.a;
          }
        }
        a2 = boundAlpha(a2);
        return {
          ok,
          format: color2.format || format2,
          r: mathMin(255, mathMax(rgb2.r, 0)),
          g: mathMin(255, mathMax(rgb2.g, 0)),
          b: mathMin(255, mathMax(rgb2.b, 0)),
          a: a2
        };
      }
      function rgbToRgb(r2, g, b2) {
        return {
          r: bound01(r2, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b2, 255) * 255
        };
      }
      function rgbToHsl(r2, g, b2) {
        r2 = bound01(r2, 255);
        g = bound01(g, 255);
        b2 = bound01(b2, 255);
        var max2 = mathMax(r2, g, b2), min2 = mathMin(r2, g, b2);
        var h2, s, l = (max2 + min2) / 2;
        if (max2 == min2) {
          h2 = s = 0;
        } else {
          var d = max2 - min2;
          s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
          switch (max2) {
            case r2:
              h2 = (g - b2) / d + (g < b2 ? 6 : 0);
              break;
            case g:
              h2 = (b2 - r2) / d + 2;
              break;
            case b2:
              h2 = (r2 - g) / d + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s, l };
      }
      function hslToRgb2(h2, s, l) {
        var r2, g, b2;
        h2 = bound01(h2, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);
        function hue2rgb(p2, q2, t4) {
          if (t4 < 0) t4 += 1;
          if (t4 > 1) t4 -= 1;
          if (t4 < 1 / 6) return p2 + (q2 - p2) * 6 * t4;
          if (t4 < 1 / 2) return q2;
          if (t4 < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t4) * 6;
          return p2;
        }
        if (s === 0) {
          r2 = g = b2 = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r2 = hue2rgb(p, q, h2 + 1 / 3);
          g = hue2rgb(p, q, h2);
          b2 = hue2rgb(p, q, h2 - 1 / 3);
        }
        return { r: r2 * 255, g: g * 255, b: b2 * 255 };
      }
      function rgbToHsv(r2, g, b2) {
        r2 = bound01(r2, 255);
        g = bound01(g, 255);
        b2 = bound01(b2, 255);
        var max2 = mathMax(r2, g, b2), min2 = mathMin(r2, g, b2);
        var h2, s, v = max2;
        var d = max2 - min2;
        s = max2 === 0 ? 0 : d / max2;
        if (max2 == min2) {
          h2 = 0;
        } else {
          switch (max2) {
            case r2:
              h2 = (g - b2) / d + (g < b2 ? 6 : 0);
              break;
            case g:
              h2 = (b2 - r2) / d + 2;
              break;
            case b2:
              h2 = (r2 - g) / d + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s, v };
      }
      function hsvToRgb(h2, s, v) {
        h2 = bound01(h2, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);
        var i = Math2.floor(h2), f = h2 - i, p = v * (1 - s), q = v * (1 - f * s), t4 = v * (1 - (1 - f) * s), mod = i % 6, r2 = [v, q, p, p, t4, v][mod], g = [t4, v, v, q, p, p][mod], b2 = [p, p, t4, v, v, q][mod];
        return { r: r2 * 255, g: g * 255, b: b2 * 255 };
      }
      function rgbToHex(r2, g, b2, allow3Char) {
        var hex2 = [
          pad2(mathRound(r2).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b2).toString(16))
        ];
        if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
          return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
        }
        return hex2.join("");
      }
      function rgbaToHex(r2, g, b2, a2, allow4Char) {
        var hex2 = [
          pad2(mathRound(r2).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b2).toString(16)),
          pad2(convertDecimalToHex(a2))
        ];
        if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
          return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
        }
        return hex2.join("");
      }
      function rgbaToArgbHex(r2, g, b2, a2) {
        var hex2 = [
          pad2(convertDecimalToHex(a2)),
          pad2(mathRound(r2).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b2).toString(16))
        ];
        return hex2.join("");
      }
      tinycolor2.equals = function(color1, color2) {
        if (!color1 || !color2) {
          return false;
        }
        return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
      };
      tinycolor2.random = function() {
        return tinycolor2.fromRatio({
          r: mathRandom(),
          g: mathRandom(),
          b: mathRandom()
        });
      };
      function desaturate(color2, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl2 = tinycolor2(color2).toHsl();
        hsl2.s -= amount / 100;
        hsl2.s = clamp01(hsl2.s);
        return tinycolor2(hsl2);
      }
      function saturate(color2, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl2 = tinycolor2(color2).toHsl();
        hsl2.s += amount / 100;
        hsl2.s = clamp01(hsl2.s);
        return tinycolor2(hsl2);
      }
      function greyscale(color2) {
        return tinycolor2(color2).desaturate(100);
      }
      function lighten2(color2, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl2 = tinycolor2(color2).toHsl();
        hsl2.l += amount / 100;
        hsl2.l = clamp01(hsl2.l);
        return tinycolor2(hsl2);
      }
      function brighten(color2, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var rgb2 = tinycolor2(color2).toRgb();
        rgb2.r = mathMax(0, mathMin(255, rgb2.r - mathRound(255 * -(amount / 100))));
        rgb2.g = mathMax(0, mathMin(255, rgb2.g - mathRound(255 * -(amount / 100))));
        rgb2.b = mathMax(0, mathMin(255, rgb2.b - mathRound(255 * -(amount / 100))));
        return tinycolor2(rgb2);
      }
      function darken2(color2, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl2 = tinycolor2(color2).toHsl();
        hsl2.l -= amount / 100;
        hsl2.l = clamp01(hsl2.l);
        return tinycolor2(hsl2);
      }
      function spin(color2, amount) {
        var hsl2 = tinycolor2(color2).toHsl();
        var hue2 = (hsl2.h + amount) % 360;
        hsl2.h = hue2 < 0 ? 360 + hue2 : hue2;
        return tinycolor2(hsl2);
      }
      function complement(color2) {
        var hsl2 = tinycolor2(color2).toHsl();
        hsl2.h = (hsl2.h + 180) % 360;
        return tinycolor2(hsl2);
      }
      function triad(color2) {
        var hsl2 = tinycolor2(color2).toHsl();
        var h2 = hsl2.h;
        return [
          tinycolor2(color2),
          tinycolor2({ h: (h2 + 120) % 360, s: hsl2.s, l: hsl2.l }),
          tinycolor2({ h: (h2 + 240) % 360, s: hsl2.s, l: hsl2.l })
        ];
      }
      function tetrad(color2) {
        var hsl2 = tinycolor2(color2).toHsl();
        var h2 = hsl2.h;
        return [
          tinycolor2(color2),
          tinycolor2({ h: (h2 + 90) % 360, s: hsl2.s, l: hsl2.l }),
          tinycolor2({ h: (h2 + 180) % 360, s: hsl2.s, l: hsl2.l }),
          tinycolor2({ h: (h2 + 270) % 360, s: hsl2.s, l: hsl2.l })
        ];
      }
      function splitcomplement(color2) {
        var hsl2 = tinycolor2(color2).toHsl();
        var h2 = hsl2.h;
        return [
          tinycolor2(color2),
          tinycolor2({ h: (h2 + 72) % 360, s: hsl2.s, l: hsl2.l }),
          tinycolor2({ h: (h2 + 216) % 360, s: hsl2.s, l: hsl2.l })
        ];
      }
      function analogous(color2, results, slices) {
        results = results || 6;
        slices = slices || 30;
        var hsl2 = tinycolor2(color2).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor2(color2)];
        for (hsl2.h = (hsl2.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl2.h = (hsl2.h + part) % 360;
          ret.push(tinycolor2(hsl2));
        }
        return ret;
      }
      function monochromatic(color2, results) {
        results = results || 6;
        var hsv = tinycolor2(color2).toHsv();
        var h2 = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;
        while (results--) {
          ret.push(tinycolor2({ h: h2, s, v }));
          v = (v + modification) % 1;
        }
        return ret;
      }
      tinycolor2.mix = function(color1, color2, amount) {
        amount = amount === 0 ? 0 : amount || 50;
        var rgb1 = tinycolor2(color1).toRgb();
        var rgb2 = tinycolor2(color2).toRgb();
        var p = amount / 100;
        var rgba2 = {
          r: (rgb2.r - rgb1.r) * p + rgb1.r,
          g: (rgb2.g - rgb1.g) * p + rgb1.g,
          b: (rgb2.b - rgb1.b) * p + rgb1.b,
          a: (rgb2.a - rgb1.a) * p + rgb1.a
        };
        return tinycolor2(rgba2);
      };
      tinycolor2.readability = function(color1, color2) {
        var c1 = tinycolor2(color1);
        var c2 = tinycolor2(color2);
        return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
      };
      tinycolor2.isReadable = function(color1, color2, wcag2) {
        var readability = tinycolor2.readability(color1, color2);
        var wcag2Parms, out;
        out = false;
        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
          case "AAsmall":
          case "AAAlarge":
            out = readability >= 4.5;
            break;
          case "AAlarge":
            out = readability >= 3;
            break;
          case "AAAsmall":
            out = readability >= 7;
            break;
        }
        return out;
      };
      tinycolor2.mostReadable = function(baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors;
        level = args.level;
        size = args.size;
        for (var i = 0; i < colorList.length; i++) {
          readability = tinycolor2.readability(baseColor, colorList[i]);
          if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor2(colorList[i]);
          }
        }
        if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
          return bestColor;
        } else {
          args.includeFallbackColors = false;
          return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
        }
      };
      var names = tinycolor2.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
      };
      var hexNames = tinycolor2.hexNames = flip2(names);
      function flip2(o) {
        var flipped = {};
        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
          }
        }
        return flipped;
      }
      function boundAlpha(a2) {
        a2 = parseFloat(a2);
        if (isNaN(a2) || a2 < 0 || a2 > 1) {
          a2 = 1;
        }
        return a2;
      }
      function bound01(n, max2) {
        if (isOnePointZero(n)) {
          n = "100%";
        }
        var processPercent = isPercentage(n);
        n = mathMin(max2, mathMax(0, parseFloat(n)));
        if (processPercent) {
          n = parseInt(n * max2, 10) / 100;
        }
        if (Math2.abs(n - max2) < 1e-6) {
          return 1;
        }
        return n % max2 / parseFloat(max2);
      }
      function clamp01(val) {
        return mathMin(1, mathMax(0, val));
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") != -1;
      }
      function pad2(c2) {
        return c2.length == 1 ? "0" + c2 : "" + c2;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          n = n * 100 + "%";
        }
        return n;
      }
      function convertDecimalToHex(d) {
        return Math2.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      var matchers = function() {
        var CSS_INTEGER = "[-\\+]?\\d+%?";
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        return {
          CSS_UNIT: new RegExp(CSS_UNIT),
          rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
          rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
          hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
          hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
          hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
          hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
          hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
      }();
      function isValidCSSUnit(color2) {
        return !!matchers.CSS_UNIT.exec(color2);
      }
      function stringInputToObject(color2) {
        color2 = color2.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
        var named2 = false;
        if (names[color2]) {
          color2 = names[color2];
          named2 = true;
        } else if (color2 == "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match2;
        if (match2 = matchers.rgb.exec(color2)) {
          return { r: match2[1], g: match2[2], b: match2[3] };
        }
        if (match2 = matchers.rgba.exec(color2)) {
          return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
        }
        if (match2 = matchers.hsl.exec(color2)) {
          return { h: match2[1], s: match2[2], l: match2[3] };
        }
        if (match2 = matchers.hsla.exec(color2)) {
          return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
        }
        if (match2 = matchers.hsv.exec(color2)) {
          return { h: match2[1], s: match2[2], v: match2[3] };
        }
        if (match2 = matchers.hsva.exec(color2)) {
          return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
        }
        if (match2 = matchers.hex8.exec(color2)) {
          return {
            r: parseIntFromHex(match2[1]),
            g: parseIntFromHex(match2[2]),
            b: parseIntFromHex(match2[3]),
            a: convertHexToDecimal(match2[4]),
            format: named2 ? "name" : "hex8"
          };
        }
        if (match2 = matchers.hex6.exec(color2)) {
          return {
            r: parseIntFromHex(match2[1]),
            g: parseIntFromHex(match2[2]),
            b: parseIntFromHex(match2[3]),
            format: named2 ? "name" : "hex"
          };
        }
        if (match2 = matchers.hex4.exec(color2)) {
          return {
            r: parseIntFromHex(match2[1] + "" + match2[1]),
            g: parseIntFromHex(match2[2] + "" + match2[2]),
            b: parseIntFromHex(match2[3] + "" + match2[3]),
            a: convertHexToDecimal(match2[4] + "" + match2[4]),
            format: named2 ? "name" : "hex8"
          };
        }
        if (match2 = matchers.hex3.exec(color2)) {
          return {
            r: parseIntFromHex(match2[1] + "" + match2[1]),
            g: parseIntFromHex(match2[2] + "" + match2[2]),
            b: parseIntFromHex(match2[3] + "" + match2[3]),
            format: named2 ? "name" : "hex"
          };
        }
        return false;
      }
      function validateWCAG2Parms(parms) {
        var level, size;
        parms = parms || { "level": "AA", "size": "small" };
        level = (parms.level || "AA").toUpperCase();
        size = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
          level = "AA";
        }
        if (size !== "small" && size !== "large") {
          size = "small";
        }
        return { "level": level, "size": size };
      }
      if (module2.exports) {
        module2.exports = tinycolor2;
      } else {
        window.tinycolor = tinycolor2;
      }
    })(Math);
  })(tinycolor);
  return tinycolor.exports;
}
requireTinycolor();
var json2csv_umd$1 = { exports: {} };
var json2csv_umd = json2csv_umd$1.exports;
var hasRequiredJson2csv_umd;
function requireJson2csv_umd() {
  if (hasRequiredJson2csv_umd) return json2csv_umd$1.exports;
  hasRequiredJson2csv_umd = 1;
  (function(module2, exports2) {
    (function(global2, factory) {
      factory(exports2);
    })(json2csv_umd, function(exports3) {
      var domain2;
      function EventHandlers() {
      }
      EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.usingDomains = false;
      EventEmitter.prototype.domain = void 0;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.init = function() {
        this.domain = null;
        if (EventEmitter.usingDomains) {
          if (domain2.active && !(this instanceof domain2.Domain)) ;
        }
        if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || isNaN(n))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n;
        return this;
      };
      function $getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      function emitNone(handler, isFn, self2) {
        if (isFn)
          handler.call(self2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2);
        }
      }
      function emitOne(handler, isFn, self2, arg1) {
        if (isFn)
          handler.call(self2, arg1);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1);
        }
      }
      function emitTwo(handler, isFn, self2, arg1, arg2) {
        if (isFn)
          handler.call(self2, arg1, arg2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1, arg2);
        }
      }
      function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
        if (isFn)
          handler.call(self2, arg1, arg2, arg3);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1, arg2, arg3);
        }
      }
      function emitMany(handler, isFn, self2, args) {
        if (isFn)
          handler.apply(self2, args);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].apply(self2, args);
        }
      }
      EventEmitter.prototype.emit = function emit2(type2) {
        var er, handler, len, args, i, events2, domain3;
        var doError = type2 === "error";
        events2 = this._events;
        if (events2)
          doError = doError && events2.error == null;
        else if (!doError)
          return false;
        domain3 = this.domain;
        if (doError) {
          er = arguments[1];
          if (domain3) {
            if (!er)
              er = new Error('Uncaught, unspecified "error" event');
            er.domainEmitter = this;
            er.domain = domain3;
            er.domainThrown = false;
            domain3.emit("error", er);
          } else if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
          return false;
        }
        handler = events2[type2];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          // fast cases
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          // slower
          default:
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            emitMany(handler, isFn, this, args);
        }
        return true;
      };
      function _addListener(target2, type2, listener2, prepend) {
        var m2;
        var events2;
        var existing;
        if (typeof listener2 !== "function")
          throw new TypeError('"listener" argument must be a function');
        events2 = target2._events;
        if (!events2) {
          events2 = target2._events = new EventHandlers();
          target2._eventsCount = 0;
        } else {
          if (events2.newListener) {
            target2.emit(
              "newListener",
              type2,
              listener2.listener ? listener2.listener : listener2
            );
            events2 = target2._events;
          }
          existing = events2[type2];
        }
        if (!existing) {
          existing = events2[type2] = listener2;
          ++target2._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events2[type2] = prepend ? [listener2, existing] : [existing, listener2];
          } else {
            if (prepend) {
              existing.unshift(listener2);
            } else {
              existing.push(listener2);
            }
          }
          if (!existing.warned) {
            m2 = $getMaxListeners(target2);
            if (m2 && m2 > 0 && existing.length > m2) {
              existing.warned = true;
              var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
              w2.name = "MaxListenersExceededWarning";
              w2.emitter = target2;
              w2.type = type2;
              w2.count = existing.length;
              emitWarning(w2);
            }
          }
        }
        return target2;
      }
      function emitWarning(e3) {
        typeof console.warn === "function" ? console.warn(e3) : console.log(e3);
      }
      EventEmitter.prototype.addListener = function addListener(type2, listener2) {
        return _addListener(this, type2, listener2, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener2(type2, listener2) {
        return _addListener(this, type2, listener2, true);
      };
      function _onceWrap(target2, type2, listener2) {
        var fired = false;
        function g() {
          target2.removeListener(type2, g);
          if (!fired) {
            fired = true;
            listener2.apply(target2, arguments);
          }
        }
        g.listener = listener2;
        return g;
      }
      EventEmitter.prototype.once = function once(type2, listener2) {
        if (typeof listener2 !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type2, _onceWrap(this, type2, listener2));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener2) {
        if (typeof listener2 !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type2, _onceWrap(this, type2, listener2));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type2, listener2) {
        var list, events2, position2, i, originalListener;
        if (typeof listener2 !== "function")
          throw new TypeError('"listener" argument must be a function');
        events2 = this._events;
        if (!events2)
          return this;
        list = events2[type2];
        if (!list)
          return this;
        if (list === listener2 || list.listener && list.listener === listener2) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events2[type2];
            if (events2.removeListener)
              this.emit("removeListener", type2, list.listener || listener2);
          }
        } else if (typeof list !== "function") {
          position2 = -1;
          for (i = list.length; i-- > 0; ) {
            if (list[i] === listener2 || list[i].listener && list[i].listener === listener2) {
              originalListener = list[i].listener;
              position2 = i;
              break;
            }
          }
          if (position2 < 0)
            return this;
          if (list.length === 1) {
            list[0] = void 0;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events2[type2];
            }
          } else {
            spliceOne(list, position2);
          }
          if (events2.removeListener)
            this.emit("removeListener", type2, originalListener || listener2);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
        var listeners, events2;
        events2 = this._events;
        if (!events2)
          return this;
        if (!events2.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events2[type2]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events2[type2];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys3 = Object.keys(events2);
          for (var i = 0, key2; i < keys3.length; ++i) {
            key2 = keys3[i];
            if (key2 === "removeListener") continue;
            this.removeAllListeners(key2);
          }
          this.removeAllListeners("removeListener");
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }
        listeners = events2[type2];
        if (typeof listeners === "function") {
          this.removeListener(type2, listeners);
        } else if (listeners) {
          do {
            this.removeListener(type2, listeners[listeners.length - 1]);
          } while (listeners[0]);
        }
        return this;
      };
      EventEmitter.prototype.listeners = function listeners(type2) {
        var evlistener;
        var ret;
        var events2 = this._events;
        if (!events2)
          ret = [];
        else {
          evlistener = events2[type2];
          if (!evlistener)
            ret = [];
          else if (typeof evlistener === "function")
            ret = [evlistener.listener || evlistener];
          else
            ret = unwrapListeners(evlistener);
        }
        return ret;
      };
      EventEmitter.listenerCount = function(emitter, type2) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type2);
        } else {
          return listenerCount.call(emitter, type2);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type2) {
        var events2 = this._events;
        if (events2) {
          var evlistener = events2[type2];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
      function spliceOne(list, index2) {
        for (var i = index2, k = i + 1, n = list.length; k < n; i += 1, k += 1)
          list[i] = list[k];
        list.pop();
      }
      function arrayClone(arr, i) {
        var copy2 = new Array(i);
        while (i--)
          copy2[i] = arr[i];
        return copy2;
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      var global$1 = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      var lookup2 = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var inited = false;
      function init2() {
        inited = true;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup2[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
      }
      function toByteArray(b64) {
        if (!inited) {
          init2();
        }
        var i, j, l, tmp, placeHolders, arr;
        var len = b64.length;
        if (len % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
        arr = new Arr(len * 3 / 4 - placeHolders);
        l = placeHolders > 0 ? len - 4 : len;
        var L = 0;
        for (i = 0, j = 0; i < l; i += 4, j += 3) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[L++] = tmp >> 16 & 255;
          arr[L++] = tmp >> 8 & 255;
          arr[L++] = tmp & 255;
        }
        if (placeHolders === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[L++] = tmp & 255;
        } else if (placeHolders === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[L++] = tmp >> 8 & 255;
          arr[L++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output2 = [];
        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
          output2.push(tripletToBase64(tmp));
        }
        return output2.join("");
      }
      function fromByteArray(uint8) {
        if (!inited) {
          init2();
        }
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3;
        var output2 = "";
        var parts = [];
        var maxChunkLength = 16383;
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          output2 += lookup2[tmp >> 2];
          output2 += lookup2[tmp << 4 & 63];
          output2 += "==";
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          output2 += lookup2[tmp >> 10];
          output2 += lookup2[tmp >> 4 & 63];
          output2 += lookup2[tmp << 2 & 63];
          output2 += "=";
        }
        parts.push(output2);
        return parts.join("");
      }
      function read2(buffer, offset2, isLE, mLen, nBytes) {
        var e3, m2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset2 + i];
        i += d;
        e3 = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e3 = e3 * 256 + buffer[offset2 + i], i += d, nBits -= 8) {
        }
        m2 = e3 & (1 << -nBits) - 1;
        e3 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m2 = m2 * 256 + buffer[offset2 + i], i += d, nBits -= 8) {
        }
        if (e3 === 0) {
          e3 = 1 - eBias;
        } else if (e3 === eMax) {
          return m2 ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m2 = m2 + Math.pow(2, mLen);
          e3 = e3 - eBias;
        }
        return (s ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
      }
      function write(buffer, value2, offset2, isLE, mLen, nBytes) {
        var e3, m2, c2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
        value2 = Math.abs(value2);
        if (isNaN(value2) || value2 === Infinity) {
          m2 = isNaN(value2) ? 1 : 0;
          e3 = eMax;
        } else {
          e3 = Math.floor(Math.log(value2) / Math.LN2);
          if (value2 * (c2 = Math.pow(2, -e3)) < 1) {
            e3--;
            c2 *= 2;
          }
          if (e3 + eBias >= 1) {
            value2 += rt / c2;
          } else {
            value2 += rt * Math.pow(2, 1 - eBias);
          }
          if (value2 * c2 >= 2) {
            e3++;
            c2 /= 2;
          }
          if (e3 + eBias >= eMax) {
            m2 = 0;
            e3 = eMax;
          } else if (e3 + eBias >= 1) {
            m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
            e3 = e3 + eBias;
          } else {
            m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e3 = 0;
          }
        }
        for (; mLen >= 8; buffer[offset2 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
        }
        e3 = e3 << mLen | m2;
        eLen += mLen;
        for (; eLen > 0; buffer[offset2 + i] = e3 & 255, i += d, e3 /= 256, eLen -= 8) {
        }
        buffer[offset2 + i - d] |= s * 128;
      }
      var toString2 = {}.toString;
      var isArray2 = Array.isArray || function(arr) {
        return toString2.call(arr) == "[object Array]";
      };
      var INSPECT_MAX_BYTES = 50;
      Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
      function kMaxLength() {
        return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function createBuffer(that, length2) {
        if (kMaxLength() < length2) {
          throw new RangeError("Invalid typed array length");
        }
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          that = new Uint8Array(length2);
          that.__proto__ = Buffer2.prototype;
        } else {
          if (that === null) {
            that = new Buffer2(length2);
          }
          that.length = length2;
        }
        return that;
      }
      function Buffer2(arg, encodingOrOffset, length2) {
        if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
          return new Buffer2(arg, encodingOrOffset, length2);
        }
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new Error(
              "If encoding is specified then the first argument must be a string"
            );
          }
          return allocUnsafe(this, arg);
        }
        return from2(this, arg, encodingOrOffset, length2);
      }
      Buffer2.poolSize = 8192;
      Buffer2._augment = function(arr) {
        arr.__proto__ = Buffer2.prototype;
        return arr;
      };
      function from2(that, value2, encodingOrOffset, length2) {
        if (typeof value2 === "number") {
          throw new TypeError('"value" argument must not be a number');
        }
        if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
          return fromArrayBuffer(that, value2, encodingOrOffset, length2);
        }
        if (typeof value2 === "string") {
          return fromString(that, value2, encodingOrOffset);
        }
        return fromObject(that, value2);
      }
      Buffer2.from = function(value2, encodingOrOffset, length2) {
        return from2(null, value2, encodingOrOffset, length2);
      };
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        Buffer2.prototype.__proto__ = Uint8Array.prototype;
        Buffer2.__proto__ = Uint8Array;
      }
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be a number');
        } else if (size < 0) {
          throw new RangeError('"size" argument must not be negative');
        }
      }
      function alloc2(that, size, fill2, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(that, size);
        }
        if (fill2 !== void 0) {
          return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
        }
        return createBuffer(that, size);
      }
      Buffer2.alloc = function(size, fill2, encoding) {
        return alloc2(null, size, fill2, encoding);
      };
      function allocUnsafe(that, size) {
        assertSize(size);
        that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT) {
          for (var i = 0; i < size; ++i) {
            that[i] = 0;
          }
        }
        return that;
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      function fromString(that, string2, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError('"encoding" must be a valid string encoding');
        }
        var length2 = byteLength(string2, encoding) | 0;
        that = createBuffer(that, length2);
        var actual = that.write(string2, encoding);
        if (actual !== length2) {
          that = that.slice(0, actual);
        }
        return that;
      }
      function fromArrayLike(that, array2) {
        var length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
        that = createBuffer(that, length2);
        for (var i = 0; i < length2; i += 1) {
          that[i] = array2[i] & 255;
        }
        return that;
      }
      function fromArrayBuffer(that, array2, byteOffset, length2) {
        array2.byteLength;
        if (byteOffset < 0 || array2.byteLength < byteOffset) {
          throw new RangeError("'offset' is out of bounds");
        }
        if (array2.byteLength < byteOffset + (length2 || 0)) {
          throw new RangeError("'length' is out of bounds");
        }
        if (byteOffset === void 0 && length2 === void 0) {
          array2 = new Uint8Array(array2);
        } else if (length2 === void 0) {
          array2 = new Uint8Array(array2, byteOffset);
        } else {
          array2 = new Uint8Array(array2, byteOffset, length2);
        }
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          that = array2;
          that.__proto__ = Buffer2.prototype;
        } else {
          that = fromArrayLike(that, array2);
        }
        return that;
      }
      function fromObject(that, obj) {
        if (internalIsBuffer(obj)) {
          var len = checked(obj.length) | 0;
          that = createBuffer(that, len);
          if (that.length === 0) {
            return that;
          }
          obj.copy(that, 0, 0, len);
          return that;
        }
        if (obj) {
          if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
            if (typeof obj.length !== "number" || isnan(obj.length)) {
              return createBuffer(that, 0);
            }
            return fromArrayLike(that, obj);
          }
          if (obj.type === "Buffer" && isArray2(obj.data)) {
            return fromArrayLike(that, obj.data);
          }
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }
      function checked(length2) {
        if (length2 >= kMaxLength()) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
        }
        return length2 | 0;
      }
      Buffer2.isBuffer = isBuffer2;
      function internalIsBuffer(b2) {
        return !!(b2 != null && b2._isBuffer);
      }
      Buffer2.compare = function compare2(a2, b2) {
        if (!internalIsBuffer(a2) || !internalIsBuffer(b2)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a2 === b2) return 0;
        var x2 = a2.length;
        var y2 = b2.length;
        for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
          if (a2[i] !== b2[i]) {
            x2 = a2[i];
            y2 = b2[i];
            break;
          }
        }
        if (x2 < y2) return -1;
        if (y2 < x2) return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length2) {
        if (!isArray2(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i;
        if (length2 === void 0) {
          length2 = 0;
          for (i = 0; i < list.length; ++i) {
            length2 += list[i].length;
          }
        }
        var buffer = Buffer2.allocUnsafe(length2);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string2, encoding) {
        if (internalIsBuffer(string2)) {
          return string2.length;
        }
        if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string2) || string2 instanceof ArrayBuffer)) {
          return string2.byteLength;
        }
        if (typeof string2 !== "string") {
          string2 = "" + string2;
        }
        var len = string2.length;
        if (len === 0) return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
            case void 0:
              return utf8ToBytes(string2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string2).length;
            default:
              if (loweredCase) return utf8ToBytes(string2).length;
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap2(b2, n, m2) {
        var i = b2[n];
        b2[n] = b2[m2];
        b2[m2] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap2(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap2(this, i, i + 3);
          swap2(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap2(this, i, i + 7);
          swap2(this, i + 1, i + 6);
          swap2(this, i + 2, i + 5);
          swap2(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString3() {
        var length2 = this.length | 0;
        if (length2 === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length2);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.equals = function equals(b2) {
        if (!internalIsBuffer(b2)) throw new TypeError("Argument must be a Buffer");
        if (this === b2) return true;
        return Buffer2.compare(this, b2) === 0;
      };
      Buffer2.prototype.inspect = function inspect2() {
        var str = "";
        var max2 = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
          if (this.length > max2) str += " ... ";
        }
        return "<Buffer " + str + ">";
      };
      Buffer2.prototype.compare = function compare2(target2, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target2)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target2 ? target2.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target2.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target2) return 0;
        var x2 = thisEnd - thisStart;
        var y2 = end - start;
        var len = Math.min(x2, y2);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target2.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x2 = thisCopy[i];
            y2 = targetCopy[i];
            break;
          }
        }
        if (x2 < y2) return -1;
        if (y2 < x2) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (isNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir) return -1;
          else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (internalIsBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read3(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        var i;
        if (dir) {
          var foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read3(arr, i) === read3(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
              if (read3(arr, i + j) !== read3(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string2, offset2, length2) {
        offset2 = Number(offset2) || 0;
        var remaining = buf.length - offset2;
        if (!length2) {
          length2 = remaining;
        } else {
          length2 = Number(length2);
          if (length2 > remaining) {
            length2 = remaining;
          }
        }
        var strLen = string2.length;
        if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
        if (length2 > strLen / 2) {
          length2 = strLen / 2;
        }
        for (var i = 0; i < length2; ++i) {
          var parsed = parseInt(string2.substr(i * 2, 2), 16);
          if (isNaN(parsed)) return i;
          buf[offset2 + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string2, offset2, length2) {
        return blitBuffer(utf8ToBytes(string2, buf.length - offset2), buf, offset2, length2);
      }
      function asciiWrite(buf, string2, offset2, length2) {
        return blitBuffer(asciiToBytes(string2), buf, offset2, length2);
      }
      function latin1Write(buf, string2, offset2, length2) {
        return asciiWrite(buf, string2, offset2, length2);
      }
      function base64Write(buf, string2, offset2, length2) {
        return blitBuffer(base64ToBytes(string2), buf, offset2, length2);
      }
      function ucs2Write(buf, string2, offset2, length2) {
        return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length2);
      }
      Buffer2.prototype.write = function write2(string2, offset2, length2, encoding) {
        if (offset2 === void 0) {
          encoding = "utf8";
          length2 = this.length;
          offset2 = 0;
        } else if (length2 === void 0 && typeof offset2 === "string") {
          encoding = offset2;
          length2 = this.length;
          offset2 = 0;
        } else if (isFinite(offset2)) {
          offset2 = offset2 | 0;
          if (isFinite(length2)) {
            length2 = length2 | 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length2;
            length2 = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset2;
        if (length2 === void 0 || length2 > remaining) length2 = remaining;
        if (string2.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string2, offset2, length2);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string2, offset2, length2);
            case "ascii":
              return asciiWrite(this, string2, offset2, length2);
            case "latin1":
            case "binary":
              return latin1Write(this, string2, offset2, length2);
            case "base64":
              return base64Write(this, string2, offset2, length2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string2, offset2, length2);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return fromByteArray(buf);
        } else {
          return fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        var out = "";
        for (var i = start; i < end; ++i) {
          out += toHex(buf[i]);
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i = 0; i < bytes.length; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice2(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        var newBuf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer2.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer2(sliceLen, void 0);
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start];
          }
        }
        return newBuf;
      };
      function checkOffset(offset2, ext, length2) {
        if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
        if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
        offset2 = offset2 | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        var val = this[offset2];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset2 + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
        offset2 = offset2 | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          checkOffset(offset2, byteLength2, this.length);
        }
        var val = this[offset2 + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset2 + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 1, this.length);
        return this[offset2];
      };
      Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 2, this.length);
        return this[offset2] | this[offset2 + 1] << 8;
      };
      Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 2, this.length);
        return this[offset2] << 8 | this[offset2 + 1];
      };
      Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
      };
      Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
        offset2 = offset2 | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        var val = this[offset2];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset2 + i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
        offset2 = offset2 | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset2 + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset2 + --i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 1, this.length);
        if (!(this[offset2] & 128)) return this[offset2];
        return (255 - this[offset2] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 2, this.length);
        var val = this[offset2] | this[offset2 + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 2, this.length);
        var val = this[offset2 + 1] | this[offset2] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return read2(this, offset2, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return read2(this, offset2, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 8, this.length);
        return read2(this, offset2, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
        if (!noAssert) checkOffset(offset2, 8, this.length);
        return read2(this, offset2, false, 52, 8);
      };
      function checkInt(buf, value2, offset2, ext, max2, min2) {
        if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
        if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset2, byteLength2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value2, offset2, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset2] = value2 & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset2 + i] = value2 / mul & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset2, byteLength2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value2, offset2, byteLength2, maxBytes, 0);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        this[offset2 + i] = value2 & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset2 + i] = value2 / mul & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) checkInt(this, value2, offset2, 1, 255, 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
        this[offset2] = value2 & 255;
        return offset2 + 1;
      };
      function objectWriteUInt16(buf, value2, offset2, littleEndian) {
        if (value2 < 0) value2 = 65535 + value2 + 1;
        for (var i = 0, j = Math.min(buf.length - offset2, 2); i < j; ++i) {
          buf[offset2 + i] = (value2 & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
        }
      }
      Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset2] = value2 & 255;
          this[offset2 + 1] = value2 >>> 8;
        } else {
          objectWriteUInt16(this, value2, offset2, true);
        }
        return offset2 + 2;
      };
      Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset2] = value2 >>> 8;
          this[offset2 + 1] = value2 & 255;
        } else {
          objectWriteUInt16(this, value2, offset2, false);
        }
        return offset2 + 2;
      };
      function objectWriteUInt32(buf, value2, offset2, littleEndian) {
        if (value2 < 0) value2 = 4294967295 + value2 + 1;
        for (var i = 0, j = Math.min(buf.length - offset2, 4); i < j; ++i) {
          buf[offset2 + i] = value2 >>> (littleEndian ? i : 3 - i) * 8 & 255;
        }
      }
      Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset2 + 3] = value2 >>> 24;
          this[offset2 + 2] = value2 >>> 16;
          this[offset2 + 1] = value2 >>> 8;
          this[offset2] = value2 & 255;
        } else {
          objectWriteUInt32(this, value2, offset2, true);
        }
        return offset2 + 4;
      };
      Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset2] = value2 >>> 24;
          this[offset2 + 1] = value2 >>> 16;
          this[offset2 + 2] = value2 >>> 8;
          this[offset2 + 3] = value2 & 255;
        } else {
          objectWriteUInt32(this, value2, offset2, false);
        }
        return offset2 + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset2, byteLength2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value2, offset2, byteLength2, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset2] = value2 & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value2 < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i] = (value2 / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset2, byteLength2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value2, offset2, byteLength2, limit - 1, -limit);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset2 + i] = value2 & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value2 < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i] = (value2 / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value2, offset2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) checkInt(this, value2, offset2, 1, 127, -128);
        if (!Buffer2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
        if (value2 < 0) value2 = 255 + value2 + 1;
        this[offset2] = value2 & 255;
        return offset2 + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset2] = value2 & 255;
          this[offset2 + 1] = value2 >>> 8;
        } else {
          objectWriteUInt16(this, value2, offset2, true);
        }
        return offset2 + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset2] = value2 >>> 8;
          this[offset2 + 1] = value2 & 255;
        } else {
          objectWriteUInt16(this, value2, offset2, false);
        }
        return offset2 + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset2] = value2 & 255;
          this[offset2 + 1] = value2 >>> 8;
          this[offset2 + 2] = value2 >>> 16;
          this[offset2 + 3] = value2 >>> 24;
        } else {
          objectWriteUInt32(this, value2, offset2, true);
        }
        return offset2 + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset2, noAssert) {
        value2 = +value2;
        offset2 = offset2 | 0;
        if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
        if (value2 < 0) value2 = 4294967295 + value2 + 1;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset2] = value2 >>> 24;
          this[offset2 + 1] = value2 >>> 16;
          this[offset2 + 2] = value2 >>> 8;
          this[offset2 + 3] = value2 & 255;
        } else {
          objectWriteUInt32(this, value2, offset2, false);
        }
        return offset2 + 4;
      };
      function checkIEEE754(buf, value2, offset2, ext, max2, min2) {
        if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
        if (offset2 < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value2, offset2, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value2, offset2, 4);
        }
        write(buf, value2, offset2, littleEndian, 23, 4);
        return offset2 + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset2, noAssert) {
        return writeFloat(this, value2, offset2, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset2, noAssert) {
        return writeFloat(this, value2, offset2, false, noAssert);
      };
      function writeDouble(buf, value2, offset2, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value2, offset2, 8);
        }
        write(buf, value2, offset2, littleEndian, 52, 8);
        return offset2 + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset2, noAssert) {
        return writeDouble(this, value2, offset2, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset2, noAssert) {
        return writeDouble(this, value2, offset2, false, noAssert);
      };
      Buffer2.prototype.copy = function copy2(target2, targetStart, start, end) {
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target2.length) targetStart = target2.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target2.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target2.length - targetStart < end - start) {
          end = target2.length - targetStart + start;
        }
        var len = end - start;
        var i;
        if (this === target2 && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; --i) {
            target2[i + targetStart] = this[i + start];
          }
        } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; ++i) {
            target2[i + targetStart] = this[i + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target2,
            this.subarray(start, start + len),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill2(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
          var len = bytes.length;
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = stringtrim(str).replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function stringtrim(str) {
        if (str.trim) return str.trim();
        return str.replace(/^\s+|\s+$/g, "");
      }
      function toHex(n) {
        if (n < 16) return "0" + n.toString(16);
        return n.toString(16);
      }
      function utf8ToBytes(string2, units) {
        units = units || Infinity;
        var codePoint;
        var length2 = string2.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i = 0; i < length2; ++i) {
          codePoint = string2.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length2) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c2, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c2 = str.charCodeAt(i);
          hi = c2 >> 8;
          lo = c2 % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset2, length2) {
        for (var i = 0; i < length2; ++i) {
          if (i + offset2 >= dst.length || i >= src.length) break;
          dst[i + offset2] = src[i];
        }
        return i;
      }
      function isnan(val) {
        return val !== val;
      }
      function isBuffer2(obj) {
        return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
      }
      function isFastBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
      }
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      var cachedSetTimeout = defaultSetTimout;
      var cachedClearTimeout = defaultClearTimeout;
      if (typeof global$1.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof global$1.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e3) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e4) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e3) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e4) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout2 = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout2);
      }
      function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item2(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      }
      function Item2(fun, array2) {
        this.fun = fun;
        this.array = array2;
      }
      Item2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      var performance2 = global$1.performance || {};
      performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      var inherits2;
      if (typeof Object.create === "function") {
        inherits2 = function inherits3(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        inherits2 = function inherits3(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
      var inherits$1 = inherits2;
      var formatRegExp = /%[sdj%]/g;
      function format2(f) {
        if (!isString2(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x3) {
          if (x3 === "%%") return "%";
          if (i >= len) return x3;
          switch (x3) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x3;
          }
        });
        for (var x2 = args[i]; i < len; x2 = args[++i]) {
          if (isNull(x2) || !isObject2(x2)) {
            str += " " + x2;
          } else {
            str += " " + inspect(x2);
          }
        }
        return str;
      }
      function deprecate(fn, msg) {
        if (isUndefined(global$1.process)) {
          return function() {
            return deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      var debugs = {};
      var debugEnviron;
      function debuglog(set2) {
        if (isUndefined(debugEnviron))
          debugEnviron = "";
        set2 = set2.toUpperCase();
        if (!debugs[set2]) {
          if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
            var pid = 0;
            debugs[set2] = function() {
              var msg = format2.apply(null, arguments);
              console.error("%s %d: %s", set2, pid, msg);
            };
          } else {
            debugs[set2] = function() {
            };
          }
        }
        return debugs[set2];
      }
      function inspect(obj, opts2) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3) ctx.depth = arguments[2];
        if (arguments.length >= 4) ctx.colors = arguments[3];
        if (isBoolean2(opts2)) {
          ctx.showHidden = opts2;
        } else if (opts2) {
          _extend(ctx, opts2);
        }
        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
        if (isUndefined(ctx.depth)) ctx.depth = 2;
        if (isUndefined(ctx.colors)) ctx.colors = false;
        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
        if (ctx.colors) ctx.stylize = stylizeWithColor;
        return formatValue2(ctx, obj, ctx.depth);
      }
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style2 = inspect.styles[styleType];
        if (style2) {
          return "\x1B[" + inspect.colors[style2][0] + "m" + str + "\x1B[" + inspect.colors[style2][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array2) {
        var hash2 = {};
        array2.forEach(function(val, idx) {
          hash2[val] = true;
        });
        return hash2;
      }
      function formatValue2(ctx, value2, recurseTimes) {
        if (ctx.customInspect && value2 && isFunction2(value2.inspect) && // Filter out the util module, it's inspect function is special
        value2.inspect !== inspect && // Also filter out any prototype objects using the circular check.
        !(value2.constructor && value2.constructor.prototype === value2)) {
          var ret = value2.inspect(recurseTimes, ctx);
          if (!isString2(ret)) {
            ret = formatValue2(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value2);
        if (primitive) {
          return primitive;
        }
        var keys3 = Object.keys(value2);
        var visibleKeys = arrayToHash(keys3);
        if (ctx.showHidden) {
          keys3 = Object.getOwnPropertyNames(value2);
        }
        if (isError(value2) && (keys3.indexOf("message") >= 0 || keys3.indexOf("description") >= 0)) {
          return formatError(value2);
        }
        if (keys3.length === 0) {
          if (isFunction2(value2)) {
            var name = value2.name ? ": " + value2.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp2(value2)) {
            return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
          }
          if (isDate2(value2)) {
            return ctx.stylize(Date.prototype.toString.call(value2), "date");
          }
          if (isError(value2)) {
            return formatError(value2);
          }
        }
        var base2 = "", array2 = false, braces = ["{", "}"];
        if (isArray$12(value2)) {
          array2 = true;
          braces = ["[", "]"];
        }
        if (isFunction2(value2)) {
          var n = value2.name ? ": " + value2.name : "";
          base2 = " [Function" + n + "]";
        }
        if (isRegExp2(value2)) {
          base2 = " " + RegExp.prototype.toString.call(value2);
        }
        if (isDate2(value2)) {
          base2 = " " + Date.prototype.toUTCString.call(value2);
        }
        if (isError(value2)) {
          base2 = " " + formatError(value2);
        }
        if (keys3.length === 0 && (!array2 || value2.length == 0)) {
          return braces[0] + base2 + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp2(value2)) {
            return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value2);
        var output2;
        if (array2) {
          output2 = formatArray2(ctx, value2, recurseTimes, visibleKeys, keys3);
        } else {
          output2 = keys3.map(function(key2) {
            return formatProperty(ctx, value2, recurseTimes, visibleKeys, key2, array2);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output2, base2, braces);
      }
      function formatPrimitive(ctx, value2) {
        if (isUndefined(value2))
          return ctx.stylize("undefined", "undefined");
        if (isString2(value2)) {
          var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber2(value2))
          return ctx.stylize("" + value2, "number");
        if (isBoolean2(value2))
          return ctx.stylize("" + value2, "boolean");
        if (isNull(value2))
          return ctx.stylize("null", "null");
      }
      function formatError(value2) {
        return "[" + Error.prototype.toString.call(value2) + "]";
      }
      function formatArray2(ctx, value2, recurseTimes, visibleKeys, keys3) {
        var output2 = [];
        for (var i = 0, l = value2.length; i < l; ++i) {
          if (hasOwnProperty2(value2, String(i))) {
            output2.push(formatProperty(
              ctx,
              value2,
              recurseTimes,
              visibleKeys,
              String(i),
              true
            ));
          } else {
            output2.push("");
          }
        }
        keys3.forEach(function(key2) {
          if (!key2.match(/^\d+$/)) {
            output2.push(formatProperty(
              ctx,
              value2,
              recurseTimes,
              visibleKeys,
              key2,
              true
            ));
          }
        });
        return output2;
      }
      function formatProperty(ctx, value2, recurseTimes, visibleKeys, key2, array2) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value2, key2) || { value: value2[key2] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty2(visibleKeys, key2)) {
          name = "[" + key2 + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue2(ctx, desc.value, null);
            } else {
              str = formatValue2(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array2) {
                str = str.split("\n").map(function(line2) {
                  return "  " + line2;
                }).join("\n").substr(2);
              } else {
                str = "\n" + str.split("\n").map(function(line2) {
                  return "   " + line2;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array2 && key2.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key2);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output2, base2, braces) {
        var length2 = output2.reduce(function(prev2, cur) {
          if (cur.indexOf("\n") >= 0) ;
          return prev2 + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length2 > 60) {
          return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output2.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base2 + " " + output2.join(", ") + " " + braces[1];
      }
      function isArray$12(ar) {
        return Array.isArray(ar);
      }
      function isBoolean2(arg) {
        return typeof arg === "boolean";
      }
      function isNull(arg) {
        return arg === null;
      }
      function isNumber2(arg) {
        return typeof arg === "number";
      }
      function isString2(arg) {
        return typeof arg === "string";
      }
      function isUndefined(arg) {
        return arg === void 0;
      }
      function isRegExp2(re2) {
        return isObject2(re2) && objectToString2(re2) === "[object RegExp]";
      }
      function isObject2(arg) {
        return typeof arg === "object" && arg !== null;
      }
      function isDate2(d) {
        return isObject2(d) && objectToString2(d) === "[object Date]";
      }
      function isError(e3) {
        return isObject2(e3) && (objectToString2(e3) === "[object Error]" || e3 instanceof Error);
      }
      function isFunction2(arg) {
        return typeof arg === "function";
      }
      function objectToString2(o) {
        return Object.prototype.toString.call(o);
      }
      function _extend(origin, add2) {
        if (!add2 || !isObject2(add2)) return origin;
        var keys3 = Object.keys(add2);
        var i = keys3.length;
        while (i--) {
          origin[keys3[i]] = add2[keys3[i]];
        }
        return origin;
      }
      function hasOwnProperty2(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function BufferList() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function(v2) {
        var entry2 = { data: v2, next: null };
        if (this.length > 0) this.tail.next = entry2;
        else this.head = entry2;
        this.tail = entry2;
        ++this.length;
      };
      BufferList.prototype.unshift = function(v2) {
        var entry2 = { data: v2, next: this.head };
        if (this.length === 0) this.tail = entry2;
        this.head = entry2;
        ++this.length;
      };
      BufferList.prototype.shift = function() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        if (this.length === 1) return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          p.data.copy(ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) {
          throw new Error("Unknown encoding: " + encoding);
        }
      }
      function StringDecoder(encoding) {
        this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
        assertEncoding(encoding);
        switch (this.encoding) {
          case "utf8":
            this.surrogateSize = 3;
            break;
          case "ucs2":
          case "utf16le":
            this.surrogateSize = 2;
            this.detectIncompleteChar = utf16DetectIncompleteChar;
            break;
          case "base64":
            this.surrogateSize = 3;
            this.detectIncompleteChar = base64DetectIncompleteChar;
            break;
          default:
            this.write = passThroughWrite;
            return;
        }
        this.charBuffer = new Buffer2(6);
        this.charReceived = 0;
        this.charLength = 0;
      }
      StringDecoder.prototype.write = function(buffer) {
        var charStr = "";
        while (this.charLength) {
          var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
          buffer.copy(this.charBuffer, this.charReceived, 0, available);
          this.charReceived += available;
          if (this.charReceived < this.charLength) {
            return "";
          }
          buffer = buffer.slice(available, buffer.length);
          charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var charCode = charStr.charCodeAt(charStr.length - 1);
          if (charCode >= 55296 && charCode <= 56319) {
            this.charLength += this.surrogateSize;
            charStr = "";
            continue;
          }
          this.charReceived = this.charLength = 0;
          if (buffer.length === 0) {
            return charStr;
          }
          break;
        }
        this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
          buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
          end -= this.charReceived;
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
          var size = this.surrogateSize;
          this.charLength += size;
          this.charReceived += size;
          this.charBuffer.copy(this.charBuffer, size, 0, size);
          buffer.copy(this.charBuffer, 0, 0, size);
          return charStr.substring(0, end);
        }
        return charStr;
      };
      StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        var i = buffer.length >= 3 ? 3 : buffer.length;
        for (; i > 0; i--) {
          var c2 = buffer[buffer.length - i];
          if (i == 1 && c2 >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (i <= 2 && c2 >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (i <= 3 && c2 >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = i;
      };
      StringDecoder.prototype.end = function(buffer) {
        var res = "";
        if (buffer && buffer.length)
          res = this.write(buffer);
        if (this.charReceived) {
          var cr2 = this.charReceived;
          var buf = this.charBuffer;
          var enc = this.encoding;
          res += buf.slice(0, cr2).toString(enc);
        }
        return res;
      };
      function passThroughWrite(buffer) {
        return buffer.toString(this.encoding);
      }
      function utf16DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 2;
        this.charLength = this.charReceived ? 2 : 0;
      }
      function base64DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 3;
        this.charLength = this.charReceived ? 3 : 0;
      }
      Readable.ReadableState = ReadableState;
      var debug2 = debuglog("stream");
      inherits$1(Readable, EventEmitter);
      function prependListener(emitter, event2, fn) {
        if (typeof emitter.prependListener === "function") {
          return emitter.prependListener(event2, fn);
        } else {
          if (!emitter._events || !emitter._events[event2])
            emitter.on(event2, fn);
          else if (Array.isArray(emitter._events[event2]))
            emitter._events[event2].unshift(fn);
          else
            emitter._events[event2] = [fn, emitter._events[event2]];
        }
      }
      function listenerCount$1(emitter, type2) {
        return emitter.listeners(type2).length;
      }
      function ReadableState(options, stream2) {
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.ranOut = false;
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        if (!(this instanceof Readable)) return new Readable(options);
        this._readableState = new ReadableState(options, this);
        this.readable = true;
        if (options && typeof options.read === "function") this._read = options.read;
        EventEmitter.call(this);
      }
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        if (!state.objectMode && typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
        }
        return readableAddChunk(this, state, chunk, encoding, false);
      };
      Readable.prototype.unshift = function(chunk) {
        var state = this._readableState;
        return readableAddChunk(this, state, chunk, "", true);
      };
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      function readableAddChunk(stream2, state, chunk, encoding, addToFront) {
        var er = chunkInvalid(state, chunk);
        if (er) {
          stream2.emit("error", er);
        } else if (chunk === null) {
          state.reading = false;
          onEofChunk(stream2, state);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (state.ended && !addToFront) {
            var e3 = new Error("stream.push() after EOF");
            stream2.emit("error", e3);
          } else if (state.endEmitted && addToFront) {
            var _e = new Error("stream.unshift() after end event");
            stream2.emit("error", _e);
          } else {
            var skipAdd;
            if (state.decoder && !addToFront && !encoding) {
              chunk = state.decoder.write(chunk);
              skipAdd = !state.objectMode && chunk.length === 0;
            }
            if (!addToFront) state.reading = false;
            if (!skipAdd) {
              if (state.flowing && state.length === 0 && !state.sync) {
                stream2.emit("data", chunk);
                stream2.read(0);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront) state.buffer.unshift(chunk);
                else state.buffer.push(chunk);
                if (state.needReadable) emitReadable(stream2);
              }
            }
            maybeReadMore(stream2, state);
          }
        } else if (!addToFront) {
          state.reading = false;
        }
        return needMoreData(state);
      }
      function needMoreData(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
      }
      Readable.prototype.setEncoding = function(enc) {
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      var MAX_HWM = 8388608;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended) return 0;
        if (state.objectMode) return 1;
        if (n !== n) {
          if (state.flowing && state.length) return state.buffer.head.data.length;
          else return state.length;
        }
        if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length) return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0) state.emittedReadable = false;
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended) endReadable(this);
          else emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0) endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0) state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading) n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0) ret = fromList(n, state);
        else ret = null;
        if (ret === null) {
          state.needReadable = true;
          n = 0;
        } else {
          state.length -= n;
        }
        if (state.length === 0) {
          if (!state.ended) state.needReadable = true;
          if (nOrig !== n && state.ended) endReadable(this);
        }
        if (ret !== null) this.emit("data", ret);
        return ret;
      };
      function chunkInvalid(state, chunk) {
        var er = null;
        if (!isBuffer2(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        return er;
      }
      function onEofChunk(stream2, state) {
        if (state.ended) return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        emitReadable(stream2);
      }
      function emitReadable(stream2) {
        var state = stream2._readableState;
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          if (state.sync) nextTick(emitReadable_, stream2);
          else emitReadable_(stream2);
        }
      }
      function emitReadable_(stream2) {
        debug2("emit readable");
        stream2.emit("readable");
        flow(stream2);
      }
      function maybeReadMore(stream2, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          nextTick(maybeReadMore_, stream2, state);
        }
      }
      function maybeReadMore_(stream2, state) {
        var len = state.length;
        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
          debug2("maybeReadMore read 0");
          stream2.read(0);
          if (len === state.length)
            break;
          else len = state.length;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n) {
        this.emit("error", new Error("not implemented"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = !pipeOpts || pipeOpts.end !== false;
        var endFn = doEnd ? onend2 : cleanup;
        if (state.endEmitted) nextTick(endFn);
        else src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable) {
          debug2("onunpipe");
          if (readable === src) {
            cleanup();
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", cleanup);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
        }
        var increasedAwaitDrain = false;
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (false === ret && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (listenerCount$1(dest, "error") === 0) dest.emit("error", er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain) state.awaitDrain--;
          if (state.awaitDrain === 0 && src.listeners("data").length) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        if (state.pipesCount === 0) return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes) return this;
          if (!dest) dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest) dest.emit("unpipe", this);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var _i = 0; _i < len; _i++) {
            dests[_i].emit("unpipe", this);
          }
          return this;
        }
        var i = indexOf(state.pipes, dest);
        if (i === -1) return this;
        state.pipes.splice(i, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1) state.pipes = state.pipes[0];
        dest.emit("unpipe", this);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = EventEmitter.prototype.on.call(this, ev, fn);
        if (ev === "data") {
          if (this._readableState.flowing !== false) this.resume();
        } else if (ev === "readable") {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              nextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      function nReadingNextTick(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      function resume(stream2, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          nextTick(resume_, stream2, state);
        }
      }
      function resume_(stream2, state) {
        if (!state.reading) {
          debug2("resume read 0");
          stream2.read(0);
        }
        state.resumeScheduled = false;
        state.awaitDrain = 0;
        stream2.emit("resume");
        flow(stream2);
        if (state.flowing && !state.reading) stream2.read(0);
      }
      Readable.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (false !== this._readableState.flowing) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        return this;
      };
      function flow(stream2) {
        var state = stream2._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream2.read() !== null) {
        }
      }
      Readable.prototype.wrap = function(stream2) {
        var state = this._readableState;
        var paused = false;
        var self2 = this;
        stream2.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) self2.push(chunk);
          }
          self2.push(null);
        });
        stream2.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder) chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0)) return;
          else if (!state.objectMode && (!chunk || !chunk.length)) return;
          var ret = self2.push(chunk);
          if (!ret) {
            paused = true;
            stream2.pause();
          }
        });
        for (var i in stream2) {
          if (this[i] === void 0 && typeof stream2[i] === "function") {
            this[i] = /* @__PURE__ */ function(method3) {
              return function() {
                return stream2[method3].apply(stream2, arguments);
              };
            }(i);
          }
        }
        var events2 = ["error", "close", "destroy", "pause", "resume"];
        forEach2(events2, function(ev) {
          stream2.on(ev, self2.emit.bind(self2, ev));
        });
        self2._read = function(n) {
          debug2("wrapped _read", n);
          if (paused) {
            paused = false;
            stream2.resume();
          }
        };
        return self2;
      };
      Readable._fromList = fromList;
      function fromList(n, state) {
        if (state.length === 0) return null;
        var ret;
        if (state.objectMode) ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder) ret = state.buffer.join("");
          else if (state.buffer.length === 1) ret = state.buffer.head.data;
          else ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = fromListPartial(n, state.buffer, state.decoder);
        }
        return ret;
      }
      function fromListPartial(n, list, hasStrings) {
        var ret;
        if (n < list.head.data.length) {
          ret = list.head.data.slice(0, n);
          list.head.data = list.head.data.slice(n);
        } else if (n === list.head.data.length) {
          ret = list.shift();
        } else {
          ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
        }
        return ret;
      }
      function copyFromBufferString(n, list) {
        var p = list.head;
        var c2 = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c2;
              if (p.next) list.head = p.next;
              else list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        list.length -= c2;
        return ret;
      }
      function copyFromBuffer(n, list) {
        var ret = Buffer2.allocUnsafe(n);
        var p = list.head;
        var c2 = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p.next) list.head = p.next;
              else list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        list.length -= c2;
        return ret;
      }
      function endReadable(stream2) {
        var state = stream2._readableState;
        if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
        if (!state.endEmitted) {
          state.ended = true;
          nextTick(endReadableNT, state, stream2);
        }
      }
      function endReadableNT(state, stream2) {
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream2.readable = false;
          stream2.emit("end");
        }
      }
      function forEach2(xs, f) {
        for (var i = 0, l = xs.length; i < l; i++) {
          f(xs[i], i);
        }
      }
      function indexOf(xs, x2) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x2) return i;
        }
        return -1;
      }
      Writable.WritableState = WritableState;
      inherits$1(Writable, EventEmitter);
      function nop() {
      }
      function WriteReq(chunk, encoding, cb) {
        this.chunk = chunk;
        this.encoding = encoding;
        this.callback = cb;
        this.next = null;
      }
      function WritableState(options, stream2) {
        Object.defineProperty(this, "buffer", {
          get: deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
        });
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream2, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function writableStateGetBuffer() {
        var current2 = this.bufferedRequest;
        var out = [];
        while (current2) {
          out.push(current2);
          current2 = current2.next;
        }
        return out;
      };
      function Writable(options) {
        if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
        this._writableState = new WritableState(options, this);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function") this._write = options.write;
          if (typeof options.writev === "function") this._writev = options.writev;
        }
        EventEmitter.call(this);
      }
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      };
      function writeAfterEnd(stream2, cb) {
        var er = new Error("write after end");
        stream2.emit("error", er);
        nextTick(cb, er);
      }
      function validChunk(stream2, state, chunk, cb) {
        var valid2 = true;
        var er = false;
        if (chunk === null) {
          er = new TypeError("May not write null values to stream");
        } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        if (er) {
          stream2.emit("error", er);
          nextTick(cb, er);
          valid2 = false;
        }
        return valid2;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (Buffer2.isBuffer(chunk)) encoding = "buffer";
        else if (!encoding) encoding = state.defaultEncoding;
        if (typeof cb !== "function") cb = nop;
        if (state.ended) writeAfterEnd(this, cb);
        else if (validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string") encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, encoding);
        }
        return chunk;
      }
      function writeOrBuffer(stream2, state, chunk, encoding, cb) {
        chunk = decodeChunk(state, chunk, encoding);
        if (Buffer2.isBuffer(chunk)) encoding = "buffer";
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret) state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream2, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev) stream2._writev(chunk, state.onwrite);
        else stream2._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream2, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) nextTick(cb, er);
        else cb(er);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream2, er) {
        var state = stream2._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        onwriteStateUpdate(state);
        if (er) onwriteError(stream2, state, sync, er, cb);
        else {
          var finished = needFinish(state);
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream2, state);
          }
          if (sync) {
            nextTick(afterWrite, stream2, state, finished, cb);
          } else {
            afterWrite(stream2, state, finished, cb);
          }
        }
      }
      function afterWrite(stream2, state, finished, cb) {
        if (!finished) onwriteDrain(stream2, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream2, state);
      }
      function onwriteDrain(stream2, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream2.emit("drain");
        }
      }
      function clearBuffer(stream2, state) {
        state.bufferProcessing = true;
        var entry2 = state.bufferedRequest;
        if (stream2._writev && entry2 && entry2.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry2;
          var count2 = 0;
          while (entry2) {
            buffer[count2] = entry2;
            entry2 = entry2.next;
            count2 += 1;
          }
          doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
        } else {
          while (entry2) {
            var chunk = entry2.chunk;
            var encoding = entry2.encoding;
            var cb = entry2.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream2, state, false, len, chunk, encoding, cb);
            entry2 = entry2.next;
            if (state.writing) {
              break;
            }
          }
          if (entry2 === null) state.lastBufferedRequest = null;
        }
        state.bufferedRequestCount = 0;
        state.bufferedRequest = entry2;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error("not implemented"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending && !state.finished) endWritable(this, state, cb);
      };
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function prefinish(stream2, state) {
        if (!state.prefinished) {
          state.prefinished = true;
          stream2.emit("prefinish");
        }
      }
      function finishMaybe(stream2, state) {
        var need = needFinish(state);
        if (need) {
          if (state.pendingcb === 0) {
            prefinish(stream2, state);
            state.finished = true;
            stream2.emit("finish");
          } else {
            prefinish(stream2, state);
          }
        }
        return need;
      }
      function endWritable(stream2, state, cb) {
        state.ending = true;
        finishMaybe(stream2, state);
        if (cb) {
          if (state.finished) nextTick(cb);
          else stream2.once("finish", cb);
        }
        state.ended = true;
        stream2.writable = false;
      }
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function(err) {
          var entry2 = _this.entry;
          _this.entry = null;
          while (entry2) {
            var cb = entry2.callback;
            state.pendingcb--;
            cb(err);
            entry2 = entry2.next;
          }
          if (state.corkedRequestsFree) {
            state.corkedRequestsFree.next = _this;
          } else {
            state.corkedRequestsFree = _this;
          }
        };
      }
      inherits$1(Duplex, Readable);
      var keys2 = Object.keys(Writable.prototype);
      for (var v = 0; v < keys2.length; v++) {
        var method2 = keys2[v];
        if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable.prototype[method2];
      }
      function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false) this.readable = false;
        if (options && options.writable === false) this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
        this.once("end", onend);
      }
      function onend() {
        if (this.allowHalfOpen || this._writableState.ended) return;
        nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      inherits$1(Transform2, Duplex);
      function TransformState(stream2) {
        this.afterTransform = function(er, data2) {
          return afterTransform(stream2, er, data2);
        };
        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
        this.writeencoding = null;
      }
      function afterTransform(stream2, er, data2) {
        var ts2 = stream2._transformState;
        ts2.transforming = false;
        var cb = ts2.writecb;
        if (!cb) return stream2.emit("error", new Error("no writecb in Transform class"));
        ts2.writechunk = null;
        ts2.writecb = null;
        if (data2 !== null && data2 !== void 0) stream2.push(data2);
        cb(er);
        var rs = stream2._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          stream2._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2)) return new Transform2(options);
        Duplex.call(this, options);
        this._transformState = new TransformState(this);
        var stream2 = this;
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function") this._transform = options.transform;
          if (typeof options.flush === "function") this._flush = options.flush;
        }
        this.once("prefinish", function() {
          if (typeof this._flush === "function") this._flush(function(er) {
            done(stream2, er);
          });
          else done(stream2);
        });
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("Not implemented");
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts2 = this._transformState;
        ts2.writecb = cb;
        ts2.writechunk = chunk;
        ts2.writeencoding = encoding;
        if (!ts2.transforming) {
          var rs = this._readableState;
          if (ts2.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts2 = this._transformState;
        if (ts2.writechunk !== null && ts2.writecb && !ts2.transforming) {
          ts2.transforming = true;
          this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
        } else {
          ts2.needTransform = true;
        }
      };
      function done(stream2, er) {
        if (er) return stream2.emit("error", er);
        var ws = stream2._writableState;
        var ts2 = stream2._transformState;
        if (ws.length) throw new Error("Calling transform done when ws.length != 0");
        if (ts2.transforming) throw new Error("Calling transform done when still transforming");
        return stream2.push(null);
      }
      inherits$1(PassThrough, Transform2);
      function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform2.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
      inherits$1(Stream, EventEmitter);
      Stream.Readable = Readable;
      Stream.Writable = Writable;
      Stream.Duplex = Duplex;
      Stream.Transform = Transform2;
      Stream.PassThrough = PassThrough;
      Stream.Stream = Stream;
      function Stream() {
        EventEmitter.call(this);
      }
      Stream.prototype.pipe = function(dest, options) {
        var source2 = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source2.pause) {
              source2.pause();
            }
          }
        }
        source2.on("data", ondata);
        function ondrain() {
          if (source2.readable && source2.resume) {
            source2.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source2.on("end", onend2);
          source2.on("close", onclose);
        }
        var didOnEnd = false;
        function onend2() {
          if (didOnEnd) return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;
          if (typeof dest.destroy === "function") dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EventEmitter.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source2.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source2.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source2.removeListener("end", onend2);
          source2.removeListener("close", onclose);
          source2.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source2.removeListener("end", cleanup);
          source2.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source2.on("end", cleanup);
        source2.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source2);
        return dest;
      };
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target2, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target2, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        return Constructor;
      }
      function _defineProperty2(obj, key2, value2) {
        if (key2 in obj) {
          Object.defineProperty(obj, key2, {
            value: value2,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key2] = value2;
        }
        return obj;
      }
      function _objectSpread2(target2) {
        for (var i = 1; i < arguments.length; i++) {
          var source2 = arguments[i] != null ? arguments[i] : {};
          var ownKeys2 = Object.keys(source2);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
            }));
          }
          ownKeys2.forEach(function(key2) {
            _defineProperty2(target2, key2, source2[key2]);
          });
        }
        return target2;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (typeof call === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _toArray(arr) {
        return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
          return arr2;
        }
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var EOL2 = "\n";
      var os = {
        EOL: EOL2
      };
      var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : {};
      var FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
      var funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", symbolTag2 = "[object Symbol]";
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
      var freeGlobal2 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
      var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
      function getValue2(object2, key2) {
        return object2 == null ? void 0 : object2[key2];
      }
      function isHostObject(value2) {
        var result = false;
        if (value2 != null && typeof value2.toString != "function") {
          try {
            result = !!(value2 + "");
          } catch (e3) {
          }
        }
        return result;
      }
      var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
      var coreJsData2 = root2["__core-js_shared__"];
      var maskSrcKey2 = function() {
        var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty$12 = objectProto2.hasOwnProperty;
      var objectToString$1 = objectProto2.toString;
      var reIsNative2 = RegExp(
        "^" + funcToString2.call(hasOwnProperty$12).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Symbol$12 = root2.Symbol, splice2 = arrayProto2.splice;
      var Map2 = getNative2(root2, "Map"), nativeCreate2 = getNative2(Object, "create");
      var symbolProto2 = Symbol$12 ? Symbol$12.prototype : void 0, symbolToString = symbolProto2 ? symbolProto2.toString : void 0;
      function Hash2(entries2) {
        var index2 = -1, length2 = entries2 ? entries2.length : 0;
        this.clear();
        while (++index2 < length2) {
          var entry2 = entries2[index2];
          this.set(entry2[0], entry2[1]);
        }
      }
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
      }
      function hashDelete2(key2) {
        return this.has(key2) && delete this.__data__[key2];
      }
      function hashGet2(key2) {
        var data2 = this.__data__;
        if (nativeCreate2) {
          var result = data2[key2];
          return result === HASH_UNDEFINED2 ? void 0 : result;
        }
        return hasOwnProperty$12.call(data2, key2) ? data2[key2] : void 0;
      }
      function hashHas2(key2) {
        var data2 = this.__data__;
        return nativeCreate2 ? data2[key2] !== void 0 : hasOwnProperty$12.call(data2, key2);
      }
      function hashSet2(key2, value2) {
        var data2 = this.__data__;
        data2[key2] = nativeCreate2 && value2 === void 0 ? HASH_UNDEFINED2 : value2;
        return this;
      }
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries2) {
        var index2 = -1, length2 = entries2 ? entries2.length : 0;
        this.clear();
        while (++index2 < length2) {
          var entry2 = entries2[index2];
          this.set(entry2[0], entry2[1]);
        }
      }
      function listCacheClear2() {
        this.__data__ = [];
      }
      function listCacheDelete2(key2) {
        var data2 = this.__data__, index2 = assocIndexOf2(data2, key2);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice2.call(data2, index2, 1);
        }
        return true;
      }
      function listCacheGet2(key2) {
        var data2 = this.__data__, index2 = assocIndexOf2(data2, key2);
        return index2 < 0 ? void 0 : data2[index2][1];
      }
      function listCacheHas2(key2) {
        return assocIndexOf2(this.__data__, key2) > -1;
      }
      function listCacheSet2(key2, value2) {
        var data2 = this.__data__, index2 = assocIndexOf2(data2, key2);
        if (index2 < 0) {
          data2.push([key2, value2]);
        } else {
          data2[index2][1] = value2;
        }
        return this;
      }
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries2) {
        var index2 = -1, length2 = entries2 ? entries2.length : 0;
        this.clear();
        while (++index2 < length2) {
          var entry2 = entries2[index2];
          this.set(entry2[0], entry2[1]);
        }
      }
      function mapCacheClear2() {
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache2)(),
          "string": new Hash2()
        };
      }
      function mapCacheDelete2(key2) {
        return getMapData2(this, key2)["delete"](key2);
      }
      function mapCacheGet2(key2) {
        return getMapData2(this, key2).get(key2);
      }
      function mapCacheHas2(key2) {
        return getMapData2(this, key2).has(key2);
      }
      function mapCacheSet2(key2, value2) {
        getMapData2(this, key2).set(key2, value2);
        return this;
      }
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function assocIndexOf2(array2, key2) {
        var length2 = array2.length;
        while (length2--) {
          if (eq2(array2[length2][0], key2)) {
            return length2;
          }
        }
        return -1;
      }
      function baseGet(object2, path2) {
        path2 = isKey(path2, object2) ? [path2] : castPath(path2);
        var index2 = 0, length2 = path2.length;
        while (object2 != null && index2 < length2) {
          object2 = object2[toKey(path2[index2++])];
        }
        return index2 && index2 == length2 ? object2 : void 0;
      }
      function baseIsNative2(value2) {
        if (!isObject$12(value2) || isMasked2(value2)) {
          return false;
        }
        var pattern = isFunction$12(value2) || isHostObject(value2) ? reIsNative2 : reIsHostCtor2;
        return pattern.test(toSource2(value2));
      }
      function baseToString(value2) {
        if (typeof value2 == "string") {
          return value2;
        }
        if (isSymbol(value2)) {
          return symbolToString ? symbolToString.call(value2) : "";
        }
        var result = value2 + "";
        return result == "0" && 1 / value2 == -Infinity ? "-0" : result;
      }
      function castPath(value2) {
        return isArray$2(value2) ? value2 : stringToPath(value2);
      }
      function getMapData2(map2, key2) {
        var data2 = map2.__data__;
        return isKeyable2(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
      }
      function getNative2(object2, key2) {
        var value2 = getValue2(object2, key2);
        return baseIsNative2(value2) ? value2 : void 0;
      }
      function isKey(value2, object2) {
        if (isArray$2(value2)) {
          return false;
        }
        var type2 = typeof value2;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value2 == null || isSymbol(value2)) {
          return true;
        }
        return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object2 != null && value2 in Object(object2);
      }
      function isKeyable2(value2) {
        var type2 = typeof value2;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
      }
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      var stringToPath = memoize2(function(string2) {
        string2 = toString$1(string2);
        var result = [];
        if (reLeadingDot.test(string2)) {
          result.push("");
        }
        string2.replace(rePropName, function(match2, number2, quote, string3) {
          result.push(quote ? string3.replace(reEscapeChar, "$1") : number2 || match2);
        });
        return result;
      });
      function toKey(value2) {
        if (typeof value2 == "string" || isSymbol(value2)) {
          return value2;
        }
        var result = value2 + "";
        return result == "0" && 1 / value2 == -Infinity ? "-0" : result;
      }
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key2)) {
            return cache2.get(key2);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key2, result);
          return result;
        };
        memoized.cache = new (memoize2.Cache || MapCache2)();
        return memoized;
      }
      memoize2.Cache = MapCache2;
      function eq2(value2, other) {
        return value2 === other || value2 !== value2 && other !== other;
      }
      var isArray$2 = Array.isArray;
      function isFunction$12(value2) {
        var tag = isObject$12(value2) ? objectToString$1.call(value2) : "";
        return tag == funcTag2 || tag == genTag2;
      }
      function isObject$12(value2) {
        var type2 = typeof value2;
        return !!value2 && (type2 == "object" || type2 == "function");
      }
      function isObjectLike2(value2) {
        return !!value2 && typeof value2 == "object";
      }
      function isSymbol(value2) {
        return typeof value2 == "symbol" || isObjectLike2(value2) && objectToString$1.call(value2) == symbolTag2;
      }
      function toString$1(value2) {
        return value2 == null ? "" : baseToString(value2);
      }
      function get2(object2, path2, defaultValue) {
        var result = object2 == null ? void 0 : baseGet(object2, path2);
        return result === void 0 ? defaultValue : result;
      }
      var lodash_get = get2;
      function getProp(obj, path2, defaultValue) {
        return obj[path2] === void 0 ? defaultValue : obj[path2];
      }
      function setProp(obj, path2, value2) {
        var pathArray = Array.isArray(path2) ? path2 : path2.split(".");
        var _pathArray = _toArray(pathArray), key2 = _pathArray[0], restPath = _pathArray.slice(1);
        return _objectSpread2({}, obj, _defineProperty2({}, key2, pathArray.length > 1 ? setProp(obj[key2] || {}, restPath, value2) : value2));
      }
      function unsetProp(obj, path2) {
        var pathArray = Array.isArray(path2) ? path2 : path2.split(".");
        var _pathArray2 = _toArray(pathArray), key2 = _pathArray2[0], restPath = _pathArray2.slice(1);
        if (_typeof(obj[key2]) !== "object") {
          return obj;
        }
        if (pathArray.length === 1) {
          return Object.keys(obj).filter(function(prop) {
            return prop !== key2;
          }).reduce(function(acc, prop) {
            return Object.assign(acc, _defineProperty2({}, prop, obj[prop]));
          }, {});
        }
        return Object.keys(obj).reduce(function(acc, prop) {
          return _objectSpread2({}, acc, _defineProperty2({}, prop, prop !== key2 ? obj[prop] : unsetProp(obj[key2], restPath)));
        }, {});
      }
      function flattenReducer(acc, arr) {
        try {
          acc.push.apply(acc, _toConsumableArray(arr));
          return acc;
        } catch (err) {
          return acc.concat(arr);
        }
      }
      function fastJoin(arr, separator) {
        var isFirst = true;
        return arr.reduce(function(acc, elem) {
          if (elem === null || elem === void 0) {
            elem = "";
          }
          if (isFirst) {
            isFirst = false;
            return "".concat(elem);
          }
          return "".concat(acc).concat(separator).concat(elem);
        }, "");
      }
      var utils = {
        getProp,
        setProp,
        unsetProp,
        fastJoin,
        flattenReducer
      };
      var getProp$1 = utils.getProp, fastJoin$1 = utils.fastJoin, flattenReducer$1 = utils.flattenReducer;
      var JSON2CSVBase = /* @__PURE__ */ function() {
        function JSON2CSVBase2(opts2) {
          _classCallCheck(this, JSON2CSVBase2);
          this.opts = this.preprocessOpts(opts2);
        }
        _createClass(JSON2CSVBase2, [{
          key: "preprocessOpts",
          value: function preprocessOpts(opts2) {
            var processedOpts = Object.assign({}, opts2);
            processedOpts.transforms = !Array.isArray(processedOpts.transforms) ? processedOpts.transforms ? [processedOpts.transforms] : [] : processedOpts.transforms;
            processedOpts.delimiter = processedOpts.delimiter || ",";
            processedOpts.eol = processedOpts.eol || os.EOL;
            processedOpts.quote = typeof processedOpts.quote === "string" ? processedOpts.quote : '"';
            processedOpts.escapedQuote = typeof processedOpts.escapedQuote === "string" ? processedOpts.escapedQuote : "".concat(processedOpts.quote).concat(processedOpts.quote);
            processedOpts.header = processedOpts.header !== false;
            processedOpts.includeEmptyRows = processedOpts.includeEmptyRows || false;
            processedOpts.withBOM = processedOpts.withBOM || false;
            return processedOpts;
          }
          /**
           * Check and normalize the fields configuration.
           *
           * @param {(string|object)[]} fields Fields configuration provided by the user
           * or inferred from the data
           * @returns {object[]} preprocessed FieldsInfo array
           */
        }, {
          key: "preprocessFieldsInfo",
          value: function preprocessFieldsInfo(fields) {
            var _this = this;
            return fields.map(function(fieldInfo) {
              if (typeof fieldInfo === "string") {
                return {
                  label: fieldInfo,
                  value: fieldInfo.includes(".") || fieldInfo.includes("[") ? function(row) {
                    return lodash_get(row, fieldInfo, _this.opts.defaultValue);
                  } : function(row) {
                    return getProp$1(row, fieldInfo, _this.opts.defaultValue);
                  }
                };
              }
              if (_typeof(fieldInfo) === "object") {
                var defaultValue = "default" in fieldInfo ? fieldInfo.default : _this.opts.defaultValue;
                if (typeof fieldInfo.value === "string") {
                  return {
                    label: fieldInfo.label || fieldInfo.value,
                    value: fieldInfo.value.includes(".") || fieldInfo.value.includes("[") ? function(row) {
                      return lodash_get(row, fieldInfo.value, defaultValue);
                    } : function(row) {
                      return getProp$1(row, fieldInfo.value, defaultValue);
                    }
                  };
                }
                if (typeof fieldInfo.value === "function") {
                  var label2 = fieldInfo.label || fieldInfo.value.name || "";
                  var field2 = {
                    label: label2,
                    default: defaultValue
                  };
                  return {
                    label: label2,
                    value: function value2(row) {
                      var value3 = fieldInfo.value(row, field2);
                      return value3 === null || value3 === void 0 ? defaultValue : value3;
                    }
                  };
                }
              }
              throw new Error("Invalid field info option. " + JSON.stringify(fieldInfo));
            });
          }
          /**
           * Create the title row with all the provided fields as column headings
           *
           * @returns {String} titles as a string
           */
        }, {
          key: "getHeader",
          value: function getHeader() {
            var _this2 = this;
            return fastJoin$1(this.opts.fields.map(function(fieldInfo) {
              return _this2.processValue(fieldInfo.label);
            }), this.opts.delimiter);
          }
          /**
           * Preprocess each object according to the given transforms (unwind, flatten, etc.).
           * @param {Object} row JSON object to be converted in a CSV row
           */
        }, {
          key: "preprocessRow",
          value: function preprocessRow(row) {
            return this.opts.transforms.reduce(function(rows, transform2) {
              return rows.map(function(row2) {
                return transform2(row2);
              }).reduce(flattenReducer$1, []);
            }, [row]);
          }
          /**
           * Create the content of a specific CSV row
           *
           * @param {Object} row JSON object to be converted in a CSV row
           * @returns {String} CSV string (row)
           */
        }, {
          key: "processRow",
          value: function processRow(row) {
            var _this3 = this;
            if (!row) {
              return void 0;
            }
            var processedRow = this.opts.fields.map(function(fieldInfo) {
              return _this3.processCell(row, fieldInfo);
            });
            if (!this.opts.includeEmptyRows && processedRow.every(function(field2) {
              return field2 === void 0;
            })) {
              return void 0;
            }
            return fastJoin$1(processedRow, this.opts.delimiter);
          }
          /**
           * Create the content of a specfic CSV row cell
           *
           * @param {Object} row JSON object representing the  CSV row that the cell belongs to
           * @param {FieldInfo} fieldInfo Details of the field to process to be a CSV cell
           * @returns {String} CSV string (cell)
           */
        }, {
          key: "processCell",
          value: function processCell(row, fieldInfo) {
            return this.processValue(fieldInfo.value(row));
          }
          /**
           * Create the content of a specfic CSV row cell
           *
           * @param {Any} value Value to be included in a CSV cell
           * @returns {String} Value stringified and processed
           */
        }, {
          key: "processValue",
          value: function processValue(value2) {
            if (value2 === null || value2 === void 0) {
              return void 0;
            }
            var valueType = _typeof(value2);
            if (valueType !== "boolean" && valueType !== "number" && valueType !== "string") {
              value2 = JSON.stringify(value2);
              if (value2 === void 0) {
                return void 0;
              }
              if (value2[0] === '"') {
                value2 = value2.replace(/^"(.+)"$/, "$1");
              }
            }
            if (typeof value2 === "string") {
              if (this.opts.excelStrings) {
                if (value2.includes(this.opts.quote)) {
                  value2 = value2.replace(new RegExp(this.opts.quote, "g"), "".concat(this.opts.escapedQuote).concat(this.opts.escapedQuote));
                }
                value2 = '"=""'.concat(value2, '"""');
              } else {
                if (value2.includes(this.opts.quote)) {
                  value2 = value2.replace(new RegExp(this.opts.quote, "g"), this.opts.escapedQuote);
                }
                value2 = "".concat(this.opts.quote).concat(value2).concat(this.opts.quote);
              }
            }
            return value2;
          }
        }]);
        return JSON2CSVBase2;
      }();
      var JSON2CSVBase_1 = JSON2CSVBase;
      var fastJoin$2 = utils.fastJoin, flattenReducer$2 = utils.flattenReducer;
      var JSON2CSVParser = /* @__PURE__ */ function(_JSON2CSVBase) {
        _inherits(JSON2CSVParser2, _JSON2CSVBase);
        function JSON2CSVParser2(opts2) {
          var _this;
          _classCallCheck(this, JSON2CSVParser2);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(JSON2CSVParser2).call(this, opts2));
          if (_this.opts.fields) {
            _this.opts.fields = _this.preprocessFieldsInfo(_this.opts.fields);
          }
          return _this;
        }
        _createClass(JSON2CSVParser2, [{
          key: "parse",
          value: function parse3(data2) {
            var processedData = this.preprocessData(data2);
            if (!this.opts.fields) {
              this.opts.fields = processedData.reduce(function(fields, item) {
                Object.keys(item).forEach(function(field2) {
                  if (!fields.includes(field2)) {
                    fields.push(field2);
                  }
                });
                return fields;
              }, []);
              this.opts.fields = this.preprocessFieldsInfo(this.opts.fields);
            }
            var header = this.opts.header ? this.getHeader() : "";
            var rows = this.processData(processedData);
            var csv = (this.opts.withBOM ? "\uFEFF" : "") + header + (header && rows ? this.opts.eol : "") + rows;
            return csv;
          }
          /**
           * Preprocess the data according to the give opts (unwind, flatten, etc.)
            and calculate the fields and field names if they are not provided.
           *
           * @param {Array|Object} data Array or object to be converted to CSV
           */
        }, {
          key: "preprocessData",
          value: function preprocessData(data2) {
            var _this2 = this;
            var processedData = Array.isArray(data2) ? data2 : [data2];
            if (!this.opts.fields && (processedData.length === 0 || _typeof(processedData[0]) !== "object")) {
              throw new Error('Data should not be empty or the "fields" option should be included');
            }
            if (this.opts.transforms.length === 0) return processedData;
            return processedData.map(function(row) {
              return _this2.preprocessRow(row);
            }).reduce(flattenReducer$2, []);
          }
          /**
           * Create the content row by row below the header
           *
           * @param {Array} data Array of JSON objects to be converted to CSV
           * @returns {String} CSV string (body)
           */
        }, {
          key: "processData",
          value: function processData(data2) {
            var _this3 = this;
            return fastJoin$2(
              data2.map(function(row) {
                return _this3.processRow(row);
              }).filter(function(row) {
                return row;
              }),
              // Filter empty rows
              this.opts.eol
            );
          }
        }]);
        return JSON2CSVParser2;
      }(JSON2CSVBase_1);
      var JSON2CSVParser_1 = JSON2CSVParser;
      var C3 = {};
      var LEFT_BRACE = C3.LEFT_BRACE = 1;
      var RIGHT_BRACE = C3.RIGHT_BRACE = 2;
      var LEFT_BRACKET = C3.LEFT_BRACKET = 3;
      var RIGHT_BRACKET = C3.RIGHT_BRACKET = 4;
      var COLON2 = C3.COLON = 5;
      var COMMA2 = C3.COMMA = 6;
      var TRUE = C3.TRUE = 7;
      var FALSE = C3.FALSE = 8;
      var NULL2 = C3.NULL = 9;
      var STRING = C3.STRING = 10;
      var NUMBER = C3.NUMBER = 11;
      var START = C3.START = 17;
      var STOP = C3.STOP = 18;
      var TRUE1 = C3.TRUE1 = 33;
      var TRUE2 = C3.TRUE2 = 34;
      var TRUE3 = C3.TRUE3 = 35;
      var FALSE1 = C3.FALSE1 = 49;
      var FALSE2 = C3.FALSE2 = 50;
      var FALSE3 = C3.FALSE3 = 51;
      var FALSE4 = C3.FALSE4 = 52;
      var NULL1 = C3.NULL1 = 65;
      var NULL22 = C3.NULL2 = 66;
      var NULL3 = C3.NULL3 = 67;
      var NUMBER1 = C3.NUMBER1 = 81;
      var NUMBER3 = C3.NUMBER3 = 83;
      var STRING1 = C3.STRING1 = 97;
      var STRING2 = C3.STRING2 = 98;
      var STRING3 = C3.STRING3 = 99;
      var STRING4 = C3.STRING4 = 100;
      var STRING5 = C3.STRING5 = 101;
      var STRING6 = C3.STRING6 = 102;
      var VALUE = C3.VALUE = 113;
      var KEY2 = C3.KEY = 114;
      var OBJECT = C3.OBJECT = 129;
      var ARRAY = C3.ARRAY = 130;
      var BACK_SLASH = "\\".charCodeAt(0);
      var FORWARD_SLASH = "/".charCodeAt(0);
      var BACKSPACE = "\b".charCodeAt(0);
      var FORM_FEED = "\f".charCodeAt(0);
      var NEWLINE2 = "\n".charCodeAt(0);
      var CARRIAGE_RETURN = "\r".charCodeAt(0);
      var TAB = "	".charCodeAt(0);
      var STRING_BUFFER_SIZE = 64 * 1024;
      function Parser() {
        this.tState = START;
        this.value = void 0;
        this.string = void 0;
        this.stringBuffer = Buffer2.alloc ? Buffer2.alloc(STRING_BUFFER_SIZE) : new Buffer2(STRING_BUFFER_SIZE);
        this.stringBufferOffset = 0;
        this.unicode = void 0;
        this.highSurrogate = void 0;
        this.key = void 0;
        this.mode = void 0;
        this.stack = [];
        this.state = VALUE;
        this.bytes_remaining = 0;
        this.bytes_in_sequence = 0;
        this.temp_buffs = { "2": new Buffer2(2), "3": new Buffer2(3), "4": new Buffer2(4) };
        this.offset = -1;
      }
      Parser.toknam = function(code) {
        var keys3 = Object.keys(C3);
        for (var i = 0, l = keys3.length; i < l; i++) {
          var key2 = keys3[i];
          if (C3[key2] === code) {
            return key2;
          }
        }
        return code && "0x" + code.toString(16);
      };
      var proto = Parser.prototype;
      proto.onError = function(err) {
        throw err;
      };
      proto.charError = function(buffer, i) {
        this.tState = STOP;
        this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser.toknam(this.tState)));
      };
      proto.appendStringChar = function(char2) {
        if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8");
          this.stringBufferOffset = 0;
        }
        this.stringBuffer[this.stringBufferOffset++] = char2;
      };
      proto.appendStringBuf = function(buf, start, end) {
        var size = buf.length;
        if (typeof start === "number") {
          if (typeof end === "number") {
            if (end < 0) {
              size = buf.length - start + end;
            } else {
              size = end - start;
            }
          } else {
            size = buf.length - start;
          }
        }
        if (size < 0) {
          size = 0;
        }
        if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
          this.stringBufferOffset = 0;
        }
        buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);
        this.stringBufferOffset += size;
      };
      proto.write = function(buffer) {
        if (typeof buffer === "string") buffer = new Buffer2(buffer);
        var n;
        for (var i = 0, l = buffer.length; i < l; i++) {
          if (this.tState === START) {
            n = buffer[i];
            this.offset++;
            if (n === 123) {
              this.onToken(LEFT_BRACE, "{");
            } else if (n === 125) {
              this.onToken(RIGHT_BRACE, "}");
            } else if (n === 91) {
              this.onToken(LEFT_BRACKET, "[");
            } else if (n === 93) {
              this.onToken(RIGHT_BRACKET, "]");
            } else if (n === 58) {
              this.onToken(COLON2, ":");
            } else if (n === 44) {
              this.onToken(COMMA2, ",");
            } else if (n === 116) {
              this.tState = TRUE1;
            } else if (n === 102) {
              this.tState = FALSE1;
            } else if (n === 110) {
              this.tState = NULL1;
            } else if (n === 34) {
              this.string = "";
              this.stringBufferOffset = 0;
              this.tState = STRING1;
            } else if (n === 45) {
              this.string = "-";
              this.tState = NUMBER1;
            } else {
              if (n >= 48 && n < 64) {
                this.string = String.fromCharCode(n);
                this.tState = NUMBER3;
              } else if (n === 32 || n === 9 || n === 10 || n === 13) ;
              else {
                return this.charError(buffer, i);
              }
            }
          } else if (this.tState === STRING1) {
            n = buffer[i];
            if (this.bytes_remaining > 0) {
              for (var j = 0; j < this.bytes_remaining; j++) {
                this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
              }
              this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);
              this.bytes_in_sequence = this.bytes_remaining = 0;
              i = i + j - 1;
            } else if (this.bytes_remaining === 0 && n >= 128) {
              if (n <= 193 || n > 244) {
                return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser.toknam(this.tState)));
              }
              if (n >= 194 && n <= 223) this.bytes_in_sequence = 2;
              if (n >= 224 && n <= 239) this.bytes_in_sequence = 3;
              if (n >= 240 && n <= 244) this.bytes_in_sequence = 4;
              if (this.bytes_in_sequence + i > buffer.length) {
                for (var k = 0; k <= buffer.length - 1 - i; k++) {
                  this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
                }
                this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;
                i = buffer.length - 1;
              } else {
                this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);
                i = i + this.bytes_in_sequence - 1;
              }
            } else if (n === 34) {
              this.tState = START;
              this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
              this.stringBufferOffset = 0;
              this.onToken(STRING, this.string);
              this.offset += Buffer2.byteLength(this.string, "utf8") + 1;
              this.string = void 0;
            } else if (n === 92) {
              this.tState = STRING2;
            } else if (n >= 32) {
              this.appendStringChar(n);
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING2) {
            n = buffer[i];
            if (n === 34) {
              this.appendStringChar(n);
              this.tState = STRING1;
            } else if (n === 92) {
              this.appendStringChar(BACK_SLASH);
              this.tState = STRING1;
            } else if (n === 47) {
              this.appendStringChar(FORWARD_SLASH);
              this.tState = STRING1;
            } else if (n === 98) {
              this.appendStringChar(BACKSPACE);
              this.tState = STRING1;
            } else if (n === 102) {
              this.appendStringChar(FORM_FEED);
              this.tState = STRING1;
            } else if (n === 110) {
              this.appendStringChar(NEWLINE2);
              this.tState = STRING1;
            } else if (n === 114) {
              this.appendStringChar(CARRIAGE_RETURN);
              this.tState = STRING1;
            } else if (n === 116) {
              this.appendStringChar(TAB);
              this.tState = STRING1;
            } else if (n === 117) {
              this.unicode = "";
              this.tState = STRING3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {
            n = buffer[i];
            if (n >= 48 && n < 64 || n > 64 && n <= 70 || n > 96 && n <= 102) {
              this.unicode += String.fromCharCode(n);
              if (this.tState++ === STRING6) {
                var intVal = parseInt(this.unicode, 16);
                this.unicode = void 0;
                if (this.highSurrogate !== void 0 && intVal >= 56320 && intVal < 57343 + 1) {
                  this.appendStringBuf(new Buffer2(String.fromCharCode(this.highSurrogate, intVal)));
                  this.highSurrogate = void 0;
                } else if (this.highSurrogate === void 0 && intVal >= 55296 && intVal < 56319 + 1) {
                  this.highSurrogate = intVal;
                } else {
                  if (this.highSurrogate !== void 0) {
                    this.appendStringBuf(new Buffer2(String.fromCharCode(this.highSurrogate)));
                    this.highSurrogate = void 0;
                  }
                  this.appendStringBuf(new Buffer2(String.fromCharCode(intVal)));
                }
                this.tState = STRING1;
              }
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
            n = buffer[i];
            switch (n) {
              case 48:
              // 0
              case 49:
              // 1
              case 50:
              // 2
              case 51:
              // 3
              case 52:
              // 4
              case 53:
              // 5
              case 54:
              // 6
              case 55:
              // 7
              case 56:
              // 8
              case 57:
              // 9
              case 46:
              // .
              case 101:
              // e
              case 69:
              // E
              case 43:
              // +
              case 45:
                this.string += String.fromCharCode(n);
                this.tState = NUMBER3;
                break;
              default:
                this.tState = START;
                var result = Number(this.string);
                if (isNaN(result)) {
                  return this.charError(buffer, i);
                }
                if (this.string.match(/[0-9]+/) == this.string && result.toString() != this.string) {
                  this.onToken(STRING, this.string);
                } else {
                  this.onToken(NUMBER, result);
                }
                this.offset += this.string.length - 1;
                this.string = void 0;
                i--;
                break;
            }
          } else if (this.tState === TRUE1) {
            if (buffer[i] === 114) {
              this.tState = TRUE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE2) {
            if (buffer[i] === 117) {
              this.tState = TRUE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE3) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(TRUE, true);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE1) {
            if (buffer[i] === 97) {
              this.tState = FALSE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE2) {
            if (buffer[i] === 108) {
              this.tState = FALSE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE3) {
            if (buffer[i] === 115) {
              this.tState = FALSE4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE4) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(FALSE, false);
              this.offset += 4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL1) {
            if (buffer[i] === 117) {
              this.tState = NULL22;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL22) {
            if (buffer[i] === 108) {
              this.tState = NULL3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL3) {
            if (buffer[i] === 108) {
              this.tState = START;
              this.onToken(NULL2, null);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          }
        }
      };
      proto.onToken = function(token2, value2) {
      };
      proto.parseError = function(token2, value2) {
        this.tState = STOP;
        this.onError(new Error("Unexpected " + Parser.toknam(token2) + (value2 ? "(" + JSON.stringify(value2) + ")" : "") + " in state " + Parser.toknam(this.state)));
      };
      proto.push = function() {
        this.stack.push({ value: this.value, key: this.key, mode: this.mode });
      };
      proto.pop = function() {
        var value2 = this.value;
        var parent = this.stack.pop();
        this.value = parent.value;
        this.key = parent.key;
        this.mode = parent.mode;
        this.emit(value2);
        if (!this.mode) {
          this.state = VALUE;
        }
      };
      proto.emit = function(value2) {
        if (this.mode) {
          this.state = COMMA2;
        }
        this.onValue(value2);
      };
      proto.onValue = function(value2) {
      };
      proto.onToken = function(token2, value2) {
        if (this.state === VALUE) {
          if (token2 === STRING || token2 === NUMBER || token2 === TRUE || token2 === FALSE || token2 === NULL2) {
            if (this.value) {
              this.value[this.key] = value2;
            }
            this.emit(value2);
          } else if (token2 === LEFT_BRACE) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = {};
            } else {
              this.value = {};
            }
            this.key = void 0;
            this.state = KEY2;
            this.mode = OBJECT;
          } else if (token2 === LEFT_BRACKET) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = [];
            } else {
              this.value = [];
            }
            this.key = 0;
            this.mode = ARRAY;
            this.state = VALUE;
          } else if (token2 === RIGHT_BRACE) {
            if (this.mode === OBJECT) {
              this.pop();
            } else {
              return this.parseError(token2, value2);
            }
          } else if (token2 === RIGHT_BRACKET) {
            if (this.mode === ARRAY) {
              this.pop();
            } else {
              return this.parseError(token2, value2);
            }
          } else {
            return this.parseError(token2, value2);
          }
        } else if (this.state === KEY2) {
          if (token2 === STRING) {
            this.key = value2;
            this.state = COLON2;
          } else if (token2 === RIGHT_BRACE) {
            this.pop();
          } else {
            return this.parseError(token2, value2);
          }
        } else if (this.state === COLON2) {
          if (token2 === COLON2) {
            this.state = VALUE;
          } else {
            return this.parseError(token2, value2);
          }
        } else if (this.state === COMMA2) {
          if (token2 === COMMA2) {
            if (this.mode === ARRAY) {
              this.key++;
              this.state = VALUE;
            } else if (this.mode === OBJECT) {
              this.state = KEY2;
            }
          } else if (token2 === RIGHT_BRACKET && this.mode === ARRAY || token2 === RIGHT_BRACE && this.mode === OBJECT) {
            this.pop();
          } else {
            return this.parseError(token2, value2);
          }
        } else {
          return this.parseError(token2, value2);
        }
      };
      Parser.C = C3;
      var jsonparse = Parser;
      var Transform$1 = Stream.Transform;
      var JSON2CSVTransform = /* @__PURE__ */ function(_Transform) {
        _inherits(JSON2CSVTransform2, _Transform);
        function JSON2CSVTransform2(opts2, transformOpts) {
          var _this;
          _classCallCheck(this, JSON2CSVTransform2);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(JSON2CSVTransform2).call(this, transformOpts));
          Object.getOwnPropertyNames(JSON2CSVBase_1.prototype).forEach(function(key2) {
            return _this[key2] = JSON2CSVBase_1.prototype[key2];
          });
          _this.opts = _this.preprocessOpts(opts2);
          _this._data = "";
          _this._hasWritten = false;
          if (_this._readableState.objectMode) {
            _this.initObjectModeParse();
          } else if (_this.opts.ndjson) {
            _this.initNDJSONParse();
          } else {
            _this.initJSONParser();
          }
          if (_this.opts.withBOM) {
            _this.push("\uFEFF");
          }
          if (_this.opts.fields) {
            _this.opts.fields = _this.preprocessFieldsInfo(_this.opts.fields);
            _this.pushHeader();
          }
          return _this;
        }
        _createClass(JSON2CSVTransform2, [{
          key: "initObjectModeParse",
          value: function initObjectModeParse() {
            var transform2 = this;
            this.parser = {
              write: function write2(line2) {
                transform2.pushLine(line2);
              },
              getPendingData: function getPendingData() {
                return void 0;
              }
            };
          }
          /**
           * Init the transform with a parser to process NDJSON data.
           * It maintains a buffer of received data, parses each line
           * as JSON and send it to `pushLine for processing.
           */
        }, {
          key: "initNDJSONParse",
          value: function initNDJSONParse() {
            var transform2 = this;
            this.parser = {
              _data: "",
              write: function write2(chunk) {
                this._data += chunk.toString();
                var lines = this._data.split("\n").map(function(line2) {
                  return line2.trim();
                }).filter(function(line2) {
                  return line2 !== "";
                });
                var pendingData = false;
                lines.forEach(function(line2, i) {
                  try {
                    transform2.pushLine(JSON.parse(line2));
                  } catch (e3) {
                    if (i === lines.length - 1) {
                      pendingData = true;
                    } else {
                      e3.message = "Invalid JSON (".concat(line2, ")");
                      transform2.emit("error", e3);
                    }
                  }
                });
                this._data = pendingData ? this._data.slice(this._data.lastIndexOf("\n")) : "";
              },
              getPendingData: function getPendingData() {
                return this._data;
              }
            };
          }
          /**
           * Init the transform with a parser to process JSON data.
           * It maintains a buffer of received data, parses each as JSON 
           * item if the data is an array or the data itself otherwise
           * and send it to `pushLine` for processing.
           */
        }, {
          key: "initJSONParser",
          value: function initJSONParser() {
            var transform2 = this;
            this.parser = new jsonparse();
            this.parser.onValue = function(value2) {
              if (this.stack.length !== this.depthToEmit) return;
              transform2.pushLine(value2);
            };
            this.parser._onToken = this.parser.onToken;
            this.parser.onToken = function(token2, value2) {
              transform2.parser._onToken(token2, value2);
              if (this.stack.length === 0 && !transform2.opts.fields && this.mode !== jsonparse.C.ARRAY && this.mode !== jsonparse.C.OBJECT) {
                this.onError(new Error('Data should not be empty or the "fields" option should be included'));
              }
              if (this.stack.length === 1) {
                if (this.depthToEmit === void 0) {
                  this.depthToEmit = this.mode === jsonparse.C.ARRAY ? 1 : 0;
                }
                if (this.depthToEmit !== 0 && this.stack.length === 1) {
                  this.value = void 0;
                }
              }
            };
            this.parser.getPendingData = function() {
              return this.value;
            };
            this.parser.onError = function(err) {
              if (err.message.includes("Unexpected")) {
                err.message = "Invalid JSON (".concat(err.message, ")");
              }
              transform2.emit("error", err);
            };
          }
          /**
           * Main function that send data to the parse to be processed.
           *
           * @param {Buffer} chunk Incoming data
           * @param {String} encoding Encoding of the incoming data. Defaults to 'utf8'
           * @param {Function} done Called when the proceesing of the supplied chunk is done
           */
        }, {
          key: "_transform",
          value: function _transform(chunk, encoding, done2) {
            this.parser.write(chunk);
            done2();
          }
        }, {
          key: "_flush",
          value: function _flush(done2) {
            if (this.parser.getPendingData()) {
              done2(new Error("Invalid data received from stdin", this.parser.getPendingData()));
            }
            done2();
          }
          /**
           * Generate the csv header and pushes it downstream.
           */
        }, {
          key: "pushHeader",
          value: function pushHeader() {
            if (this.opts.header) {
              var header = this.getHeader();
              this.emit("header", header);
              this.push(header);
              this._hasWritten = true;
            }
          }
          /**
           * Transforms an incoming json data to csv and pushes it downstream.
           *
           * @param {Object} data JSON object to be converted in a CSV row
           */
        }, {
          key: "pushLine",
          value: function pushLine(data2) {
            var _this2 = this;
            var processedData = this.preprocessRow(data2);
            if (!this._hasWritten) {
              this.opts.fields = this.opts.fields || this.preprocessFieldsInfo(Object.keys(processedData[0]));
              this.pushHeader();
            }
            processedData.forEach(function(row) {
              var line2 = _this2.processRow(row, _this2.opts);
              if (line2 === void 0) return;
              _this2.emit("line", line2);
              _this2.push(_this2._hasWritten ? _this2.opts.eol + line2 : line2);
              _this2._hasWritten = true;
            });
          }
        }]);
        return JSON2CSVTransform2;
      }(Transform$1);
      var JSON2CSVTransform_1 = JSON2CSVTransform;
      var Transform$2 = Stream.Transform;
      var fastJoin$3 = utils.fastJoin;
      var JSON2CSVAsyncParser = /* @__PURE__ */ function() {
        function JSON2CSVAsyncParser2(opts2, transformOpts) {
          _classCallCheck(this, JSON2CSVAsyncParser2);
          this.input = new Transform$2(transformOpts);
          this.input._read = function() {
          };
          this.transform = new JSON2CSVTransform_1(opts2, transformOpts);
          this.processor = this.input.pipe(this.transform);
        }
        _createClass(JSON2CSVAsyncParser2, [{
          key: "fromInput",
          value: function fromInput(input) {
            if (this._input) {
              throw new Error("Async parser already has an input.");
            }
            this._input = input;
            this.input = this._input.pipe(this.processor);
            return this;
          }
        }, {
          key: "throughTransform",
          value: function throughTransform(transform2) {
            if (this._output) {
              throw new Error("Can't add transforms once an output has been added.");
            }
            this.processor = this.processor.pipe(transform2);
            return this;
          }
        }, {
          key: "toOutput",
          value: function toOutput(output2) {
            if (this._output) {
              throw new Error("Async parser already has an output.");
            }
            this._output = output2;
            this.processor = this.processor.pipe(output2);
            return this;
          }
        }, {
          key: "promise",
          value: function promise() {
            var _this = this;
            var returnCSV = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
            return new Promise(function(resolve2, reject) {
              if (!returnCSV) {
                _this.processor.on("finish", function() {
                  return resolve2();
                }).on("error", function(err) {
                  return reject(err);
                });
                return;
              }
              var csvBuffer = [];
              _this.processor.on("data", function(chunk) {
                return csvBuffer.push(chunk.toString());
              }).on("finish", function() {
                return resolve2(fastJoin$3(csvBuffer, ""));
              }).on("error", function(err) {
                return reject(err);
              });
            });
          }
        }]);
        return JSON2CSVAsyncParser2;
      }();
      var JSON2CSVAsyncParser_1 = JSON2CSVAsyncParser;
      function flatten2() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$objects = _ref.objects, objects = _ref$objects === void 0 ? true : _ref$objects, _ref$arrays = _ref.arrays, arrays = _ref$arrays === void 0 ? false : _ref$arrays, _ref$separator = _ref.separator, separator = _ref$separator === void 0 ? "." : _ref$separator;
        function step(obj, flatDataRow, currentPath) {
          Object.keys(obj).forEach(function(key2) {
            var newPath = currentPath ? "".concat(currentPath).concat(separator).concat(key2) : key2;
            var value2 = obj[key2];
            if (objects && _typeof(value2) === "object" && value2 !== null && !Array.isArray(value2) && Object.prototype.toString.call(value2.toJSON) !== "[object Function]" && Object.keys(value2).length) {
              step(value2, flatDataRow, newPath);
              return;
            }
            if (arrays && Array.isArray(value2)) {
              step(value2, flatDataRow, newPath);
              return;
            }
            flatDataRow[newPath] = value2;
          });
          return flatDataRow;
        }
        return function(dataRow) {
          return step(dataRow, {});
        };
      }
      var flatten_1 = flatten2;
      var setProp$1 = utils.setProp, unsetProp$1 = utils.unsetProp, flattenReducer$3 = utils.flattenReducer;
      function getUnwindablePaths(obj, currentPath) {
        return Object.keys(obj).reduce(function(unwindablePaths, key2) {
          var newPath = currentPath ? "".concat(currentPath, ".").concat(key2) : key2;
          var value2 = obj[key2];
          if (_typeof(value2) === "object" && value2 !== null && !Array.isArray(value2) && Object.prototype.toString.call(value2.toJSON) !== "[object Function]" && Object.keys(value2).length) {
            unwindablePaths = unwindablePaths.concat(getUnwindablePaths(value2, newPath));
          } else if (Array.isArray(value2)) {
            unwindablePaths.push(newPath);
            unwindablePaths = unwindablePaths.concat(value2.map(function(arrObj) {
              return getUnwindablePaths(arrObj, newPath);
            }).reduce(flattenReducer$3, []).filter(function(item, index2, arr) {
              return arr.indexOf(item) !== index2;
            }));
          }
          return unwindablePaths;
        }, []);
      }
      function unwind() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$paths = _ref.paths, paths = _ref$paths === void 0 ? void 0 : _ref$paths, _ref$blankOut = _ref.blankOut, blankOut = _ref$blankOut === void 0 ? false : _ref$blankOut;
        function unwindReducer(rows, unwindPath) {
          return rows.map(function(row) {
            var unwindArray = lodash_get(row, unwindPath);
            if (!Array.isArray(unwindArray)) {
              return row;
            }
            if (!unwindArray.length) {
              return unsetProp$1(row, unwindPath);
            }
            return unwindArray.map(function(unwindRow, index2) {
              var clonedRow = blankOut && index2 > 0 ? {} : row;
              return setProp$1(clonedRow, unwindPath, unwindRow);
            });
          }).reduce(flattenReducer$3, []);
        }
        paths = Array.isArray(paths) ? paths : paths ? [paths] : void 0;
        return function(dataRow) {
          return (paths || getUnwindablePaths(dataRow)).reduce(unwindReducer, [dataRow]);
        };
      }
      var unwind_1 = unwind;
      var Readable$1 = Stream.Readable;
      var Parser$1 = JSON2CSVParser_1;
      var AsyncParser = JSON2CSVAsyncParser_1;
      var Transform$3 = JSON2CSVTransform_1;
      var parse2 = function parse3(data2, opts2) {
        return new JSON2CSVParser_1(opts2).parse(data2);
      };
      var parseAsync = function parseAsync2(data2, opts2, transformOpts) {
        try {
          if (!(data2 instanceof Readable$1)) {
            transformOpts = Object.assign({}, transformOpts, {
              objectMode: true
            });
          }
          var asyncParser = new JSON2CSVAsyncParser_1(opts2, transformOpts);
          var promise = asyncParser.promise();
          if (Array.isArray(data2)) {
            data2.forEach(function(item) {
              return asyncParser.input.push(item);
            });
            asyncParser.input.push(null);
          } else if (data2 instanceof Readable$1) {
            asyncParser.fromInput(data2);
          } else {
            asyncParser.input.push(data2);
            asyncParser.input.push(null);
          }
          return promise;
        } catch (err) {
          return Promise.reject(err);
        }
      };
      var transforms2 = {
        flatten: flatten_1,
        unwind: unwind_1
      };
      var json2csv = {
        Parser: Parser$1,
        AsyncParser,
        Transform: Transform$3,
        parse: parse2,
        parseAsync,
        transforms: transforms2
      };
      exports3.AsyncParser = AsyncParser;
      exports3.Parser = Parser$1;
      exports3.Transform = Transform$3;
      exports3.default = json2csv;
      exports3.parse = parse2;
      exports3.parseAsync = parseAsync;
      exports3.transforms = transforms2;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  })(json2csv_umd$1, json2csv_umd$1.exports);
  return json2csv_umd$1.exports;
}
requireJson2csv_umd();
const schemeRdBu = [[103, 0, 31], [178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], [247, 247, 247], [209, 229, 240], [146, 197, 222], [67, 147, 195], [33, 102, 172], [5, 48, 97]];
function rgbSpline(spline) {
  return (colors2) => {
    const n = colors2.length;
    const r2 = new Array(n);
    const g = new Array(n);
    const b2 = new Array(n);
    let i;
    let color2;
    for (i = 0; i < n; ++i) {
      color2 = [colors2[i][0], colors2[i][1], colors2[i][2]];
      r2[i] = color2[0] || 0;
      g[i] = color2[1] || 0;
      b2[i] = color2[2] || 0;
    }
    const rFunc = spline(r2);
    const gFunc = spline(g);
    const bFunc = spline(b2);
    return (t4) => [rFunc(t4), gFunc(t4), bFunc(t4)];
  };
}
function basis(values2) {
  function innerBasis(t12, v0, v1, v2, v3) {
    const t22 = t12 * t12;
    const t32 = t22 * t12;
    return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
  }
  const n = values2.length - 1;
  return (t4) => {
    const i = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n - 1) : Math.floor(t4 * n);
    const v1 = values2[i];
    const v2 = values2[i + 1];
    const v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2;
    const v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
    return innerBasis((t4 - i / n) * n, v0, v1, v2, v3);
  };
}
const interpolateRgbBasis = rgbSpline(basis);
interpolateRgbBasis(schemeRdBu);
makeStyles()(() => ({
  channelNamesLegendContainer: {
    position: "absolute",
    bottom: "0px",
    left: "0px",
    paddingLeft: "10px",
    paddingBottom: "10px"
  },
  channelNamesLegendLayer: {
    display: "flex"
  },
  channelNamesRow: {
    flexDirection: "column"
  },
  channelNamesCol: {
    flexDirection: "row"
  },
  channelNameText: {
    marginRight: "10px"
  }
}));
const EMPTY$1 = {};
function shallowEqual(a2, b2) {
  if (a2 === void 0) {
    a2 = EMPTY$1;
  }
  if (b2 === void 0) {
    b2 = EMPTY$1;
  }
  const aKeys = Object.keys(a2);
  const bKeys = Object.keys(b2);
  return a2 === b2 || aKeys.length === bKeys.length && aKeys.every((key2) => a2[key2] === b2[key2]);
}
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (b3.hasOwnProperty(p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key2) {
  return _hasOwnProperty.call(obj, key2);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys_1 = new Array(obj.length);
    for (var k = 0; k < keys_1.length; k++) {
      keys_1[k] = "" + k;
    }
    return keys_1;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys2 = [];
  for (var i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys2.push(i);
    }
  }
  return keys2;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
    case "undefined":
      return null;
    //this is how JSON.stringify behaves for array items
    default:
      return obj;
  }
}
function isInteger(str) {
  var i = 0;
  var len = str.length;
  var charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path2) {
  if (path2.indexOf("/") === -1 && path2.indexOf("~") === -1)
    return path2;
  return path2.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path2) {
  return path2.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
        if (hasUndefined(obj[i_1])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key2 in args) {
    var value2 = typeof args[key2] === "object" ? JSON.stringify(args[key2], null, 2) : args[key2];
    if (typeof value2 !== "undefined") {
      messageParts.push(key2 + ": " + value2);
    }
  }
  return messageParts.join("\n");
}
var PatchError = (
  /** @class */
  function(_super) {
    __extends(PatchError2, _super);
    function PatchError2(message, name, index2, operation, tree2) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, patchErrorMessageFormatter(message, { name, index: index2, operation, tree: tree2 })) || this;
      _this.name = name;
      _this.index = index2;
      _this.operation = operation;
      _this.tree = tree2;
      Object.setPrototypeOf(_this, _newTarget.prototype);
      _this.message = patchErrorMessageFormatter(message, { name, index: index2, operation, tree: tree2 });
      return _this;
    }
    return PatchError2;
  }(Error)
);
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key2, document2) {
    obj[key2] = this.value;
    return { newDocument: document2 };
  },
  remove: function(obj, key2, document2) {
    var removed = obj[key2];
    delete obj[key2];
    return { newDocument: document2, removed };
  },
  replace: function(obj, key2, document2) {
    var removed = obj[key2];
    obj[key2] = this.value;
    return { newDocument: document2, removed };
  },
  move: function(obj, key2, document2) {
    var removed = getValueByPointer(document2, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    var originalValue = applyOperation(document2, { op: "remove", path: this.from }).removed;
    applyOperation(document2, { op: "add", path: this.path, value: originalValue });
    return { newDocument: document2, removed };
  },
  copy: function(obj, key2, document2) {
    var valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
    return { newDocument: document2 };
  },
  test: function(obj, key2, document2) {
    return { newDocument: document2, test: _areEquals(obj[key2], this.value) };
  },
  _get: function(obj, key2, document2) {
    this.value = obj[key2];
    return { newDocument: document2 };
  }
};
var arrOps = {
  add: function(arr, i, document2) {
    if (isInteger(i)) {
      arr.splice(i, 0, this.value);
    } else {
      arr[i] = this.value;
    }
    return { newDocument: document2, index: i };
  },
  remove: function(arr, i, document2) {
    var removedList = arr.splice(i, 1);
    return { newDocument: document2, removed: removedList[0] };
  },
  replace: function(arr, i, document2) {
    var removed = arr[i];
    arr[i] = this.value;
    return { newDocument: document2, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index2) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index2 === void 0) {
    index2 = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    var path2 = operation.path || "";
    var keys2 = path2.split("/");
    var obj = document2;
    var t4 = 1;
    var len = keys2.length;
    var existingPathFragment = void 0;
    var key2 = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key2 = keys2[t4];
      if (key2 && key2.indexOf("~") != -1) {
        key2 = unescapePathComponent(key2);
      }
      if (banPrototypeModifications && (key2 == "__proto__" || key2 == "prototype" && t4 > 0 && keys2[t4 - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key2] === void 0) {
            existingPathFragment = keys2.slice(0, t4).join("/");
          } else if (t4 == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t4++;
      if (Array.isArray(obj)) {
        if (key2 === "-") {
          key2 = obj.length;
        } else {
          if (validateOperation && !isInteger(key2)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index2, operation, document2);
          } else if (isInteger(key2)) {
            key2 = ~~key2;
          }
        }
        if (t4 >= len) {
          if (validateOperation && operation.op === "add" && key2 > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index2, operation, document2);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key2, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (t4 >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key2, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key2];
      if (validateOperation && t4 < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document2);
      }
    }
  }
}
function applyPatch(document2, patch2, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch2)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  var results = new Array(patch2.length);
  for (var i = 0, length_1 = patch2.length; i < length_1; i++) {
    results[i] = applyOperation(document2, patch2[i], validateOperation, true, banPrototypeModifications, i);
    document2 = results[i].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index2) {
  var operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
  }
  return operationResult.newDocument;
}
function validator(operation, index2, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index2, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index2, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index2, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index2, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index2, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index2, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index2, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = { op: "_get", path: operation.from, value: void 0 };
      var error2 = validate([existingValue], document2);
      if (error2 && error2.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index2, operation, document2);
      }
    }
  }
}
function validate(sequence2, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence2)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence2), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence2.length; i++) {
        externalValidator(sequence2[i], i, document2, void 0);
      }
    }
  } catch (e3) {
    if (e3 instanceof JsonPatchError) {
      return e3;
    } else {
      throw e3;
    }
  }
}
function _areEquals(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    var arrA = Array.isArray(a2), arrB = Array.isArray(b2), i, length2, key2;
    if (arrA && arrB) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i = length2; i-- !== 0; )
        if (!_areEquals(a2[i], b2[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys2 = Object.keys(a2);
    length2 = keys2.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i = length2; i-- !== 0; )
      if (!b2.hasOwnProperty(keys2[i]))
        return false;
    for (i = length2; i-- !== 0; ) {
      key2 = keys2[i];
      if (!_areEquals(a2[key2], b2[key2]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
const core = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  JsonPatchError,
  _areEquals,
  applyOperation,
  applyPatch,
  applyReducer,
  deepClone,
  getValueByPointer,
  validate,
  validator
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */
var beforeDict = /* @__PURE__ */ new WeakMap();
var Mirror = (
  /** @class */
  /* @__PURE__ */ function() {
    function Mirror2(obj) {
      this.observers = /* @__PURE__ */ new Map();
      this.obj = obj;
    }
    return Mirror2;
  }()
);
var ObserverInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ObserverInfo2(callback, observer) {
      this.callback = callback;
      this.observer = observer;
    }
    return ObserverInfo2;
  }()
);
function getMirror(obj) {
  return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
function unobserve(root2, observer) {
  observer.unobserve();
}
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = function() {
      generate(observer);
    };
    var fastCheck = function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    };
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
function generate(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp2 = observer.patches;
  if (temp2.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp2);
    }
  }
  return temp2;
}
function _generate(mirror, obj, patches, path2, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var deleted = false;
  for (var t4 = oldKeys.length - 1; t4 >= 0; t4--) {
    var key2 = oldKeys[t4];
    var oldVal = mirror[key2];
    if (hasOwnProperty(obj, key2) && !(obj[key2] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key2];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path2 + "/" + escapePathComponent(key2), invertible);
      } else {
        if (oldVal !== newVal) {
          if (invertible) {
            patches.push({ op: "test", path: path2 + "/" + escapePathComponent(key2), value: _deepClone(oldVal) });
          }
          patches.push({ op: "replace", path: path2 + "/" + escapePathComponent(key2), value: _deepClone(newVal) });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({ op: "test", path: path2 + "/" + escapePathComponent(key2), value: _deepClone(oldVal) });
      }
      patches.push({ op: "remove", path: path2 + "/" + escapePathComponent(key2) });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path: path2, value: mirror });
      }
      patches.push({ op: "replace", path: path2, value: obj });
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t4 = 0; t4 < newKeys.length; t4++) {
    var key2 = newKeys[t4];
    if (!hasOwnProperty(mirror, key2) && obj[key2] !== void 0) {
      patches.push({ op: "add", path: path2 + "/" + escapePathComponent(key2), value: _deepClone(obj[key2]) });
    }
  }
}
function compare$7(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}
const duplex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: compare$7,
  generate,
  observe,
  unobserve
}, Symbol.toStringTag, { value: "Module" }));
Object.assign({}, core, duplex, {
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
});
var jsonStringifyPrettyCompact;
var hasRequiredJsonStringifyPrettyCompact;
function requireJsonStringifyPrettyCompact() {
  if (hasRequiredJsonStringifyPrettyCompact) return jsonStringifyPrettyCompact;
  hasRequiredJsonStringifyPrettyCompact = 1;
  var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;
  jsonStringifyPrettyCompact = function stringify2(passedObj, options) {
    var indent, maxLength, replacer2;
    options = options || {};
    indent = JSON.stringify(
      [1],
      void 0,
      options.indent === void 0 ? 2 : options.indent
    ).slice(2, -3);
    maxLength = indent === "" ? Infinity : options.maxLength === void 0 ? 80 : options.maxLength;
    replacer2 = options.replacer;
    return function _stringify(obj, currentIndent, reserved) {
      var end, index2, items, key2, keyPart, keys2, length2, nextIndent, prettified, start, string2, value2;
      if (obj && typeof obj.toJSON === "function") {
        obj = obj.toJSON();
      }
      string2 = JSON.stringify(obj, replacer2);
      if (string2 === void 0) {
        return string2;
      }
      length2 = maxLength - currentIndent.length - reserved;
      if (string2.length <= length2) {
        prettified = string2.replace(
          stringOrChar,
          function(match2, stringLiteral) {
            return stringLiteral || match2 + " ";
          }
        );
        if (prettified.length <= length2) {
          return prettified;
        }
      }
      if (replacer2 != null) {
        obj = JSON.parse(string2);
        replacer2 = void 0;
      }
      if (typeof obj === "object" && obj !== null) {
        nextIndent = currentIndent + indent;
        items = [];
        index2 = 0;
        if (Array.isArray(obj)) {
          start = "[";
          end = "]";
          length2 = obj.length;
          for (; index2 < length2; index2++) {
            items.push(
              _stringify(obj[index2], nextIndent, index2 === length2 - 1 ? 0 : 1) || "null"
            );
          }
        } else {
          start = "{";
          end = "}";
          keys2 = Object.keys(obj);
          length2 = keys2.length;
          for (; index2 < length2; index2++) {
            key2 = keys2[index2];
            keyPart = JSON.stringify(key2) + ": ";
            value2 = _stringify(
              obj[key2],
              nextIndent,
              keyPart.length + (index2 === length2 - 1 ? 0 : 1)
            );
            if (value2 !== void 0) {
              items.push(keyPart + value2);
            }
          }
        }
        if (items.length > 0) {
          return [start, indent + items.join(",\n" + nextIndent), end].join(
            "\n" + currentIndent
          );
        }
      }
      return string2;
    }(passedObj, "", 0);
  };
  return jsonStringifyPrettyCompact;
}
var jsonStringifyPrettyCompactExports = requireJsonStringifyPrettyCompact();
const stringify$2 = /* @__PURE__ */ getDefaultExportFromCjs(jsonStringifyPrettyCompactExports);
function adjustSpatial(item, encode2, swap2) {
  let t4;
  if (encode2.x2) {
    if (encode2.x) {
      if (swap2 && item.x > item.x2) {
        t4 = item.x;
        item.x = item.x2;
        item.x2 = t4;
      }
      item.width = item.x2 - item.x;
    } else {
      item.x = item.x2 - (item.width || 0);
    }
  }
  if (encode2.xc) {
    item.x = item.xc - (item.width || 0) / 2;
  }
  if (encode2.y2) {
    if (encode2.y) {
      if (swap2 && item.y > item.y2) {
        t4 = item.y;
        item.y = item.y2;
        item.y2 = t4;
      }
      item.height = item.y2 - item.y;
    } else {
      item.y = item.y2 - (item.height || 0);
    }
  }
  if (encode2.yc) {
    item.y = item.yc - (item.height || 0) / 2;
  }
}
var Constants = {
  NaN: NaN,
  E: Math.E,
  LN2: Math.LN2,
  LN10: Math.LN10,
  LOG2E: Math.LOG2E,
  LOG10E: Math.LOG10E,
  PI: Math.PI,
  SQRT1_2: Math.SQRT1_2,
  SQRT2: Math.SQRT2,
  MIN_VALUE: Number.MIN_VALUE,
  MAX_VALUE: Number.MAX_VALUE
};
var Ops = {
  "*": (a2, b2) => a2 * b2,
  "+": (a2, b2) => a2 + b2,
  "-": (a2, b2) => a2 - b2,
  "/": (a2, b2) => a2 / b2,
  "%": (a2, b2) => a2 % b2,
  ">": (a2, b2) => a2 > b2,
  "<": (a2, b2) => a2 < b2,
  "<=": (a2, b2) => a2 <= b2,
  ">=": (a2, b2) => a2 >= b2,
  "==": (a2, b2) => a2 == b2,
  "!=": (a2, b2) => a2 != b2,
  "===": (a2, b2) => a2 === b2,
  "!==": (a2, b2) => a2 !== b2,
  "&": (a2, b2) => a2 & b2,
  "|": (a2, b2) => a2 | b2,
  "^": (a2, b2) => a2 ^ b2,
  "<<": (a2, b2) => a2 << b2,
  ">>": (a2, b2) => a2 >> b2,
  ">>>": (a2, b2) => a2 >>> b2
};
var Unary = {
  "+": (a2) => +a2,
  "-": (a2) => -a2,
  "~": (a2) => ~a2,
  "!": (a2) => !a2
};
const slice = Array.prototype.slice;
const apply = (m2, args, cast) => {
  const obj = cast ? cast(args[0]) : args[0];
  return obj[m2].apply(obj, slice.call(args, 1));
};
const datetime = (y2, m2, d, H, M2, S, ms) => new Date(y2, m2 || 0, d != null ? d : 1, H || 0, M2 || 0, S || 0, ms || 0);
var Functions = {
  // math functions
  isNaN: Number.isNaN,
  isFinite: Number.isFinite,
  abs: Math.abs,
  acos: Math.acos,
  asin: Math.asin,
  atan: Math.atan,
  atan2: Math.atan2,
  ceil: Math.ceil,
  cos: Math.cos,
  exp: Math.exp,
  floor: Math.floor,
  log: Math.log,
  max: Math.max,
  min: Math.min,
  pow: Math.pow,
  random: Math.random,
  round: Math.round,
  sin: Math.sin,
  sqrt: Math.sqrt,
  tan: Math.tan,
  clamp: (a2, b2, c2) => Math.max(b2, Math.min(c2, a2)),
  // date functions
  now: Date.now,
  utc: Date.UTC,
  datetime,
  date: (d) => new Date(d).getDate(),
  day: (d) => new Date(d).getDay(),
  year: (d) => new Date(d).getFullYear(),
  month: (d) => new Date(d).getMonth(),
  hours: (d) => new Date(d).getHours(),
  minutes: (d) => new Date(d).getMinutes(),
  seconds: (d) => new Date(d).getSeconds(),
  milliseconds: (d) => new Date(d).getMilliseconds(),
  time: (d) => new Date(d).getTime(),
  timezoneoffset: (d) => new Date(d).getTimezoneOffset(),
  utcdate: (d) => new Date(d).getUTCDate(),
  utcday: (d) => new Date(d).getUTCDay(),
  utcyear: (d) => new Date(d).getUTCFullYear(),
  utcmonth: (d) => new Date(d).getUTCMonth(),
  utchours: (d) => new Date(d).getUTCHours(),
  utcminutes: (d) => new Date(d).getUTCMinutes(),
  utcseconds: (d) => new Date(d).getUTCSeconds(),
  utcmilliseconds: (d) => new Date(d).getUTCMilliseconds(),
  // sequence functions
  length: (x2) => x2.length,
  join: function() {
    return apply("join", arguments);
  },
  indexof: function() {
    return apply("indexOf", arguments);
  },
  lastindexof: function() {
    return apply("lastIndexOf", arguments);
  },
  slice: function() {
    return apply("slice", arguments);
  },
  reverse: (x2) => x2.slice().reverse(),
  // string functions
  parseFloat,
  parseInt,
  upper: (x2) => String(x2).toUpperCase(),
  lower: (x2) => String(x2).toLowerCase(),
  substring: function() {
    return apply("substring", arguments, String);
  },
  split: function() {
    return apply("split", arguments, String);
  },
  replace: function() {
    return apply("replace", arguments, String);
  },
  trim: (x2) => String(x2).trim(),
  // regexp functions
  regexp: RegExp,
  test: (r2, t4) => RegExp(r2).test(t4)
};
const EventFunctions = ["view", "item", "group", "xy", "x", "y"];
const Visitors = {
  Literal: ($2, n) => n.value,
  Identifier: ($2, n) => {
    const id2 = n.name;
    return $2.memberDepth > 0 ? id2 : id2 === "datum" ? $2.datum : id2 === "event" ? $2.event : id2 === "item" ? $2.item : Constants[id2] || $2.params["$" + id2];
  },
  MemberExpression: ($2, n) => {
    const d = !n.computed, o = $2(n.object);
    if (d) $2.memberDepth += 1;
    const p = $2(n.property);
    if (d) $2.memberDepth -= 1;
    return o[p];
  },
  CallExpression: ($2, n) => {
    const args = n.arguments;
    let name = n.callee.name;
    if (name.startsWith("_")) {
      name = name.slice(1);
    }
    return name === "if" ? $2(args[0]) ? $2(args[1]) : $2(args[2]) : ($2.fn[name] || Functions[name]).apply($2.fn, args.map($2));
  },
  ArrayExpression: ($2, n) => n.elements.map($2),
  BinaryExpression: ($2, n) => Ops[n.operator]($2(n.left), $2(n.right)),
  UnaryExpression: ($2, n) => Unary[n.operator]($2(n.argument)),
  ConditionalExpression: ($2, n) => $2(n.test) ? $2(n.consequent) : $2(n.alternate),
  LogicalExpression: ($2, n) => n.operator === "&&" ? $2(n.left) && $2(n.right) : $2(n.left) || $2(n.right),
  ObjectExpression: ($2, n) => n.properties.reduce((o, p) => {
    $2.memberDepth += 1;
    const k = $2(p.key);
    $2.memberDepth -= 1;
    o[k] = $2(p.value);
    return o;
  }, {})
};
function interpret(ast, fn, params2, datum2, event2, item) {
  const $2 = (n) => Visitors[n.type]($2, n);
  $2.memberDepth = 0;
  $2.fn = Object.create(fn);
  $2.params = params2;
  $2.datum = datum2;
  $2.event = event2;
  $2.item = item;
  EventFunctions.forEach((f) => $2.fn[f] = (...args) => event2.vega[f](...args));
  return $2(ast);
}
var expression$1 = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (_) => interpret(ast, fn, _);
  },
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (datum2, _) => interpret(ast, fn, _, datum2);
  },
  /**
   * Parse an expression applied to an event stream.
   */
  event(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (event2) => interpret(ast, fn, void 0, void 0, event2);
  },
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (_, event2) => {
      const datum2 = event2.item && event2.item.datum;
      return interpret(ast, fn, _, datum2, event2);
    };
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode(ctx, encode2) {
    const {
      marktype,
      channels
    } = encode2, fn = ctx.functions, swap2 = marktype === "group" || marktype === "image" || marktype === "rect";
    return (item, _) => {
      const datum2 = item.datum;
      let m2 = 0, v;
      for (const name in channels) {
        v = interpret(channels[name].ast, fn, _, datum2, void 0, item);
        if (item[name] !== v) {
          item[name] = v;
          m2 = 1;
        }
      }
      if (marktype !== "rule") {
        adjustSpatial(item, channels, swap2);
      }
      return m2;
    };
  }
};
const version$3 = "5.2.0";
const pkg$1 = {
  version: version$3
};
Array.prototype.flat || Object.defineProperty(Array.prototype, "flat", { configurable: true, value: function r() {
  var t4 = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
  return t4 ? Array.prototype.reduce.call(this, function(a2, e3) {
    return Array.isArray(e3) ? a2.push.apply(a2, r.call(e3, t4 - 1)) : a2.push(e3), a2;
  }, []) : Array.prototype.slice.call(this);
}, writable: true }), Array.prototype.flatMap || Object.defineProperty(Array.prototype, "flatMap", { configurable: true, value: function(r2) {
  return Array.prototype.map.apply(this, arguments).flat();
}, writable: true });
var clone = { exports: {} };
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone.exports;
  hasRequiredClone = 1;
  (function(module2) {
    var clone2 = function() {
      function _instanceof(obj, type2) {
        return type2 != null && obj instanceof type2;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone3(parent, circular, depth, prototype2, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype2 = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve2, reject) {
              parent2.then(function(value2) {
                resolve2(_clone(value2, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone3.__isArray(parent2)) {
            child = [];
          } else if (clone3.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone3.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype2 == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype2);
              proto = prototype2;
            }
          }
          if (circular) {
            var index2 = allParents.indexOf(parent2);
            if (index2 != -1) {
              return allChildren[index2];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value2, key2) {
              var keyChild = _clone(key2, depth2 - 1);
              var valueChild = _clone(value2, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value2) {
              var entryChild = _clone(value2, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols2 = Object.getOwnPropertySymbols(parent2);
            for (var i = 0; i < symbols2.length; i++) {
              var symbol2 = symbols2[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol2);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol2] = _clone(parent2[symbol2], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol2, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i = 0; i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone3.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c2 = function() {
        };
        c2.prototype = parent;
        return new c2();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone3.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone3.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone3.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone3.__isRegExp = __isRegExp;
      function __getRegExpFlags(re2) {
        var flags = "";
        if (re2.global) flags += "g";
        if (re2.ignoreCase) flags += "i";
        if (re2.multiline) flags += "m";
        return flags;
      }
      clone3.__getRegExpFlags = __getRegExpFlags;
      return clone3;
    }();
    if (module2.exports) {
      module2.exports = clone2;
    }
  })(clone);
  return clone.exports;
}
var cloneExports = requireClone();
const clone_ = /* @__PURE__ */ getDefaultExportFromCjs(cloneExports);
var fastDeepEqual;
var hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
  if (hasRequiredFastDeepEqual) return fastDeepEqual;
  hasRequiredFastDeepEqual = 1;
  fastDeepEqual = function equal2(a2, b2) {
    if (a2 === b2) return true;
    if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
      if (a2.constructor !== b2.constructor) return false;
      var length2, i, keys2;
      if (Array.isArray(a2)) {
        length2 = a2.length;
        if (length2 != b2.length) return false;
        for (i = length2; i-- !== 0; )
          if (!equal2(a2[i], b2[i])) return false;
        return true;
      }
      if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
      if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
      if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
      keys2 = Object.keys(a2);
      length2 = keys2.length;
      if (length2 !== Object.keys(b2).length) return false;
      for (i = length2; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b2, keys2[i])) return false;
      for (i = length2; i-- !== 0; ) {
        var key2 = keys2[i];
        if (!equal2(a2[key2], b2[key2])) return false;
      }
      return true;
    }
    return a2 !== a2 && b2 !== b2;
  };
  return fastDeepEqual;
}
var fastDeepEqualExports = requireFastDeepEqual();
const equal = /* @__PURE__ */ getDefaultExportFromCjs(fastDeepEqualExports);
var fastJsonStableStringify;
var hasRequiredFastJsonStableStringify;
function requireFastJsonStableStringify() {
  if (hasRequiredFastJsonStableStringify) return fastJsonStableStringify;
  hasRequiredFastJsonStableStringify = 1;
  fastJsonStableStringify = function(data2, opts2) {
    if (!opts2) opts2 = {};
    if (typeof opts2 === "function") opts2 = { cmp: opts2 };
    var cycles = typeof opts2.cycles === "boolean" ? opts2.cycles : false;
    var cmp2 = opts2.cmp && /* @__PURE__ */ function(f) {
      return function(node2) {
        return function(a2, b2) {
          var aobj = { key: a2, value: node2[a2] };
          var bobj = { key: b2, value: node2[b2] };
          return f(aobj, bobj);
        };
      };
    }(opts2.cmp);
    var seen = [];
    return function stringify2(node2) {
      if (node2 && node2.toJSON && typeof node2.toJSON === "function") {
        node2 = node2.toJSON();
      }
      if (node2 === void 0) return;
      if (typeof node2 == "number") return isFinite(node2) ? "" + node2 : "null";
      if (typeof node2 !== "object") return JSON.stringify(node2);
      var i, out;
      if (Array.isArray(node2)) {
        out = "[";
        for (i = 0; i < node2.length; i++) {
          if (i) out += ",";
          out += stringify2(node2[i]) || "null";
        }
        return out + "]";
      }
      if (node2 === null) return "null";
      if (seen.indexOf(node2) !== -1) {
        if (cycles) return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var seenIndex = seen.push(node2) - 1;
      var keys2 = Object.keys(node2).sort(cmp2 && cmp2(node2));
      out = "";
      for (i = 0; i < keys2.length; i++) {
        var key2 = keys2[i];
        var value2 = stringify2(node2[key2]);
        if (!value2) continue;
        if (out) out += ",";
        out += JSON.stringify(key2) + ":" + value2;
      }
      seen.splice(seenIndex, 1);
      return "{" + out + "}";
    }(data2);
  };
  return fastJsonStableStringify;
}
var fastJsonStableStringifyExports = requireFastJsonStableStringify();
const stableStringify = /* @__PURE__ */ getDefaultExportFromCjs(fastJsonStableStringifyExports);
function isLogicalOr(op) {
  return !!op.or;
}
function isLogicalAnd(op) {
  return !!op.and;
}
function isLogicalNot(op) {
  return !!op.not;
}
function forEachLeaf(op, fn) {
  if (isLogicalNot(op)) {
    forEachLeaf(op.not, fn);
  } else if (isLogicalAnd(op)) {
    for (const subop of op.and) {
      forEachLeaf(subop, fn);
    }
  } else if (isLogicalOr(op)) {
    for (const subop of op.or) {
      forEachLeaf(subop, fn);
    }
  } else {
    fn(op);
  }
}
function normalizeLogicalComposition(op, normalizer) {
  if (isLogicalNot(op)) {
    return { not: normalizeLogicalComposition(op.not, normalizer) };
  } else if (isLogicalAnd(op)) {
    return { and: op.and.map((o) => normalizeLogicalComposition(o, normalizer)) };
  } else if (isLogicalOr(op)) {
    return { or: op.or.map((o) => normalizeLogicalComposition(o, normalizer)) };
  } else {
    return normalizer(op);
  }
}
const deepEqual = equal;
const duplicate = clone_;
function never(message) {
  throw new Error(message);
}
function pick(obj, props) {
  const copy2 = {};
  for (const prop of props) {
    if (has$2(obj, prop)) {
      copy2[prop] = obj[prop];
    }
  }
  return copy2;
}
function omit(obj, props) {
  const copy2 = Object.assign({}, obj);
  for (const prop of props) {
    delete copy2[prop];
  }
  return copy2;
}
Set.prototype["toJSON"] = function() {
  return `Set(${[...this].map((x2) => stableStringify(x2)).join(",")})`;
};
const stringify$1 = stableStringify;
function hash(a2) {
  if (isNumber$1(a2)) {
    return a2;
  }
  const str = isString(a2) ? a2 : stableStringify(a2);
  if (str.length < 250) {
    return str;
  }
  let h2 = 0;
  for (let i = 0; i < str.length; i++) {
    const char2 = str.charCodeAt(i);
    h2 = (h2 << 5) - h2 + char2;
    h2 = h2 & h2;
  }
  return h2;
}
function isNullOrFalse(x2) {
  return x2 === false || x2 === null;
}
function contains(array2, item) {
  return array2.includes(item);
}
function some(arr, f) {
  let i = 0;
  for (const [k, a2] of arr.entries()) {
    if (f(a2, k, i++)) {
      return true;
    }
  }
  return false;
}
function every(arr, f) {
  let i = 0;
  for (const [k, a2] of arr.entries()) {
    if (!f(a2, k, i++)) {
      return false;
    }
  }
  return true;
}
function mergeDeep$1(dest, ...src) {
  for (const s of src) {
    deepMerge_$1(dest, s !== null && s !== void 0 ? s : {});
  }
  return dest;
}
function deepMerge_$1(dest, src) {
  for (const property2 of keys$1(src)) {
    writeConfig(dest, property2, src[property2], true);
  }
}
function unique(values2, f) {
  const results = [];
  const u2 = {};
  let v;
  for (const val of values2) {
    v = f(val);
    if (v in u2) {
      continue;
    }
    u2[v] = 1;
    results.push(val);
  }
  return results;
}
function isEqual(dict, other) {
  const dictKeys = keys$1(dict);
  const otherKeys = keys$1(other);
  if (dictKeys.length !== otherKeys.length) {
    return false;
  }
  for (const key2 of dictKeys) {
    if (dict[key2] !== other[key2]) {
      return false;
    }
  }
  return true;
}
function setEqual(a2, b2) {
  if (a2.size !== b2.size) {
    return false;
  }
  for (const e3 of a2) {
    if (!b2.has(e3)) {
      return false;
    }
  }
  return true;
}
function hasIntersection(a2, b2) {
  for (const key2 of a2) {
    if (b2.has(key2)) {
      return true;
    }
  }
  return false;
}
function prefixGenerator(a2) {
  const prefixes2 = /* @__PURE__ */ new Set();
  for (const x2 of a2) {
    const splitField = splitAccessPath(x2);
    const wrappedWithAccessors = splitField.map((y2, i) => i === 0 ? y2 : `[${y2}]`);
    const computedPrefixes = wrappedWithAccessors.map((_, i) => wrappedWithAccessors.slice(0, i + 1).join(""));
    for (const y2 of computedPrefixes) {
      prefixes2.add(y2);
    }
  }
  return prefixes2;
}
function fieldIntersection(a2, b2) {
  if (a2 === void 0 || b2 === void 0) {
    return true;
  }
  return hasIntersection(prefixGenerator(a2), prefixGenerator(b2));
}
function isEmpty(obj) {
  return keys$1(obj).length === 0;
}
const keys$1 = Object.keys;
const vals = Object.values;
const entries$1 = Object.entries;
function isBoolean(b2) {
  return b2 === true || b2 === false;
}
function varName(s) {
  const alphanumericS = s.replace(/\W/g, "_");
  return (s.match(/^\d+/) ? "_" : "") + alphanumericS;
}
function logicalExpr(op, cb) {
  if (isLogicalNot(op)) {
    return `!(${logicalExpr(op.not, cb)})`;
  } else if (isLogicalAnd(op)) {
    return `(${op.and.map((and) => logicalExpr(and, cb)).join(") && (")})`;
  } else if (isLogicalOr(op)) {
    return `(${op.or.map((or2) => logicalExpr(or2, cb)).join(") || (")})`;
  } else {
    return cb(op);
  }
}
function deleteNestedProperty(obj, orderedProps) {
  if (orderedProps.length === 0) {
    return true;
  }
  const prop = orderedProps.shift();
  if (prop in obj && deleteNestedProperty(obj[prop], orderedProps)) {
    delete obj[prop];
  }
  return isEmpty(obj);
}
function titleCase(s) {
  return s.charAt(0).toUpperCase() + s.substr(1);
}
function accessPathWithDatum(path2, datum2 = "datum") {
  const pieces = splitAccessPath(path2);
  const prefixes2 = [];
  for (let i = 1; i <= pieces.length; i++) {
    const prefix2 = `[${pieces.slice(0, i).map($).join("][")}]`;
    prefixes2.push(`${datum2}${prefix2}`);
  }
  return prefixes2.join(" && ");
}
function flatAccessWithDatum(path2, datum2 = "datum") {
  return `${datum2}[${$(splitAccessPath(path2).join("."))}]`;
}
function escapePathAccess(string2) {
  return string2.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function replacePathInField(path2) {
  return `${splitAccessPath(path2).map(escapePathAccess).join("\\.")}`;
}
function replaceAll(string2, find2, replacement) {
  return string2.replace(new RegExp(find2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), replacement);
}
function removePathFromField(path2) {
  return `${splitAccessPath(path2).join(".")}`;
}
function accessPathDepth(path2) {
  if (!path2) {
    return 0;
  }
  return splitAccessPath(path2).length;
}
function getFirstDefined(...args) {
  for (const arg of args) {
    if (arg !== void 0) {
      return arg;
    }
  }
  return void 0;
}
let idCounter = 42;
function uniqueId(prefix2) {
  const id2 = ++idCounter;
  return prefix2 ? String(prefix2) + id2 : id2;
}
function resetIdCounter() {
  idCounter = 42;
}
function internalField(name) {
  return isInternalField(name) ? name : `__${name}`;
}
function isInternalField(name) {
  return name.startsWith("__");
}
function normalizeAngle(angle2) {
  if (angle2 === void 0) {
    return void 0;
  }
  return (angle2 % 360 + 360) % 360;
}
function isNumeric(value2) {
  if (isNumber$1(value2)) {
    return true;
  }
  return !isNaN(value2) && !isNaN(parseFloat(value2));
}
var __rest$w = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
const ROW = "row";
const COLUMN = "column";
const FACET = "facet";
const X = "x";
const Y = "y";
const X2 = "x2";
const Y2 = "y2";
const XOFFSET = "xOffset";
const YOFFSET = "yOffset";
const RADIUS = "radius";
const RADIUS2 = "radius2";
const THETA = "theta";
const THETA2 = "theta2";
const LATITUDE = "latitude";
const LONGITUDE = "longitude";
const LATITUDE2 = "latitude2";
const LONGITUDE2 = "longitude2";
const COLOR = "color";
const FILL = "fill";
const STROKE = "stroke";
const SHAPE = "shape";
const SIZE = "size";
const ANGLE = "angle";
const OPACITY = "opacity";
const FILLOPACITY = "fillOpacity";
const STROKEOPACITY = "strokeOpacity";
const STROKEWIDTH = "strokeWidth";
const STROKEDASH = "strokeDash";
const TEXT$1 = "text";
const ORDER = "order";
const DETAIL = "detail";
const KEY = "key";
const TOOLTIP = "tooltip";
const HREF = "href";
const URL$1 = "url";
const DESCRIPTION = "description";
const POSITION_CHANNEL_INDEX = {
  x: 1,
  y: 1,
  x2: 1,
  y2: 1
};
const POLAR_POSITION_CHANNEL_INDEX = {
  theta: 1,
  theta2: 1,
  radius: 1,
  radius2: 1
};
function isPolarPositionChannel(c2) {
  return c2 in POLAR_POSITION_CHANNEL_INDEX;
}
const GEO_POSIITON_CHANNEL_INDEX = {
  longitude: 1,
  longitude2: 1,
  latitude: 1,
  latitude2: 1
};
function getPositionChannelFromLatLong(channel) {
  switch (channel) {
    case LATITUDE:
      return "y";
    case LATITUDE2:
      return "y2";
    case LONGITUDE:
      return "x";
    case LONGITUDE2:
      return "x2";
  }
}
function isGeoPositionChannel(c2) {
  return c2 in GEO_POSIITON_CHANNEL_INDEX;
}
const GEOPOSITION_CHANNELS = keys$1(GEO_POSIITON_CHANNEL_INDEX);
const UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), POLAR_POSITION_CHANNEL_INDEX), GEO_POSIITON_CHANNEL_INDEX), {
  xOffset: 1,
  yOffset: 1,
  // color
  color: 1,
  fill: 1,
  stroke: 1,
  // other non-position with scale
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
  strokeDash: 1,
  size: 1,
  angle: 1,
  shape: 1,
  // channels without scales
  order: 1,
  text: 1,
  detail: 1,
  key: 1,
  tooltip: 1,
  href: 1,
  url: 1,
  description: 1
});
function isColorChannel(channel) {
  return channel === COLOR || channel === FILL || channel === STROKE;
}
const FACET_CHANNEL_INDEX = {
  row: 1,
  column: 1,
  facet: 1
};
const FACET_CHANNELS = keys$1(FACET_CHANNEL_INDEX);
const CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);
const CHANNELS = keys$1(CHANNEL_INDEX);
const { order: _o, detail: _d, tooltip: _tt1 } = CHANNEL_INDEX, SINGLE_DEF_CHANNEL_INDEX = __rest$w(CHANNEL_INDEX, ["order", "detail", "tooltip"]);
const { row: _r, column: _c, facet: _f } = SINGLE_DEF_CHANNEL_INDEX, SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest$w(SINGLE_DEF_CHANNEL_INDEX, ["row", "column", "facet"]);
function isSingleDefUnitChannel(str) {
  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];
}
function isChannel(str) {
  return !!CHANNEL_INDEX[str];
}
const SECONDARY_RANGE_CHANNEL = [X2, Y2, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];
function isSecondaryRangeChannel(c2) {
  const main2 = getMainRangeChannel(c2);
  return main2 !== c2;
}
function getMainRangeChannel(channel) {
  switch (channel) {
    case X2:
      return X;
    case Y2:
      return Y;
    case LATITUDE2:
      return LATITUDE;
    case LONGITUDE2:
      return LONGITUDE;
    case THETA2:
      return THETA;
    case RADIUS2:
      return RADIUS;
  }
  return channel;
}
function getVgPositionChannel(channel) {
  if (isPolarPositionChannel(channel)) {
    switch (channel) {
      case THETA:
        return "startAngle";
      case THETA2:
        return "endAngle";
      case RADIUS:
        return "outerRadius";
      case RADIUS2:
        return "innerRadius";
    }
  }
  return channel;
}
function getSecondaryRangeChannel(channel) {
  switch (channel) {
    case X:
      return X2;
    case Y:
      return Y2;
    case LATITUDE:
      return LATITUDE2;
    case LONGITUDE:
      return LONGITUDE2;
    case THETA:
      return THETA2;
    case RADIUS:
      return RADIUS2;
  }
  return void 0;
}
function getSizeChannel(channel) {
  switch (channel) {
    case X:
    case X2:
      return "width";
    case Y:
    case Y2:
      return "height";
  }
  return void 0;
}
function getOffsetChannel(channel) {
  switch (channel) {
    case X:
      return "xOffset";
    case Y:
      return "yOffset";
    case X2:
      return "x2Offset";
    case Y2:
      return "y2Offset";
    case THETA:
      return "thetaOffset";
    case RADIUS:
      return "radiusOffset";
    case THETA2:
      return "theta2Offset";
    case RADIUS2:
      return "radius2Offset";
  }
  return void 0;
}
function getOffsetScaleChannel(channel) {
  switch (channel) {
    case X:
      return "xOffset";
    case Y:
      return "yOffset";
  }
  return void 0;
}
function getMainChannelFromOffsetChannel(channel) {
  switch (channel) {
    case "xOffset":
      return "x";
    case "yOffset":
      return "y";
  }
}
const UNIT_CHANNELS = keys$1(UNIT_CHANNEL_INDEX);
const {
  x: _x,
  y: _y,
  // x2 and y2 share the same scale as x and y
  x2: _x2,
  y2: _y2,
  //
  xOffset: _xo,
  yOffset: _yo,
  latitude: _latitude,
  longitude: _longitude,
  latitude2: _latitude2,
  longitude2: _longitude2,
  theta: _theta,
  theta2: _theta2,
  radius: _radius,
  radius2: _radius2
} = UNIT_CHANNEL_INDEX, NONPOSITION_CHANNEL_INDEX = __rest$w(UNIT_CHANNEL_INDEX, ["x", "y", "x2", "y2", "xOffset", "yOffset", "latitude", "longitude", "latitude2", "longitude2", "theta", "theta2", "radius", "radius2"]);
const NONPOSITION_CHANNELS = keys$1(NONPOSITION_CHANNEL_INDEX);
const POSITION_SCALE_CHANNEL_INDEX = {
  x: 1,
  y: 1
};
const POSITION_SCALE_CHANNELS = keys$1(POSITION_SCALE_CHANNEL_INDEX);
function isXorY(channel) {
  return channel in POSITION_SCALE_CHANNEL_INDEX;
}
const POLAR_POSITION_SCALE_CHANNEL_INDEX = {
  theta: 1,
  radius: 1
};
const POLAR_POSITION_SCALE_CHANNELS = keys$1(POLAR_POSITION_SCALE_CHANNEL_INDEX);
function getPositionScaleChannel(sizeType) {
  return sizeType === "width" ? X : Y;
}
const OFFSET_SCALE_CHANNEL_INDEX = { xOffset: 1, yOffset: 1 };
function isXorYOffset(channel) {
  return channel in OFFSET_SCALE_CHANNEL_INDEX;
}
const {
  // x2 and y2 share the same scale as x and y
  // text and tooltip have format instead of scale,
  // href has neither format, nor scale
  text: _t,
  tooltip: _tt,
  href: _hr,
  url: _u,
  description: _al,
  // detail and order have no scale
  detail: _dd,
  key: _k,
  order: _oo
} = NONPOSITION_CHANNEL_INDEX, NONPOSITION_SCALE_CHANNEL_INDEX = __rest$w(NONPOSITION_CHANNEL_INDEX, ["text", "tooltip", "href", "url", "description", "detail", "key", "order"]);
const NONPOSITION_SCALE_CHANNELS = keys$1(NONPOSITION_SCALE_CHANNEL_INDEX);
function isNonPositionScaleChannel(channel) {
  return !!NONPOSITION_CHANNEL_INDEX[channel];
}
function supportLegend(channel) {
  switch (channel) {
    case COLOR:
    case FILL:
    case STROKE:
    case SIZE:
    case SHAPE:
    case OPACITY:
    case STROKEWIDTH:
    case STROKEDASH:
      return true;
    case FILLOPACITY:
    case STROKEOPACITY:
    case ANGLE:
      return false;
  }
}
const SCALE_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), POLAR_POSITION_SCALE_CHANNEL_INDEX), OFFSET_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);
const SCALE_CHANNELS = keys$1(SCALE_CHANNEL_INDEX);
function isScaleChannel(channel) {
  return !!SCALE_CHANNEL_INDEX[channel];
}
function supportMark(channel, mark2) {
  return getSupportedMark(channel)[mark2];
}
const ALL_MARKS = {
  // all marks
  arc: "always",
  area: "always",
  bar: "always",
  circle: "always",
  geoshape: "always",
  image: "always",
  line: "always",
  rule: "always",
  point: "always",
  rect: "always",
  square: "always",
  trail: "always",
  text: "always",
  tick: "always"
};
const { geoshape: _g } = ALL_MARKS, ALL_MARKS_EXCEPT_GEOSHAPE = __rest$w(ALL_MARKS, ["geoshape"]);
function getSupportedMark(channel) {
  switch (channel) {
    case COLOR:
    case FILL:
    case STROKE:
    // falls through
    case DESCRIPTION:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case ORDER:
    // TODO: revise (order might not support rect, which is not stackable?)
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    // falls through
    case FACET:
    case ROW:
    // falls through
    case COLUMN:
      return ALL_MARKS;
    case X:
    case Y:
    case XOFFSET:
    case YOFFSET:
    case LATITUDE:
    case LONGITUDE:
      return ALL_MARKS_EXCEPT_GEOSHAPE;
    case X2:
    case Y2:
    case LATITUDE2:
    case LONGITUDE2:
      return {
        area: "always",
        bar: "always",
        image: "always",
        rect: "always",
        rule: "always",
        circle: "binned",
        point: "binned",
        square: "binned",
        tick: "binned",
        line: "binned",
        trail: "binned"
      };
    case SIZE:
      return {
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        text: "always",
        line: "always",
        trail: "always"
      };
    case STROKEDASH:
      return {
        line: "always",
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        geoshape: "always"
      };
    case SHAPE:
      return { point: "always", geoshape: "always" };
    case TEXT$1:
      return { text: "always" };
    case ANGLE:
      return { point: "always", square: "always", text: "always" };
    case URL$1:
      return { image: "always" };
    case THETA:
      return { text: "always", arc: "always" };
    case RADIUS:
      return { text: "always", arc: "always" };
    case THETA2:
    case RADIUS2:
      return { arc: "always" };
  }
}
function rangeType(channel) {
  switch (channel) {
    case X:
    case Y:
    case THETA:
    case RADIUS:
    case XOFFSET:
    case YOFFSET:
    case SIZE:
    case ANGLE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]
    case X2:
    case Y2:
    case THETA2:
    case RADIUS2:
      return void 0;
    case FACET:
    case ROW:
    case COLUMN:
    case SHAPE:
    case STROKEDASH:
    // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]
    case TEXT$1:
    case TOOLTIP:
    case HREF:
    case URL$1:
    case DESCRIPTION:
      return "discrete";
    // Color can be either continuous or discrete, depending on scale type.
    case COLOR:
    case FILL:
    case STROKE:
      return "flexible";
    // No scale, no range type.
    case LATITUDE:
    case LONGITUDE:
    case LATITUDE2:
    case LONGITUDE2:
    case DETAIL:
    case KEY:
    case ORDER:
      return void 0;
  }
}
const AGGREGATE_OP_INDEX = {
  argmax: 1,
  argmin: 1,
  average: 1,
  count: 1,
  distinct: 1,
  product: 1,
  max: 1,
  mean: 1,
  median: 1,
  min: 1,
  missing: 1,
  q1: 1,
  q3: 1,
  ci0: 1,
  ci1: 1,
  stderr: 1,
  stdev: 1,
  stdevp: 1,
  sum: 1,
  valid: 1,
  values: 1,
  variance: 1,
  variancep: 1
};
const MULTIDOMAIN_SORT_OP_INDEX = {
  count: 1,
  min: 1,
  max: 1
};
function isArgminDef(a2) {
  return !!a2 && !!a2["argmin"];
}
function isArgmaxDef(a2) {
  return !!a2 && !!a2["argmax"];
}
function isAggregateOp(a2) {
  return isString(a2) && !!AGGREGATE_OP_INDEX[a2];
}
const COUNTING_OPS = /* @__PURE__ */ new Set([
  "count",
  "valid",
  "missing",
  "distinct"
]);
function isCountingAggregateOp(aggregate) {
  return isString(aggregate) && COUNTING_OPS.has(aggregate);
}
function isMinMaxOp(aggregate) {
  return isString(aggregate) && contains(["min", "max"], aggregate);
}
const SUM_OPS = /* @__PURE__ */ new Set([
  "count",
  "sum",
  "distinct",
  "valid",
  "missing"
]);
const SHARED_DOMAIN_OPS = /* @__PURE__ */ new Set([
  "mean",
  "average",
  "median",
  "q1",
  "q3",
  "min",
  "max"
]);
function binToString(bin2) {
  if (isBoolean$2(bin2)) {
    bin2 = normalizeBin(bin2, void 0);
  }
  return "bin" + keys$1(bin2).map((p) => isParameterExtent(bin2[p]) ? varName(`_${p}_${entries$1(bin2[p])}`) : varName(`_${p}_${bin2[p]}`)).join("");
}
function isBinning(bin2) {
  return bin2 === true || isBinParams(bin2) && !bin2.binned;
}
function isBinned(bin2) {
  return bin2 === "binned" || isBinParams(bin2) && bin2.binned === true;
}
function isBinParams(bin2) {
  return isObject$1(bin2);
}
function isParameterExtent(extent2) {
  return extent2 === null || extent2 === void 0 ? void 0 : extent2["param"];
}
function autoMaxBins(channel) {
  switch (channel) {
    case ROW:
    case COLUMN:
    case SIZE:
    case COLOR:
    case FILL:
    case STROKE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    // Facets and Size shouldn't have too many bins
    // We choose 6 like shape to simplify the rule [falls through]
    case SHAPE:
      return 6;
    // Vega's "shape" has 6 distinct values
    case STROKEDASH:
      return 4;
    // We only provide 5 different stroke dash values (but 4 is more effective)
    default:
      return 10;
  }
}
function isExprRef(o) {
  return !!(o === null || o === void 0 ? void 0 : o.expr);
}
function replaceExprRef(index2) {
  const props = keys$1(index2 || {});
  const newIndex = {};
  for (const prop of props) {
    newIndex[prop] = signalRefOrValue(index2[prop]);
  }
  return newIndex;
}
var __rest$v = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function extractTitleConfig(titleConfig) {
  const {
    // These are non-mark title config that need to be hardcoded
    anchor,
    frame: frame2,
    offset: offset2,
    orient: orient2,
    angle: angle2,
    limit,
    // color needs to be redirect to fill
    color: color2,
    // subtitle properties
    subtitleColor,
    subtitleFont,
    subtitleFontSize,
    subtitleFontStyle,
    subtitleFontWeight,
    subtitleLineHeight,
    subtitlePadding
  } = titleConfig, rest = __rest$v(titleConfig, ["anchor", "frame", "offset", "orient", "angle", "limit", "color", "subtitleColor", "subtitleFont", "subtitleFontSize", "subtitleFontStyle", "subtitleFontWeight", "subtitleLineHeight", "subtitlePadding"]);
  const titleMarkConfig = Object.assign(Object.assign({}, rest), color2 ? { fill: color2 } : {});
  const nonMarkTitleProperties = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, anchor ? { anchor } : {}), frame2 ? { frame: frame2 } : {}), offset2 ? { offset: offset2 } : {}), orient2 ? { orient: orient2 } : {}), angle2 !== void 0 ? { angle: angle2 } : {}), limit !== void 0 ? { limit } : {});
  const subtitle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, subtitleColor ? { subtitleColor } : {}), subtitleFont ? { subtitleFont } : {}), subtitleFontSize ? { subtitleFontSize } : {}), subtitleFontStyle ? { subtitleFontStyle } : {}), subtitleFontWeight ? { subtitleFontWeight } : {}), subtitleLineHeight ? { subtitleLineHeight } : {}), subtitlePadding ? { subtitlePadding } : {});
  const subtitleMarkConfig = pick(titleConfig, ["align", "baseline", "dx", "dy", "limit"]);
  return { titleMarkConfig, subtitleMarkConfig, nonMarkTitleProperties, subtitle };
}
function isText(v) {
  return isString(v) || isArray$1(v) && isString(v[0]);
}
function isSignalRef(o) {
  return !!(o === null || o === void 0 ? void 0 : o.signal);
}
function isVgRangeStep(range2) {
  return !!range2["step"];
}
function isDataRefUnionedDomain(domain2) {
  if (!isArray$1(domain2)) {
    return "fields" in domain2 && !("data" in domain2);
  }
  return false;
}
function isFieldRefUnionDomain(domain2) {
  if (!isArray$1(domain2)) {
    return "fields" in domain2 && "data" in domain2;
  }
  return false;
}
function isDataRefDomain(domain2) {
  if (!isArray$1(domain2)) {
    return "field" in domain2 && "data" in domain2;
  }
  return false;
}
const VG_MARK_CONFIG_INDEX = {
  aria: 1,
  description: 1,
  ariaRole: 1,
  ariaRoleDescription: 1,
  blend: 1,
  opacity: 1,
  fill: 1,
  fillOpacity: 1,
  stroke: 1,
  strokeCap: 1,
  strokeWidth: 1,
  strokeOpacity: 1,
  strokeDash: 1,
  strokeDashOffset: 1,
  strokeJoin: 1,
  strokeOffset: 1,
  strokeMiterLimit: 1,
  startAngle: 1,
  endAngle: 1,
  padAngle: 1,
  innerRadius: 1,
  outerRadius: 1,
  size: 1,
  shape: 1,
  interpolate: 1,
  tension: 1,
  orient: 1,
  align: 1,
  baseline: 1,
  text: 1,
  dir: 1,
  dx: 1,
  dy: 1,
  ellipsis: 1,
  limit: 1,
  radius: 1,
  theta: 1,
  angle: 1,
  font: 1,
  fontSize: 1,
  fontWeight: 1,
  fontStyle: 1,
  lineBreak: 1,
  lineHeight: 1,
  cursor: 1,
  href: 1,
  tooltip: 1,
  cornerRadius: 1,
  cornerRadiusTopLeft: 1,
  cornerRadiusTopRight: 1,
  cornerRadiusBottomLeft: 1,
  cornerRadiusBottomRight: 1,
  aspect: 1,
  width: 1,
  height: 1,
  url: 1,
  smooth: 1
  // commented below are vg channel that do not have mark config.
  // x: 1,
  // y: 1,
  // x2: 1,
  // y2: 1,
  // xc'|'yc'
  // clip: 1,
  // path: 1,
  // url: 1,
};
const VG_MARK_CONFIGS = keys$1(VG_MARK_CONFIG_INDEX);
const VG_MARK_INDEX = {
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
const VG_CORNERRADIUS_CHANNELS = [
  "cornerRadius",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight"
];
var __rest$u = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function signalOrValueRefWithCondition(val) {
  const condition = isArray$1(val.condition) ? val.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(val.condition);
  return Object.assign(Object.assign({}, signalRefOrValue(val)), { condition });
}
function signalRefOrValue(value2) {
  if (isExprRef(value2)) {
    const { expr: expr2 } = value2, rest = __rest$u(value2, ["expr"]);
    return Object.assign({ signal: expr2 }, rest);
  }
  return value2;
}
function conditionalSignalRefOrValue(value2) {
  if (isExprRef(value2)) {
    const { expr: expr2 } = value2, rest = __rest$u(value2, ["expr"]);
    return Object.assign({ signal: expr2 }, rest);
  }
  return value2;
}
function signalOrValueRef(value2) {
  if (isExprRef(value2)) {
    const { expr: expr2 } = value2, rest = __rest$u(value2, ["expr"]);
    return Object.assign({ signal: expr2 }, rest);
  }
  if (isSignalRef(value2)) {
    return value2;
  }
  return value2 !== void 0 ? { value: value2 } : void 0;
}
function exprFromSignalRefOrValue(ref2) {
  if (isSignalRef(ref2)) {
    return ref2.signal;
  }
  return $(ref2);
}
function exprFromValueRefOrSignalRef(ref2) {
  if (isSignalRef(ref2)) {
    return ref2.signal;
  }
  return $(ref2.value);
}
function signalOrStringValue(v) {
  if (isSignalRef(v)) {
    return v.signal;
  }
  return v == null ? null : $(v);
}
function applyMarkConfig(e3, model, propsList) {
  for (const property2 of propsList) {
    const value2 = getMarkConfig(property2, model.markDef, model.config);
    if (value2 !== void 0) {
      e3[property2] = signalOrValueRef(value2);
    }
  }
  return e3;
}
function getStyles(mark2) {
  var _a;
  return [].concat(mark2.type, (_a = mark2.style) !== null && _a !== void 0 ? _a : []);
}
function getMarkPropOrConfig(channel, mark2, config, opt = {}) {
  const { vgChannel, ignoreVgConfig } = opt;
  if (vgChannel && mark2[vgChannel] !== void 0) {
    return mark2[vgChannel];
  } else if (mark2[channel] !== void 0) {
    return mark2[channel];
  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {
    return void 0;
  }
  return getMarkConfig(channel, mark2, config, opt);
}
function getMarkConfig(channel, mark2, config, { vgChannel } = {}) {
  return getFirstDefined(
    // style config has highest precedence
    vgChannel ? getMarkStyleConfig(channel, mark2, config.style) : void 0,
    getMarkStyleConfig(channel, mark2, config.style),
    // then mark-specific config
    vgChannel ? config[mark2.type][vgChannel] : void 0,
    config[mark2.type][channel],
    // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine
    // If there is vgChannel, skip vl channel.
    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.
    vgChannel ? config.mark[vgChannel] : config.mark[channel]
    // Need to cast for the same reason as above
  );
}
function getMarkStyleConfig(prop, mark2, styleConfigIndex) {
  return getStyleConfig(prop, getStyles(mark2), styleConfigIndex);
}
function getStyleConfig(p, styles, styleConfigIndex) {
  styles = array$5(styles);
  let value2;
  for (const style2 of styles) {
    const styleConfig = styleConfigIndex[style2];
    if (styleConfig && styleConfig[p] !== void 0) {
      value2 = styleConfig[p];
    }
  }
  return value2;
}
function sortParams(orderDef, fieldRefOption) {
  return array$5(orderDef).reduce((s, orderChannelDef) => {
    var _a;
    s.field.push(vgField(orderChannelDef, fieldRefOption));
    s.order.push((_a = orderChannelDef.sort) !== null && _a !== void 0 ? _a : "ascending");
    return s;
  }, { field: [], order: [] });
}
function mergeTitleFieldDefs(f1, f2) {
  const merged = [...f1];
  f2.forEach((fdToMerge) => {
    for (const fieldDef1 of merged) {
      if (deepEqual(fieldDef1, fdToMerge)) {
        return;
      }
    }
    merged.push(fdToMerge);
  });
  return merged;
}
function mergeTitle(title1, title2) {
  if (deepEqual(title1, title2) || !title2) {
    return title1;
  } else if (!title1) {
    return title2;
  } else {
    return [...array$5(title1), ...array$5(title2)].join(", ");
  }
}
function mergeTitleComponent(v1, v2) {
  const v1Val = v1.value;
  const v2Val = v2.value;
  if (v1Val == null || v2Val === null) {
    return {
      explicit: v1.explicit,
      value: null
    };
  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {
    return {
      explicit: v1.explicit,
      value: mergeTitle(v1Val, v2Val)
    };
  } else if (isText(v1Val) || isSignalRef(v1Val)) {
    return {
      explicit: v1.explicit,
      value: v1Val
    };
  } else if (isText(v2Val) || isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: v2Val
    };
  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: mergeTitleFieldDefs(v1Val, v2Val)
    };
  }
  throw new Error("It should never reach here");
}
function invalidSpec(spec) {
  return `Invalid specification ${stringify$1(spec)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
const FIT_NON_SINGLE = 'Autosize "fit" only works for single views and layered views.';
function containerSizeNonSingle(name) {
  const uName = name == "width" ? "Width" : "Height";
  return `${uName} "container" only works for single views and layered views.`;
}
function containerSizeNotCompatibleWithAutosize(name) {
  const uName = name == "width" ? "Width" : "Height";
  const fitDirection = name == "width" ? "x" : "y";
  return `${uName} "container" only works well with autosize "fit" or "fit-${fitDirection}".`;
}
function droppingFit(channel) {
  return channel ? `Dropping "fit-${channel}" because spec has discrete ${getSizeChannel(channel)}.` : `Dropping "fit" because spec has discrete size.`;
}
function unknownField(channel) {
  return `Unknown field for ${channel}. Cannot calculate view size.`;
}
function cannotProjectOnChannelWithoutField(channel) {
  return `Cannot project a selection on encoding channel "${channel}", which has no field.`;
}
function cannotProjectAggregate(channel, aggregate) {
  return `Cannot project a selection on encoding channel "${channel}" as it uses an aggregate function ("${aggregate}").`;
}
function nearestNotSupportForContinuous(mark2) {
  return `The "nearest" transform is not supported for ${mark2} marks.`;
}
function selectionNotSupported(mark2) {
  return `Selection not supported for ${mark2} yet.`;
}
function selectionNotFound(name) {
  return `Cannot find a selection named "${name}".`;
}
const SCALE_BINDINGS_CONTINUOUS = "Scale bindings are currently only supported for scales with unbinned, continuous domains.";
const LEGEND_BINDINGS_MUST_HAVE_PROJECTION = "Legend bindings are only supported for selections over an individual field or encoding channel.";
function cannotLookupVariableParameter(name) {
  return `Lookups can only be performed on selection parameters. "${name}" is a variable parameter.`;
}
function noSameUnitLookup(name) {
  return `Cannot define and lookup the "${name}" selection in the same view. Try moving the lookup into a second, layered view?`;
}
const NEEDS_SAME_SELECTION = "The same selection must be used to override scale domains in a layered view.";
const INTERVAL_INITIALIZED_WITH_X_Y = 'Interval selections should be initialized using "x" and/or "y" keys.';
function noSuchRepeatedValue(field2) {
  return `Unknown repeated value "${field2}".`;
}
function columnsNotSupportByRowCol(type2) {
  return `The "columns" property cannot be used when "${type2}" has nested row/column.`;
}
const CONCAT_CANNOT_SHARE_AXIS = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
function unrecognizedParse(p) {
  return `Unrecognized parse "${p}".`;
}
function differentParse(field2, local, ancestor) {
  return `An ancestor parsed field "${field2}" as ${ancestor} but a child wants to parse the field as ${local}.`;
}
const ADD_SAME_CHILD_TWICE = "Attempt to add the same child twice.";
function invalidTransformIgnored(transform2) {
  return `Ignoring an invalid transform: ${stringify$1(transform2)}.`;
}
const NO_FIELDS_NEEDS_AS = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
function customFormatTypeNotAllowed(channel) {
  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;
}
function projectionOverridden(opt) {
  const { parentProjection, projection: projection2 } = opt;
  return `Layer's shared projection ${stringify$1(parentProjection)} is overridden by a child projection ${stringify$1(projection2)}.`;
}
const REPLACE_ANGLE_WITH_THETA = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
function offsetNestedInsideContinuousPositionScaleDropped(mainChannel) {
  return `${mainChannel}Offset dropped because ${mainChannel} is continuous`;
}
function replaceOffsetWithMainChannel(mainChannel) {
  return `There is no ${mainChannel} encoding. Replacing ${mainChannel}Offset encoding as ${mainChannel}.`;
}
function primitiveChannelDef(channel, type2, value2) {
  return `Channel ${channel} is a ${type2}. Converted to {value: ${stringify$1(value2)}}.`;
}
function invalidFieldType(type2) {
  return `Invalid field type "${type2}".`;
}
function invalidFieldTypeForCountAggregate(type2, aggregate) {
  return `Invalid field type "${type2}" for aggregate: "${aggregate}", using "quantitative" instead.`;
}
function invalidAggregate(aggregate) {
  return `Invalid aggregation operator "${aggregate}".`;
}
function droppingColor(type2, opt) {
  const { fill: fill2, stroke: stroke2 } = opt;
  return `Dropping color ${type2} as the plot also has ${fill2 && stroke2 ? "fill and stroke" : fill2 ? "fill" : "stroke"}.`;
}
function relativeBandSizeNotSupported(sizeChannel) {
  return `Position range does not support relative band size for ${sizeChannel}.`;
}
function emptyFieldDef(fieldDef, channel) {
  return `Dropping ${stringify$1(fieldDef)} from channel "${channel}" since it does not contain any data field, datum, value, or signal.`;
}
const LINE_WITH_VARYING_SIZE = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
function incompatibleChannel(channel, markOrFacet, when) {
  return `${channel} dropped as it is incompatible with "${markOrFacet}"${""}.`;
}
function offsetEncodingScaleIgnored(channel) {
  return `${channel} encoding has no scale, so specified scale is ignored.`;
}
function invalidEncodingChannel(channel) {
  return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;
}
function channelShouldBeDiscrete(channel) {
  return `${channel} encoding should be discrete (ordinal / nominal / binned).`;
}
function channelShouldBeDiscreteOrDiscretizing(channel) {
  return `${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
}
function facetChannelDropped(channels) {
  return `Facet encoding dropped as ${channels.join(" and ")} ${channels.length > 1 ? "are" : "is"} also specified.`;
}
function discreteChannelCannotEncode(channel, type2) {
  return `Using discrete channel "${channel}" to encode "${type2}" field can be misleading as it does not encode ${type2 === "ordinal" ? "order" : "magnitude"}.`;
}
function rangeMarkAlignmentCannotBeExpression(align2) {
  return `The ${align2} for range marks cannot be an expression`;
}
function lineWithRange(hasX2, hasY2) {
  const channels = hasX2 && hasY2 ? "x2 and y2" : hasX2 ? "x2" : "y2";
  return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;
}
function orientOverridden(original, actual) {
  return `Specified orient "${original}" overridden with "${actual}".`;
}
function cannotUseScalePropertyWithNonColor(prop) {
  return `Cannot use the scale property "${prop}" with non-color channel.`;
}
function cannotUseRelativeBandSizeWithNonBandScale(scaleType2) {
  return `Cannot use the relative band size with ${scaleType2} scale.`;
}
function unaggregateDomainHasNoEffectForRawField(fieldDef) {
  return `Using unaggregated domain with raw field has no effect (${stringify$1(fieldDef)}).`;
}
function unaggregateDomainWithNonSharedDomainOp(aggregate) {
  return `Unaggregated domain not applicable for "${aggregate}" since it produces values outside the origin domain of the source data.`;
}
function unaggregatedDomainWithLogScale(fieldDef) {
  return `Unaggregated domain is currently unsupported for log scale (${stringify$1(fieldDef)}).`;
}
function cannotApplySizeToNonOrientedMark(mark2) {
  return `Cannot apply size to non-oriented mark "${mark2}".`;
}
function scaleTypeNotWorkWithChannel(channel, scaleType2, defaultScaleType) {
  return `Channel "${channel}" does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
}
function scaleTypeNotWorkWithFieldDef(scaleType2, defaultScaleType) {
  return `FieldDef does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
}
function scalePropertyNotWorkWithScaleType(scaleType2, propName, channel) {
  return `${channel}-scale's "${propName}" is dropped as it does not work with ${scaleType2} scale.`;
}
function stepDropped(channel) {
  return `The step for "${channel}" is dropped because the ${channel === "width" ? "x" : "y"} is continuous.`;
}
function mergeConflictingProperty(property2, propertyOf, v1, v2) {
  return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify$1(v1)} and ${stringify$1(v2)}). Using ${stringify$1(v1)}.`;
}
function mergeConflictingDomainProperty(property2, propertyOf, v1, v2) {
  return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify$1(v1)} and ${stringify$1(v2)}). Using the union of the two domains.`;
}
function independentScaleMeansIndependentGuide(channel) {
  return `Setting the scale to be independent for "${channel}" means we also have to set the guide (axis or legend) to be independent.`;
}
function domainSortDropped(sort2) {
  return `Dropping sort property ${stringify$1(sort2)} as unioned domains only support boolean or op "count", "min", and "max".`;
}
const MORE_THAN_ONE_SORT = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.";
const FACETED_INDEPENDENT_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.";
const FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.";
const FACETED_INDEPENDENT_SAME_SOURCE = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
function cannotStackRangedMark(channel) {
  return `Cannot stack "${channel}" if there is already "${channel}2".`;
}
function cannotStackNonLinearScale(scaleType2) {
  return `Cannot stack non-linear scale (${scaleType2}).`;
}
function stackNonSummativeAggregate(aggregate) {
  return `Stacking is applied even though the aggregate function is non-summative ("${aggregate}").`;
}
function invalidTimeUnit(unitName2, value2) {
  return `Invalid ${unitName2}: ${stringify$1(value2)}.`;
}
function droppedDay(d) {
  return `Dropping day from datetime ${stringify$1(d)} as day cannot be combined with other units.`;
}
function errorBarCenterAndExtentAreNotNeeded(center, extent2) {
  return `${extent2 ? "extent " : ""}${extent2 && center ? "and " : ""}${center ? "center " : ""}${extent2 && center ? "are " : "is "}not needed when data are aggregated.`;
}
function errorBarCenterIsUsedWithWrongExtent(center, extent2, mark2) {
  return `${center} is not usually used with ${extent2} for ${mark2}.`;
}
function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {
  return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;
}
function errorBand1DNotSupport(property2) {
  return `1D error band does not support ${property2}.`;
}
function channelRequiredForBinned(channel) {
  return `Channel ${channel} is required for "binned" bin.`;
}
function channelShouldNotBeUsedForBinned(channel) {
  return `Channel ${channel} should not be used with "binned" bin.`;
}
function domainRequiredForThresholdScale(channel) {
  return `Domain for ${channel} is required for threshold scale.`;
}
const main = logger(Warn);
let current = main;
function set(newLogger) {
  current = newLogger;
  return current;
}
function reset() {
  current = main;
  return current;
}
function warn(...args) {
  current.warn(...args);
}
function debug$2(...args) {
  current.debug(...args);
}
function isDateTime(o) {
  if (o && isObject$1(o)) {
    for (const part of TIMEUNIT_PARTS) {
      if (part in o) {
        return true;
      }
    }
  }
  return false;
}
const MONTHS = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
];
const SHORT_MONTHS = MONTHS.map((m2) => m2.substr(0, 3));
const DAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
const SHORT_DAYS = DAYS.map((d) => d.substr(0, 3));
function normalizeQuarter(q) {
  if (isNumeric(q)) {
    q = +q;
  }
  if (isNumber$1(q)) {
    if (q > 4) {
      warn(invalidTimeUnit("quarter", q));
    }
    return q - 1;
  } else {
    throw new Error(invalidTimeUnit("quarter", q));
  }
}
function normalizeMonth(m2) {
  if (isNumeric(m2)) {
    m2 = +m2;
  }
  if (isNumber$1(m2)) {
    return m2 - 1;
  } else {
    const lowerM = m2.toLowerCase();
    const monthIndex = MONTHS.indexOf(lowerM);
    if (monthIndex !== -1) {
      return monthIndex;
    }
    const shortM = lowerM.substr(0, 3);
    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);
    if (shortMonthIndex !== -1) {
      return shortMonthIndex;
    }
    throw new Error(invalidTimeUnit("month", m2));
  }
}
function normalizeDay(d) {
  if (isNumeric(d)) {
    d = +d;
  }
  if (isNumber$1(d)) {
    return d % 7;
  } else {
    const lowerD = d.toLowerCase();
    const dayIndex = DAYS.indexOf(lowerD);
    if (dayIndex !== -1) {
      return dayIndex;
    }
    const shortD = lowerD.substr(0, 3);
    const shortDayIndex = SHORT_DAYS.indexOf(shortD);
    if (shortDayIndex !== -1) {
      return shortDayIndex;
    }
    throw new Error(invalidTimeUnit("day", d));
  }
}
function dateTimeParts(d, normalize2) {
  const parts = [];
  if (normalize2 && d.day !== void 0) {
    if (keys$1(d).length > 1) {
      warn(droppedDay(d));
      d = duplicate(d);
      delete d.day;
    }
  }
  if (d.year !== void 0) {
    parts.push(d.year);
  } else {
    parts.push(2012);
  }
  if (d.month !== void 0) {
    const month2 = normalize2 ? normalizeMonth(d.month) : d.month;
    parts.push(month2);
  } else if (d.quarter !== void 0) {
    const quarter2 = normalize2 ? normalizeQuarter(d.quarter) : d.quarter;
    parts.push(isNumber$1(quarter2) ? quarter2 * 3 : `${quarter2}*3`);
  } else {
    parts.push(0);
  }
  if (d.date !== void 0) {
    parts.push(d.date);
  } else if (d.day !== void 0) {
    const day2 = normalize2 ? normalizeDay(d.day) : d.day;
    parts.push(isNumber$1(day2) ? day2 + 1 : `${day2}+1`);
  } else {
    parts.push(1);
  }
  for (const timeUnit of ["hours", "minutes", "seconds", "milliseconds"]) {
    const unit2 = d[timeUnit];
    parts.push(typeof unit2 === "undefined" ? 0 : unit2);
  }
  return parts;
}
function dateTimeToExpr(d) {
  const parts = dateTimeParts(d, true);
  const string2 = parts.join(", ");
  if (d.utc) {
    return `utc(${string2})`;
  } else {
    return `datetime(${string2})`;
  }
}
function dateTimeExprToExpr(d) {
  const parts = dateTimeParts(d, false);
  const string2 = parts.join(", ");
  if (d.utc) {
    return `utc(${string2})`;
  } else {
    return `datetime(${string2})`;
  }
}
function dateTimeToTimestamp(d) {
  const parts = dateTimeParts(d, true);
  if (d.utc) {
    return +new Date(Date.UTC(...parts));
  } else {
    return +new Date(...parts);
  }
}
var __rest$t = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
const LOCAL_SINGLE_TIMEUNIT_INDEX = {
  year: 1,
  quarter: 1,
  month: 1,
  week: 1,
  day: 1,
  dayofyear: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
};
const TIMEUNIT_PARTS = keys$1(LOCAL_SINGLE_TIMEUNIT_INDEX);
function isLocalSingleTimeUnit(timeUnit) {
  return !!LOCAL_SINGLE_TIMEUNIT_INDEX[timeUnit];
}
function isUTCTimeUnit(t4) {
  return t4.startsWith("utc");
}
function getLocalTimeUnit(t4) {
  return t4.substr(3);
}
const VEGALITE_TIMEFORMAT = {
  "year-month": "%b %Y ",
  "year-month-date": "%b %d, %Y "
};
function getTimeUnitParts(timeUnit) {
  return TIMEUNIT_PARTS.filter((part) => containsTimeUnit(timeUnit, part));
}
function containsTimeUnit(fullTimeUnit, timeUnit) {
  const index2 = fullTimeUnit.indexOf(timeUnit);
  if (index2 < 0) {
    return false;
  }
  if (index2 > 0 && timeUnit === "seconds" && fullTimeUnit.charAt(index2 - 1) === "i") {
    return false;
  }
  if (fullTimeUnit.length > index2 + 3 && timeUnit === "day" && fullTimeUnit.charAt(index2 + 3) === "o") {
    return false;
  }
  if (index2 > 0 && timeUnit === "year" && fullTimeUnit.charAt(index2 - 1) === "f") {
    return false;
  }
  return true;
}
function fieldExpr(fullTimeUnit, field2, { end } = { end: false }) {
  const fieldRef2 = accessPathWithDatum(field2);
  const utc = isUTCTimeUnit(fullTimeUnit) ? "utc" : "";
  function func(timeUnit) {
    if (timeUnit === "quarter") {
      return `(${utc}quarter(${fieldRef2})-1)`;
    } else {
      return `${utc}${timeUnit}(${fieldRef2})`;
    }
  }
  let lastTimeUnit;
  const dateExpr = {};
  for (const part of TIMEUNIT_PARTS) {
    if (containsTimeUnit(fullTimeUnit, part)) {
      dateExpr[part] = func(part);
      lastTimeUnit = part;
    }
  }
  if (end) {
    dateExpr[lastTimeUnit] += "+1";
  }
  return dateTimeExprToExpr(dateExpr);
}
function timeUnitSpecifierExpression(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  const timeUnitParts = getTimeUnitParts(timeUnit);
  return `timeUnitSpecifier(${stringify$1(timeUnitParts)}, ${stringify$1(VEGALITE_TIMEFORMAT)})`;
}
function formatExpression(timeUnit, field2, isUTCScale) {
  if (!timeUnit) {
    return void 0;
  }
  const expr2 = timeUnitSpecifierExpression(timeUnit);
  const utc = isUTCScale || isUTCTimeUnit(timeUnit);
  return `${utc ? "utc" : "time"}Format(${field2}, ${expr2})`;
}
function normalizeTimeUnit(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  let params2;
  if (isString(timeUnit)) {
    params2 = {
      unit: timeUnit
    };
  } else if (isObject$1(timeUnit)) {
    params2 = Object.assign(Object.assign({}, timeUnit), timeUnit.unit ? { unit: timeUnit.unit } : {});
  }
  if (isUTCTimeUnit(params2.unit)) {
    params2.utc = true;
    params2.unit = getLocalTimeUnit(params2.unit);
  }
  return params2;
}
function timeUnitToString(tu) {
  const _a = normalizeTimeUnit(tu), { utc } = _a, rest = __rest$t(_a, ["utc"]);
  if (rest.unit) {
    return (utc ? "utc" : "") + keys$1(rest).map((p) => varName(`${p === "unit" ? "" : `_${p}_`}${rest[p]}`)).join("");
  } else {
    return (utc ? "utc" : "") + "timeunit" + keys$1(rest).map((p) => varName(`_${p}_${rest[p]}`)).join("");
  }
}
function isSelectionPredicate(predicate) {
  return predicate === null || predicate === void 0 ? void 0 : predicate["param"];
}
function isFieldEqualPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.equal !== void 0;
}
function isFieldLTPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.lt !== void 0;
}
function isFieldLTEPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.lte !== void 0;
}
function isFieldGTPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.gt !== void 0;
}
function isFieldGTEPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.gte !== void 0;
}
function isFieldRangePredicate(predicate) {
  if (predicate === null || predicate === void 0 ? void 0 : predicate.field) {
    if (isArray$1(predicate.range) && predicate.range.length === 2) {
      return true;
    } else if (isSignalRef(predicate.range)) {
      return true;
    }
  }
  return false;
}
function isFieldOneOfPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && (isArray$1(predicate.oneOf) || isArray$1(predicate.in));
}
function isFieldValidPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.valid !== void 0;
}
function isFieldPredicate(predicate) {
  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);
}
function predicateValueExpr(v, timeUnit) {
  return valueExpr(v, { timeUnit, wrapTime: true });
}
function predicateValuesExpr(vals2, timeUnit) {
  return vals2.map((v) => predicateValueExpr(v, timeUnit));
}
function fieldFilterExpression(predicate, useInRange = true) {
  var _a;
  const { field: field2 } = predicate;
  const timeUnit = (_a = normalizeTimeUnit(predicate.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;
  const fieldExpr$1 = timeUnit ? (
    // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
    // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
    // TODO: support utc
    `time(${fieldExpr(timeUnit, field2)})`
  ) : vgField(predicate, { expr: "datum" });
  if (isFieldEqualPredicate(predicate)) {
    return `${fieldExpr$1}===${predicateValueExpr(predicate.equal, timeUnit)}`;
  } else if (isFieldLTPredicate(predicate)) {
    const upper = predicate.lt;
    return `${fieldExpr$1}<${predicateValueExpr(upper, timeUnit)}`;
  } else if (isFieldGTPredicate(predicate)) {
    const lower = predicate.gt;
    return `${fieldExpr$1}>${predicateValueExpr(lower, timeUnit)}`;
  } else if (isFieldLTEPredicate(predicate)) {
    const upper = predicate.lte;
    return `${fieldExpr$1}<=${predicateValueExpr(upper, timeUnit)}`;
  } else if (isFieldGTEPredicate(predicate)) {
    const lower = predicate.gte;
    return `${fieldExpr$1}>=${predicateValueExpr(lower, timeUnit)}`;
  } else if (isFieldOneOfPredicate(predicate)) {
    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(",")}], ${fieldExpr$1}) !== -1`;
  } else if (isFieldValidPredicate(predicate)) {
    return fieldValidPredicate(fieldExpr$1, predicate.valid);
  } else if (isFieldRangePredicate(predicate)) {
    const { range: range2 } = predicate;
    const lower = isSignalRef(range2) ? { signal: `${range2.signal}[0]` } : range2[0];
    const upper = isSignalRef(range2) ? { signal: `${range2.signal}[1]` } : range2[1];
    if (lower !== null && upper !== null && useInRange) {
      return "inrange(" + fieldExpr$1 + ", [" + predicateValueExpr(lower, timeUnit) + ", " + predicateValueExpr(upper, timeUnit) + "])";
    }
    const exprs = [];
    if (lower !== null) {
      exprs.push(`${fieldExpr$1} >= ${predicateValueExpr(lower, timeUnit)}`);
    }
    if (upper !== null) {
      exprs.push(`${fieldExpr$1} <= ${predicateValueExpr(upper, timeUnit)}`);
    }
    return exprs.length > 0 ? exprs.join(" && ") : "true";
  }
  throw new Error(`Invalid field predicate: ${stringify$1(predicate)}`);
}
function fieldValidPredicate(fieldExpr2, valid2 = true) {
  if (valid2) {
    return `isValid(${fieldExpr2}) && isFinite(+${fieldExpr2})`;
  } else {
    return `!isValid(${fieldExpr2}) || !isFinite(+${fieldExpr2})`;
  }
}
function normalizePredicate$1(f) {
  var _a;
  if (isFieldPredicate(f) && f.timeUnit) {
    return Object.assign(Object.assign({}, f), { timeUnit: (_a = normalizeTimeUnit(f.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit });
  }
  return f;
}
const Type = {
  quantitative: "quantitative",
  ordinal: "ordinal",
  temporal: "temporal",
  nominal: "nominal",
  geojson: "geojson"
};
function isContinuous(type2) {
  return type2 === "quantitative" || type2 === "temporal";
}
function isDiscrete$1(type2) {
  return type2 === "ordinal" || type2 === "nominal";
}
const QUANTITATIVE = Type.quantitative;
const ORDINAL = Type.ordinal;
const TEMPORAL = Type.temporal;
const NOMINAL = Type.nominal;
const GEOJSON = Type.geojson;
function getFullName(type2) {
  if (type2) {
    type2 = type2.toLowerCase();
    switch (type2) {
      case "q":
      case QUANTITATIVE:
        return "quantitative";
      case "t":
      case TEMPORAL:
        return "temporal";
      case "o":
      case ORDINAL:
        return "ordinal";
      case "n":
      case NOMINAL:
        return "nominal";
      case GEOJSON:
        return "geojson";
    }
  }
  return void 0;
}
var __rest$s = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
const ScaleType = {
  // Continuous - Quantitative
  LINEAR: "linear",
  LOG: "log",
  // Continuous - Time
  TIME: "time",
  UTC: "utc",
  POINT: "point",
  BAND: "band"
};
const SCALE_CATEGORY_INDEX = {
  linear: "numeric",
  log: "numeric",
  pow: "numeric",
  sqrt: "numeric",
  symlog: "numeric",
  identity: "numeric",
  sequential: "numeric",
  time: "time",
  utc: "time",
  ordinal: "ordinal",
  "bin-ordinal": "bin-ordinal",
  point: "ordinal-position",
  band: "ordinal-position",
  quantile: "discretizing",
  quantize: "discretizing",
  threshold: "discretizing"
};
function scaleCompatible(scaleType1, scaleType2) {
  const scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];
  const scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];
  return scaleCategory1 === scaleCategory2 || scaleCategory1 === "ordinal-position" && scaleCategory2 === "time" || scaleCategory2 === "ordinal-position" && scaleCategory1 === "time";
}
const SCALE_PRECEDENCE_INDEX = {
  // numeric
  linear: 0,
  log: 1,
  pow: 1,
  sqrt: 1,
  symlog: 1,
  identity: 1,
  sequential: 1,
  // time
  time: 0,
  utc: 0,
  // ordinal-position -- these have higher precedence than continuous scales as they support more types of data
  point: 10,
  band: 11,
  // non grouped types
  ordinal: 0,
  "bin-ordinal": 0,
  quantile: 0,
  quantize: 0,
  threshold: 0
};
function scaleTypePrecedence(scaleType2) {
  return SCALE_PRECEDENCE_INDEX[scaleType2];
}
const QUANTITATIVE_SCALES = /* @__PURE__ */ new Set([
  "linear",
  "log",
  "pow",
  "sqrt",
  "symlog"
]);
const CONTINUOUS_TO_CONTINUOUS_SCALES = /* @__PURE__ */ new Set([
  ...QUANTITATIVE_SCALES,
  "time",
  "utc"
]);
function isQuantitative(type2) {
  return QUANTITATIVE_SCALES.has(type2);
}
const CONTINUOUS_TO_DISCRETE_SCALES = /* @__PURE__ */ new Set([
  "quantile",
  "quantize",
  "threshold"
]);
const CONTINUOUS_DOMAIN_SCALES = /* @__PURE__ */ new Set([
  ...CONTINUOUS_TO_CONTINUOUS_SCALES,
  ...CONTINUOUS_TO_DISCRETE_SCALES,
  "sequential",
  "identity"
]);
const DISCRETE_DOMAIN_SCALES = /* @__PURE__ */ new Set([
  "ordinal",
  "bin-ordinal",
  "point",
  "band"
]);
function hasDiscreteDomain(type2) {
  return DISCRETE_DOMAIN_SCALES.has(type2);
}
function hasContinuousDomain(type2) {
  return CONTINUOUS_DOMAIN_SCALES.has(type2);
}
function isContinuousToContinuous(type2) {
  return CONTINUOUS_TO_CONTINUOUS_SCALES.has(type2);
}
function isContinuousToDiscrete(type2) {
  return CONTINUOUS_TO_DISCRETE_SCALES.has(type2);
}
const defaultScaleConfig = {
  pointPadding: 0.5,
  barBandPaddingInner: 0.1,
  rectBandPaddingInner: 0,
  bandWithNestedOffsetPaddingInner: 0.2,
  bandWithNestedOffsetPaddingOuter: 0.2,
  minBandSize: 2,
  minFontSize: 8,
  maxFontSize: 40,
  minOpacity: 0.3,
  maxOpacity: 0.8,
  // FIXME: revise if these *can* become ratios of width/height step
  minSize: 9,
  minStrokeWidth: 1,
  maxStrokeWidth: 4,
  quantileCount: 4,
  quantizeCount: 4
};
function isExtendedScheme(scheme2) {
  return !isString(scheme2) && !!scheme2["name"];
}
function isParameterDomain(domain2) {
  return domain2 === null || domain2 === void 0 ? void 0 : domain2["param"];
}
function isDomainUnionWith(domain2) {
  return domain2 === null || domain2 === void 0 ? void 0 : domain2["unionWith"];
}
function isFieldRange(range2) {
  return isObject$1(range2) && "field" in range2;
}
const SCALE_PROPERTY_INDEX = {
  type: 1,
  domain: 1,
  domainMax: 1,
  domainMin: 1,
  domainMid: 1,
  align: 1,
  range: 1,
  rangeMax: 1,
  rangeMin: 1,
  scheme: 1,
  bins: 1,
  // Other properties
  reverse: 1,
  round: 1,
  // quantitative / time
  clamp: 1,
  nice: 1,
  // quantitative
  base: 1,
  exponent: 1,
  constant: 1,
  interpolate: 1,
  zero: 1,
  // band/point
  padding: 1,
  paddingInner: 1,
  paddingOuter: 1
};
const { type, domain: domain$1, range: range$1, rangeMax, rangeMin, scheme } = SCALE_PROPERTY_INDEX, NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX = __rest$s(SCALE_PROPERTY_INDEX, ["type", "domain", "range", "rangeMax", "rangeMin", "scheme"]);
const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys$1(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);
function scaleTypeSupportProperty(scaleType2, propName) {
  switch (propName) {
    case "type":
    case "domain":
    case "reverse":
    case "range":
      return true;
    case "scheme":
    case "interpolate":
      return !["point", "band", "identity"].includes(scaleType2);
    case "bins":
      return !["point", "band", "identity", "ordinal"].includes(scaleType2);
    case "round":
      return isContinuousToContinuous(scaleType2) || scaleType2 === "band" || scaleType2 === "point";
    case "padding":
    case "rangeMin":
    case "rangeMax":
      return isContinuousToContinuous(scaleType2) || ["point", "band"].includes(scaleType2);
    case "paddingOuter":
    case "align":
      return ["point", "band"].includes(scaleType2);
    case "paddingInner":
      return scaleType2 === "band";
    case "domainMax":
    case "domainMid":
    case "domainMin":
    case "clamp":
      return isContinuousToContinuous(scaleType2);
    case "nice":
      return isContinuousToContinuous(scaleType2) || scaleType2 === "quantize" || scaleType2 === "threshold";
    case "exponent":
      return scaleType2 === "pow";
    case "base":
      return scaleType2 === "log";
    case "constant":
      return scaleType2 === "symlog";
    case "zero":
      return hasContinuousDomain(scaleType2) && !contains([
        "log",
        "time",
        "utc",
        "threshold",
        "quantile"
        // quantile depends on distribution so zero does not matter
      ], scaleType2);
  }
}
function channelScalePropertyIncompatability(channel, propName) {
  switch (propName) {
    case "interpolate":
    case "scheme":
    case "domainMid":
      if (!isColorChannel(channel)) {
        return cannotUseScalePropertyWithNonColor(propName);
      }
      return void 0;
    case "align":
    case "type":
    case "bins":
    case "domain":
    case "domainMax":
    case "domainMin":
    case "range":
    case "base":
    case "exponent":
    case "constant":
    case "nice":
    case "padding":
    case "paddingInner":
    case "paddingOuter":
    case "rangeMax":
    case "rangeMin":
    case "reverse":
    case "round":
    case "clamp":
    case "zero":
      return void 0;
  }
}
function scaleTypeSupportDataType(specifiedType, fieldDefType) {
  if (contains([ORDINAL, NOMINAL], fieldDefType)) {
    return specifiedType === void 0 || hasDiscreteDomain(specifiedType);
  } else if (fieldDefType === TEMPORAL) {
    return contains([ScaleType.TIME, ScaleType.UTC, void 0], specifiedType);
  } else if (fieldDefType === QUANTITATIVE) {
    return isQuantitative(specifiedType) || isContinuousToDiscrete(specifiedType) || specifiedType === void 0;
  }
  return true;
}
function channelSupportScaleType(channel, scaleType2, hasNestedOffsetScale = false) {
  if (!isScaleChannel(channel)) {
    return false;
  }
  switch (channel) {
    case X:
    case Y:
    case XOFFSET:
    case YOFFSET:
    case THETA:
    case RADIUS:
      if (isContinuousToContinuous(scaleType2)) {
        return true;
      } else if (scaleType2 === "band") {
        return true;
      } else if (scaleType2 === "point") {
        return !hasNestedOffsetScale;
      }
      return false;
    case SIZE:
    // TODO: size and opacity can support ordinal with more modification
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case ANGLE:
      return isContinuousToContinuous(scaleType2) || isContinuousToDiscrete(scaleType2) || contains(["band", "point", "ordinal"], scaleType2);
    case COLOR:
    case FILL:
    case STROKE:
      return scaleType2 !== "band";
    // band does not make sense with color
    case STROKEDASH:
    case SHAPE:
      return scaleType2 === "ordinal" || isContinuousToDiscrete(scaleType2);
  }
}
const Mark = {
  arc: "arc",
  area: "area",
  bar: "bar",
  image: "image",
  line: "line",
  point: "point",
  rect: "rect",
  rule: "rule",
  text: "text",
  tick: "tick",
  trail: "trail",
  circle: "circle",
  square: "square",
  geoshape: "geoshape"
};
const ARC = Mark.arc;
const AREA = Mark.area;
const BAR = Mark.bar;
const IMAGE = Mark.image;
const LINE = Mark.line;
const POINT = Mark.point;
const RECT = Mark.rect;
const RULE = Mark.rule;
const TEXT = Mark.text;
const TICK = Mark.tick;
const TRAIL = Mark.trail;
const CIRCLE = Mark.circle;
const SQUARE = Mark.square;
const GEOSHAPE = Mark.geoshape;
function isPathMark(m2) {
  return ["line", "area", "trail"].includes(m2);
}
function isRectBasedMark(m2) {
  return [
    "rect",
    "bar",
    "image",
    "arc"
    /* arc is rect/interval in polar coordinate */
  ].includes(m2);
}
const PRIMITIVE_MARKS = new Set(keys$1(Mark));
function isMarkDef(mark2) {
  return mark2["type"];
}
const STROKE_CONFIG = [
  "stroke",
  "strokeWidth",
  "strokeDash",
  "strokeDashOffset",
  "strokeOpacity",
  "strokeJoin",
  "strokeMiterLimit"
];
const FILL_CONFIG = ["fill", "fillOpacity"];
const FILL_STROKE_CONFIG = [...STROKE_CONFIG, ...FILL_CONFIG];
const VL_ONLY_MARK_CONFIG_INDEX = {
  color: 1,
  filled: 1,
  invalid: 1,
  order: 1,
  radius2: 1,
  theta2: 1,
  timeUnitBandSize: 1,
  timeUnitBandPosition: 1
};
const VL_ONLY_MARK_CONFIG_PROPERTIES = keys$1(VL_ONLY_MARK_CONFIG_INDEX);
const VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
  area: ["line", "point"],
  bar: ["binSpacing", "continuousBandSize", "discreteBandSize"],
  rect: ["binSpacing", "continuousBandSize", "discreteBandSize"],
  line: ["point"],
  tick: ["bandSize", "thickness"]
};
const defaultMarkConfig = {
  color: "#4c78a8",
  invalid: "filter",
  timeUnitBandSize: 1
};
const MARK_CONFIG_INDEX = {
  mark: 1,
  arc: 1,
  area: 1,
  bar: 1,
  circle: 1,
  image: 1,
  line: 1,
  point: 1,
  rect: 1,
  rule: 1,
  square: 1,
  text: 1,
  tick: 1,
  trail: 1,
  geoshape: 1
};
const MARK_CONFIGS = keys$1(MARK_CONFIG_INDEX);
function isRelativeBandSize(o) {
  return o && o["band"] != void 0;
}
const BAR_CORNER_RADIUS_INDEX = {
  horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
  vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
};
const DEFAULT_RECT_BAND_SIZE = 5;
const defaultBarConfig = {
  binSpacing: 1,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  timeUnitBandPosition: 0.5
};
const defaultRectConfig = {
  binSpacing: 0,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  timeUnitBandPosition: 0.5
};
const defaultTickConfig = {
  thickness: 1
};
function getMarkType(m2) {
  return isMarkDef(m2) ? m2.type : m2;
}
function midPointRefWithPositionInvalidTest(params2) {
  const { channel, channelDef, markDef, scale: scale2, config } = params2;
  const ref2 = midPoint(params2);
  if (
    // Only this for field def without counting aggregate (as count wouldn't be null)
    isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && // and only for continuous scale
    scale2 && isContinuousToContinuous(scale2.get("type"))
  ) {
    return wrapPositionInvalidTest({
      fieldDef: channelDef,
      channel,
      markDef,
      ref: ref2,
      config
    });
  }
  return ref2;
}
function wrapPositionInvalidTest({ fieldDef, channel, markDef, ref: ref2, config }) {
  if (isPathMark(markDef.type)) {
    return ref2;
  }
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid === null) {
    return [fieldInvalidTestValueRef(fieldDef, channel), ref2];
  }
  return ref2;
}
function fieldInvalidTestValueRef(fieldDef, channel) {
  const test2 = fieldInvalidPredicate(fieldDef, true);
  const mainChannel = getMainRangeChannel(channel);
  const zeroValueRef = mainChannel === "y" ? { field: { group: "height" } } : (
    // x / angle / radius can all use 0
    { value: 0 }
  );
  return Object.assign({ test: test2 }, zeroValueRef);
}
function fieldInvalidPredicate(field2, invalid = true) {
  return fieldValidPredicate(isString(field2) ? field2 : vgField(field2, { expr: "datum" }), !invalid);
}
function datumDefToExpr(datumDef) {
  const { datum: datum2 } = datumDef;
  if (isDateTime(datum2)) {
    return dateTimeToExpr(datum2);
  }
  return `${stringify$1(datum2)}`;
}
function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode2) {
  const ref2 = {};
  if (scaleName) {
    ref2.scale = scaleName;
  }
  if (isDatumDef(fieldDef)) {
    const { datum: datum2 } = fieldDef;
    if (isDateTime(datum2)) {
      ref2.signal = dateTimeToExpr(datum2);
    } else if (isSignalRef(datum2)) {
      ref2.signal = datum2.signal;
    } else if (isExprRef(datum2)) {
      ref2.signal = datum2.expr;
    } else {
      ref2.value = datum2;
    }
  } else {
    ref2.field = vgField(fieldDef, opt);
  }
  if (encode2) {
    const { offset: offset2, band: band2 } = encode2;
    if (offset2) {
      ref2.offset = offset2;
    }
    if (band2) {
      ref2.band = band2;
    }
  }
  return ref2;
}
function interpolatedSignalRef({ scaleName, fieldOrDatumDef, fieldOrDatumDef2, offset: offset2, startSuffix, bandPosition = 0.5 }) {
  const expr2 = 0 < bandPosition && bandPosition < 1 ? "datum" : void 0;
  const start = vgField(fieldOrDatumDef, { expr: expr2, suffix: startSuffix });
  const end = fieldOrDatumDef2 !== void 0 ? vgField(fieldOrDatumDef2, { expr: expr2 }) : vgField(fieldOrDatumDef, { suffix: "end", expr: expr2 });
  const ref2 = {};
  if (bandPosition === 0 || bandPosition === 1) {
    ref2.scale = scaleName;
    const val = bandPosition === 0 ? start : end;
    ref2.field = val;
  } else {
    const datum2 = isSignalRef(bandPosition) ? `${bandPosition.signal} * ${start} + (1-${bandPosition.signal}) * ${end}` : `${bandPosition} * ${start} + ${1 - bandPosition} * ${end}`;
    ref2.signal = `scale("${scaleName}", ${datum2})`;
  }
  if (offset2) {
    ref2.offset = offset2;
  }
  return ref2;
}
function midPoint({ channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale2, stack: stack2, offset: offset2, defaultRef, bandPosition }) {
  var _a;
  if (channelDef) {
    if (isFieldOrDatumDef(channelDef)) {
      const scaleType2 = scale2 === null || scale2 === void 0 ? void 0 : scale2.get("type");
      if (isTypedFieldDef(channelDef)) {
        bandPosition !== null && bandPosition !== void 0 ? bandPosition : bandPosition = getBandPosition({
          fieldDef: channelDef,
          fieldDef2: channel2Def,
          markDef,
          config
        });
        const { bin: bin2, timeUnit, type: type2 } = channelDef;
        if (isBinning(bin2) || bandPosition && timeUnit && type2 === TEMPORAL) {
          if (stack2 === null || stack2 === void 0 ? void 0 : stack2.impute) {
            return valueRefForFieldOrDatumDef(channelDef, scaleName, { binSuffix: "mid" }, { offset: offset2 });
          }
          if (bandPosition && !hasDiscreteDomain(scaleType2)) {
            return interpolatedSignalRef({ scaleName, fieldOrDatumDef: channelDef, bandPosition, offset: offset2 });
          }
          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? { binSuffix: "range" } : {}, {
            offset: offset2
          });
        } else if (isBinned(bin2)) {
          if (isFieldDef(channel2Def)) {
            return interpolatedSignalRef({
              scaleName,
              fieldOrDatumDef: channelDef,
              fieldOrDatumDef2: channel2Def,
              bandPosition,
              offset: offset2
            });
          } else {
            const channel2 = channel === X ? X2 : Y2;
            warn(channelRequiredForBinned(channel2));
          }
        }
      }
      return valueRefForFieldOrDatumDef(
        channelDef,
        scaleName,
        hasDiscreteDomain(scaleType2) ? { binSuffix: "range" } : {},
        // no need for bin suffix if there is no scale
        {
          offset: offset2,
          // For band, to get mid point, need to offset by half of the band
          band: scaleType2 === "band" ? (_a = bandPosition !== null && bandPosition !== void 0 ? bandPosition : channelDef.bandPosition) !== null && _a !== void 0 ? _a : 0.5 : void 0
        }
      );
    } else if (isValueDef(channelDef)) {
      const value2 = channelDef.value;
      const offsetMixins = offset2 ? { offset: offset2 } : {};
      return Object.assign(Object.assign({}, widthHeightValueOrSignalRef(channel, value2)), offsetMixins);
    }
  }
  if (isFunction$3(defaultRef)) {
    defaultRef = defaultRef();
  }
  if (defaultRef) {
    return Object.assign(Object.assign({}, defaultRef), offset2 ? { offset: offset2 } : {});
  }
  return defaultRef;
}
function widthHeightValueOrSignalRef(channel, value2) {
  if (contains(["x", "x2"], channel) && value2 === "width") {
    return { field: { group: "width" } };
  } else if (contains(["y", "y2"], channel) && value2 === "height") {
    return { field: { group: "height" } };
  }
  return signalOrValueRef(value2);
}
function isCustomFormatType(formatType) {
  return formatType && formatType !== "number" && formatType !== "time";
}
function customFormatExpr(formatType, field2, format2) {
  return `${formatType}(${field2}${format2 ? `, ${stringify$1(format2)}` : ""})`;
}
const BIN_RANGE_DELIMITER = " – ";
function formatSignalRef({ fieldOrDatumDef, format: format2, formatType, expr: expr2, normalizeStack, config }) {
  var _a, _b;
  if (isCustomFormatType(formatType)) {
    return formatCustomType({
      fieldOrDatumDef,
      format: format2,
      formatType,
      expr: expr2,
      config
    });
  }
  const field2 = fieldToFormat(fieldOrDatumDef, expr2, normalizeStack);
  const type2 = channelDefType(fieldOrDatumDef);
  if (format2 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (type2 === "quantitative") {
      if (normalizeStack && config.normalizedNumberFormatType)
        return formatCustomType({
          fieldOrDatumDef,
          format: config.normalizedNumberFormat,
          formatType: config.normalizedNumberFormatType,
          expr: expr2,
          config
        });
      if (config.numberFormatType) {
        return formatCustomType({
          fieldOrDatumDef,
          format: config.numberFormat,
          formatType: config.numberFormatType,
          expr: expr2,
          config
        });
      }
    }
    if (type2 === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === void 0) {
      return formatCustomType({
        fieldOrDatumDef,
        format: config.timeFormat,
        formatType: config.timeFormatType,
        expr: expr2,
        config
      });
    }
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const signal = timeFormatExpression({
      field: field2,
      timeUnit: isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : void 0,
      format: format2,
      formatType: config.timeFormatType,
      rawTimeFormat: config.timeFormat,
      isUTCScale: isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC
    });
    return signal ? { signal } : void 0;
  }
  format2 = numberFormat({ type: type2, specifiedFormat: format2, config, normalizeStack });
  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, { expr: expr2, binSuffix: "end" });
    return {
      signal: binFormatExpression(field2, endField, format2, formatType, config)
    };
  } else if (format2 || channelDefType(fieldOrDatumDef) === "quantitative") {
    return {
      signal: `${formatExpr(field2, format2)}`
    };
  } else {
    return { signal: `isValid(${field2}) ? ${field2} : ""+${field2}` };
  }
}
function fieldToFormat(fieldOrDatumDef, expr2, normalizeStack) {
  if (isFieldDef(fieldOrDatumDef)) {
    if (normalizeStack) {
      return `${vgField(fieldOrDatumDef, { expr: expr2, suffix: "end" })}-${vgField(fieldOrDatumDef, {
        expr: expr2,
        suffix: "start"
      })}`;
    } else {
      return vgField(fieldOrDatumDef, { expr: expr2 });
    }
  } else {
    return datumDefToExpr(fieldOrDatumDef);
  }
}
function formatCustomType({ fieldOrDatumDef, format: format2, formatType, expr: expr2, normalizeStack, config, field: field2 }) {
  field2 !== null && field2 !== void 0 ? field2 : field2 = fieldToFormat(fieldOrDatumDef, expr2, normalizeStack);
  if (field2 !== "datum.value" && // For axis/legend, we can't correctly know the end of the bin from `datum`
  isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, { expr: expr2, binSuffix: "end" });
    return {
      signal: binFormatExpression(field2, endField, format2, formatType, config)
    };
  }
  return { signal: customFormatExpr(formatType, field2, format2) };
}
function guideFormat(fieldOrDatumDef, type2, format2, formatType, config, omitTimeFormatConfig) {
  var _a;
  if (isCustomFormatType(formatType)) {
    return void 0;
  } else if (format2 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (channelDefType(fieldOrDatumDef) === "quantitative") {
      if (config.normalizedNumberFormatType && isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize") {
        return void 0;
      }
      if (config.numberFormatType) {
        return void 0;
      }
    }
  }
  if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" && config.normalizedNumberFormat) {
    return numberFormat({
      type: "quantitative",
      config,
      normalizeStack: true
    });
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : void 0;
    if (timeUnit === void 0 && config.customFormatTypes && config.timeFormatType) {
      return void 0;
    }
    return timeFormat({ specifiedFormat: format2, timeUnit, config, omitTimeFormatConfig });
  }
  return numberFormat({ type: type2, specifiedFormat: format2, config });
}
function guideFormatType(formatType, fieldOrDatumDef, scaleType2) {
  var _a;
  if (formatType && (isSignalRef(formatType) || formatType === "number" || formatType === "time")) {
    return formatType;
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType2 !== "time" && scaleType2 !== "utc") {
    return isFieldDef(fieldOrDatumDef) && ((_a = normalizeTimeUnit(fieldOrDatumDef === null || fieldOrDatumDef === void 0 ? void 0 : fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.utc) ? "utc" : "time";
  }
  return void 0;
}
function numberFormat({ type: type2, specifiedFormat, config, normalizeStack }) {
  if (isString(specifiedFormat)) {
    return specifiedFormat;
  }
  if (type2 === QUANTITATIVE) {
    return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;
  }
  return void 0;
}
function timeFormat({ specifiedFormat, timeUnit, config, omitTimeFormatConfig }) {
  if (specifiedFormat) {
    return specifiedFormat;
  }
  if (timeUnit) {
    return {
      signal: timeUnitSpecifierExpression(timeUnit)
    };
  }
  return omitTimeFormatConfig ? void 0 : config.timeFormat;
}
function formatExpr(field2, format2) {
  return `format(${field2}, "${format2 || ""}")`;
}
function binNumberFormatExpr(field2, format2, formatType, config) {
  var _a;
  if (isCustomFormatType(formatType)) {
    return customFormatExpr(formatType, field2, format2);
  }
  return formatExpr(field2, (_a = isString(format2) ? format2 : void 0) !== null && _a !== void 0 ? _a : config.numberFormat);
}
function binFormatExpression(startField, endField, format2, formatType, config) {
  if (format2 === void 0 && formatType === void 0 && config.customFormatTypes && config.numberFormatType) {
    return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);
  }
  const start = binNumberFormatExpr(startField, format2, formatType, config);
  const end = binNumberFormatExpr(endField, format2, formatType, config);
  return `${fieldValidPredicate(startField, false)} ? "null" : ${start} + "${BIN_RANGE_DELIMITER}" + ${end}`;
}
function timeFormatExpression({ field: field2, timeUnit, format: format2, formatType, rawTimeFormat, isUTCScale }) {
  if (!timeUnit || format2) {
    if (!timeUnit && formatType) {
      return `${formatType}(${field2}, '${format2}')`;
    }
    format2 = isString(format2) ? format2 : rawTimeFormat;
    return `${isUTCScale ? "utc" : "time"}Format(${field2}, '${format2}')`;
  } else {
    return formatExpression(timeUnit, field2, isUTCScale);
  }
}
const DEFAULT_SORT_OP = "min";
const SORT_BY_CHANNEL_INDEX = {
  x: 1,
  y: 1,
  color: 1,
  fill: 1,
  stroke: 1,
  strokeWidth: 1,
  size: 1,
  shape: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  opacity: 1,
  text: 1
};
function isSortByChannel(c2) {
  return c2 in SORT_BY_CHANNEL_INDEX;
}
function isSortByEncoding(sort2) {
  return !!(sort2 === null || sort2 === void 0 ? void 0 : sort2["encoding"]);
}
function isSortField(sort2) {
  return sort2 && (sort2["op"] === "count" || !!sort2["field"]);
}
function isSortArray(sort2) {
  return sort2 && isArray$1(sort2);
}
function isFacetMapping(f) {
  return "row" in f || "column" in f;
}
function isFacetFieldDef(channelDef) {
  return !!channelDef && "header" in channelDef;
}
function isFacetSpec(spec) {
  return "facet" in spec;
}
var __rest$r = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function isConditionalParameter(c2) {
  return c2["param"];
}
function isRepeatRef(field2) {
  return field2 && !isString(field2) && "repeat" in field2;
}
function toFieldDefBase(fieldDef) {
  const { field: field2, timeUnit, bin: bin2, aggregate } = fieldDef;
  return Object.assign(Object.assign(Object.assign(Object.assign({}, timeUnit ? { timeUnit } : {}), bin2 ? { bin: bin2 } : {}), aggregate ? { aggregate } : {}), { field: field2 });
}
function isSortableFieldDef(fieldDef) {
  return "sort" in fieldDef;
}
function getBandPosition({ fieldDef, fieldDef2, markDef: mark2, config }) {
  if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== void 0) {
    return fieldDef.bandPosition;
  }
  if (isFieldDef(fieldDef)) {
    const { timeUnit, bin: bin2 } = fieldDef;
    if (timeUnit && !fieldDef2) {
      return isRectBasedMark(mark2.type) ? 0 : getMarkConfig("timeUnitBandPosition", mark2, config);
    } else if (isBinning(bin2)) {
      return 0.5;
    }
  }
  return void 0;
}
function getBandSize({ channel, fieldDef, fieldDef2, markDef: mark2, config, scaleType: scaleType2, useVlSizeChannel }) {
  var _a, _b, _c2;
  const sizeChannel = getSizeChannel(channel);
  const size = getMarkPropOrConfig(useVlSizeChannel ? "size" : sizeChannel, mark2, config, {
    vgChannel: sizeChannel
  });
  if (size !== void 0) {
    return size;
  }
  if (isFieldDef(fieldDef)) {
    const { timeUnit, bin: bin2 } = fieldDef;
    if (timeUnit && !fieldDef2) {
      return { band: getMarkConfig("timeUnitBandSize", mark2, config) };
    } else if (isBinning(bin2) && !hasDiscreteDomain(scaleType2)) {
      return { band: 1 };
    }
  }
  if (isRectBasedMark(mark2.type)) {
    if (scaleType2) {
      if (hasDiscreteDomain(scaleType2)) {
        return ((_a = config[mark2.type]) === null || _a === void 0 ? void 0 : _a.discreteBandSize) || { band: 1 };
      } else {
        return (_b = config[mark2.type]) === null || _b === void 0 ? void 0 : _b.continuousBandSize;
      }
    }
    return (_c2 = config[mark2.type]) === null || _c2 === void 0 ? void 0 : _c2.discreteBandSize;
  }
  return void 0;
}
function hasBandEnd(fieldDef, fieldDef2, markDef, config) {
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === "temporal") {
    return getBandPosition({ fieldDef, fieldDef2, markDef, config }) !== void 0;
  }
  return false;
}
function isConditionalDef(channelDef) {
  return channelDef && "condition" in channelDef;
}
function hasConditionalFieldDef(channelDef) {
  const condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef["condition"];
  return !!condition && !isArray$1(condition) && isFieldDef(condition);
}
function hasConditionalFieldOrDatumDef(channelDef) {
  const condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef["condition"];
  return !!condition && !isArray$1(condition) && isFieldOrDatumDef(condition);
}
function hasConditionalValueDef(channelDef) {
  const condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef["condition"];
  return !!condition && (isArray$1(condition) || isValueDef(condition));
}
function isFieldDef(channelDef) {
  return channelDef && (!!channelDef["field"] || channelDef["aggregate"] === "count");
}
function channelDefType(channelDef) {
  return channelDef === null || channelDef === void 0 ? void 0 : channelDef["type"];
}
function isDatumDef(channelDef) {
  return channelDef && "datum" in channelDef;
}
function isContinuousFieldOrDatumDef(cd) {
  return isTypedFieldDef(cd) && !isDiscrete(cd) || isNumericDataDef(cd);
}
function isNumericDataDef(cd) {
  return isDatumDef(cd) && isNumber$1(cd.datum);
}
function isFieldOrDatumDef(channelDef) {
  return isFieldDef(channelDef) || isDatumDef(channelDef);
}
function isTypedFieldDef(channelDef) {
  return channelDef && ("field" in channelDef || channelDef["aggregate"] === "count") && "type" in channelDef;
}
function isValueDef(channelDef) {
  return channelDef && "value" in channelDef && "value" in channelDef;
}
function isScaleFieldDef(channelDef) {
  return channelDef && ("scale" in channelDef || "sort" in channelDef);
}
function isPositionFieldOrDatumDef(channelDef) {
  return channelDef && ("axis" in channelDef || "stack" in channelDef || "impute" in channelDef);
}
function isMarkPropFieldOrDatumDef(channelDef) {
  return channelDef && "legend" in channelDef;
}
function isStringFieldOrDatumDef(channelDef) {
  return channelDef && ("format" in channelDef || "formatType" in channelDef);
}
function toStringFieldDef(fieldDef) {
  return omit(fieldDef, ["legend", "axis", "header", "scale"]);
}
function isOpFieldDef(fieldDef) {
  return "op" in fieldDef;
}
function vgField(fieldDef, opt = {}) {
  var _a, _b, _c2;
  let field2 = fieldDef.field;
  const prefix2 = opt.prefix;
  let suffix = opt.suffix;
  let argAccessor = "";
  if (isCount(fieldDef)) {
    field2 = internalField("count");
  } else {
    let fn;
    if (!opt.nofn) {
      if (isOpFieldDef(fieldDef)) {
        fn = fieldDef.op;
      } else {
        const { bin: bin2, aggregate, timeUnit } = fieldDef;
        if (isBinning(bin2)) {
          fn = binToString(bin2);
          suffix = ((_a = opt.binSuffix) !== null && _a !== void 0 ? _a : "") + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : "");
        } else if (aggregate) {
          if (isArgmaxDef(aggregate)) {
            argAccessor = `["${field2}"]`;
            field2 = `argmax_${aggregate.argmax}`;
          } else if (isArgminDef(aggregate)) {
            argAccessor = `["${field2}"]`;
            field2 = `argmin_${aggregate.argmin}`;
          } else {
            fn = String(aggregate);
          }
        } else if (timeUnit) {
          fn = timeUnitToString(timeUnit);
          suffix = (!["range", "mid"].includes(opt.binSuffix) && opt.binSuffix || "") + ((_c2 = opt.suffix) !== null && _c2 !== void 0 ? _c2 : "");
        }
      }
    }
    if (fn) {
      field2 = field2 ? `${fn}_${field2}` : fn;
    }
  }
  if (suffix) {
    field2 = `${field2}_${suffix}`;
  }
  if (prefix2) {
    field2 = `${prefix2}_${field2}`;
  }
  if (opt.forAs) {
    return removePathFromField(field2);
  } else if (opt.expr) {
    return flatAccessWithDatum(field2, opt.expr) + argAccessor;
  } else {
    return replacePathInField(field2) + argAccessor;
  }
}
function isDiscrete(def2) {
  switch (def2.type) {
    case "nominal":
    case "ordinal":
    case "geojson":
      return true;
    case "quantitative":
      return isFieldDef(def2) && !!def2.bin;
    case "temporal":
      return false;
  }
  throw new Error(invalidFieldType(def2.type));
}
function isDiscretizing(def2) {
  var _a;
  return isScaleFieldDef(def2) && isContinuousToDiscrete((_a = def2.scale) === null || _a === void 0 ? void 0 : _a.type);
}
function isCount(fieldDef) {
  return fieldDef.aggregate === "count";
}
function verbalTitleFormatter(fieldDef, config) {
  var _a;
  const { field: field2, bin: bin2, timeUnit, aggregate } = fieldDef;
  if (aggregate === "count") {
    return config.countTitle;
  } else if (isBinning(bin2)) {
    return `${field2} (binned)`;
  } else if (timeUnit) {
    const unit2 = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;
    if (unit2) {
      return `${field2} (${getTimeUnitParts(unit2).join("-")})`;
    }
  } else if (aggregate) {
    if (isArgmaxDef(aggregate)) {
      return `${field2} for max ${aggregate.argmax}`;
    } else if (isArgminDef(aggregate)) {
      return `${field2} for min ${aggregate.argmin}`;
    } else {
      return `${titleCase(aggregate)} of ${field2}`;
    }
  }
  return field2;
}
function functionalTitleFormatter(fieldDef) {
  const { aggregate, bin: bin2, timeUnit, field: field2 } = fieldDef;
  if (isArgmaxDef(aggregate)) {
    return `${field2} for argmax(${aggregate.argmax})`;
  } else if (isArgminDef(aggregate)) {
    return `${field2} for argmin(${aggregate.argmin})`;
  }
  const timeUnitParams = normalizeTimeUnit(timeUnit);
  const fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && "timeunit" || isBinning(bin2) && "bin";
  if (fn) {
    return `${fn.toUpperCase()}(${field2})`;
  } else {
    return field2;
  }
}
const defaultTitleFormatter = (fieldDef, config) => {
  switch (config.fieldTitle) {
    case "plain":
      return fieldDef.field;
    case "functional":
      return functionalTitleFormatter(fieldDef);
    default:
      return verbalTitleFormatter(fieldDef, config);
  }
};
let titleFormatter = defaultTitleFormatter;
function setTitleFormatter(formatter) {
  titleFormatter = formatter;
}
function resetTitleFormatter() {
  setTitleFormatter(defaultTitleFormatter);
}
function title(fieldOrDatumDef, config, { allowDisabling, includeDefault = true }) {
  var _a, _b;
  const guideTitle = (_a = getGuide(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.title;
  if (!isFieldDef(fieldOrDatumDef)) {
    return guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldOrDatumDef.title;
  }
  const fieldDef = fieldOrDatumDef;
  const def2 = includeDefault ? defaultTitle(fieldDef, config) : void 0;
  if (allowDisabling) {
    return getFirstDefined(guideTitle, fieldDef.title, def2);
  } else {
    return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def2;
  }
}
function getGuide(fieldDef) {
  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {
    return fieldDef.axis;
  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {
    return fieldDef.legend;
  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {
    return fieldDef.header;
  }
  return void 0;
}
function defaultTitle(fieldDef, config) {
  return titleFormatter(fieldDef, config);
}
function getFormatMixins(fieldDef) {
  var _a;
  if (isStringFieldOrDatumDef(fieldDef)) {
    const { format: format2, formatType } = fieldDef;
    return { format: format2, formatType };
  } else {
    const guide = (_a = getGuide(fieldDef)) !== null && _a !== void 0 ? _a : {};
    const { format: format2, formatType } = guide;
    return { format: format2, formatType };
  }
}
function defaultType$2(fieldDef, channel) {
  var _a;
  switch (channel) {
    case "latitude":
    case "longitude":
      return "quantitative";
    case "row":
    case "column":
    case "facet":
    case "shape":
    case "strokeDash":
      return "nominal";
    case "order":
      return "ordinal";
  }
  if (isSortableFieldDef(fieldDef) && isArray$1(fieldDef.sort)) {
    return "ordinal";
  }
  const { aggregate, bin: bin2, timeUnit } = fieldDef;
  if (timeUnit) {
    return "temporal";
  }
  if (bin2 || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
    return "quantitative";
  }
  if (isScaleFieldDef(fieldDef) && ((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.type)) {
    switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {
      case "numeric":
      case "discretizing":
        return "quantitative";
      case "time":
        return "temporal";
    }
  }
  return "nominal";
}
function getFieldDef(channelDef) {
  if (isFieldDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function getFieldOrDatumDef(channelDef) {
  if (isFieldOrDatumDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function initChannelDef(channelDef, channel, config, opt = {}) {
  if (isString(channelDef) || isNumber$1(channelDef) || isBoolean$2(channelDef)) {
    const primitiveType = isString(channelDef) ? "string" : isNumber$1(channelDef) ? "number" : "boolean";
    warn(primitiveChannelDef(channel, primitiveType, channelDef));
    return { value: channelDef };
  }
  if (isFieldOrDatumDef(channelDef)) {
    return initFieldOrDatumDef(channelDef, channel, config, opt);
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return Object.assign(Object.assign({}, channelDef), {
      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>
      condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt)
    });
  }
  return channelDef;
}
function initFieldOrDatumDef(fd, channel, config, opt) {
  if (isStringFieldOrDatumDef(fd)) {
    const { format: format2, formatType } = fd, rest = __rest$r(fd, ["format", "formatType"]);
    if (isCustomFormatType(formatType) && !config.customFormatTypes) {
      warn(customFormatTypeNotAllowed(channel));
      return initFieldOrDatumDef(rest, channel, config, opt);
    }
  } else {
    const guideType = isPositionFieldOrDatumDef(fd) ? "axis" : isMarkPropFieldOrDatumDef(fd) ? "legend" : isFacetFieldDef(fd) ? "header" : null;
    if (guideType && fd[guideType]) {
      const _a = fd[guideType], { format: format2, formatType } = _a, newGuide = __rest$r(_a, ["format", "formatType"]);
      if (isCustomFormatType(formatType) && !config.customFormatTypes) {
        warn(customFormatTypeNotAllowed(channel));
        return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), { [guideType]: newGuide }), channel, config, opt);
      }
    }
  }
  if (isFieldDef(fd)) {
    return initFieldDef(fd, channel, opt);
  }
  return initDatumDef(fd);
}
function initDatumDef(datumDef) {
  let type2 = datumDef["type"];
  if (type2) {
    return datumDef;
  }
  const { datum: datum2 } = datumDef;
  type2 = isNumber$1(datum2) ? "quantitative" : isString(datum2) ? "nominal" : isDateTime(datum2) ? "temporal" : void 0;
  return Object.assign(Object.assign({}, datumDef), { type: type2 });
}
function initFieldDef(fd, channel, { compositeMark = false } = {}) {
  const { aggregate, timeUnit, bin: bin2, field: field2 } = fd;
  const fieldDef = Object.assign({}, fd);
  if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
    warn(invalidAggregate(aggregate));
    delete fieldDef.aggregate;
  }
  if (timeUnit) {
    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);
  }
  if (field2) {
    fieldDef.field = `${field2}`;
  }
  if (isBinning(bin2)) {
    fieldDef.bin = normalizeBin(bin2, channel);
  }
  if (isBinned(bin2) && !isXorY(channel)) {
    warn(channelShouldNotBeUsedForBinned(channel));
  }
  if (isTypedFieldDef(fieldDef)) {
    const { type: type2 } = fieldDef;
    const fullType = getFullName(type2);
    if (type2 !== fullType) {
      fieldDef.type = fullType;
    }
    if (type2 !== "quantitative") {
      if (isCountingAggregateOp(aggregate)) {
        warn(invalidFieldTypeForCountAggregate(type2, aggregate));
        fieldDef.type = "quantitative";
      }
    }
  } else if (!isSecondaryRangeChannel(channel)) {
    const newType = defaultType$2(fieldDef, channel);
    fieldDef["type"] = newType;
  }
  if (isTypedFieldDef(fieldDef)) {
    const { compatible, warning } = channelCompatibility(fieldDef, channel) || {};
    if (compatible === false) {
      warn(warning);
    }
  }
  if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {
    const { sort: sort2 } = fieldDef;
    if (isSortByChannel(sort2)) {
      return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sort2 } });
    }
    const sub = sort2.substr(1);
    if (sort2.charAt(0) === "-" && isSortByChannel(sub)) {
      return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sub, order: "descending" } });
    }
  }
  if (isFacetFieldDef(fieldDef)) {
    const { header } = fieldDef;
    if (header) {
      const { orient: orient2 } = header, rest = __rest$r(header, ["orient"]);
      if (orient2) {
        return Object.assign(Object.assign({}, fieldDef), { header: Object.assign(Object.assign({}, rest), { labelOrient: header.labelOrient || orient2, titleOrient: header.titleOrient || orient2 }) });
      }
    }
  }
  return fieldDef;
}
function normalizeBin(bin2, channel) {
  if (isBoolean$2(bin2)) {
    return { maxbins: autoMaxBins(channel) };
  } else if (bin2 === "binned") {
    return {
      binned: true
    };
  } else if (!bin2.maxbins && !bin2.step) {
    return Object.assign(Object.assign({}, bin2), { maxbins: autoMaxBins(channel) });
  } else {
    return bin2;
  }
}
const COMPATIBLE = { compatible: true };
function channelCompatibility(fieldDef, channel) {
  const type2 = fieldDef.type;
  if (type2 === "geojson" && channel !== "shape") {
    return {
      compatible: false,
      warning: `Channel ${channel} should not be used with a geojson data.`
    };
  }
  switch (channel) {
    case ROW:
    case COLUMN:
    case FACET:
      if (!isDiscrete(fieldDef)) {
        return {
          compatible: false,
          warning: channelShouldBeDiscrete(channel)
        };
      }
      return COMPATIBLE;
    case X:
    case Y:
    case XOFFSET:
    case YOFFSET:
    case COLOR:
    case FILL:
    case STROKE:
    case TEXT$1:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case URL$1:
    case ANGLE:
    case THETA:
    case RADIUS:
    case DESCRIPTION:
      return COMPATIBLE;
    case LONGITUDE:
    case LONGITUDE2:
    case LATITUDE:
    case LATITUDE2:
      if (type2 !== QUANTITATIVE) {
        return {
          compatible: false,
          warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`
        };
      }
      return COMPATIBLE;
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    case SIZE:
    case THETA2:
    case RADIUS2:
    case X2:
    case Y2:
      if (type2 === "nominal" && !fieldDef["sort"]) {
        return {
          compatible: false,
          warning: `Channel ${channel} should not be used with an unsorted discrete field.`
        };
      }
      return COMPATIBLE;
    case SHAPE:
    case STROKEDASH:
      if (!isDiscrete(fieldDef) && !isDiscretizing(fieldDef)) {
        return {
          compatible: false,
          warning: channelShouldBeDiscreteOrDiscretizing(channel)
        };
      }
      return COMPATIBLE;
    case ORDER:
      if (fieldDef.type === "nominal" && !("sort" in fieldDef)) {
        return {
          compatible: false,
          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`
        };
      }
      return COMPATIBLE;
  }
}
function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {
  const { formatType } = getFormatMixins(fieldOrDatumDef);
  return formatType === "time" || !formatType && isTimeFieldDef(fieldOrDatumDef);
}
function isTimeFieldDef(def2) {
  return def2 && (def2["type"] === "temporal" || isFieldDef(def2) && !!def2.timeUnit);
}
function valueExpr(v, { timeUnit, type: type2, wrapTime, undefinedIfExprNotRequired }) {
  var _a;
  const unit2 = timeUnit && ((_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit);
  let isTime = unit2 || type2 === "temporal";
  let expr2;
  if (isExprRef(v)) {
    expr2 = v.expr;
  } else if (isSignalRef(v)) {
    expr2 = v.signal;
  } else if (isDateTime(v)) {
    isTime = true;
    expr2 = dateTimeToExpr(v);
  } else if (isString(v) || isNumber$1(v)) {
    if (isTime) {
      expr2 = `datetime(${stringify$1(v)})`;
      if (isLocalSingleTimeUnit(unit2)) {
        if (isNumber$1(v) && v < 1e4 || isString(v) && isNaN(Date.parse(v))) {
          expr2 = dateTimeToExpr({ [unit2]: v });
        }
      }
    }
  }
  if (expr2) {
    return wrapTime && isTime ? `time(${expr2})` : expr2;
  }
  return undefinedIfExprNotRequired ? void 0 : stringify$1(v);
}
function valueArray(fieldOrDatumDef, values2) {
  const { type: type2 } = fieldOrDatumDef;
  return values2.map((v) => {
    const expr2 = valueExpr(v, {
      timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : void 0,
      type: type2,
      undefinedIfExprNotRequired: true
    });
    if (expr2 !== void 0) {
      return { signal: expr2 };
    }
    return v;
  });
}
function binRequiresRange(fieldDef, channel) {
  if (!isBinning(fieldDef.bin)) {
    console.warn("Only call this method for binned field defs.");
    return false;
  }
  return isScaleChannel(channel) && ["ordinal", "nominal"].includes(fieldDef.type);
}
const CONDITIONAL_AXIS_PROP_INDEX = {
  labelAlign: {
    part: "labels",
    vgProp: "align"
  },
  labelBaseline: {
    part: "labels",
    vgProp: "baseline"
  },
  labelColor: {
    part: "labels",
    vgProp: "fill"
  },
  labelFont: {
    part: "labels",
    vgProp: "font"
  },
  labelFontSize: {
    part: "labels",
    vgProp: "fontSize"
  },
  labelFontStyle: {
    part: "labels",
    vgProp: "fontStyle"
  },
  labelFontWeight: {
    part: "labels",
    vgProp: "fontWeight"
  },
  labelOpacity: {
    part: "labels",
    vgProp: "opacity"
  },
  labelOffset: null,
  labelPadding: null,
  gridColor: {
    part: "grid",
    vgProp: "stroke"
  },
  gridDash: {
    part: "grid",
    vgProp: "strokeDash"
  },
  gridDashOffset: {
    part: "grid",
    vgProp: "strokeDashOffset"
  },
  gridOpacity: {
    part: "grid",
    vgProp: "opacity"
  },
  gridWidth: {
    part: "grid",
    vgProp: "strokeWidth"
  },
  tickColor: {
    part: "ticks",
    vgProp: "stroke"
  },
  tickDash: {
    part: "ticks",
    vgProp: "strokeDash"
  },
  tickDashOffset: {
    part: "ticks",
    vgProp: "strokeDashOffset"
  },
  tickOpacity: {
    part: "ticks",
    vgProp: "opacity"
  },
  tickSize: null,
  tickWidth: {
    part: "ticks",
    vgProp: "strokeWidth"
  }
};
function isConditionalAxisValue(v) {
  return v === null || v === void 0 ? void 0 : v.condition;
}
const AXIS_PARTS = ["domain", "grid", "labels", "ticks", "title"];
const AXIS_PROPERTY_TYPE = {
  grid: "grid",
  gridCap: "grid",
  gridColor: "grid",
  gridDash: "grid",
  gridDashOffset: "grid",
  gridOpacity: "grid",
  gridScale: "grid",
  gridWidth: "grid",
  orient: "main",
  bandPosition: "both",
  aria: "main",
  description: "main",
  domain: "main",
  domainCap: "main",
  domainColor: "main",
  domainDash: "main",
  domainDashOffset: "main",
  domainOpacity: "main",
  domainWidth: "main",
  format: "main",
  formatType: "main",
  labelAlign: "main",
  labelAngle: "main",
  labelBaseline: "main",
  labelBound: "main",
  labelColor: "main",
  labelFlush: "main",
  labelFlushOffset: "main",
  labelFont: "main",
  labelFontSize: "main",
  labelFontStyle: "main",
  labelFontWeight: "main",
  labelLimit: "main",
  labelLineHeight: "main",
  labelOffset: "main",
  labelOpacity: "main",
  labelOverlap: "main",
  labelPadding: "main",
  labels: "main",
  labelSeparation: "main",
  maxExtent: "main",
  minExtent: "main",
  offset: "both",
  position: "main",
  tickCap: "main",
  tickColor: "main",
  tickDash: "main",
  tickDashOffset: "main",
  tickMinStep: "both",
  tickOffset: "both",
  tickOpacity: "main",
  tickRound: "both",
  ticks: "main",
  tickSize: "main",
  tickWidth: "both",
  title: "main",
  titleAlign: "main",
  titleAnchor: "main",
  titleAngle: "main",
  titleBaseline: "main",
  titleColor: "main",
  titleFont: "main",
  titleFontSize: "main",
  titleFontStyle: "main",
  titleFontWeight: "main",
  titleLimit: "main",
  titleLineHeight: "main",
  titleOpacity: "main",
  titlePadding: "main",
  titleX: "main",
  titleY: "main",
  encode: "both",
  scale: "both",
  tickBand: "both",
  tickCount: "both",
  tickExtra: "both",
  translate: "both",
  values: "both",
  zindex: "both"
  // this is actually set afterward, so it doesn't matter
};
const COMMON_AXIS_PROPERTIES_INDEX = {
  orient: 1,
  aria: 1,
  bandPosition: 1,
  description: 1,
  domain: 1,
  domainCap: 1,
  domainColor: 1,
  domainDash: 1,
  domainDashOffset: 1,
  domainOpacity: 1,
  domainWidth: 1,
  format: 1,
  formatType: 1,
  grid: 1,
  gridCap: 1,
  gridColor: 1,
  gridDash: 1,
  gridDashOffset: 1,
  gridOpacity: 1,
  gridWidth: 1,
  labelAlign: 1,
  labelAngle: 1,
  labelBaseline: 1,
  labelBound: 1,
  labelColor: 1,
  labelFlush: 1,
  labelFlushOffset: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelLineHeight: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labels: 1,
  labelSeparation: 1,
  maxExtent: 1,
  minExtent: 1,
  offset: 1,
  position: 1,
  tickBand: 1,
  tickCap: 1,
  tickColor: 1,
  tickCount: 1,
  tickDash: 1,
  tickDashOffset: 1,
  tickExtra: 1,
  tickMinStep: 1,
  tickOffset: 1,
  tickOpacity: 1,
  tickRound: 1,
  ticks: 1,
  tickSize: 1,
  tickWidth: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleAngle: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titlePadding: 1,
  titleX: 1,
  titleY: 1,
  translate: 1,
  values: 1,
  zindex: 1
};
const AXIS_PROPERTIES_INDEX = Object.assign(Object.assign({}, COMMON_AXIS_PROPERTIES_INDEX), { style: 1, labelExpr: 1, encoding: 1 });
function isAxisProperty(prop) {
  return !!AXIS_PROPERTIES_INDEX[prop];
}
const AXIS_CONFIGS_INDEX = {
  axis: 1,
  axisBand: 1,
  axisBottom: 1,
  axisDiscrete: 1,
  axisLeft: 1,
  axisPoint: 1,
  axisQuantitative: 1,
  axisRight: 1,
  axisTemporal: 1,
  axisTop: 1,
  axisX: 1,
  axisXBand: 1,
  axisXDiscrete: 1,
  axisXPoint: 1,
  axisXQuantitative: 1,
  axisXTemporal: 1,
  axisY: 1,
  axisYBand: 1,
  axisYDiscrete: 1,
  axisYPoint: 1,
  axisYQuantitative: 1,
  axisYTemporal: 1
};
const AXIS_CONFIGS = keys$1(AXIS_CONFIGS_INDEX);
function isUnitSpec(spec) {
  return "mark" in spec;
}
class CompositeMarkNormalizer {
  constructor(name, run2) {
    this.name = name;
    this.run = run2;
  }
  hasMatchingType(spec) {
    if (isUnitSpec(spec)) {
      return getMarkType(spec.mark) === this.name;
    }
    return false;
  }
}
var __rest$q = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function channelHasField(encoding, channel) {
  const channelDef = encoding && encoding[channel];
  if (channelDef) {
    if (isArray$1(channelDef)) {
      return some(channelDef, (fieldDef) => !!fieldDef.field);
    } else {
      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);
    }
  }
  return false;
}
function channelHasFieldOrDatum(encoding, channel) {
  const channelDef = encoding && encoding[channel];
  if (channelDef) {
    if (isArray$1(channelDef)) {
      return some(channelDef, (fieldDef) => !!fieldDef.field);
    } else {
      return isFieldDef(channelDef) || isDatumDef(channelDef) || hasConditionalFieldOrDatumDef(channelDef);
    }
  }
  return false;
}
function channelHasNestedOffsetScale(encoding, channel) {
  if (isXorY(channel)) {
    const fieldDef = encoding[channel];
    if ((isFieldDef(fieldDef) || isDatumDef(fieldDef)) && isDiscrete$1(fieldDef.type)) {
      const offsetChannel = getOffsetScaleChannel(channel);
      return channelHasFieldOrDatum(encoding, offsetChannel);
    }
  }
  return false;
}
function isAggregate$1(encoding) {
  return some(CHANNELS, (channel) => {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      if (isArray$1(channelDef)) {
        return some(channelDef, (fieldDef) => !!fieldDef.aggregate);
      } else {
        const fieldDef = getFieldDef(channelDef);
        return fieldDef && !!fieldDef.aggregate;
      }
    }
    return false;
  });
}
function extractTransformsFromEncoding(oldEncoding, config) {
  const groupby = [];
  const bins2 = [];
  const timeUnits2 = [];
  const aggregate = [];
  const encoding = {};
  forEach(oldEncoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      const { field: field2, aggregate: aggOp, bin: bin2, timeUnit } = channelDef, remaining = __rest$q(channelDef, ["field", "aggregate", "bin", "timeUnit"]);
      if (aggOp || timeUnit || bin2) {
        const guide = getGuide(channelDef);
        const isTitleDefined = guide === null || guide === void 0 ? void 0 : guide.title;
        let newField = vgField(channelDef, { forAs: true });
        const newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : { title: title(channelDef, config, { allowDisabling: true }) }), remaining), {
          // Always overwrite field
          field: newField
        });
        if (aggOp) {
          let op;
          if (isArgmaxDef(aggOp)) {
            op = "argmax";
            newField = vgField({ op: "argmax", field: aggOp.argmax }, { forAs: true });
            newFieldDef.field = `${newField}.${field2}`;
          } else if (isArgminDef(aggOp)) {
            op = "argmin";
            newField = vgField({ op: "argmin", field: aggOp.argmin }, { forAs: true });
            newFieldDef.field = `${newField}.${field2}`;
          } else if (aggOp !== "boxplot" && aggOp !== "errorbar" && aggOp !== "errorband") {
            op = aggOp;
          }
          if (op) {
            const aggregateEntry = {
              op,
              as: newField
            };
            if (field2) {
              aggregateEntry.field = field2;
            }
            aggregate.push(aggregateEntry);
          }
        } else {
          groupby.push(newField);
          if (isTypedFieldDef(channelDef) && isBinning(bin2)) {
            bins2.push({ bin: bin2, field: field2, as: newField });
            groupby.push(vgField(channelDef, { binSuffix: "end" }));
            if (binRequiresRange(channelDef, channel)) {
              groupby.push(vgField(channelDef, { binSuffix: "range" }));
            }
            if (isXorY(channel)) {
              const secondaryChannel = {
                field: `${newField}_end`
              };
              encoding[`${channel}2`] = secondaryChannel;
            }
            newFieldDef.bin = "binned";
            if (!isSecondaryRangeChannel(channel)) {
              newFieldDef["type"] = QUANTITATIVE;
            }
          } else if (timeUnit) {
            timeUnits2.push({
              timeUnit,
              field: field2,
              as: newField
            });
            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && "time";
            if (formatType) {
              if (channel === TEXT$1 || channel === TOOLTIP) {
                newFieldDef["formatType"] = formatType;
              } else if (isNonPositionScaleChannel(channel)) {
                newFieldDef["legend"] = Object.assign({ formatType }, newFieldDef["legend"]);
              } else if (isXorY(channel)) {
                newFieldDef["axis"] = Object.assign({ formatType }, newFieldDef["axis"]);
              }
            }
          }
        }
        encoding[channel] = newFieldDef;
      } else {
        groupby.push(field2);
        encoding[channel] = oldEncoding[channel];
      }
    } else {
      encoding[channel] = oldEncoding[channel];
    }
  });
  return {
    bins: bins2,
    timeUnits: timeUnits2,
    aggregate,
    groupby,
    encoding
  };
}
function markChannelCompatible(encoding, channel, mark2) {
  const markSupported = supportMark(channel, mark2);
  if (!markSupported) {
    return false;
  } else if (markSupported === "binned") {
    const primaryFieldDef = encoding[channel === X2 ? X : Y];
    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {
      return true;
    } else {
      return false;
    }
  }
  return true;
}
function initEncoding(encoding, mark2, filled, config) {
  const normalizedEncoding = {};
  for (const key2 of keys$1(encoding)) {
    if (!isChannel(key2)) {
      warn(invalidEncodingChannel(key2));
    }
  }
  for (let channel of UNIT_CHANNELS) {
    if (!encoding[channel]) {
      continue;
    }
    const channelDef = encoding[channel];
    if (isXorYOffset(channel)) {
      const mainChannel = getMainChannelFromOffsetChannel(channel);
      const positionDef = normalizedEncoding[mainChannel];
      if (isFieldDef(positionDef)) {
        if (isContinuous(positionDef.type)) {
          if (isFieldDef(channelDef)) {
            warn(offsetNestedInsideContinuousPositionScaleDropped(mainChannel));
            continue;
          }
        }
      } else {
        channel = mainChannel;
        warn(replaceOffsetWithMainChannel(mainChannel));
      }
    }
    if (channel === "angle" && mark2 === "arc" && !encoding.theta) {
      warn(REPLACE_ANGLE_WITH_THETA);
      channel = THETA;
    }
    if (!markChannelCompatible(encoding, channel, mark2)) {
      warn(incompatibleChannel(channel, mark2));
      continue;
    }
    if (channel === SIZE && mark2 === "line") {
      const fieldDef = getFieldDef(encoding[channel]);
      if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.aggregate) {
        warn(LINE_WITH_VARYING_SIZE);
        continue;
      }
    }
    if (channel === COLOR && (filled ? "fill" in encoding : "stroke" in encoding)) {
      warn(droppingColor("encoding", { fill: "fill" in encoding, stroke: "stroke" in encoding }));
      continue;
    }
    if (channel === DETAIL || channel === ORDER && !isArray$1(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray$1(channelDef)) {
      if (channelDef) {
        normalizedEncoding[channel] = array$5(channelDef).reduce((defs, fieldDef) => {
          if (!isFieldDef(fieldDef)) {
            warn(emptyFieldDef(fieldDef, channel));
          } else {
            defs.push(initFieldDef(fieldDef, channel));
          }
          return defs;
        }, []);
      }
    } else {
      if (channel === TOOLTIP && channelDef === null) {
        normalizedEncoding[channel] = null;
      } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {
        warn(emptyFieldDef(channelDef, channel));
        continue;
      }
      normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);
    }
  }
  return normalizedEncoding;
}
function normalizeEncoding(encoding, config) {
  const normalizedEncoding = {};
  for (const channel of keys$1(encoding)) {
    const newChannelDef = initChannelDef(encoding[channel], channel, config, { compositeMark: true });
    normalizedEncoding[channel] = newChannelDef;
  }
  return normalizedEncoding;
}
function fieldDefs(encoding) {
  const arr = [];
  for (const channel of keys$1(encoding)) {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      const channelDefArray = array$5(channelDef);
      for (const def2 of channelDefArray) {
        if (isFieldDef(def2)) {
          arr.push(def2);
        } else if (hasConditionalFieldDef(def2)) {
          arr.push(def2.condition);
        }
      }
    }
  }
  return arr;
}
function forEach(mapping, f, thisArg) {
  if (!mapping) {
    return;
  }
  for (const channel of keys$1(mapping)) {
    const el = mapping[channel];
    if (isArray$1(el)) {
      for (const channelDef of el) {
        f.call(thisArg, channelDef, channel);
      }
    } else {
      f.call(thisArg, el, channel);
    }
  }
}
function reduce(mapping, f, init2, thisArg) {
  if (!mapping) {
    return init2;
  }
  return keys$1(mapping).reduce((r2, channel) => {
    const map2 = mapping[channel];
    if (isArray$1(map2)) {
      return map2.reduce((r1, channelDef) => {
        return f.call(thisArg, r1, channelDef, channel);
      }, r2);
    } else {
      return f.call(thisArg, r2, map2, channel);
    }
  }, init2);
}
function pathGroupingFields(mark2, encoding) {
  return keys$1(encoding).reduce((details, channel) => {
    switch (channel) {
      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, aria label, cursor should not cause lines to group
      case X:
      case Y:
      case HREF:
      case DESCRIPTION:
      case URL$1:
      case X2:
      case Y2:
      case XOFFSET:
      case YOFFSET:
      case THETA:
      case THETA2:
      case RADIUS:
      case RADIUS2:
      // falls through
      case LATITUDE:
      case LONGITUDE:
      case LATITUDE2:
      case LONGITUDE2:
      // TODO: case 'cursor':
      // text, shape, shouldn't be a part of line/trail/area [falls through]
      case TEXT$1:
      case SHAPE:
      case ANGLE:
      // falls through
      // tooltip fields should not be added to group by [falls through]
      case TOOLTIP:
        return details;
      case ORDER:
        if (mark2 === "line" || mark2 === "trail") {
          return details;
        }
      // but order should group area for stacking (falls through)
      case DETAIL:
      case KEY: {
        const channelDef = encoding[channel];
        if (isArray$1(channelDef) || isFieldDef(channelDef)) {
          for (const fieldDef of array$5(channelDef)) {
            if (!fieldDef.aggregate) {
              details.push(vgField(fieldDef, {}));
            }
          }
        }
        return details;
      }
      case SIZE:
        if (mark2 === "trail") {
          return details;
        }
      // For line, size should group lines.
      // falls through
      case COLOR:
      case FILL:
      case STROKE:
      case OPACITY:
      case FILLOPACITY:
      case STROKEOPACITY:
      case STROKEDASH:
      case STROKEWIDTH: {
        const fieldDef = getFieldDef(encoding[channel]);
        if (fieldDef && !fieldDef.aggregate) {
          details.push(vgField(fieldDef, {}));
        }
        return details;
      }
    }
  }, []);
}
var __rest$p = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function filterTooltipWithAggregatedField(oldEncoding) {
  const { tooltip: tooltip2 } = oldEncoding, filteredEncoding = __rest$p(oldEncoding, ["tooltip"]);
  if (!tooltip2) {
    return { filteredEncoding };
  }
  let customTooltipWithAggregatedField;
  let customTooltipWithoutAggregatedField;
  if (isArray$1(tooltip2)) {
    for (const t4 of tooltip2) {
      if (t4.aggregate) {
        if (!customTooltipWithAggregatedField) {
          customTooltipWithAggregatedField = [];
        }
        customTooltipWithAggregatedField.push(t4);
      } else {
        if (!customTooltipWithoutAggregatedField) {
          customTooltipWithoutAggregatedField = [];
        }
        customTooltipWithoutAggregatedField.push(t4);
      }
    }
    if (customTooltipWithAggregatedField) {
      filteredEncoding.tooltip = customTooltipWithAggregatedField;
    }
  } else {
    if (tooltip2["aggregate"]) {
      filteredEncoding.tooltip = tooltip2;
    } else {
      customTooltipWithoutAggregatedField = tooltip2;
    }
  }
  if (isArray$1(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {
    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];
  }
  return { customTooltipWithoutAggregatedField, filteredEncoding };
}
function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {
  if ("tooltip" in encodingWithoutContinuousAxis) {
    return { tooltip: encodingWithoutContinuousAxis.tooltip };
  }
  const fiveSummaryTooltip = tooltipSummary.map(({ fieldPrefix, titlePrefix }) => {
    const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : "";
    return {
      field: fieldPrefix + continuousAxisChannelDef.field,
      type: continuousAxisChannelDef.type,
      title: isSignalRef(titlePrefix) ? { signal: `${titlePrefix}"${escape(mainTitle)}"` } : titlePrefix + mainTitle
    };
  });
  const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);
  return {
    tooltip: [
      ...fiveSummaryTooltip,
      // need to cast because TextFieldDef supports fewer types of bin
      ...unique(tooltipFieldDefs, hash)
    ]
  };
}
function getTitle(continuousAxisChannelDef) {
  const { title: title2, field: field2 } = continuousAxisChannelDef;
  return getFirstDefined(title2, field2);
}
function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {
  const { scale: scale2, axis } = continuousAxisChannelDef;
  return ({ partName, mark: mark2, positionPrefix, endPositionPrefix = void 0, extraEncoding = {} }) => {
    const title2 = getTitle(continuousAxisChannelDef);
    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {
      mark: mark2,
      encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: `${positionPrefix}_${continuousAxisChannelDef.field}`, type: continuousAxisChannelDef.type }, title2 !== void 0 ? { title: title2 } : {}), scale2 !== void 0 ? { scale: scale2 } : {}), axis !== void 0 ? { axis } : {}) }, isString(endPositionPrefix) ? {
        [`${continuousAxis}2`]: {
          field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`
        }
      } : {}), sharedEncoding), extraEncoding)
    });
  };
}
function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {
  const { clip: clip2, color: color2, opacity: opacity2 } = markDef;
  const mark2 = markDef.type;
  if (markDef[part] || markDef[part] === void 0 && compositeMarkConfig[part]) {
    return [
      Object.assign(Object.assign({}, partBaseSpec), { mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip2 ? { clip: clip2 } : {}), color2 ? { color: color2 } : {}), opacity2 ? { opacity: opacity2 } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : { type: partBaseSpec.mark }), { style: `${mark2}-${String(part)}` }), isBoolean$2(markDef[part]) ? {} : markDef[part]) })
    ];
  }
  return [];
}
function compositeMarkContinuousAxis(spec, orient2, compositeMark) {
  const { encoding } = spec;
  const continuousAxis = orient2 === "vertical" ? "y" : "x";
  const continuousAxisChannelDef = encoding[continuousAxis];
  const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];
  const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];
  const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];
  return {
    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),
    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),
    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),
    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),
    continuousAxis
  };
}
function filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {
  if (continuousAxisChannelDef === null || continuousAxisChannelDef === void 0 ? void 0 : continuousAxisChannelDef.aggregate) {
    const { aggregate } = continuousAxisChannelDef, continuousAxisWithoutAggregate = __rest$p(continuousAxisChannelDef, ["aggregate"]);
    if (aggregate !== compositeMark) {
      warn(errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));
    }
    return continuousAxisWithoutAggregate;
  } else {
    return continuousAxisChannelDef;
  }
}
function compositeMarkOrient(spec, compositeMark) {
  const { mark: mark2, encoding } = spec;
  const { x: x2, y: y2 } = encoding;
  if (isMarkDef(mark2) && mark2.orient) {
    return mark2.orient;
  }
  if (isContinuousFieldOrDatumDef(x2)) {
    if (isContinuousFieldOrDatumDef(y2)) {
      const xAggregate = isFieldDef(x2) && x2.aggregate;
      const yAggregate = isFieldDef(y2) && y2.aggregate;
      if (!xAggregate && yAggregate === compositeMark) {
        return "vertical";
      } else if (!yAggregate && xAggregate === compositeMark) {
        return "horizontal";
      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {
        throw new Error("Both x and y cannot have aggregate");
      } else {
        if (isFieldOrDatumDefForTimeFormat(y2) && !isFieldOrDatumDefForTimeFormat(x2)) {
          return "horizontal";
        }
        return "vertical";
      }
    }
    return "horizontal";
  } else if (isContinuousFieldOrDatumDef(y2)) {
    return "vertical";
  } else {
    throw new Error(`Need a valid continuous axis for ${compositeMark}s`);
  }
}
var __rest$o = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
const BOXPLOT = "boxplot";
const BOXPLOT_PARTS = ["box", "median", "outliers", "rule", "ticks"];
const boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);
function getBoxPlotType(extent2) {
  if (isNumber$1(extent2)) {
    return "tukey";
  }
  return extent2;
}
function normalizeBoxPlot(spec, { config }) {
  var _a, _b;
  spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });
  const { mark: mark2, encoding: _encoding, params: params2, projection: _p } = spec, outerSpec = __rest$o(spec, ["mark", "encoding", "params", "projection"]);
  const markDef = isMarkDef(mark2) ? mark2 : { type: mark2 };
  if (params2) {
    warn(selectionNotSupported("boxplot"));
  }
  const extent2 = (_a = markDef.extent) !== null && _a !== void 0 ? _a : config.boxplot.extent;
  const sizeValue = getMarkPropOrConfig(
    "size",
    markDef,
    // TODO: https://github.com/vega/vega-lite/issues/6245
    config
  );
  const boxPlotType = getBoxPlotType(extent2);
  const { bins: bins2, timeUnits: timeUnits2, transform: transform2, continuousAxisChannelDef, continuousAxis, groupby, aggregate, encodingWithoutContinuousAxis, ticksOrient, boxOrient, customTooltipWithoutAggregatedField } = boxParams(spec, extent2, config);
  const { color: color2, size } = encodingWithoutContinuousAxis, encodingWithoutSizeColorAndContinuousAxis = __rest$o(encodingWithoutContinuousAxis, ["color", "size"]);
  const makeBoxPlotPart = (sharedEncoding) => {
    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);
  };
  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);
  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);
  const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? { size } : {}));
  const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([
    { fieldPrefix: boxPlotType === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
    { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
    { fieldPrefix: "mid_box_", titlePrefix: "Median" },
    { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
    { fieldPrefix: boxPlotType === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
  ], continuousAxisChannelDef, encodingWithoutContinuousAxis);
  const endTick = { type: "tick", color: "black", opacity: 1, orient: ticksOrient, invalid: null, aria: false };
  const whiskerTooltipEncoding = boxPlotType === "min-max" ? fiveSummaryTooltipEncoding : (
    // for tukey / k-IQR, just show upper/lower-whisker
    getCompositeMarkTooltip([
      { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
      { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
    ], continuousAxisChannelDef, encodingWithoutContinuousAxis)
  );
  const whiskerLayers = [
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: { type: "rule", invalid: null, aria: false },
      positionPrefix: "lower_whisker",
      endPositionPrefix: "lower_box",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: { type: "rule", invalid: null, aria: false },
      positionPrefix: "upper_box",
      endPositionPrefix: "upper_whisker",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "lower_whisker",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "upper_whisker",
      extraEncoding: whiskerTooltipEncoding
    })
  ];
  const boxLayers = [
    ...boxPlotType !== "tukey" ? whiskerLayers : [],
    ...makeBoxPlotBox({
      partName: "box",
      mark: Object.assign(Object.assign({ type: "bar" }, sizeValue ? { size: sizeValue } : {}), { orient: boxOrient, invalid: null, ariaRoleDescription: "box" }),
      positionPrefix: "lower_box",
      endPositionPrefix: "upper_box",
      extraEncoding: fiveSummaryTooltipEncoding
    }),
    ...makeBoxPlotMidTick({
      partName: "median",
      mark: Object.assign(Object.assign(Object.assign({ type: "tick", invalid: null }, isObject$1(config.boxplot.median) && config.boxplot.median.color ? { color: config.boxplot.median.color } : {}), sizeValue ? { size: sizeValue } : {}), { orient: ticksOrient, aria: false }),
      positionPrefix: "mid_box",
      extraEncoding: fiveSummaryTooltipEncoding
    })
  ];
  if (boxPlotType === "min-max") {
    return Object.assign(Object.assign({}, outerSpec), { transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform2), layer: boxLayers });
  }
  const lowerBoxExpr = `datum["lower_box_${continuousAxisChannelDef.field}"]`;
  const upperBoxExpr = `datum["upper_box_${continuousAxisChannelDef.field}"]`;
  const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;
  const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent2} * ${iqrExpr}`;
  const upperWhiskerExpr = `${upperBoxExpr} + ${extent2} * ${iqrExpr}`;
  const fieldExpr2 = `datum["${continuousAxisChannelDef.field}"]`;
  const joinaggregateTransform = {
    joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),
    groupby
  };
  const filteredWhiskerSpec = {
    transform: [
      {
        filter: `(${lowerWhiskerExpr} <= ${fieldExpr2}) && (${fieldExpr2} <= ${upperWhiskerExpr})`
      },
      {
        aggregate: [
          {
            op: "min",
            field: continuousAxisChannelDef.field,
            as: `lower_whisker_${continuousAxisChannelDef.field}`
          },
          {
            op: "max",
            field: continuousAxisChannelDef.field,
            as: `upper_whisker_${continuousAxisChannelDef.field}`
          },
          // preserve lower_box / upper_box
          {
            op: "min",
            field: `lower_box_${continuousAxisChannelDef.field}`,
            as: `lower_box_${continuousAxisChannelDef.field}`
          },
          {
            op: "max",
            field: `upper_box_${continuousAxisChannelDef.field}`,
            as: `upper_box_${continuousAxisChannelDef.field}`
          },
          ...aggregate
        ],
        groupby
      }
    ],
    layer: whiskerLayers
  };
  const { tooltip: tooltip2 } = encodingWithoutSizeColorAndContinuousAxis, encodingWithoutSizeColorContinuousAxisAndTooltip = __rest$o(encodingWithoutSizeColorAndContinuousAxis, ["tooltip"]);
  const { scale: scale2, axis } = continuousAxisChannelDef;
  const title2 = getTitle(continuousAxisChannelDef);
  const axisWithoutTitle = omit(axis, ["title"]);
  const outlierLayersMixins = partLayerMixins(markDef, "outliers", config.boxplot, {
    transform: [{ filter: `(${fieldExpr2} < ${lowerWhiskerExpr}) || (${fieldExpr2} > ${upperWhiskerExpr})` }],
    mark: "point",
    encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: continuousAxisChannelDef.field, type: continuousAxisChannelDef.type }, title2 !== void 0 ? { title: title2 } : {}), scale2 !== void 0 ? { scale: scale2 } : {}), isEmpty(axisWithoutTitle) ? {} : { axis: axisWithoutTitle }) }, encodingWithoutSizeColorContinuousAxisAndTooltip), color2 ? { color: color2 } : {}), customTooltipWithoutAggregatedField ? { tooltip: customTooltipWithoutAggregatedField } : {})
  })[0];
  let filteredLayersMixins;
  const filteredLayersMixinsTransforms = [...bins2, ...timeUnits2, joinaggregateTransform];
  if (outlierLayersMixins) {
    filteredLayersMixins = {
      transform: filteredLayersMixinsTransforms,
      layer: [outlierLayersMixins, filteredWhiskerSpec]
    };
  } else {
    filteredLayersMixins = filteredWhiskerSpec;
    filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);
  }
  return Object.assign(Object.assign({}, outerSpec), { layer: [
    filteredLayersMixins,
    {
      // boxplot
      transform: transform2,
      layer: boxLayers
    }
  ] });
}
function boxParamsQuartiles(continousAxisField) {
  return [
    {
      op: "q1",
      field: continousAxisField,
      as: `lower_box_${continousAxisField}`
    },
    {
      op: "q3",
      field: continousAxisField,
      as: `upper_box_${continousAxisField}`
    }
  ];
}
function boxParams(spec, extent2, config) {
  const orient2 = compositeMarkOrient(spec, BOXPLOT);
  const { continuousAxisChannelDef, continuousAxis } = compositeMarkContinuousAxis(spec, orient2, BOXPLOT);
  const continuousFieldName = continuousAxisChannelDef.field;
  const boxPlotType = getBoxPlotType(extent2);
  const boxplotSpecificAggregate = [
    ...boxParamsQuartiles(continuousFieldName),
    {
      op: "median",
      field: continuousFieldName,
      as: `mid_box_${continuousFieldName}`
    },
    {
      op: "min",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "lower_whisker_" : "min_") + continuousFieldName
    },
    {
      op: "max",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "upper_whisker_" : "max_") + continuousFieldName
    }
  ];
  const postAggregateCalculates = boxPlotType === "min-max" || boxPlotType === "tukey" ? [] : [
    // This is for the  original k-IQR, which we do not expose
    {
      calculate: `datum["upper_box_${continuousFieldName}"] - datum["lower_box_${continuousFieldName}"]`,
      as: `iqr_${continuousFieldName}`
    },
    {
      calculate: `min(datum["upper_box_${continuousFieldName}"] + datum["iqr_${continuousFieldName}"] * ${extent2}, datum["max_${continuousFieldName}"])`,
      as: `upper_whisker_${continuousFieldName}`
    },
    {
      calculate: `max(datum["lower_box_${continuousFieldName}"] - datum["iqr_${continuousFieldName}"] * ${extent2}, datum["min_${continuousFieldName}"])`,
      as: `lower_whisker_${continuousFieldName}`
    }
  ];
  const _a = spec.encoding, _b = continuousAxis;
  _a[_b];
  const oldEncodingWithoutContinuousAxis = __rest$o(_a, [typeof _b === "symbol" ? _b : _b + ""]);
  const { customTooltipWithoutAggregatedField, filteredEncoding } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);
  const { bins: bins2, timeUnits: timeUnits2, aggregate, groupby, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(filteredEncoding, config);
  const ticksOrient = orient2 === "vertical" ? "horizontal" : "vertical";
  const boxOrient = orient2;
  const transform2 = [
    ...bins2,
    ...timeUnits2,
    {
      aggregate: [...aggregate, ...boxplotSpecificAggregate],
      groupby
    },
    ...postAggregateCalculates
  ];
  return {
    bins: bins2,
    timeUnits: timeUnits2,
    transform: transform2,
    groupby,
    aggregate,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient,
    boxOrient,
    customTooltipWithoutAggregatedField
  };
}
var __rest$n = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
const ERRORBAR = "errorbar";
const ERRORBAR_PARTS = ["ticks", "rule"];
const errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);
function normalizeErrorBar(spec, { config }) {
  spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });
  const { transform: transform2, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAR, config);
  delete encodingWithoutContinuousAxis["size"];
  const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);
  const thickness = markDef.thickness;
  const size = markDef.size;
  const tick2 = Object.assign(Object.assign({ type: "tick", orient: ticksOrient, aria: false }, thickness !== void 0 ? { thickness } : {}), size !== void 0 ? { size } : {});
  const layer = [
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "lower",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "upper",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "rule",
      mark: Object.assign({ type: "rule", ariaRoleDescription: "errorbar" }, thickness !== void 0 ? { size: thickness } : {}),
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    })
  ];
  return Object.assign(Object.assign(Object.assign({}, outerSpec), { transform: transform2 }), layer.length > 1 ? { layer } : Object.assign({}, layer[0]));
}
function errorBarOrientAndInputType(spec, compositeMark) {
  const { encoding } = spec;
  if (errorBarIsInputTypeRaw(encoding)) {
    return {
      orient: compositeMarkOrient(spec, compositeMark),
      inputType: "raw"
    };
  }
  const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);
  const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);
  const x2 = encoding.x;
  const y2 = encoding.y;
  if (isTypeAggregatedUpperLower) {
    if (isTypeAggregatedError) {
      throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);
    }
    const x22 = encoding.x2;
    const y22 = encoding.y2;
    if (isFieldOrDatumDef(x22) && isFieldOrDatumDef(y22)) {
      throw new Error(`${compositeMark} cannot have both x2 and y2`);
    } else if (isFieldOrDatumDef(x22)) {
      if (isContinuousFieldOrDatumDef(x2)) {
        return { orient: "horizontal", inputType: "aggregated-upper-lower" };
      } else {
        throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);
      }
    } else if (isFieldOrDatumDef(y22)) {
      if (isContinuousFieldOrDatumDef(y2)) {
        return { orient: "vertical", inputType: "aggregated-upper-lower" };
      } else {
        throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);
      }
    }
    throw new Error("No ranged axis");
  } else {
    const xError = encoding.xError;
    const xError2 = encoding.xError2;
    const yError = encoding.yError;
    const yError2 = encoding.yError2;
    if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {
      throw new Error(`${compositeMark} cannot have xError2 without xError`);
    }
    if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have yError2 without yError`);
    }
    if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);
    } else if (isFieldOrDatumDef(xError)) {
      if (isContinuousFieldOrDatumDef(x2)) {
        return { orient: "horizontal", inputType: "aggregated-error" };
      } else {
        throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
      }
    } else if (isFieldOrDatumDef(yError)) {
      if (isContinuousFieldOrDatumDef(y2)) {
        return { orient: "vertical", inputType: "aggregated-error" };
      } else {
        throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
      }
    }
    throw new Error("No ranged axis");
  }
}
function errorBarIsInputTypeRaw(encoding) {
  return (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) && !isFieldOrDatumDef(encoding.x2) && !isFieldOrDatumDef(encoding.y2) && !isFieldOrDatumDef(encoding.xError) && !isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(encoding.yError) && !isFieldOrDatumDef(encoding.yError2);
}
function errorBarIsInputTypeAggregatedUpperLower(encoding) {
  return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);
}
function errorBarIsInputTypeAggregatedError(encoding) {
  return isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);
}
function errorBarParams(spec, compositeMark, config) {
  var _a;
  const { mark: mark2, encoding, params: params2, projection: _p } = spec, outerSpec = __rest$n(spec, ["mark", "encoding", "params", "projection"]);
  const markDef = isMarkDef(mark2) ? mark2 : { type: mark2 };
  if (params2) {
    warn(selectionNotSupported(compositeMark));
  }
  const { orient: orient2, inputType } = errorBarOrientAndInputType(spec, compositeMark);
  const { continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, continuousAxis } = compositeMarkContinuousAxis(spec, orient2, compositeMark);
  const { errorBarSpecificAggregate, postAggregateCalculates, tooltipSummary, tooltipTitleWithFieldName } = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);
  const _b = encoding, _c2 = continuousAxis;
  _b[_c2];
  const _d2 = continuousAxis === "x" ? "x2" : "y2";
  _b[_d2];
  const _e = continuousAxis === "x" ? "xError" : "yError";
  _b[_e];
  const _f2 = continuousAxis === "x" ? "xError2" : "yError2";
  _b[_f2];
  const oldEncodingWithoutContinuousAxis = __rest$n(_b, [typeof _c2 === "symbol" ? _c2 : _c2 + "", typeof _d2 === "symbol" ? _d2 : _d2 + "", typeof _e === "symbol" ? _e : _e + "", typeof _f2 === "symbol" ? _f2 : _f2 + ""]);
  const { bins: bins2, timeUnits: timeUnits2, aggregate: oldAggregate, groupby: oldGroupBy, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);
  const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];
  const groupby = inputType !== "raw" ? [] : oldGroupBy;
  const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);
  return {
    transform: [
      ...(_a = outerSpec.transform) !== null && _a !== void 0 ? _a : [],
      ...bins2,
      ...timeUnits2,
      ...aggregate.length === 0 ? [] : [{ aggregate, groupby }],
      ...postAggregateCalculates
    ],
    groupby,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient: orient2 === "vertical" ? "horizontal" : "vertical",
    markDef,
    outerSpec,
    tooltipEncoding
  };
}
function errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {
  let errorBarSpecificAggregate = [];
  let postAggregateCalculates = [];
  const continuousFieldName = continuousAxisChannelDef.field;
  let tooltipSummary;
  let tooltipTitleWithFieldName = false;
  if (inputType === "raw") {
    const center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === "iqr" ? "median" : "mean" : config.errorbar.center;
    const extent2 = markDef.extent ? markDef.extent : center === "mean" ? "stderr" : "iqr";
    if (center === "median" !== (extent2 === "iqr")) {
      warn(errorBarCenterIsUsedWithWrongExtent(center, extent2, compositeMark));
    }
    if (extent2 === "stderr" || extent2 === "stdev") {
      errorBarSpecificAggregate = [
        { op: extent2, field: continuousFieldName, as: `extent_${continuousFieldName}` },
        { op: center, field: continuousFieldName, as: `center_${continuousFieldName}` }
      ];
      postAggregateCalculates = [
        {
          calculate: `datum["center_${continuousFieldName}"] + datum["extent_${continuousFieldName}"]`,
          as: `upper_${continuousFieldName}`
        },
        {
          calculate: `datum["center_${continuousFieldName}"] - datum["extent_${continuousFieldName}"]`,
          as: `lower_${continuousFieldName}`
        }
      ];
      tooltipSummary = [
        { fieldPrefix: "center_", titlePrefix: titleCase(center) },
        { fieldPrefix: "upper_", titlePrefix: getTitlePrefix(center, extent2, "+") },
        { fieldPrefix: "lower_", titlePrefix: getTitlePrefix(center, extent2, "-") }
      ];
      tooltipTitleWithFieldName = true;
    } else {
      let centerOp;
      let lowerExtentOp;
      let upperExtentOp;
      if (extent2 === "ci") {
        centerOp = "mean";
        lowerExtentOp = "ci0";
        upperExtentOp = "ci1";
      } else {
        centerOp = "median";
        lowerExtentOp = "q1";
        upperExtentOp = "q3";
      }
      errorBarSpecificAggregate = [
        { op: lowerExtentOp, field: continuousFieldName, as: `lower_${continuousFieldName}` },
        { op: upperExtentOp, field: continuousFieldName, as: `upper_${continuousFieldName}` },
        { op: centerOp, field: continuousFieldName, as: `center_${continuousFieldName}` }
      ];
      tooltipSummary = [
        {
          fieldPrefix: "upper_",
          titlePrefix: title({ field: continuousFieldName, aggregate: upperExtentOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "lower_",
          titlePrefix: title({ field: continuousFieldName, aggregate: lowerExtentOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "center_",
          titlePrefix: title({ field: continuousFieldName, aggregate: centerOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        }
      ];
    }
  } else {
    if (markDef.center || markDef.extent) {
      warn(errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));
    }
    if (inputType === "aggregated-upper-lower") {
      tooltipSummary = [];
      postAggregateCalculates = [
        { calculate: `datum["${continuousAxisChannelDef2.field}"]`, as: `upper_${continuousFieldName}` },
        { calculate: `datum["${continuousFieldName}"]`, as: `lower_${continuousFieldName}` }
      ];
    } else if (inputType === "aggregated-error") {
      tooltipSummary = [{ fieldPrefix: "", titlePrefix: continuousFieldName }];
      postAggregateCalculates = [
        {
          calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError.field}"]`,
          as: `upper_${continuousFieldName}`
        }
      ];
      if (continuousAxisChannelDefError2) {
        postAggregateCalculates.push({
          calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError2.field}"]`,
          as: `lower_${continuousFieldName}`
        });
      } else {
        postAggregateCalculates.push({
          calculate: `datum["${continuousFieldName}"] - datum["${continuousAxisChannelDefError.field}"]`,
          as: `lower_${continuousFieldName}`
        });
      }
    }
    for (const postAggregateCalculate of postAggregateCalculates) {
      tooltipSummary.push({
        fieldPrefix: postAggregateCalculate.as.substring(0, 6),
        titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum["', ""), '"]', "")
      });
    }
  }
  return { postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName };
}
function getTitlePrefix(center, extent2, operation) {
  return `${titleCase(center)} ${operation} ${extent2}`;
}
const ERRORBAND = "errorband";
const ERRORBAND_PARTS = ["band", "borders"];
const errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);
function normalizeErrorBand(spec, { config }) {
  spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });
  const { transform: transform2, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAND, config);
  const errorBandDef = markDef;
  const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);
  const is2D = spec.encoding.x !== void 0 && spec.encoding.y !== void 0;
  let bandMark = { type: is2D ? "area" : "rect" };
  let bordersMark = { type: is2D ? "line" : "rule" };
  const interpolate2 = Object.assign(Object.assign({}, errorBandDef.interpolate ? { interpolate: errorBandDef.interpolate } : {}), errorBandDef.tension && errorBandDef.interpolate ? { tension: errorBandDef.tension } : {});
  if (is2D) {
    bandMark = Object.assign(Object.assign(Object.assign({}, bandMark), interpolate2), { ariaRoleDescription: "errorband" });
    bordersMark = Object.assign(Object.assign(Object.assign({}, bordersMark), interpolate2), { aria: false });
  } else if (errorBandDef.interpolate) {
    warn(errorBand1DNotSupport("interpolate"));
  } else if (errorBandDef.tension) {
    warn(errorBand1DNotSupport("tension"));
  }
  return Object.assign(Object.assign({}, outerSpec), { transform: transform2, layer: [
    ...makeErrorBandPart({
      partName: "band",
      mark: bandMark,
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBandPart({
      partName: "borders",
      mark: bordersMark,
      positionPrefix: "lower",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBandPart({
      partName: "borders",
      mark: bordersMark,
      positionPrefix: "upper",
      extraEncoding: tooltipEncoding
    })
  ] });
}
const compositeMarkRegistry = {};
function add(mark2, run2, parts) {
  const normalizer = new CompositeMarkNormalizer(mark2, run2);
  compositeMarkRegistry[mark2] = { normalizer, parts };
}
function getAllCompositeMarks() {
  return keys$1(compositeMarkRegistry);
}
add(BOXPLOT, normalizeBoxPlot, BOXPLOT_PARTS);
add(ERRORBAR, normalizeErrorBar, ERRORBAR_PARTS);
add(ERRORBAND, normalizeErrorBand, ERRORBAND_PARTS);
const VL_ONLY_LEGEND_CONFIG = [
  "gradientHorizontalMaxLength",
  "gradientHorizontalMinLength",
  "gradientVerticalMaxLength",
  "gradientVerticalMinLength",
  "unselectedOpacity"
];
const HEADER_TITLE_PROPERTIES_MAP = {
  titleAlign: "align",
  titleAnchor: "anchor",
  titleAngle: "angle",
  titleBaseline: "baseline",
  titleColor: "color",
  titleFont: "font",
  titleFontSize: "fontSize",
  titleFontStyle: "fontStyle",
  titleFontWeight: "fontWeight",
  titleLimit: "limit",
  titleLineHeight: "lineHeight",
  titleOrient: "orient",
  titlePadding: "offset"
};
const HEADER_LABEL_PROPERTIES_MAP = {
  labelAlign: "align",
  labelAnchor: "anchor",
  labelAngle: "angle",
  labelBaseline: "baseline",
  labelColor: "color",
  labelFont: "font",
  labelFontSize: "fontSize",
  labelFontStyle: "fontStyle",
  labelFontWeight: "fontWeight",
  labelLimit: "limit",
  labelLineHeight: "lineHeight",
  labelOrient: "orient",
  labelPadding: "offset"
};
const HEADER_TITLE_PROPERTIES = keys$1(HEADER_TITLE_PROPERTIES_MAP);
const HEADER_LABEL_PROPERTIES = keys$1(HEADER_LABEL_PROPERTIES_MAP);
const HEADER_CONFIGS_INDEX = {
  header: 1,
  headerRow: 1,
  headerColumn: 1,
  headerFacet: 1
};
const HEADER_CONFIGS = keys$1(HEADER_CONFIGS_INDEX);
const LEGEND_SCALE_CHANNELS = [
  "size",
  "shape",
  "fill",
  "stroke",
  "strokeDash",
  "strokeWidth",
  "opacity"
];
const defaultLegendConfig = {
  gradientHorizontalMaxLength: 200,
  gradientHorizontalMinLength: 100,
  gradientVerticalMaxLength: 200,
  gradientVerticalMinLength: 64,
  unselectedOpacity: 0.35
};
const COMMON_LEGEND_PROPERTY_INDEX = {
  aria: 1,
  clipHeight: 1,
  columnPadding: 1,
  columns: 1,
  cornerRadius: 1,
  description: 1,
  direction: 1,
  fillColor: 1,
  format: 1,
  formatType: 1,
  gradientLength: 1,
  gradientOpacity: 1,
  gradientStrokeColor: 1,
  gradientStrokeWidth: 1,
  gradientThickness: 1,
  gridAlign: 1,
  labelAlign: 1,
  labelBaseline: 1,
  labelColor: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labelSeparation: 1,
  legendX: 1,
  legendY: 1,
  offset: 1,
  orient: 1,
  padding: 1,
  rowPadding: 1,
  strokeColor: 1,
  symbolDash: 1,
  symbolDashOffset: 1,
  symbolFillColor: 1,
  symbolLimit: 1,
  symbolOffset: 1,
  symbolOpacity: 1,
  symbolSize: 1,
  symbolStrokeColor: 1,
  symbolStrokeWidth: 1,
  symbolType: 1,
  tickCount: 1,
  tickMinStep: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titleOrient: 1,
  titlePadding: 1,
  type: 1,
  values: 1,
  zindex: 1
};
const SELECTION_ID = "_vgsid_";
const defaultConfig$1 = {
  point: {
    on: "click",
    fields: [SELECTION_ID],
    toggle: "event.shiftKey",
    resolve: "global",
    clear: "dblclick"
  },
  interval: {
    on: "[mousedown, window:mouseup] > window:mousemove!",
    encodings: ["x", "y"],
    translate: "[mousedown, window:mouseup] > window:mousemove!",
    zoom: "wheel!",
    mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
    resolve: "global",
    clear: "dblclick"
  }
};
function isLegendBinding(bind2) {
  return bind2 === "legend" || !!(bind2 === null || bind2 === void 0 ? void 0 : bind2.legend);
}
function isLegendStreamBinding(bind2) {
  return isLegendBinding(bind2) && isObject$1(bind2);
}
function isSelectionParameter(param2) {
  return !!(param2 === null || param2 === void 0 ? void 0 : param2["select"]);
}
var __rest$m = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function assembleParameterSignals(params2) {
  const signals = [];
  for (const param2 of params2 || []) {
    if (isSelectionParameter(param2))
      continue;
    const { expr: expr2, bind: bind2 } = param2, rest = __rest$m(param2, ["expr", "bind"]);
    if (bind2 && expr2) {
      const signal = Object.assign(Object.assign({}, rest), { bind: bind2, init: expr2 });
      signals.push(signal);
    } else {
      const signal = Object.assign(Object.assign(Object.assign({}, rest), expr2 ? { update: expr2 } : {}), bind2 ? { bind: bind2 } : {});
      signals.push(signal);
    }
  }
  return signals;
}
function isAnyConcatSpec(spec) {
  return isVConcatSpec(spec) || isHConcatSpec(spec) || isConcatSpec(spec);
}
function isConcatSpec(spec) {
  return "concat" in spec;
}
function isVConcatSpec(spec) {
  return "vconcat" in spec;
}
function isHConcatSpec(spec) {
  return "hconcat" in spec;
}
function getStepFor({ step, offsetIsDiscrete }) {
  var _a;
  if (offsetIsDiscrete) {
    return (_a = step.for) !== null && _a !== void 0 ? _a : "offset";
  } else {
    return "position";
  }
}
function isStep(size) {
  return isObject$1(size) && size["step"] !== void 0;
}
function isFrameMixins(o) {
  return o["view"] || o["width"] || o["height"];
}
const DEFAULT_SPACING = 20;
const COMPOSITION_LAYOUT_INDEX = {
  align: 1,
  bounds: 1,
  center: 1,
  columns: 1,
  spacing: 1
};
const COMPOSITION_LAYOUT_PROPERTIES = keys$1(COMPOSITION_LAYOUT_INDEX);
function extractCompositionLayout(spec, specType, config) {
  var _a, _b;
  const compositionConfig = config[specType];
  const layout = {};
  const { spacing: spacingConfig, columns } = compositionConfig;
  if (spacingConfig !== void 0) {
    layout.spacing = spacingConfig;
  }
  if (columns !== void 0) {
    if (isFacetSpec(spec) && !isFacetMapping(spec.facet) || isConcatSpec(spec)) {
      layout.columns = columns;
    }
  }
  if (isVConcatSpec(spec)) {
    layout.columns = 1;
  }
  for (const prop of COMPOSITION_LAYOUT_PROPERTIES) {
    if (spec[prop] !== void 0) {
      if (prop === "spacing") {
        const spacing = spec[prop];
        layout[prop] = isNumber$1(spacing) ? spacing : {
          row: (_a = spacing.row) !== null && _a !== void 0 ? _a : spacingConfig,
          column: (_b = spacing.column) !== null && _b !== void 0 ? _b : spacingConfig
        };
      } else {
        layout[prop] = spec[prop];
      }
    }
  }
  return layout;
}
var __rest$l = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function getViewConfigContinuousSize(viewConfig, channel) {
  var _a;
  return (_a = viewConfig[channel]) !== null && _a !== void 0 ? _a : viewConfig[channel === "width" ? "continuousWidth" : "continuousHeight"];
}
function getViewConfigDiscreteStep(viewConfig, channel) {
  const size = getViewConfigDiscreteSize(viewConfig, channel);
  return isStep(size) ? size.step : DEFAULT_STEP;
}
function getViewConfigDiscreteSize(viewConfig, channel) {
  var _a;
  const size = (_a = viewConfig[channel]) !== null && _a !== void 0 ? _a : viewConfig[channel === "width" ? "discreteWidth" : "discreteHeight"];
  return getFirstDefined(size, { step: viewConfig.step });
}
const DEFAULT_STEP = 20;
const defaultViewConfig = {
  continuousWidth: 200,
  continuousHeight: 200,
  step: DEFAULT_STEP
};
const defaultConfig = {
  background: "white",
  padding: 5,
  timeFormat: "%b %d, %Y",
  countTitle: "Count of Records",
  view: defaultViewConfig,
  mark: defaultMarkConfig,
  arc: {},
  area: {},
  bar: defaultBarConfig,
  circle: {},
  geoshape: {},
  image: {},
  line: {},
  point: {},
  rect: defaultRectConfig,
  rule: { color: "black" },
  square: {},
  text: { color: "black" },
  tick: defaultTickConfig,
  trail: {},
  boxplot: {
    size: 14,
    extent: 1.5,
    box: {},
    median: { color: "white" },
    outliers: {},
    rule: {},
    ticks: null
  },
  errorbar: {
    center: "mean",
    rule: true,
    ticks: false
  },
  errorband: {
    band: {
      opacity: 0.3
    },
    borders: false
  },
  scale: defaultScaleConfig,
  projection: {},
  legend: defaultLegendConfig,
  header: { titlePadding: 10, labelPadding: 10 },
  headerColumn: {},
  headerRow: {},
  headerFacet: {},
  selection: defaultConfig$1,
  style: {},
  title: {},
  facet: { spacing: DEFAULT_SPACING },
  concat: { spacing: DEFAULT_SPACING },
  normalizedNumberFormat: ".0%"
};
const tab10 = [
  "#4c78a8",
  "#f58518",
  "#e45756",
  "#72b7b2",
  "#54a24b",
  "#eeca3b",
  "#b279a2",
  "#ff9da6",
  "#9d755d",
  "#bab0ac"
];
const DEFAULT_FONT_SIZE = {
  text: 11,
  guideLabel: 10,
  guideTitle: 11,
  groupTitle: 13,
  groupSubtitle: 12
};
const DEFAULT_COLOR = {
  blue: tab10[0],
  orange: tab10[1],
  red: tab10[2],
  teal: tab10[3],
  green: tab10[4],
  yellow: tab10[5],
  purple: tab10[6],
  pink: tab10[7],
  brown: tab10[8],
  gray0: "#000",
  gray1: "#111",
  gray2: "#222",
  gray3: "#333",
  gray4: "#444",
  gray5: "#555",
  gray6: "#666",
  gray7: "#777",
  gray8: "#888",
  gray9: "#999",
  gray10: "#aaa",
  gray11: "#bbb",
  gray12: "#ccc",
  gray13: "#ddd",
  gray14: "#eee",
  gray15: "#fff"
};
function colorSignalConfig(color2 = {}) {
  return {
    signals: [
      {
        name: "color",
        value: isObject$1(color2) ? Object.assign(Object.assign({}, DEFAULT_COLOR), color2) : DEFAULT_COLOR
      }
    ],
    mark: { color: { signal: "color.blue" } },
    rule: { color: { signal: "color.gray0" } },
    text: {
      color: { signal: "color.gray0" }
    },
    style: {
      "guide-label": {
        fill: { signal: "color.gray0" }
      },
      "guide-title": {
        fill: { signal: "color.gray0" }
      },
      "group-title": {
        fill: { signal: "color.gray0" }
      },
      "group-subtitle": {
        fill: { signal: "color.gray0" }
      },
      cell: {
        stroke: { signal: "color.gray8" }
      }
    },
    axis: {
      domainColor: { signal: "color.gray13" },
      gridColor: { signal: "color.gray8" },
      tickColor: { signal: "color.gray13" }
    },
    range: {
      category: [
        { signal: "color.blue" },
        { signal: "color.orange" },
        { signal: "color.red" },
        { signal: "color.teal" },
        { signal: "color.green" },
        { signal: "color.yellow" },
        { signal: "color.purple" },
        { signal: "color.pink" },
        { signal: "color.brown" },
        { signal: "color.grey8" }
      ]
    }
  };
}
function fontSizeSignalConfig(fontSize2) {
  return {
    signals: [
      {
        name: "fontSize",
        value: isObject$1(fontSize2) ? Object.assign(Object.assign({}, DEFAULT_FONT_SIZE), fontSize2) : DEFAULT_FONT_SIZE
      }
    ],
    text: {
      fontSize: { signal: "fontSize.text" }
    },
    style: {
      "guide-label": {
        fontSize: { signal: "fontSize.guideLabel" }
      },
      "guide-title": {
        fontSize: { signal: "fontSize.guideTitle" }
      },
      "group-title": {
        fontSize: { signal: "fontSize.groupTitle" }
      },
      "group-subtitle": {
        fontSize: { signal: "fontSize.groupSubtitle" }
      }
    }
  };
}
function fontConfig(font2) {
  return {
    text: { font: font2 },
    style: {
      "guide-label": { font: font2 },
      "guide-title": { font: font2 },
      "group-title": { font: font2 },
      "group-subtitle": { font: font2 }
    }
  };
}
function getAxisConfigInternal(axisConfig2) {
  const props = keys$1(axisConfig2 || {});
  const axisConfigInternal = {};
  for (const prop of props) {
    const val = axisConfig2[prop];
    axisConfigInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);
  }
  return axisConfigInternal;
}
function getStyleConfigInternal(styleConfig) {
  const props = keys$1(styleConfig);
  const styleConfigInternal = {};
  for (const prop of props) {
    styleConfigInternal[prop] = getAxisConfigInternal(styleConfig[prop]);
  }
  return styleConfigInternal;
}
const configPropsWithExpr = [
  ...MARK_CONFIGS,
  ...AXIS_CONFIGS,
  ...HEADER_CONFIGS,
  "background",
  "padding",
  "legend",
  "lineBreak",
  "scale",
  "style",
  "title",
  "view"
];
function initConfig(specifiedConfig = {}) {
  const { color: color2, font: font2, fontSize: fontSize2, selection } = specifiedConfig, restConfig = __rest$l(specifiedConfig, ["color", "font", "fontSize", "selection"]);
  const mergedConfig = mergeConfig({}, duplicate(defaultConfig), font2 ? fontConfig(font2) : {}, color2 ? colorSignalConfig(color2) : {}, fontSize2 ? fontSizeSignalConfig(fontSize2) : {}, restConfig || {});
  if (selection) {
    writeConfig(mergedConfig, "selection", selection, true);
  }
  const outputConfig = omit(mergedConfig, configPropsWithExpr);
  for (const prop of ["background", "lineBreak", "padding"]) {
    if (mergedConfig[prop]) {
      outputConfig[prop] = signalRefOrValue(mergedConfig[prop]);
    }
  }
  for (const markConfigType of MARK_CONFIGS) {
    if (mergedConfig[markConfigType]) {
      outputConfig[markConfigType] = replaceExprRef(mergedConfig[markConfigType]);
    }
  }
  for (const axisConfigType of AXIS_CONFIGS) {
    if (mergedConfig[axisConfigType]) {
      outputConfig[axisConfigType] = getAxisConfigInternal(mergedConfig[axisConfigType]);
    }
  }
  for (const headerConfigType of HEADER_CONFIGS) {
    if (mergedConfig[headerConfigType]) {
      outputConfig[headerConfigType] = replaceExprRef(mergedConfig[headerConfigType]);
    }
  }
  if (mergedConfig.legend) {
    outputConfig.legend = replaceExprRef(mergedConfig.legend);
  }
  if (mergedConfig.scale) {
    outputConfig.scale = replaceExprRef(mergedConfig.scale);
  }
  if (mergedConfig.style) {
    outputConfig.style = getStyleConfigInternal(mergedConfig.style);
  }
  if (mergedConfig.title) {
    outputConfig.title = replaceExprRef(mergedConfig.title);
  }
  if (mergedConfig.view) {
    outputConfig.view = replaceExprRef(mergedConfig.view);
  }
  return outputConfig;
}
const MARK_STYLES = /* @__PURE__ */ new Set(["view", ...PRIMITIVE_MARKS]);
const VL_ONLY_CONFIG_PROPERTIES = [
  "color",
  "fontSize",
  "background",
  "padding",
  "facet",
  "concat",
  "numberFormat",
  "numberFormatType",
  "normalizedNumberFormat",
  "normalizedNumberFormatType",
  "timeFormat",
  "countTitle",
  "header",
  "axisQuantitative",
  "axisTemporal",
  "axisDiscrete",
  "axisPoint",
  "axisXBand",
  "axisXPoint",
  "axisXDiscrete",
  "axisXQuantitative",
  "axisXTemporal",
  "axisYBand",
  "axisYPoint",
  "axisYDiscrete",
  "axisYQuantitative",
  "axisYTemporal",
  "scale",
  "selection",
  "overlay"
  // FIXME: Redesign and unhide this
];
const VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = Object.assign({ view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"] }, VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX);
function stripAndRedirectConfig(config) {
  config = duplicate(config);
  for (const prop of VL_ONLY_CONFIG_PROPERTIES) {
    delete config[prop];
  }
  if (config.axis) {
    for (const prop in config.axis) {
      if (isConditionalAxisValue(config.axis[prop])) {
        delete config.axis[prop];
      }
    }
  }
  if (config.legend) {
    for (const prop of VL_ONLY_LEGEND_CONFIG) {
      delete config.legend[prop];
    }
  }
  if (config.mark) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config.mark[prop];
    }
    if (config.mark.tooltip && isObject$1(config.mark.tooltip)) {
      delete config.mark.tooltip;
    }
  }
  if (config.params) {
    config.signals = (config.signals || []).concat(assembleParameterSignals(config.params));
    delete config.params;
  }
  for (const markType2 of MARK_STYLES) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config[markType2][prop];
    }
    const vlOnlyMarkSpecificConfigs = VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType2];
    if (vlOnlyMarkSpecificConfigs) {
      for (const prop of vlOnlyMarkSpecificConfigs) {
        delete config[markType2][prop];
      }
    }
    redirectConfigToStyleConfig(config, markType2);
  }
  for (const m2 of getAllCompositeMarks()) {
    delete config[m2];
  }
  redirectTitleConfig(config);
  for (const prop in config) {
    if (isObject$1(config[prop]) && isEmpty(config[prop])) {
      delete config[prop];
    }
  }
  return isEmpty(config) ? void 0 : config;
}
function redirectTitleConfig(config) {
  const { titleMarkConfig, subtitleMarkConfig, subtitle } = extractTitleConfig(config.title);
  if (!isEmpty(titleMarkConfig)) {
    config.style["group-title"] = Object.assign(
      Object.assign({}, config.style["group-title"]),
      titleMarkConfig
      // config.title has higher precedence than config.style.group-title in Vega
    );
  }
  if (!isEmpty(subtitleMarkConfig)) {
    config.style["group-subtitle"] = Object.assign(Object.assign({}, config.style["group-subtitle"]), subtitleMarkConfig);
  }
  if (!isEmpty(subtitle)) {
    config.title = subtitle;
  } else {
    delete config.title;
  }
}
function redirectConfigToStyleConfig(config, prop, toProp, compositeMarkPart) {
  const propConfig = config[prop];
  if (prop === "view") {
    toProp = "cell";
  }
  const style2 = Object.assign(Object.assign({}, propConfig), config.style[toProp !== null && toProp !== void 0 ? toProp : prop]);
  if (!isEmpty(style2)) {
    config.style[toProp !== null && toProp !== void 0 ? toProp : prop] = style2;
  }
  {
    delete config[prop];
  }
}
function isLayerSpec(spec) {
  return "layer" in spec;
}
function isRepeatSpec(spec) {
  return "repeat" in spec;
}
function isLayerRepeatSpec(spec) {
  return !isArray$1(spec.repeat) && spec.repeat["layer"];
}
var __rest$k = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
class SpecMapper {
  map(spec, params2) {
    if (isFacetSpec(spec)) {
      return this.mapFacet(spec, params2);
    } else if (isRepeatSpec(spec)) {
      return this.mapRepeat(spec, params2);
    } else if (isHConcatSpec(spec)) {
      return this.mapHConcat(spec, params2);
    } else if (isVConcatSpec(spec)) {
      return this.mapVConcat(spec, params2);
    } else if (isConcatSpec(spec)) {
      return this.mapConcat(spec, params2);
    } else {
      return this.mapLayerOrUnit(spec, params2);
    }
  }
  mapLayerOrUnit(spec, params2) {
    if (isLayerSpec(spec)) {
      return this.mapLayer(spec, params2);
    } else if (isUnitSpec(spec)) {
      return this.mapUnit(spec, params2);
    }
    throw new Error(invalidSpec(spec));
  }
  mapLayer(spec, params2) {
    return Object.assign(Object.assign({}, spec), { layer: spec.layer.map((subspec) => this.mapLayerOrUnit(subspec, params2)) });
  }
  mapHConcat(spec, params2) {
    return Object.assign(Object.assign({}, spec), { hconcat: spec.hconcat.map((subspec) => this.map(subspec, params2)) });
  }
  mapVConcat(spec, params2) {
    return Object.assign(Object.assign({}, spec), { vconcat: spec.vconcat.map((subspec) => this.map(subspec, params2)) });
  }
  mapConcat(spec, params2) {
    const { concat } = spec, rest = __rest$k(spec, ["concat"]);
    return Object.assign(Object.assign({}, rest), { concat: concat.map((subspec) => this.map(subspec, params2)) });
  }
  mapFacet(spec, params2) {
    return Object.assign(Object.assign({}, spec), {
      // TODO: remove "any" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760
      spec: this.map(spec.spec, params2)
    });
  }
  mapRepeat(spec, params2) {
    return Object.assign(Object.assign({}, spec), {
      // as any is required here since TS cannot infer that the output type satisfies the input type
      spec: this.map(spec.spec, params2)
    });
  }
}
const STACK_OFFSET_INDEX = {
  zero: 1,
  center: 1,
  normalize: 1
};
function isStackOffset(s) {
  return s in STACK_OFFSET_INDEX;
}
const STACKABLE_MARKS = /* @__PURE__ */ new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);
const STACK_BY_DEFAULT_MARKS = /* @__PURE__ */ new Set([BAR, AREA, ARC]);
function isUnbinnedQuantitative(channelDef) {
  return isFieldDef(channelDef) && channelDefType(channelDef) === "quantitative" && !channelDef.bin;
}
function potentialStackedChannel(encoding, x2) {
  var _a, _b;
  const y2 = x2 === "x" ? "y" : "radius";
  const xDef = encoding[x2];
  const yDef = encoding[y2];
  if (isFieldDef(xDef) && isFieldDef(yDef)) {
    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {
      if (xDef.stack) {
        return x2;
      } else if (yDef.stack) {
        return y2;
      }
      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;
      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;
      if (xAggregate !== yAggregate) {
        return xAggregate ? x2 : y2;
      } else {
        const xScale = (_a = xDef.scale) === null || _a === void 0 ? void 0 : _a.type;
        const yScale = (_b = yDef.scale) === null || _b === void 0 ? void 0 : _b.type;
        if (xScale && xScale !== "linear") {
          return y2;
        } else if (yScale && yScale !== "linear") {
          return x2;
        }
      }
    } else if (isUnbinnedQuantitative(xDef)) {
      return x2;
    } else if (isUnbinnedQuantitative(yDef)) {
      return y2;
    }
  } else if (isUnbinnedQuantitative(xDef)) {
    return x2;
  } else if (isUnbinnedQuantitative(yDef)) {
    return y2;
  }
  return void 0;
}
function getDimensionChannel(channel) {
  switch (channel) {
    case "x":
      return "y";
    case "y":
      return "x";
    case "theta":
      return "radius";
    case "radius":
      return "theta";
  }
}
function stack(m2, encoding) {
  var _a, _b;
  const mark2 = isMarkDef(m2) ? m2.type : m2;
  if (!STACKABLE_MARKS.has(mark2)) {
    return null;
  }
  const fieldChannel = potentialStackedChannel(encoding, "x") || potentialStackedChannel(encoding, "theta");
  if (!fieldChannel) {
    return null;
  }
  const stackedFieldDef = encoding[fieldChannel];
  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : void 0;
  const dimensionChannel = getDimensionChannel(fieldChannel);
  const groupbyChannels = [];
  const groupbyFields = /* @__PURE__ */ new Set();
  if (encoding[dimensionChannel]) {
    const dimensionDef = encoding[dimensionChannel];
    const dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : void 0;
    if (dimensionField && dimensionField !== stackedField) {
      groupbyChannels.push(dimensionChannel);
      groupbyFields.add(dimensionField);
    }
    const dimensionOffsetChannel = dimensionChannel === "x" ? "xOffset" : "yOffset";
    const dimensionOffsetDef = encoding[dimensionOffsetChannel];
    const dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : void 0;
    if (dimensionOffsetField && dimensionOffsetField !== stackedField) {
      groupbyChannels.push(dimensionOffsetChannel);
      groupbyFields.add(dimensionOffsetField);
    }
  }
  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {
    if (channel !== "tooltip" && channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      for (const cDef of array$5(channelDef)) {
        const fieldDef = getFieldDef(cDef);
        if (fieldDef.aggregate) {
          continue;
        }
        const f = vgField(fieldDef, {});
        if (
          // if fielddef is a repeat, just include it in the stack by
          !f || // otherwise, the field must be different from the groupBy fields.
          !groupbyFields.has(f)
        ) {
          sc.push({ channel, fieldDef });
        }
      }
    }
    return sc;
  }, []);
  let offset2;
  if (stackedFieldDef.stack !== void 0) {
    if (isBoolean$2(stackedFieldDef.stack)) {
      offset2 = stackedFieldDef.stack ? "zero" : null;
    } else {
      offset2 = stackedFieldDef.stack;
    }
  } else if (STACK_BY_DEFAULT_MARKS.has(mark2)) {
    offset2 = "zero";
  }
  if (!offset2 || !isStackOffset(offset2)) {
    return null;
  }
  if (isAggregate$1(encoding) && stackBy.length === 0) {
    return null;
  }
  if (((_a = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _a === void 0 ? void 0 : _a.type) && ((_b = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _b === void 0 ? void 0 : _b.type) !== ScaleType.LINEAR) {
    warn(cannotStackNonLinearScale(stackedFieldDef.scale.type));
    return null;
  }
  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {
    if (stackedFieldDef.stack !== void 0) {
      warn(cannotStackRangedMark(fieldChannel));
    }
    return null;
  }
  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !SUM_OPS.has(stackedFieldDef.aggregate)) {
    warn(stackNonSummativeAggregate(stackedFieldDef.aggregate));
  }
  return {
    groupbyChannels,
    groupbyFields,
    fieldChannel,
    impute: stackedFieldDef.impute === null ? false : isPathMark(mark2),
    stackBy,
    offset: offset2
  };
}
var __rest$j = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function dropLineAndPoint(markDef) {
  const { point: _point, line: _line } = markDef, mark2 = __rest$j(markDef, ["point", "line"]);
  return keys$1(mark2).length > 1 ? mark2 : mark2.type;
}
function dropLineAndPointFromConfig(config) {
  for (const mark2 of ["line", "area", "rule", "trail"]) {
    if (config[mark2]) {
      config = Object.assign(Object.assign({}, config), {
        // TODO: remove as any
        [mark2]: omit(config[mark2], ["point", "line"])
      });
    }
  }
  return config;
}
function getPointOverlay(markDef, markConfig = {}, encoding) {
  if (markDef.point === "transparent") {
    return { opacity: 0 };
  } else if (markDef.point) {
    return isObject$1(markDef.point) ? markDef.point : {};
  } else if (markDef.point !== void 0) {
    return null;
  } else {
    if (markConfig.point || encoding.shape) {
      return isObject$1(markConfig.point) ? markConfig.point : {};
    }
    return void 0;
  }
}
function getLineOverlay(markDef, markConfig = {}) {
  if (markDef.line) {
    return markDef.line === true ? {} : markDef.line;
  } else if (markDef.line !== void 0) {
    return null;
  } else {
    if (markConfig.line) {
      return markConfig.line === true ? {} : markConfig.line;
    }
    return void 0;
  }
}
class PathOverlayNormalizer {
  constructor() {
    this.name = "path-overlay";
  }
  hasMatchingType(spec, config) {
    if (isUnitSpec(spec)) {
      const { mark: mark2, encoding } = spec;
      const markDef = isMarkDef(mark2) ? mark2 : { type: mark2 };
      switch (markDef.type) {
        case "line":
        case "rule":
        case "trail":
          return !!getPointOverlay(markDef, config[markDef.type], encoding);
        case "area":
          return (
            // false / null are also included as we want to remove the properties
            !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])
          );
      }
    }
    return false;
  }
  run(spec, normParams, normalize2) {
    const { config } = normParams;
    const { params: params2, projection: projection2, mark: mark2, encoding: e3 } = spec, outerSpec = __rest$j(spec, ["params", "projection", "mark", "encoding"]);
    const encoding = normalizeEncoding(e3, config);
    const markDef = isMarkDef(mark2) ? mark2 : { type: mark2 };
    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);
    const lineOverlay = markDef.type === "area" && getLineOverlay(markDef, config[markDef.type]);
    const layer = [
      Object.assign(Object.assign({}, params2 ? { params: params2 } : {}), {
        mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef.type === "area" && markDef.opacity === void 0 && markDef.fillOpacity === void 0 ? { opacity: 0.7 } : {}), markDef)),
        // drop shape from encoding as this might be used to trigger point overlay
        encoding: omit(encoding, ["shape"])
      })
    ];
    const stackProps = stack(markDef, encoding);
    let overlayEncoding = encoding;
    if (stackProps) {
      const { fieldChannel: stackFieldChannel, offset: offset2 } = stackProps;
      overlayEncoding = Object.assign(Object.assign({}, encoding), { [stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset2 ? { stack: offset2 } : {}) });
    }
    if (lineOverlay) {
      layer.push(Object.assign(Object.assign({}, projection2 ? { projection: projection2 } : {}), { mark: Object.assign(Object.assign({ type: "line" }, pick(markDef, ["clip", "interpolate", "tension", "tooltip"])), lineOverlay), encoding: overlayEncoding }));
    }
    if (pointOverlay) {
      layer.push(Object.assign(Object.assign({}, projection2 ? { projection: projection2 } : {}), { mark: Object.assign(Object.assign({ type: "point", opacity: 1, filled: true }, pick(markDef, ["clip", "tooltip"])), pointOverlay), encoding: overlayEncoding }));
    }
    return normalize2(Object.assign(Object.assign({}, outerSpec), { layer }), Object.assign(Object.assign({}, normParams), { config: dropLineAndPointFromConfig(config) }));
  }
}
var __rest$i = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function replaceRepeaterInFacet(facet, repeater) {
  if (!repeater) {
    return facet;
  }
  if (isFacetMapping(facet)) {
    return replaceRepeaterInMapping(facet, repeater);
  }
  return replaceRepeaterInFieldDef(facet, repeater);
}
function replaceRepeaterInEncoding(encoding, repeater) {
  if (!repeater) {
    return encoding;
  }
  return replaceRepeaterInMapping(encoding, repeater);
}
function replaceRepeatInProp(prop, o, repeater) {
  const val = o[prop];
  if (isRepeatRef(val)) {
    if (val.repeat in repeater) {
      return Object.assign(Object.assign({}, o), { [prop]: repeater[val.repeat] });
    } else {
      warn(noSuchRepeatedValue(val.repeat));
      return void 0;
    }
  }
  return o;
}
function replaceRepeaterInFieldDef(fieldDef, repeater) {
  fieldDef = replaceRepeatInProp("field", fieldDef, repeater);
  if (fieldDef === void 0) {
    return void 0;
  } else if (fieldDef === null) {
    return null;
  }
  if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {
    const sort2 = replaceRepeatInProp("field", fieldDef.sort, repeater);
    fieldDef = Object.assign(Object.assign({}, fieldDef), sort2 ? { sort: sort2 } : {});
  }
  return fieldDef;
}
function replaceRepeaterInFieldOrDatumDef(def2, repeater) {
  if (isFieldDef(def2)) {
    return replaceRepeaterInFieldDef(def2, repeater);
  } else {
    const datumDef = replaceRepeatInProp("datum", def2, repeater);
    if (datumDef !== def2 && !datumDef.type) {
      datumDef.type = "nominal";
    }
    return datumDef;
  }
}
function replaceRepeaterInChannelDef(channelDef, repeater) {
  if (isFieldOrDatumDef(channelDef)) {
    const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);
    if (fd) {
      return fd;
    } else if (isConditionalDef(channelDef)) {
      return { condition: channelDef.condition };
    }
  } else {
    if (hasConditionalFieldOrDatumDef(channelDef)) {
      const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);
      if (fd) {
        return Object.assign(Object.assign({}, channelDef), { condition: fd });
      } else {
        const { condition } = channelDef, channelDefWithoutCondition = __rest$i(channelDef, ["condition"]);
        return channelDefWithoutCondition;
      }
    }
    return channelDef;
  }
  return void 0;
}
function replaceRepeaterInMapping(mapping, repeater) {
  const out = {};
  for (const channel in mapping) {
    if (has$2(mapping, channel)) {
      const channelDef = mapping[channel];
      if (isArray$1(channelDef)) {
        out[channel] = channelDef.map((cd) => replaceRepeaterInChannelDef(cd, repeater)).filter((cd) => cd);
      } else {
        const cd = replaceRepeaterInChannelDef(channelDef, repeater);
        if (cd !== void 0) {
          out[channel] = cd;
        }
      }
    }
  }
  return out;
}
class RuleForRangedLineNormalizer {
  constructor() {
    this.name = "RuleForRangedLine";
  }
  hasMatchingType(spec) {
    if (isUnitSpec(spec)) {
      const { encoding, mark: mark2 } = spec;
      if (mark2 === "line" || isMarkDef(mark2) && mark2.type === "line") {
        for (const channel of SECONDARY_RANGE_CHANNEL) {
          const mainChannel = getMainRangeChannel(channel);
          const mainChannelDef = encoding[mainChannel];
          if (encoding[channel]) {
            if (isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin) || isDatumDef(mainChannelDef)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  run(spec, params2, normalize2) {
    const { encoding, mark: mark2 } = spec;
    warn(lineWithRange(!!encoding.x2, !!encoding.y2));
    return normalize2(Object.assign(Object.assign({}, spec), { mark: isObject$1(mark2) ? Object.assign(Object.assign({}, mark2), { type: "rule" }) : "rule" }), params2);
  }
}
var __rest$h = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
class CoreNormalizer extends SpecMapper {
  constructor() {
    super(...arguments);
    this.nonFacetUnitNormalizers = [
      boxPlotNormalizer,
      errorBarNormalizer,
      errorBandNormalizer,
      new PathOverlayNormalizer(),
      new RuleForRangedLineNormalizer()
    ];
  }
  map(spec, params2) {
    if (isUnitSpec(spec)) {
      const hasRow = channelHasField(spec.encoding, ROW);
      const hasColumn = channelHasField(spec.encoding, COLUMN);
      const hasFacet = channelHasField(spec.encoding, FACET);
      if (hasRow || hasColumn || hasFacet) {
        return this.mapFacetedUnit(spec, params2);
      }
    }
    return super.map(spec, params2);
  }
  // This is for normalizing non-facet unit
  mapUnit(spec, params2) {
    const { parentEncoding, parentProjection } = params2;
    const encoding = replaceRepeaterInEncoding(spec.encoding, params2.repeater);
    const specWithReplacedEncoding = Object.assign(Object.assign({}, spec), encoding ? { encoding } : {});
    if (parentEncoding || parentProjection) {
      return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params2);
    }
    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);
    for (const unitNormalizer of this.nonFacetUnitNormalizers) {
      if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params2.config)) {
        return unitNormalizer.run(specWithReplacedEncoding, params2, normalizeLayerOrUnit);
      }
    }
    return specWithReplacedEncoding;
  }
  mapRepeat(spec, params2) {
    if (isLayerRepeatSpec(spec)) {
      return this.mapLayerRepeat(spec, params2);
    } else {
      return this.mapNonLayerRepeat(spec, params2);
    }
  }
  mapLayerRepeat(spec, params2) {
    const { repeat: repeat2, spec: childSpec } = spec, rest = __rest$h(spec, ["repeat", "spec"]);
    const { row, column: column2, layer } = repeat2;
    const { repeater = {}, repeaterPrefix = "" } = params2;
    if (row || column2) {
      return this.mapRepeat(Object.assign(Object.assign({}, spec), { repeat: Object.assign(Object.assign({}, row ? { row } : {}), column2 ? { column: column2 } : {}), spec: {
        repeat: { layer },
        spec: childSpec
      } }), params2);
    } else {
      return Object.assign(Object.assign({}, rest), { layer: layer.map((layerValue) => {
        const childRepeater = Object.assign(Object.assign({}, repeater), { layer: layerValue });
        const childName = `${(childSpec.name || "") + repeaterPrefix}child__layer_${varName(layerValue)}`;
        const child = this.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params2), { repeater: childRepeater, repeaterPrefix: childName }));
        child.name = childName;
        return child;
      }) });
    }
  }
  mapNonLayerRepeat(spec, params2) {
    var _a;
    const { repeat: repeat2, spec: childSpec, data: data2 } = spec, remainingProperties = __rest$h(spec, ["repeat", "spec", "data"]);
    if (!isArray$1(repeat2) && spec.columns) {
      spec = omit(spec, ["columns"]);
      warn(columnsNotSupportByRowCol("repeat"));
    }
    const concat = [];
    const { repeater = {}, repeaterPrefix = "" } = params2;
    const row = !isArray$1(repeat2) && repeat2.row || [repeater ? repeater.row : null];
    const column2 = !isArray$1(repeat2) && repeat2.column || [repeater ? repeater.column : null];
    const repeatValues = isArray$1(repeat2) && repeat2 || [repeater ? repeater.repeat : null];
    for (const repeatValue of repeatValues) {
      for (const rowValue of row) {
        for (const columnValue of column2) {
          const childRepeater = {
            repeat: repeatValue,
            row: rowValue,
            column: columnValue,
            layer: repeater.layer
          };
          const childName = (childSpec.name || "") + repeaterPrefix + "child__" + (isArray$1(repeat2) ? `${varName(repeatValue)}` : (repeat2.row ? `row_${varName(rowValue)}` : "") + (repeat2.column ? `column_${varName(columnValue)}` : ""));
          const child = this.map(childSpec, Object.assign(Object.assign({}, params2), { repeater: childRepeater, repeaterPrefix: childName }));
          child.name = childName;
          concat.push(omit(child, ["data"]));
        }
      }
    }
    const columns = isArray$1(repeat2) ? spec.columns : repeat2.column ? repeat2.column.length : 1;
    return Object.assign(Object.assign({ data: (_a = childSpec.data) !== null && _a !== void 0 ? _a : data2, align: "all" }, remainingProperties), {
      columns,
      concat
    });
  }
  mapFacet(spec, params2) {
    const { facet } = spec;
    if (isFacetMapping(facet) && spec.columns) {
      spec = omit(spec, ["columns"]);
      warn(columnsNotSupportByRowCol("facet"));
    }
    return super.mapFacet(spec, params2);
  }
  mapUnitWithParentEncodingOrProjection(spec, params2) {
    const { encoding, projection: projection2 } = spec;
    const { parentEncoding, parentProjection, config } = params2;
    const mergedProjection = mergeProjection({ parentProjection, projection: projection2 });
    const mergedEncoding = mergeEncoding({
      parentEncoding,
      encoding: replaceRepeaterInEncoding(encoding, params2.repeater)
    });
    return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? { projection: mergedProjection } : {}), mergedEncoding ? { encoding: mergedEncoding } : {}), { config });
  }
  mapFacetedUnit(spec, normParams) {
    const _a = spec.encoding, { row, column: column2, facet } = _a, encoding = __rest$h(_a, ["row", "column", "facet"]);
    const { mark: mark2, width: width2, projection: projection2, height: height2, view, params: params2, encoding: _ } = spec, outerSpec = __rest$h(spec, ["mark", "width", "projection", "height", "view", "params", "encoding"]);
    const { facetMapping, layout } = this.getFacetMappingAndLayout({ row, column: column2, facet }, normParams);
    const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);
    return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {
      // row / column has higher precedence than facet
      facet: facetMapping,
      spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, width2 ? { width: width2 } : {}), height2 ? { height: height2 } : {}), view ? { view } : {}), projection2 ? { projection: projection2 } : {}), { mark: mark2, encoding: newEncoding }), params2 ? { params: params2 } : {})
    }), normParams);
  }
  getFacetMappingAndLayout(facets, params2) {
    var _a;
    const { row, column: column2, facet } = facets;
    if (row || column2) {
      if (facet) {
        warn(facetChannelDropped([...row ? [ROW] : [], ...column2 ? [COLUMN] : []]));
      }
      const facetMapping = {};
      const layout = {};
      for (const channel of [ROW, COLUMN]) {
        const def2 = facets[channel];
        if (def2) {
          const { align: align2, center, spacing, columns } = def2, defWithoutLayout = __rest$h(def2, ["align", "center", "spacing", "columns"]);
          facetMapping[channel] = defWithoutLayout;
          for (const prop of ["align", "center", "spacing"]) {
            if (def2[prop] !== void 0) {
              (_a = layout[prop]) !== null && _a !== void 0 ? _a : layout[prop] = {};
              layout[prop][channel] = def2[prop];
            }
          }
        }
      }
      return { facetMapping, layout };
    } else {
      const { align: align2, center, spacing, columns } = facet, facetMapping = __rest$h(facet, ["align", "center", "spacing", "columns"]);
      return {
        facetMapping: replaceRepeaterInFacet(facetMapping, params2.repeater),
        layout: Object.assign(Object.assign(Object.assign(Object.assign({}, align2 ? { align: align2 } : {}), center ? { center } : {}), spacing ? { spacing } : {}), columns ? { columns } : {})
      };
    }
  }
  mapLayer(spec, _a) {
    var { parentEncoding, parentProjection } = _a, otherParams = __rest$h(_a, ["parentEncoding", "parentProjection"]);
    const { encoding, projection: projection2 } = spec, rest = __rest$h(spec, ["encoding", "projection"]);
    const params2 = Object.assign(Object.assign({}, otherParams), { parentEncoding: mergeEncoding({ parentEncoding, encoding, layer: true }), parentProjection: mergeProjection({ parentProjection, projection: projection2 }) });
    return super.mapLayer(rest, params2);
  }
}
function mergeEncoding({ parentEncoding, encoding = {}, layer }) {
  let merged = {};
  if (parentEncoding) {
    const channels = /* @__PURE__ */ new Set([...keys$1(parentEncoding), ...keys$1(encoding)]);
    for (const channel of channels) {
      const channelDef = encoding[channel];
      const parentChannelDef = parentEncoding[channel];
      if (isFieldOrDatumDef(channelDef)) {
        const mergedChannelDef = Object.assign(Object.assign({}, parentChannelDef), channelDef);
        merged[channel] = mergedChannelDef;
      } else if (hasConditionalFieldOrDatumDef(channelDef)) {
        merged[channel] = Object.assign(Object.assign({}, channelDef), { condition: Object.assign(Object.assign({}, parentChannelDef), channelDef.condition) });
      } else if (channelDef || channelDef === null) {
        merged[channel] = channelDef;
      } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || isArray$1(parentChannelDef)) {
        merged[channel] = parentChannelDef;
      }
    }
  } else {
    merged = encoding;
  }
  return !merged || isEmpty(merged) ? void 0 : merged;
}
function mergeProjection(opt) {
  const { parentProjection, projection: projection2 } = opt;
  if (parentProjection && projection2) {
    warn(projectionOverridden({ parentProjection, projection: projection2 }));
  }
  return projection2 !== null && projection2 !== void 0 ? projection2 : parentProjection;
}
function isFilter(t4) {
  return "filter" in t4;
}
function isImputeSequence(t4) {
  return (t4 === null || t4 === void 0 ? void 0 : t4["stop"]) !== void 0;
}
function isLookup(t4) {
  return "lookup" in t4;
}
function isLookupData(from2) {
  return "data" in from2;
}
function isLookupSelection(from2) {
  return "param" in from2;
}
function isPivot(t4) {
  return "pivot" in t4;
}
function isDensity(t4) {
  return "density" in t4;
}
function isQuantile(t4) {
  return "quantile" in t4;
}
function isRegression(t4) {
  return "regression" in t4;
}
function isLoess(t4) {
  return "loess" in t4;
}
function isSample(t4) {
  return "sample" in t4;
}
function isWindow(t4) {
  return "window" in t4;
}
function isJoinAggregate(t4) {
  return "joinaggregate" in t4;
}
function isFlatten(t4) {
  return "flatten" in t4;
}
function isCalculate(t4) {
  return "calculate" in t4;
}
function isBin(t4) {
  return "bin" in t4;
}
function isImpute(t4) {
  return "impute" in t4;
}
function isTimeUnit(t4) {
  return "timeUnit" in t4;
}
function isAggregate(t4) {
  return "aggregate" in t4;
}
function isStack(t4) {
  return "stack" in t4;
}
function isFold(t4) {
  return "fold" in t4;
}
function normalizeTransform(transform2) {
  return transform2.map((t4) => {
    if (isFilter(t4)) {
      return {
        filter: normalizeLogicalComposition(t4.filter, normalizePredicate$1)
      };
    }
    return t4;
  });
}
var __rest$g = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
class SelectionCompatibilityNormalizer extends SpecMapper {
  map(spec, normParams) {
    var _a, _b;
    (_a = normParams.emptySelections) !== null && _a !== void 0 ? _a : normParams.emptySelections = {};
    (_b = normParams.selectionPredicates) !== null && _b !== void 0 ? _b : normParams.selectionPredicates = {};
    spec = normalizeTransforms(spec, normParams);
    return super.map(spec, normParams);
  }
  mapLayerOrUnit(spec, normParams) {
    spec = normalizeTransforms(spec, normParams);
    if (spec.encoding) {
      const encoding = {};
      for (const [channel, enc] of entries$1(spec.encoding)) {
        encoding[channel] = normalizeChannelDef(enc, normParams);
      }
      spec = Object.assign(Object.assign({}, spec), { encoding });
    }
    return super.mapLayerOrUnit(spec, normParams);
  }
  mapUnit(spec, normParams) {
    const _a = spec, { selection } = _a, rest = __rest$g(_a, ["selection"]);
    if (selection) {
      return Object.assign(Object.assign({}, rest), { params: entries$1(selection).map(([name, selDef]) => {
        var _a2;
        const _b = selDef, { init: value2, bind: bind2, empty } = _b, select2 = __rest$g(_b, ["init", "bind", "empty"]);
        if (select2.type === "single") {
          select2.type = "point";
          select2.toggle = false;
        } else if (select2.type === "multi") {
          select2.type = "point";
        }
        normParams.emptySelections[name] = empty !== "none";
        for (const pred of vals((_a2 = normParams.selectionPredicates[name]) !== null && _a2 !== void 0 ? _a2 : {})) {
          pred.empty = empty !== "none";
        }
        return { name, value: value2, select: select2, bind: bind2 };
      }) });
    }
    return spec;
  }
}
function normalizeTransforms(spec, normParams) {
  const { transform: tx2 } = spec, rest = __rest$g(spec, ["transform"]);
  if (tx2) {
    const transform2 = tx2.map((t4) => {
      if (isFilter(t4)) {
        return { filter: normalizePredicate(t4, normParams) };
      } else if (isBin(t4) && isBinParams(t4.bin)) {
        return Object.assign(Object.assign({}, t4), { bin: normalizeBinExtent(t4.bin) });
      } else if (isLookup(t4)) {
        const _a = t4.from, { selection: param2 } = _a, from2 = __rest$g(_a, ["selection"]);
        return param2 ? Object.assign(Object.assign({}, t4), { from: Object.assign({ param: param2 }, from2) }) : t4;
      }
      return t4;
    });
    return Object.assign(Object.assign({}, rest), { transform: transform2 });
  }
  return spec;
}
function normalizeChannelDef(obj, normParams) {
  var _a, _b;
  const enc = duplicate(obj);
  if (isFieldDef(enc) && isBinParams(enc.bin)) {
    enc.bin = normalizeBinExtent(enc.bin);
  }
  if (isScaleFieldDef(enc) && ((_b = (_a = enc.scale) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.selection)) {
    const _c2 = enc.scale.domain, { selection: param2 } = _c2, domain2 = __rest$g(_c2, ["selection"]);
    enc.scale.domain = Object.assign(Object.assign({}, domain2), param2 ? { param: param2 } : {});
  }
  if (isConditionalDef(enc)) {
    if (isArray$1(enc.condition)) {
      enc.condition = enc.condition.map((c2) => {
        const { selection, param: param2, test: test2 } = c2, cond = __rest$g(c2, ["selection", "param", "test"]);
        return param2 ? c2 : Object.assign(Object.assign({}, cond), { test: normalizePredicate(c2, normParams) });
      });
    } else {
      const _d2 = normalizeChannelDef(enc.condition, normParams), { selection, param: param2, test: test2 } = _d2, cond = __rest$g(_d2, ["selection", "param", "test"]);
      enc.condition = param2 ? enc.condition : Object.assign(Object.assign({}, cond), { test: normalizePredicate(enc.condition, normParams) });
    }
  }
  return enc;
}
function normalizeBinExtent(bin2) {
  const ext = bin2.extent;
  if (ext === null || ext === void 0 ? void 0 : ext.selection) {
    const { selection: param2 } = ext, rest = __rest$g(ext, ["selection"]);
    return Object.assign(Object.assign({}, bin2), { extent: Object.assign(Object.assign({}, rest), { param: param2 }) });
  }
  return bin2;
}
function normalizePredicate(op, normParams) {
  const normalizeSelectionComposition = (o) => {
    return normalizeLogicalComposition(o, (param2) => {
      var _a, _b;
      var _c2;
      const empty = (_a = normParams.emptySelections[param2]) !== null && _a !== void 0 ? _a : true;
      const pred = { param: param2, empty };
      (_b = (_c2 = normParams.selectionPredicates)[param2]) !== null && _b !== void 0 ? _b : _c2[param2] = [];
      normParams.selectionPredicates[param2].push(pred);
      return pred;
    });
  };
  return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, (o) => o.selection ? normalizeSelectionComposition(o.selection) : o);
}
class TopLevelSelectionsNormalizer extends SpecMapper {
  map(spec, normParams) {
    var _a;
    const selections = (_a = normParams.selections) !== null && _a !== void 0 ? _a : [];
    if (spec.params && !isUnitSpec(spec)) {
      const params2 = [];
      for (const param2 of spec.params) {
        if (isSelectionParameter(param2)) {
          selections.push(param2);
        } else {
          params2.push(param2);
        }
      }
      spec.params = params2;
    }
    normParams.selections = selections;
    return super.map(spec, addSpecNameToParams(spec, normParams));
  }
  mapUnit(spec, normParams) {
    var _a;
    const selections = normParams.selections;
    if (!selections || !selections.length)
      return spec;
    const path2 = ((_a = normParams.path) !== null && _a !== void 0 ? _a : []).concat(spec.name);
    const params2 = [];
    for (const selection of selections) {
      if (!selection.views || !selection.views.length) {
        params2.push(selection);
      } else {
        for (const view of selection.views) {
          if (isString(view) && (view === spec.name || path2.indexOf(view) >= 0) || isArray$1(view) && view.map((v) => path2.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1]))) {
            params2.push(selection);
          }
        }
      }
    }
    if (params2.length)
      spec.params = params2;
    return spec;
  }
}
for (const method2 of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
  const proto = TopLevelSelectionsNormalizer.prototype[method2];
  TopLevelSelectionsNormalizer.prototype[method2] = function(spec, params2) {
    return proto.call(this, spec, addSpecNameToParams(spec, params2));
  };
}
function addSpecNameToParams(spec, params2) {
  var _a;
  return spec.name ? Object.assign(Object.assign({}, params2), { path: ((_a = params2.path) !== null && _a !== void 0 ? _a : []).concat(spec.name) }) : params2;
}
function normalize(spec, config) {
  if (config === void 0) {
    config = initConfig(spec.config);
  }
  const normalizedSpec = normalizeGenericSpec(spec, config);
  const { width: width2, height: height2 } = spec;
  const autosize = normalizeAutoSize(normalizedSpec, { width: width2, height: height2, autosize: spec.autosize }, config);
  return Object.assign(Object.assign({}, normalizedSpec), autosize ? { autosize } : {});
}
const coreNormalizer = new CoreNormalizer();
const selectionCompatNormalizer = new SelectionCompatibilityNormalizer();
const topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer();
function normalizeGenericSpec(spec, config = {}) {
  const normParams = { config };
  return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec, normParams), normParams), normParams);
}
function _normalizeAutoSize(autosize) {
  return isString(autosize) ? { type: autosize } : autosize !== null && autosize !== void 0 ? autosize : {};
}
function normalizeAutoSize(spec, sizeInfo, config) {
  let { width: width2, height: height2 } = sizeInfo;
  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);
  const autosizeDefault = {};
  if (!isFitCompatible) {
    if (width2 == "container") {
      warn(containerSizeNonSingle("width"));
      width2 = void 0;
    }
    if (height2 == "container") {
      warn(containerSizeNonSingle("height"));
      height2 = void 0;
    }
  } else {
    if (width2 == "container" && height2 == "container") {
      autosizeDefault.type = "fit";
      autosizeDefault.contains = "padding";
    } else if (width2 == "container") {
      autosizeDefault.type = "fit-x";
      autosizeDefault.contains = "padding";
    } else if (height2 == "container") {
      autosizeDefault.type = "fit-y";
      autosizeDefault.contains = "padding";
    }
  }
  const autosize = Object.assign(Object.assign(Object.assign({ type: "pad" }, autosizeDefault), config ? _normalizeAutoSize(config.autosize) : {}), _normalizeAutoSize(spec.autosize));
  if (autosize.type === "fit" && !isFitCompatible) {
    warn(FIT_NON_SINGLE);
    autosize.type = "pad";
  }
  if (width2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-x")) {
    warn(containerSizeNotCompatibleWithAutosize("width"));
  }
  if (height2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-y")) {
    warn(containerSizeNotCompatibleWithAutosize("height"));
  }
  if (deepEqual(autosize, { type: "pad" })) {
    return void 0;
  }
  return autosize;
}
function isFitType(autoSizeType) {
  return autoSizeType === "fit" || autoSizeType === "fit-x" || autoSizeType === "fit-y";
}
function getFitType(sizeType) {
  return sizeType ? `fit-${getPositionScaleChannel(sizeType)}` : "fit";
}
const TOP_LEVEL_PROPERTIES = [
  "background",
  "padding"
  // We do not include "autosize" here as it is supported by only unit and layer specs and thus need to be normalized
];
function extractTopLevelProperties(t4, includeParams) {
  const o = {};
  for (const p of TOP_LEVEL_PROPERTIES) {
    if (t4 && t4[p] !== void 0) {
      o[p] = signalRefOrValue(t4[p]);
    }
  }
  if (includeParams) {
    o.params = t4.params;
  }
  return o;
}
class Split {
  constructor(explicit = {}, implicit2 = {}) {
    this.explicit = explicit;
    this.implicit = implicit2;
  }
  clone() {
    return new Split(duplicate(this.explicit), duplicate(this.implicit));
  }
  combine() {
    return Object.assign(Object.assign({}, this.explicit), this.implicit);
  }
  get(key2) {
    return getFirstDefined(this.explicit[key2], this.implicit[key2]);
  }
  getWithExplicit(key2) {
    if (this.explicit[key2] !== void 0) {
      return { explicit: true, value: this.explicit[key2] };
    } else if (this.implicit[key2] !== void 0) {
      return { explicit: false, value: this.implicit[key2] };
    }
    return { explicit: false, value: void 0 };
  }
  setWithExplicit(key2, { value: value2, explicit }) {
    if (value2 !== void 0) {
      this.set(key2, value2, explicit);
    }
  }
  set(key2, value2, explicit) {
    delete this[explicit ? "implicit" : "explicit"][key2];
    this[explicit ? "explicit" : "implicit"][key2] = value2;
    return this;
  }
  copyKeyFromSplit(key2, { explicit, implicit: implicit2 }) {
    if (explicit[key2] !== void 0) {
      this.set(key2, explicit[key2], true);
    } else if (implicit2[key2] !== void 0) {
      this.set(key2, implicit2[key2], false);
    }
  }
  copyKeyFromObject(key2, s) {
    if (s[key2] !== void 0) {
      this.set(key2, s[key2], true);
    }
  }
  /**
   * Merge split object into this split object. Properties from the other split
   * overwrite properties from this split.
   */
  copyAll(other) {
    for (const key2 of keys$1(other.combine())) {
      const val = other.getWithExplicit(key2);
      this.setWithExplicit(key2, val);
    }
  }
}
function makeExplicit(value2) {
  return {
    explicit: true,
    value: value2
  };
}
function makeImplicit(value2) {
  return {
    explicit: false,
    value: value2
  };
}
function tieBreakByComparing(compare2) {
  return (v1, v2, property2, propertyOf) => {
    const diff = compare2(v1.value, v2.value);
    if (diff > 0) {
      return v1;
    } else if (diff < 0) {
      return v2;
    }
    return defaultTieBreaker(v1, v2, property2, propertyOf);
  };
}
function defaultTieBreaker(v1, v2, property2, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn(mergeConflictingProperty(property2, propertyOf, v1.value, v2.value));
  }
  return v1;
}
function mergeValuesWithExplicit(v1, v2, property2, propertyOf, tieBreaker = defaultTieBreaker) {
  if (v1 === void 0 || v1.value === void 0) {
    return v2;
  }
  if (v1.explicit && !v2.explicit) {
    return v1;
  } else if (v2.explicit && !v1.explicit) {
    return v2;
  } else if (deepEqual(v1.value, v2.value)) {
    return v1;
  } else {
    return tieBreaker(v1, v2, property2, propertyOf);
  }
}
class AncestorParse extends Split {
  constructor(explicit = {}, implicit2 = {}, parseNothing = false) {
    super(explicit, implicit2);
    this.explicit = explicit;
    this.implicit = implicit2;
    this.parseNothing = parseNothing;
  }
  clone() {
    const clone2 = super.clone();
    clone2.parseNothing = this.parseNothing;
    return clone2;
  }
}
function isUrlData(data2) {
  return "url" in data2;
}
function isInlineData(data2) {
  return "values" in data2;
}
function isNamedData(data2) {
  return "name" in data2 && !isUrlData(data2) && !isInlineData(data2) && !isGenerator(data2);
}
function isGenerator(data2) {
  return data2 && (isSequenceGenerator(data2) || isSphereGenerator(data2) || isGraticuleGenerator(data2));
}
function isSequenceGenerator(data2) {
  return "sequence" in data2;
}
function isSphereGenerator(data2) {
  return "sphere" in data2;
}
function isGraticuleGenerator(data2) {
  return "graticule" in data2;
}
var DataSourceType;
(function(DataSourceType2) {
  DataSourceType2[DataSourceType2["Raw"] = 0] = "Raw";
  DataSourceType2[DataSourceType2["Main"] = 1] = "Main";
  DataSourceType2[DataSourceType2["Row"] = 2] = "Row";
  DataSourceType2[DataSourceType2["Column"] = 3] = "Column";
  DataSourceType2[DataSourceType2["Lookup"] = 4] = "Lookup";
})(DataSourceType || (DataSourceType = {}));
var __rest$f = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function assembleInit(init2, isExpr2 = true, wrap2 = identity$6) {
  if (isArray$1(init2)) {
    const assembled = init2.map((v) => assembleInit(v, isExpr2, wrap2));
    return isExpr2 ? `[${assembled.join(", ")}]` : assembled;
  } else if (isDateTime(init2)) {
    if (isExpr2) {
      return wrap2(dateTimeToExpr(init2));
    } else {
      return wrap2(dateTimeToTimestamp(init2));
    }
  }
  return isExpr2 ? wrap2(stringify$1(init2)) : init2;
}
function assembleUnitSelectionSignals(model, signals) {
  var _a;
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const name = selCmpt.name;
    let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === "global" ? "true" : `{unit: ${unitName(model)}}`}`;
    for (const c2 of selectionCompilers) {
      if (!c2.defined(selCmpt))
        continue;
      if (c2.signals)
        signals = c2.signals(model, selCmpt, signals);
      if (c2.modifyExpr)
        modifyExpr = c2.modifyExpr(model, selCmpt, modifyExpr);
    }
    signals.push({
      name: name + MODIFY,
      on: [
        {
          events: { signal: selCmpt.name + TUPLE },
          update: `modify(${$(selCmpt.name + STORE)}, ${modifyExpr})`
        }
      ]
    });
  }
  return cleanupEmptyOnArray(signals);
}
function assembleFacetSignals(model, signals) {
  if (model.component.selection && keys$1(model.component.selection).length) {
    const name = $(model.getName("cell"));
    signals.unshift({
      name: "facet",
      value: {},
      on: [
        {
          events: eventSelector("mousemove", "scope"),
          update: `isTuple(facet) ? facet : group(${name}).datum`
        }
      ]
    });
  }
  return cleanupEmptyOnArray(signals);
}
function assembleTopLevelSignals(model, signals) {
  var _a;
  let hasSelections = false;
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const name = selCmpt.name;
    const store = $(name + STORE);
    const hasSg = signals.filter((s) => s.name === name);
    if (hasSg.length === 0) {
      const resolve2 = selCmpt.resolve === "global" ? "union" : selCmpt.resolve;
      const isPoint = selCmpt.type === "point" ? ", true, true)" : ")";
      signals.push({
        name: selCmpt.name,
        update: `${VL_SELECTION_RESOLVE}(${store}, ${$(resolve2)}${isPoint}`
      });
    }
    hasSelections = true;
    for (const c2 of selectionCompilers) {
      if (c2.defined(selCmpt) && c2.topLevelSignals) {
        signals = c2.topLevelSignals(model, selCmpt, signals);
      }
    }
  }
  if (hasSelections) {
    const hasUnit = signals.filter((s) => s.name === "unit");
    if (hasUnit.length === 0) {
      signals.unshift({
        name: "unit",
        value: {},
        on: [{ events: "mousemove", update: "isTuple(group()) ? group() : unit" }]
      });
    }
  }
  return cleanupEmptyOnArray(signals);
}
function assembleUnitSelectionData(model, data2) {
  var _a;
  const dataCopy = [...data2];
  const unit2 = unitName(model, { escape: false });
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const store = { name: selCmpt.name + STORE };
    if (selCmpt.project.hasSelectionId) {
      store.transform = [{ type: "collect", sort: { field: SELECTION_ID } }];
    }
    if (selCmpt.init) {
      const fields = selCmpt.project.items.map((proj) => {
        const { signals } = proj, rest = __rest$f(proj, ["signals"]);
        return rest;
      });
      store.values = selCmpt.project.hasSelectionId ? selCmpt.init.map((i) => ({ unit: unit2, [SELECTION_ID]: assembleInit(i, false)[0] })) : selCmpt.init.map((i) => ({ unit: unit2, fields, values: assembleInit(i, false) }));
    }
    const contains2 = dataCopy.filter((d) => d.name === selCmpt.name + STORE);
    if (!contains2.length) {
      dataCopy.push(store);
    }
  }
  return dataCopy;
}
function assembleUnitSelectionMarks(model, marks) {
  var _a;
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    for (const c2 of selectionCompilers) {
      if (c2.defined(selCmpt) && c2.marks) {
        marks = c2.marks(model, selCmpt, marks);
      }
    }
  }
  return marks;
}
function assembleLayerSelectionMarks(model, marks) {
  for (const child of model.children) {
    if (isUnitModel(child)) {
      marks = assembleUnitSelectionMarks(child, marks);
    }
  }
  return marks;
}
function assembleSelectionScaleDomain(model, extent2, scaleCmpt, domain2) {
  const parsedExtent = parseSelectionExtent(model, extent2.param, extent2);
  return {
    signal: hasContinuousDomain(scaleCmpt.get("type")) && isArray$1(domain2) && domain2[0] > domain2[1] ? `isValid(${parsedExtent}) && reverse(${parsedExtent})` : parsedExtent
  };
}
function cleanupEmptyOnArray(signals) {
  return signals.map((s) => {
    if (s.on && !s.on.length)
      delete s.on;
    return s;
  });
}
class DataFlowNode {
  constructor(parent, debugName) {
    this.debugName = debugName;
    this._children = [];
    this._parent = null;
    if (parent) {
      this.parent = parent;
    }
  }
  /**
   * Clone this node with a deep copy but don't clone links to children or parents.
   */
  clone() {
    throw new Error("Cannot clone node");
  }
  get parent() {
    return this._parent;
  }
  /**
   * Set the parent of the node and also add this node to the parent's children.
   */
  set parent(parent) {
    this._parent = parent;
    if (parent) {
      parent.addChild(this);
    }
  }
  get children() {
    return this._children;
  }
  numChildren() {
    return this._children.length;
  }
  addChild(child, loc) {
    if (this._children.includes(child)) {
      warn(ADD_SAME_CHILD_TWICE);
      return;
    }
    if (loc !== void 0) {
      this._children.splice(loc, 0, child);
    } else {
      this._children.push(child);
    }
  }
  removeChild(oldChild) {
    const loc = this._children.indexOf(oldChild);
    this._children.splice(loc, 1);
    return loc;
  }
  /**
   * Remove node from the dataflow.
   */
  remove() {
    let loc = this._parent.removeChild(this);
    for (const child of this._children) {
      child._parent = this._parent;
      this._parent.addChild(child, loc++);
    }
  }
  /**
   * Insert another node as a parent of this node.
   */
  insertAsParentOf(other) {
    const parent = other.parent;
    parent.removeChild(this);
    this.parent = parent;
    other.parent = this;
  }
  swapWithParent() {
    const parent = this._parent;
    const newParent = parent.parent;
    for (const child of this._children) {
      child.parent = parent;
    }
    this._children = [];
    parent.removeChild(this);
    const loc = parent.parent.removeChild(parent);
    this._parent = newParent;
    newParent.addChild(this, loc);
    parent.parent = this;
  }
}
class OutputNode extends DataFlowNode {
  /**
   * @param source The name of the source. Will change in assemble.
   * @param type The type of the output node.
   * @param refCounts A global ref counter map.
   */
  constructor(parent, source2, type2, refCounts) {
    super(parent, source2);
    this.type = type2;
    this.refCounts = refCounts;
    this._source = this._name = source2;
    if (this.refCounts && !(this._name in this.refCounts)) {
      this.refCounts[this._name] = 0;
    }
  }
  clone() {
    const cloneObj = new this.constructor();
    cloneObj.debugName = `clone_${this.debugName}`;
    cloneObj._source = this._source;
    cloneObj._name = `clone_${this._name}`;
    cloneObj.type = this.type;
    cloneObj.refCounts = this.refCounts;
    cloneObj.refCounts[cloneObj._name] = 0;
    return cloneObj;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    if (this._hash === void 0) {
      this._hash = `Output ${uniqueId()}`;
    }
    return this._hash;
  }
  /**
   * Request the datasource name and increase the ref counter.
   *
   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.
   * It is crucial to request the name from an output node to mark it as a required node.
   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.
   *
   * In the assemble phase, this will return the correct name.
   */
  getSource() {
    this.refCounts[this._name]++;
    return this._source;
  }
  isRequired() {
    return !!this.refCounts[this._name];
  }
  setSource(source2) {
    this._source = source2;
  }
}
var __rest$e = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
class TimeUnitNode extends DataFlowNode {
  constructor(parent, formula) {
    super(parent);
    this.formula = formula;
  }
  clone() {
    return new TimeUnitNode(null, duplicate(this.formula));
  }
  static makeFromEncoding(parent, model) {
    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef) => {
      const { field: field2, timeUnit } = fieldDef;
      if (timeUnit) {
        const as = vgField(fieldDef, { forAs: true });
        timeUnitComponent[hash({
          as,
          field: field2,
          timeUnit
        })] = {
          as,
          field: field2,
          timeUnit
        };
      }
      return timeUnitComponent;
    }, {});
    if (isEmpty(formula)) {
      return null;
    }
    return new TimeUnitNode(parent, formula);
  }
  static makeFromTransform(parent, t4) {
    const _a = Object.assign({}, t4), { timeUnit } = _a, other = __rest$e(_a, ["timeUnit"]);
    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);
    const component = Object.assign(Object.assign({}, other), { timeUnit: normalizedTimeUnit });
    return new TimeUnitNode(parent, {
      [hash(component)]: component
    });
  }
  /**
   * Merge together TimeUnitNodes assigning the children of `other` to `this`
   * and removing `other`.
   */
  merge(other) {
    this.formula = Object.assign({}, this.formula);
    for (const key2 in other.formula) {
      if (!this.formula[key2]) {
        this.formula[key2] = other.formula[key2];
      }
    }
    for (const child of other.children) {
      other.removeChild(child);
      child.parent = this;
    }
    other.remove();
  }
  /**
   * Remove time units coming from the other node.
   */
  removeFormulas(fields) {
    const newFormula = {};
    for (const [key2, timeUnit] of entries$1(this.formula)) {
      if (!fields.has(timeUnit.as)) {
        newFormula[key2] = timeUnit;
      }
    }
    this.formula = newFormula;
  }
  producedFields() {
    return new Set(vals(this.formula).map((f) => f.as));
  }
  dependentFields() {
    return new Set(vals(this.formula).map((f) => f.field));
  }
  hash() {
    return `TimeUnit ${hash(this.formula)}`;
  }
  assemble() {
    const transforms2 = [];
    for (const f of vals(this.formula)) {
      const { field: field2, as, timeUnit } = f;
      const _a = normalizeTimeUnit(timeUnit), { unit: unit2, utc } = _a, params2 = __rest$e(_a, ["unit", "utc"]);
      transforms2.push(Object.assign(Object.assign(Object.assign(Object.assign({ field: replacePathInField(field2), type: "timeunit" }, unit2 ? { units: getTimeUnitParts(unit2) } : {}), utc ? { timezone: "utc" } : {}), params2), { as: [as, `${as}_end`] }));
    }
    return transforms2;
  }
}
var __rest$d = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
const TUPLE_FIELDS = "_tuple_fields";
class SelectionProjectionComponent {
  constructor(...items) {
    this.items = items;
    this.hasChannel = {};
    this.hasField = {};
    this.hasSelectionId = false;
  }
}
const project = {
  defined: () => {
    return true;
  },
  parse: (model, selCmpt, selDef) => {
    var _a;
    const name = selCmpt.name;
    const proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent();
    const parsed = {};
    const timeUnits2 = {};
    const signals = /* @__PURE__ */ new Set();
    const signalName = (p, range2) => {
      const suffix = range2 === "visual" ? p.channel : p.field;
      let sg = varName(`${name}_${suffix}`);
      for (let counter2 = 1; signals.has(sg); counter2++) {
        sg = varName(`${name}_${suffix}_${counter2}`);
      }
      signals.add(sg);
      return { [range2]: sg };
    };
    const type2 = selCmpt.type;
    const cfg = model.config.selection[type2];
    const init2 = selDef.value !== void 0 ? array$5(selDef.value) : null;
    let { fields, encodings } = isObject$1(selDef.select) ? selDef.select : {};
    if (!fields && !encodings && init2) {
      for (const initVal of init2) {
        if (!isObject$1(initVal)) {
          continue;
        }
        for (const key2 of keys$1(initVal)) {
          if (isSingleDefUnitChannel(key2)) {
            (encodings || (encodings = [])).push(key2);
          } else {
            if (type2 === "interval") {
              warn(INTERVAL_INITIALIZED_WITH_X_Y);
              encodings = cfg.encodings;
            } else {
              (fields || (fields = [])).push(key2);
            }
          }
        }
      }
    }
    if (!fields && !encodings) {
      encodings = cfg.encodings;
      if ("fields" in cfg) {
        fields = cfg.fields;
      }
    }
    for (const channel of encodings !== null && encodings !== void 0 ? encodings : []) {
      const fieldDef = model.fieldDef(channel);
      if (fieldDef) {
        let field2 = fieldDef.field;
        if (fieldDef.aggregate) {
          warn(cannotProjectAggregate(channel, fieldDef.aggregate));
          continue;
        } else if (!field2) {
          warn(cannotProjectOnChannelWithoutField(channel));
          continue;
        }
        if (fieldDef.timeUnit) {
          field2 = model.vgField(channel);
          const component = {
            timeUnit: fieldDef.timeUnit,
            as: field2,
            field: fieldDef.field
          };
          timeUnits2[hash(component)] = component;
        }
        if (!parsed[field2]) {
          let tplType = "E";
          if (type2 === "interval") {
            const scaleType2 = model.getScaleComponent(channel).get("type");
            if (hasContinuousDomain(scaleType2)) {
              tplType = "R";
            }
          } else if (fieldDef.bin) {
            tplType = "R-RE";
          }
          const p = { field: field2, channel, type: tplType };
          p.signals = Object.assign(Object.assign({}, signalName(p, "data")), signalName(p, "visual"));
          proj.items.push(parsed[field2] = p);
          proj.hasField[field2] = proj.hasChannel[channel] = parsed[field2];
          proj.hasSelectionId = proj.hasSelectionId || field2 === SELECTION_ID;
        }
      } else {
        warn(cannotProjectOnChannelWithoutField(channel));
      }
    }
    for (const field2 of fields !== null && fields !== void 0 ? fields : []) {
      if (proj.hasField[field2])
        continue;
      const p = { type: "E", field: field2 };
      p.signals = Object.assign({}, signalName(p, "data"));
      proj.items.push(p);
      proj.hasField[field2] = p;
      proj.hasSelectionId = proj.hasSelectionId || field2 === SELECTION_ID;
    }
    if (init2) {
      selCmpt.init = init2.map((v) => {
        return proj.items.map((p) => isObject$1(v) ? v[p.channel] !== void 0 ? v[p.channel] : v[p.field] : v);
      });
    }
    if (!isEmpty(timeUnits2)) {
      proj.timeUnit = new TimeUnitNode(null, timeUnits2);
    }
  },
  signals: (model, selCmpt, allSignals) => {
    const name = selCmpt.name + TUPLE_FIELDS;
    const hasSignal2 = allSignals.filter((s) => s.name === name);
    return hasSignal2.length > 0 || selCmpt.project.hasSelectionId ? allSignals : allSignals.concat({
      name,
      value: selCmpt.project.items.map((proj) => {
        const { signals, hasLegend } = proj, rest = __rest$d(proj, ["signals", "hasLegend"]);
        rest.field = replacePathInField(rest.field);
        return rest;
      })
    });
  }
};
const scaleBindings = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind === "scales";
  },
  parse: (model, selCmpt) => {
    const bound2 = selCmpt.scales = [];
    for (const proj of selCmpt.project.items) {
      const channel = proj.channel;
      if (!isScaleChannel(channel)) {
        continue;
      }
      const scale2 = model.getScaleComponent(channel);
      const scaleType2 = scale2 ? scale2.get("type") : void 0;
      if (!scale2 || !hasContinuousDomain(scaleType2)) {
        warn(SCALE_BINDINGS_CONTINUOUS);
        continue;
      }
      scale2.set("selectionExtent", { param: selCmpt.name, field: proj.field }, true);
      bound2.push(proj);
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const bound2 = selCmpt.scales.filter((proj) => signals.filter((s) => s.name === proj.signals.data).length === 0);
    if (!model.parent || isTopLevelLayer(model) || bound2.length === 0) {
      return signals;
    }
    const namedSg = signals.filter((s) => s.name === selCmpt.name)[0];
    let update2 = namedSg.update;
    if (update2.indexOf(VL_SELECTION_RESOLVE) >= 0) {
      namedSg.update = `{${bound2.map((proj) => `${$(replacePathInField(proj.field))}: ${proj.signals.data}`).join(", ")}}`;
    } else {
      for (const proj of bound2) {
        const mapping = `${$(replacePathInField(proj.field))}: ${proj.signals.data}`;
        if (!update2.includes(mapping)) {
          update2 = `${update2.substring(0, update2.length - 1)}, ${mapping}}`;
        }
      }
      namedSg.update = update2;
    }
    return signals.concat(bound2.map((proj) => ({ name: proj.signals.data })));
  },
  signals: (model, selCmpt, signals) => {
    if (model.parent && !isTopLevelLayer(model)) {
      for (const proj of selCmpt.scales) {
        const signal = signals.filter((s) => s.name === proj.signals.data)[0];
        signal.push = "outer";
        delete signal.value;
        delete signal.update;
      }
    }
    return signals;
  }
};
function domain(model, channel) {
  const scale2 = $(model.scaleName(channel));
  return `domain(${scale2})`;
}
function isTopLevelLayer(model) {
  var _a;
  return model.parent && isLayerModel(model.parent) && ((_a = !model.parent.parent) !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));
}
var __rest$c = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
const BRUSH = "_brush";
const SCALE_TRIGGER = "_scale_trigger";
const interval = {
  defined: (selCmpt) => selCmpt.type === "interval",
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const fieldsSg = name + TUPLE_FIELDS;
    const hasScales = scaleBindings.defined(selCmpt);
    const init2 = selCmpt.init ? selCmpt.init[0] : null;
    const dataSignals = [];
    const scaleTriggers = [];
    if (selCmpt.translate && !hasScales) {
      const filterExpr = `!event.item || event.item.mark.name !== ${$(name + BRUSH)}`;
      events(selCmpt, (on2, evt) => {
        var _a;
        var _b;
        const filters2 = array$5((_a = (_b = evt.between[0]).filter) !== null && _a !== void 0 ? _a : _b.filter = []);
        if (!filters2.includes(filterExpr)) {
          filters2.push(filterExpr);
        }
        return on2;
      });
    }
    selCmpt.project.items.forEach((proj, i) => {
      const channel = proj.channel;
      if (channel !== X && channel !== Y) {
        warn("Interval selections only support x and y encoding channels.");
        return;
      }
      const val = init2 ? init2[i] : null;
      const cs = channelSignals(model, selCmpt, proj, val);
      const dname = proj.signals.data;
      const vname = proj.signals.visual;
      const scaleName = $(model.scaleName(channel));
      const scaleType2 = model.getScaleComponent(channel).get("type");
      const toNum = hasContinuousDomain(scaleType2) ? "+" : "";
      signals.push(...cs);
      dataSignals.push(dname);
      scaleTriggers.push({
        scaleName: model.scaleName(channel),
        expr: `(!isArray(${dname}) || (${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`
      });
    });
    if (!hasScales && scaleTriggers.length) {
      signals.push({
        name: name + SCALE_TRIGGER,
        value: {},
        on: [
          {
            events: scaleTriggers.map((t4) => ({ scale: t4.scaleName })),
            update: `${scaleTriggers.map((t4) => t4.expr).join(" && ")} ? ${name + SCALE_TRIGGER} : {}`
          }
        ]
      });
    }
    const update2 = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;
    return signals.concat(Object.assign(Object.assign({ name: name + TUPLE }, init2 ? { init: `{${update2}: ${assembleInit(init2)}}` } : {}), dataSignals.length ? {
      on: [
        {
          events: [{ signal: dataSignals.join(" || ") }],
          update: `${dataSignals.join(" && ")} ? {${update2}: [${dataSignals}]} : null`
        }
      ]
    } : {}));
  },
  marks: (model, selCmpt, marks) => {
    const name = selCmpt.name;
    const { x: x2, y: y2 } = selCmpt.project.hasChannel;
    const xvname = x2 === null || x2 === void 0 ? void 0 : x2.signals.visual;
    const yvname = y2 === null || y2 === void 0 ? void 0 : y2.signals.visual;
    const store = `data(${$(selCmpt.name + STORE)})`;
    if (scaleBindings.defined(selCmpt) || !x2 && !y2) {
      return marks;
    }
    const update2 = {
      x: x2 !== void 0 ? { signal: `${xvname}[0]` } : { value: 0 },
      y: y2 !== void 0 ? { signal: `${yvname}[0]` } : { value: 0 },
      x2: x2 !== void 0 ? { signal: `${xvname}[1]` } : { field: { group: "width" } },
      y2: y2 !== void 0 ? { signal: `${yvname}[1]` } : { field: { group: "height" } }
    };
    if (selCmpt.resolve === "global") {
      for (const key2 of keys$1(update2)) {
        update2[key2] = [
          Object.assign({ test: `${store}.length && ${store}[0].unit === ${unitName(model)}` }, update2[key2]),
          { value: 0 }
        ];
      }
    }
    const _a = selCmpt.mark, { fill: fill2, fillOpacity, cursor: cursor2 } = _a, stroke2 = __rest$c(_a, ["fill", "fillOpacity", "cursor"]);
    const vgStroke = keys$1(stroke2).reduce((def2, k) => {
      def2[k] = [
        {
          test: [x2 !== void 0 && `${xvname}[0] !== ${xvname}[1]`, y2 !== void 0 && `${yvname}[0] !== ${yvname}[1]`].filter((t4) => t4).join(" && "),
          value: stroke2[k]
        },
        { value: null }
      ];
      return def2;
    }, {});
    return [
      {
        name: `${name + BRUSH}_bg`,
        type: "rect",
        clip: true,
        encode: {
          enter: {
            fill: { value: fill2 },
            fillOpacity: { value: fillOpacity }
          },
          update: update2
        }
      },
      ...marks,
      {
        name: name + BRUSH,
        type: "rect",
        clip: true,
        encode: {
          enter: Object.assign(Object.assign({}, cursor2 ? { cursor: { value: cursor2 } } : {}), { fill: { value: "transparent" } }),
          update: Object.assign(Object.assign({}, update2), vgStroke)
        }
      }
    ];
  }
};
function channelSignals(model, selCmpt, proj, init2) {
  const channel = proj.channel;
  const vname = proj.signals.visual;
  const dname = proj.signals.data;
  const hasScales = scaleBindings.defined(selCmpt);
  const scaleName = $(model.scaleName(channel));
  const scale2 = model.getScaleComponent(channel);
  const scaleType2 = scale2 ? scale2.get("type") : void 0;
  const scaled = (str) => `scale(${scaleName}, ${str})`;
  const size = model.getSizeSignalRef(channel === X ? "width" : "height").signal;
  const coord = `${channel}(unit)`;
  const on2 = events(selCmpt, (def2, evt) => {
    return [
      ...def2,
      { events: evt.between[0], update: `[${coord}, ${coord}]` },
      { events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]` }
      // Brush End
    ];
  });
  on2.push({
    events: { signal: selCmpt.name + SCALE_TRIGGER },
    update: hasContinuousDomain(scaleType2) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`
  });
  return hasScales ? [{ name: dname, on: [] }] : [
    Object.assign(Object.assign({ name: vname }, init2 ? { init: assembleInit(init2, true, scaled) } : { value: [] }), { on: on2 }),
    Object.assign(Object.assign({ name: dname }, init2 ? { init: assembleInit(init2) } : {}), { on: [
      {
        events: { signal: vname },
        update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`
      }
    ] })
  ];
}
function events(selCmpt, cb) {
  return selCmpt.events.reduce((on2, evt) => {
    if (!evt.between) {
      warn(`${evt} is not an ordered event stream for interval selections.`);
      return on2;
    }
    return cb(on2, evt);
  }, []);
}
const point$1 = {
  defined: (selCmpt) => selCmpt.type === "point",
  signals: (model, selCmpt, signals) => {
    var _a;
    const name = selCmpt.name;
    const fieldsSg = name + TUPLE_FIELDS;
    const project2 = selCmpt.project;
    const datum2 = "(item().isVoronoi ? datum.datum : datum)";
    const brushes = vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce((acc, cmpt) => {
      return cmpt.type === "interval" ? acc.concat(cmpt.name + BRUSH) : acc;
    }, []).map((b2) => `indexof(item().mark.name, '${b2}') < 0`).join(" && ");
    const test2 = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${brushes ? ` && ${brushes}` : ""}`;
    let update2 = `unit: ${unitName(model)}, `;
    if (selCmpt.project.hasSelectionId) {
      update2 += `${SELECTION_ID}: ${datum2}[${$(SELECTION_ID)}]`;
    } else {
      const values2 = project2.items.map((p) => {
        const fieldDef = model.fieldDef(p.channel);
        return (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) ? `[${datum2}[${$(model.vgField(p.channel, {}))}], ${datum2}[${$(model.vgField(p.channel, { binSuffix: "end" }))}]]` : `${datum2}[${$(p.field)}]`;
      }).join(", ");
      update2 += `fields: ${fieldsSg}, values: [${values2}]`;
    }
    const events2 = selCmpt.events;
    return signals.concat([
      {
        name: name + TUPLE,
        on: events2 ? [
          {
            events: events2,
            update: `${test2} ? {${update2}} : null`,
            force: true
          }
        ] : []
      }
    ]);
  }
};
function wrapCondition(model, channelDef, vgChannel, refFn) {
  const condition = isConditionalDef(channelDef) && channelDef.condition;
  const valueRef = refFn(channelDef);
  if (condition) {
    const conditions = array$5(condition);
    const vgConditions = conditions.map((c2) => {
      const conditionValueRef = refFn(c2);
      if (isConditionalParameter(c2)) {
        const { param: param2, empty } = c2;
        const test2 = parseSelectionPredicate(model, { param: param2, empty });
        return Object.assign({ test: test2 }, conditionValueRef);
      } else {
        const test2 = expression(model, c2.test);
        return Object.assign({ test: test2 }, conditionValueRef);
      }
    });
    return {
      [vgChannel]: [...vgConditions, ...valueRef !== void 0 ? [valueRef] : []]
    };
  } else {
    return valueRef !== void 0 ? { [vgChannel]: valueRef } : {};
  }
}
function text$1(model, channel = "text") {
  const channelDef = model.encoding[channel];
  return wrapCondition(model, channelDef, channel, (cDef) => textRef(cDef, model.config));
}
function textRef(channelDef, config, expr2 = "datum") {
  if (channelDef) {
    if (isValueDef(channelDef)) {
      return signalOrValueRef(channelDef.value);
    }
    if (isFieldOrDatumDef(channelDef)) {
      const { format: format2, formatType } = getFormatMixins(channelDef);
      return formatSignalRef({ fieldOrDatumDef: channelDef, format: format2, formatType, expr: expr2, config });
    }
  }
  return void 0;
}
function tooltip(model, opt = {}) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding.tooltip;
  if (isArray$1(channelDef)) {
    return { tooltip: tooltipRefForEncoding({ tooltip: channelDef }, stack2, config, opt) };
  } else {
    const datum2 = opt.reactiveGeom ? "datum.datum" : "datum";
    return wrapCondition(model, channelDef, "tooltip", (cDef) => {
      const tooltipRefFromChannelDef = textRef(cDef, config, datum2);
      if (tooltipRefFromChannelDef) {
        return tooltipRefFromChannelDef;
      }
      if (cDef === null) {
        return void 0;
      }
      let markTooltip = getMarkPropOrConfig("tooltip", markDef, config);
      if (markTooltip === true) {
        markTooltip = { content: "encoding" };
      }
      if (isString(markTooltip)) {
        return { value: markTooltip };
      } else if (isObject$1(markTooltip)) {
        if (isSignalRef(markTooltip)) {
          return markTooltip;
        } else if (markTooltip.content === "encoding") {
          return tooltipRefForEncoding(encoding, stack2, config, opt);
        } else {
          return { signal: datum2 };
        }
      }
      return void 0;
    });
  }
}
function tooltipData(encoding, stack2, config, { reactiveGeom } = {}) {
  const toSkip = {};
  const expr2 = reactiveGeom ? "datum.datum" : "datum";
  const tuples = [];
  function add2(fDef, channel) {
    const mainChannel = getMainRangeChannel(channel);
    const fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {
      type: encoding[mainChannel].type
      // for secondary field def, copy type from main channel
    });
    const title2 = fieldDef.title || defaultTitle(fieldDef, config);
    const key2 = array$5(title2).join(", ");
    let value2;
    if (isXorY(channel)) {
      const channel2 = channel === "x" ? "x2" : "y2";
      const fieldDef2 = getFieldDef(encoding[channel2]);
      if (isBinned(fieldDef.bin) && fieldDef2) {
        const startField = vgField(fieldDef, { expr: expr2 });
        const endField = vgField(fieldDef2, { expr: expr2 });
        const { format: format2, formatType } = getFormatMixins(fieldDef);
        value2 = binFormatExpression(startField, endField, format2, formatType, config);
        toSkip[channel2] = true;
      }
    }
    if ((isXorY(channel) || channel === THETA || channel === RADIUS) && stack2 && stack2.fieldChannel === channel && stack2.offset === "normalize") {
      const { format: format2, formatType } = getFormatMixins(fieldDef);
      value2 = formatSignalRef({
        fieldOrDatumDef: fieldDef,
        format: format2,
        formatType,
        expr: expr2,
        config,
        normalizeStack: true
      }).signal;
    }
    value2 !== null && value2 !== void 0 ? value2 : value2 = textRef(fieldDef, config, expr2).signal;
    tuples.push({ channel, key: key2, value: value2 });
  }
  forEach(encoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      add2(channelDef, channel);
    } else if (hasConditionalFieldDef(channelDef)) {
      add2(channelDef.condition, channel);
    }
  });
  const out = {};
  for (const { channel, key: key2, value: value2 } of tuples) {
    if (!toSkip[channel] && !out[key2]) {
      out[key2] = value2;
    }
  }
  return out;
}
function tooltipRefForEncoding(encoding, stack2, config, { reactiveGeom } = {}) {
  const data2 = tooltipData(encoding, stack2, config, { reactiveGeom });
  const keyValues = entries$1(data2).map(([key2, value2]) => `"${key2}": ${value2}`);
  return keyValues.length > 0 ? { signal: `{${keyValues.join(", ")}}` } : void 0;
}
function aria(model) {
  const { markDef, config } = model;
  const enableAria = getMarkPropOrConfig("aria", markDef, config);
  if (enableAria === false) {
    return {};
  }
  return Object.assign(Object.assign(Object.assign({}, enableAria ? { aria: enableAria } : {}), ariaRoleDescription(model)), description(model));
}
function ariaRoleDescription(model) {
  const { mark: mark2, markDef, config } = model;
  if (config.aria === false) {
    return {};
  }
  const ariaRoleDesc = getMarkPropOrConfig("ariaRoleDescription", markDef, config);
  if (ariaRoleDesc != null) {
    return { ariaRoleDescription: { value: ariaRoleDesc } };
  }
  return mark2 in VG_MARK_INDEX ? {} : { ariaRoleDescription: { value: mark2 } };
}
function description(model) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding.description;
  if (channelDef) {
    return wrapCondition(model, channelDef, "description", (cDef) => textRef(cDef, model.config));
  }
  const descriptionValue = getMarkPropOrConfig("description", markDef, config);
  if (descriptionValue != null) {
    return {
      description: signalOrValueRef(descriptionValue)
    };
  }
  if (config.aria === false) {
    return {};
  }
  const data2 = tooltipData(encoding, stack2, config);
  if (isEmpty(data2)) {
    return void 0;
  }
  return {
    description: {
      signal: entries$1(data2).map(([key2, value2], index2) => `"${index2 > 0 ? "; " : ""}${key2}: " + (${value2})`).join(" + ")
    }
  };
}
function nonPosition(channel, model, opt = {}) {
  const { markDef, encoding, config } = model;
  const { vgChannel } = opt;
  let { defaultRef, defaultValue } = opt;
  if (defaultRef === void 0) {
    defaultValue !== null && defaultValue !== void 0 ? defaultValue : defaultValue = getMarkPropOrConfig(channel, markDef, config, { vgChannel, ignoreVgConfig: true });
    if (defaultValue !== void 0) {
      defaultRef = signalOrValueRef(defaultValue);
    }
  }
  const channelDef = encoding[channel];
  return wrapCondition(model, channelDef, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, (cDef) => {
    return midPoint({
      channel,
      channelDef: cDef,
      markDef,
      config,
      scaleName: model.scaleName(channel),
      scale: model.getScaleComponent(channel),
      stack: null,
      defaultRef
    });
  });
}
function color(model, opt = { filled: void 0 }) {
  var _a, _b, _c2, _d2;
  const { markDef, encoding, config } = model;
  const { type: markType2 } = markDef;
  const filled = (_a = opt.filled) !== null && _a !== void 0 ? _a : getMarkPropOrConfig("filled", markDef, config);
  const transparentIfNeeded = contains(["bar", "point", "circle", "square", "geoshape"], markType2) ? "transparent" : void 0;
  const defaultFill = (_c2 = (_b = getMarkPropOrConfig(filled === true ? "color" : void 0, markDef, config, { vgChannel: "fill" })) !== null && _b !== void 0 ? _b : (
    // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
    config.mark[filled === true && "color"]
  )) !== null && _c2 !== void 0 ? _c2 : (
    // If there is no fill, always fill symbols, bar, geoshape
    // with transparent fills https://github.com/vega/vega-lite/issues/1316
    transparentIfNeeded
  );
  const defaultStroke = (_d2 = getMarkPropOrConfig(filled === false ? "color" : void 0, markDef, config, { vgChannel: "stroke" })) !== null && _d2 !== void 0 ? _d2 : (
    // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
    config.mark[filled === false && "color"]
  );
  const colorVgChannel = filled ? "fill" : "stroke";
  const fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, defaultFill ? { fill: signalOrValueRef(defaultFill) } : {}), defaultStroke ? { stroke: signalOrValueRef(defaultStroke) } : {});
  if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {
    warn(droppingColor("property", { fill: "fill" in markDef, stroke: "stroke" in markDef }));
  }
  return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition("color", model, {
    vgChannel: colorVgChannel,
    defaultValue: filled ? defaultFill : defaultStroke
  })), nonPosition("fill", model, {
    // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding
    defaultValue: encoding.fill ? defaultFill : void 0
  })), nonPosition("stroke", model, {
    // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding
    defaultValue: encoding.stroke ? defaultStroke : void 0
  }));
}
function zindex(model) {
  const { encoding, mark: mark2 } = model;
  const order = encoding.order;
  if (!isPathMark(mark2) && isValueDef(order)) {
    return wrapCondition(model, order, "zindex", (cd) => signalOrValueRef(cd.value));
  }
  return {};
}
function positionOffset({ channel: baseChannel, markDef, encoding = {}, model, bandPosition }) {
  const channel = `${baseChannel}Offset`;
  const defaultValue = markDef[channel];
  const channelDef = encoding[channel];
  if ((channel === "xOffset" || channel === "yOffset") && channelDef) {
    const ref2 = midPoint({
      channel,
      channelDef,
      markDef,
      config: model === null || model === void 0 ? void 0 : model.config,
      scaleName: model.scaleName(channel),
      scale: model.getScaleComponent(channel),
      stack: null,
      defaultRef: signalOrValueRef(defaultValue),
      bandPosition
    });
    return { offsetType: "encoding", offset: ref2 };
  }
  const markDefOffsetValue = markDef[channel];
  if (markDefOffsetValue) {
    return { offsetType: "visual", offset: markDefOffsetValue };
  }
  return {};
}
function pointPosition(channel, model, { defaultPos, vgChannel }) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding[channel];
  const channel2Def = encoding[getSecondaryRangeChannel(channel)];
  const scaleName = model.scaleName(channel);
  const scale2 = model.getScaleComponent(channel);
  const { offset: offset2, offsetType } = positionOffset({
    channel,
    markDef,
    encoding,
    model,
    bandPosition: 0.5
  });
  const defaultRef = pointPositionDefaultRef({
    model,
    defaultPos,
    channel,
    scaleName,
    scale: scale2
  });
  const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ? (
    // use geopoint output if there are lat/long and there is no point position overriding lat/long.
    { field: model.getName(channel) }
  ) : positionRef({
    channel,
    channelDef,
    channel2Def,
    markDef,
    config,
    scaleName,
    scale: scale2,
    stack: stack2,
    offset: offset2,
    defaultRef,
    bandPosition: offsetType === "encoding" ? 0 : void 0
  });
  return valueRef ? { [vgChannel || channel]: valueRef } : void 0;
}
function positionRef(params2) {
  const { channel, channelDef, scaleName, stack: stack2, offset: offset2, markDef } = params2;
  if (isFieldOrDatumDef(channelDef) && stack2 && channel === stack2.fieldChannel) {
    if (isFieldDef(channelDef)) {
      let bandPosition = channelDef.bandPosition;
      if (bandPosition === void 0 && markDef.type === "text" && (channel === "radius" || channel === "theta")) {
        bandPosition = 0.5;
      }
      if (bandPosition !== void 0) {
        return interpolatedSignalRef({
          scaleName,
          fieldOrDatumDef: channelDef,
          startSuffix: "start",
          bandPosition,
          offset: offset2
        });
      }
    }
    return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "end" }, { offset: offset2 });
  }
  return midPointRefWithPositionInvalidTest(params2);
}
function pointPositionDefaultRef({ model, defaultPos, channel, scaleName, scale: scale2 }) {
  const { markDef, config } = model;
  return () => {
    const mainChannel = getMainRangeChannel(channel);
    const vgChannel = getVgPositionChannel(channel);
    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, { vgChannel });
    if (definedValueOrConfig !== void 0) {
      return widthHeightValueOrSignalRef(channel, definedValueOrConfig);
    }
    switch (defaultPos) {
      case "zeroOrMin":
      case "zeroOrMax":
        if (scaleName) {
          const scaleType2 = scale2.get("type");
          if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType2)) ;
          else {
            if (scale2.domainDefinitelyIncludesZero()) {
              return {
                scale: scaleName,
                value: 0
              };
            }
          }
        }
        if (defaultPos === "zeroOrMin") {
          return mainChannel === "y" ? { field: { group: "height" } } : { value: 0 };
        } else {
          switch (mainChannel) {
            case "radius":
              return {
                signal: `min(${model.width.signal},${model.height.signal})/2`
              };
            case "theta":
              return { signal: "2*PI" };
            case "x":
              return { field: { group: "width" } };
            case "y":
              return { value: 0 };
          }
        }
        break;
      case "mid": {
        const sizeRef = model[getSizeChannel(channel)];
        return Object.assign(Object.assign({}, sizeRef), { mult: 0.5 });
      }
    }
    return void 0;
  };
}
const ALIGNED_X_CHANNEL = {
  left: "x",
  center: "xc",
  right: "x2"
};
const BASELINED_Y_CHANNEL = {
  top: "y",
  middle: "yc",
  bottom: "y2"
};
function vgAlignedPositionChannel(channel, markDef, config, defaultAlign = "middle") {
  if (channel === "radius" || channel === "theta") {
    return getVgPositionChannel(channel);
  }
  const alignChannel = channel === "x" ? "align" : "baseline";
  const align2 = getMarkPropOrConfig(alignChannel, markDef, config);
  let alignExcludingSignal;
  if (isSignalRef(align2)) {
    warn(rangeMarkAlignmentCannotBeExpression(alignChannel));
    alignExcludingSignal = void 0;
  } else {
    alignExcludingSignal = align2;
  }
  if (channel === "x") {
    return ALIGNED_X_CHANNEL[alignExcludingSignal || (defaultAlign === "top" ? "left" : "center")];
  } else {
    return BASELINED_Y_CHANNEL[alignExcludingSignal || defaultAlign];
  }
}
function pointOrRangePosition(channel, model, { defaultPos, defaultPos2, range: range2 }) {
  if (range2) {
    return rangePosition(channel, model, { defaultPos, defaultPos2 });
  }
  return pointPosition(channel, model, { defaultPos });
}
function rangePosition(channel, model, { defaultPos, defaultPos2 }) {
  const { markDef, config } = model;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);
  const vgChannel = pos2Mixins[sizeChannel] ? (
    // If there is width/height, we need to position the marks based on the alignment.
    vgAlignedPositionChannel(channel, markDef, config)
  ) : (
    // Otherwise, make sure to apply to the right Vg Channel (for arc mark)
    getVgPositionChannel(channel)
  );
  return Object.assign(Object.assign({}, pointPosition(channel, model, { defaultPos, vgChannel })), pos2Mixins);
}
function pointPosition2OrSize(model, defaultPos, channel) {
  const { encoding, mark: mark2, markDef, stack: stack2, config } = model;
  const baseChannel = getMainRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const channelDef = encoding[baseChannel];
  const scaleName = model.scaleName(baseChannel);
  const scale2 = model.getScaleComponent(baseChannel);
  const { offset: offset2 } = channel in encoding || channel in markDef ? positionOffset({ channel, markDef, encoding, model }) : positionOffset({ channel: baseChannel, markDef, encoding, model });
  if (!channelDef && (channel === "x2" || channel === "y2") && (encoding.latitude || encoding.longitude)) {
    const vgSizeChannel = getSizeChannel(channel);
    const size = model.markDef[vgSizeChannel];
    if (size != null) {
      return {
        [vgSizeChannel]: { value: size }
      };
    } else {
      return {
        [vgChannel]: { field: model.getName(channel) }
      };
    }
  }
  const valueRef = position2Ref({
    channel,
    channelDef,
    channel2Def: encoding[channel],
    markDef,
    config,
    scaleName,
    scale: scale2,
    stack: stack2,
    offset: offset2,
    defaultRef: void 0
  });
  if (valueRef !== void 0) {
    return { [vgChannel]: valueRef };
  }
  return position2orSize(channel, markDef) || position2orSize(channel, {
    [channel]: getMarkStyleConfig(channel, markDef, config.style),
    [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)
  }) || position2orSize(channel, config[mark2]) || position2orSize(channel, config.mark) || {
    [vgChannel]: pointPositionDefaultRef({
      model,
      defaultPos,
      channel,
      scaleName,
      scale: scale2
    })()
  };
}
function position2Ref({ channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale2, stack: stack2, offset: offset2, defaultRef }) {
  if (isFieldOrDatumDef(channelDef) && stack2 && // If fieldChannel is X and channel is X2 (or Y and Y2)
  channel.charAt(0) === stack2.fieldChannel.charAt(0)) {
    return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "start" }, { offset: offset2 });
  }
  return midPointRefWithPositionInvalidTest({
    channel,
    channelDef: channel2Def,
    scaleName,
    scale: scale2,
    stack: stack2,
    markDef,
    config,
    offset: offset2,
    defaultRef
  });
}
function position2orSize(channel, markDef) {
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  if (markDef[vgChannel] !== void 0) {
    return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[vgChannel]) };
  } else if (markDef[channel] !== void 0) {
    return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[channel]) };
  } else if (markDef[sizeChannel]) {
    const dimensionSize = markDef[sizeChannel];
    if (isRelativeBandSize(dimensionSize)) {
      warn(relativeBandSizeNotSupported(sizeChannel));
    } else {
      return { [sizeChannel]: widthHeightValueOrSignalRef(channel, dimensionSize) };
    }
  }
  return void 0;
}
function rectPosition(model, channel) {
  var _a, _b;
  const { config, encoding, markDef } = model;
  const mark2 = markDef.type;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const channelDef = encoding[channel];
  const channelDef2 = encoding[channel2];
  const scale2 = model.getScaleComponent(channel);
  const scaleType2 = scale2 ? scale2.get("type") : void 0;
  const orient2 = markDef.orient;
  const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig("size", markDef, config, { vgChannel: sizeChannel });
  const isBarBand = mark2 === "bar" && (channel === "x" ? orient2 === "vertical" : orient2 === "horizontal");
  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) && !hasDiscreteDomain(scaleType2)) {
    return rectBinPosition({
      fieldDef: channelDef,
      fieldDef2: channelDef2,
      channel,
      model
    });
  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType2) || isBarBand) && !channelDef2) {
    return positionAndSize(channelDef, channel, model);
  } else {
    return rangePosition(channel, model, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
  }
}
function defaultSizeRef(sizeChannel, scaleName, scale2, config, bandSize) {
  if (isRelativeBandSize(bandSize)) {
    if (scale2) {
      const scaleType2 = scale2.get("type");
      if (scaleType2 === "band") {
        let bandWidth = `bandwidth('${scaleName}')`;
        if (bandSize.band !== 1) {
          bandWidth = `${bandSize.band} * ${bandWidth}`;
        }
        return { signal: `max(0.25, ${bandWidth})` };
      } else if (bandSize.band !== 1) {
        warn(cannotUseRelativeBandSizeWithNonBandScale(scaleType2));
        bandSize = void 0;
      }
    } else {
      return {
        mult: bandSize.band,
        field: { group: sizeChannel }
      };
    }
  } else if (isSignalRef(bandSize)) {
    return bandSize;
  } else if (bandSize) {
    return { value: bandSize };
  }
  if (scale2) {
    const scaleRange = scale2.get("range");
    if (isVgRangeStep(scaleRange) && isNumber$1(scaleRange.step)) {
      return { value: scaleRange.step - 2 };
    }
  }
  const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);
  return { value: defaultStep - 2 };
}
function positionAndSize(fieldDef, channel, model) {
  const { markDef, encoding, config, stack: stack2 } = model;
  const orient2 = markDef.orient;
  const scaleName = model.scaleName(channel);
  const scale2 = model.getScaleComponent(channel);
  const vgSizeChannel = getSizeChannel(channel);
  const channel2 = getSecondaryRangeChannel(channel);
  const offsetScaleChannel = getOffsetChannel(channel);
  const offsetScaleName = model.scaleName(offsetScaleChannel);
  const useVlSizeChannel = orient2 === "horizontal" && channel === "y" || orient2 === "vertical" && channel === "x";
  let sizeMixins;
  if (encoding.size || markDef.size) {
    if (useVlSizeChannel) {
      sizeMixins = nonPosition("size", model, {
        vgChannel: vgSizeChannel,
        defaultRef: signalOrValueRef(markDef.size)
      });
    } else {
      warn(cannotApplySizeToNonOrientedMark(markDef.type));
    }
  }
  const hasSizeFromMarkOrEncoding = !!sizeMixins;
  const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType: scale2 === null || scale2 === void 0 ? void 0 : scale2.get("type"), useVlSizeChannel });
  sizeMixins = sizeMixins || {
    [vgSizeChannel]: defaultSizeRef(vgSizeChannel, offsetScaleName || scaleName, scale2, config, bandSize)
  };
  const defaultBandAlign = (scale2 === null || scale2 === void 0 ? void 0 : scale2.get("type")) === "band" && isRelativeBandSize(bandSize) && !hasSizeFromMarkOrEncoding ? "top" : "middle";
  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);
  const center = vgChannel === "xc" || vgChannel === "yc";
  const { offset: offset2, offsetType } = positionOffset({ channel, markDef, encoding, model, bandPosition: center ? 0.5 : 0 });
  const posRef = midPointRefWithPositionInvalidTest({
    channel,
    channelDef: fieldDef,
    markDef,
    config,
    scaleName,
    scale: scale2,
    stack: stack2,
    offset: offset2,
    defaultRef: pointPositionDefaultRef({ model, defaultPos: "mid", channel, scaleName, scale: scale2 }),
    bandPosition: center ? offsetType === "encoding" ? 0 : 0.5 : isSignalRef(bandSize) ? { signal: `(1-${bandSize})/2` } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0
  });
  if (vgSizeChannel) {
    return Object.assign({ [vgChannel]: posRef }, sizeMixins);
  } else {
    const vgChannel2 = getVgPositionChannel(channel2);
    const sizeRef = sizeMixins[vgSizeChannel];
    const sizeOffset = offset2 ? Object.assign(Object.assign({}, sizeRef), { offset: offset2 }) : sizeRef;
    return {
      [vgChannel]: posRef,
      // posRef might be an array that wraps position invalid test
      [vgChannel2]: isArray$1(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), { offset: sizeOffset })] : Object.assign(Object.assign({}, posRef), { offset: sizeOffset })
    };
  }
}
function getBinSpacing(channel, spacing, reverse2, translate2, offset2) {
  if (isPolarPositionChannel(channel)) {
    return 0;
  }
  const spacingOffset = channel === "x" || channel === "y2" ? -spacing / 2 : spacing / 2;
  if (isSignalRef(reverse2) || isSignalRef(offset2) || isSignalRef(translate2)) {
    const reverseExpr = signalOrStringValue(reverse2);
    const offsetExpr = signalOrStringValue(offset2);
    const translateExpr = signalOrStringValue(translate2);
    const t4 = translateExpr ? `${translateExpr} + ` : "";
    const r2 = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : "";
    const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;
    return {
      signal: t4 + r2 + o
    };
  } else {
    offset2 = offset2 || 0;
    return translate2 + (reverse2 ? -offset2 - spacingOffset : +offset2 + spacingOffset);
  }
}
function rectBinPosition({ fieldDef, fieldDef2, channel, model }) {
  var _a, _b, _c2;
  const { config, markDef, encoding } = model;
  const scale2 = model.getScaleComponent(channel);
  const scaleName = model.scaleName(channel);
  const scaleType2 = scale2 ? scale2.get("type") : void 0;
  const reverse2 = scale2.get("reverse");
  const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType: scaleType2 });
  const axis = (_a = model.component.axes[channel]) === null || _a === void 0 ? void 0 : _a[0];
  const axisTranslate = (_b = axis === null || axis === void 0 ? void 0 : axis.get("translate")) !== null && _b !== void 0 ? _b : 0.5;
  const spacing = isXorY(channel) ? (_c2 = getMarkPropOrConfig("binSpacing", markDef, config)) !== null && _c2 !== void 0 ? _c2 : 0 : 0;
  const channel2 = getSecondaryRangeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const vgChannel2 = getVgPositionChannel(channel2);
  const { offset: offset2 } = positionOffset({ channel, markDef, encoding, model, bandPosition: 0 });
  const bandPosition = isSignalRef(bandSize) ? { signal: `(1-${bandSize.signal})/2` } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0.5;
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {
    return {
      [vgChannel2]: rectBinRef({
        fieldDef,
        scaleName,
        bandPosition,
        offset: getBinSpacing(channel2, spacing, reverse2, axisTranslate, offset2)
      }),
      [vgChannel]: rectBinRef({
        fieldDef,
        scaleName,
        bandPosition: isSignalRef(bandPosition) ? { signal: `1-${bandPosition.signal}` } : 1 - bandPosition,
        offset: getBinSpacing(channel, spacing, reverse2, axisTranslate, offset2)
      })
    };
  } else if (isBinned(fieldDef.bin)) {
    const startRef = valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: getBinSpacing(channel2, spacing, reverse2, axisTranslate, offset2) });
    if (isFieldDef(fieldDef2)) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: getBinSpacing(channel, spacing, reverse2, axisTranslate, offset2) })
      };
    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: {
          signal: `scale("${scaleName}", ${vgField(fieldDef, { expr: "datum" })} + ${fieldDef.bin.step})`,
          offset: getBinSpacing(channel, spacing, reverse2, axisTranslate, offset2)
        }
      };
    }
  }
  warn(channelRequiredForBinned(channel2));
  return void 0;
}
function rectBinRef({ fieldDef, scaleName, bandPosition, offset: offset2 }) {
  return interpolatedSignalRef({
    scaleName,
    fieldOrDatumDef: fieldDef,
    bandPosition,
    offset: offset2
  });
}
const ALWAYS_IGNORE = /* @__PURE__ */ new Set(["aria", "width", "height"]);
function baseEncodeEntry(model, ignore) {
  const { fill: fill2 = void 0, stroke: stroke2 = void 0 } = ignore.color === "include" ? color(model) : {};
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, "fill", fill2)), wrapAllFieldsInvalid(model, "stroke", stroke2)), nonPosition("opacity", model)), nonPosition("fillOpacity", model)), nonPosition("strokeOpacity", model)), nonPosition("strokeWidth", model)), nonPosition("strokeDash", model)), zindex(model)), tooltip(model)), text$1(model, "href")), aria(model));
}
function wrapAllFieldsInvalid(model, channel, valueRef) {
  const { config, mark: mark2, markDef } = model;
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid === "hide" && valueRef && !isPathMark(mark2)) {
    const test2 = allFieldsInvalidPredicate$1(model, { invalid: true, channels: SCALE_CHANNELS });
    if (test2) {
      return {
        [channel]: [
          // prepend the invalid case
          // TODO: support custom value
          { test: test2, value: null },
          ...array$5(valueRef)
        ]
      };
    }
  }
  return valueRef ? { [channel]: valueRef } : {};
}
function markDefProperties(mark2, ignore) {
  return VG_MARK_CONFIGS.reduce((m2, prop) => {
    if (!ALWAYS_IGNORE.has(prop) && mark2[prop] !== void 0 && ignore[prop] !== "ignore") {
      m2[prop] = signalOrValueRef(mark2[prop]);
    }
    return m2;
  }, {});
}
function allFieldsInvalidPredicate$1(model, { invalid = false, channels }) {
  const filterIndex = channels.reduce((aggregator, channel) => {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const scaleType2 = scaleComponent.get("type");
      const field2 = model.vgField(channel, { expr: "datum" });
      if (field2 && hasContinuousDomain(scaleType2)) {
        aggregator[field2] = true;
      }
    }
    return aggregator;
  }, {});
  const fields = keys$1(filterIndex);
  if (fields.length > 0) {
    const op = invalid ? "||" : "&&";
    return fields.map((field2) => fieldInvalidPredicate(field2, invalid)).join(` ${op} `);
  }
  return void 0;
}
function defined(model) {
  const { config, markDef } = model;
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid) {
    const signal = allFieldsInvalidPredicate(model, { channels: POSITION_SCALE_CHANNELS });
    if (signal) {
      return { defined: { signal } };
    }
  }
  return {};
}
function allFieldsInvalidPredicate(model, { invalid = false, channels }) {
  const filterIndex = channels.reduce((aggregator, channel) => {
    var _a;
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const scaleType2 = scaleComponent.get("type");
      const field2 = model.vgField(channel, { expr: "datum", binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? "mid" : void 0 });
      if (field2 && hasContinuousDomain(scaleType2)) {
        aggregator[field2] = true;
      }
    }
    return aggregator;
  }, {});
  const fields = keys$1(filterIndex);
  if (fields.length > 0) {
    const op = invalid ? "||" : "&&";
    return fields.map((field2) => fieldInvalidPredicate(field2, invalid)).join(` ${op} `);
  }
  return void 0;
}
function valueIfDefined(prop, value2) {
  if (value2 !== void 0) {
    return { [prop]: signalOrValueRef(value2) };
  }
  return void 0;
}
const VORONOI = "voronoi";
const nearest = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && selCmpt.nearest;
  },
  parse: (model, selCmpt) => {
    if (selCmpt.events) {
      for (const s of selCmpt.events) {
        s.markname = model.getName(VORONOI);
      }
    }
  },
  marks: (model, selCmpt, marks) => {
    const { x: x2, y: y2 } = selCmpt.project.hasChannel;
    const markType2 = model.mark;
    if (isPathMark(markType2)) {
      warn(nearestNotSupportForContinuous(markType2));
      return marks;
    }
    const cellDef = {
      name: model.getName(VORONOI),
      type: "path",
      interactive: true,
      from: { data: model.getName("marks") },
      encode: {
        update: Object.assign({ fill: { value: "transparent" }, strokeWidth: { value: 0.35 }, stroke: { value: "transparent" }, isVoronoi: { value: true } }, tooltip(model, { reactiveGeom: true }))
      },
      transform: [
        {
          type: "voronoi",
          x: { expr: x2 || !y2 ? "datum.datum.x || 0" : "0" },
          y: { expr: y2 || !x2 ? "datum.datum.y || 0" : "0" },
          size: [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")]
        }
      ]
    };
    let index2 = 0;
    let exists = false;
    marks.forEach((mark2, i) => {
      var _a;
      const name = (_a = mark2.name) !== null && _a !== void 0 ? _a : "";
      if (name === model.component.mark[0].name) {
        index2 = i;
      } else if (name.indexOf(VORONOI) >= 0) {
        exists = true;
      }
    });
    if (!exists) {
      marks.splice(index2 + 1, 0, cellDef);
    }
    return marks;
  }
};
const inputBindings = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind !== "scales" && !isLegendBinding(selCmpt.bind);
  },
  parse: (model, selCmpt, selDef) => disableDirectManipulation(selCmpt, selDef),
  topLevelSignals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const proj = selCmpt.project;
    const bind2 = selCmpt.bind;
    const init2 = selCmpt.init && selCmpt.init[0];
    const datum2 = nearest.defined(selCmpt) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
    proj.items.forEach((p, i) => {
      var _a, _b;
      const sgname = varName(`${name}_${p.field}`);
      const hasSignal2 = signals.filter((s) => s.name === sgname);
      if (!hasSignal2.length) {
        signals.unshift(Object.assign(Object.assign({ name: sgname }, init2 ? { init: assembleInit(init2[i]) } : { value: null }), { on: selCmpt.events ? [
          {
            events: selCmpt.events,
            update: `datum && item().mark.marktype !== 'group' ? ${datum2}[${$(p.field)}] : null`
          }
        ] : [], bind: (_b = (_a = bind2[p.field]) !== null && _a !== void 0 ? _a : bind2[p.channel]) !== null && _b !== void 0 ? _b : bind2 }));
      }
    });
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const proj = selCmpt.project;
    const signal = signals.filter((s) => s.name === name + TUPLE)[0];
    const fields = name + TUPLE_FIELDS;
    const values2 = proj.items.map((p) => varName(`${name}_${p.field}`));
    const valid2 = values2.map((v) => `${v} !== null`).join(" && ");
    if (values2.length) {
      signal.update = `${valid2} ? {fields: ${fields}, values: [${values2.join(", ")}]} : null`;
    }
    delete signal.value;
    delete signal.on;
    return signals;
  }
};
const TOGGLE = "_toggle";
const toggle = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && !!selCmpt.toggle;
  },
  signals: (model, selCmpt, signals) => {
    return signals.concat({
      name: selCmpt.name + TOGGLE,
      value: false,
      on: [{ events: selCmpt.events, update: selCmpt.toggle }]
    });
  },
  modifyExpr: (model, selCmpt) => {
    const tpl = selCmpt.name + TUPLE;
    const signal = selCmpt.name + TOGGLE;
    return `${signal} ? null : ${tpl}, ` + (selCmpt.resolve === "global" ? `${signal} ? null : true, ` : `${signal} ? null : {unit: ${unitName(model)}}, `) + `${signal} ? ${tpl} : null`;
  }
};
const clear = {
  defined: (selCmpt) => {
    return selCmpt.clear !== void 0 && selCmpt.clear !== false;
  },
  parse: (model, selCmpt) => {
    if (selCmpt.clear) {
      selCmpt.clear = isString(selCmpt.clear) ? eventSelector(selCmpt.clear, "view") : selCmpt.clear;
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    if (inputBindings.defined(selCmpt)) {
      for (const proj of selCmpt.project.items) {
        const idx = signals.findIndex((n) => n.name === varName(`${selCmpt.name}_${proj.field}`));
        if (idx !== -1) {
          signals[idx].on.push({ events: selCmpt.clear, update: "null" });
        }
      }
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    function addClear(idx, update2) {
      if (idx !== -1 && signals[idx].on) {
        signals[idx].on.push({ events: selCmpt.clear, update: update2 });
      }
    }
    if (selCmpt.type === "interval") {
      for (const proj of selCmpt.project.items) {
        const vIdx = signals.findIndex((n) => n.name === proj.signals.visual);
        addClear(vIdx, "[0, 0]");
        if (vIdx === -1) {
          const dIdx = signals.findIndex((n) => n.name === proj.signals.data);
          addClear(dIdx, "null");
        }
      }
    } else {
      let tIdx = signals.findIndex((n) => n.name === selCmpt.name + TUPLE);
      addClear(tIdx, "null");
      if (toggle.defined(selCmpt)) {
        tIdx = signals.findIndex((n) => n.name === selCmpt.name + TOGGLE);
        addClear(tIdx, "false");
      }
    }
    return signals;
  }
};
const legendBindings = {
  defined: (selCmpt) => {
    const spec = selCmpt.resolve === "global" && selCmpt.bind && isLegendBinding(selCmpt.bind);
    const projLen = selCmpt.project.items.length === 1 && selCmpt.project.items[0].field !== SELECTION_ID;
    if (spec && !projLen) {
      warn(LEGEND_BINDINGS_MUST_HAVE_PROJECTION);
    }
    return spec && projLen;
  },
  parse: (model, selCmpt, selDef) => {
    var _a;
    const selDef_ = duplicate(selDef);
    selDef_.select = isString(selDef_.select) ? { type: selDef_.select, toggle: selCmpt.toggle } : Object.assign(Object.assign({}, selDef_.select), { toggle: selCmpt.toggle });
    disableDirectManipulation(selCmpt, selDef_);
    if (isObject$1(selDef.select) && (selDef.select.on || selDef.select.clear)) {
      const legendFilter = 'event.item && indexof(event.item.mark.role, "legend") < 0';
      for (const evt2 of selCmpt.events) {
        evt2.filter = array$5((_a = evt2.filter) !== null && _a !== void 0 ? _a : []);
        if (!evt2.filter.includes(legendFilter)) {
          evt2.filter.push(legendFilter);
        }
      }
    }
    const evt = isLegendStreamBinding(selCmpt.bind) ? selCmpt.bind.legend : "click";
    const stream2 = isString(evt) ? eventSelector(evt, "view") : array$5(evt);
    selCmpt.bind = { legend: { merge: stream2 } };
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const selName = selCmpt.name;
    const stream2 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
    const markName = (name) => (s) => {
      const ds = duplicate(s);
      ds.markname = name;
      return ds;
    };
    for (const proj of selCmpt.project.items) {
      if (!proj.hasLegend)
        continue;
      const prefix2 = `${varName(proj.field)}_legend`;
      const sgName = `${selName}_${prefix2}`;
      const hasSignal2 = signals.filter((s) => s.name === sgName);
      if (hasSignal2.length === 0) {
        const events2 = stream2.merge.map(markName(`${prefix2}_symbols`)).concat(stream2.merge.map(markName(`${prefix2}_labels`))).concat(stream2.merge.map(markName(`${prefix2}_entries`)));
        signals.unshift(Object.assign(Object.assign({ name: sgName }, !selCmpt.init ? { value: null } : {}), { on: [
          // Legend entries do not store values, so we need to walk the scenegraph to the symbol datum.
          { events: events2, update: "datum.value || item().items[0].items[0].datum.value", force: true },
          { events: stream2.merge, update: `!event.item || !datum ? null : ${sgName}`, force: true }
        ] }));
      }
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const proj = selCmpt.project;
    const tuple = signals.find((s) => s.name === name + TUPLE);
    const fields = name + TUPLE_FIELDS;
    const values2 = proj.items.filter((p) => p.hasLegend).map((p) => varName(`${name}_${varName(p.field)}_legend`));
    const valid2 = values2.map((v) => `${v} !== null`).join(" && ");
    const update2 = `${valid2} ? {fields: ${fields}, values: [${values2.join(", ")}]} : null`;
    if (selCmpt.events && values2.length > 0) {
      tuple.on.push({
        events: values2.map((signal) => ({ signal })),
        update: update2
      });
    } else if (values2.length > 0) {
      tuple.update = update2;
      delete tuple.value;
      delete tuple.on;
    }
    const toggle2 = signals.find((s) => s.name === name + TOGGLE);
    const events2 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
    if (toggle2) {
      if (!selCmpt.events)
        toggle2.on[0].events = events2;
      else
        toggle2.on.push(Object.assign(Object.assign({}, toggle2.on[0]), { events: events2 }));
    }
    return signals;
  }
};
function parseInteractiveLegend(model, channel, legendCmpt) {
  var _a, _b, _c2, _d2;
  const field2 = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.field;
  for (const selCmpt of vals((_b = model.component.selection) !== null && _b !== void 0 ? _b : {})) {
    const proj = (_c2 = selCmpt.project.hasField[field2]) !== null && _c2 !== void 0 ? _c2 : selCmpt.project.hasChannel[channel];
    if (proj && legendBindings.defined(selCmpt)) {
      const legendSelections = (_d2 = legendCmpt.get("selections")) !== null && _d2 !== void 0 ? _d2 : [];
      legendSelections.push(selCmpt.name);
      legendCmpt.set("selections", legendSelections, false);
      proj.hasLegend = true;
    }
  }
}
const ANCHOR$1 = "_translate_anchor";
const DELTA$1 = "_translate_delta";
const translate = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.translate;
  },
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const hasScales = scaleBindings.defined(selCmpt);
    const anchor = name + ANCHOR$1;
    const { x: x2, y: y2 } = selCmpt.project.hasChannel;
    let events2 = eventSelector(selCmpt.translate, "scope");
    if (!hasScales) {
      events2 = events2.map((e3) => (e3.between[0].markname = name + BRUSH, e3));
    }
    signals.push({
      name: anchor,
      value: {},
      on: [
        {
          events: events2.map((e3) => e3.between[0]),
          update: "{x: x(unit), y: y(unit)" + (x2 !== void 0 ? `, extent_x: ${hasScales ? domain(model, X) : `slice(${x2.signals.visual})`}` : "") + (y2 !== void 0 ? `, extent_y: ${hasScales ? domain(model, Y) : `slice(${y2.signals.visual})`}` : "") + "}"
        }
      ]
    }, {
      name: name + DELTA$1,
      value: {},
      on: [
        {
          events: events2,
          update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`
        }
      ]
    });
    if (x2 !== void 0) {
      onDelta$1(model, selCmpt, x2, "width", signals);
    }
    if (y2 !== void 0) {
      onDelta$1(model, selCmpt, y2, "height", signals);
    }
    return signals;
  }
};
function onDelta$1(model, selCmpt, proj, size, signals) {
  var _a, _b;
  const name = selCmpt.name;
  const anchor = name + ANCHOR$1;
  const delta = name + DELTA$1;
  const channel = proj.channel;
  const hasScales = scaleBindings.defined(selCmpt);
  const signal = signals.filter((s) => s.name === proj.signals[hasScales ? "data" : "visual"])[0];
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt.get("type");
  const reversed = scaleCmpt.get("reverse");
  const sign2 = !hasScales ? "" : channel === X ? reversed ? "" : "-" : reversed ? "-" : "";
  const extent2 = `${anchor}.extent_${channel}`;
  const offset2 = `${sign2}${delta}.${channel} / ${hasScales ? `${sizeSg}` : `span(${extent2})`}`;
  const panFn = !hasScales ? "panLinear" : scaleType2 === "log" ? "panLog" : scaleType2 === "symlog" ? "panSymlog" : scaleType2 === "pow" ? "panPow" : "panLinear";
  const arg = !hasScales ? "" : scaleType2 === "pow" ? `, ${(_a = scaleCmpt.get("exponent")) !== null && _a !== void 0 ? _a : 1}` : scaleType2 === "symlog" ? `, ${(_b = scaleCmpt.get("constant")) !== null && _b !== void 0 ? _b : 1}` : "";
  const update2 = `${panFn}(${extent2}, ${offset2}${arg})`;
  signal.on.push({
    events: { signal: delta },
    update: hasScales ? update2 : `clampRange(${update2}, 0, ${sizeSg})`
  });
}
const ANCHOR = "_zoom_anchor";
const DELTA = "_zoom_delta";
const zoom = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.zoom;
  },
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const hasScales = scaleBindings.defined(selCmpt);
    const delta = name + DELTA;
    const { x: x2, y: y2 } = selCmpt.project.hasChannel;
    const sx = $(model.scaleName(X));
    const sy = $(model.scaleName(Y));
    let events2 = eventSelector(selCmpt.zoom, "scope");
    if (!hasScales) {
      events2 = events2.map((e3) => (e3.markname = name + BRUSH, e3));
    }
    signals.push({
      name: name + ANCHOR,
      on: [
        {
          events: events2,
          update: !hasScales ? `{x: x(unit), y: y(unit)}` : "{" + [sx ? `x: invert(${sx}, x(unit))` : "", sy ? `y: invert(${sy}, y(unit))` : ""].filter((expr2) => !!expr2).join(", ") + "}"
        }
      ]
    }, {
      name: delta,
      on: [
        {
          events: events2,
          force: true,
          update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
        }
      ]
    });
    if (x2 !== void 0) {
      onDelta(model, selCmpt, x2, "width", signals);
    }
    if (y2 !== void 0) {
      onDelta(model, selCmpt, y2, "height", signals);
    }
    return signals;
  }
};
function onDelta(model, selCmpt, proj, size, signals) {
  var _a, _b;
  const name = selCmpt.name;
  const channel = proj.channel;
  const hasScales = scaleBindings.defined(selCmpt);
  const signal = signals.filter((s) => s.name === proj.signals[hasScales ? "data" : "visual"])[0];
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt.get("type");
  const base2 = hasScales ? domain(model, channel) : signal.name;
  const delta = name + DELTA;
  const anchor = `${name}${ANCHOR}.${channel}`;
  const zoomFn = !hasScales ? "zoomLinear" : scaleType2 === "log" ? "zoomLog" : scaleType2 === "symlog" ? "zoomSymlog" : scaleType2 === "pow" ? "zoomPow" : "zoomLinear";
  const arg = !hasScales ? "" : scaleType2 === "pow" ? `, ${(_a = scaleCmpt.get("exponent")) !== null && _a !== void 0 ? _a : 1}` : scaleType2 === "symlog" ? `, ${(_b = scaleCmpt.get("constant")) !== null && _b !== void 0 ? _b : 1}` : "";
  const update2 = `${zoomFn}(${base2}, ${anchor}, ${delta}${arg})`;
  signal.on.push({
    events: { signal: delta },
    update: hasScales ? update2 : `clampRange(${update2}, 0, ${sizeSg})`
  });
}
const STORE = "_store";
const TUPLE = "_tuple";
const MODIFY = "_modify";
const VL_SELECTION_RESOLVE = "vlSelectionResolve";
const selectionCompilers = [
  point$1,
  interval,
  project,
  toggle,
  // Bindings may disable direct manipulation.
  inputBindings,
  scaleBindings,
  legendBindings,
  clear,
  translate,
  zoom,
  nearest
];
function getFacetModel(model) {
  let parent = model.parent;
  while (parent) {
    if (isFacetModel(parent))
      break;
    parent = parent.parent;
  }
  return parent;
}
function unitName(model, { escape: escape2 } = { escape: true }) {
  let name = escape2 ? $(model.name) : model.name;
  const facetModel = getFacetModel(model);
  if (facetModel) {
    const { facet } = facetModel;
    for (const channel of FACET_CHANNELS) {
      if (facet[channel]) {
        name += ` + '__facet_${channel}_' + (facet[${$(facetModel.vgField(channel))}])`;
      }
    }
  }
  return name;
}
function requiresSelectionId(model) {
  var _a;
  return vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce((identifier2, selCmpt) => {
    return identifier2 || selCmpt.project.hasSelectionId;
  }, false);
}
function disableDirectManipulation(selCmpt, selDef) {
  if (isString(selDef.select) || !selDef.select.on)
    delete selCmpt.events;
  if (isString(selDef.select) || !selDef.select.clear)
    delete selCmpt.clear;
  if (isString(selDef.select) || !selDef.select.toggle)
    delete selCmpt.toggle;
}
function getName(node2) {
  const name = [];
  if (node2.type === "Identifier") {
    return [node2.name];
  }
  if (node2.type === "Literal") {
    return [node2.value];
  }
  if (node2.type === "MemberExpression") {
    name.push(...getName(node2.object));
    name.push(...getName(node2.property));
  }
  return name;
}
function startsWithDatum(node2) {
  if (node2.object.type === "MemberExpression") {
    return startsWithDatum(node2.object);
  }
  return node2.object.name === "datum";
}
function getDependentFields(expression2) {
  const ast = parser$1(expression2);
  const dependents = /* @__PURE__ */ new Set();
  ast.visit((node2) => {
    if (node2.type === "MemberExpression" && startsWithDatum(node2)) {
      dependents.add(getName(node2).slice(1).join("."));
    }
  });
  return dependents;
}
class FilterNode extends DataFlowNode {
  constructor(parent, model, filter2) {
    super(parent);
    this.model = model;
    this.filter = filter2;
    this.expr = expression(this.model, this.filter, this);
    this._dependentFields = getDependentFields(this.expr);
  }
  clone() {
    return new FilterNode(null, this.model, duplicate(this.filter));
  }
  dependentFields() {
    return this._dependentFields;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  assemble() {
    return {
      type: "filter",
      expr: this.expr
    };
  }
  hash() {
    return `Filter ${this.expr}`;
  }
}
function parseUnitSelection(model, selDefs) {
  var _a;
  const selCmpts = {};
  const selectionConfig = model.config.selection;
  if (!selDefs || !selDefs.length)
    return selCmpts;
  for (const def2 of selDefs) {
    const name = varName(def2.name);
    const selDef = def2.select;
    const type2 = isString(selDef) ? selDef : selDef.type;
    const defaults2 = isObject$1(selDef) ? duplicate(selDef) : { type: type2 };
    const cfg = selectionConfig[type2];
    for (const key2 in cfg) {
      if (key2 === "fields" || key2 === "encodings") {
        continue;
      }
      if (key2 === "mark") {
        defaults2[key2] = Object.assign(Object.assign({}, cfg[key2]), defaults2[key2]);
      }
      if (defaults2[key2] === void 0 || defaults2[key2] === true) {
        defaults2[key2] = (_a = cfg[key2]) !== null && _a !== void 0 ? _a : defaults2[key2];
      }
    }
    const selCmpt = selCmpts[name] = Object.assign(Object.assign({}, defaults2), {
      name,
      type: type2,
      init: def2.value,
      bind: def2.bind,
      events: isString(defaults2.on) ? eventSelector(defaults2.on, "scope") : array$5(duplicate(defaults2.on))
    });
    for (const c2 of selectionCompilers) {
      if (c2.defined(selCmpt) && c2.parse) {
        c2.parse(model, selCmpt, def2);
      }
    }
  }
  return selCmpts;
}
function parseSelectionPredicate(model, pred, dfnode, datum2 = "datum") {
  const name = isString(pred) ? pred : pred.param;
  const vname = varName(name);
  const store = $(vname + STORE);
  let selCmpt;
  try {
    selCmpt = model.getSelectionComponent(vname, name);
  } catch (e3) {
    return `!!${vname}`;
  }
  if (selCmpt.project.timeUnit) {
    const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;
    const tunode = selCmpt.project.timeUnit.clone();
    if (child.parent) {
      tunode.insertAsParentOf(child);
    } else {
      child.parent = tunode;
    }
  }
  const fn = selCmpt.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(";
  const resolve2 = selCmpt.resolve === "global" ? ")" : `, ${$(selCmpt.resolve)})`;
  const test2 = `${fn}${store}, ${datum2}${resolve2}`;
  const length2 = `length(data(${store}))`;
  return pred.empty === false ? `${length2} && ${test2}` : `!${length2} || ${test2}`;
}
function parseSelectionExtent(model, name, extent2) {
  const vname = varName(name);
  const encoding = extent2["encoding"];
  let field2 = extent2["field"];
  let selCmpt;
  try {
    selCmpt = model.getSelectionComponent(vname, name);
  } catch (e3) {
    return vname;
  }
  if (!encoding && !field2) {
    field2 = selCmpt.project.items[0].field;
    if (selCmpt.project.items.length > 1) {
      warn(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${$(field2)}.`);
    }
  } else if (encoding && !field2) {
    const encodings = selCmpt.project.items.filter((p) => p.channel === encoding);
    if (!encodings.length || encodings.length > 1) {
      field2 = selCmpt.project.items[0].field;
      warn((!encodings.length ? "No " : "Multiple ") + `matching ${$(encoding)} encoding found for selection ${$(extent2.param)}. Using "field": ${$(field2)}.`);
    } else {
      field2 = encodings[0].field;
    }
  }
  return `${selCmpt.name}[${$(replacePathInField(field2))}]`;
}
function materializeSelections(model, main2) {
  var _a;
  for (const [selection, selCmpt] of entries$1((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const lookupName = model.getName(`lookup_${selection}`);
    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main2, model, { param: selection }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
  }
}
function expression(model, filterOp, node2) {
  return logicalExpr(filterOp, (predicate) => {
    if (isString(predicate)) {
      return predicate;
    } else if (isSelectionPredicate(predicate)) {
      return parseSelectionPredicate(model, predicate, node2);
    } else {
      return fieldFilterExpression(predicate);
    }
  });
}
var __rest$b = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function assembleTitle(title2, config) {
  if (!title2) {
    return void 0;
  }
  if (isArray$1(title2) && !isText(title2)) {
    return title2.map((fieldDef) => defaultTitle(fieldDef, config)).join(", ");
  }
  return title2;
}
function setAxisEncode(axis, part, vgProp, vgRef) {
  var _a, _b, _c2;
  var _d2, _e;
  (_a = axis.encode) !== null && _a !== void 0 ? _a : axis.encode = {};
  (_b = (_d2 = axis.encode)[part]) !== null && _b !== void 0 ? _b : _d2[part] = {};
  (_c2 = (_e = axis.encode[part]).update) !== null && _c2 !== void 0 ? _c2 : _e.update = {};
  axis.encode[part].update[vgProp] = vgRef;
}
function assembleAxis(axisCmpt, kind, config, opt = { header: false }) {
  var _a, _b;
  const _c2 = axisCmpt.combine(), { disable, orient: orient2, scale: scale2, labelExpr, title: title2, zindex: zindex2 } = _c2, axis = __rest$b(_c2, ["disable", "orient", "scale", "labelExpr", "title", "zindex"]);
  if (disable) {
    return void 0;
  }
  for (const prop in axis) {
    const propType = AXIS_PROPERTY_TYPE[prop];
    const propValue = axis[prop];
    if (propType && propType !== kind && propType !== "both") {
      delete axis[prop];
    } else if (isConditionalAxisValue(propValue)) {
      const { condition } = propValue, valueOrSignalRef = __rest$b(propValue, ["condition"]);
      const conditions = array$5(condition);
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        const vgRef = [
          ...conditions.map((c2) => {
            const { test: test2 } = c2, valueOrSignalCRef = __rest$b(c2, ["test"]);
            return Object.assign({ test: expression(null, test2) }, valueOrSignalCRef);
          }),
          valueOrSignalRef
        ];
        setAxisEncode(axis, part, vgProp, vgRef);
        delete axis[prop];
      } else if (propIndex === null) {
        const signalRef = {
          signal: conditions.map((c2) => {
            const { test: test2 } = c2, valueOrSignalCRef = __rest$b(c2, ["test"]);
            return `${expression(null, test2)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;
          }).join("") + exprFromValueRefOrSignalRef(valueOrSignalRef)
        };
        axis[prop] = signalRef;
      }
    } else if (isSignalRef(propValue)) {
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        setAxisEncode(axis, part, vgProp, propValue);
        delete axis[prop];
      }
    }
    if (contains(["labelAlign", "labelBaseline"], prop) && axis[prop] === null) {
      delete axis[prop];
    }
  }
  if (kind === "grid") {
    if (!axis.grid) {
      return void 0;
    }
    if (axis.encode) {
      const { grid } = axis.encode;
      axis.encode = Object.assign({}, grid ? { grid } : {});
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    return Object.assign(Object.assign({
      scale: scale2,
      orient: orient2
    }, axis), {
      domain: false,
      labels: false,
      aria: false,
      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`
      // would not affect gridAxis
      maxExtent: 0,
      minExtent: 0,
      ticks: false,
      zindex: getFirstDefined(zindex2, 0)
      // put grid behind marks by default
    });
  } else {
    if (!opt.header && axisCmpt.mainExtracted) {
      return void 0;
    }
    if (labelExpr !== void 0) {
      let expr2 = labelExpr;
      if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {
        expr2 = replaceAll(labelExpr, "datum.label", axis.encode.labels.update.text.signal);
      }
      setAxisEncode(axis, "labels", "text", { signal: expr2 });
    }
    if (axis.labelAlign === null) {
      delete axis.labelAlign;
    }
    if (axis.encode) {
      for (const part of AXIS_PARTS) {
        if (!axisCmpt.hasAxisPart(part)) {
          delete axis.encode[part];
        }
      }
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    const titleString = assembleTitle(title2, config);
    return Object.assign(Object.assign(Object.assign(Object.assign({
      scale: scale2,
      orient: orient2,
      grid: false
    }, titleString ? { title: titleString } : {}), axis), config.aria === false ? { aria: false } : {}), {
      zindex: getFirstDefined(zindex2, 0)
      // put axis line above marks by default
    });
  }
}
function assembleAxisSignals(model) {
  const { axes } = model.component;
  const signals = [];
  for (const channel of POSITION_SCALE_CHANNELS) {
    if (axes[channel]) {
      for (const axis of axes[channel]) {
        if (!axis.get("disable") && !axis.get("gridScale")) {
          const sizeType = channel === "x" ? "height" : "width";
          const update2 = model.getSizeSignalRef(sizeType).signal;
          if (sizeType !== update2) {
            signals.push({
              name: sizeType,
              update: update2
            });
          }
        }
      }
    }
  }
  return signals;
}
function assembleAxes(axisComponents, config) {
  const { x: x2 = [], y: y2 = [] } = axisComponents;
  return [
    ...x2.map((a2) => assembleAxis(a2, "grid", config)),
    ...y2.map((a2) => assembleAxis(a2, "grid", config)),
    ...x2.map((a2) => assembleAxis(a2, "main", config)),
    ...y2.map((a2) => assembleAxis(a2, "main", config))
  ].filter((a2) => a2);
}
function getAxisConfigFromConfigTypes(configTypes, config, channel, orient2) {
  return Object.assign.apply(null, [
    {},
    ...configTypes.map((configType) => {
      if (configType === "axisOrient") {
        const orient1 = channel === "x" ? "bottom" : "left";
        const orientConfig1 = config[channel === "x" ? "axisBottom" : "axisLeft"] || {};
        const orientConfig2 = config[channel === "x" ? "axisTop" : "axisRight"] || {};
        const props = /* @__PURE__ */ new Set([...keys$1(orientConfig1), ...keys$1(orientConfig2)]);
        const conditionalOrientAxisConfig = {};
        for (const prop of props.values()) {
          conditionalOrientAxisConfig[prop] = {
            // orient is surely signal in this case
            signal: `${orient2["signal"]} === "${orient1}" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`
          };
        }
        return conditionalOrientAxisConfig;
      }
      return config[configType];
    })
  ]);
}
function getAxisConfigs(channel, scaleType2, orient2, config) {
  const typeBasedConfigTypes = scaleType2 === "band" ? ["axisDiscrete", "axisBand"] : scaleType2 === "point" ? ["axisDiscrete", "axisPoint"] : isQuantitative(scaleType2) ? ["axisQuantitative"] : scaleType2 === "time" || scaleType2 === "utc" ? ["axisTemporal"] : [];
  const axisChannel = channel === "x" ? "axisX" : "axisY";
  const axisOrient = isSignalRef(orient2) ? "axisOrient" : `axis${titleCase(orient2)}`;
  const vlOnlyConfigTypes = [
    // technically Vega does have axisBand, but if we make another separation here,
    // it will further introduce complexity in the code
    ...typeBasedConfigTypes,
    ...typeBasedConfigTypes.map((c2) => axisChannel + c2.substr(4))
  ];
  const vgConfigTypes = ["axis", axisOrient, axisChannel];
  return {
    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient2),
    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient2),
    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)
  };
}
function getAxisConfigStyle(axisConfigTypes, config) {
  var _a;
  const toMerge = [{}];
  for (const configType of axisConfigTypes) {
    let style2 = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;
    if (style2) {
      style2 = array$5(style2);
      for (const s of style2) {
        toMerge.push(config.style[s]);
      }
    }
  }
  return Object.assign.apply(null, toMerge);
}
function getAxisConfig(property2, styleConfigIndex, style2, axisConfigs = {}) {
  var _a;
  const styleConfig = getStyleConfig(property2, style2, styleConfigIndex);
  if (styleConfig !== void 0) {
    return {
      configFrom: "style",
      configValue: styleConfig
    };
  }
  for (const configFrom of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"]) {
    if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property2]) !== void 0) {
      return { configFrom, configValue: axisConfigs[configFrom][property2] };
    }
  }
  return {};
}
const axisRules = {
  scale: ({ model, channel }) => model.scaleName(channel),
  format: ({ fieldOrDatumDef, config, axis }) => {
    const { format: format2, formatType } = axis;
    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format2, formatType, config, true);
  },
  formatType: ({ axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
    const { formatType } = axis;
    return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
  },
  grid: ({ fieldOrDatumDef, axis, scaleType: scaleType2 }) => {
    var _a;
    return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType2, fieldOrDatumDef);
  },
  gridScale: ({ model, channel }) => gridScale(model, channel),
  labelAlign: ({ axis, labelAngle, orient: orient2, channel }) => axis.labelAlign || defaultLabelAlign(labelAngle, orient2, channel),
  labelAngle: ({ labelAngle }) => labelAngle,
  labelBaseline: ({ axis, labelAngle, orient: orient2, channel }) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient2, channel),
  labelFlush: ({ axis, fieldOrDatumDef, channel }) => {
    var _a;
    return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel);
  },
  labelOverlap: ({ axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
    var _a;
    return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap$1(fieldOrDatumDef.type, scaleType2, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0);
  },
  // we already calculate orient in parse
  orient: ({ orient: orient2 }) => orient2,
  tickCount: ({ channel, model, axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
    var _a;
    const sizeType = channel === "x" ? "width" : channel === "y" ? "height" : void 0;
    const size = sizeType ? model.getSizeSignalRef(sizeType) : void 0;
    return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size, values: axis.values });
  },
  title: ({ axis, model, channel }) => {
    if (axis.title !== void 0) {
      return axis.title;
    }
    const fieldDefTitle = getFieldDefTitle(model, channel);
    if (fieldDefTitle !== void 0) {
      return fieldDefTitle;
    }
    const fieldDef = model.typedFieldDef(channel);
    const channel2 = channel === "x" ? "x2" : "y2";
    const fieldDef2 = model.fieldDef(channel2);
    return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);
  },
  values: ({ axis, fieldOrDatumDef }) => values$2(axis, fieldOrDatumDef),
  zindex: ({ axis, fieldOrDatumDef, mark: mark2 }) => {
    var _a;
    return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark2, fieldOrDatumDef);
  }
};
function defaultGrid(scaleType2, fieldDef) {
  return !hasDiscreteDomain(scaleType2) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) && !isBinned(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);
}
function gridScale(model, channel) {
  const gridChannel = channel === "x" ? "y" : "x";
  if (model.getScaleComponent(gridChannel)) {
    return model.scaleName(gridChannel);
  }
  return void 0;
}
function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {
  const labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle;
  if (labelAngle !== void 0) {
    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);
  } else {
    const { configValue: angle2 } = getAxisConfig("labelAngle", styleConfig, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs);
    if (angle2 !== void 0) {
      return normalizeAngle(angle2);
    } else {
      if (channel === X && contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) && !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {
        return 270;
      }
      return void 0;
    }
  }
}
function normalizeAngleExpr(angle2) {
  return `(((${angle2.signal} % 360) + 360) % 360)`;
}
function defaultLabelBaseline(angle2, orient2, channel, alwaysIncludeMiddle) {
  if (angle2 !== void 0) {
    if (channel === "x") {
      if (isSignalRef(angle2)) {
        const a2 = normalizeAngleExpr(angle2);
        const orientIsTop = isSignalRef(orient2) ? `(${orient2.signal} === "top")` : orient2 === "top";
        return {
          signal: `(45 < ${a2} && ${a2} < 135) || (225 < ${a2} && ${a2} < 315) ? "middle" :(${a2} <= 45 || 315 <= ${a2}) === ${orientIsTop} ? "bottom" : "top"`
        };
      }
      if (45 < angle2 && angle2 < 135 || 225 < angle2 && angle2 < 315) {
        return "middle";
      }
      if (isSignalRef(orient2)) {
        const op = angle2 <= 45 || 315 <= angle2 ? "===" : "!==";
        return { signal: `${orient2.signal} ${op} "top" ? "bottom" : "top"` };
      }
      return (angle2 <= 45 || 315 <= angle2) === (orient2 === "top") ? "bottom" : "top";
    } else {
      if (isSignalRef(angle2)) {
        const a2 = normalizeAngleExpr(angle2);
        const orientIsLeft = isSignalRef(orient2) ? `(${orient2.signal} === "left")` : orient2 === "left";
        const middle = alwaysIncludeMiddle ? '"middle"' : "null";
        return {
          signal: `${a2} <= 45 || 315 <= ${a2} || (135 <= ${a2} && ${a2} <= 225) ? ${middle} : (45 <= ${a2} && ${a2} <= 135) === ${orientIsLeft} ? "top" : "bottom"`
        };
      }
      if (angle2 <= 45 || 315 <= angle2 || 135 <= angle2 && angle2 <= 225) {
        return alwaysIncludeMiddle ? "middle" : null;
      }
      if (isSignalRef(orient2)) {
        const op = 45 <= angle2 && angle2 <= 135 ? "===" : "!==";
        return { signal: `${orient2.signal} ${op} "left" ? "top" : "bottom"` };
      }
      return (45 <= angle2 && angle2 <= 135) === (orient2 === "left") ? "top" : "bottom";
    }
  }
  return void 0;
}
function defaultLabelAlign(angle2, orient2, channel) {
  if (angle2 === void 0) {
    return void 0;
  }
  const isX2 = channel === "x";
  const startAngle = isX2 ? 0 : 90;
  const mainOrient = isX2 ? "bottom" : "left";
  if (isSignalRef(angle2)) {
    const a2 = normalizeAngleExpr(angle2);
    const orientIsMain = isSignalRef(orient2) ? `(${orient2.signal} === "${mainOrient}")` : orient2 === mainOrient;
    return {
      signal: `(${startAngle ? `(${a2} + 90)` : a2} % 180 === 0) ? ${isX2 ? null : '"center"'} :(${startAngle} < ${a2} && ${a2} < ${180 + startAngle}) === ${orientIsMain} ? "left" : "right"`
    };
  }
  if ((angle2 + startAngle) % 180 === 0) {
    return isX2 ? null : "center";
  }
  if (isSignalRef(orient2)) {
    const op = startAngle < angle2 && angle2 < 180 + startAngle ? "===" : "!==";
    const orientIsMain = `${orient2.signal} ${op} "${mainOrient}"`;
    return {
      signal: `${orientIsMain} ? "left" : "right"`
    };
  }
  if ((startAngle < angle2 && angle2 < 180 + startAngle) === (orient2 === mainOrient)) {
    return "left";
  }
  return "right";
}
function defaultLabelFlush(type2, channel) {
  if (channel === "x" && contains(["quantitative", "temporal"], type2)) {
    return true;
  }
  return void 0;
}
function defaultLabelOverlap$1(type2, scaleType2, hasTimeUnit, sort2) {
  if (hasTimeUnit && !isObject$1(sort2) || type2 !== "nominal" && type2 !== "ordinal") {
    if (scaleType2 === "log" || scaleType2 === "symlog") {
      return "greedy";
    }
    return true;
  }
  return void 0;
}
function defaultOrient(channel) {
  return channel === "x" ? "bottom" : "left";
}
function defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size, values: vals2 }) {
  var _a;
  if (!vals2 && !hasDiscreteDomain(scaleType2) && scaleType2 !== "log") {
    if (isFieldDef(fieldOrDatumDef)) {
      if (isBinning(fieldOrDatumDef.bin)) {
        return { signal: `ceil(${size.signal}/10)` };
      }
      if (fieldOrDatumDef.timeUnit && contains(["month", "hours", "day", "quarter"], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {
        return void 0;
      }
    }
    return { signal: `ceil(${size.signal}/40)` };
  }
  return void 0;
}
function getFieldDefTitle(model, channel) {
  const channel2 = channel === "x" ? "x2" : "y2";
  const fieldDef = model.fieldDef(channel);
  const fieldDef2 = model.fieldDef(channel2);
  const title1 = fieldDef ? fieldDef.title : void 0;
  const title2 = fieldDef2 ? fieldDef2.title : void 0;
  if (title1 && title2) {
    return mergeTitle(title1, title2);
  } else if (title1) {
    return title1;
  } else if (title2) {
    return title2;
  } else if (title1 !== void 0) {
    return title1;
  } else if (title2 !== void 0) {
    return title2;
  }
  return void 0;
}
function values$2(axis, fieldOrDatumDef) {
  const vals2 = axis.values;
  if (isArray$1(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultZindex(mark2, fieldDef) {
  if (mark2 === "rect" && isDiscrete(fieldDef)) {
    return 1;
  }
  return 0;
}
class CalculateNode extends DataFlowNode {
  constructor(parent, transform2) {
    super(parent);
    this.transform = transform2;
    this._dependentFields = getDependentFields(this.transform.calculate);
  }
  clone() {
    return new CalculateNode(null, duplicate(this.transform));
  }
  static parseAllForSortIndex(parent, model) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (!isScaleFieldDef(fieldDef)) {
        return;
      }
      if (isSortArray(fieldDef.sort)) {
        const { field: field2, timeUnit } = fieldDef;
        const sort2 = fieldDef.sort;
        const calculate = sort2.map((sortValue, i) => {
          return `${fieldFilterExpression({ field: field2, timeUnit, equal: sortValue })} ? ${i} : `;
        }).join("") + sort2.length;
        parent = new CalculateNode(parent, {
          calculate,
          as: sortArrayIndexField(fieldDef, channel, { forAs: true })
        });
      }
    });
    return parent;
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.as]);
  }
  dependentFields() {
    return this._dependentFields;
  }
  assemble() {
    return {
      type: "formula",
      expr: this.transform.calculate,
      as: this.transform.as
    };
  }
  hash() {
    return `Calculate ${hash(this.transform)}`;
  }
}
function sortArrayIndexField(fieldDef, channel, opt) {
  return vgField(fieldDef, Object.assign({ prefix: channel, suffix: "sort_index" }, opt !== null && opt !== void 0 ? opt : {}));
}
function getHeaderChannel(channel, orient2) {
  if (contains(["top", "bottom"], orient2)) {
    return "column";
  } else if (contains(["left", "right"], orient2)) {
    return "row";
  }
  return channel === "row" ? "row" : "column";
}
function getHeaderProperty(prop, header, config, channel) {
  const headerSpecificConfig = channel === "row" ? config.headerRow : channel === "column" ? config.headerColumn : config.headerFacet;
  return getFirstDefined((header || {})[prop], headerSpecificConfig[prop], config.header[prop]);
}
function getHeaderProperties(properties2, header, config, channel) {
  const props = {};
  for (const prop of properties2) {
    const value2 = getHeaderProperty(prop, header || {}, config, channel);
    if (value2 !== void 0) {
      props[prop] = value2;
    }
  }
  return props;
}
const HEADER_CHANNELS = ["row", "column"];
const HEADER_TYPES = ["header", "footer"];
function assembleTitleGroup(model, channel) {
  const title2 = model.component.layoutHeaders[channel].title;
  const config = model.config ? model.config : void 0;
  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : void 0;
  const { titleAnchor, titleAngle: ta, titleOrient } = getHeaderProperties(["titleAnchor", "titleAngle", "titleOrient"], facetFieldDef.header, config, channel);
  const headerChannel = getHeaderChannel(channel, titleOrient);
  const titleAngle = normalizeAngle(ta);
  return {
    name: `${channel}-title`,
    type: "group",
    role: `${headerChannel}-title`,
    title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: title2 }, channel === "row" ? { orient: "left" } : {}), { style: "guide-title" }), defaultHeaderGuideBaseline(titleAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP))
  };
}
function defaultHeaderGuideAlign(headerChannel, angle2, anchor = "middle") {
  switch (anchor) {
    case "start":
      return { align: "left" };
    case "end":
      return { align: "right" };
  }
  const align2 = defaultLabelAlign(angle2, headerChannel === "row" ? "left" : "top", headerChannel === "row" ? "y" : "x");
  return align2 ? { align: align2 } : {};
}
function defaultHeaderGuideBaseline(angle2, channel) {
  const baseline2 = defaultLabelBaseline(angle2, channel === "row" ? "left" : "top", channel === "row" ? "y" : "x", true);
  return baseline2 ? { baseline: baseline2 } : {};
}
function assembleHeaderGroups(model, channel) {
  const layoutHeader = model.component.layoutHeaders[channel];
  const groups = [];
  for (const headerType of HEADER_TYPES) {
    if (layoutHeader[headerType]) {
      for (const headerComponent of layoutHeader[headerType]) {
        const group2 = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);
        if (group2 != null) {
          groups.push(group2);
        }
      }
    }
  }
  return groups;
}
function getSort$1(facetFieldDef, channel) {
  var _a;
  const { sort: sort2 } = facetFieldDef;
  if (isSortField(sort2)) {
    return {
      field: vgField(sort2, { expr: "datum" }),
      order: (_a = sort2.order) !== null && _a !== void 0 ? _a : "ascending"
    };
  } else if (isArray$1(sort2)) {
    return {
      field: sortArrayIndexField(facetFieldDef, channel, { expr: "datum" }),
      order: "ascending"
    };
  } else {
    return {
      field: vgField(facetFieldDef, { expr: "datum" }),
      order: sort2 !== null && sort2 !== void 0 ? sort2 : "ascending"
    };
  }
}
function assembleLabelTitle(facetFieldDef, channel, config) {
  const { format: format2, formatType, labelAngle, labelAnchor, labelOrient, labelExpr } = getHeaderProperties(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], facetFieldDef.header, config, channel);
  const titleTextExpr = formatSignalRef({
    fieldOrDatumDef: facetFieldDef,
    format: format2,
    formatType,
    expr: "parent",
    config
  }).signal;
  const headerChannel = getHeaderChannel(channel, labelOrient);
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: {
    signal: labelExpr ? replaceAll(replaceAll(labelExpr, "datum.label", titleTextExpr), "datum.value", vgField(facetFieldDef, { expr: "parent" })) : titleTextExpr
  } }, channel === "row" ? { orient: "left" } : {}), { style: "guide-label", frame: "group" }), defaultHeaderGuideBaseline(labelAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP));
}
function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {
  if (headerComponent) {
    let title2 = null;
    const { facetFieldDef } = layoutHeader;
    const config = model.config ? model.config : void 0;
    if (facetFieldDef && headerComponent.labels) {
      const { labelOrient } = getHeaderProperties(["labelOrient"], facetFieldDef.header, config, channel);
      if (channel === "row" && !contains(["top", "bottom"], labelOrient) || channel === "column" && !contains(["left", "right"], labelOrient)) {
        title2 = assembleLabelTitle(facetFieldDef, channel, config);
      }
    }
    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);
    const axes = headerComponent.axes;
    const hasAxes = (axes === null || axes === void 0 ? void 0 : axes.length) > 0;
    if (title2 || hasAxes) {
      const sizeChannel = channel === "row" ? "height" : "width";
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName(`${channel}_${headerType}`), type: "group", role: `${channel}-${headerType}` }, layoutHeader.facetFieldDef ? {
        from: { data: model.getName(`${channel}_domain`) },
        sort: getSort$1(facetFieldDef, channel)
      } : {}), hasAxes && isFacetWithoutRowCol ? {
        from: { data: model.getName(`facet_domain_${channel}`) }
      } : {}), title2 ? { title: title2 } : {}), headerComponent.sizeSignal ? {
        encode: {
          update: {
            [sizeChannel]: headerComponent.sizeSignal
          }
        }
      } : {}), hasAxes ? { axes } : {});
    }
  }
  return null;
}
const LAYOUT_TITLE_BAND = {
  column: {
    start: 0,
    end: 1
  },
  row: {
    start: 1,
    end: 0
  }
};
function getLayoutTitleBand(titleAnchor, headerChannel) {
  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];
}
function assembleLayoutTitleBand(headerComponentIndex, config) {
  const titleBand = {};
  for (const channel of FACET_CHANNELS) {
    const headerComponent = headerComponentIndex[channel];
    if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent.facetFieldDef) {
      const { titleAnchor, titleOrient } = getHeaderProperties(["titleAnchor", "titleOrient"], headerComponent.facetFieldDef.header, config, channel);
      const headerChannel = getHeaderChannel(channel, titleOrient);
      const band2 = getLayoutTitleBand(titleAnchor, headerChannel);
      if (band2 !== void 0) {
        titleBand[headerChannel] = band2;
      }
    }
  }
  return isEmpty(titleBand) ? void 0 : titleBand;
}
function assembleHeaderProperties(config, facetFieldDef, channel, properties2, propertiesMap) {
  const props = {};
  for (const prop of properties2) {
    if (!propertiesMap[prop]) {
      continue;
    }
    const value2 = getHeaderProperty(prop, facetFieldDef === null || facetFieldDef === void 0 ? void 0 : facetFieldDef.header, config, channel);
    if (value2 !== void 0) {
      props[propertiesMap[prop]] = value2;
    }
  }
  return props;
}
function assembleLayoutSignals(model) {
  return [
    ...sizeSignals(model, "width"),
    ...sizeSignals(model, "height"),
    ...sizeSignals(model, "childWidth"),
    ...sizeSignals(model, "childHeight")
  ];
}
function sizeSignals(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const size = model.component.layoutSize.get(sizeType);
  if (!size || size === "merged") {
    return [];
  }
  const name = model.getSizeSignalRef(sizeType).signal;
  if (size === "step") {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const type2 = scaleComponent.get("type");
      const range2 = scaleComponent.get("range");
      if (hasDiscreteDomain(type2) && isVgRangeStep(range2)) {
        const scaleName = model.scaleName(channel);
        if (isFacetModel(model.parent)) {
          const parentResolve = model.parent.component.resolve;
          if (parentResolve.scale[channel] === "independent") {
            return [stepSignal(scaleName, range2)];
          }
        }
        return [
          stepSignal(scaleName, range2),
          {
            name,
            update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)
          }
        ];
      }
    }
    throw new Error("layout size is step although width/height is not step.");
  } else if (size == "container") {
    const isWidth = name.endsWith("width");
    const expr2 = isWidth ? "containerSize()[0]" : "containerSize()[1]";
    const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? "width" : "height");
    const safeExpr = `isFinite(${expr2}) ? ${expr2} : ${defaultValue}`;
    return [{ name, init: safeExpr, on: [{ update: safeExpr, events: "window:resize" }] }];
  } else {
    return [
      {
        name,
        value: size
      }
    ];
  }
}
function stepSignal(scaleName, range2) {
  const name = `${scaleName}_step`;
  if (isSignalRef(range2.step)) {
    return { name, update: range2.step.signal };
  } else {
    return { name, value: range2.step };
  }
}
function sizeExpr(scaleName, scaleComponent, cardinality) {
  const type2 = scaleComponent.get("type");
  const padding2 = scaleComponent.get("padding");
  const paddingOuter2 = getFirstDefined(scaleComponent.get("paddingOuter"), padding2);
  let paddingInner2 = scaleComponent.get("paddingInner");
  paddingInner2 = type2 === "band" ? (
    // only band has real paddingInner
    paddingInner2 !== void 0 ? paddingInner2 : padding2
  ) : (
    // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
    // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
    1
  );
  return `bandspace(${cardinality}, ${signalOrStringValue(paddingInner2)}, ${signalOrStringValue(paddingOuter2)}) * ${scaleName}_step`;
}
function getSizeTypeFromLayoutSizeType(layoutSizeType) {
  return layoutSizeType === "childWidth" ? "width" : layoutSizeType === "childHeight" ? "height" : layoutSizeType;
}
function guideEncodeEntry(encoding, model) {
  return keys$1(encoding).reduce((encode2, channel) => {
    const valueDef = encoding[channel];
    return Object.assign(Object.assign({}, encode2), wrapCondition(model, valueDef, channel, (def2) => signalOrValueRef(def2.value)));
  }, {});
}
function defaultScaleResolve(channel, model) {
  if (isFacetModel(model)) {
    return channel === "theta" ? "independent" : "shared";
  } else if (isLayerModel(model)) {
    return "shared";
  } else if (isConcatModel(model)) {
    return isXorY(channel) || channel === "theta" || channel === "radius" ? "independent" : "shared";
  }
  throw new Error("invalid model type for resolve");
}
function parseGuideResolve(resolve2, channel) {
  const channelScaleResolve = resolve2.scale[channel];
  const guide = isXorY(channel) ? "axis" : "legend";
  if (channelScaleResolve === "independent") {
    if (resolve2[guide][channel] === "shared") {
      warn(independentScaleMeansIndependentGuide(channel));
    }
    return "independent";
  }
  return resolve2[guide][channel] || "shared";
}
const LEGEND_COMPONENT_PROPERTY_INDEX = Object.assign(Object.assign({}, COMMON_LEGEND_PROPERTY_INDEX), {
  disable: 1,
  labelExpr: 1,
  selections: 1,
  // channel scales
  opacity: 1,
  shape: 1,
  stroke: 1,
  fill: 1,
  size: 1,
  strokeWidth: 1,
  strokeDash: 1,
  // encode
  encode: 1
});
const LEGEND_COMPONENT_PROPERTIES = keys$1(LEGEND_COMPONENT_PROPERTY_INDEX);
class LegendComponent extends Split {
}
const legendEncodeRules = {
  symbols,
  gradient,
  labels: labels$1,
  entries
};
function symbols(symbolsSpec, { fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2 }) {
  var _a, _b, _c2, _d2, _e, _f2, _g2, _h;
  if (legendType2 !== "symbol") {
    return void 0;
  }
  const { markDef, encoding, config, mark: mark2 } = model;
  const filled = markDef.filled && mark2 !== "trail";
  let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), color(model, { filled }));
  const symbolOpacity = (_a = legendCmpt.get("symbolOpacity")) !== null && _a !== void 0 ? _a : config.legend.symbolOpacity;
  const symbolFillColor = (_b = legendCmpt.get("symbolFillColor")) !== null && _b !== void 0 ? _b : config.legend.symbolFillColor;
  const symbolStrokeColor = (_c2 = legendCmpt.get("symbolStrokeColor")) !== null && _c2 !== void 0 ? _c2 : config.legend.symbolStrokeColor;
  const opacity2 = symbolOpacity === void 0 ? (_d2 = getMaxValue(encoding.opacity)) !== null && _d2 !== void 0 ? _d2 : markDef.opacity : void 0;
  if (out.fill) {
    if (channel === "fill" || filled && channel === COLOR) {
      delete out.fill;
    } else {
      if (out.fill["field"]) {
        if (symbolFillColor) {
          delete out.fill;
        } else {
          out.fill = signalOrValueRef((_e = config.legend.symbolBaseFillColor) !== null && _e !== void 0 ? _e : "black");
          out.fillOpacity = signalOrValueRef(opacity2 !== null && opacity2 !== void 0 ? opacity2 : 1);
        }
      } else if (isArray$1(out.fill)) {
        const fill2 = (_h = (_g2 = getFirstConditionValue((_f2 = encoding.fill) !== null && _f2 !== void 0 ? _f2 : encoding.color)) !== null && _g2 !== void 0 ? _g2 : markDef.fill) !== null && _h !== void 0 ? _h : filled && markDef.color;
        if (fill2) {
          out.fill = signalOrValueRef(fill2);
        }
      }
    }
  }
  if (out.stroke) {
    if (channel === "stroke" || !filled && channel === COLOR) {
      delete out.stroke;
    } else {
      if (out.stroke["field"] || symbolStrokeColor) {
        delete out.stroke;
      } else if (isArray$1(out.stroke)) {
        const stroke2 = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : void 0);
        if (stroke2) {
          out.stroke = { value: stroke2 };
        }
      }
    }
  }
  if (channel !== OPACITY) {
    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);
    if (condition) {
      out.opacity = [
        Object.assign({ test: condition }, signalOrValueRef(opacity2 !== null && opacity2 !== void 0 ? opacity2 : 1)),
        signalOrValueRef(config.legend.unselectedOpacity)
      ];
    } else if (opacity2) {
      out.opacity = signalOrValueRef(opacity2);
    }
  }
  out = Object.assign(Object.assign({}, out), symbolsSpec);
  return isEmpty(out) ? void 0 : out;
}
function gradient(gradientSpec, { model, legendType: legendType2, legendCmpt }) {
  var _a;
  if (legendType2 !== "gradient") {
    return void 0;
  }
  const { config, markDef, encoding } = model;
  let out = {};
  const gradientOpacity = (_a = legendCmpt.get("gradientOpacity")) !== null && _a !== void 0 ? _a : config.legend.gradientOpacity;
  const opacity2 = gradientOpacity === void 0 ? getMaxValue(encoding.opacity) || markDef.opacity : void 0;
  if (opacity2) {
    out.opacity = signalOrValueRef(opacity2);
  }
  out = Object.assign(Object.assign({}, out), gradientSpec);
  return isEmpty(out) ? void 0 : out;
}
function labels$1(specifiedlabelsSpec, { fieldOrDatumDef, model, channel, legendCmpt }) {
  const legend = model.legend(channel) || {};
  const config = model.config;
  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : void 0;
  const opacity2 = condition ? [{ test: condition, value: 1 }, { value: config.legend.unselectedOpacity }] : void 0;
  const { format: format2, formatType } = legend;
  let text2 = void 0;
  if (isCustomFormatType(formatType)) {
    text2 = formatCustomType({
      fieldOrDatumDef,
      field: "datum.value",
      format: format2,
      formatType,
      config
    });
  } else if (format2 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (fieldOrDatumDef.type === "quantitative" && config.numberFormatType) {
      text2 = formatCustomType({
        fieldOrDatumDef,
        field: "datum.value",
        format: config.numberFormat,
        formatType: config.numberFormatType,
        config
      });
    } else if (fieldOrDatumDef.type === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === void 0) {
      text2 = formatCustomType({
        fieldOrDatumDef,
        field: "datum.value",
        format: config.timeFormat,
        formatType: config.timeFormatType,
        config
      });
    }
  }
  const labelsSpec = Object.assign(Object.assign(Object.assign({}, opacity2 ? { opacity: opacity2 } : {}), text2 ? { text: text2 } : {}), specifiedlabelsSpec);
  return isEmpty(labelsSpec) ? void 0 : labelsSpec;
}
function entries(entriesSpec, { legendCmpt }) {
  const selections = legendCmpt.get("selections");
  return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), { fill: { value: "transparent" } }) : entriesSpec;
}
function getMaxValue(channelDef) {
  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));
}
function getFirstConditionValue(channelDef) {
  return getConditionValue(channelDef, (v, conditionalDef) => {
    return getFirstDefined(v, conditionalDef.value);
  });
}
function getConditionValue(channelDef, reducer) {
  if (hasConditionalValueDef(channelDef)) {
    return array$5(channelDef.condition).reduce(reducer, channelDef.value);
  } else if (isValueDef(channelDef)) {
    return channelDef.value;
  }
  return void 0;
}
function selectedCondition(model, legendCmpt, fieldDef) {
  const selections = legendCmpt.get("selections");
  if (!(selections === null || selections === void 0 ? void 0 : selections.length))
    return void 0;
  const field2 = $(fieldDef.field);
  return selections.map((name) => {
    const store = $(varName(name) + STORE);
    return `(!length(data(${store})) || (${name}[${field2}] && indexof(${name}[${field2}], datum.value) >= 0))`;
  }).join(" || ");
}
const legendRules = {
  direction: ({ direction }) => direction,
  format: ({ fieldOrDatumDef, legend, config }) => {
    const { format: format2, formatType } = legend;
    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format2, formatType, config, false);
  },
  formatType: ({ legend, fieldOrDatumDef, scaleType: scaleType2 }) => {
    const { formatType } = legend;
    return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
  },
  gradientLength: (params2) => {
    var _a, _b;
    const { legend, legendConfig } = params2;
    return (_b = (_a = legend.gradientLength) !== null && _a !== void 0 ? _a : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params2);
  },
  labelOverlap: ({ legend, legendConfig, scaleType: scaleType2 }) => {
    var _a, _b;
    return (_b = (_a = legend.labelOverlap) !== null && _a !== void 0 ? _a : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap(scaleType2);
  },
  symbolType: ({ legend, markDef, channel, encoding }) => {
    var _a;
    return (_a = legend.symbolType) !== null && _a !== void 0 ? _a : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape);
  },
  title: ({ fieldOrDatumDef, config }) => title(fieldOrDatumDef, config, { allowDisabling: true }),
  type: ({ legendType: legendType2, scaleType: scaleType2, channel }) => {
    if (isColorChannel(channel) && isContinuousToContinuous(scaleType2)) {
      if (legendType2 === "gradient") {
        return void 0;
      }
    } else if (legendType2 === "symbol") {
      return void 0;
    }
    return legendType2;
  },
  values: ({ fieldOrDatumDef, legend }) => values$1(legend, fieldOrDatumDef)
};
function values$1(legend, fieldOrDatumDef) {
  const vals2 = legend.values;
  if (isArray$1(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultSymbolType(mark2, channel, shapeChannelDef, markShape) {
  var _a;
  if (channel !== "shape") {
    const shape2 = (_a = getFirstConditionValue(shapeChannelDef)) !== null && _a !== void 0 ? _a : markShape;
    if (shape2) {
      return shape2;
    }
  }
  switch (mark2) {
    case "bar":
    case "rect":
    case "image":
    case "square":
      return "square";
    case "line":
    case "trail":
    case "rule":
      return "stroke";
    case "arc":
    case "point":
    case "circle":
    case "tick":
    case "geoshape":
    case "area":
    case "text":
      return "circle";
  }
}
function getLegendType(params2) {
  const { legend } = params2;
  return getFirstDefined(legend.type, defaultType$1(params2));
}
function defaultType$1({ channel, timeUnit, scaleType: scaleType2 }) {
  if (isColorChannel(channel)) {
    if (contains(["quarter", "month", "day"], timeUnit)) {
      return "symbol";
    }
    if (isContinuousToContinuous(scaleType2)) {
      return "gradient";
    }
  }
  return "symbol";
}
function getDirection({ legendConfig, legendType: legendType2, orient: orient2, legend }) {
  var _a, _b;
  return (_b = (_a = legend.direction) !== null && _a !== void 0 ? _a : legendConfig[legendType2 ? "gradientDirection" : "symbolDirection"]) !== null && _b !== void 0 ? _b : defaultDirection(orient2, legendType2);
}
function defaultDirection(orient2, legendType2) {
  switch (orient2) {
    case "top":
    case "bottom":
      return "horizontal";
    case "left":
    case "right":
    case "none":
    case void 0:
      return void 0;
    // vertical is Vega's default
    default:
      return legendType2 === "gradient" ? "horizontal" : void 0;
  }
}
function defaultGradientLength({ legendConfig, model, direction, orient: orient2, scaleType: scaleType2 }) {
  const { gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength } = legendConfig;
  if (isContinuousToContinuous(scaleType2)) {
    if (direction === "horizontal") {
      if (orient2 === "top" || orient2 === "bottom") {
        return gradientLengthSignal(model, "width", gradientHorizontalMinLength, gradientHorizontalMaxLength);
      } else {
        return gradientHorizontalMinLength;
      }
    } else {
      return gradientLengthSignal(model, "height", gradientVerticalMinLength, gradientVerticalMaxLength);
    }
  }
  return void 0;
}
function gradientLengthSignal(model, sizeType, min2, max2) {
  const sizeSignal = model.getSizeSignalRef(sizeType).signal;
  return { signal: `clamp(${sizeSignal}, ${min2}, ${max2})` };
}
function defaultLabelOverlap(scaleType2) {
  if (contains(["quantile", "threshold", "log", "symlog"], scaleType2)) {
    return "greedy";
  }
  return void 0;
}
function parseLegend(model) {
  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);
  model.component.legends = legendComponent;
  return legendComponent;
}
function parseUnitLegend(model) {
  const { encoding } = model;
  const legendComponent = {};
  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {
    const def2 = getFieldOrDatumDef(encoding[channel]);
    if (!def2 || !model.getScaleComponent(channel)) {
      continue;
    }
    if (channel === SHAPE && isFieldDef(def2) && def2.type === GEOJSON) {
      continue;
    }
    legendComponent[channel] = parseLegendForChannel(model, channel);
  }
  return legendComponent;
}
function getLegendDefWithScale(model, channel) {
  const scale2 = model.scaleName(channel);
  if (model.mark === "trail") {
    if (channel === "color") {
      return { stroke: scale2 };
    } else if (channel === "size") {
      return { strokeWidth: scale2 };
    }
  }
  if (channel === "color") {
    return model.markDef.filled ? { fill: scale2 } : { stroke: scale2 };
  }
  return { [channel]: scale2 };
}
function isExplicit$1(value2, property2, legend, fieldDef) {
  switch (property2) {
    case "disable":
      return legend !== void 0;
    // if axis is specified or null/false, then its enable/disable state is explicit
    case "values":
      return !!(legend === null || legend === void 0 ? void 0 : legend.values);
    case "title":
      if (property2 === "title" && value2 === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {
        return true;
      }
  }
  return value2 === (legend || {})[property2];
}
function parseLegendForChannel(model, channel) {
  var _a, _b, _c2;
  let legend = model.legend(channel);
  const { markDef, encoding, config } = model;
  const legendConfig = config.legend;
  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));
  parseInteractiveLegend(model, channel, legendCmpt);
  const disable = legend !== void 0 ? !legend : legendConfig.disable;
  legendCmpt.set("disable", disable, legend !== void 0);
  if (disable) {
    return legendCmpt;
  }
  legend = legend || {};
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : void 0;
  const orient2 = legend.orient || config.legend.orient || "right";
  const legendType2 = getLegendType({ legend, channel, timeUnit, scaleType: scaleType2 });
  const direction = getDirection({ legend, legendType: legendType2, orient: orient2, legendConfig });
  const ruleParams = {
    legend,
    channel,
    model,
    markDef,
    encoding,
    fieldOrDatumDef,
    legendConfig,
    config,
    scaleType: scaleType2,
    orient: orient2,
    legendType: legendType2,
    direction
  };
  for (const property2 of LEGEND_COMPONENT_PROPERTIES) {
    if (legendType2 === "gradient" && property2.startsWith("symbol") || legendType2 === "symbol" && property2.startsWith("gradient")) {
      continue;
    }
    const value2 = property2 in legendRules ? legendRules[property2](ruleParams) : legend[property2];
    if (value2 !== void 0) {
      const explicit = isExplicit$1(value2, property2, legend, model.fieldDef(channel));
      if (explicit || config.legend[property2] === void 0) {
        legendCmpt.set(property2, value2, explicit);
      }
    }
  }
  const legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};
  const selections = legendCmpt.get("selections");
  const legendEncode = {};
  const legendEncodeParams = { fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2 };
  for (const part of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
    const legendEncodingPart = guideEncodeEntry((_c2 = legendEncoding[part]) !== null && _c2 !== void 0 ? _c2 : {}, model);
    const value2 = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) : legendEncodingPart;
    if (value2 !== void 0 && !isEmpty(value2)) {
      legendEncode[part] = Object.assign(Object.assign(Object.assign({}, (selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? { name: `${varName(fieldOrDatumDef.field)}_legend_${part}` } : {}), (selections === null || selections === void 0 ? void 0 : selections.length) ? { interactive: !!selections } : {}), { update: value2 });
    }
  }
  if (!isEmpty(legendEncode)) {
    legendCmpt.set("encode", legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));
  }
  return legendCmpt;
}
function parseNonUnitLegend(model) {
  const { legends, resolve: resolve2 } = model.component;
  for (const child of model.children) {
    parseLegend(child);
    for (const channel of keys$1(child.component.legends)) {
      resolve2.legend[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve2.legend[channel] === "shared") {
        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);
        if (!legends[channel]) {
          resolve2.legend[channel] = "independent";
          delete legends[channel];
        }
      }
    }
  }
  for (const channel of keys$1(legends)) {
    for (const child of model.children) {
      if (!child.component.legends[channel]) {
        continue;
      }
      if (resolve2.legend[channel] === "shared") {
        delete child.component.legends[channel];
      }
    }
  }
  return legends;
}
function mergeLegendComponent(mergedLegend, childLegend) {
  var _a, _b, _c2, _d2;
  if (!mergedLegend) {
    return childLegend.clone();
  }
  const mergedOrient = mergedLegend.getWithExplicit("orient");
  const childOrient = childLegend.getWithExplicit("orient");
  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
    return void 0;
  }
  let typeMerged = false;
  for (const prop of LEGEND_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(
      mergedLegend.getWithExplicit(prop),
      childLegend.getWithExplicit(prop),
      prop,
      "legend",
      // Tie breaker function
      (v1, v2) => {
        switch (prop) {
          case "symbolType":
            return mergeSymbolType(v1, v2);
          case "title":
            return mergeTitleComponent(v1, v2);
          case "type":
            typeMerged = true;
            return makeImplicit("symbol");
        }
        return defaultTieBreaker(v1, v2, prop, "legend");
      }
    );
    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);
  }
  if (typeMerged) {
    if ((_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient) {
      deleteNestedProperty(mergedLegend.implicit, ["encode", "gradient"]);
    }
    if ((_d2 = (_c2 = mergedLegend.explicit) === null || _c2 === void 0 ? void 0 : _c2.encode) === null || _d2 === void 0 ? void 0 : _d2.gradient) {
      deleteNestedProperty(mergedLegend.explicit, ["encode", "gradient"]);
    }
  }
  return mergedLegend;
}
function mergeSymbolType(st1, st2) {
  if (st2.value === "circle") {
    return st2;
  }
  return st1;
}
var __rest$a = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function setLegendEncode(legend, part, vgProp, vgRef) {
  var _a, _b, _c2;
  var _d2, _e;
  (_a = legend.encode) !== null && _a !== void 0 ? _a : legend.encode = {};
  (_b = (_d2 = legend.encode)[part]) !== null && _b !== void 0 ? _b : _d2[part] = {};
  (_c2 = (_e = legend.encode[part]).update) !== null && _c2 !== void 0 ? _c2 : _e.update = {};
  legend.encode[part].update[vgProp] = vgRef;
}
function assembleLegends(model) {
  const legendComponentIndex = model.component.legends;
  const legendByDomain = {};
  for (const channel of keys$1(legendComponentIndex)) {
    const scaleComponent = model.getScaleComponent(channel);
    const domainHash = stringify$1(scaleComponent.get("domains"));
    if (legendByDomain[domainHash]) {
      for (const mergedLegendComponent of legendByDomain[domainHash]) {
        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);
        if (!merged) {
          legendByDomain[domainHash].push(legendComponentIndex[channel]);
        }
      }
    } else {
      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];
    }
  }
  const legends = vals(legendByDomain).flat().map((l) => assembleLegend(l, model.config)).filter((l) => l !== void 0);
  return legends;
}
function assembleLegend(legendCmpt, config) {
  var _a, _b, _c2;
  const _d2 = legendCmpt.combine(), { disable, labelExpr, selections } = _d2, legend = __rest$a(_d2, ["disable", "labelExpr", "selections"]);
  if (disable) {
    return void 0;
  }
  if (config.aria === false && legend.aria == void 0) {
    legend.aria = false;
  }
  if ((_a = legend.encode) === null || _a === void 0 ? void 0 : _a.symbols) {
    const out = legend.encode.symbols.update;
    if (out.fill && out.fill["value"] !== "transparent" && !out.stroke && !legend.stroke) {
      out.stroke = { value: "transparent" };
    }
    for (const property2 of LEGEND_SCALE_CHANNELS) {
      if (legend[property2]) {
        delete out[property2];
      }
    }
  }
  if (!legend.title) {
    delete legend.title;
  }
  if (labelExpr !== void 0) {
    let expr2 = labelExpr;
    if (((_c2 = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c2 === void 0 ? void 0 : _c2.update) && isSignalRef(legend.encode.labels.update.text)) {
      expr2 = replaceAll(labelExpr, "datum.label", legend.encode.labels.update.text.signal);
    }
    setLegendEncode(legend, "labels", "text", { signal: expr2 });
  }
  return legend;
}
function assembleProjections(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return assembleProjectionsForModelAndChildren(model);
  } else {
    return assembleProjectionForModel(model);
  }
}
function assembleProjectionsForModelAndChildren(model) {
  return model.children.reduce((projections2, child) => {
    return projections2.concat(child.assembleProjections());
  }, assembleProjectionForModel(model));
}
function assembleProjectionForModel(model) {
  const component = model.component.projection;
  if (!component || component.merged) {
    return [];
  }
  const projection2 = component.combine();
  const { name } = projection2;
  if (!component.data) {
    return [
      Object.assign(Object.assign({ name }, { translate: { signal: "[width / 2, height / 2]" } }), projection2)
    ];
  } else {
    const size = {
      signal: `[${component.size.map((ref2) => ref2.signal).join(", ")}]`
    };
    const fits = component.data.reduce((sources, data2) => {
      const source2 = isSignalRef(data2) ? data2.signal : `data('${model.lookupDataSource(data2)}')`;
      if (!contains(sources, source2)) {
        sources.push(source2);
      }
      return sources;
    }, []);
    if (fits.length <= 0) {
      throw new Error("Projection's fit didn't find any data sources");
    }
    return [
      Object.assign({
        name,
        size,
        fit: {
          signal: fits.length > 1 ? `[${fits.join(", ")}]` : fits[0]
        }
      }, projection2)
    ];
  }
}
const PROJECTION_PROPERTIES = [
  "type",
  "clipAngle",
  "clipExtent",
  "center",
  "rotate",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
class ProjectionComponent extends Split {
  constructor(name, specifiedProjection, size, data2) {
    super(
      Object.assign({}, specifiedProjection),
      // all explicit properties of projection
      { name }
      // name as initial implicit property
    );
    this.specifiedProjection = specifiedProjection;
    this.size = size;
    this.data = data2;
    this.merged = false;
  }
  /**
   * Whether the projection parameters should fit provided data.
   */
  get isFit() {
    return !!this.data;
  }
}
function parseProjection(model) {
  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);
}
function parseUnitProjection(model) {
  var _a;
  if (model.hasProjection) {
    const proj = replaceExprRef(model.specifiedProjection);
    const fit2 = !(proj && (proj.scale != null || proj.translate != null));
    const size = fit2 ? [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")] : void 0;
    const data2 = fit2 ? gatherFitData(model) : void 0;
    const projComp = new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, (_a = replaceExprRef(model.config.projection)) !== null && _a !== void 0 ? _a : {}), proj !== null && proj !== void 0 ? proj : {}), size, data2);
    if (!projComp.get("type")) {
      projComp.set("type", "equalEarth", false);
    }
    return projComp;
  }
  return void 0;
}
function gatherFitData(model) {
  const data2 = [];
  const { encoding } = model;
  for (const posssiblePair of [
    [LONGITUDE, LATITUDE],
    [LONGITUDE2, LATITUDE2]
  ]) {
    if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {
      data2.push({
        signal: model.getName(`geojson_${data2.length}`)
      });
    }
  }
  if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {
    data2.push({
      signal: model.getName(`geojson_${data2.length}`)
    });
  }
  if (data2.length === 0) {
    data2.push(model.requestDataName(DataSourceType.Main));
  }
  return data2;
}
function mergeIfNoConflict(first, second2) {
  const allPropertiesShared = every(PROJECTION_PROPERTIES, (prop) => {
    if (!has$2(first.explicit, prop) && !has$2(second2.explicit, prop)) {
      return true;
    }
    if (has$2(first.explicit, prop) && has$2(second2.explicit, prop) && // some properties might be signals or objects and require hashing for comparison
    deepEqual(first.get(prop), second2.get(prop))) {
      return true;
    }
    return false;
  });
  const size = deepEqual(first.size, second2.size);
  if (size) {
    if (allPropertiesShared) {
      return first;
    } else if (deepEqual(first.explicit, {})) {
      return second2;
    } else if (deepEqual(second2.explicit, {})) {
      return first;
    }
  }
  return null;
}
function parseNonUnitProjections(model) {
  if (model.children.length === 0) {
    return void 0;
  }
  let nonUnitProjection;
  for (const child of model.children) {
    parseProjection(child);
  }
  const mergable = every(model.children, (child) => {
    const projection2 = child.component.projection;
    if (!projection2) {
      return true;
    } else if (!nonUnitProjection) {
      nonUnitProjection = projection2;
      return true;
    } else {
      const merge2 = mergeIfNoConflict(nonUnitProjection, projection2);
      if (merge2) {
        nonUnitProjection = merge2;
      }
      return !!merge2;
    }
  });
  if (nonUnitProjection && mergable) {
    const name = model.projectionName(true);
    const modelProjection = new ProjectionComponent(name, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));
    for (const child of model.children) {
      const projection2 = child.component.projection;
      if (projection2) {
        if (projection2.isFit) {
          modelProjection.data.push(...child.component.projection.data);
        }
        child.renameProjection(projection2.get("name"), name);
        projection2.merged = true;
      }
    }
    return modelProjection;
  }
  return void 0;
}
var __rest$9 = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function rangeFormula(model, fieldDef, channel, config) {
  var _a, _b;
  if (binRequiresRange(fieldDef, channel)) {
    const guide = isUnitModel(model) ? (_b = (_a = model.axis(channel)) !== null && _a !== void 0 ? _a : model.legend(channel)) !== null && _b !== void 0 ? _b : {} : {};
    const startField = vgField(fieldDef, { expr: "datum" });
    const endField = vgField(fieldDef, { expr: "datum", binSuffix: "end" });
    return {
      formulaAs: vgField(fieldDef, { binSuffix: "range", forAs: true }),
      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)
    };
  }
  return {};
}
function binKey(bin2, field2) {
  return `${binToString(bin2)}_${field2}`;
}
function getSignalsFromModel(model, key2) {
  return {
    signal: model.getName(`${key2}_bins`),
    extentSignal: model.getName(`${key2}_extent`)
  };
}
function getBinSignalName(model, field2, bin2) {
  var _a;
  const normalizedBin = (_a = normalizeBin(bin2, void 0)) !== null && _a !== void 0 ? _a : {};
  const key2 = binKey(normalizedBin, field2);
  return model.getName(`${key2}_bins`);
}
function isBinTransform(t4) {
  return "as" in t4;
}
function createBinComponent(t4, bin2, model) {
  let as;
  let span2;
  if (isBinTransform(t4)) {
    as = isString(t4.as) ? [t4.as, `${t4.as}_end`] : [t4.as[0], t4.as[1]];
  } else {
    as = [vgField(t4, { forAs: true }), vgField(t4, { binSuffix: "end", forAs: true })];
  }
  const normalizedBin = Object.assign({}, normalizeBin(bin2, void 0));
  const key2 = binKey(normalizedBin, t4.field);
  const { signal, extentSignal } = getSignalsFromModel(model, key2);
  if (isParameterExtent(normalizedBin.extent)) {
    const ext = normalizedBin.extent;
    span2 = parseSelectionExtent(model, ext.param, ext);
    delete normalizedBin.extent;
  }
  const binComponent = Object.assign(Object.assign(Object.assign({ bin: normalizedBin, field: t4.field, as: [as] }, signal ? { signal } : {}), extentSignal ? { extentSignal } : {}), span2 ? { span: span2 } : {});
  return { key: key2, binComponent };
}
class BinNode extends DataFlowNode {
  constructor(parent, bins2) {
    super(parent);
    this.bins = bins2;
  }
  clone() {
    return new BinNode(null, duplicate(this.bins));
  }
  static makeFromEncoding(parent, model) {
    const bins2 = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
        const { key: key2, binComponent } = createBinComponent(fieldDef, fieldDef.bin, model);
        binComponentIndex[key2] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key2]), rangeFormula(model, fieldDef, channel, model.config));
      }
      return binComponentIndex;
    }, {});
    if (isEmpty(bins2)) {
      return null;
    }
    return new BinNode(parent, bins2);
  }
  /**
   * Creates a bin node from BinTransform.
   * The optional parameter should provide
   */
  static makeFromTransform(parent, t4, model) {
    const { key: key2, binComponent } = createBinComponent(t4, t4.bin, model);
    return new BinNode(parent, {
      [key2]: binComponent
    });
  }
  /**
   * Merge bin nodes. This method either integrates the bin config from the other node
   * or if this node already has a bin config, renames the corresponding signal in the model.
   */
  merge(other, renameSignal) {
    for (const key2 of keys$1(other.bins)) {
      if (key2 in this.bins) {
        renameSignal(other.bins[key2].signal, this.bins[key2].signal);
        this.bins[key2].as = unique([...this.bins[key2].as, ...other.bins[key2].as], hash);
      } else {
        this.bins[key2] = other.bins[key2];
      }
    }
    for (const child of other.children) {
      other.removeChild(child);
      child.parent = this;
    }
    other.remove();
  }
  producedFields() {
    return new Set(vals(this.bins).map((c2) => c2.as).flat(2));
  }
  dependentFields() {
    return new Set(vals(this.bins).map((c2) => c2.field));
  }
  hash() {
    return `Bin ${hash(this.bins)}`;
  }
  assemble() {
    return vals(this.bins).flatMap((bin2) => {
      const transform2 = [];
      const [binAs, ...remainingAs] = bin2.as;
      const _a = bin2.bin, { extent: extent2 } = _a, params2 = __rest$9(_a, ["extent"]);
      const binTrans = Object.assign(Object.assign(Object.assign({ type: "bin", field: replacePathInField(bin2.field), as: binAs, signal: bin2.signal }, !isParameterExtent(extent2) ? { extent: extent2 } : { extent: null }), bin2.span ? { span: { signal: `span(${bin2.span})` } } : {}), params2);
      if (!extent2 && bin2.extentSignal) {
        transform2.push({
          type: "extent",
          field: replacePathInField(bin2.field),
          signal: bin2.extentSignal
        });
        binTrans.extent = { signal: bin2.extentSignal };
      }
      transform2.push(binTrans);
      for (const as of remainingAs) {
        for (let i = 0; i < 2; i++) {
          transform2.push({
            type: "formula",
            expr: vgField({ field: binAs[i] }, { expr: "datum" }),
            as: as[i]
          });
        }
      }
      if (bin2.formula) {
        transform2.push({
          type: "formula",
          expr: bin2.formula,
          as: bin2.formulaAs
        });
      }
      return transform2;
    });
  }
}
function addDimension(dims, channel, fieldDef, model) {
  var _a;
  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0;
  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {
    dims.add(vgField(fieldDef, {}));
    dims.add(vgField(fieldDef, { suffix: "end" }));
    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {
      dims.add(vgField(fieldDef, { binSuffix: "range" }));
    }
  } else if (isGeoPositionChannel(channel)) {
    const posChannel = getPositionChannelFromLatLong(channel);
    dims.add(model.getName(posChannel));
  } else {
    dims.add(vgField(fieldDef));
  }
  if (isScaleFieldDef(fieldDef) && isFieldRange((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.range)) {
    dims.add(fieldDef.scale.range.field);
  }
  return dims;
}
function mergeMeasures(parentMeasures, childMeasures) {
  var _a;
  for (const field2 of keys$1(childMeasures)) {
    const ops2 = childMeasures[field2];
    for (const op of keys$1(ops2)) {
      if (field2 in parentMeasures) {
        parentMeasures[field2][op] = /* @__PURE__ */ new Set([...(_a = parentMeasures[field2][op]) !== null && _a !== void 0 ? _a : [], ...ops2[op]]);
      } else {
        parentMeasures[field2] = { [op]: ops2[op] };
      }
    }
  }
}
class AggregateNode extends DataFlowNode {
  /**
   * @param dimensions string set for dimensions
   * @param measures dictionary mapping field name => dict of aggregation functions and names to use
   */
  constructor(parent, dimensions, measures) {
    super(parent);
    this.dimensions = dimensions;
    this.measures = measures;
  }
  clone() {
    return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));
  }
  get groupBy() {
    return this.dimensions;
  }
  static makeFromEncoding(parent, model) {
    let isAggregate2 = false;
    model.forEachFieldDef((fd) => {
      if (fd.aggregate) {
        isAggregate2 = true;
      }
    });
    const meas = {};
    const dims = /* @__PURE__ */ new Set();
    if (!isAggregate2) {
      return null;
    }
    model.forEachFieldDef((fieldDef, channel) => {
      var _a, _b, _c2, _d2;
      const { aggregate, field: field2 } = fieldDef;
      if (aggregate) {
        if (aggregate === "count") {
          (_a = meas["*"]) !== null && _a !== void 0 ? _a : meas["*"] = {};
          meas["*"]["count"] = /* @__PURE__ */ new Set([vgField(fieldDef, { forAs: true })]);
        } else {
          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
            const op = isArgminDef(aggregate) ? "argmin" : "argmax";
            const argField = aggregate[op];
            (_b = meas[argField]) !== null && _b !== void 0 ? _b : meas[argField] = {};
            meas[argField][op] = /* @__PURE__ */ new Set([vgField({ op, field: argField }, { forAs: true })]);
          } else {
            (_c2 = meas[field2]) !== null && _c2 !== void 0 ? _c2 : meas[field2] = {};
            meas[field2][aggregate] = /* @__PURE__ */ new Set([vgField(fieldDef, { forAs: true })]);
          }
          if (isScaleChannel(channel) && model.scaleDomain(channel) === "unaggregated") {
            (_d2 = meas[field2]) !== null && _d2 !== void 0 ? _d2 : meas[field2] = {};
            meas[field2]["min"] = /* @__PURE__ */ new Set([vgField({ field: field2, aggregate: "min" }, { forAs: true })]);
            meas[field2]["max"] = /* @__PURE__ */ new Set([vgField({ field: field2, aggregate: "max" }, { forAs: true })]);
          }
        }
      } else {
        addDimension(dims, channel, fieldDef, model);
      }
    });
    if (dims.size + keys$1(meas).length === 0) {
      return null;
    }
    return new AggregateNode(parent, dims, meas);
  }
  static makeFromTransform(parent, t4) {
    var _a, _b, _c2;
    const dims = /* @__PURE__ */ new Set();
    const meas = {};
    for (const s of t4.aggregate) {
      const { op, field: field2, as } = s;
      if (op) {
        if (op === "count") {
          (_a = meas["*"]) !== null && _a !== void 0 ? _a : meas["*"] = {};
          meas["*"]["count"] = /* @__PURE__ */ new Set([as ? as : vgField(s, { forAs: true })]);
        } else {
          (_b = meas[field2]) !== null && _b !== void 0 ? _b : meas[field2] = {};
          meas[field2][op] = /* @__PURE__ */ new Set([as ? as : vgField(s, { forAs: true })]);
        }
      }
    }
    for (const s of (_c2 = t4.groupby) !== null && _c2 !== void 0 ? _c2 : []) {
      dims.add(s);
    }
    if (dims.size + keys$1(meas).length === 0) {
      return null;
    }
    return new AggregateNode(parent, dims, meas);
  }
  merge(other) {
    if (setEqual(this.dimensions, other.dimensions)) {
      mergeMeasures(this.measures, other.measures);
      return true;
    }
    debug$2("different dimensions, cannot merge");
    return false;
  }
  addDimensions(fields) {
    fields.forEach(this.dimensions.add, this.dimensions);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([...this.dimensions, ...keys$1(this.measures)]);
  }
  producedFields() {
    const out = /* @__PURE__ */ new Set();
    for (const field2 of keys$1(this.measures)) {
      for (const op of keys$1(this.measures[field2])) {
        const m2 = this.measures[field2][op];
        if (m2.size === 0) {
          out.add(`${op}_${field2}`);
        } else {
          m2.forEach(out.add, out);
        }
      }
    }
    return out;
  }
  hash() {
    return `Aggregate ${hash({ dimensions: this.dimensions, measures: this.measures })}`;
  }
  assemble() {
    const ops2 = [];
    const fields = [];
    const as = [];
    for (const field2 of keys$1(this.measures)) {
      for (const op of keys$1(this.measures[field2])) {
        for (const alias of this.measures[field2][op]) {
          as.push(alias);
          ops2.push(op);
          fields.push(field2 === "*" ? null : replacePathInField(field2));
        }
      }
    }
    const result = {
      type: "aggregate",
      groupby: [...this.dimensions].map(replacePathInField),
      ops: ops2,
      fields,
      as
    };
    return result;
  }
}
class FacetNode extends DataFlowNode {
  /**
   * @param model The facet model.
   * @param name The name that this facet source will have.
   * @param data The source data for this facet data.
   */
  constructor(parent, model, name, data2) {
    super(parent);
    this.model = model;
    this.name = name;
    this.data = data2;
    for (const channel of FACET_CHANNELS) {
      const fieldDef = model.facet[channel];
      if (fieldDef) {
        const { bin: bin2, sort: sort2 } = fieldDef;
        this[channel] = Object.assign({ name: model.getName(`${channel}_domain`), fields: [vgField(fieldDef), ...isBinning(bin2) ? [vgField(fieldDef, { binSuffix: "end" })] : []] }, isSortField(sort2) ? { sortField: sort2 } : isArray$1(sort2) ? { sortIndexField: sortArrayIndexField(fieldDef, channel) } : {});
      }
    }
    this.childModel = model.child;
  }
  hash() {
    let out = `Facet`;
    for (const channel of FACET_CHANNELS) {
      if (this[channel]) {
        out += ` ${channel.charAt(0)}:${hash(this[channel])}`;
      }
    }
    return out;
  }
  get fields() {
    var _a;
    const f = [];
    for (const channel of FACET_CHANNELS) {
      if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {
        f.push(...this[channel].fields);
      }
    }
    return f;
  }
  dependentFields() {
    const depFields = new Set(this.fields);
    for (const channel of FACET_CHANNELS) {
      if (this[channel]) {
        if (this[channel].sortField) {
          depFields.add(this[channel].sortField.field);
        }
        if (this[channel].sortIndexField) {
          depFields.add(this[channel].sortIndexField);
        }
      }
    }
    return depFields;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  /**
   * The name to reference this source is its name.
   */
  getSource() {
    return this.name;
  }
  getChildIndependentFieldsWithStep() {
    const childIndependentFieldsWithStep = {};
    for (const channel of POSITION_SCALE_CHANNELS) {
      const childScaleComponent = this.childModel.component.scales[channel];
      if (childScaleComponent && !childScaleComponent.merged) {
        const type2 = childScaleComponent.get("type");
        const range2 = childScaleComponent.get("range");
        if (hasDiscreteDomain(type2) && isVgRangeStep(range2)) {
          const domain2 = assembleDomain(this.childModel, channel);
          const field2 = getFieldFromDomain(domain2);
          if (field2) {
            childIndependentFieldsWithStep[channel] = field2;
          } else {
            warn(unknownField(channel));
          }
        }
      }
    }
    return childIndependentFieldsWithStep;
  }
  assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {
    const childChannel = { row: "y", column: "x", facet: void 0 }[channel];
    const fields = [];
    const ops2 = [];
    const as = [];
    if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {
      if (crossedDataName) {
        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
        ops2.push("max");
      } else {
        fields.push(childIndependentFieldsWithStep[childChannel]);
        ops2.push("distinct");
      }
      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
    }
    const { sortField, sortIndexField } = this[channel];
    if (sortField) {
      const { op = DEFAULT_SORT_OP, field: field2 } = sortField;
      fields.push(field2);
      ops2.push(op);
      as.push(vgField(sortField, { forAs: true }));
    } else if (sortIndexField) {
      fields.push(sortIndexField);
      ops2.push("max");
      as.push(sortIndexField);
    }
    return {
      name: this[channel].name,
      // Use data from the crossed one if it exist
      source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,
      transform: [
        Object.assign({ type: "aggregate", groupby: this[channel].fields }, fields.length ? {
          fields,
          ops: ops2,
          as
        } : {})
      ]
    };
  }
  assembleFacetHeaderData(childIndependentFieldsWithStep) {
    var _a, _b;
    const { columns } = this.model.layout;
    const { layoutHeaders: layoutHeaders2 } = this.model.component;
    const data2 = [];
    const hasSharedAxis = {};
    for (const headerChannel of HEADER_CHANNELS) {
      for (const headerType of HEADER_TYPES) {
        const headers = (_a = layoutHeaders2[headerChannel] && layoutHeaders2[headerChannel][headerType]) !== null && _a !== void 0 ? _a : [];
        for (const header of headers) {
          if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            hasSharedAxis[headerChannel] = true;
            break;
          }
        }
      }
      if (hasSharedAxis[headerChannel]) {
        const cardinality = `length(data("${this.facet.name}"))`;
        const stop3 = headerChannel === "row" ? columns ? { signal: `ceil(${cardinality} / ${columns})` } : 1 : columns ? { signal: `min(${cardinality}, ${columns})` } : { signal: cardinality };
        data2.push({
          name: `${this.facet.name}_${headerChannel}`,
          transform: [
            {
              type: "sequence",
              start: 0,
              stop: stop3
            }
          ]
        });
      }
    }
    const { row, column: column2 } = hasSharedAxis;
    if (row || column2) {
      data2.unshift(this.assembleRowColumnHeaderData("facet", null, childIndependentFieldsWithStep));
    }
    return data2;
  }
  assemble() {
    var _a, _b;
    const data2 = [];
    let crossedDataName = null;
    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();
    const { column: column2, row, facet } = this;
    if (column2 && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {
      crossedDataName = `cross_${this.column.name}_${this.row.name}`;
      const fields = [].concat((_a = childIndependentFieldsWithStep.x) !== null && _a !== void 0 ? _a : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);
      const ops2 = fields.map(() => "distinct");
      data2.push({
        name: crossedDataName,
        source: this.data,
        transform: [
          {
            type: "aggregate",
            groupby: this.fields,
            fields,
            ops: ops2
          }
        ]
      });
    }
    for (const channel of [COLUMN, ROW]) {
      if (this[channel]) {
        data2.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));
      }
    }
    if (facet) {
      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);
      if (facetData) {
        data2.push(...facetData);
      }
    }
    return data2;
  }
}
function unquote(pattern) {
  if (pattern.startsWith("'") && pattern.endsWith("'") || pattern.startsWith('"') && pattern.endsWith('"')) {
    return pattern.slice(1, -1);
  }
  return pattern;
}
function parseExpression(field2, parse2) {
  const f = accessPathWithDatum(field2);
  if (parse2 === "number") {
    return `toNumber(${f})`;
  } else if (parse2 === "boolean") {
    return `toBoolean(${f})`;
  } else if (parse2 === "string") {
    return `toString(${f})`;
  } else if (parse2 === "date") {
    return `toDate(${f})`;
  } else if (parse2 === "flatten") {
    return f;
  } else if (parse2.startsWith("date:")) {
    const specifier = unquote(parse2.slice(5, parse2.length));
    return `timeParse(${f},'${specifier}')`;
  } else if (parse2.startsWith("utc:")) {
    const specifier = unquote(parse2.slice(4, parse2.length));
    return `utcParse(${f},'${specifier}')`;
  } else {
    warn(unrecognizedParse(parse2));
    return null;
  }
}
function getImplicitFromFilterTransform(transform2) {
  const implicit2 = {};
  forEachLeaf(transform2.filter, (filter2) => {
    var _a;
    if (isFieldPredicate(filter2)) {
      let val = null;
      if (isFieldEqualPredicate(filter2)) {
        val = signalRefOrValue(filter2.equal);
      } else if (isFieldLTEPredicate(filter2)) {
        val = signalRefOrValue(filter2.lte);
      } else if (isFieldLTPredicate(filter2)) {
        val = signalRefOrValue(filter2.lt);
      } else if (isFieldGTPredicate(filter2)) {
        val = signalRefOrValue(filter2.gt);
      } else if (isFieldGTEPredicate(filter2)) {
        val = signalRefOrValue(filter2.gte);
      } else if (isFieldRangePredicate(filter2)) {
        val = filter2.range[0];
      } else if (isFieldOneOfPredicate(filter2)) {
        val = ((_a = filter2.oneOf) !== null && _a !== void 0 ? _a : filter2["in"])[0];
      }
      if (val) {
        if (isDateTime(val)) {
          implicit2[filter2.field] = "date";
        } else if (isNumber$1(val)) {
          implicit2[filter2.field] = "number";
        } else if (isString(val)) {
          implicit2[filter2.field] = "string";
        }
      }
      if (filter2.timeUnit) {
        implicit2[filter2.field] = "date";
      }
    }
  });
  return implicit2;
}
function getImplicitFromEncoding(model) {
  const implicit2 = {};
  function add2(fieldDef) {
    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {
      implicit2[fieldDef.field] = "date";
    } else if (fieldDef.type === "quantitative" && isMinMaxOp(fieldDef.aggregate)) {
      implicit2[fieldDef.field] = "number";
    } else if (accessPathDepth(fieldDef.field) > 1) {
      if (!(fieldDef.field in implicit2)) {
        implicit2[fieldDef.field] = "flatten";
      }
    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {
      if (!(fieldDef.sort.field in implicit2)) {
        implicit2[fieldDef.sort.field] = "flatten";
      }
    }
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef)) {
        add2(fieldDef);
      } else {
        const mainChannel = getMainRangeChannel(channel);
        const mainFieldDef = model.fieldDef(mainChannel);
        add2(Object.assign(Object.assign({}, fieldDef), { type: mainFieldDef.type }));
      }
    });
  }
  if (isUnitModel(model)) {
    const { mark: mark2, markDef, encoding } = model;
    if (isPathMark(mark2) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)
    !model.encoding.order) {
      const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
      const dimensionChannelDef = encoding[dimensionChannel];
      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === "quantitative" && !(dimensionChannelDef.field in implicit2)) {
        implicit2[dimensionChannelDef.field] = "number";
      }
    }
  }
  return implicit2;
}
function getImplicitFromSelection(model) {
  const implicit2 = {};
  if (isUnitModel(model) && model.component.selection) {
    for (const name of keys$1(model.component.selection)) {
      const selCmpt = model.component.selection[name];
      for (const proj of selCmpt.project.items) {
        if (!proj.channel && accessPathDepth(proj.field) > 1) {
          implicit2[proj.field] = "flatten";
        }
      }
    }
  }
  return implicit2;
}
class ParseNode extends DataFlowNode {
  constructor(parent, parse2) {
    super(parent);
    this._parse = parse2;
  }
  clone() {
    return new ParseNode(null, duplicate(this._parse));
  }
  hash() {
    return `Parse ${hash(this._parse)}`;
  }
  /**
   * Creates a parse node from a data.format.parse and updates ancestorParse.
   */
  static makeExplicit(parent, model, ancestorParse) {
    var _a;
    let explicit = {};
    const data2 = model.data;
    if (!isGenerator(data2) && ((_a = data2 === null || data2 === void 0 ? void 0 : data2.format) === null || _a === void 0 ? void 0 : _a.parse)) {
      explicit = data2.format.parse;
    }
    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);
  }
  /**
   * Creates a parse node from "explicit" parse and "implicit" parse and updates ancestorParse.
   */
  static makeWithAncestors(parent, explicit, implicit2, ancestorParse) {
    for (const field2 of keys$1(implicit2)) {
      const parsedAs = ancestorParse.getWithExplicit(field2);
      if (parsedAs.value !== void 0) {
        if (parsedAs.explicit || parsedAs.value === implicit2[field2] || parsedAs.value === "derived" || implicit2[field2] === "flatten") {
          delete implicit2[field2];
        } else {
          warn(differentParse(field2, implicit2[field2], parsedAs.value));
        }
      }
    }
    for (const field2 of keys$1(explicit)) {
      const parsedAs = ancestorParse.get(field2);
      if (parsedAs !== void 0) {
        if (parsedAs === explicit[field2]) {
          delete explicit[field2];
        } else {
          warn(differentParse(field2, explicit[field2], parsedAs));
        }
      }
    }
    const parse2 = new Split(explicit, implicit2);
    ancestorParse.copyAll(parse2);
    const p = {};
    for (const key2 of keys$1(parse2.combine())) {
      const val = parse2.get(key2);
      if (val !== null) {
        p[key2] = val;
      }
    }
    if (keys$1(p).length === 0 || ancestorParse.parseNothing) {
      return null;
    }
    return new ParseNode(parent, p);
  }
  get parse() {
    return this._parse;
  }
  merge(other) {
    this._parse = Object.assign(Object.assign({}, this._parse), other.parse);
    other.remove();
  }
  /**
   * Assemble an object for Vega's format.parse property.
   */
  assembleFormatParse() {
    const formatParse = {};
    for (const field2 of keys$1(this._parse)) {
      const p = this._parse[field2];
      if (accessPathDepth(field2) === 1) {
        formatParse[field2] = p;
      }
    }
    return formatParse;
  }
  // format parse depends and produces all fields in its parse
  producedFields() {
    return new Set(keys$1(this._parse));
  }
  dependentFields() {
    return new Set(keys$1(this._parse));
  }
  assembleTransforms(onlyNested = false) {
    return keys$1(this._parse).filter((field2) => onlyNested ? accessPathDepth(field2) > 1 : true).map((field2) => {
      const expr2 = parseExpression(field2, this._parse[field2]);
      if (!expr2) {
        return null;
      }
      const formula = {
        type: "formula",
        expr: expr2,
        as: removePathFromField(field2)
        // Vega output is always flattened
      };
      return formula;
    }).filter((t4) => t4 !== null);
  }
}
class IdentifierNode extends DataFlowNode {
  clone() {
    return new IdentifierNode(null);
  }
  constructor(parent) {
    super(parent);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([SELECTION_ID]);
  }
  hash() {
    return "Identifier";
  }
  assemble() {
    return { type: "identifier", as: SELECTION_ID };
  }
}
class GraticuleNode extends DataFlowNode {
  constructor(parent, params2) {
    super(parent);
    this.params = params2;
  }
  clone() {
    return new GraticuleNode(null, this.params);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return void 0;
  }
  hash() {
    return `Graticule ${hash(this.params)}`;
  }
  assemble() {
    return Object.assign({ type: "graticule" }, this.params === true ? {} : this.params);
  }
}
class SequenceNode extends DataFlowNode {
  constructor(parent, params2) {
    super(parent);
    this.params = params2;
  }
  clone() {
    return new SequenceNode(null, this.params);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    var _a;
    return /* @__PURE__ */ new Set([(_a = this.params.as) !== null && _a !== void 0 ? _a : "data"]);
  }
  hash() {
    return `Hash ${hash(this.params)}`;
  }
  assemble() {
    return Object.assign({ type: "sequence" }, this.params);
  }
}
class SourceNode extends DataFlowNode {
  constructor(data2) {
    super(null);
    data2 !== null && data2 !== void 0 ? data2 : data2 = { name: "source" };
    let format2;
    if (!isGenerator(data2)) {
      format2 = data2.format ? Object.assign({}, omit(data2.format, ["parse"])) : {};
    }
    if (isInlineData(data2)) {
      this._data = { values: data2.values };
    } else if (isUrlData(data2)) {
      this._data = { url: data2.url };
      if (!format2.type) {
        let defaultExtension = /(?:\.([^.]+))?$/.exec(data2.url)[1];
        if (!contains(["json", "csv", "tsv", "dsv", "topojson"], defaultExtension)) {
          defaultExtension = "json";
        }
        format2.type = defaultExtension;
      }
    } else if (isSphereGenerator(data2)) {
      this._data = { values: [{ type: "Sphere" }] };
    } else if (isNamedData(data2) || isGenerator(data2)) {
      this._data = {};
    }
    this._generator = isGenerator(data2);
    if (data2.name) {
      this._name = data2.name;
    }
    if (format2 && !isEmpty(format2)) {
      this._data.format = format2;
    }
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return void 0;
  }
  get data() {
    return this._data;
  }
  hasName() {
    return !!this._name;
  }
  get isGenerator() {
    return this._generator;
  }
  get dataName() {
    return this._name;
  }
  set dataName(name) {
    this._name = name;
  }
  set parent(parent) {
    throw new Error("Source nodes have to be roots.");
  }
  remove() {
    throw new Error("Source nodes are roots and cannot be removed.");
  }
  hash() {
    throw new Error("Cannot hash sources");
  }
  assemble() {
    return Object.assign(Object.assign({ name: this._name }, this._data), { transform: [] });
  }
}
var __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value2), value2;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Optimizer_modified;
function isDataSourceNode(node2) {
  return node2 instanceof SourceNode || node2 instanceof GraticuleNode || node2 instanceof SequenceNode;
}
class Optimizer {
  constructor() {
    _Optimizer_modified.set(this, void 0);
    __classPrivateFieldSet(this, _Optimizer_modified, false);
  }
  // Once true, #modified is never set to false
  setModified() {
    __classPrivateFieldSet(this, _Optimizer_modified, true);
  }
  get modifiedFlag() {
    return __classPrivateFieldGet(this, _Optimizer_modified, "f");
  }
}
_Optimizer_modified = /* @__PURE__ */ new WeakMap();
class BottomUpOptimizer extends Optimizer {
  /**
   * Compute a map of node depths that we can use to determine a topological sort order.
   */
  getNodeDepths(node2, depth, depths) {
    depths.set(node2, depth);
    for (const child of node2.children) {
      this.getNodeDepths(child, depth + 1, depths);
    }
    return depths;
  }
  /**
   * Run the optimizer on all nodes starting from the leaves.
   */
  optimize(node2) {
    const depths = this.getNodeDepths(node2, 0, /* @__PURE__ */ new Map());
    const topologicalSort = [...depths.entries()].sort((a2, b2) => b2[1] - a2[1]);
    for (const tuple of topologicalSort) {
      this.run(tuple[0]);
    }
    return this.modifiedFlag;
  }
}
class TopDownOptimizer extends Optimizer {
  /**
   * Run the optimizer depth first on all nodes starting from the roots.
   */
  optimize(node2) {
    this.run(node2);
    for (const child of node2.children) {
      this.optimize(child);
    }
    return this.modifiedFlag;
  }
}
class MergeIdenticalNodes extends TopDownOptimizer {
  mergeNodes(parent, nodes) {
    const mergedNode = nodes.shift();
    for (const node2 of nodes) {
      parent.removeChild(node2);
      node2.parent = mergedNode;
      node2.remove();
    }
  }
  run(node2) {
    const hashes = node2.children.map((x2) => x2.hash());
    const buckets = {};
    for (let i = 0; i < hashes.length; i++) {
      if (buckets[hashes[i]] === void 0) {
        buckets[hashes[i]] = [node2.children[i]];
      } else {
        buckets[hashes[i]].push(node2.children[i]);
      }
    }
    for (const k of keys$1(buckets)) {
      if (buckets[k].length > 1) {
        this.setModified();
        this.mergeNodes(node2, buckets[k]);
      }
    }
  }
}
class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer {
  constructor(model) {
    super();
    this.requiresSelectionId = model && requiresSelectionId(model);
  }
  run(node2) {
    if (node2 instanceof IdentifierNode) {
      if (!(this.requiresSelectionId && (isDataSourceNode(node2.parent) || node2.parent instanceof AggregateNode || node2.parent instanceof ParseNode))) {
        this.setModified();
        node2.remove();
      }
    }
  }
}
class RemoveDuplicateTimeUnits extends Optimizer {
  optimize(node2) {
    this.run(node2, /* @__PURE__ */ new Set());
    return this.modifiedFlag;
  }
  run(node2, timeUnitFields) {
    let producedFields = /* @__PURE__ */ new Set();
    if (node2 instanceof TimeUnitNode) {
      producedFields = node2.producedFields();
      if (hasIntersection(producedFields, timeUnitFields)) {
        this.setModified();
        node2.removeFormulas(timeUnitFields);
        if (node2.producedFields.length === 0) {
          node2.remove();
        }
      }
    }
    for (const child of node2.children) {
      this.run(child, /* @__PURE__ */ new Set([...timeUnitFields, ...producedFields]));
    }
  }
}
class RemoveUnnecessaryOutputNodes extends TopDownOptimizer {
  constructor() {
    super();
  }
  run(node2) {
    if (node2 instanceof OutputNode && !node2.isRequired()) {
      this.setModified();
      node2.remove();
    }
  }
}
class MoveParseUp extends BottomUpOptimizer {
  run(node2) {
    if (isDataSourceNode(node2)) {
      return;
    }
    if (node2.numChildren() > 1) {
      return;
    }
    for (const child of node2.children) {
      if (child instanceof ParseNode) {
        if (node2 instanceof ParseNode) {
          this.setModified();
          node2.merge(child);
        } else {
          if (fieldIntersection(node2.producedFields(), child.dependentFields())) {
            continue;
          }
          this.setModified();
          child.swapWithParent();
        }
      }
    }
    return;
  }
}
class MergeParse extends BottomUpOptimizer {
  run(node2) {
    const originalChildren = [...node2.children];
    const parseChildren = node2.children.filter((child) => child instanceof ParseNode);
    if (node2.numChildren() > 1 && parseChildren.length >= 1) {
      const commonParse = {};
      const conflictingParse = /* @__PURE__ */ new Set();
      for (const parseNode of parseChildren) {
        const parse2 = parseNode.parse;
        for (const k of keys$1(parse2)) {
          if (!(k in commonParse)) {
            commonParse[k] = parse2[k];
          } else if (commonParse[k] !== parse2[k]) {
            conflictingParse.add(k);
          }
        }
      }
      for (const field2 of conflictingParse) {
        delete commonParse[field2];
      }
      if (!isEmpty(commonParse)) {
        this.setModified();
        const mergedParseNode = new ParseNode(node2, commonParse);
        for (const childNode of originalChildren) {
          if (childNode instanceof ParseNode) {
            for (const key2 of keys$1(commonParse)) {
              delete childNode.parse[key2];
            }
          }
          node2.removeChild(childNode);
          childNode.parent = mergedParseNode;
          if (childNode instanceof ParseNode && keys$1(childNode.parse).length === 0) {
            childNode.remove();
          }
        }
      }
    }
  }
}
class RemoveUnusedSubtrees extends BottomUpOptimizer {
  run(node2) {
    if (node2 instanceof OutputNode || node2.numChildren() > 0 || node2 instanceof FacetNode) ;
    else if (node2 instanceof SourceNode) ;
    else {
      this.setModified();
      node2.remove();
    }
  }
}
class MergeTimeUnits extends BottomUpOptimizer {
  run(node2) {
    const timeUnitChildren = node2.children.filter((x2) => x2 instanceof TimeUnitNode);
    const combination = timeUnitChildren.pop();
    for (const timeUnit of timeUnitChildren) {
      this.setModified();
      combination.merge(timeUnit);
    }
  }
}
class MergeAggregates extends BottomUpOptimizer {
  run(node2) {
    const aggChildren = node2.children.filter((child) => child instanceof AggregateNode);
    const groupedAggregates = {};
    for (const agg of aggChildren) {
      const groupBys = hash(agg.groupBy);
      if (!(groupBys in groupedAggregates)) {
        groupedAggregates[groupBys] = [];
      }
      groupedAggregates[groupBys].push(agg);
    }
    for (const group2 of keys$1(groupedAggregates)) {
      const mergeableAggs = groupedAggregates[group2];
      if (mergeableAggs.length > 1) {
        const mergedAggs = mergeableAggs.pop();
        for (const agg of mergeableAggs) {
          if (mergedAggs.merge(agg)) {
            node2.removeChild(agg);
            agg.parent = mergedAggs;
            agg.remove();
            this.setModified();
          }
        }
      }
    }
  }
}
class MergeBins extends BottomUpOptimizer {
  constructor(model) {
    super();
    this.model = model;
  }
  run(node2) {
    const moveBinsUp = !(isDataSourceNode(node2) || node2 instanceof FilterNode || node2 instanceof ParseNode || node2 instanceof IdentifierNode);
    const promotableBins = [];
    const remainingBins = [];
    for (const child of node2.children) {
      if (child instanceof BinNode) {
        if (moveBinsUp && !fieldIntersection(node2.producedFields(), child.dependentFields())) {
          promotableBins.push(child);
        } else {
          remainingBins.push(child);
        }
      }
    }
    if (promotableBins.length > 0) {
      const promotedBin = promotableBins.pop();
      for (const bin2 of promotableBins) {
        promotedBin.merge(bin2, this.model.renameSignal.bind(this.model));
      }
      this.setModified();
      if (node2 instanceof BinNode) {
        node2.merge(promotedBin, this.model.renameSignal.bind(this.model));
      } else {
        promotedBin.swapWithParent();
      }
    }
    if (remainingBins.length > 1) {
      const remainingBin = remainingBins.pop();
      for (const bin2 of remainingBins) {
        remainingBin.merge(bin2, this.model.renameSignal.bind(this.model));
      }
      this.setModified();
    }
  }
}
class MergeOutputs extends BottomUpOptimizer {
  run(node2) {
    const children2 = [...node2.children];
    const hasOutputChild = some(children2, (child) => child instanceof OutputNode);
    if (!hasOutputChild || node2.numChildren() <= 1) {
      return;
    }
    const otherChildren = [];
    let mainOutput;
    for (const child of children2) {
      if (child instanceof OutputNode) {
        let lastOutput = child;
        while (lastOutput.numChildren() === 1) {
          const [theChild] = lastOutput.children;
          if (theChild instanceof OutputNode) {
            lastOutput = theChild;
          } else {
            break;
          }
        }
        otherChildren.push(...lastOutput.children);
        if (mainOutput) {
          node2.removeChild(child);
          child.parent = mainOutput.parent;
          mainOutput.parent.removeChild(mainOutput);
          mainOutput.parent = lastOutput;
          this.setModified();
        } else {
          mainOutput = lastOutput;
        }
      } else {
        otherChildren.push(child);
      }
    }
    if (otherChildren.length) {
      this.setModified();
      for (const child of otherChildren) {
        child.parent.removeChild(child);
        child.parent = mainOutput;
      }
    }
  }
}
class JoinAggregateTransformNode extends DataFlowNode {
  constructor(parent, transform2) {
    super(parent);
    this.transform = transform2;
  }
  clone() {
    return new JoinAggregateTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
  }
  dependentFields() {
    const out = /* @__PURE__ */ new Set();
    if (this.transform.groupby) {
      this.transform.groupby.forEach(out.add, out);
    }
    this.transform.joinaggregate.map((w2) => w2.field).filter((f) => f !== void 0).forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this.transform.joinaggregate.map(this.getDefaultName));
  }
  getDefaultName(joinAggregateFieldDef) {
    var _a;
    return (_a = joinAggregateFieldDef.as) !== null && _a !== void 0 ? _a : vgField(joinAggregateFieldDef);
  }
  hash() {
    return `JoinAggregateTransform ${hash(this.transform)}`;
  }
  assemble() {
    const fields = [];
    const ops2 = [];
    const as = [];
    for (const joinaggregate of this.transform.joinaggregate) {
      ops2.push(joinaggregate.op);
      as.push(this.getDefaultName(joinaggregate));
      fields.push(joinaggregate.field === void 0 ? null : joinaggregate.field);
    }
    const groupby = this.transform.groupby;
    return Object.assign({
      type: "joinaggregate",
      as,
      ops: ops2,
      fields
    }, groupby !== void 0 ? { groupby } : {});
  }
}
function getStackByFields(model) {
  return model.stack.stackBy.reduce((fields, by) => {
    const fieldDef = by.fieldDef;
    const _field = vgField(fieldDef);
    if (_field) {
      fields.push(_field);
    }
    return fields;
  }, []);
}
function isValidAsArray(as) {
  return isArray$1(as) && as.every((s) => isString(s)) && as.length > 1;
}
class StackNode extends DataFlowNode {
  constructor(parent, stack2) {
    super(parent);
    this._stack = stack2;
  }
  clone() {
    return new StackNode(null, duplicate(this._stack));
  }
  static makeFromTransform(parent, stackTransform) {
    const { stack: stack2, groupby, as, offset: offset2 = "zero" } = stackTransform;
    const sortFields = [];
    const sortOrder = [];
    if (stackTransform.sort !== void 0) {
      for (const sortField of stackTransform.sort) {
        sortFields.push(sortField.field);
        sortOrder.push(getFirstDefined(sortField.order, "ascending"));
      }
    }
    const sort2 = {
      field: sortFields,
      order: sortOrder
    };
    let normalizedAs;
    if (isValidAsArray(as)) {
      normalizedAs = as;
    } else if (isString(as)) {
      normalizedAs = [as, `${as}_end`];
    } else {
      normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];
    }
    return new StackNode(parent, {
      dimensionFieldDefs: [],
      stackField: stack2,
      groupby,
      offset: offset2,
      sort: sort2,
      facetby: [],
      as: normalizedAs
    });
  }
  static makeFromEncoding(parent, model) {
    const stackProperties = model.stack;
    const { encoding } = model;
    if (!stackProperties) {
      return null;
    }
    const { groupbyChannels, fieldChannel, offset: offset2, impute } = stackProperties;
    const dimensionFieldDefs = groupbyChannels.map((groupbyChannel) => {
      const cDef = encoding[groupbyChannel];
      return getFieldDef(cDef);
    }).filter((def2) => !!def2);
    const stackby = getStackByFields(model);
    const orderDef = model.encoding.order;
    let sort2;
    if (isArray$1(orderDef) || isFieldDef(orderDef)) {
      sort2 = sortParams(orderDef);
    } else {
      sort2 = stackby.reduce((s, field2) => {
        s.field.push(field2);
        s.order.push(fieldChannel === "y" ? "descending" : "ascending");
        return s;
      }, { field: [], order: [] });
    }
    return new StackNode(parent, {
      dimensionFieldDefs,
      stackField: model.vgField(fieldChannel),
      facetby: [],
      stackby,
      sort: sort2,
      offset: offset2,
      impute,
      as: [
        model.vgField(fieldChannel, { suffix: "start", forAs: true }),
        model.vgField(fieldChannel, { suffix: "end", forAs: true })
      ]
    });
  }
  get stack() {
    return this._stack;
  }
  addDimensions(fields) {
    this._stack.facetby.push(...fields);
  }
  dependentFields() {
    const out = /* @__PURE__ */ new Set();
    out.add(this._stack.stackField);
    this.getGroupbyFields().forEach(out.add, out);
    this._stack.facetby.forEach(out.add, out);
    this._stack.sort.field.forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this._stack.as);
  }
  hash() {
    return `Stack ${hash(this._stack)}`;
  }
  getGroupbyFields() {
    const { dimensionFieldDefs, impute, groupby } = this._stack;
    if (dimensionFieldDefs.length > 0) {
      return dimensionFieldDefs.map((dimensionFieldDef) => {
        if (dimensionFieldDef.bin) {
          if (impute) {
            return [vgField(dimensionFieldDef, { binSuffix: "mid" })];
          }
          return [
            // For binned group by field without impute, we need both bin (start) and bin_end
            vgField(dimensionFieldDef, {}),
            vgField(dimensionFieldDef, { binSuffix: "end" })
          ];
        }
        return [vgField(dimensionFieldDef)];
      }).flat();
    }
    return groupby !== null && groupby !== void 0 ? groupby : [];
  }
  assemble() {
    const transform2 = [];
    const { facetby, dimensionFieldDefs, stackField: field2, stackby, sort: sort2, offset: offset2, impute, as } = this._stack;
    if (impute) {
      for (const dimensionFieldDef of dimensionFieldDefs) {
        const { bandPosition = 0.5, bin: bin2 } = dimensionFieldDef;
        if (bin2) {
          const binStart = vgField(dimensionFieldDef, { expr: "datum" });
          const binEnd = vgField(dimensionFieldDef, { expr: "datum", binSuffix: "end" });
          transform2.push({
            type: "formula",
            expr: `${bandPosition}*${binStart}+${1 - bandPosition}*${binEnd}`,
            as: vgField(dimensionFieldDef, { binSuffix: "mid", forAs: true })
          });
        }
        transform2.push({
          type: "impute",
          field: field2,
          groupby: [...stackby, ...facetby],
          key: vgField(dimensionFieldDef, { binSuffix: "mid" }),
          method: "value",
          value: 0
        });
      }
    }
    transform2.push({
      type: "stack",
      groupby: [...this.getGroupbyFields(), ...facetby],
      field: field2,
      sort: sort2,
      as,
      offset: offset2
    });
    return transform2;
  }
}
class WindowTransformNode extends DataFlowNode {
  constructor(parent, transform2) {
    super(parent);
    this.transform = transform2;
  }
  clone() {
    return new WindowTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
  }
  dependentFields() {
    var _a, _b;
    const out = /* @__PURE__ */ new Set();
    ((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []).forEach(out.add, out);
    ((_b = this.transform.sort) !== null && _b !== void 0 ? _b : []).forEach((m2) => out.add(m2.field));
    this.transform.window.map((w2) => w2.field).filter((f) => f !== void 0).forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this.transform.window.map(this.getDefaultName));
  }
  getDefaultName(windowFieldDef) {
    var _a;
    return (_a = windowFieldDef.as) !== null && _a !== void 0 ? _a : vgField(windowFieldDef);
  }
  hash() {
    return `WindowTransform ${hash(this.transform)}`;
  }
  assemble() {
    var _a;
    const fields = [];
    const ops2 = [];
    const as = [];
    const params2 = [];
    for (const window2 of this.transform.window) {
      ops2.push(window2.op);
      as.push(this.getDefaultName(window2));
      params2.push(window2.param === void 0 ? null : window2.param);
      fields.push(window2.field === void 0 ? null : window2.field);
    }
    const frame2 = this.transform.frame;
    const groupby = this.transform.groupby;
    if (frame2 && frame2[0] === null && frame2[1] === null && ops2.every((o) => isAggregateOp(o))) {
      return Object.assign({ type: "joinaggregate", as, ops: ops2, fields }, groupby !== void 0 ? { groupby } : {});
    }
    const sortFields = [];
    const sortOrder = [];
    if (this.transform.sort !== void 0) {
      for (const sortField of this.transform.sort) {
        sortFields.push(sortField.field);
        sortOrder.push((_a = sortField.order) !== null && _a !== void 0 ? _a : "ascending");
      }
    }
    const sort2 = {
      field: sortFields,
      order: sortOrder
    };
    const ignorePeers = this.transform.ignorePeers;
    return Object.assign(Object.assign(Object.assign({
      type: "window",
      params: params2,
      as,
      ops: ops2,
      fields,
      sort: sort2
    }, ignorePeers !== void 0 ? { ignorePeers } : {}), groupby !== void 0 ? { groupby } : {}), frame2 !== void 0 ? { frame: frame2 } : {});
  }
}
function cloneSubtree(facet) {
  function clone2(node2) {
    if (!(node2 instanceof FacetNode)) {
      const copy2 = node2.clone();
      if (copy2 instanceof OutputNode) {
        const newName = FACET_SCALE_PREFIX + copy2.getSource();
        copy2.setSource(newName);
        facet.model.component.data.outputNodes[newName] = copy2;
      } else if (copy2 instanceof AggregateNode || copy2 instanceof StackNode || copy2 instanceof WindowTransformNode || copy2 instanceof JoinAggregateTransformNode) {
        copy2.addDimensions(facet.fields);
      }
      for (const n of node2.children.flatMap(clone2)) {
        n.parent = copy2;
      }
      return [copy2];
    }
    return node2.children.flatMap(clone2);
  }
  return clone2;
}
function moveFacetDown(node2) {
  if (node2 instanceof FacetNode) {
    if (node2.numChildren() === 1 && !(node2.children[0] instanceof OutputNode)) {
      const child = node2.children[0];
      if (child instanceof AggregateNode || child instanceof StackNode || child instanceof WindowTransformNode || child instanceof JoinAggregateTransformNode) {
        child.addDimensions(node2.fields);
      }
      child.swapWithParent();
      moveFacetDown(node2);
    } else {
      const facetMain = node2.model.component.data.main;
      moveMainDownToFacet(facetMain);
      const cloner = cloneSubtree(node2);
      const copy2 = node2.children.map(cloner).flat();
      for (const c2 of copy2) {
        c2.parent = facetMain;
      }
    }
  } else {
    node2.children.map(moveFacetDown);
  }
}
function moveMainDownToFacet(node2) {
  if (node2 instanceof OutputNode && node2.type === DataSourceType.Main) {
    if (node2.numChildren() === 1) {
      const child = node2.children[0];
      if (!(child instanceof FacetNode)) {
        child.swapWithParent();
        moveMainDownToFacet(node2);
      }
    }
  }
}
const FACET_SCALE_PREFIX = "scale_";
const MAX_OPTIMIZATION_RUNS = 5;
function checkLinks(nodes) {
  for (const node2 of nodes) {
    for (const child of node2.children) {
      if (child.parent !== node2) {
        return false;
      }
    }
    if (!checkLinks(node2.children)) {
      return false;
    }
  }
  return true;
}
function runOptimizer(optimizer, nodes) {
  let modified2 = false;
  for (const node2 of nodes) {
    modified2 = optimizer.optimize(node2) || modified2;
  }
  return modified2;
}
function optimizationDataflowHelper(dataComponent, model, firstPass) {
  let roots = dataComponent.sources;
  let modified2 = false;
  modified2 = runOptimizer(new RemoveUnnecessaryOutputNodes(), roots) || modified2;
  modified2 = runOptimizer(new RemoveUnnecessaryIdentifierNodes(model), roots) || modified2;
  roots = roots.filter((r2) => r2.numChildren() > 0);
  modified2 = runOptimizer(new RemoveUnusedSubtrees(), roots) || modified2;
  roots = roots.filter((r2) => r2.numChildren() > 0);
  if (!firstPass) {
    modified2 = runOptimizer(new MoveParseUp(), roots) || modified2;
    modified2 = runOptimizer(new MergeBins(model), roots) || modified2;
    modified2 = runOptimizer(new RemoveDuplicateTimeUnits(), roots) || modified2;
    modified2 = runOptimizer(new MergeParse(), roots) || modified2;
    modified2 = runOptimizer(new MergeAggregates(), roots) || modified2;
    modified2 = runOptimizer(new MergeTimeUnits(), roots) || modified2;
    modified2 = runOptimizer(new MergeIdenticalNodes(), roots) || modified2;
    modified2 = runOptimizer(new MergeOutputs(), roots) || modified2;
  }
  dataComponent.sources = roots;
  return modified2;
}
function optimizeDataflow(data2, model) {
  checkLinks(data2.sources);
  let firstPassCounter = 0;
  let secondPassCounter = 0;
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data2, model, true)) {
      break;
    }
    firstPassCounter++;
  }
  data2.sources.map(moveFacetDown);
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data2, model, false)) {
      break;
    }
    secondPassCounter++;
  }
  checkLinks(data2.sources);
  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {
    warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);
  }
}
class SignalRefWrapper {
  constructor(exprGenerator) {
    Object.defineProperty(this, "signal", {
      enumerable: true,
      get: exprGenerator
    });
  }
  static fromName(rename, signalName) {
    return new SignalRefWrapper(() => rename(signalName));
  }
}
var __rest$8 = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function parseScaleDomain(model) {
  if (isUnitModel(model)) {
    parseUnitScaleDomain(model);
  } else {
    parseNonUnitScaleDomain(model);
  }
}
function parseUnitScaleDomain(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of keys$1(localScaleComponents)) {
    const domains = parseDomainForChannel(model, channel);
    const localScaleCmpt = localScaleComponents[channel];
    localScaleCmpt.setWithExplicit("domains", domains);
    parseSelectionDomain(model, channel);
    if (model.component.data.isFaceted) {
      let facetParent = model;
      while (!isFacetModel(facetParent) && facetParent.parent) {
        facetParent = facetParent.parent;
      }
      const resolve2 = facetParent.component.resolve.scale[channel];
      if (resolve2 === "shared") {
        for (const domain2 of domains.value) {
          if (isDataRefDomain(domain2)) {
            domain2.data = FACET_SCALE_PREFIX + domain2.data.replace(FACET_SCALE_PREFIX, "");
          }
        }
      }
    }
  }
}
function parseNonUnitScaleDomain(model) {
  for (const child of model.children) {
    parseScaleDomain(child);
  }
  const localScaleComponents = model.component.scales;
  for (const channel of keys$1(localScaleComponents)) {
    let domains;
    let selectionExtent = null;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        if (domains === void 0) {
          domains = childComponent.getWithExplicit("domains");
        } else {
          domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit("domains"), "domains", "scale", domainsTieBreaker);
        }
        const se = childComponent.get("selectionExtent");
        if (selectionExtent && se && selectionExtent.param !== se.param) {
          warn(NEEDS_SAME_SELECTION);
        }
        selectionExtent = se;
      }
    }
    localScaleComponents[channel].setWithExplicit("domains", domains);
    if (selectionExtent) {
      localScaleComponents[channel].set("selectionExtent", selectionExtent, true);
    }
  }
}
function normalizeUnaggregatedDomain(domain2, fieldDef, scaleType2, scaleConfig) {
  if (domain2 === "unaggregated") {
    const { valid: valid2, reason } = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (!valid2) {
      warn(reason);
      return void 0;
    }
  } else if (domain2 === void 0 && scaleConfig.useUnaggregatedDomain) {
    const { valid: valid2 } = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (valid2) {
      return "unaggregated";
    }
  }
  return domain2;
}
function parseDomainForChannel(model, channel) {
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const { encoding } = model;
  const domain2 = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType2, model.config.scale);
  if (domain2 !== model.scaleDomain(channel)) {
    model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), { domain: domain2 });
  }
  if (channel === "x" && getFieldOrDatumDef(encoding.x2)) {
    if (getFieldOrDatumDef(encoding.x)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain2, model, "x"), parseSingleChannelDomain(scaleType2, domain2, model, "x2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain2, model, "x2");
    }
  } else if (channel === "y" && getFieldOrDatumDef(encoding.y2)) {
    if (getFieldOrDatumDef(encoding.y)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain2, model, "y"), parseSingleChannelDomain(scaleType2, domain2, model, "y2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain2, model, "y2");
    }
  }
  return parseSingleChannelDomain(scaleType2, domain2, model, channel);
}
function mapDomainToDataSignal(domain2, type2, timeUnit) {
  return domain2.map((v) => {
    const data2 = valueExpr(v, { timeUnit, type: type2 });
    return { signal: `{data: ${data2}}` };
  });
}
function convertDomainIfItIsDateTime(domain2, type2, timeUnit) {
  var _a;
  const normalizedTimeUnit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;
  if (type2 === "temporal" || normalizedTimeUnit) {
    return mapDomainToDataSignal(domain2, type2, normalizedTimeUnit);
  }
  return [domain2];
}
function parseSingleChannelDomain(scaleType2, domain2, model, channel) {
  const { encoding } = model;
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const { type: type2 } = fieldOrDatumDef;
  const timeUnit = fieldOrDatumDef["timeUnit"];
  if (isDomainUnionWith(domain2)) {
    const defaultDomain = parseSingleChannelDomain(scaleType2, void 0, model, channel);
    const unionWith = convertDomainIfItIsDateTime(domain2.unionWith, type2, timeUnit);
    return makeExplicit([...defaultDomain.value, ...unionWith]);
  } else if (isSignalRef(domain2)) {
    return makeExplicit([domain2]);
  } else if (domain2 && domain2 !== "unaggregated" && !isParameterDomain(domain2)) {
    return makeExplicit(convertDomainIfItIsDateTime(domain2, type2, timeUnit));
  }
  const stack2 = model.stack;
  if (stack2 && channel === stack2.fieldChannel) {
    if (stack2.offset === "normalize") {
      return makeImplicit([[0, 1]]);
    }
    const data2 = model.requestDataName(DataSourceType.Main);
    return makeImplicit([
      {
        data: data2,
        field: model.vgField(channel, { suffix: "start" })
      },
      {
        data: data2,
        field: model.vgField(channel, { suffix: "end" })
      }
    ]);
  }
  const sort2 = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType2) : void 0;
  if (isDatumDef(fieldOrDatumDef)) {
    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type2, timeUnit);
    return makeImplicit(d);
  }
  const fieldDef = fieldOrDatumDef;
  if (domain2 === "unaggregated") {
    const data2 = model.requestDataName(DataSourceType.Main);
    const { field: field2 } = fieldOrDatumDef;
    return makeImplicit([
      {
        data: data2,
        field: vgField({ field: field2, aggregate: "min" })
      },
      {
        data: data2,
        field: vgField({ field: field2, aggregate: "max" })
      }
    ]);
  } else if (isBinning(fieldDef.bin)) {
    if (hasDiscreteDomain(scaleType2)) {
      if (scaleType2 === "bin-ordinal") {
        return makeImplicit([]);
      }
      return makeImplicit([
        {
          // If sort by aggregation of a specified sort field, we need to use RAW table,
          // so we can aggregate values for the scale independently from the main aggregation.
          data: isBoolean(sort2) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),
          // Use range if we added it and the scale does not support computing a range as a signal.
          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? { binSuffix: "range" } : {}),
          // we have to use a sort object if sort = true to make the sort correct by bin start
          sort: sort2 === true || !isObject$1(sort2) ? {
            field: model.vgField(channel, {}),
            op: "min"
            // min or max doesn't matter since we sort by the start of the bin range
          } : sort2
        }
      ]);
    } else {
      const { bin: bin2 } = fieldDef;
      if (isBinning(bin2)) {
        const binSignal = getBinSignalName(model, fieldDef.field, bin2);
        return makeImplicit([
          new SignalRefWrapper(() => {
            const signal = model.getSignalName(binSignal);
            return `[${signal}.start, ${signal}.stop]`;
          })
        ]);
      } else {
        return makeImplicit([
          {
            data: model.requestDataName(DataSourceType.Main),
            field: model.vgField(channel, {})
          }
        ]);
      }
    }
  } else if (fieldDef.timeUnit && contains(["time", "utc"], scaleType2) && hasBandEnd(fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0, model.markDef, model.config)) {
    const data2 = model.requestDataName(DataSourceType.Main);
    return makeImplicit([
      {
        data: data2,
        field: model.vgField(channel)
      },
      {
        data: data2,
        field: model.vgField(channel, { suffix: "end" })
      }
    ]);
  } else if (sort2) {
    return makeImplicit([
      {
        // If sort by aggregation of a specified sort field, we need to use RAW table,
        // so we can aggregate values for the scale independently from the main aggregation.
        data: isBoolean(sort2) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),
        field: model.vgField(channel),
        sort: sort2
      }
    ]);
  } else {
    return makeImplicit([
      {
        data: model.requestDataName(DataSourceType.Main),
        field: model.vgField(channel)
      }
    ]);
  }
}
function normalizeSortField(sort2, isStackedMeasure) {
  const { op, field: field2, order } = sort2;
  return Object.assign(Object.assign({
    // Apply default op
    op: op !== null && op !== void 0 ? op : isStackedMeasure ? "sum" : DEFAULT_SORT_OP
  }, field2 ? { field: replacePathInField(field2) } : {}), order ? { order } : {});
}
function parseSelectionDomain(model, channel) {
  var _a;
  const scale2 = model.component.scales[channel];
  const spec = model.specifiedScales[channel].domain;
  const bin2 = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.bin;
  const domain2 = isParameterDomain(spec) && spec;
  const extent2 = isBinParams(bin2) && isParameterExtent(bin2.extent) && bin2.extent;
  if (domain2 || extent2) {
    scale2.set("selectionExtent", domain2 !== null && domain2 !== void 0 ? domain2 : extent2, true);
  }
}
function domainSort(model, channel, scaleType2) {
  if (!hasDiscreteDomain(scaleType2)) {
    return void 0;
  }
  const fieldDef = model.fieldDef(channel);
  const sort2 = fieldDef.sort;
  if (isSortArray(sort2)) {
    return {
      op: "min",
      field: sortArrayIndexField(fieldDef, channel),
      order: "ascending"
    };
  }
  const { stack: stack2 } = model;
  const stackDimensions = stack2 ? /* @__PURE__ */ new Set([...stack2.groupbyFields, ...stack2.stackBy.map((s) => s.fieldDef.field)]) : void 0;
  if (isSortField(sort2)) {
    const isStackedMeasure = stack2 && !stackDimensions.has(sort2.field);
    return normalizeSortField(sort2, isStackedMeasure);
  } else if (isSortByEncoding(sort2)) {
    const { encoding, order } = sort2;
    const fieldDefToSortBy = model.fieldDef(encoding);
    const { aggregate, field: field2 } = fieldDefToSortBy;
    const isStackedMeasure = stack2 && !stackDimensions.has(field2);
    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
      return normalizeSortField({
        field: vgField(fieldDefToSortBy),
        order
      }, isStackedMeasure);
    } else if (isAggregateOp(aggregate) || !aggregate) {
      return normalizeSortField({
        op: aggregate,
        field: field2,
        order
      }, isStackedMeasure);
    }
  } else if (sort2 === "descending") {
    return {
      op: "min",
      field: model.vgField(channel),
      order: "descending"
    };
  } else if (contains([
    "ascending",
    void 0
    /* default =ascending*/
  ], sort2)) {
    return true;
  }
  return void 0;
}
function canUseUnaggregatedDomain(fieldDef, scaleType2) {
  const { aggregate, type: type2 } = fieldDef;
  if (!aggregate) {
    return {
      valid: false,
      reason: unaggregateDomainHasNoEffectForRawField(fieldDef)
    };
  }
  if (isString(aggregate) && !SHARED_DOMAIN_OPS.has(aggregate)) {
    return {
      valid: false,
      reason: unaggregateDomainWithNonSharedDomainOp(aggregate)
    };
  }
  if (type2 === "quantitative") {
    if (scaleType2 === "log") {
      return {
        valid: false,
        reason: unaggregatedDomainWithLogScale(fieldDef)
      };
    }
  }
  return { valid: true };
}
function domainsTieBreaker(v1, v2, property2, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn(mergeConflictingDomainProperty(property2, propertyOf, v1.value, v2.value));
  }
  return { explicit: v1.explicit, value: [...v1.value, ...v2.value] };
}
function mergeDomains(domains) {
  const uniqueDomains = unique(domains.map((domain2) => {
    if (isDataRefDomain(domain2)) {
      const { sort: _s } = domain2, domainWithoutSort = __rest$8(domain2, ["sort"]);
      return domainWithoutSort;
    }
    return domain2;
  }), hash);
  const sorts = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      const s = d.sort;
      if (s !== void 0 && !isBoolean(s)) {
        if ("op" in s && s.op === "count") {
          delete s.field;
        }
        if (s.order === "ascending") {
          delete s.order;
        }
      }
      return s;
    }
    return void 0;
  }).filter((s) => s !== void 0), hash);
  if (uniqueDomains.length === 0) {
    return void 0;
  } else if (uniqueDomains.length === 1) {
    const domain2 = domains[0];
    if (isDataRefDomain(domain2) && sorts.length > 0) {
      let sort22 = sorts[0];
      if (sorts.length > 1) {
        warn(MORE_THAN_ONE_SORT);
        sort22 = true;
      } else {
        if (isObject$1(sort22) && "field" in sort22) {
          const sortField = sort22.field;
          if (domain2.field === sortField) {
            sort22 = sort22.order ? { order: sort22.order } : true;
          }
        }
      }
      return Object.assign(Object.assign({}, domain2), { sort: sort22 });
    }
    return domain2;
  }
  const unionDomainSorts = unique(sorts.map((s) => {
    if (isBoolean(s) || !("op" in s) || isString(s.op) && s.op in MULTIDOMAIN_SORT_OP_INDEX) {
      return s;
    }
    warn(domainSortDropped(s));
    return true;
  }), hash);
  let sort2;
  if (unionDomainSorts.length === 1) {
    sort2 = unionDomainSorts[0];
  } else if (unionDomainSorts.length > 1) {
    warn(MORE_THAN_ONE_SORT);
    sort2 = true;
  }
  const allData = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      return d.data;
    }
    return null;
  }), (x2) => x2);
  if (allData.length === 1 && allData[0] !== null) {
    const domain2 = Object.assign({ data: allData[0], fields: uniqueDomains.map((d) => d.field) }, sort2 ? { sort: sort2 } : {});
    return domain2;
  }
  return Object.assign({ fields: uniqueDomains }, sort2 ? { sort: sort2 } : {});
}
function getFieldFromDomain(domain2) {
  if (isDataRefDomain(domain2) && isString(domain2.field)) {
    return domain2.field;
  } else if (isDataRefUnionedDomain(domain2)) {
    let field2;
    for (const nonUnionDomain of domain2.fields) {
      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {
        if (!field2) {
          field2 = nonUnionDomain.field;
        } else if (field2 !== nonUnionDomain.field) {
          warn(FACETED_INDEPENDENT_DIFFERENT_SOURCES);
          return field2;
        }
      }
    }
    warn(FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);
    return field2;
  } else if (isFieldRefUnionDomain(domain2)) {
    warn(FACETED_INDEPENDENT_SAME_SOURCE);
    const field2 = domain2.fields[0];
    return isString(field2) ? field2 : void 0;
  }
  return void 0;
}
function assembleDomain(model, channel) {
  const scaleComponent = model.component.scales[channel];
  const domains = scaleComponent.get("domains").map((domain2) => {
    if (isDataRefDomain(domain2)) {
      domain2.data = model.lookupDataSource(domain2.data);
    }
    return domain2;
  });
  return mergeDomains(domains);
}
var __rest$7 = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function assembleScales(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return model.children.reduce((scales2, child) => {
      return scales2.concat(assembleScales(child));
    }, assembleScalesForModel(model));
  } else {
    return assembleScalesForModel(model);
  }
}
function assembleScalesForModel(model) {
  return keys$1(model.component.scales).reduce((scales2, channel) => {
    const scaleComponent = model.component.scales[channel];
    if (scaleComponent.merged) {
      return scales2;
    }
    const scale2 = scaleComponent.combine();
    const { name, type: type2, selectionExtent, domains: _d2, range: _r2, reverse: reverse2 } = scale2, otherScaleProps = __rest$7(scale2, ["name", "type", "selectionExtent", "domains", "range", "reverse"]);
    const range2 = assembleScaleRange(scale2.range, name, channel, model);
    const domain2 = assembleDomain(model, channel);
    const domainRaw = selectionExtent ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain2) : null;
    scales2.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      name,
      type: type2
    }, domain2 ? { domain: domain2 } : {}), domainRaw ? { domainRaw } : {}), { range: range2 }), reverse2 !== void 0 ? { reverse: reverse2 } : {}), otherScaleProps));
    return scales2;
  }, []);
}
function assembleScaleRange(scaleRange, scaleName, channel, model) {
  if (isXorY(channel)) {
    if (isVgRangeStep(scaleRange)) {
      return {
        step: { signal: `${scaleName}_step` }
      };
    }
  } else if (isObject$1(scaleRange) && isDataRefDomain(scaleRange)) {
    return Object.assign(Object.assign({}, scaleRange), { data: model.lookupDataSource(scaleRange.data) });
  }
  return scaleRange;
}
class ScaleComponent extends Split {
  constructor(name, typeWithExplicit) {
    super(
      {},
      // no initial explicit property
      { name }
      // name as initial implicit property
    );
    this.merged = false;
    this.setWithExplicit("type", typeWithExplicit);
  }
  /**
   * Whether the scale definitely includes zero in the domain
   */
  domainDefinitelyIncludesZero() {
    if (this.get("zero") !== false) {
      return true;
    }
    return some(this.get("domains"), (d) => isArray$1(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);
  }
}
const RANGE_PROPERTIES = ["range", "scheme"];
function parseUnitScaleRange(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of SCALE_CHANNELS) {
    const localScaleCmpt = localScaleComponents[channel];
    if (!localScaleCmpt) {
      continue;
    }
    const rangeWithExplicit = parseRangeForChannel(channel, model);
    localScaleCmpt.setWithExplicit("range", rangeWithExplicit);
  }
}
function getBinStepSignal(model, channel) {
  const fieldDef = model.fieldDef(channel);
  if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) {
    const { bin: bin2, field: field2 } = fieldDef;
    const sizeType = getSizeChannel(channel);
    const sizeSignal = model.getName(sizeType);
    if (isObject$1(bin2) && bin2.binned && bin2.step !== void 0) {
      return new SignalRefWrapper(() => {
        const scaleName = model.scaleName(channel);
        const binCount = `(domain("${scaleName}")[1] - domain("${scaleName}")[0]) / ${bin2.step}`;
        return `${model.getSignalName(sizeSignal)} / (${binCount})`;
      });
    } else if (isBinning(bin2)) {
      const binSignal = getBinSignalName(model, field2, bin2);
      return new SignalRefWrapper(() => {
        const updatedName = model.getSignalName(binSignal);
        const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;
        return `${model.getSignalName(sizeSignal)} / (${binCount})`;
      });
    }
  }
  return void 0;
}
function parseRangeForChannel(channel, model) {
  const specifiedScale = model.specifiedScales[channel];
  const { size } = model;
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  for (const property2 of RANGE_PROPERTIES) {
    if (specifiedScale[property2] !== void 0) {
      const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
      const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
      if (!supportedByScaleType) {
        warn(scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
      } else if (channelIncompatability) {
        warn(channelIncompatability);
      } else {
        switch (property2) {
          case "range": {
            const range2 = specifiedScale.range;
            if (isArray$1(range2)) {
              if (isXorY(channel)) {
                return makeExplicit(range2.map((v) => {
                  if (v === "width" || v === "height") {
                    const sizeSignal = model.getName(v);
                    const getSignalName = model.getSignalName.bind(model);
                    return SignalRefWrapper.fromName(getSignalName, sizeSignal);
                  }
                  return v;
                }));
              }
            } else if (isObject$1(range2)) {
              return makeExplicit({
                data: model.requestDataName(DataSourceType.Main),
                field: range2.field,
                sort: { op: "min", field: model.vgField(channel) }
              });
            }
            return makeExplicit(range2);
          }
          case "scheme":
            return makeExplicit(parseScheme(specifiedScale[property2]));
        }
      }
    }
  }
  const sizeChannel = channel === X || channel === "xOffset" ? "width" : "height";
  const sizeValue = size[sizeChannel];
  if (isStep(sizeValue)) {
    if (isXorY(channel)) {
      if (hasDiscreteDomain(scaleType2)) {
        const step = getPositionStep(sizeValue, model, channel);
        if (step) {
          return makeExplicit({ step });
        }
      } else {
        warn(stepDropped(sizeChannel));
      }
    } else if (isXorYOffset(channel)) {
      const positionChannel = channel === XOFFSET ? "x" : "y";
      const positionScaleCmpt = model.getScaleComponent(positionChannel);
      const positionScaleType = positionScaleCmpt.get("type");
      if (positionScaleType === "band") {
        const step = getOffsetStep(sizeValue, scaleType2);
        if (step) {
          return makeExplicit(step);
        }
      }
    }
  }
  const { rangeMin: rangeMin2, rangeMax: rangeMax2 } = specifiedScale;
  const d = defaultRange(channel, model);
  if ((rangeMin2 !== void 0 || rangeMax2 !== void 0) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same
  scaleTypeSupportProperty(scaleType2, "rangeMin") && isArray$1(d) && d.length === 2) {
    return makeExplicit([rangeMin2 !== null && rangeMin2 !== void 0 ? rangeMin2 : d[0], rangeMax2 !== null && rangeMax2 !== void 0 ? rangeMax2 : d[1]]);
  }
  return makeImplicit(d);
}
function parseScheme(scheme2) {
  if (isExtendedScheme(scheme2)) {
    return Object.assign({ scheme: scheme2.name }, omit(scheme2, ["name"]));
  }
  return { scheme: scheme2 };
}
function defaultRange(channel, model) {
  const { size, config, mark: mark2, encoding } = model;
  const getSignalName = model.getSignalName.bind(model);
  const { type: type2 } = getFieldOrDatumDef(encoding[channel]);
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  const { domain: domain2, domainMid } = model.specifiedScales[channel];
  switch (channel) {
    case X:
    case Y: {
      if (contains(["point", "band"], scaleType2)) {
        const positionSize = getDiscretePositionSize(channel, size, config.view);
        if (isStep(positionSize)) {
          const step = getPositionStep(positionSize, model, channel);
          return { step };
        }
      }
      const sizeType = getSizeChannel(channel);
      const sizeSignal = model.getName(sizeType);
      if (channel === Y && hasContinuousDomain(scaleType2)) {
        return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];
      } else {
        return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];
      }
    }
    case XOFFSET:
    case YOFFSET:
      return getOffsetRange(channel, model, scaleType2);
    case SIZE: {
      const zero2 = model.component.scales[channel].get("zero");
      const rangeMin2 = sizeRangeMin(mark2, zero2, config);
      const rangeMax2 = sizeRangeMax(mark2, size, model, config);
      if (isContinuousToDiscrete(scaleType2)) {
        return interpolateRange(rangeMin2, rangeMax2, defaultContinuousToDiscreteCount(scaleType2, config, domain2, channel));
      } else {
        return [rangeMin2, rangeMax2];
      }
    }
    case THETA:
      return [0, Math.PI * 2];
    case ANGLE:
      return [0, 360];
    case RADIUS: {
      return [
        0,
        new SignalRefWrapper(() => {
          const w2 = model.getSignalName("width");
          const h2 = model.getSignalName("height");
          return `min(${w2},${h2})/2`;
        })
      ];
    }
    case STROKEWIDTH:
      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];
    case STROKEDASH:
      return [
        // TODO: add this to Vega's config.range?
        [1, 0],
        [4, 2],
        [2, 1],
        [1, 1],
        [1, 2, 4, 2]
      ];
    case SHAPE:
      return "symbol";
    case COLOR:
    case FILL:
    case STROKE:
      if (scaleType2 === "ordinal") {
        return type2 === "nominal" ? "category" : "ordinal";
      } else {
        if (domainMid !== void 0) {
          return "diverging";
        } else {
          return mark2 === "rect" || mark2 === "geoshape" ? "heatmap" : "ramp";
        }
      }
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
      return [config.scale.minOpacity, config.scale.maxOpacity];
  }
}
function getPositionStep(step, model, channel) {
  var _a, _b, _c2, _d2, _e;
  const { encoding } = model;
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const offsetChannel = getOffsetScaleChannel(channel);
  const offsetDef = encoding[offsetChannel];
  const stepFor = getStepFor({ step, offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete$1(offsetDef.type) });
  if (stepFor === "offset" && channelHasFieldOrDatum(encoding, offsetChannel)) {
    const offsetScaleCmpt = model.getScaleComponent(offsetChannel);
    const offsetScaleName = model.scaleName(offsetChannel);
    let stepCount = `domain('${offsetScaleName}').length`;
    if (offsetScaleCmpt.get("type") === "band") {
      const offsetPaddingInner = (_b = (_a = offsetScaleCmpt.get("paddingInner")) !== null && _a !== void 0 ? _a : offsetScaleCmpt.get("padding")) !== null && _b !== void 0 ? _b : 0;
      const offsetPaddingOuter = (_d2 = (_c2 = offsetScaleCmpt.get("paddingOuter")) !== null && _c2 !== void 0 ? _c2 : offsetScaleCmpt.get("padding")) !== null && _d2 !== void 0 ? _d2 : 0;
      stepCount = `bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`;
    }
    const paddingInner2 = (_e = mergedScaleCmpt.get("paddingInner")) !== null && _e !== void 0 ? _e : mergedScaleCmpt.get("padding");
    return {
      signal: `${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner2)})`
    };
  } else {
    return step.step;
  }
}
function getOffsetStep(step, offsetScaleType) {
  const stepFor = getStepFor({ step, offsetIsDiscrete: hasDiscreteDomain(offsetScaleType) });
  if (stepFor === "offset") {
    return { step: step.step };
  }
  return void 0;
}
function getOffsetRange(channel, model, offsetScaleType) {
  const positionChannel = channel === XOFFSET ? "x" : "y";
  const positionScaleCmpt = model.getScaleComponent(positionChannel);
  const positionScaleType = positionScaleCmpt.get("type");
  const positionScaleName = model.scaleName(positionChannel);
  if (positionScaleType === "band") {
    const size = getDiscretePositionSize(positionChannel, model.size, model.config.view);
    if (isStep(size)) {
      const step = getOffsetStep(size, offsetScaleType);
      if (step) {
        return step;
      }
    }
    return [0, { signal: `bandwidth('${positionScaleName}')` }];
  } else {
    return never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);
  }
}
function getDiscretePositionSize(channel, size, viewConfig) {
  const sizeChannel = channel === X ? "width" : "height";
  const sizeValue = size[sizeChannel];
  if (sizeValue) {
    return sizeValue;
  }
  return getViewConfigDiscreteSize(viewConfig, sizeChannel);
}
function defaultContinuousToDiscreteCount(scaleType2, config, domain2, channel) {
  switch (scaleType2) {
    case "quantile":
      return config.scale.quantileCount;
    case "quantize":
      return config.scale.quantizeCount;
    case "threshold":
      if (domain2 !== void 0 && isArray$1(domain2)) {
        return domain2.length + 1;
      } else {
        warn(domainRequiredForThresholdScale(channel));
        return 3;
      }
  }
}
function interpolateRange(rangeMin2, rangeMax2, cardinality) {
  const f = () => {
    const rMax = signalOrStringValue(rangeMax2);
    const rMin = signalOrStringValue(rangeMin2);
    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;
    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;
  };
  if (isSignalRef(rangeMax2)) {
    return new SignalRefWrapper(f);
  } else {
    return { signal: f() };
  }
}
function sizeRangeMin(mark2, zero2, config) {
  if (zero2) {
    if (isSignalRef(zero2)) {
      return { signal: `${zero2.signal} ? 0 : ${sizeRangeMin(mark2, false, config)}` };
    } else {
      return 0;
    }
  }
  switch (mark2) {
    case "bar":
    case "tick":
      return config.scale.minBandSize;
    case "line":
    case "trail":
    case "rule":
      return config.scale.minStrokeWidth;
    case "text":
      return config.scale.minFontSize;
    case "point":
    case "square":
    case "circle":
      return config.scale.minSize;
  }
  throw new Error(incompatibleChannel("size", mark2));
}
const MAX_SIZE_RANGE_STEP_RATIO = 0.95;
function sizeRangeMax(mark2, size, model, config) {
  const xyStepSignals = {
    x: getBinStepSignal(model, "x"),
    y: getBinStepSignal(model, "y")
  };
  switch (mark2) {
    case "bar":
    case "tick": {
      if (config.scale.maxBandSize !== void 0) {
        return config.scale.maxBandSize;
      }
      const min2 = minXYStep(size, xyStepSignals, config.view);
      if (isNumber$1(min2)) {
        return min2 - 1;
      } else {
        return new SignalRefWrapper(() => `${min2.signal} - 1`);
      }
    }
    case "line":
    case "trail":
    case "rule":
      return config.scale.maxStrokeWidth;
    case "text":
      return config.scale.maxFontSize;
    case "point":
    case "square":
    case "circle": {
      if (config.scale.maxSize) {
        return config.scale.maxSize;
      }
      const pointStep = minXYStep(size, xyStepSignals, config.view);
      if (isNumber$1(pointStep)) {
        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);
      } else {
        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);
      }
    }
  }
  throw new Error(incompatibleChannel("size", mark2));
}
function minXYStep(size, xyStepSignals, viewConfig) {
  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, "width");
  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, "height");
  if (xyStepSignals.x || xyStepSignals.y) {
    return new SignalRefWrapper(() => {
      const exprs = [
        xyStepSignals.x ? xyStepSignals.x.signal : widthStep,
        xyStepSignals.y ? xyStepSignals.y.signal : heightStep
      ];
      return `min(${exprs.join(", ")})`;
    });
  }
  return Math.min(widthStep, heightStep);
}
function parseScaleProperty(model, property2) {
  if (isUnitModel(model)) {
    parseUnitScaleProperty(model, property2);
  } else {
    parseNonUnitScaleProperty(model, property2);
  }
}
function parseUnitScaleProperty(model, property2) {
  const localScaleComponents = model.component.scales;
  const { config, encoding, markDef, specifiedScales } = model;
  for (const channel of keys$1(localScaleComponents)) {
    const specifiedScale = specifiedScales[channel];
    const localScaleCmpt = localScaleComponents[channel];
    const mergedScaleCmpt = model.getScaleComponent(channel);
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    const specifiedValue = specifiedScale[property2];
    const scaleType2 = mergedScaleCmpt.get("type");
    const scalePadding = mergedScaleCmpt.get("padding");
    const scalePaddingInner = mergedScaleCmpt.get("paddingInner");
    const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
    const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
    if (specifiedValue !== void 0) {
      if (!supportedByScaleType) {
        warn(scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
      } else if (channelIncompatability) {
        warn(channelIncompatability);
      }
    }
    if (supportedByScaleType && channelIncompatability === void 0) {
      if (specifiedValue !== void 0) {
        const timeUnit = fieldOrDatumDef["timeUnit"];
        const type2 = fieldOrDatumDef.type;
        switch (property2) {
          // domainMax/Min to signal if the value is a datetime object
          case "domainMax":
          case "domainMin":
            if (isDateTime(specifiedScale[property2]) || type2 === "temporal" || timeUnit) {
              localScaleCmpt.set(property2, { signal: valueExpr(specifiedScale[property2], { type: type2, timeUnit }) }, true);
            } else {
              localScaleCmpt.set(property2, specifiedScale[property2], true);
            }
            break;
          default:
            localScaleCmpt.copyKeyFromObject(property2, specifiedScale);
        }
      } else {
        const value2 = property2 in scaleRules ? scaleRules[property2]({
          model,
          channel,
          fieldOrDatumDef,
          scaleType: scaleType2,
          scalePadding,
          scalePaddingInner,
          domain: specifiedScale.domain,
          domainMin: specifiedScale.domainMin,
          domainMax: specifiedScale.domainMax,
          markDef,
          config,
          hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel)
        }) : config.scale[property2];
        if (value2 !== void 0) {
          localScaleCmpt.set(property2, value2, false);
        }
      }
    }
  }
}
const scaleRules = {
  bins: ({ model, fieldOrDatumDef }) => isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : void 0,
  interpolate: ({ channel, fieldOrDatumDef }) => interpolate(channel, fieldOrDatumDef.type),
  nice: ({ scaleType: scaleType2, channel, domain: domain2, domainMin, domainMax, fieldOrDatumDef }) => nice(scaleType2, channel, domain2, domainMin, domainMax, fieldOrDatumDef),
  padding: ({ channel, scaleType: scaleType2, fieldOrDatumDef, markDef, config }) => padding(channel, scaleType2, config.scale, fieldOrDatumDef, markDef, config.bar),
  paddingInner: ({ scalePadding, channel, markDef, scaleType: scaleType2, config, hasNestedOffsetScale }) => paddingInner(scalePadding, channel, markDef.type, scaleType2, config.scale, hasNestedOffsetScale),
  paddingOuter: ({ scalePadding, channel, scaleType: scaleType2, scalePaddingInner, config, hasNestedOffsetScale }) => paddingOuter(scalePadding, channel, scaleType2, scalePaddingInner, config.scale, hasNestedOffsetScale),
  reverse: ({ fieldOrDatumDef, scaleType: scaleType2, channel, config }) => {
    const sort2 = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0;
    return reverse(scaleType2, sort2, channel, config.scale);
  },
  zero: ({ channel, fieldOrDatumDef, domain: domain2, markDef, scaleType: scaleType2 }) => zero(channel, fieldOrDatumDef, domain2, markDef, scaleType2)
};
function parseScaleRange(model) {
  if (isUnitModel(model)) {
    parseUnitScaleRange(model);
  } else {
    parseNonUnitScaleProperty(model, "range");
  }
}
function parseNonUnitScaleProperty(model, property2) {
  const localScaleComponents = model.component.scales;
  for (const child of model.children) {
    if (property2 === "range") {
      parseScaleRange(child);
    } else {
      parseScaleProperty(child, property2);
    }
  }
  for (const channel of keys$1(localScaleComponents)) {
    let valueWithExplicit;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        const childValueWithExplicit = childComponent.getWithExplicit(property2);
        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property2, "scale", tieBreakByComparing((v1, v2) => {
          switch (property2) {
            case "range":
              if (v1.step && v2.step) {
                return v1.step - v2.step;
              }
              return 0;
          }
          return 0;
        }));
      }
    }
    localScaleComponents[channel].setWithExplicit(property2, valueWithExplicit);
  }
}
function bins(model, fieldDef) {
  const bin2 = fieldDef.bin;
  if (isBinning(bin2)) {
    const binSignal = getBinSignalName(model, fieldDef.field, bin2);
    return new SignalRefWrapper(() => {
      return model.getSignalName(binSignal);
    });
  } else if (isBinned(bin2) && isBinParams(bin2) && bin2.step !== void 0) {
    return {
      step: bin2.step
    };
  }
  return void 0;
}
function interpolate(channel, type2) {
  if (contains([COLOR, FILL, STROKE], channel) && type2 !== "nominal") {
    return "hcl";
  }
  return void 0;
}
function nice(scaleType2, channel, specifiedDomain, domainMin, domainMax, fieldOrDatumDef) {
  var _a;
  if (((_a = getFieldDef(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.bin) || isArray$1(specifiedDomain) || domainMax != null || domainMin != null || contains([ScaleType.TIME, ScaleType.UTC], scaleType2)) {
    return void 0;
  }
  return isXorY(channel) ? true : void 0;
}
function padding(channel, scaleType2, scaleConfig, fieldOrDatumDef, markDef, barConfig) {
  if (isXorY(channel)) {
    if (isContinuousToContinuous(scaleType2)) {
      if (scaleConfig.continuousPadding !== void 0) {
        return scaleConfig.continuousPadding;
      }
      const { type: type2, orient: orient2 } = markDef;
      if (type2 === "bar" && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {
        if (orient2 === "vertical" && channel === "x" || orient2 === "horizontal" && channel === "y") {
          return barConfig.continuousBandSize;
        }
      }
    }
    if (scaleType2 === ScaleType.POINT) {
      return scaleConfig.pointPadding;
    }
  }
  return void 0;
}
function paddingInner(paddingValue, channel, mark2, scaleType2, scaleConfig, hasNestedOffsetScale = false) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (isXorY(channel)) {
    const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner, bandWithNestedOffsetPaddingInner } = scaleConfig;
    if (hasNestedOffsetScale) {
      return bandWithNestedOffsetPaddingInner;
    }
    return getFirstDefined(bandPaddingInner, mark2 === "bar" ? barBandPaddingInner : rectBandPaddingInner);
  } else if (isXorYOffset(channel)) {
    if (scaleType2 === ScaleType.BAND) {
      return scaleConfig.offsetBandPaddingInner;
    }
  }
  return void 0;
}
function paddingOuter(paddingValue, channel, scaleType2, paddingInnerValue, scaleConfig, hasNestedOffsetScale = false) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (isXorY(channel)) {
    const { bandPaddingOuter, bandWithNestedOffsetPaddingOuter } = scaleConfig;
    if (hasNestedOffsetScale) {
      return bandWithNestedOffsetPaddingOuter;
    }
    if (scaleType2 === ScaleType.BAND) {
      return getFirstDefined(
        bandPaddingOuter,
        /* By default, paddingOuter is paddingInner / 2. The reason is that
          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
          and we want the width/height to be integer by default.
          Note that step (by default) and cardinality are integers.) */
        isSignalRef(paddingInnerValue) ? { signal: `${paddingInnerValue.signal}/2` } : paddingInnerValue / 2
      );
    }
  } else if (isXorYOffset(channel)) {
    if (scaleType2 === ScaleType.POINT) {
      return 0.5;
    } else if (scaleType2 === ScaleType.BAND) {
      return scaleConfig.offsetBandPaddingOuter;
    }
  }
  return void 0;
}
function reverse(scaleType2, sort2, channel, scaleConfig) {
  if (channel === "x" && scaleConfig.xReverse !== void 0) {
    if (hasContinuousDomain(scaleType2) && sort2 === "descending") {
      if (isSignalRef(scaleConfig.xReverse)) {
        return { signal: `!${scaleConfig.xReverse.signal}` };
      } else {
        return !scaleConfig.xReverse;
      }
    }
    return scaleConfig.xReverse;
  }
  if (hasContinuousDomain(scaleType2) && sort2 === "descending") {
    return true;
  }
  return void 0;
}
function zero(channel, fieldDef, specifiedDomain, markDef, scaleType2) {
  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== "unaggregated";
  if (hasCustomDomain) {
    if (hasContinuousDomain(scaleType2)) {
      if (isArray$1(specifiedDomain)) {
        const first = specifiedDomain[0];
        const last = specifiedDomain[specifiedDomain.length - 1];
        if (first <= 0 && last >= 0) {
          return true;
        }
      }
      return false;
    }
  }
  if (channel === "size" && fieldDef.type === "quantitative" && !isContinuousToDiscrete(scaleType2)) {
    return true;
  }
  if (!(isFieldDef(fieldDef) && fieldDef.bin) && contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {
    const { orient: orient2, type: type2 } = markDef;
    if (contains(["bar", "area", "line", "trail"], type2)) {
      if (orient2 === "horizontal" && channel === "y" || orient2 === "vertical" && channel === "x") {
        return false;
      }
    }
    return true;
  }
  return false;
}
function scaleType(specifiedScale, channel, fieldDef, mark2, hasNestedOffsetScale = false) {
  const defaultScaleType = defaultType(channel, fieldDef, mark2, hasNestedOffsetScale);
  const { type: type2 } = specifiedScale;
  if (!isScaleChannel(channel)) {
    return null;
  }
  if (type2 !== void 0) {
    if (!channelSupportScaleType(channel, type2)) {
      warn(scaleTypeNotWorkWithChannel(channel, type2, defaultScaleType));
      return defaultScaleType;
    }
    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type2, fieldDef.type)) {
      warn(scaleTypeNotWorkWithFieldDef(type2, defaultScaleType));
      return defaultScaleType;
    }
    return type2;
  }
  return defaultScaleType;
}
function defaultType(channel, fieldDef, mark2, hasNestedOffsetScale) {
  var _a;
  switch (fieldDef.type) {
    case "nominal":
    case "ordinal": {
      if (isColorChannel(channel) || rangeType(channel) === "discrete") {
        if (channel === "shape" && fieldDef.type === "ordinal") {
          warn(discreteChannelCannotEncode(channel, "ordinal"));
        }
        return "ordinal";
      }
      if (isXorY(channel) || isXorYOffset(channel)) {
        if (contains(["rect", "bar", "image", "rule"], mark2.type)) {
          return "band";
        }
        if (hasNestedOffsetScale) {
          return "band";
        }
      } else if (mark2.type === "arc" && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {
        return "band";
      }
      const dimensionSize = mark2[getSizeChannel(channel)];
      if (isRelativeBandSize(dimensionSize)) {
        return "band";
      }
      if (isPositionFieldOrDatumDef(fieldDef) && ((_a = fieldDef.axis) === null || _a === void 0 ? void 0 : _a.tickBand)) {
        return "band";
      }
      return "point";
    }
    case "temporal":
      if (isColorChannel(channel)) {
        return "time";
      } else if (rangeType(channel) === "discrete") {
        warn(discreteChannelCannotEncode(channel, "temporal"));
        return "ordinal";
      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {
        return "utc";
      }
      return "time";
    case "quantitative":
      if (isColorChannel(channel)) {
        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
          return "bin-ordinal";
        }
        return "linear";
      } else if (rangeType(channel) === "discrete") {
        warn(discreteChannelCannotEncode(channel, "quantitative"));
        return "ordinal";
      }
      return "linear";
    case "geojson":
      return void 0;
  }
  throw new Error(invalidFieldType(fieldDef.type));
}
function parseScales(model, { ignoreRange } = {}) {
  parseScaleCore(model);
  parseScaleDomain(model);
  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {
    parseScaleProperty(model, prop);
  }
  if (!ignoreRange) {
    parseScaleRange(model);
  }
}
function parseScaleCore(model) {
  if (isUnitModel(model)) {
    model.component.scales = parseUnitScaleCore(model);
  } else {
    model.component.scales = parseNonUnitScaleCore(model);
  }
}
function parseUnitScaleCore(model) {
  const { encoding, mark: mark2, markDef } = model;
  const scaleComponents = {};
  for (const channel of SCALE_CHANNELS) {
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    if (fieldOrDatumDef && mark2 === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {
      continue;
    }
    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef["scale"];
    if (isXorYOffset(channel)) {
      const mainChannel = getMainChannelFromOffsetChannel(channel);
      if (!channelHasNestedOffsetScale(encoding, mainChannel)) {
        if (specifiedScale) {
          warn(offsetEncodingScaleIgnored(channel));
        }
        continue;
      }
    }
    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {
      specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : specifiedScale = {};
      const hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);
      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);
      scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {
        value: sType,
        explicit: specifiedScale.type === sType
      });
    }
  }
  return scaleComponents;
}
const scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));
function parseNonUnitScaleCore(model) {
  var _a;
  var _b;
  const scaleComponents = model.component.scales = {};
  const scaleTypeWithExplicitIndex = {};
  const resolve2 = model.component.resolve;
  for (const child of model.children) {
    parseScaleCore(child);
    for (const channel of keys$1(child.component.scales)) {
      (_a = (_b = resolve2.scale)[channel]) !== null && _a !== void 0 ? _a : _b[channel] = defaultScaleResolve(channel, model);
      if (resolve2.scale[channel] === "shared") {
        const explicitScaleType = scaleTypeWithExplicitIndex[channel];
        const childScaleType = child.component.scales[channel].getWithExplicit("type");
        if (explicitScaleType) {
          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {
            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, "type", "scale", scaleTypeTieBreaker);
          } else {
            resolve2.scale[channel] = "independent";
            delete scaleTypeWithExplicitIndex[channel];
          }
        } else {
          scaleTypeWithExplicitIndex[channel] = childScaleType;
        }
      }
    }
  }
  for (const channel of keys$1(scaleTypeWithExplicitIndex)) {
    const name = model.scaleName(channel, true);
    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];
    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);
    for (const child of model.children) {
      const childScale = child.component.scales[channel];
      if (childScale) {
        child.renameScale(childScale.get("name"), name);
        childScale.merged = true;
      }
    }
  }
  return scaleComponents;
}
var __rest$6 = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
class NameMap {
  constructor() {
    this.nameMap = {};
  }
  rename(oldName, newName) {
    this.nameMap[oldName] = newName;
  }
  has(name) {
    return this.nameMap[name] !== void 0;
  }
  get(name) {
    while (this.nameMap[name] && name !== this.nameMap[name]) {
      name = this.nameMap[name];
    }
    return name;
  }
}
function isUnitModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "unit";
}
function isFacetModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "facet";
}
function isConcatModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "concat";
}
function isLayerModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "layer";
}
class Model {
  constructor(spec, type2, parent, parentGivenName, config, resolve2, view) {
    var _a, _b;
    this.type = type2;
    this.parent = parent;
    this.config = config;
    this.correctDataNames = (mark2) => {
      var _a2, _b2, _c2;
      if ((_a2 = mark2.from) === null || _a2 === void 0 ? void 0 : _a2.data) {
        mark2.from.data = this.lookupDataSource(mark2.from.data);
      }
      if ((_c2 = (_b2 = mark2.from) === null || _b2 === void 0 ? void 0 : _b2.facet) === null || _c2 === void 0 ? void 0 : _c2.data) {
        mark2.from.facet.data = this.lookupDataSource(mark2.from.facet.data);
      }
      return mark2;
    };
    this.parent = parent;
    this.config = config;
    this.view = replaceExprRef(view);
    this.name = (_a = spec.name) !== null && _a !== void 0 ? _a : parentGivenName;
    this.title = isText(spec.title) ? { text: spec.title } : spec.title ? replaceExprRef(spec.title) : void 0;
    this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();
    this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();
    this.signalNameMap = parent ? parent.signalNameMap : new NameMap();
    this.data = spec.data;
    this.description = spec.description;
    this.transforms = normalizeTransform((_b = spec.transform) !== null && _b !== void 0 ? _b : []);
    this.layout = type2 === "layer" || type2 === "unit" ? {} : extractCompositionLayout(spec, type2, config);
    this.component = {
      data: {
        sources: parent ? parent.component.data.sources : [],
        outputNodes: parent ? parent.component.data.outputNodes : {},
        outputNodeRefCounts: parent ? parent.component.data.outputNodeRefCounts : {},
        // data is faceted if the spec is a facet spec or the parent has faceted data and data is undefined
        isFaceted: isFacetSpec(spec) || (parent === null || parent === void 0 ? void 0 : parent.component.data.isFaceted) && spec.data === void 0
      },
      layoutSize: new Split(),
      layoutHeaders: { row: {}, column: {}, facet: {} },
      mark: null,
      resolve: Object.assign({ scale: {}, axis: {}, legend: {} }, resolve2 ? duplicate(resolve2) : {}),
      selection: null,
      scales: null,
      projection: null,
      axes: {},
      legends: {}
    };
  }
  get width() {
    return this.getSizeSignalRef("width");
  }
  get height() {
    return this.getSizeSignalRef("height");
  }
  parse() {
    this.parseScale();
    this.parseLayoutSize();
    this.renameTopLevelLayoutSizeSignal();
    this.parseSelections();
    this.parseProjection();
    this.parseData();
    this.parseAxesAndHeaders();
    this.parseLegends();
    this.parseMarkGroup();
  }
  parseScale() {
    parseScales(this);
  }
  parseProjection() {
    parseProjection(this);
  }
  /**
   * Rename top-level spec's size to be just width / height, ignoring model name.
   * This essentially merges the top-level spec's width/height signals with the width/height signals
   * to help us reduce redundant signals declaration.
   */
  renameTopLevelLayoutSizeSignal() {
    if (this.getName("width") !== "width") {
      this.renameSignal(this.getName("width"), "width");
    }
    if (this.getName("height") !== "height") {
      this.renameSignal(this.getName("height"), "height");
    }
  }
  parseLegends() {
    parseLegend(this);
  }
  assembleEncodeFromView(view) {
    const { style: _ } = view, baseView = __rest$6(view, ["style"]);
    const e3 = {};
    for (const property2 of keys$1(baseView)) {
      const value2 = baseView[property2];
      if (value2 !== void 0) {
        e3[property2] = signalOrValueRef(value2);
      }
    }
    return e3;
  }
  assembleGroupEncodeEntry(isTopLevel) {
    let encodeEntry2 = {};
    if (this.view) {
      encodeEntry2 = this.assembleEncodeFromView(this.view);
    }
    if (!isTopLevel) {
      if (this.description) {
        encodeEntry2["description"] = signalOrValueRef(this.description);
      }
      if (this.type === "unit" || this.type === "layer") {
        return Object.assign({ width: this.getSizeSignalRef("width"), height: this.getSizeSignalRef("height") }, encodeEntry2 !== null && encodeEntry2 !== void 0 ? encodeEntry2 : {});
      }
    }
    return isEmpty(encodeEntry2) ? void 0 : encodeEntry2;
  }
  assembleLayout() {
    if (!this.layout) {
      return void 0;
    }
    const _a = this.layout, { spacing } = _a, layout = __rest$6(_a, ["spacing"]);
    const { component, config } = this;
    const titleBand = assembleLayoutTitleBand(component.layoutHeaders, config);
    return Object.assign(Object.assign(Object.assign({ padding: spacing }, this.assembleDefaultLayout()), layout), titleBand ? { titleBand } : {});
  }
  assembleDefaultLayout() {
    return {};
  }
  assembleHeaderMarks() {
    const { layoutHeaders: layoutHeaders2 } = this.component;
    let headerMarks = [];
    for (const channel of FACET_CHANNELS) {
      if (layoutHeaders2[channel].title) {
        headerMarks.push(assembleTitleGroup(this, channel));
      }
    }
    for (const channel of HEADER_CHANNELS) {
      headerMarks = headerMarks.concat(assembleHeaderGroups(this, channel));
    }
    return headerMarks;
  }
  assembleAxes() {
    return assembleAxes(this.component.axes, this.config);
  }
  assembleLegends() {
    return assembleLegends(this);
  }
  assembleProjections() {
    return assembleProjections(this);
  }
  assembleTitle() {
    var _a, _b, _c2;
    const _d2 = (_a = this.title) !== null && _a !== void 0 ? _a : {}, { encoding } = _d2, titleNoEncoding = __rest$6(_d2, ["encoding"]);
    const title2 = Object.assign(Object.assign(Object.assign({}, extractTitleConfig(this.config.title).nonMarkTitleProperties), titleNoEncoding), encoding ? { encode: { update: encoding } } : {});
    if (title2.text) {
      if (contains(["unit", "layer"], this.type)) {
        if (contains(["middle", void 0], title2.anchor)) {
          (_b = title2.frame) !== null && _b !== void 0 ? _b : title2.frame = "group";
        }
      } else {
        (_c2 = title2.anchor) !== null && _c2 !== void 0 ? _c2 : title2.anchor = "start";
      }
      return isEmpty(title2) ? void 0 : title2;
    }
    return void 0;
  }
  /**
   * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.
   */
  assembleGroup(signals = []) {
    const group2 = {};
    signals = signals.concat(this.assembleSignals());
    if (signals.length > 0) {
      group2.signals = signals;
    }
    const layout = this.assembleLayout();
    if (layout) {
      group2.layout = layout;
    }
    group2.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
    const scales2 = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];
    if (scales2.length > 0) {
      group2.scales = scales2;
    }
    const axes = this.assembleAxes();
    if (axes.length > 0) {
      group2.axes = axes;
    }
    const legends = this.assembleLegends();
    if (legends.length > 0) {
      group2.legends = legends;
    }
    return group2;
  }
  getName(text2) {
    return varName((this.name ? `${this.name}_` : "") + text2);
  }
  getDataName(type2) {
    return this.getName(DataSourceType[type2].toLowerCase());
  }
  /**
   * Request a data source name for the given data source type and mark that data source as required.
   * This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().
   * You can lookup the correct dataset name in assemble with `lookupDataSource`.
   */
  requestDataName(name) {
    const fullName = this.getDataName(name);
    const refCounts = this.component.data.outputNodeRefCounts;
    refCounts[fullName] = (refCounts[fullName] || 0) + 1;
    return fullName;
  }
  getSizeSignalRef(layoutSizeType) {
    if (isFacetModel(this.parent)) {
      const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
      const channel = getPositionScaleChannel(sizeType);
      const scaleComponent = this.component.scales[channel];
      if (scaleComponent && !scaleComponent.merged) {
        const type2 = scaleComponent.get("type");
        const range2 = scaleComponent.get("range");
        if (hasDiscreteDomain(type2) && isVgRangeStep(range2)) {
          const scaleName = scaleComponent.get("name");
          const domain2 = assembleDomain(this, channel);
          const field2 = getFieldFromDomain(domain2);
          if (field2) {
            const fieldRef2 = vgField({ aggregate: "distinct", field: field2 }, { expr: "datum" });
            return {
              signal: sizeExpr(scaleName, scaleComponent, fieldRef2)
            };
          } else {
            warn(unknownField(channel));
            return null;
          }
        }
      }
    }
    return {
      signal: this.signalNameMap.get(this.getName(layoutSizeType))
    };
  }
  /**
   * Lookup the name of the datasource for an output node. You probably want to call this in assemble.
   */
  lookupDataSource(name) {
    const node2 = this.component.data.outputNodes[name];
    if (!node2) {
      return name;
    }
    return node2.getSource();
  }
  getSignalName(oldSignalName) {
    return this.signalNameMap.get(oldSignalName);
  }
  renameSignal(oldName, newName) {
    this.signalNameMap.rename(oldName, newName);
  }
  renameScale(oldName, newName) {
    this.scaleNameMap.rename(oldName, newName);
  }
  renameProjection(oldName, newName) {
    this.projectionNameMap.rename(oldName, newName);
  }
  /**
   * @return scale name for a given channel after the scale has been parsed and named.
   */
  scaleName(originalScaleName, parse2) {
    if (parse2) {
      return this.getName(originalScaleName);
    }
    if (
      // If there is a scale for the channel, there should be a local scale component for it
      isChannel(originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName] || // in the scale name map (the scale get merged by its parent)
      this.scaleNameMap.has(this.getName(originalScaleName))
    ) {
      return this.scaleNameMap.get(this.getName(originalScaleName));
    }
    return void 0;
  }
  /**
   * @return projection name after the projection has been parsed and named.
   */
  projectionName(parse2) {
    if (parse2) {
      return this.getName("projection");
    }
    if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) {
      return this.projectionNameMap.get(this.getName("projection"));
    }
    return void 0;
  }
  /**
   * Traverse a model's hierarchy to get the scale component for a particular channel.
   */
  getScaleComponent(channel) {
    if (!this.component.scales) {
      throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
    }
    const localScaleComponent = this.component.scales[channel];
    if (localScaleComponent && !localScaleComponent.merged) {
      return localScaleComponent;
    }
    return this.parent ? this.parent.getScaleComponent(channel) : void 0;
  }
  /**
   * Traverse a model's hierarchy to get a particular selection component.
   */
  getSelectionComponent(variableName, origName) {
    let sel = this.component.selection[variableName];
    if (!sel && this.parent) {
      sel = this.parent.getSelectionComponent(variableName, origName);
    }
    if (!sel) {
      throw new Error(selectionNotFound(origName));
    }
    return sel;
  }
  /**
   * Returns true if the model has a signalRef for an axis orient.
   */
  hasAxisOrientSignalRef() {
    var _a, _b;
    return ((_a = this.component.axes.x) === null || _a === void 0 ? void 0 : _a.some((a2) => a2.hasOrientSignalRef())) || ((_b = this.component.axes.y) === null || _b === void 0 ? void 0 : _b.some((a2) => a2.hasOrientSignalRef()));
  }
}
class ModelWithField extends Model {
  /** Get "field" reference for Vega */
  vgField(channel, opt = {}) {
    const fieldDef = this.fieldDef(channel);
    if (!fieldDef) {
      return void 0;
    }
    return vgField(fieldDef, opt);
  }
  reduceFieldDef(f, init2) {
    return reduce(this.getMapping(), (acc, cd, c2) => {
      const fieldDef = getFieldDef(cd);
      if (fieldDef) {
        return f(acc, fieldDef, c2);
      }
      return acc;
    }, init2);
  }
  forEachFieldDef(f, t4) {
    forEach(this.getMapping(), (cd, c2) => {
      const fieldDef = getFieldDef(cd);
      if (fieldDef) {
        f(fieldDef, c2);
      }
    }, t4);
  }
}
var __rest$5 = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
class DensityTransformNode extends DataFlowNode {
  constructor(parent, transform2) {
    var _a, _b, _c2;
    super(parent);
    this.transform = transform2;
    this.transform = duplicate(transform2);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "value", (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : "density"];
    if (transform2.groupby && transform2.minsteps == null && transform2.maxsteps == null && transform2.steps == null) {
      this.transform.steps = 200;
    }
  }
  clone() {
    return new DensityTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.density, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `DensityTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { density } = _a, rest = __rest$5(_a, ["density"]);
    const result = Object.assign({ type: "kde", field: density }, rest);
    return result;
  }
}
class FilterInvalidNode extends DataFlowNode {
  constructor(parent, filter2) {
    super(parent);
    this.filter = filter2;
  }
  clone() {
    return new FilterInvalidNode(null, Object.assign({}, this.filter));
  }
  static make(parent, model) {
    const { config, mark: mark2, markDef } = model;
    const invalid = getMarkPropOrConfig("invalid", markDef, config);
    if (invalid !== "filter") {
      return null;
    }
    const filter2 = model.reduceFieldDef((aggregator, fieldDef, channel) => {
      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);
      if (scaleComponent) {
        const scaleType2 = scaleComponent.get("type");
        if (hasContinuousDomain(scaleType2) && fieldDef.aggregate !== "count" && !isPathMark(mark2)) {
          aggregator[fieldDef.field] = fieldDef;
        }
      }
      return aggregator;
    }, {});
    if (!keys$1(filter2).length) {
      return null;
    }
    return new FilterInvalidNode(parent, filter2);
  }
  dependentFields() {
    return new Set(keys$1(this.filter));
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `FilterInvalid ${hash(this.filter)}`;
  }
  /**
   * Create the VgTransforms for each of the filtered fields.
   */
  assemble() {
    const filters2 = keys$1(this.filter).reduce((vegaFilters, field2) => {
      const fieldDef = this.filter[field2];
      const ref2 = vgField(fieldDef, { expr: "datum" });
      if (fieldDef !== null) {
        if (fieldDef.type === "temporal") {
          vegaFilters.push(`(isDate(${ref2}) || (isValid(${ref2}) && isFinite(+${ref2})))`);
        } else if (fieldDef.type === "quantitative") {
          vegaFilters.push(`isValid(${ref2})`);
          vegaFilters.push(`isFinite(+${ref2})`);
        } else ;
      }
      return vegaFilters;
    }, []);
    return filters2.length > 0 ? {
      type: "filter",
      expr: filters2.join(" && ")
    } : null;
  }
}
class FlattenTransformNode extends DataFlowNode {
  constructor(parent, transform2) {
    super(parent);
    this.transform = transform2;
    this.transform = duplicate(transform2);
    const { flatten: flatten2, as = [] } = this.transform;
    this.transform.as = flatten2.map((f, i) => {
      var _a;
      return (_a = as[i]) !== null && _a !== void 0 ? _a : f;
    });
  }
  clone() {
    return new FlattenTransformNode(this.parent, duplicate(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.flatten);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FlattenTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { flatten: fields, as } = this.transform;
    const result = {
      type: "flatten",
      fields,
      as
    };
    return result;
  }
}
class FoldTransformNode extends DataFlowNode {
  constructor(parent, transform2) {
    var _a, _b, _c2;
    super(parent);
    this.transform = transform2;
    this.transform = duplicate(transform2);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "key", (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : "value"];
  }
  clone() {
    return new FoldTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.fold);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FoldTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { fold, as } = this.transform;
    const result = {
      type: "fold",
      fields: fold,
      as
    };
    return result;
  }
}
class GeoJSONNode extends DataFlowNode {
  constructor(parent, fields, geojson, signal) {
    super(parent);
    this.fields = fields;
    this.geojson = geojson;
    this.signal = signal;
  }
  clone() {
    return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);
  }
  static parseAll(parent, model) {
    if (model.component.projection && !model.component.projection.isFit) {
      return parent;
    }
    let geoJsonCounter = 0;
    for (const coordinates of [
      [LONGITUDE, LATITUDE],
      [LONGITUDE2, LATITUDE2]
    ]) {
      const pair = coordinates.map((channel) => {
        const def2 = getFieldOrDatumDef(model.encoding[channel]);
        return isFieldDef(def2) ? def2.field : isDatumDef(def2) ? { expr: `${def2.datum}` } : isValueDef(def2) ? { expr: `${def2["value"]}` } : void 0;
      });
      if (pair[0] || pair[1]) {
        parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));
      }
    }
    if (model.channelHasField(SHAPE)) {
      const fieldDef = model.typedFieldDef(SHAPE);
      if (fieldDef.type === GEOJSON) {
        parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));
      }
    }
    return parent;
  }
  dependentFields() {
    var _a;
    const fields = ((_a = this.fields) !== null && _a !== void 0 ? _a : []).filter(isString);
    return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...fields]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;
  }
  assemble() {
    return [
      ...this.geojson ? [
        {
          type: "filter",
          expr: `isValid(datum["${this.geojson}"])`
        }
      ] : [],
      Object.assign(Object.assign(Object.assign({ type: "geojson" }, this.fields ? { fields: this.fields } : {}), this.geojson ? { geojson: this.geojson } : {}), { signal: this.signal })
    ];
  }
}
class GeoPointNode extends DataFlowNode {
  constructor(parent, projection2, fields, as) {
    super(parent);
    this.projection = projection2;
    this.fields = fields;
    this.as = as;
  }
  clone() {
    return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));
  }
  static parseAll(parent, model) {
    if (!model.projectionName()) {
      return parent;
    }
    for (const coordinates of [
      [LONGITUDE, LATITUDE],
      [LONGITUDE2, LATITUDE2]
    ]) {
      const pair = coordinates.map((channel) => {
        const def2 = getFieldOrDatumDef(model.encoding[channel]);
        return isFieldDef(def2) ? def2.field : isDatumDef(def2) ? { expr: `${def2.datum}` } : isValueDef(def2) ? { expr: `${def2["value"]}` } : void 0;
      });
      const suffix = coordinates[0] === LONGITUDE2 ? "2" : "";
      if (pair[0] || pair[1]) {
        parent = new GeoPointNode(parent, model.projectionName(), pair, [
          model.getName(`x${suffix}`),
          model.getName(`y${suffix}`)
        ]);
      }
    }
    return parent;
  }
  dependentFields() {
    return new Set(this.fields.filter(isString));
  }
  producedFields() {
    return new Set(this.as);
  }
  hash() {
    return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;
  }
  assemble() {
    return {
      type: "geopoint",
      projection: this.projection,
      fields: this.fields,
      as: this.as
    };
  }
}
class ImputeNode extends DataFlowNode {
  constructor(parent, transform2) {
    super(parent);
    this.transform = transform2;
  }
  clone() {
    return new ImputeNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.impute, this.transform.key, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.impute]);
  }
  processSequence(keyvals) {
    const { start = 0, stop: stop3, step } = keyvals;
    const result = [start, stop3, ...step ? [step] : []].join(",");
    return { signal: `sequence(${result})` };
  }
  static makeFromTransform(parent, imputeTransform) {
    return new ImputeNode(parent, imputeTransform);
  }
  static makeFromEncoding(parent, model) {
    const encoding = model.encoding;
    const xDef = encoding.x;
    const yDef = encoding.y;
    if (isFieldDef(xDef) && isFieldDef(yDef)) {
      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : void 0;
      if (imputedChannel === void 0) {
        return void 0;
      }
      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : void 0;
      const { method: method2, value: value2, frame: frame2, keyvals } = imputedChannel.impute;
      const groupbyFields = pathGroupingFields(model.mark, encoding);
      return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ impute: imputedChannel.field, key: keyChannel.field }, method2 ? { method: method2 } : {}), value2 !== void 0 ? { value: value2 } : {}), frame2 ? { frame: frame2 } : {}), keyvals !== void 0 ? { keyvals } : {}), groupbyFields.length ? { groupby: groupbyFields } : {}));
    }
    return null;
  }
  hash() {
    return `Impute ${hash(this.transform)}`;
  }
  assemble() {
    const { impute, key: key2, keyvals, method: method2, groupby, value: value2, frame: frame2 = [null, null] } = this.transform;
    const imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({ type: "impute", field: impute, key: key2 }, keyvals ? { keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals } : {}), { method: "value" }), groupby ? { groupby } : {}), { value: !method2 || method2 === "value" ? value2 : null });
    if (method2 && method2 !== "value") {
      const deriveNewField = Object.assign({ type: "window", as: [`imputed_${impute}_value`], ops: [method2], fields: [impute], frame: frame2, ignorePeers: false }, groupby ? { groupby } : {});
      const replaceOriginal = {
        type: "formula",
        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,
        as: impute
      };
      return [imputeTransform, deriveNewField, replaceOriginal];
    } else {
      return [imputeTransform];
    }
  }
}
var __rest$4 = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
class LoessTransformNode extends DataFlowNode {
  constructor(parent, transform2) {
    var _a, _b, _c2;
    super(parent);
    this.transform = transform2;
    this.transform = duplicate(transform2);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : transform2.on, (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : transform2.loess];
  }
  clone() {
    return new LoessTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.loess, this.transform.on, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `LoessTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { loess: loess2, on: on2 } = _a, rest = __rest$4(_a, ["loess", "on"]);
    const result = Object.assign({ type: "loess", x: on2, y: loess2 }, rest);
    return result;
  }
}
class LookupNode extends DataFlowNode {
  constructor(parent, transform2, secondary) {
    super(parent);
    this.transform = transform2;
    this.secondary = secondary;
  }
  clone() {
    return new LookupNode(null, duplicate(this.transform), this.secondary);
  }
  static make(parent, model, transform2, counter2) {
    const sources = model.component.data.sources;
    const { from: from2 } = transform2;
    let fromOutputNode = null;
    if (isLookupData(from2)) {
      let fromSource = findSource(from2.data, sources);
      if (!fromSource) {
        fromSource = new SourceNode(from2.data);
        sources.push(fromSource);
      }
      const fromOutputName = model.getName(`lookup_${counter2}`);
      fromOutputNode = new OutputNode(fromSource, fromOutputName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
      model.component.data.outputNodes[fromOutputName] = fromOutputNode;
    } else if (isLookupSelection(from2)) {
      const selName = from2.param;
      transform2 = Object.assign({ as: selName }, transform2);
      let selCmpt;
      try {
        selCmpt = model.getSelectionComponent(varName(selName), selName);
      } catch (e3) {
        throw new Error(cannotLookupVariableParameter(selName));
      }
      fromOutputNode = selCmpt.materialized;
      if (!fromOutputNode) {
        throw new Error(noSameUnitLookup(selName));
      }
    }
    return new LookupNode(parent, transform2, fromOutputNode.getSource());
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.lookup]);
  }
  producedFields() {
    return new Set(this.transform.as ? array$5(this.transform.as) : this.transform.from.fields);
  }
  hash() {
    return `Lookup ${hash({ transform: this.transform, secondary: this.secondary })}`;
  }
  assemble() {
    let foreign;
    if (this.transform.from.fields) {
      foreign = Object.assign({ values: this.transform.from.fields }, this.transform.as ? { as: array$5(this.transform.as) } : {});
    } else {
      let asName = this.transform.as;
      if (!isString(asName)) {
        warn(NO_FIELDS_NEEDS_AS);
        asName = "_lookup";
      }
      foreign = {
        as: [asName]
      };
    }
    return Object.assign(Object.assign({ type: "lookup", from: this.secondary, key: this.transform.from.key, fields: [this.transform.lookup] }, foreign), this.transform.default ? { default: this.transform.default } : {});
  }
}
var __rest$3 = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
class QuantileTransformNode extends DataFlowNode {
  constructor(parent, transform2) {
    var _a, _b, _c2;
    super(parent);
    this.transform = transform2;
    this.transform = duplicate(transform2);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "prob", (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : "value"];
  }
  clone() {
    return new QuantileTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.quantile, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `QuantileTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { quantile: quantile2 } = _a, rest = __rest$3(_a, ["quantile"]);
    const result = Object.assign({ type: "quantile", field: quantile2 }, rest);
    return result;
  }
}
var __rest$2 = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
class RegressionTransformNode extends DataFlowNode {
  constructor(parent, transform2) {
    var _a, _b, _c2;
    super(parent);
    this.transform = transform2;
    this.transform = duplicate(transform2);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : transform2.on, (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : transform2.regression];
  }
  clone() {
    return new RegressionTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.regression, this.transform.on, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `RegressionTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { regression, on: on2 } = _a, rest = __rest$2(_a, ["regression", "on"]);
    const result = Object.assign({ type: "regression", x: on2, y: regression }, rest);
    return result;
  }
}
class PivotTransformNode extends DataFlowNode {
  constructor(parent, transform2) {
    super(parent);
    this.transform = transform2;
  }
  clone() {
    return new PivotTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    var _a;
    this.transform.groupby = unique(((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []).concat(fields), (d) => d);
  }
  producedFields() {
    return void 0;
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.pivot, this.transform.value, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  hash() {
    return `PivotTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { pivot, value: value2, groupby, limit, op } = this.transform;
    return Object.assign(Object.assign(Object.assign({ type: "pivot", field: pivot, value: value2 }, limit !== void 0 ? { limit } : {}), op !== void 0 ? { op } : {}), groupby !== void 0 ? { groupby } : {});
  }
}
class SampleTransformNode extends DataFlowNode {
  constructor(parent, transform2) {
    super(parent);
    this.transform = transform2;
  }
  clone() {
    return new SampleTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `SampleTransform ${hash(this.transform)}`;
  }
  assemble() {
    return {
      type: "sample",
      size: this.transform.sample
    };
  }
}
function makeWalkTree(data2) {
  let datasetIndex = 0;
  function walkTree(node2, dataSource) {
    var _a;
    if (node2 instanceof SourceNode) {
      if (!node2.isGenerator && !isUrlData(node2.data)) {
        data2.push(dataSource);
        const newData = {
          name: null,
          source: dataSource.name,
          transform: []
        };
        dataSource = newData;
      }
    }
    if (node2 instanceof ParseNode) {
      if (node2.parent instanceof SourceNode && !dataSource.source) {
        dataSource.format = Object.assign(Object.assign({}, (_a = dataSource.format) !== null && _a !== void 0 ? _a : {}), { parse: node2.assembleFormatParse() });
        dataSource.transform.push(...node2.assembleTransforms(true));
      } else {
        dataSource.transform.push(...node2.assembleTransforms());
      }
    }
    if (node2 instanceof FacetNode) {
      if (!dataSource.name) {
        dataSource.name = `data_${datasetIndex++}`;
      }
      if (!dataSource.source || dataSource.transform.length > 0) {
        data2.push(dataSource);
        node2.data = dataSource.name;
      } else {
        node2.data = dataSource.source;
      }
      data2.push(...node2.assemble());
      return;
    }
    if (node2 instanceof GraticuleNode || node2 instanceof SequenceNode || node2 instanceof FilterInvalidNode || node2 instanceof FilterNode || node2 instanceof CalculateNode || node2 instanceof GeoPointNode || node2 instanceof AggregateNode || node2 instanceof LookupNode || node2 instanceof WindowTransformNode || node2 instanceof JoinAggregateTransformNode || node2 instanceof FoldTransformNode || node2 instanceof FlattenTransformNode || node2 instanceof DensityTransformNode || node2 instanceof LoessTransformNode || node2 instanceof QuantileTransformNode || node2 instanceof RegressionTransformNode || node2 instanceof IdentifierNode || node2 instanceof SampleTransformNode || node2 instanceof PivotTransformNode) {
      dataSource.transform.push(node2.assemble());
    }
    if (node2 instanceof BinNode || node2 instanceof TimeUnitNode || node2 instanceof ImputeNode || node2 instanceof StackNode || node2 instanceof GeoJSONNode) {
      dataSource.transform.push(...node2.assemble());
    }
    if (node2 instanceof OutputNode) {
      if (dataSource.source && dataSource.transform.length === 0) {
        node2.setSource(dataSource.source);
      } else if (node2.parent instanceof OutputNode) {
        node2.setSource(dataSource.name);
      } else {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        node2.setSource(dataSource.name);
        if (node2.numChildren() === 1) {
          data2.push(dataSource);
          const newData = {
            name: null,
            source: dataSource.name,
            transform: []
          };
          dataSource = newData;
        }
      }
    }
    switch (node2.numChildren()) {
      case 0:
        if (node2 instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {
          data2.push(dataSource);
        }
        break;
      case 1:
        walkTree(node2.children[0], dataSource);
        break;
      default: {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        let source2 = dataSource.name;
        if (!dataSource.source || dataSource.transform.length > 0) {
          data2.push(dataSource);
        } else {
          source2 = dataSource.source;
        }
        for (const child of node2.children) {
          const newData = {
            name: null,
            source: source2,
            transform: []
          };
          walkTree(child, newData);
        }
        break;
      }
    }
  }
  return walkTree;
}
function assembleFacetData(root2) {
  const data2 = [];
  const walkTree = makeWalkTree(data2);
  for (const child of root2.children) {
    walkTree(child, {
      source: root2.name,
      name: null,
      transform: []
    });
  }
  return data2;
}
function assembleRootData(dataComponent, datasets) {
  var _a, _b;
  const data2 = [];
  const walkTree = makeWalkTree(data2);
  let sourceIndex = 0;
  for (const root2 of dataComponent.sources) {
    if (!root2.hasName()) {
      root2.dataName = `source_${sourceIndex++}`;
    }
    const newData = root2.assemble();
    walkTree(root2, newData);
  }
  for (const d of data2) {
    if (d.transform.length === 0) {
      delete d.transform;
    }
  }
  let whereTo = 0;
  for (const [i, d] of data2.entries()) {
    if (((_a = d.transform) !== null && _a !== void 0 ? _a : []).length === 0 && !d.source) {
      data2.splice(whereTo++, 0, data2.splice(i, 1)[0]);
    }
  }
  for (const d of data2) {
    for (const t4 of (_b = d.transform) !== null && _b !== void 0 ? _b : []) {
      if (t4.type === "lookup") {
        t4.from = dataComponent.outputNodes[t4.from].getSource();
      }
    }
  }
  for (const d of data2) {
    if (d.name in datasets) {
      d.values = datasets[d.name];
    }
  }
  return data2;
}
function getHeaderType(orient2) {
  if (orient2 === "top" || orient2 === "left" || isSignalRef(orient2)) {
    return "header";
  }
  return "footer";
}
function parseFacetHeaders(model) {
  for (const channel of FACET_CHANNELS) {
    parseFacetHeader(model, channel);
  }
  mergeChildAxis(model, "x");
  mergeChildAxis(model, "y");
}
function parseFacetHeader(model, channel) {
  var _a;
  const { facet, config, child, component } = model;
  if (model.channelHasField(channel)) {
    const fieldDef = facet[channel];
    const titleConfig = getHeaderProperty("title", null, config, channel);
    let title$1 = title(fieldDef, config, {
      allowDisabling: true,
      includeDefault: titleConfig === void 0 || !!titleConfig
    });
    if (child.component.layoutHeaders[channel].title) {
      title$1 = isArray$1(title$1) ? title$1.join(", ") : title$1;
      title$1 += ` / ${child.component.layoutHeaders[channel].title}`;
      child.component.layoutHeaders[channel].title = null;
    }
    const labelOrient = getHeaderProperty("labelOrient", fieldDef.header, config, channel);
    const labels2 = fieldDef.header !== null ? getFirstDefined((_a = fieldDef.header) === null || _a === void 0 ? void 0 : _a.labels, config.header.labels, true) : false;
    const headerType = contains(["bottom", "right"], labelOrient) ? "footer" : "header";
    component.layoutHeaders[channel] = {
      title: fieldDef.header !== null ? title$1 : null,
      facetFieldDef: fieldDef,
      [headerType]: channel === "facet" ? [] : [makeHeaderComponent(model, channel, labels2)]
    };
  }
}
function makeHeaderComponent(model, channel, labels2) {
  const sizeType = channel === "row" ? "height" : "width";
  return {
    labels: labels2,
    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : void 0,
    axes: []
  };
}
function mergeChildAxis(model, channel) {
  var _a;
  const { child } = model;
  if (child.component.axes[channel]) {
    const { layoutHeaders: layoutHeaders2, resolve: resolve2 } = model.component;
    resolve2.axis[channel] = parseGuideResolve(resolve2, channel);
    if (resolve2.axis[channel] === "shared") {
      const headerChannel = channel === "x" ? "column" : "row";
      const layoutHeader = layoutHeaders2[headerChannel];
      for (const axisComponent of child.component.axes[channel]) {
        const headerType = getHeaderType(axisComponent.get("orient"));
        (_a = layoutHeader[headerType]) !== null && _a !== void 0 ? _a : layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)];
        const mainAxis = assembleAxis(axisComponent, "main", model.config, { header: true });
        if (mainAxis) {
          layoutHeader[headerType][0].axes.push(mainAxis);
        }
        axisComponent.mainExtracted = true;
      }
    }
  }
}
function parseLayerLayoutSize(model) {
  parseChildrenLayoutSize(model);
  parseNonUnitLayoutSizeForChannel(model, "width");
  parseNonUnitLayoutSizeForChannel(model, "height");
}
function parseConcatLayoutSize(model) {
  parseChildrenLayoutSize(model);
  const widthType = model.layout.columns === 1 ? "width" : "childWidth";
  const heightType = model.layout.columns === void 0 ? "height" : "childHeight";
  parseNonUnitLayoutSizeForChannel(model, widthType);
  parseNonUnitLayoutSizeForChannel(model, heightType);
}
function parseChildrenLayoutSize(model) {
  for (const child of model.children) {
    child.parseLayoutSize();
  }
}
function parseNonUnitLayoutSizeForChannel(model, layoutSizeType) {
  var _a;
  const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
  const channel = getPositionScaleChannel(sizeType);
  const resolve2 = model.component.resolve;
  const layoutSizeCmpt = model.component.layoutSize;
  let mergedSize;
  for (const child of model.children) {
    const childSize = child.component.layoutSize.getWithExplicit(sizeType);
    const scaleResolve = (_a = resolve2.scale[channel]) !== null && _a !== void 0 ? _a : defaultScaleResolve(channel, model);
    if (scaleResolve === "independent" && childSize.value === "step") {
      mergedSize = void 0;
      break;
    }
    if (mergedSize) {
      if (scaleResolve === "independent" && mergedSize.value !== childSize.value) {
        mergedSize = void 0;
        break;
      }
      mergedSize = mergeValuesWithExplicit(mergedSize, childSize, sizeType, "");
    } else {
      mergedSize = childSize;
    }
  }
  if (mergedSize) {
    for (const child of model.children) {
      model.renameSignal(child.getName(sizeType), model.getName(layoutSizeType));
      child.component.layoutSize.set(sizeType, "merged", false);
    }
    layoutSizeCmpt.setWithExplicit(layoutSizeType, mergedSize);
  } else {
    layoutSizeCmpt.setWithExplicit(layoutSizeType, {
      explicit: false,
      value: void 0
    });
  }
}
function parseUnitLayoutSize(model) {
  const { size, component } = model;
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (size[sizeType]) {
      const specifiedSize = size[sizeType];
      component.layoutSize.set(sizeType, isStep(specifiedSize) ? "step" : specifiedSize, true);
    } else {
      const defaultSize2 = defaultUnitSize(model, sizeType);
      component.layoutSize.set(sizeType, defaultSize2, false);
    }
  }
}
function defaultUnitSize(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const config = model.config;
  const scaleComponent = model.getScaleComponent(channel);
  if (scaleComponent) {
    const scaleType2 = scaleComponent.get("type");
    const range2 = scaleComponent.get("range");
    if (hasDiscreteDomain(scaleType2)) {
      const size = getViewConfigDiscreteSize(config.view, sizeType);
      if (isVgRangeStep(range2) || isStep(size)) {
        return "step";
      } else {
        return size;
      }
    } else {
      return getViewConfigContinuousSize(config.view, sizeType);
    }
  } else if (model.hasProjection || model.mark === "arc") {
    return getViewConfigContinuousSize(config.view, sizeType);
  } else {
    const size = getViewConfigDiscreteSize(config.view, sizeType);
    return isStep(size) ? size.step : size;
  }
}
function facetSortFieldName(fieldDef, sort2, opt) {
  return vgField(sort2, Object.assign({ suffix: `by_${vgField(fieldDef)}` }, opt !== null && opt !== void 0 ? opt : {}));
}
class FacetModel extends ModelWithField {
  constructor(spec, parent, parentGivenName, config) {
    super(spec, "facet", parent, parentGivenName, config, spec.resolve);
    this.child = buildModel(spec.spec, this, this.getName("child"), void 0, config);
    this.children = [this.child];
    this.facet = this.initFacet(spec.facet);
  }
  initFacet(facet) {
    if (!isFacetMapping(facet)) {
      return { facet: this.initFacetFieldDef(facet, "facet") };
    }
    const channels = keys$1(facet);
    const normalizedFacet = {};
    for (const channel of channels) {
      if (![ROW, COLUMN].includes(channel)) {
        warn(incompatibleChannel(channel, "facet"));
        break;
      }
      const fieldDef = facet[channel];
      if (fieldDef.field === void 0) {
        warn(emptyFieldDef(fieldDef, channel));
        break;
      }
      normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);
    }
    return normalizedFacet;
  }
  initFacetFieldDef(fieldDef, channel) {
    const facetFieldDef = initFieldDef(fieldDef, channel);
    if (facetFieldDef.header) {
      facetFieldDef.header = replaceExprRef(facetFieldDef.header);
    } else if (facetFieldDef.header === null) {
      facetFieldDef.header = null;
    }
    return facetFieldDef;
  }
  channelHasField(channel) {
    return !!this.facet[channel];
  }
  fieldDef(channel) {
    return this.facet[channel];
  }
  parseData() {
    this.component.data = parseData(this);
    this.child.parseData();
  }
  parseLayoutSize() {
    parseChildrenLayoutSize(this);
  }
  parseSelections() {
    this.child.parseSelections();
    this.component.selection = this.child.component.selection;
  }
  parseMarkGroup() {
    this.child.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    this.child.parseAxesAndHeaders();
    parseFacetHeaders(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.child.assembleSelectionTopLevelSignals(signals);
  }
  assembleSignals() {
    this.child.assembleSignals();
    return [];
  }
  assembleSelectionData(data2) {
    return this.child.assembleSelectionData(data2);
  }
  getHeaderLayoutMixins() {
    var _a, _b, _c2;
    const layoutMixins = {};
    for (const channel of FACET_CHANNELS) {
      for (const headerType of HEADER_TYPES) {
        const layoutHeaderComponent = this.component.layoutHeaders[channel];
        const headerComponent = layoutHeaderComponent[headerType];
        const { facetFieldDef } = layoutHeaderComponent;
        if (facetFieldDef) {
          const titleOrient = getHeaderProperty("titleOrient", facetFieldDef.header, this.config, channel);
          if (["right", "bottom"].includes(titleOrient)) {
            const headerChannel = getHeaderChannel(channel, titleOrient);
            (_a = layoutMixins.titleAnchor) !== null && _a !== void 0 ? _a : layoutMixins.titleAnchor = {};
            layoutMixins.titleAnchor[headerChannel] = "end";
          }
        }
        if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {
          const sizeType = channel === "row" ? "height" : "width";
          const bandType = headerType === "header" ? "headerBand" : "footerBand";
          if (channel !== "facet" && !this.child.component.layoutSize.get(sizeType)) {
            (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : layoutMixins[bandType] = {};
            layoutMixins[bandType][channel] = 0.5;
          }
          if (layoutHeaderComponent.title) {
            (_c2 = layoutMixins.offset) !== null && _c2 !== void 0 ? _c2 : layoutMixins.offset = {};
            layoutMixins.offset[channel === "row" ? "rowTitle" : "columnTitle"] = 10;
          }
        }
      }
    }
    return layoutMixins;
  }
  assembleDefaultLayout() {
    const { column: column2, row } = this.facet;
    const columns = column2 ? this.columnDistinctSignal() : row ? 1 : void 0;
    let align2 = "all";
    if (!row && this.component.resolve.scale.x === "independent") {
      align2 = "none";
    } else if (!column2 && this.component.resolve.scale.y === "independent") {
      align2 = "none";
    }
    return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), columns ? { columns } : {}), { bounds: "full", align: align2 });
  }
  assembleLayoutSignals() {
    return this.child.assembleLayoutSignals();
  }
  columnDistinctSignal() {
    if (this.parent && this.parent instanceof FacetModel) {
      return void 0;
    } else {
      const facetLayoutDataName = this.getName("column_domain");
      return { signal: `length(data('${facetLayoutDataName}'))` };
    }
  }
  assembleGroupStyle() {
    return void 0;
  }
  assembleGroup(signals) {
    if (this.parent && this.parent instanceof FacetModel) {
      return Object.assign(Object.assign({}, this.channelHasField("column") ? {
        encode: {
          update: {
            // TODO(https://github.com/vega/vega-lite/issues/2759):
            // Correct the signal for facet of concat of facet_column
            columns: { field: vgField(this.facet.column, { prefix: "distinct" }) }
          }
        }
      } : {}), super.assembleGroup(signals));
    }
    return super.assembleGroup(signals);
  }
  /**
   * Aggregate cardinality for calculating size
   */
  getCardinalityAggregateForChild() {
    const fields = [];
    const ops2 = [];
    const as = [];
    if (this.child instanceof FacetModel) {
      if (this.child.channelHasField("column")) {
        const field2 = vgField(this.child.facet.column);
        fields.push(field2);
        ops2.push("distinct");
        as.push(`distinct_${field2}`);
      }
    } else {
      for (const channel of POSITION_SCALE_CHANNELS) {
        const childScaleComponent = this.child.component.scales[channel];
        if (childScaleComponent && !childScaleComponent.merged) {
          const type2 = childScaleComponent.get("type");
          const range2 = childScaleComponent.get("range");
          if (hasDiscreteDomain(type2) && isVgRangeStep(range2)) {
            const domain2 = assembleDomain(this.child, channel);
            const field2 = getFieldFromDomain(domain2);
            if (field2) {
              fields.push(field2);
              ops2.push("distinct");
              as.push(`distinct_${field2}`);
            } else {
              warn(unknownField(channel));
            }
          }
        }
      }
    }
    return { fields, ops: ops2, as };
  }
  assembleFacet() {
    const { name, data: data2 } = this.component.data.facetRoot;
    const { row, column: column2 } = this.facet;
    const { fields, ops: ops2, as } = this.getCardinalityAggregateForChild();
    const groupby = [];
    for (const channel of FACET_CHANNELS) {
      const fieldDef = this.facet[channel];
      if (fieldDef) {
        groupby.push(vgField(fieldDef));
        const { bin: bin2, sort: sort2 } = fieldDef;
        if (isBinning(bin2)) {
          groupby.push(vgField(fieldDef, { binSuffix: "end" }));
        }
        if (isSortField(sort2)) {
          const { field: field2, op = DEFAULT_SORT_OP } = sort2;
          const outputName = facetSortFieldName(fieldDef, sort2);
          if (row && column2) {
            fields.push(outputName);
            ops2.push("max");
            as.push(outputName);
          } else {
            fields.push(field2);
            ops2.push(op);
            as.push(outputName);
          }
        } else if (isArray$1(sort2)) {
          const outputName = sortArrayIndexField(fieldDef, channel);
          fields.push(outputName);
          ops2.push("max");
          as.push(outputName);
        }
      }
    }
    const cross2 = !!row && !!column2;
    return Object.assign({
      name,
      data: data2,
      groupby
    }, cross2 || fields.length > 0 ? {
      aggregate: Object.assign(Object.assign({}, cross2 ? { cross: cross2 } : {}), fields.length ? { fields, ops: ops2, as } : {})
    } : {});
  }
  facetSortFields(channel) {
    const { facet } = this;
    const fieldDef = facet[channel];
    if (fieldDef) {
      if (isSortField(fieldDef.sort)) {
        return [facetSortFieldName(fieldDef, fieldDef.sort, { expr: "datum" })];
      } else if (isArray$1(fieldDef.sort)) {
        return [sortArrayIndexField(fieldDef, channel, { expr: "datum" })];
      }
      return [vgField(fieldDef, { expr: "datum" })];
    }
    return [];
  }
  facetSortOrder(channel) {
    const { facet } = this;
    const fieldDef = facet[channel];
    if (fieldDef) {
      const { sort: sort2 } = fieldDef;
      const order = (isSortField(sort2) ? sort2.order : !isArray$1(sort2) && sort2) || "ascending";
      return [order];
    }
    return [];
  }
  assembleLabelTitle() {
    var _a;
    const { facet, config } = this;
    if (facet.facet) {
      return assembleLabelTitle(facet.facet, "facet", config);
    }
    const ORTHOGONAL_ORIENT = {
      row: ["top", "bottom"],
      column: ["left", "right"]
    };
    for (const channel of HEADER_CHANNELS) {
      if (facet[channel]) {
        const labelOrient = getHeaderProperty("labelOrient", (_a = facet[channel]) === null || _a === void 0 ? void 0 : _a.header, config, channel);
        if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {
          return assembleLabelTitle(facet[channel], channel, config);
        }
      }
    }
    return void 0;
  }
  assembleMarks() {
    const { child } = this;
    const facetRoot = this.component.data.facetRoot;
    const data2 = assembleFacetData(facetRoot);
    const encodeEntry2 = child.assembleGroupEncodeEntry(false);
    const title2 = this.assembleLabelTitle() || child.assembleTitle();
    const style2 = child.assembleGroupStyle();
    const markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: this.getName("cell"), type: "group" }, title2 ? { title: title2 } : {}), style2 ? { style: style2 } : {}), {
      from: {
        facet: this.assembleFacet()
      },
      // TODO: move this to after data
      sort: {
        field: FACET_CHANNELS.map((c2) => this.facetSortFields(c2)).flat(),
        order: FACET_CHANNELS.map((c2) => this.facetSortOrder(c2)).flat()
      }
    }), data2.length > 0 ? { data: data2 } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), child.assembleGroup(assembleFacetSignals(this, [])));
    return [markGroup];
  }
  getMapping() {
    return this.facet;
  }
}
function makeJoinAggregateFromFacet(parent, facet) {
  const { row, column: column2 } = facet;
  if (row && column2) {
    let newParent = null;
    for (const fieldDef of [row, column2]) {
      if (isSortField(fieldDef.sort)) {
        const { field: field2, op = DEFAULT_SORT_OP } = fieldDef.sort;
        parent = newParent = new JoinAggregateTransformNode(parent, {
          joinaggregate: [
            {
              op,
              field: field2,
              as: facetSortFieldName(fieldDef, fieldDef.sort, { forAs: true })
            }
          ],
          groupby: [vgField(fieldDef)]
        });
      }
    }
    return newParent;
  }
  return null;
}
function findSource(data2, sources) {
  var _a, _b, _c2, _d2;
  for (const other of sources) {
    const otherData = other.data;
    if (data2.name && other.hasName() && data2.name !== other.dataName) {
      continue;
    }
    const formatMesh = (_a = data2["format"]) === null || _a === void 0 ? void 0 : _a.mesh;
    const otherFeature = (_b = otherData.format) === null || _b === void 0 ? void 0 : _b.feature;
    if (formatMesh && otherFeature) {
      continue;
    }
    const formatFeature = (_c2 = data2["format"]) === null || _c2 === void 0 ? void 0 : _c2.feature;
    if ((formatFeature || otherFeature) && formatFeature !== otherFeature) {
      continue;
    }
    const otherMesh = (_d2 = otherData.format) === null || _d2 === void 0 ? void 0 : _d2.mesh;
    if ((formatMesh || otherMesh) && formatMesh !== otherMesh) {
      continue;
    }
    if (isInlineData(data2) && isInlineData(otherData)) {
      if (deepEqual(data2.values, otherData.values)) {
        return other;
      }
    } else if (isUrlData(data2) && isUrlData(otherData)) {
      if (data2.url === otherData.url) {
        return other;
      }
    } else if (isNamedData(data2)) {
      if (data2.name === other.dataName) {
        return other;
      }
    }
  }
  return null;
}
function parseRoot(model, sources) {
  if (model.data || !model.parent) {
    if (model.data === null) {
      const source2 = new SourceNode({ values: [] });
      sources.push(source2);
      return source2;
    }
    const existingSource = findSource(model.data, sources);
    if (existingSource) {
      if (!isGenerator(model.data)) {
        existingSource.data.format = mergeDeep$1({}, model.data.format, existingSource.data.format);
      }
      if (!existingSource.hasName() && model.data.name) {
        existingSource.dataName = model.data.name;
      }
      return existingSource;
    } else {
      const source2 = new SourceNode(model.data);
      sources.push(source2);
      return source2;
    }
  } else {
    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
  }
}
function parseTransformArray(head, model, ancestorParse) {
  var _a, _b;
  let lookupCounter = 0;
  for (const t4 of model.transforms) {
    let derivedType = void 0;
    let transformNode;
    if (isCalculate(t4)) {
      transformNode = head = new CalculateNode(head, t4);
      derivedType = "derived";
    } else if (isFilter(t4)) {
      const implicit2 = getImplicitFromFilterTransform(t4);
      transformNode = head = (_a = ParseNode.makeWithAncestors(head, {}, implicit2, ancestorParse)) !== null && _a !== void 0 ? _a : head;
      head = new FilterNode(head, model, t4.filter);
    } else if (isBin(t4)) {
      transformNode = head = BinNode.makeFromTransform(head, t4, model);
      derivedType = "number";
    } else if (isTimeUnit(t4)) {
      derivedType = "date";
      const parsedAs = ancestorParse.getWithExplicit(t4.field);
      if (parsedAs.value === void 0) {
        head = new ParseNode(head, { [t4.field]: derivedType });
        ancestorParse.set(t4.field, derivedType, false);
      }
      transformNode = head = TimeUnitNode.makeFromTransform(head, t4);
    } else if (isAggregate(t4)) {
      transformNode = head = AggregateNode.makeFromTransform(head, t4);
      derivedType = "number";
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    } else if (isLookup(t4)) {
      transformNode = head = LookupNode.make(head, model, t4, lookupCounter++);
      derivedType = "derived";
    } else if (isWindow(t4)) {
      transformNode = head = new WindowTransformNode(head, t4);
      derivedType = "number";
    } else if (isJoinAggregate(t4)) {
      transformNode = head = new JoinAggregateTransformNode(head, t4);
      derivedType = "number";
    } else if (isStack(t4)) {
      transformNode = head = StackNode.makeFromTransform(head, t4);
      derivedType = "derived";
    } else if (isFold(t4)) {
      transformNode = head = new FoldTransformNode(head, t4);
      derivedType = "derived";
    } else if (isFlatten(t4)) {
      transformNode = head = new FlattenTransformNode(head, t4);
      derivedType = "derived";
    } else if (isPivot(t4)) {
      transformNode = head = new PivotTransformNode(head, t4);
      derivedType = "derived";
    } else if (isSample(t4)) {
      head = new SampleTransformNode(head, t4);
    } else if (isImpute(t4)) {
      transformNode = head = ImputeNode.makeFromTransform(head, t4);
      derivedType = "derived";
    } else if (isDensity(t4)) {
      transformNode = head = new DensityTransformNode(head, t4);
      derivedType = "derived";
    } else if (isQuantile(t4)) {
      transformNode = head = new QuantileTransformNode(head, t4);
      derivedType = "derived";
    } else if (isRegression(t4)) {
      transformNode = head = new RegressionTransformNode(head, t4);
      derivedType = "derived";
    } else if (isLoess(t4)) {
      transformNode = head = new LoessTransformNode(head, t4);
      derivedType = "derived";
    } else {
      warn(invalidTransformIgnored(t4));
      continue;
    }
    if (transformNode && derivedType !== void 0) {
      for (const field2 of (_b = transformNode.producedFields()) !== null && _b !== void 0 ? _b : []) {
        ancestorParse.set(field2, derivedType, false);
      }
    }
  }
  return head;
}
function parseData(model) {
  var _a, _b, _c2, _d2, _e, _f2, _g2, _h, _j, _k2;
  let head = parseRoot(model, model.component.data.sources);
  const { outputNodes, outputNodeRefCounts } = model.component.data;
  const data2 = model.data;
  const newData = data2 && (isGenerator(data2) || isUrlData(data2) || isInlineData(data2));
  const ancestorParse = !newData && model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();
  if (isGenerator(data2)) {
    if (isSequenceGenerator(data2)) {
      head = new SequenceNode(head, data2.sequence);
    } else if (isGraticuleGenerator(data2)) {
      head = new GraticuleNode(head, data2.graticule);
    }
    ancestorParse.parseNothing = true;
  } else if (((_a = data2 === null || data2 === void 0 ? void 0 : data2.format) === null || _a === void 0 ? void 0 : _a.parse) === null) {
    ancestorParse.parseNothing = true;
  }
  head = (_b = ParseNode.makeExplicit(head, model, ancestorParse)) !== null && _b !== void 0 ? _b : head;
  head = new IdentifierNode(head);
  const parentIsLayer = model.parent && isLayerModel(model.parent);
  if (isUnitModel(model) || isFacetModel(model)) {
    if (parentIsLayer) {
      head = (_c2 = BinNode.makeFromEncoding(head, model)) !== null && _c2 !== void 0 ? _c2 : head;
    }
  }
  if (model.transforms.length > 0) {
    head = parseTransformArray(head, model, ancestorParse);
  }
  const implicitSelection = getImplicitFromSelection(model);
  const implicitEncoding = getImplicitFromEncoding(model);
  head = (_d2 = ParseNode.makeWithAncestors(head, {}, Object.assign(Object.assign({}, implicitSelection), implicitEncoding), ancestorParse)) !== null && _d2 !== void 0 ? _d2 : head;
  if (isUnitModel(model)) {
    head = GeoJSONNode.parseAll(head, model);
    head = GeoPointNode.parseAll(head, model);
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    if (!parentIsLayer) {
      head = (_e = BinNode.makeFromEncoding(head, model)) !== null && _e !== void 0 ? _e : head;
    }
    head = (_f2 = TimeUnitNode.makeFromEncoding(head, model)) !== null && _f2 !== void 0 ? _f2 : head;
    head = CalculateNode.parseAllForSortIndex(head, model);
  }
  const rawName = model.getDataName(DataSourceType.Raw);
  const raw = new OutputNode(head, rawName, DataSourceType.Raw, outputNodeRefCounts);
  outputNodes[rawName] = raw;
  head = raw;
  if (isUnitModel(model)) {
    const agg = AggregateNode.makeFromEncoding(head, model);
    if (agg) {
      head = agg;
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    }
    head = (_g2 = ImputeNode.makeFromEncoding(head, model)) !== null && _g2 !== void 0 ? _g2 : head;
    head = (_h = StackNode.makeFromEncoding(head, model)) !== null && _h !== void 0 ? _h : head;
  }
  if (isUnitModel(model)) {
    head = (_j = FilterInvalidNode.make(head, model)) !== null && _j !== void 0 ? _j : head;
  }
  const mainName = model.getDataName(DataSourceType.Main);
  const main2 = new OutputNode(head, mainName, DataSourceType.Main, outputNodeRefCounts);
  outputNodes[mainName] = main2;
  head = main2;
  if (isUnitModel(model)) {
    materializeSelections(model, main2);
  }
  let facetRoot = null;
  if (isFacetModel(model)) {
    const facetName = model.getName("facet");
    head = (_k2 = makeJoinAggregateFromFacet(head, model.facet)) !== null && _k2 !== void 0 ? _k2 : head;
    facetRoot = new FacetNode(head, model, facetName, main2.getSource());
    outputNodes[facetName] = facetRoot;
  }
  return Object.assign(Object.assign({}, model.component.data), {
    outputNodes,
    outputNodeRefCounts,
    raw,
    main: main2,
    facetRoot,
    ancestorParse
  });
}
class ConcatModel extends Model {
  constructor(spec, parent, parentGivenName, config) {
    var _a, _b, _c2, _d2;
    super(spec, "concat", parent, parentGivenName, config, spec.resolve);
    if (((_b = (_a = spec.resolve) === null || _a === void 0 ? void 0 : _a.axis) === null || _b === void 0 ? void 0 : _b.x) === "shared" || ((_d2 = (_c2 = spec.resolve) === null || _c2 === void 0 ? void 0 : _c2.axis) === null || _d2 === void 0 ? void 0 : _d2.y) === "shared") {
      warn(CONCAT_CANNOT_SHARE_AXIS);
    }
    this.children = this.getChildren(spec).map((child, i) => {
      return buildModel(child, this, this.getName(`concat_${i}`), void 0, config);
    });
  }
  parseData() {
    this.component.data = parseData(this);
    for (const child of this.children) {
      child.parseData();
    }
  }
  parseSelections() {
    this.component.selection = {};
    for (const child of this.children) {
      child.parseSelections();
      for (const key2 of keys$1(child.component.selection)) {
        this.component.selection[key2] = child.component.selection[key2];
      }
    }
  }
  parseMarkGroup() {
    for (const child of this.children) {
      child.parseMarkGroup();
    }
  }
  parseAxesAndHeaders() {
    for (const child of this.children) {
      child.parseAxesAndHeaders();
    }
  }
  getChildren(spec) {
    if (isVConcatSpec(spec)) {
      return spec.vconcat;
    } else if (isHConcatSpec(spec)) {
      return spec.hconcat;
    }
    return spec.concat;
  }
  parseLayoutSize() {
    parseConcatLayoutSize(this);
  }
  parseAxisGroup() {
    return null;
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
  }
  assembleSignals() {
    this.children.forEach((child) => child.assembleSignals());
    return [];
  }
  assembleLayoutSignals() {
    const layoutSignals = assembleLayoutSignals(this);
    for (const child of this.children) {
      layoutSignals.push(...child.assembleLayoutSignals());
    }
    return layoutSignals;
  }
  assembleSelectionData(data2) {
    return this.children.reduce((db, child) => child.assembleSelectionData(db), data2);
  }
  assembleMarks() {
    return this.children.map((child) => {
      const title2 = child.assembleTitle();
      const style2 = child.assembleGroupStyle();
      const encodeEntry2 = child.assembleGroupEncodeEntry(false);
      return Object.assign(Object.assign(Object.assign(Object.assign({ type: "group", name: child.getName("group") }, title2 ? { title: title2 } : {}), style2 ? { style: style2 } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), child.assembleGroup());
    });
  }
  assembleGroupStyle() {
    return void 0;
  }
  assembleDefaultLayout() {
    const columns = this.layout.columns;
    return Object.assign(Object.assign({}, columns != null ? { columns } : {}), {
      bounds: "full",
      // Use align each so it can work with multiple plots with different size
      align: "each"
    });
  }
}
function isFalseOrNull(v) {
  return v === false || v === null;
}
const AXIS_COMPONENT_PROPERTIES_INDEX = Object.assign(Object.assign({ disable: 1, gridScale: 1, scale: 1 }, COMMON_AXIS_PROPERTIES_INDEX), { labelExpr: 1, encode: 1 });
const AXIS_COMPONENT_PROPERTIES = keys$1(AXIS_COMPONENT_PROPERTIES_INDEX);
class AxisComponent extends Split {
  constructor(explicit = {}, implicit2 = {}, mainExtracted = false) {
    super();
    this.explicit = explicit;
    this.implicit = implicit2;
    this.mainExtracted = mainExtracted;
  }
  clone() {
    return new AxisComponent(duplicate(this.explicit), duplicate(this.implicit), this.mainExtracted);
  }
  hasAxisPart(part) {
    if (part === "axis") {
      return true;
    }
    if (part === "grid" || part === "title") {
      return !!this.get(part);
    }
    return !isFalseOrNull(this.get(part));
  }
  hasOrientSignalRef() {
    return isSignalRef(this.explicit.orient);
  }
}
function labels(model, channel, specifiedLabelsSpec) {
  var _a;
  const { encoding, config } = model;
  const fieldOrDatumDef = (_a = getFieldOrDatumDef(encoding[channel])) !== null && _a !== void 0 ? _a : getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);
  const axis = model.axis(channel) || {};
  const { format: format2, formatType } = axis;
  if (isCustomFormatType(formatType)) {
    return Object.assign({ text: formatCustomType({
      fieldOrDatumDef,
      field: "datum.value",
      format: format2,
      formatType,
      config
    }) }, specifiedLabelsSpec);
  } else if (format2 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (channelDefType(fieldOrDatumDef) === "quantitative") {
      if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" && config.normalizedNumberFormatType) {
        return Object.assign({ text: formatCustomType({
          fieldOrDatumDef,
          field: "datum.value",
          format: config.normalizedNumberFormat,
          formatType: config.normalizedNumberFormatType,
          config
        }) }, specifiedLabelsSpec);
      } else if (config.numberFormatType) {
        return Object.assign({ text: formatCustomType({
          fieldOrDatumDef,
          field: "datum.value",
          format: config.numberFormat,
          formatType: config.numberFormatType,
          config
        }) }, specifiedLabelsSpec);
      }
    }
    if (channelDefType(fieldOrDatumDef) === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && !fieldOrDatumDef.timeUnit) {
      return Object.assign({ text: formatCustomType({
        fieldOrDatumDef,
        field: "datum.value",
        format: config.timeFormat,
        formatType: config.timeFormatType,
        config
      }) }, specifiedLabelsSpec);
    }
  }
  return specifiedLabelsSpec;
}
function parseUnitAxes(model) {
  return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {
    if (model.component.scales[channel]) {
      axis[channel] = [parseAxis(channel, model)];
    }
    return axis;
  }, {});
}
const OPPOSITE_ORIENT = {
  bottom: "top",
  top: "bottom",
  left: "right",
  right: "left"
};
function parseLayerAxes(model) {
  var _a;
  const { axes, resolve: resolve2 } = model.component;
  const axisCount = { top: 0, bottom: 0, right: 0, left: 0 };
  for (const child of model.children) {
    child.parseAxesAndHeaders();
    for (const channel of keys$1(child.component.axes)) {
      resolve2.axis[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve2.axis[channel] === "shared") {
        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);
        if (!axes[channel]) {
          resolve2.axis[channel] = "independent";
          delete axes[channel];
        }
      }
    }
  }
  for (const channel of POSITION_SCALE_CHANNELS) {
    for (const child of model.children) {
      if (!child.component.axes[channel]) {
        continue;
      }
      if (resolve2.axis[channel] === "independent") {
        axes[channel] = ((_a = axes[channel]) !== null && _a !== void 0 ? _a : []).concat(child.component.axes[channel]);
        for (const axisComponent of child.component.axes[channel]) {
          const { value: orient2, explicit } = axisComponent.getWithExplicit("orient");
          if (isSignalRef(orient2)) {
            continue;
          }
          if (axisCount[orient2] > 0 && !explicit) {
            const oppositeOrient = OPPOSITE_ORIENT[orient2];
            if (axisCount[orient2] > axisCount[oppositeOrient]) {
              axisComponent.set("orient", oppositeOrient, false);
            }
          }
          axisCount[orient2]++;
        }
      }
      delete child.component.axes[channel];
    }
    if (resolve2.axis[channel] === "independent" && axes[channel] && axes[channel].length > 1) {
      for (const axisCmpt of axes[channel]) {
        if (!!axisCmpt.get("grid") && !axisCmpt.explicit.grid) {
          axisCmpt.implicit.grid = false;
        }
      }
    }
  }
}
function mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {
  if (mergedAxisCmpts) {
    if (mergedAxisCmpts.length !== childAxisCmpts.length) {
      return void 0;
    }
    const length2 = mergedAxisCmpts.length;
    for (let i = 0; i < length2; i++) {
      const merged = mergedAxisCmpts[i];
      const child = childAxisCmpts[i];
      if (!!merged !== !!child) {
        return void 0;
      } else if (merged && child) {
        const mergedOrient = merged.getWithExplicit("orient");
        const childOrient = child.getWithExplicit("orient");
        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
          return void 0;
        } else {
          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);
        }
      }
    }
  } else {
    return childAxisCmpts.map((axisComponent) => axisComponent.clone());
  }
  return mergedAxisCmpts;
}
function mergeAxisComponent(merged, child) {
  for (const prop of AXIS_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(
      merged.getWithExplicit(prop),
      child.getWithExplicit(prop),
      prop,
      "axis",
      // Tie breaker function
      (v1, v2) => {
        switch (prop) {
          case "title":
            return mergeTitleComponent(v1, v2);
          case "gridScale":
            return {
              explicit: v1.explicit,
              value: getFirstDefined(v1.value, v2.value)
            };
        }
        return defaultTieBreaker(v1, v2, prop, "axis");
      }
    );
    merged.setWithExplicit(prop, mergedValueWithExplicit);
  }
  return merged;
}
function isExplicit(value2, property2, axis, model, channel) {
  if (property2 === "disable") {
    return axis !== void 0;
  }
  axis = axis || {};
  switch (property2) {
    case "titleAngle":
    case "labelAngle":
      return value2 === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));
    case "values":
      return !!axis.values;
    // specified axis.values is already respected, but may get transformed.
    case "encode":
      return !!axis.encoding || !!axis.labelAngle;
    case "title":
      if (value2 === getFieldDefTitle(model, channel)) {
        return true;
      }
  }
  return value2 === axis[property2];
}
const propsToAlwaysIncludeConfig = /* @__PURE__ */ new Set([
  "grid",
  "translate",
  // the rest are not axis configs in Vega, but are in VL, so we need to set too.
  "format",
  "formatType",
  "orient",
  "labelExpr",
  "tickCount",
  "position",
  "tickMinStep"
]);
function parseAxis(channel, model) {
  var _a, _b, _c2;
  let axis = model.axis(channel);
  const axisComponent = new AxisComponent();
  const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);
  const { mark: mark2, config } = model;
  const orient2 = (axis === null || axis === void 0 ? void 0 : axis.orient) || ((_a = config[channel === "x" ? "axisX" : "axisY"]) === null || _a === void 0 ? void 0 : _a.orient) || ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) || defaultOrient(channel);
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const axisConfigs = getAxisConfigs(channel, scaleType2, orient2, model.config);
  const disable = axis !== void 0 ? !axis : getAxisConfig("disable", config.style, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;
  axisComponent.set("disable", disable, axis !== void 0);
  if (disable) {
    return axisComponent;
  }
  axis = axis || {};
  const labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);
  const ruleParams = {
    fieldOrDatumDef,
    axis,
    channel,
    model,
    scaleType: scaleType2,
    orient: orient2,
    labelAngle,
    mark: mark2,
    config
  };
  for (const property2 of AXIS_COMPONENT_PROPERTIES) {
    const value2 = property2 in axisRules ? axisRules[property2](ruleParams) : isAxisProperty(property2) ? axis[property2] : void 0;
    const hasValue = value2 !== void 0;
    const explicit = isExplicit(value2, property2, axis, model, channel);
    if (hasValue && explicit) {
      axisComponent.set(property2, value2, explicit);
    } else {
      const { configValue = void 0, configFrom = void 0 } = isAxisProperty(property2) && property2 !== "values" ? getAxisConfig(property2, config.style, axis.style, axisConfigs) : {};
      const hasConfigValue = configValue !== void 0;
      if (hasValue && !hasConfigValue) {
        axisComponent.set(property2, value2, explicit);
      } else if (
        // Cases need implicit values
        // 1. Axis config that aren't available in Vega
        !(configFrom === "vgAxisConfig") || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)
        propsToAlwaysIncludeConfig.has(property2) && hasConfigValue || // 3. Conditional axis values and signals
        isConditionalAxisValue(configValue) || isSignalRef(configValue)
      ) {
        axisComponent.set(property2, configValue, false);
      }
    }
  }
  const axisEncoding = (_c2 = axis.encoding) !== null && _c2 !== void 0 ? _c2 : {};
  const axisEncode = AXIS_PARTS.reduce((e3, part) => {
    var _a2;
    if (!axisComponent.hasAxisPart(part)) {
      return e3;
    }
    const axisEncodingPart = guideEncodeEntry((_a2 = axisEncoding[part]) !== null && _a2 !== void 0 ? _a2 : {}, model);
    const value2 = part === "labels" ? labels(model, channel, axisEncodingPart) : axisEncodingPart;
    if (value2 !== void 0 && !isEmpty(value2)) {
      e3[part] = { update: value2 };
    }
    return e3;
  }, {});
  if (!isEmpty(axisEncode)) {
    axisComponent.set("encode", axisEncode, !!axis.encoding || axis.labelAngle !== void 0);
  }
  return axisComponent;
}
function initLayoutSize({ encoding, size }) {
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (isStep(size[sizeType])) {
      if (isContinuousFieldOrDatumDef(encoding[channel])) {
        delete size[sizeType];
        warn(stepDropped(sizeType));
      }
    }
  }
  return size;
}
function initMarkdef(originalMarkDef, encoding, config) {
  const markDef = replaceExprRef(originalMarkDef);
  const specifiedOrient = getMarkPropOrConfig("orient", markDef, config);
  markDef.orient = orient(markDef.type, encoding, specifiedOrient);
  if (specifiedOrient !== void 0 && specifiedOrient !== markDef.orient) {
    warn(orientOverridden(markDef.orient, specifiedOrient));
  }
  if (markDef.type === "bar" && markDef.orient) {
    const cornerRadiusEnd = getMarkPropOrConfig("cornerRadiusEnd", markDef, config);
    if (cornerRadiusEnd !== void 0) {
      const newProps = markDef.orient === "horizontal" && encoding.x2 || markDef.orient === "vertical" && encoding.y2 ? ["cornerRadius"] : BAR_CORNER_RADIUS_INDEX[markDef.orient];
      for (const newProp of newProps) {
        markDef[newProp] = cornerRadiusEnd;
      }
      if (markDef.cornerRadiusEnd !== void 0) {
        delete markDef.cornerRadiusEnd;
      }
    }
  }
  const specifiedOpacity = getMarkPropOrConfig("opacity", markDef, config);
  if (specifiedOpacity === void 0) {
    markDef.opacity = opacity(markDef.type, encoding);
  }
  const specifiedCursor = getMarkPropOrConfig("cursor", markDef, config);
  if (specifiedCursor === void 0) {
    markDef.cursor = cursor(markDef, encoding, config);
  }
  return markDef;
}
function cursor(markDef, encoding, config) {
  if (encoding.href || markDef.href || getMarkPropOrConfig("href", markDef, config)) {
    return "pointer";
  }
  return markDef.cursor;
}
function opacity(mark2, encoding) {
  if (contains([POINT, TICK, CIRCLE, SQUARE], mark2)) {
    if (!isAggregate$1(encoding)) {
      return 0.7;
    }
  }
  return void 0;
}
function defaultFilled(markDef, config, { graticule: graticule2 }) {
  if (graticule2) {
    return false;
  }
  const filledConfig = getMarkConfig("filled", markDef, config);
  const mark2 = markDef.type;
  return getFirstDefined(filledConfig, mark2 !== POINT && mark2 !== LINE && mark2 !== RULE);
}
function orient(mark2, encoding, specifiedOrient) {
  switch (mark2) {
    case POINT:
    case CIRCLE:
    case SQUARE:
    case TEXT:
    case RECT:
    case IMAGE:
      return void 0;
  }
  const { x: x2, y: y2, x2: x22, y2: y22 } = encoding;
  switch (mark2) {
    case BAR:
      if (isFieldDef(x2) && (isBinned(x2.bin) || isFieldDef(y2) && y2.aggregate && !x2.aggregate)) {
        return "vertical";
      }
      if (isFieldDef(y2) && (isBinned(y2.bin) || isFieldDef(x2) && x2.aggregate && !y2.aggregate)) {
        return "horizontal";
      }
      if (y22 || x22) {
        if (specifiedOrient) {
          return specifiedOrient;
        }
        if (!x22) {
          if (isFieldDef(x2) && x2.type === QUANTITATIVE && !isBinning(x2.bin) || isNumericDataDef(x2)) {
            return "horizontal";
          }
        }
        if (!y22) {
          if (isFieldDef(y2) && y2.type === QUANTITATIVE && !isBinning(y2.bin) || isNumericDataDef(y2)) {
            return "vertical";
          }
        }
      }
    // falls through
    case RULE:
      if (x22 && !(isFieldDef(x2) && isBinned(x2.bin)) && y22 && !(isFieldDef(y2) && isBinned(y2.bin))) {
        return void 0;
      }
    // falls through
    case AREA:
      if (y22) {
        if (isFieldDef(y2) && isBinned(y2.bin)) {
          return "horizontal";
        } else {
          return "vertical";
        }
      } else if (x22) {
        if (isFieldDef(x2) && isBinned(x2.bin)) {
          return "vertical";
        } else {
          return "horizontal";
        }
      } else if (mark2 === RULE) {
        if (x2 && !y2) {
          return "vertical";
        } else if (y2 && !x2) {
          return "horizontal";
        }
      }
    // falls through
    case LINE:
    case TICK: {
      const xIsContinuous = isContinuousFieldOrDatumDef(x2);
      const yIsContinuous = isContinuousFieldOrDatumDef(y2);
      if (specifiedOrient) {
        return specifiedOrient;
      } else if (xIsContinuous && !yIsContinuous) {
        return mark2 !== "tick" ? "horizontal" : "vertical";
      } else if (!xIsContinuous && yIsContinuous) {
        return mark2 !== "tick" ? "vertical" : "horizontal";
      } else if (xIsContinuous && yIsContinuous) {
        const xDef = x2;
        const yDef = y2;
        const xIsTemporal = xDef.type === TEMPORAL;
        const yIsTemporal = yDef.type === TEMPORAL;
        if (xIsTemporal && !yIsTemporal) {
          return mark2 !== "tick" ? "vertical" : "horizontal";
        } else if (!xIsTemporal && yIsTemporal) {
          return mark2 !== "tick" ? "horizontal" : "vertical";
        }
        if (!xDef.aggregate && yDef.aggregate) {
          return mark2 !== "tick" ? "vertical" : "horizontal";
        } else if (xDef.aggregate && !yDef.aggregate) {
          return mark2 !== "tick" ? "horizontal" : "vertical";
        }
        return "vertical";
      } else {
        return void 0;
      }
    }
  }
  return "vertical";
}
const arc = {
  vgMark: "arc",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), rectPosition(model, "radius")), rectPosition(model, "theta"));
  }
};
const area = {
  vgMark: "area",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "include",
      size: "ignore",
      theta: "ignore"
    })), pointOrRangePosition("x", model, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: model.markDef.orient === "horizontal"
    })), pointOrRangePosition("y", model, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: model.markDef.orient === "vertical"
    })), defined(model));
  }
};
const bar = {
  vgMark: "rect",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x")), rectPosition(model, "y"));
  }
};
const geoshape = {
  vgMark: "shape",
  encodeEntry: (model) => {
    return Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }));
  },
  postEncodingTransform: (model) => {
    const { encoding } = model;
    const shapeDef = encoding.shape;
    const transform2 = Object.assign({ type: "geoshape", projection: model.projectionName() }, shapeDef && isFieldDef(shapeDef) && shapeDef.type === GEOJSON ? { field: vgField(shapeDef, { expr: "datum" }) } : {});
    return [transform2];
  }
};
const image = {
  vgMark: "image",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "ignore",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x")), rectPosition(model, "y")), text$1(model, "url"));
  }
};
const line = {
  vgMark: "line",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model, {
      vgChannel: "strokeWidth"
      // VL's line size is strokeWidth
    })), defined(model));
  }
};
const trail = {
  vgMark: "trail",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model)), defined(model));
  }
};
function encodeEntry(model, fixedShape) {
  const { config } = model;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
    align: "ignore",
    baseline: "ignore",
    color: "include",
    size: "include",
    orient: "ignore",
    theta: "ignore"
  })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model)), nonPosition("angle", model)), shapeMixins(model, config, fixedShape));
}
function shapeMixins(model, config, fixedShape) {
  if (fixedShape) {
    return { shape: { value: fixedShape } };
  }
  return nonPosition("shape", model);
}
const point = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model);
  }
};
const circle = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model, "circle");
  }
};
const square = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model, "square");
  }
};
const rect = {
  vgMark: "rect",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x")), rectPosition(model, "y"));
  }
};
const rule = {
  vgMark: "rule",
  encodeEntry: (model) => {
    const { markDef } = model;
    const orient2 = markDef.orient;
    if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {
      return {};
    }
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), pointOrRangePosition("x", model, {
      defaultPos: orient2 === "horizontal" ? "zeroOrMax" : "mid",
      defaultPos2: "zeroOrMin",
      range: orient2 !== "vertical"
      // include x2 for horizontal or line segment rule
    })), pointOrRangePosition("y", model, {
      defaultPos: orient2 === "vertical" ? "zeroOrMax" : "mid",
      defaultPos2: "zeroOrMin",
      range: orient2 !== "horizontal"
      // include y2 for vertical or line segment rule
    })), nonPosition("size", model, {
      vgChannel: "strokeWidth"
      // VL's rule size is strokeWidth
    }));
  }
};
const text = {
  vgMark: "text",
  encodeEntry: (model) => {
    const { config, encoding } = model;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "include",
      baseline: "include",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "include"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), text$1(model)), nonPosition("size", model, {
      vgChannel: "fontSize"
      // VL's text size is fontSize
    })), nonPosition("angle", model)), valueIfDefined("align", align(model.markDef, encoding, config))), valueIfDefined("baseline", baseline(model.markDef, encoding, config))), pointPosition("radius", model, { defaultPos: null })), pointPosition("theta", model, { defaultPos: null }));
  }
};
function align(markDef, encoding, config) {
  const a2 = getMarkPropOrConfig("align", markDef, config);
  if (a2 === void 0) {
    return "center";
  }
  return void 0;
}
function baseline(markDef, encoding, config) {
  const b2 = getMarkPropOrConfig("baseline", markDef, config);
  if (b2 === void 0) {
    return "middle";
  }
  return void 0;
}
const tick = {
  vgMark: "rect",
  encodeEntry: (model) => {
    const { config, markDef } = model;
    const orient2 = markDef.orient;
    const vgSizeChannel = orient2 === "horizontal" ? "width" : "height";
    const vgThicknessChannel = orient2 === "horizontal" ? "height" : "width";
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid", vgChannel: "xc" })), pointPosition("y", model, { defaultPos: "mid", vgChannel: "yc" })), nonPosition("size", model, {
      defaultValue: defaultSize(model),
      vgChannel: vgSizeChannel
    })), { [vgThicknessChannel]: signalOrValueRef(getMarkPropOrConfig("thickness", markDef, config)) });
  }
};
function defaultSize(model) {
  var _a;
  const { config, markDef } = model;
  const { orient: orient2 } = markDef;
  const vgSizeChannel = orient2 === "horizontal" ? "width" : "height";
  const scale2 = model.getScaleComponent(orient2 === "horizontal" ? "x" : "y");
  const markPropOrConfig = (_a = getMarkPropOrConfig("size", markDef, config, { vgChannel: vgSizeChannel })) !== null && _a !== void 0 ? _a : config.tick.bandSize;
  if (markPropOrConfig !== void 0) {
    return markPropOrConfig;
  } else {
    const scaleRange = scale2 ? scale2.get("range") : void 0;
    if (scaleRange && isVgRangeStep(scaleRange) && isNumber$1(scaleRange.step)) {
      return scaleRange.step * 3 / 4;
    }
    const defaultViewStep = getViewConfigDiscreteStep(config.view, vgSizeChannel);
    return defaultViewStep * 3 / 4;
  }
}
const markCompiler = {
  arc,
  area,
  bar,
  circle,
  geoshape,
  image,
  line,
  point,
  rect,
  rule,
  square,
  text,
  tick,
  trail
};
function parseMarkGroups(model) {
  if (contains([LINE, AREA, TRAIL], model.mark)) {
    const details = pathGroupingFields(model.mark, model.encoding);
    if (details.length > 0) {
      return getPathGroups(model, details);
    }
  } else if (model.mark === BAR) {
    const hasCornerRadius2 = VG_CORNERRADIUS_CHANNELS.some((prop) => getMarkPropOrConfig(prop, model.markDef, model.config));
    if (model.stack && !model.fieldDef("size") && hasCornerRadius2) {
      return getGroupsForStackedBarWithCornerRadius(model);
    }
  }
  return getMarkGroup(model);
}
const FACETED_PATH_PREFIX = "faceted_path_";
function getPathGroups(model, details) {
  return [
    {
      name: model.getName("pathgroup"),
      type: "group",
      from: {
        facet: {
          name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),
          data: model.requestDataName(DataSourceType.Main),
          groupby: details
        }
      },
      encode: {
        update: {
          width: { field: { group: "width" } },
          height: { field: { group: "height" } }
        }
      },
      // With subfacet for line/area group, need to use faceted data from above.
      marks: getMarkGroup(model, { fromPrefix: FACETED_PATH_PREFIX })
    }
  ];
}
const STACK_GROUP_PREFIX = "stack_group_";
function getGroupsForStackedBarWithCornerRadius(model) {
  var _a;
  const [mark2] = getMarkGroup(model, { fromPrefix: STACK_GROUP_PREFIX });
  const fieldScale = model.scaleName(model.stack.fieldChannel);
  const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt);
  const stackFieldGroup = (func, expr2) => {
    const vgFieldMinMax = [
      stackField({ prefix: "min", suffix: "start", expr: expr2 }),
      stackField({ prefix: "max", suffix: "start", expr: expr2 }),
      stackField({ prefix: "min", suffix: "end", expr: expr2 }),
      stackField({ prefix: "max", suffix: "end", expr: expr2 })
    ];
    return `${func}(${vgFieldMinMax.map((field2) => `scale('${fieldScale}',${field2})`).join(",")})`;
  };
  let groupUpdate;
  let innerGroupUpdate;
  if (model.stack.fieldChannel === "x") {
    groupUpdate = Object.assign(Object.assign({}, pick(mark2.encode.update, ["y", "yc", "y2", "height", ...VG_CORNERRADIUS_CHANNELS])), { x: { signal: stackFieldGroup("min", "datum") }, x2: { signal: stackFieldGroup("max", "datum") }, clip: { value: true } });
    innerGroupUpdate = {
      x: { field: { group: "x" }, mult: -1 },
      height: { field: { group: "height" } }
    };
    mark2.encode.update = Object.assign(Object.assign({}, omit(mark2.encode.update, ["y", "yc", "y2"])), { height: { field: { group: "height" } } });
  } else {
    groupUpdate = Object.assign(Object.assign({}, pick(mark2.encode.update, ["x", "xc", "x2", "width"])), { y: { signal: stackFieldGroup("min", "datum") }, y2: { signal: stackFieldGroup("max", "datum") }, clip: { value: true } });
    innerGroupUpdate = {
      y: { field: { group: "y" }, mult: -1 },
      width: { field: { group: "width" } }
    };
    mark2.encode.update = Object.assign(Object.assign({}, omit(mark2.encode.update, ["x", "xc", "x2"])), { width: { field: { group: "width" } } });
  }
  for (const key2 of VG_CORNERRADIUS_CHANNELS) {
    const configValue = getMarkConfig(key2, model.markDef, model.config);
    if (mark2.encode.update[key2]) {
      groupUpdate[key2] = mark2.encode.update[key2];
      delete mark2.encode.update[key2];
    } else if (configValue) {
      groupUpdate[key2] = signalOrValueRef(configValue);
    }
    if (configValue) {
      mark2.encode.update[key2] = { value: 0 };
    }
  }
  const groupby = [];
  if (((_a = model.stack.groupbyChannels) === null || _a === void 0 ? void 0 : _a.length) > 0) {
    for (const groupbyChannel of model.stack.groupbyChannels) {
      const groupByField = model.fieldDef(groupbyChannel);
      const field2 = vgField(groupByField);
      if (field2) {
        groupby.push(field2);
      }
      if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.bin) || (groupByField === null || groupByField === void 0 ? void 0 : groupByField.timeUnit)) {
        groupby.push(vgField(groupByField, { binSuffix: "end" }));
      }
    }
  }
  const strokeProperties = [
    "stroke",
    "strokeWidth",
    "strokeJoin",
    "strokeCap",
    "strokeDash",
    "strokeDashOffset",
    "strokeMiterLimit",
    "strokeOpacity"
  ];
  groupUpdate = strokeProperties.reduce((encode2, prop) => {
    if (mark2.encode.update[prop]) {
      return Object.assign(Object.assign({}, encode2), { [prop]: mark2.encode.update[prop] });
    } else {
      const configValue = getMarkConfig(prop, model.markDef, model.config);
      if (configValue !== void 0) {
        return Object.assign(Object.assign({}, encode2), { [prop]: signalOrValueRef(configValue) });
      } else {
        return encode2;
      }
    }
  }, groupUpdate);
  if (groupUpdate.stroke) {
    groupUpdate.strokeForeground = { value: true };
    groupUpdate.strokeOffset = { value: 0 };
  }
  return [
    {
      type: "group",
      from: {
        facet: {
          data: model.requestDataName(DataSourceType.Main),
          name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),
          groupby,
          aggregate: {
            fields: [
              stackField({ suffix: "start" }),
              stackField({ suffix: "start" }),
              stackField({ suffix: "end" }),
              stackField({ suffix: "end" })
            ],
            ops: ["min", "max", "min", "max"]
          }
        }
      },
      encode: {
        update: groupUpdate
      },
      marks: [
        {
          type: "group",
          encode: { update: innerGroupUpdate },
          marks: [mark2]
        }
      ]
    }
  ];
}
function getSort(model) {
  var _a;
  const { encoding, stack: stack2, mark: mark2, markDef, config } = model;
  const order = encoding.order;
  if (!isArray$1(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig("order", markDef, config))) {
    return void 0;
  } else if ((isArray$1(order) || isFieldDef(order)) && !stack2) {
    return sortParams(order, { expr: "datum" });
  } else if (isPathMark(mark2)) {
    const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
    const dimensionChannelDef = encoding[dimensionChannel];
    if (isFieldDef(dimensionChannelDef)) {
      const s = dimensionChannelDef.sort;
      if (isArray$1(s)) {
        return {
          field: vgField(dimensionChannelDef, { prefix: dimensionChannel, suffix: "sort_index", expr: "datum" })
        };
      } else if (isSortField(s)) {
        return {
          field: vgField({
            // FIXME: this op might not already exist?
            // FIXME: what if dimensionChannel (x or y) contains custom domain?
            aggregate: isAggregate$1(model.encoding) ? s.op : void 0,
            field: s.field
          }, { expr: "datum" })
        };
      } else if (isSortByEncoding(s)) {
        const fieldDefToSort = model.fieldDef(s.encoding);
        return {
          field: vgField(fieldDefToSort, { expr: "datum" }),
          order: s.order
        };
      } else if (s === null) {
        return void 0;
      } else {
        return {
          field: vgField(dimensionChannelDef, {
            // For stack with imputation, we only have bin_mid
            binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? "mid" : void 0,
            expr: "datum"
          })
        };
      }
    }
    return void 0;
  }
  return void 0;
}
function getMarkGroup(model, opt = { fromPrefix: "" }) {
  const { mark: mark2, markDef, encoding, config } = model;
  const clip2 = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));
  const style2 = getStyles(markDef);
  const key2 = encoding.key;
  const sort2 = getSort(model);
  const interactive2 = interactiveFlag(model);
  const aria2 = getMarkPropOrConfig("aria", markDef, config);
  const postEncodingTransform = markCompiler[mark2].postEncodingTransform ? markCompiler[mark2].postEncodingTransform(model) : null;
  return [
    Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName("marks"), type: markCompiler[mark2].vgMark }, clip2 ? { clip: true } : {}), style2 ? { style: style2 } : {}), key2 ? { key: key2.field } : {}), sort2 ? { sort: sort2 } : {}), interactive2 ? interactive2 : {}), aria2 === false ? { aria: aria2 } : {}), { from: { data: opt.fromPrefix + model.requestDataName(DataSourceType.Main) }, encode: {
      update: markCompiler[mark2].encodeEntry(model)
    } }), postEncodingTransform ? {
      transform: postEncodingTransform
    } : {})
  ];
}
function scaleClip(model) {
  const xScale = model.getScaleComponent("x");
  const yScale = model.getScaleComponent("y");
  return (xScale === null || xScale === void 0 ? void 0 : xScale.get("selectionExtent")) || (yScale === null || yScale === void 0 ? void 0 : yScale.get("selectionExtent")) ? true : void 0;
}
function projectionClip(model) {
  const projection2 = model.component.projection;
  return projection2 && !projection2.isFit ? true : void 0;
}
function interactiveFlag(model) {
  if (!model.component.selection)
    return null;
  const unitCount = keys$1(model.component.selection).length;
  let parentCount = unitCount;
  let parent = model.parent;
  while (parent && parentCount === 0) {
    parentCount = keys$1(parent.component.selection).length;
    parent = parent.parent;
  }
  return parentCount ? {
    interactive: unitCount > 0 || !!model.encoding.tooltip
  } : null;
}
class UnitModel extends ModelWithField {
  constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {
    var _a;
    super(spec, "unit", parent, parentGivenName, config, void 0, isFrameMixins(spec) ? spec.view : void 0);
    this.specifiedScales = {};
    this.specifiedAxes = {};
    this.specifiedLegends = {};
    this.specifiedProjection = {};
    this.selection = [];
    this.children = [];
    const markDef = isMarkDef(spec.mark) ? Object.assign({}, spec.mark) : { type: spec.mark };
    const mark2 = markDef.type;
    if (markDef.filled === void 0) {
      markDef.filled = defaultFilled(markDef, config, {
        graticule: spec.data && isGraticuleGenerator(spec.data)
      });
    }
    const encoding = this.encoding = initEncoding(spec.encoding || {}, mark2, markDef.filled, config);
    this.markDef = initMarkdef(markDef, encoding, config);
    this.size = initLayoutSize({
      encoding,
      size: isFrameMixins(spec) ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? { width: spec.width } : {}), spec.height ? { height: spec.height } : {}) : parentGivenSize
    });
    this.stack = stack(mark2, encoding);
    this.specifiedScales = this.initScales(mark2, encoding);
    this.specifiedAxes = this.initAxes(encoding);
    this.specifiedLegends = this.initLegends(encoding);
    this.specifiedProjection = spec.projection;
    this.selection = ((_a = spec.params) !== null && _a !== void 0 ? _a : []).filter((p) => isSelectionParameter(p));
  }
  get hasProjection() {
    const { encoding } = this;
    const isGeoShapeMark = this.mark === GEOSHAPE;
    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some((channel) => isFieldOrDatumDef(encoding[channel]));
    return isGeoShapeMark || hasGeoPosition;
  }
  /**
   * Return specified Vega-Lite scale domain for a particular channel
   * @param channel
   */
  scaleDomain(channel) {
    const scale2 = this.specifiedScales[channel];
    return scale2 ? scale2.domain : void 0;
  }
  axis(channel) {
    return this.specifiedAxes[channel];
  }
  legend(channel) {
    return this.specifiedLegends[channel];
  }
  initScales(mark2, encoding) {
    return SCALE_CHANNELS.reduce((scales2, channel) => {
      var _a;
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      if (fieldOrDatumDef) {
        scales2[channel] = this.initScale((_a = fieldOrDatumDef.scale) !== null && _a !== void 0 ? _a : {});
      }
      return scales2;
    }, {});
  }
  initScale(scale2) {
    const { domain: domain2, range: range2 } = scale2;
    const scaleInternal = replaceExprRef(scale2);
    if (isArray$1(domain2)) {
      scaleInternal.domain = domain2.map(signalRefOrValue);
    }
    if (isArray$1(range2)) {
      scaleInternal.range = range2.map(signalRefOrValue);
    }
    return scaleInternal;
  }
  initAxes(encoding) {
    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {
      const channelDef = encoding[channel];
      if (isFieldOrDatumDef(channelDef) || channel === X && isFieldOrDatumDef(encoding.x2) || channel === Y && isFieldOrDatumDef(encoding.y2)) {
        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : void 0;
        _axis[channel] = axisSpec ? this.initAxis(Object.assign({}, axisSpec)) : axisSpec;
      }
      return _axis;
    }, {});
  }
  initAxis(axis) {
    const props = keys$1(axis);
    const axisInternal = {};
    for (const prop of props) {
      const val = axis[prop];
      axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);
    }
    return axisInternal;
  }
  initLegends(encoding) {
    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      if (fieldOrDatumDef && supportLegend(channel)) {
        const legend = fieldOrDatumDef.legend;
        _legend[channel] = legend ? replaceExprRef(legend) : legend;
      }
      return _legend;
    }, {});
  }
  parseData() {
    this.component.data = parseData(this);
  }
  parseLayoutSize() {
    parseUnitLayoutSize(this);
  }
  parseSelections() {
    this.component.selection = parseUnitSelection(this, this.selection);
  }
  parseMarkGroup() {
    this.component.mark = parseMarkGroups(this);
  }
  parseAxesAndHeaders() {
    this.component.axes = parseUnitAxes(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return assembleTopLevelSignals(this, signals);
  }
  assembleSignals() {
    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];
  }
  assembleSelectionData(data2) {
    return assembleUnitSelectionData(this, data2);
  }
  assembleLayout() {
    return null;
  }
  assembleLayoutSignals() {
    return assembleLayoutSignals(this);
  }
  assembleMarks() {
    var _a;
    let marks = (_a = this.component.mark) !== null && _a !== void 0 ? _a : [];
    if (!this.parent || !isLayerModel(this.parent)) {
      marks = assembleUnitSelectionMarks(this, marks);
    }
    return marks.map(this.correctDataNames);
  }
  assembleGroupStyle() {
    const { style: style2 } = this.view || {};
    if (style2 !== void 0) {
      return style2;
    }
    if (this.encoding.x || this.encoding.y) {
      return "cell";
    } else {
      return void 0;
    }
  }
  getMapping() {
    return this.encoding;
  }
  get mark() {
    return this.markDef.type;
  }
  channelHasField(channel) {
    return channelHasField(this.encoding, channel);
  }
  fieldDef(channel) {
    const channelDef = this.encoding[channel];
    return getFieldDef(channelDef);
  }
  typedFieldDef(channel) {
    const fieldDef = this.fieldDef(channel);
    if (isTypedFieldDef(fieldDef)) {
      return fieldDef;
    }
    return null;
  }
}
class LayerModel extends Model {
  constructor(spec, parent, parentGivenName, parentGivenSize, config) {
    super(spec, "layer", parent, parentGivenName, config, spec.resolve, spec.view);
    const layoutSize = Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? { width: spec.width } : {}), spec.height ? { height: spec.height } : {});
    this.children = spec.layer.map((layer, i) => {
      if (isLayerSpec(layer)) {
        return new LayerModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
      } else if (isUnitSpec(layer)) {
        return new UnitModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
      }
      throw new Error(invalidSpec(layer));
    });
  }
  parseData() {
    this.component.data = parseData(this);
    for (const child of this.children) {
      child.parseData();
    }
  }
  parseLayoutSize() {
    parseLayerLayoutSize(this);
  }
  parseSelections() {
    this.component.selection = {};
    for (const child of this.children) {
      child.parseSelections();
      for (const key2 of keys$1(child.component.selection)) {
        this.component.selection[key2] = child.component.selection[key2];
      }
    }
  }
  parseMarkGroup() {
    for (const child of this.children) {
      child.parseMarkGroup();
    }
  }
  parseAxesAndHeaders() {
    parseLayerAxes(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
  }
  // TODO: Support same named selections across children.
  assembleSignals() {
    return this.children.reduce((signals, child) => {
      return signals.concat(child.assembleSignals());
    }, assembleAxisSignals(this));
  }
  assembleLayoutSignals() {
    return this.children.reduce((signals, child) => {
      return signals.concat(child.assembleLayoutSignals());
    }, assembleLayoutSignals(this));
  }
  assembleSelectionData(data2) {
    return this.children.reduce((db, child) => child.assembleSelectionData(db), data2);
  }
  assembleGroupStyle() {
    const uniqueStyles = /* @__PURE__ */ new Set();
    for (const child of this.children) {
      for (const style2 of array$5(child.assembleGroupStyle())) {
        uniqueStyles.add(style2);
      }
    }
    const styles = Array.from(uniqueStyles);
    return styles.length > 1 ? styles : styles.length === 1 ? styles[0] : void 0;
  }
  assembleTitle() {
    let title2 = super.assembleTitle();
    if (title2) {
      return title2;
    }
    for (const child of this.children) {
      title2 = child.assembleTitle();
      if (title2) {
        return title2;
      }
    }
    return void 0;
  }
  assembleLayout() {
    return null;
  }
  assembleMarks() {
    return assembleLayerSelectionMarks(this, this.children.flatMap((child) => {
      return child.assembleMarks();
    }));
  }
  assembleLegends() {
    return this.children.reduce((legends, child) => {
      return legends.concat(child.assembleLegends());
    }, assembleLegends(this));
  }
}
function buildModel(spec, parent, parentGivenName, unitSize, config) {
  if (isFacetSpec(spec)) {
    return new FacetModel(spec, parent, parentGivenName, config);
  } else if (isLayerSpec(spec)) {
    return new LayerModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isUnitSpec(spec)) {
    return new UnitModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isAnyConcatSpec(spec)) {
    return new ConcatModel(spec, parent, parentGivenName, config);
  }
  throw new Error(invalidSpec(spec));
}
var __rest$1 = function(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
};
function compile(inputSpec, opt = {}) {
  if (opt.logger) {
    set(opt.logger);
  }
  if (opt.fieldTitle) {
    setTitleFormatter(opt.fieldTitle);
  }
  try {
    const config = initConfig(mergeConfig(opt.config, inputSpec.config));
    const spec = normalize(inputSpec, config);
    const model = buildModel(spec, null, "", void 0, config);
    model.parse();
    optimizeDataflow(model.component.data, model);
    const vgSpec = assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);
    return {
      spec: vgSpec,
      normalized: spec
    };
  } finally {
    if (opt.logger) {
      reset();
    }
    if (opt.fieldTitle) {
      resetTitleFormatter();
    }
  }
}
function getTopLevelProperties(inputSpec, autosize, config, model) {
  const width2 = model.component.layoutSize.get("width");
  const height2 = model.component.layoutSize.get("height");
  if (autosize === void 0) {
    autosize = { type: "pad" };
    if (model.hasAxisOrientSignalRef()) {
      autosize.resize = true;
    }
  } else if (isString(autosize)) {
    autosize = { type: autosize };
  }
  if (width2 && height2 && isFitType(autosize.type)) {
    if (width2 === "step" && height2 === "step") {
      warn(droppingFit());
      autosize.type = "pad";
    } else if (width2 === "step" || height2 === "step") {
      const sizeType = width2 === "step" ? "width" : "height";
      warn(droppingFit(getPositionScaleChannel(sizeType)));
      const inverseSizeType = sizeType === "width" ? "height" : "width";
      autosize.type = getFitType(inverseSizeType);
    }
  }
  return Object.assign(Object.assign(Object.assign({}, keys$1(autosize).length === 1 && autosize.type ? autosize.type === "pad" ? {} : { autosize: autosize.type } : { autosize }), extractTopLevelProperties(config, false)), extractTopLevelProperties(inputSpec, true));
}
function assembleTopLevelModel(model, topLevelProperties, datasets = {}, usermeta) {
  const vgConfig = model.config ? stripAndRedirectConfig(model.config) : void 0;
  const data2 = [].concat(
    model.assembleSelectionData([]),
    // only assemble data in the root
    assembleRootData(model.component.data, datasets)
  );
  const projections2 = model.assembleProjections();
  const title2 = model.assembleTitle();
  const style2 = model.assembleGroupStyle();
  const encodeEntry2 = model.assembleGroupEncodeEntry(true);
  let layoutSignals = model.assembleLayoutSignals();
  layoutSignals = layoutSignals.filter((signal) => {
    if ((signal.name === "width" || signal.name === "height") && signal.value !== void 0) {
      topLevelProperties[signal.name] = +signal.value;
      return false;
    }
    return true;
  });
  const { params: params2 } = topLevelProperties, otherTopLevelProps = __rest$1(topLevelProperties, ["params"]);
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ $schema: "https://vega.github.io/schema/vega/v5.json" }, model.description ? { description: model.description } : {}), otherTopLevelProps), title2 ? { title: title2 } : {}), style2 ? { style: style2 } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), { data: data2 }), projections2.length > 0 ? { projections: projections2 } : {}), model.assembleGroup([
    ...layoutSignals,
    ...model.assembleSelectionTopLevelSignals([]),
    ...assembleParameterSignals(params2)
  ])), vgConfig ? { config: vgConfig } : {}), usermeta ? { usermeta } : {});
}
const version$2 = pkg$1.version;
const vegaLiteImport = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accessPathDepth,
  accessPathWithDatum,
  compile,
  contains,
  deepEqual,
  deleteNestedProperty,
  duplicate,
  entries: entries$1,
  every,
  fieldIntersection,
  flatAccessWithDatum,
  getFirstDefined,
  hasIntersection,
  hash,
  internalField,
  isBoolean,
  isEmpty,
  isEqual,
  isInternalField,
  isNullOrFalse,
  isNumeric,
  keys: keys$1,
  logicalExpr,
  mergeDeep: mergeDeep$1,
  never,
  normalize,
  normalizeAngle,
  omit,
  pick,
  prefixGenerator,
  removePathFromField,
  replaceAll,
  replacePathInField,
  resetIdCounter,
  setEqual,
  some,
  stringify: stringify$1,
  titleCase,
  unique,
  uniqueId,
  vals,
  varName,
  version: version$2
}, Symbol.toStringTag, { value: "Module" }));
function e(e3) {
  const [n, r2] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e3).slice(1, 3);
  return { library: n, version: r2 };
}
var version$1 = "2.10.0";
var pkg = {
  version: version$1
};
const lightColor = "#fff";
const medColor = "#888";
const darkTheme = {
  background: "#333",
  title: {
    color: lightColor,
    subtitleColor: lightColor
  },
  style: {
    "guide-label": {
      fill: lightColor
    },
    "guide-title": {
      fill: lightColor
    }
  },
  axis: {
    domainColor: lightColor,
    gridColor: medColor,
    tickColor: lightColor
  }
};
const markColor$7 = "#4572a7";
const excelTheme = {
  background: "#fff",
  arc: { fill: markColor$7 },
  area: { fill: markColor$7 },
  line: { stroke: markColor$7, strokeWidth: 2 },
  path: { stroke: markColor$7 },
  rect: { fill: markColor$7 },
  shape: { stroke: markColor$7 },
  symbol: { fill: markColor$7, strokeWidth: 1.5, size: 50 },
  axis: {
    bandPosition: 0.5,
    grid: true,
    gridColor: "#000000",
    gridOpacity: 1,
    gridWidth: 0.5,
    labelPadding: 10,
    tickSize: 5,
    tickWidth: 0.5
  },
  axisBand: {
    grid: false,
    tickExtra: true
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 50,
    symbolType: "square"
  },
  range: {
    category: [
      "#4572a7",
      "#aa4643",
      "#8aa453",
      "#71598e",
      "#4598ae",
      "#d98445",
      "#94aace",
      "#d09393",
      "#b9cc98",
      "#a99cbc"
    ]
  }
};
const markColor$6 = "#30a2da";
const axisColor$2 = "#cbcbcb";
const guideLabelColor = "#999";
const guideTitleColor = "#333";
const backgroundColor$2 = "#f0f0f0";
const blackTitle = "#333";
const fiveThirtyEightTheme = {
  arc: { fill: markColor$6 },
  area: { fill: markColor$6 },
  axis: {
    domainColor: axisColor$2,
    grid: true,
    gridColor: axisColor$2,
    gridWidth: 1,
    labelColor: guideLabelColor,
    labelFontSize: 10,
    titleColor: guideTitleColor,
    tickColor: axisColor$2,
    tickSize: 10,
    titleFontSize: 14,
    titlePadding: 10,
    labelPadding: 4
  },
  axisBand: {
    grid: false
  },
  background: backgroundColor$2,
  group: {
    fill: backgroundColor$2
  },
  legend: {
    labelColor: blackTitle,
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square",
    titleColor: blackTitle,
    titleFontSize: 14,
    titlePadding: 10
  },
  line: {
    stroke: markColor$6,
    strokeWidth: 2
  },
  path: { stroke: markColor$6, strokeWidth: 0.5 },
  rect: { fill: markColor$6 },
  range: {
    category: [
      "#30a2da",
      "#fc4f30",
      "#e5ae38",
      "#6d904f",
      "#8b8b8b",
      "#b96db8",
      "#ff9e27",
      "#56cc60",
      "#52d2ca",
      "#52689e",
      "#545454",
      "#9fe4f8"
    ],
    diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
    heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
  },
  point: {
    filled: true,
    shape: "circle"
  },
  shape: { stroke: markColor$6 },
  bar: {
    binSpacing: 2,
    fill: markColor$6,
    stroke: null
  },
  title: {
    anchor: "start",
    fontSize: 24,
    fontWeight: 600,
    offset: 20
  }
};
const markColor$5 = "#000";
const ggplot2Theme = {
  group: {
    fill: "#e5e5e5"
  },
  arc: { fill: markColor$5 },
  area: { fill: markColor$5 },
  line: { stroke: markColor$5 },
  path: { stroke: markColor$5 },
  rect: { fill: markColor$5 },
  shape: { stroke: markColor$5 },
  symbol: { fill: markColor$5, size: 40 },
  axis: {
    domain: false,
    grid: true,
    gridColor: "#FFFFFF",
    gridOpacity: 1,
    labelColor: "#7F7F7F",
    labelPadding: 4,
    tickColor: "#7F7F7F",
    tickSize: 5.67,
    titleFontSize: 16,
    titleFontWeight: "normal"
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 40
  },
  range: {
    category: [
      "#000000",
      "#7F7F7F",
      "#1A1A1A",
      "#999999",
      "#333333",
      "#B0B0B0",
      "#4D4D4D",
      "#C9C9C9",
      "#666666",
      "#DCDCDC"
    ]
  }
};
const headlineFontSize = 22;
const headlineFontWeight = "normal";
const labelFont$1 = "Benton Gothic, sans-serif";
const labelFontSize = 11.5;
const labelFontWeight = "normal";
const markColor$4 = "#82c6df";
const titleFont = "Benton Gothic Bold, sans-serif";
const titleFontWeight = "normal";
const titleFontSize$1 = 13;
const colorSchemes$1 = {
  "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
  "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
  "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"]
};
const latimesTheme = {
  background: "#ffffff",
  title: {
    anchor: "start",
    color: "#000000",
    font: titleFont,
    fontSize: headlineFontSize,
    fontWeight: headlineFontWeight
  },
  arc: { fill: markColor$4 },
  area: { fill: markColor$4 },
  line: { stroke: markColor$4, strokeWidth: 2 },
  path: { stroke: markColor$4 },
  rect: { fill: markColor$4 },
  shape: { stroke: markColor$4 },
  symbol: { fill: markColor$4, size: 30 },
  axis: {
    labelFont: labelFont$1,
    labelFontSize,
    labelFontWeight,
    titleFont,
    titleFontSize: titleFontSize$1,
    titleFontWeight
  },
  axisX: {
    labelAngle: 0,
    labelPadding: 4,
    tickSize: 3
  },
  axisY: {
    labelBaseline: "middle",
    maxExtent: 45,
    minExtent: 45,
    tickSize: 2,
    titleAlign: "left",
    titleAngle: 0,
    titleX: -45,
    titleY: -11
  },
  legend: {
    labelFont: labelFont$1,
    labelFontSize,
    symbolType: "square",
    titleFont,
    titleFontSize: titleFontSize$1,
    titleFontWeight
  },
  range: {
    category: colorSchemes$1["category-6"],
    diverging: colorSchemes$1["fireandice-6"],
    heatmap: colorSchemes$1["fire-7"],
    ordinal: colorSchemes$1["fire-7"],
    ramp: colorSchemes$1["fire-7"]
  }
};
const markColor$3 = "#ab5787";
const axisColor$1 = "#979797";
const quartzTheme = {
  background: "#f9f9f9",
  arc: { fill: markColor$3 },
  area: { fill: markColor$3 },
  line: { stroke: markColor$3 },
  path: { stroke: markColor$3 },
  rect: { fill: markColor$3 },
  shape: { stroke: markColor$3 },
  symbol: { fill: markColor$3, size: 30 },
  axis: {
    domainColor: axisColor$1,
    domainWidth: 0.5,
    gridWidth: 0.2,
    labelColor: axisColor$1,
    tickColor: axisColor$1,
    tickWidth: 0.2,
    titleColor: axisColor$1
  },
  axisBand: {
    grid: false
  },
  axisX: {
    grid: true,
    tickSize: 10
  },
  axisY: {
    domain: false,
    grid: true,
    tickSize: 0
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square"
  },
  range: {
    category: [
      "#ab5787",
      "#51b2e5",
      "#703c5c",
      "#168dd9",
      "#d190b6",
      "#00609f",
      "#d365ba",
      "#154866",
      "#666666",
      "#c4c4c4"
    ]
  }
};
const markColor$2 = "#3e5c69";
const voxTheme = {
  background: "#fff",
  arc: { fill: markColor$2 },
  area: { fill: markColor$2 },
  line: { stroke: markColor$2 },
  path: { stroke: markColor$2 },
  rect: { fill: markColor$2 },
  shape: { stroke: markColor$2 },
  symbol: { fill: markColor$2 },
  axis: {
    domainWidth: 0.5,
    grid: true,
    labelPadding: 2,
    tickSize: 5,
    tickWidth: 0.5,
    titleFontWeight: "normal"
  },
  axisBand: {
    grid: false
  },
  axisX: {
    gridWidth: 0.2
  },
  axisY: {
    gridDash: [3],
    gridWidth: 0.4
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolType: "square"
  },
  range: {
    category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
  }
};
const markColor$1 = "#1696d2";
const axisColor = "#000000";
const backgroundColor$1 = "#FFFFFF";
const font = "Lato";
const labelFont = "Lato";
const sourceFont = "Lato";
const gridColor$1 = "#DEDDDD";
const titleFontSize = 18;
const colorSchemes = {
  "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
  "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
  "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
  "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
};
const urbanInstituteTheme = {
  background: backgroundColor$1,
  title: {
    anchor: "start",
    fontSize: titleFontSize,
    font
  },
  axisX: {
    domain: true,
    domainColor: axisColor,
    domainWidth: 1,
    grid: false,
    labelFontSize: 12,
    labelFont,
    labelAngle: 0,
    tickColor: axisColor,
    tickSize: 5,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font
  },
  axisY: {
    domain: false,
    domainWidth: 1,
    grid: true,
    gridColor: gridColor$1,
    gridWidth: 1,
    labelFontSize: 12,
    labelFont,
    labelPadding: 8,
    ticks: false,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font,
    titleAngle: 0,
    titleY: -10,
    titleX: 18
  },
  legend: {
    labelFontSize: 12,
    labelFont,
    symbolSize: 100,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font,
    orient: "right",
    offset: 10
  },
  view: {
    stroke: "transparent"
  },
  range: {
    category: colorSchemes["six-groups-cat-1"],
    diverging: colorSchemes["diverging-colors"],
    heatmap: colorSchemes["diverging-colors"],
    ordinal: colorSchemes["six-groups-seq"],
    ramp: colorSchemes["shades-blue"]
  },
  area: {
    fill: markColor$1
  },
  rect: {
    fill: markColor$1
  },
  line: {
    color: markColor$1,
    stroke: markColor$1,
    strokeWidth: 5
  },
  trail: {
    color: markColor$1,
    stroke: markColor$1,
    strokeWidth: 0,
    size: 1
  },
  path: {
    stroke: markColor$1,
    strokeWidth: 0.5
  },
  point: {
    filled: true
  },
  text: {
    font: sourceFont,
    color: markColor$1,
    fontSize: 11,
    align: "center",
    fontWeight: 400,
    size: 11
  },
  style: {
    bar: {
      fill: markColor$1,
      stroke: null
    }
  },
  arc: { fill: markColor$1 },
  shape: { stroke: markColor$1 },
  symbol: { fill: markColor$1, size: 30 }
};
const markColor = "#3366CC";
const gridColor = "#ccc";
const defaultFont = "Arial, sans-serif";
const googlechartsTheme = {
  arc: { fill: markColor },
  area: { fill: markColor },
  path: { stroke: markColor },
  rect: { fill: markColor },
  shape: { stroke: markColor },
  symbol: { stroke: markColor },
  circle: { fill: markColor },
  background: "#fff",
  padding: {
    top: 10,
    right: 10,
    bottom: 10,
    left: 10
  },
  style: {
    "guide-label": {
      font: defaultFont,
      fontSize: 12
    },
    "guide-title": {
      font: defaultFont,
      fontSize: 12
    },
    "group-title": {
      font: defaultFont,
      fontSize: 12
    }
  },
  title: {
    font: defaultFont,
    fontSize: 14,
    fontWeight: "bold",
    dy: -3,
    anchor: "start"
  },
  axis: {
    gridColor,
    tickColor: gridColor,
    domain: false,
    grid: true
  },
  range: {
    category: [
      "#4285F4",
      "#DB4437",
      "#F4B400",
      "#0F9D58",
      "#AB47BC",
      "#00ACC1",
      "#FF7043",
      "#9E9D24",
      "#5C6BC0",
      "#F06292",
      "#00796B",
      "#C2185B"
    ],
    heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
  }
};
const ptToPx = (value2) => value2 * (1 / 3 + 1);
const fontSmallPx = ptToPx(9);
const legendFontPx = ptToPx(10);
const fontLargePx = ptToPx(12);
const fontStandard = "Segoe UI";
const fontTitle = "wf_standard-font, helvetica, arial, sans-serif";
const firstLevelElementColor = "#252423";
const secondLevelElementColor = "#605E5C";
const backgroundColor = "transparent";
const backgroundSecondaryColor = "#C8C6C4";
const paletteColor1 = "#118DFF";
const paletteColor2 = "#12239E";
const paletteColor3 = "#E66C37";
const paletteColor4 = "#6B007B";
const paletteColor5 = "#E044A7";
const paletteColor6 = "#744EC2";
const paletteColor7 = "#D9B300";
const paletteColor8 = "#D64550";
const divergentColorMax = paletteColor1;
const divergentColorMin = "#DEEFFF";
const divergentPalette = [divergentColorMin, divergentColorMax];
const ordinalPalette = [
  divergentColorMin,
  "#c7e4ff",
  "#b0d9ff",
  "#9aceff",
  "#83c3ff",
  "#6cb9ff",
  "#55aeff",
  "#3fa3ff",
  "#2898ff",
  divergentColorMax
];
const powerbiTheme = {
  view: { stroke: backgroundColor },
  background: backgroundColor,
  font: fontStandard,
  header: {
    titleFont: fontTitle,
    titleFontSize: fontLargePx,
    titleColor: firstLevelElementColor,
    labelFont: fontStandard,
    labelFontSize: legendFontPx,
    labelColor: secondLevelElementColor
  },
  axis: {
    ticks: false,
    grid: false,
    domain: false,
    labelColor: secondLevelElementColor,
    labelFontSize: fontSmallPx,
    titleFont: fontTitle,
    titleColor: firstLevelElementColor,
    titleFontSize: fontLargePx,
    titleFontWeight: "normal"
  },
  axisQuantitative: {
    tickCount: 3,
    grid: true,
    gridColor: backgroundSecondaryColor,
    gridDash: [1, 5],
    labelFlush: false
  },
  axisBand: { tickExtra: true },
  axisX: { labelPadding: 5 },
  axisY: { labelPadding: 10 },
  bar: { fill: paletteColor1 },
  line: {
    stroke: paletteColor1,
    strokeWidth: 3,
    strokeCap: "round",
    strokeJoin: "round"
  },
  text: { font: fontStandard, fontSize: fontSmallPx, fill: secondLevelElementColor },
  arc: { fill: paletteColor1 },
  area: { fill: paletteColor1, line: true, opacity: 0.6 },
  path: { stroke: paletteColor1 },
  rect: { fill: paletteColor1 },
  point: { fill: paletteColor1, filled: true, size: 75 },
  shape: { stroke: paletteColor1 },
  symbol: { fill: paletteColor1, strokeWidth: 1.5, size: 50 },
  legend: {
    titleFont: fontStandard,
    titleFontWeight: "bold",
    titleColor: secondLevelElementColor,
    labelFont: fontStandard,
    labelFontSize: legendFontPx,
    labelColor: secondLevelElementColor,
    symbolType: "circle",
    symbolSize: 75
  },
  range: {
    category: [
      paletteColor1,
      paletteColor2,
      paletteColor3,
      paletteColor4,
      paletteColor5,
      paletteColor6,
      paletteColor7,
      paletteColor8
    ],
    diverging: divergentPalette,
    heatmap: divergentPalette,
    ordinal: ordinalPalette
  }
};
const version = pkg.version;
const themes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dark: darkTheme,
  excel: excelTheme,
  fivethirtyeight: fiveThirtyEightTheme,
  ggplot2: ggplot2Theme,
  googlecharts: googlechartsTheme,
  latimes: latimesTheme,
  powerbi: powerbiTheme,
  quartz: quartzTheme,
  urbaninstitute: urbanInstituteTheme,
  version,
  vox: voxTheme
}, Symbol.toStringTag, { value: "Module" }));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(s, e3) {
  var t4 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
    t4[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t4[p[i]] = s[p[i]];
    }
  return t4;
}
function formatValue(value2, valueToHtml, maxDepth2) {
  if (isArray$1(value2)) {
    return `[${value2.map((v) => valueToHtml(isString(v) ? v : stringify(v, maxDepth2))).join(", ")}]`;
  }
  if (isObject$1(value2)) {
    let content2 = "";
    const _a = value2, { title: title2, image: image2 } = _a, rest = __rest(_a, ["title", "image"]);
    if (title2) {
      content2 += `<h2>${valueToHtml(title2)}</h2>`;
    }
    if (image2) {
      content2 += `<img src="${valueToHtml(image2)}">`;
    }
    const keys2 = Object.keys(rest);
    if (keys2.length > 0) {
      content2 += "<table>";
      for (const key2 of keys2) {
        let val = rest[key2];
        if (val === void 0) {
          continue;
        }
        if (isObject$1(val)) {
          val = stringify(val, maxDepth2);
        }
        content2 += `<tr><td class="key">${valueToHtml(key2)}:</td><td class="value">${valueToHtml(val)}</td></tr>`;
      }
      content2 += `</table>`;
    }
    return content2 || "{}";
  }
  return valueToHtml(value2);
}
function replacer(maxDepth2) {
  const stack2 = [];
  return function(key2, value2) {
    if (typeof value2 !== "object" || value2 === null) {
      return value2;
    }
    const pos = stack2.indexOf(this) + 1;
    stack2.length = pos;
    if (stack2.length > maxDepth2) {
      return "[Object]";
    }
    if (stack2.indexOf(value2) >= 0) {
      return "[Circular]";
    }
    stack2.push(value2);
    return value2;
  };
}
function stringify(obj, maxDepth2) {
  return JSON.stringify(obj, replacer(maxDepth2));
}
var defaultStyle = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element img {
  max-width: 200px;
  max-height: 200px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;
const EL_ID = "vg-tooltip-element";
const DEFAULT_OPTIONS = {
  /**
   * X offset.
   */
  offsetX: 10,
  /**
   * Y offset.
   */
  offsetY: 10,
  /**
   * ID of the tooltip element.
   */
  id: EL_ID,
  /**
   * ID of the tooltip CSS style.
   */
  styleId: "vega-tooltip-style",
  /**
   * The name of the theme. You can use the CSS class called [THEME]-theme to style the tooltips.
   *
   * There are two predefined themes: "light" (default) and "dark".
   */
  theme: "light",
  /**
   * Do not use the default styles provided by Vega Tooltip. If you enable this option, you need to use your own styles. It is not necessary to disable the default style when using a custom theme.
   */
  disableDefaultStyle: false,
  /**
   * HTML sanitizer function that removes dangerous HTML to prevent XSS.
   *
   * This should be a function from string to string. You may replace it with a formatter such as a markdown formatter.
   */
  sanitize: escapeHTML,
  /**
   * The maximum recursion depth when printing objects in the tooltip.
   */
  maxDepth: 2,
  /**
   * A function to customize the rendered HTML of the tooltip.
   * @param value A value string, or object of value strings keyed by field
   * @param sanitize The `sanitize` function from `options.sanitize`
   * @returns {string} The returned string will become the `innerHTML` of the tooltip element
   */
  formatTooltip: formatValue
};
function escapeHTML(value2) {
  return String(value2).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function createDefaultStyle(id2) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(id2)) {
    throw new Error("Invalid HTML ID");
  }
  return defaultStyle.toString().replace(EL_ID, id2);
}
function calculatePosition(event2, tooltipBox, offsetX, offsetY) {
  let x2 = event2.clientX + offsetX;
  if (x2 + tooltipBox.width > window.innerWidth) {
    x2 = +event2.clientX - offsetX - tooltipBox.width;
  }
  let y2 = event2.clientY + offsetY;
  if (y2 + tooltipBox.height > window.innerHeight) {
    y2 = +event2.clientY - offsetY - tooltipBox.height;
  }
  return { x: x2, y: y2 };
}
class Handler2 {
  /**
   * Create the tooltip handler and initialize the element and style.
   *
   * @param options Tooltip Options
   */
  constructor(options) {
    this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    const elementId = this.options.id;
    this.el = null;
    this.call = this.tooltipHandler.bind(this);
    if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const style2 = document.createElement("style");
      style2.setAttribute("id", this.options.styleId);
      style2.innerHTML = createDefaultStyle(elementId);
      const head = document.head;
      if (head.childNodes.length > 0) {
        head.insertBefore(style2, head.childNodes[0]);
      } else {
        head.appendChild(style2);
      }
    }
  }
  /**
   * The tooltip handler function.
   */
  tooltipHandler(handler, event2, item, value2) {
    var _a;
    this.el = document.getElementById(this.options.id);
    if (!this.el) {
      this.el = document.createElement("div");
      this.el.setAttribute("id", this.options.id);
      this.el.classList.add("vg-tooltip");
      const tooltipContainer = (_a = document.fullscreenElement) !== null && _a !== void 0 ? _a : document.body;
      tooltipContainer.appendChild(this.el);
    }
    if (value2 == null || value2 === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = this.options.formatTooltip(value2, this.options.sanitize, this.options.maxDepth);
    this.el.classList.add("visible", `${this.options.theme}-theme`);
    const { x: x2, y: y2 } = calculatePosition(event2, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
    this.el.setAttribute("style", `top: ${y2}px; left: ${x2}px`);
  }
}
function _defineProperty$2(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key2, arg) {
  try {
    var info2 = gen[key2](arg);
    var value2 = info2.value;
  } catch (error2) {
    reject(error2);
    return;
  }
  if (info2.done) {
    resolve2(value2);
  } else {
    Promise.resolve(value2).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve2, reject) {
      var gen = fn.apply(self2, args);
      function _next(value2) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value2);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var Op = Object.prototype;
var hasOwn = Op.hasOwnProperty;
var undefined$1;
var $Symbol = typeof Symbol === "function" ? Symbol : {};
var iteratorSymbol = $Symbol.iterator || "@@iterator";
var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
function wrap(innerFn, outerFn, self2, tryLocsList) {
  var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
  var generator = Object.create(protoGenerator.prototype);
  var context2 = new Context(tryLocsList || []);
  generator._invoke = makeInvokeMethod(innerFn, self2, context2);
  return generator;
}
function tryCatch(fn, obj, arg) {
  try {
    return {
      type: "normal",
      arg: fn.call(obj, arg)
    };
  } catch (err) {
    return {
      type: "throw",
      arg: err
    };
  }
}
var GenStateSuspendedStart = "suspendedStart";
var GenStateSuspendedYield = "suspendedYield";
var GenStateExecuting = "executing";
var GenStateCompleted = "completed";
var ContinueSentinel = {};
function Generator() {
}
function GeneratorFunction() {
}
function GeneratorFunctionPrototype() {
}
var IteratorPrototype = {};
IteratorPrototype[iteratorSymbol] = function() {
  return this;
};
var getProto = Object.getPrototypeOf;
var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
  IteratorPrototype = NativeIteratorPrototype;
}
var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
GeneratorFunctionPrototype.constructor = GeneratorFunction;
GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
function defineIteratorMethods(prototype2) {
  ["next", "throw", "return"].forEach(function(method2) {
    prototype2[method2] = function(arg) {
      return this._invoke(method2, arg);
    };
  });
}
function isGeneratorFunction(genFun) {
  var ctor = typeof genFun === "function" && genFun.constructor;
  return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
  // do is to check its .name property.
  (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
}
function mark(genFun) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
  } else {
    genFun.__proto__ = GeneratorFunctionPrototype;
    if (!(toStringTagSymbol in genFun)) {
      genFun[toStringTagSymbol] = "GeneratorFunction";
    }
  }
  genFun.prototype = Object.create(Gp);
  return genFun;
}
function awrap(arg) {
  return {
    __await: arg
  };
}
function AsyncIterator(generator, PromiseImpl) {
  function invoke2(method2, arg, resolve2, reject) {
    var record = tryCatch(generator[method2], generator, arg);
    if (record.type === "throw") {
      reject(record.arg);
    } else {
      var result = record.arg;
      var value2 = result.value;
      if (value2 && typeof value2 === "object" && hasOwn.call(value2, "__await")) {
        return PromiseImpl.resolve(value2.__await).then(function(value3) {
          invoke2("next", value3, resolve2, reject);
        }, function(err) {
          invoke2("throw", err, resolve2, reject);
        });
      }
      return PromiseImpl.resolve(value2).then(function(unwrapped) {
        result.value = unwrapped;
        resolve2(result);
      }, function(error2) {
        return invoke2("throw", error2, resolve2, reject);
      });
    }
  }
  var previousPromise;
  function enqueue2(method2, arg) {
    function callInvokeWithMethodAndArg() {
      return new PromiseImpl(function(resolve2, reject) {
        invoke2(method2, arg, resolve2, reject);
      });
    }
    return previousPromise = // If enqueue has been called before, then we want to wait until
    // all previous Promises have been resolved before calling invoke,
    // so that results are always delivered in the correct order. If
    // enqueue has not been called before, then it is important to
    // call invoke immediately, without waiting on a callback to fire,
    // so that the async generator function has the opportunity to do
    // any necessary setup in a predictable way. This predictability
    // is why the Promise constructor synchronously invokes its
    // executor callback, and why async functions synchronously
    // execute code before the first await. Since we implement simple
    // async functions in terms of async generators, it is especially
    // important to get this right, even though it requires care.
    previousPromise ? previousPromise.then(
      callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg
    ) : callInvokeWithMethodAndArg();
  }
  this._invoke = enqueue2;
}
defineIteratorMethods(AsyncIterator.prototype);
AsyncIterator.prototype[asyncIteratorSymbol] = function() {
  return this;
};
function async(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
  if (PromiseImpl === void 0) PromiseImpl = Promise;
  var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
  return isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
    return result.done ? result.value : iter.next();
  });
}
function makeInvokeMethod(innerFn, self2, context2) {
  var state = GenStateSuspendedStart;
  return function invoke2(method2, arg) {
    if (state === GenStateExecuting) {
      throw new Error("Generator is already running");
    }
    if (state === GenStateCompleted) {
      if (method2 === "throw") {
        throw arg;
      }
      return doneResult();
    }
    context2.method = method2;
    context2.arg = arg;
    while (true) {
      var delegate = context2.delegate;
      if (delegate) {
        var delegateResult = maybeInvokeDelegate(delegate, context2);
        if (delegateResult) {
          if (delegateResult === ContinueSentinel) continue;
          return delegateResult;
        }
      }
      if (context2.method === "next") {
        context2.sent = context2._sent = context2.arg;
      } else if (context2.method === "throw") {
        if (state === GenStateSuspendedStart) {
          state = GenStateCompleted;
          throw context2.arg;
        }
        context2.dispatchException(context2.arg);
      } else if (context2.method === "return") {
        context2.abrupt("return", context2.arg);
      }
      state = GenStateExecuting;
      var record = tryCatch(innerFn, self2, context2);
      if (record.type === "normal") {
        state = context2.done ? GenStateCompleted : GenStateSuspendedYield;
        if (record.arg === ContinueSentinel) {
          continue;
        }
        return {
          value: record.arg,
          done: context2.done
        };
      } else if (record.type === "throw") {
        state = GenStateCompleted;
        context2.method = "throw";
        context2.arg = record.arg;
      }
    }
  };
}
function maybeInvokeDelegate(delegate, context2) {
  var method2 = delegate.iterator[context2.method];
  if (method2 === undefined$1) {
    context2.delegate = null;
    if (context2.method === "throw") {
      if (delegate.iterator["return"]) {
        context2.method = "return";
        context2.arg = undefined$1;
        maybeInvokeDelegate(delegate, context2);
        if (context2.method === "throw") {
          return ContinueSentinel;
        }
      }
      context2.method = "throw";
      context2.arg = new TypeError("The iterator does not provide a 'throw' method");
    }
    return ContinueSentinel;
  }
  var record = tryCatch(method2, delegate.iterator, context2.arg);
  if (record.type === "throw") {
    context2.method = "throw";
    context2.arg = record.arg;
    context2.delegate = null;
    return ContinueSentinel;
  }
  var info2 = record.arg;
  if (!info2) {
    context2.method = "throw";
    context2.arg = new TypeError("iterator result is not an object");
    context2.delegate = null;
    return ContinueSentinel;
  }
  if (info2.done) {
    context2[delegate.resultName] = info2.value;
    context2.next = delegate.nextLoc;
    if (context2.method !== "return") {
      context2.method = "next";
      context2.arg = undefined$1;
    }
  } else {
    return info2;
  }
  context2.delegate = null;
  return ContinueSentinel;
}
defineIteratorMethods(Gp);
Gp[toStringTagSymbol] = "Generator";
Gp[iteratorSymbol] = function() {
  return this;
};
Gp.toString = function() {
  return "[object Generator]";
};
function pushTryEntry(locs) {
  var entry2 = {
    tryLoc: locs[0]
  };
  if (1 in locs) {
    entry2.catchLoc = locs[1];
  }
  if (2 in locs) {
    entry2.finallyLoc = locs[2];
    entry2.afterLoc = locs[3];
  }
  this.tryEntries.push(entry2);
}
function resetTryEntry(entry2) {
  var record = entry2.completion || {};
  record.type = "normal";
  delete record.arg;
  entry2.completion = record;
}
function Context(tryLocsList) {
  this.tryEntries = [{
    tryLoc: "root"
  }];
  tryLocsList.forEach(pushTryEntry, this);
  this.reset(true);
}
function keys(object2) {
  var keys2 = [];
  for (var key2 in object2) {
    keys2.push(key2);
  }
  keys2.reverse();
  return function next2() {
    while (keys2.length) {
      var key3 = keys2.pop();
      if (key3 in object2) {
        next2.value = key3;
        next2.done = false;
        return next2;
      }
    }
    next2.done = true;
    return next2;
  };
}
function values(iterable) {
  if (iterable) {
    var iteratorMethod = iterable[iteratorSymbol];
    if (iteratorMethod) {
      return iteratorMethod.call(iterable);
    }
    if (typeof iterable.next === "function") {
      return iterable;
    }
    if (!isNaN(iterable.length)) {
      var i = -1, next2 = function next3() {
        while (++i < iterable.length) {
          if (hasOwn.call(iterable, i)) {
            next3.value = iterable[i];
            next3.done = false;
            return next3;
          }
        }
        next3.value = undefined$1;
        next3.done = true;
        return next3;
      };
      return next2.next = next2;
    }
  }
  return {
    next: doneResult
  };
}
function doneResult() {
  return {
    value: undefined$1,
    done: true
  };
}
Context.prototype = {
  constructor: Context,
  reset: function reset2(skipTempReset) {
    this.prev = 0;
    this.next = 0;
    this.sent = this._sent = undefined$1;
    this.done = false;
    this.delegate = null;
    this.method = "next";
    this.arg = undefined$1;
    this.tryEntries.forEach(resetTryEntry);
    if (!skipTempReset) {
      for (var name in this) {
        if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
          this[name] = undefined$1;
        }
      }
    }
  },
  stop: function stop2() {
    this.done = true;
    var rootEntry = this.tryEntries[0];
    var rootRecord = rootEntry.completion;
    if (rootRecord.type === "throw") {
      throw rootRecord.arg;
    }
    return this.rval;
  },
  dispatchException: function dispatchException(exception) {
    if (this.done) {
      throw exception;
    }
    var context2 = this;
    function handle(loc, caught) {
      record.type = "throw";
      record.arg = exception;
      context2.next = loc;
      if (caught) {
        context2.method = "next";
        context2.arg = undefined$1;
      }
      return !!caught;
    }
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry2 = this.tryEntries[i];
      var record = entry2.completion;
      if (entry2.tryLoc === "root") {
        return handle("end");
      }
      if (entry2.tryLoc <= this.prev) {
        var hasCatch = hasOwn.call(entry2, "catchLoc");
        var hasFinally = hasOwn.call(entry2, "finallyLoc");
        if (hasCatch && hasFinally) {
          if (this.prev < entry2.catchLoc) {
            return handle(entry2.catchLoc, true);
          } else if (this.prev < entry2.finallyLoc) {
            return handle(entry2.finallyLoc);
          }
        } else if (hasCatch) {
          if (this.prev < entry2.catchLoc) {
            return handle(entry2.catchLoc, true);
          }
        } else if (hasFinally) {
          if (this.prev < entry2.finallyLoc) {
            return handle(entry2.finallyLoc);
          }
        } else {
          throw new Error("try statement without catch or finally");
        }
      }
    }
  },
  abrupt: function abrupt(type2, arg) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry2 = this.tryEntries[i];
      if (entry2.tryLoc <= this.prev && hasOwn.call(entry2, "finallyLoc") && this.prev < entry2.finallyLoc) {
        var finallyEntry = entry2;
        break;
      }
    }
    if (finallyEntry && (type2 === "break" || type2 === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
      finallyEntry = null;
    }
    var record = finallyEntry ? finallyEntry.completion : {};
    record.type = type2;
    record.arg = arg;
    if (finallyEntry) {
      this.method = "next";
      this.next = finallyEntry.finallyLoc;
      return ContinueSentinel;
    }
    return this.complete(record);
  },
  complete: function complete(record, afterLoc) {
    if (record.type === "throw") {
      throw record.arg;
    }
    if (record.type === "break" || record.type === "continue") {
      this.next = record.arg;
    } else if (record.type === "return") {
      this.rval = this.arg = record.arg;
      this.method = "return";
      this.next = "end";
    } else if (record.type === "normal" && afterLoc) {
      this.next = afterLoc;
    }
    return ContinueSentinel;
  },
  finish: function finish(finallyLoc) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry2 = this.tryEntries[i];
      if (entry2.finallyLoc === finallyLoc) {
        this.complete(entry2.completion, entry2.afterLoc);
        resetTryEntry(entry2);
        return ContinueSentinel;
      }
    }
  },
  "catch": function _catch(tryLoc) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry2 = this.tryEntries[i];
      if (entry2.tryLoc === tryLoc) {
        var record = entry2.completion;
        if (record.type === "throw") {
          var thrown = record.arg;
          resetTryEntry(entry2);
        }
        return thrown;
      }
    }
    throw new Error("illegal catch attempt");
  },
  delegateYield: function delegateYield(iterable, resultName, nextLoc) {
    this.delegate = {
      iterator: values(iterable),
      resultName,
      nextLoc
    };
    if (this.method === "next") {
      this.arg = undefined$1;
    }
    return ContinueSentinel;
  }
};
var _regeneratorRuntime = {
  wrap,
  isGeneratorFunction,
  AsyncIterator,
  mark,
  awrap,
  async,
  keys,
  values
};
var yallist = Yallist$1;
Yallist$1.Node = Node$1;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self2.push(arguments[i]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node2) {
  if (node2.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next2 = node2.next;
  var prev2 = node2.prev;
  if (next2) {
    next2.prev = prev2;
  }
  if (prev2) {
    prev2.next = next2;
  }
  if (node2 === this.head) {
    this.head = next2;
  }
  if (node2 === this.tail) {
    this.tail = prev2;
  }
  node2.list.length--;
  node2.next = null;
  node2.prev = null;
  node2.list = null;
  return next2;
};
Yallist$1.prototype.unshiftNode = function(node2) {
  if (node2 === this.head) {
    return;
  }
  if (node2.list) {
    node2.list.removeNode(node2);
  }
  var head = this.head;
  node2.list = this;
  node2.next = head;
  if (head) {
    head.prev = node2;
  }
  this.head = node2;
  if (!this.tail) {
    this.tail = node2;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node2) {
  if (node2 === this.tail) {
    return;
  }
  if (node2.list) {
    node2.list.removeNode(node2);
  }
  var tail = this.tail;
  node2.list = this;
  node2.prev = tail;
  if (tail) {
    tail.next = node2;
  }
  this.tail = node2;
  if (!this.head) {
    this.head = node2;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from2, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from2 = from2 || 0;
  if (from2 < 0) {
    from2 += this.length;
  }
  var ret = new Yallist$1();
  if (to < from2 || to < 0) {
    return ret;
  }
  if (from2 < 0) {
    from2 = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from2; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from2, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from2 = from2 || 0;
  if (from2 < 0) {
    from2 += this.length;
  }
  var ret = new Yallist$1();
  if (to < from2 || to < 0) {
    return ret;
  }
  if (from2 < 0) {
    from2 = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from2; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
    walker = insert(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? void 0 : arguments[i + 2]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node2, value2) {
  var inserted = node2 === self2.head ? new Node$1(value2, null, node2, self2) : new Node$1(value2, node2, node2.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node$1(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node$1(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node$1(value2, prev2, next2, list) {
  if (!(this instanceof Node$1)) {
    return new Node$1(value2, prev2, next2, list);
  }
  this.list = list;
  this.value = value2;
  if (prev2) {
    prev2.next = this;
    this.prev = prev2;
  } else {
    this.prev = null;
  }
  if (next2) {
    next2.prev = this;
    this.next = next2;
  } else {
    this.next = null;
  }
}
try {
  Yallist$1.prototype[Symbol.iterator] = /* @__PURE__ */ _regeneratorRuntime.mark(function _callee() {
    var walker;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            walker = this.head;
          case 1:
            if (!walker) {
              _context.next = 7;
              break;
            }
            _context.next = 4;
            return walker.value;
          case 4:
            walker = walker.next;
            _context.next = 1;
            break;
          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  });
} catch (er) {
}
var Yallist = yallist;
var MAX = Symbol("max");
var LENGTH = Symbol("length");
var LENGTH_CALCULATOR = Symbol("lengthCalculator");
var ALLOW_STALE = Symbol("allowStale");
var MAX_AGE = Symbol("maxAge");
var DISPOSE = Symbol("dispose");
var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
var LRU_LIST = Symbol("lruList");
var CACHE = Symbol("cache");
var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
var naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number") options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0)) throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number") throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== "number" || mL < 0) throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number") throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== "function") lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit2) => {
        hit2.length = this[LENGTH_CALCULATOR](hit2.value, hit2.key);
        this[LENGTH] += hit2.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this[LRU_LIST].tail; walker !== null; ) {
      var prev2 = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev2;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this[LRU_LIST].head; walker !== null; ) {
      var next2 = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next2;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit2) => this[DISPOSE](hit2.key, hit2.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit2) => isStale(this, hit2) ? false : {
      k: hit2.key,
      v: hit2.value,
      e: hit2.now + (hit2.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key2, value2, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number") throw new TypeError("maxAge must be a number");
    var now2 = maxAge ? Date.now() : 0;
    var len = this[LENGTH_CALCULATOR](value2, key2);
    if (this[CACHE].has(key2)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key2));
        return false;
      }
      var node2 = this[CACHE].get(key2);
      var item = node2.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key2, item.value);
      }
      item.now = now2;
      item.maxAge = maxAge;
      item.value = value2;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key2);
      trim(this);
      return true;
    }
    var hit2 = new Entry(key2, value2, len, now2, maxAge);
    if (hit2.length > this[MAX]) {
      if (this[DISPOSE]) this[DISPOSE](key2, value2);
      return false;
    }
    this[LENGTH] += hit2.length;
    this[LRU_LIST].unshift(hit2);
    this[CACHE].set(key2, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key2) {
    if (!this[CACHE].has(key2)) return false;
    var hit2 = this[CACHE].get(key2).value;
    return !isStale(this, hit2);
  }
  get(key2) {
    return get(this, key2, true);
  }
  peek(key2) {
    return get(this, key2, false);
  }
  pop() {
    var node2 = this[LRU_LIST].tail;
    if (!node2) return null;
    del(this, node2);
    return node2.value;
  }
  del(key2) {
    del(this, this[CACHE].get(key2));
  }
  load(arr) {
    this.reset();
    var now2 = Date.now();
    for (var l = arr.length - 1; l >= 0; l--) {
      var hit2 = arr[l];
      var expiresAt = hit2.e || 0;
      if (expiresAt === 0)
        this.set(hit2.k, hit2.v);
      else {
        var maxAge = expiresAt - now2;
        if (maxAge > 0) {
          this.set(hit2.k, hit2.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value2, key2) => get(this, key2, false));
  }
}
var get = (self2, key2, doUse) => {
  var node2 = self2[CACHE].get(key2);
  if (node2) {
    var hit2 = node2.value;
    if (isStale(self2, hit2)) {
      del(self2, node2);
      if (!self2[ALLOW_STALE]) return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET]) node2.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node2);
      }
    }
    return hit2.value;
  }
};
var isStale = (self2, hit2) => {
  if (!hit2 || !hit2.maxAge && !self2[MAX_AGE]) return false;
  var diff = Date.now() - hit2.now;
  return hit2.maxAge ? diff > hit2.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
};
var trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (var walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      var prev2 = walker.prev;
      del(self2, walker);
      walker = prev2;
    }
  }
};
var del = (self2, node2) => {
  if (node2) {
    var hit2 = node2.value;
    if (self2[DISPOSE]) self2[DISPOSE](hit2.key, hit2.value);
    self2[LENGTH] -= hit2.length;
    self2[CACHE].delete(hit2.key);
    self2[LRU_LIST].removeNode(node2);
  }
};
class Entry {
  constructor(key2, value2, length2, now2, maxAge) {
    this.key = key2;
    this.value = value2;
    this.length = length2;
    this.now = now2;
    this.maxAge = maxAge || 0;
  }
}
var forEachStep = (self2, fn, node2, thisp) => {
  var hit2 = node2.value;
  if (isStale(self2, hit2)) {
    del(self2, node2);
    if (!self2[ALLOW_STALE]) hit2 = void 0;
  }
  if (hit2) fn.call(thisp, hit2.value, hit2.key, self2);
};
var lruCache = LRUCache;
var opts = ["includePrerelease", "loose", "rtl"];
var parseOptions$1 = (options) => !options ? {} : typeof options !== "object" ? {
  loose: true
} : opts.filter((k) => options[k]).reduce((o, k) => {
  o[k] = true;
  return o;
}, {});
var parseOptions_1 = parseOptions$1;
var re$1 = { exports: {} };
var MAX_LENGTH$1 = 256;
var MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
var MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
var debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return console.error("SEMVER", ...args);
} : () => {
};
var debug_1 = debug$1;
(function(module2, exports2) {
  var MAX_SAFE_COMPONENT_LENGTH2 = constants.MAX_SAFE_COMPONENT_LENGTH;
  var debug2 = debug_1;
  exports2 = module2.exports = {};
  var re2 = exports2.re = [];
  var src = exports2.src = [];
  var t4 = exports2.t = {};
  var R = 0;
  var createToken = (name, value2, isGlobal) => {
    var index2 = R++;
    debug2(name, index2, value2);
    t4[name] = index2;
    src[index2] = value2;
    re2[index2] = new RegExp(value2, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", "(".concat(src[t4.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t4.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t4.NUMERICIDENTIFIER], ")"));
  createToken("MAINVERSIONLOOSE", "(".concat(src[t4.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t4.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t4.NUMERICIDENTIFIERLOOSE], ")"));
  createToken("PRERELEASEIDENTIFIER", "(?:".concat(src[t4.NUMERICIDENTIFIER], "|").concat(src[t4.NONNUMERICIDENTIFIER], ")"));
  createToken("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(src[t4.NUMERICIDENTIFIERLOOSE], "|").concat(src[t4.NONNUMERICIDENTIFIER], ")"));
  createToken("PRERELEASE", "(?:-(".concat(src[t4.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t4.PRERELEASEIDENTIFIER], ")*))"));
  createToken("PRERELEASELOOSE", "(?:-?(".concat(src[t4.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t4.PRERELEASEIDENTIFIERLOOSE], ")*))"));
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", "(?:\\+(".concat(src[t4.BUILDIDENTIFIER], "(?:\\.").concat(src[t4.BUILDIDENTIFIER], ")*))"));
  createToken("FULLPLAIN", "v?".concat(src[t4.MAINVERSION]).concat(src[t4.PRERELEASE], "?").concat(src[t4.BUILD], "?"));
  createToken("FULL", "^".concat(src[t4.FULLPLAIN], "$"));
  createToken("LOOSEPLAIN", "[v=\\s]*".concat(src[t4.MAINVERSIONLOOSE]).concat(src[t4.PRERELEASELOOSE], "?").concat(src[t4.BUILD], "?"));
  createToken("LOOSE", "^".concat(src[t4.LOOSEPLAIN], "$"));
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", "".concat(src[t4.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
  createToken("XRANGEIDENTIFIER", "".concat(src[t4.NUMERICIDENTIFIER], "|x|X|\\*"));
  createToken("XRANGEPLAIN", "[v=\\s]*(".concat(src[t4.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t4.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t4.XRANGEIDENTIFIER], ")") + "(?:".concat(src[t4.PRERELEASE], ")?").concat(src[t4.BUILD], "?") + ")?)?");
  createToken("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(src[t4.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t4.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t4.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(src[t4.PRERELEASELOOSE], ")?").concat(src[t4.BUILD], "?") + ")?)?");
  createToken("XRANGE", "^".concat(src[t4.GTLT], "\\s*").concat(src[t4.XRANGEPLAIN], "$"));
  createToken("XRANGELOOSE", "^".concat(src[t4.GTLT], "\\s*").concat(src[t4.XRANGEPLAINLOOSE], "$"));
  createToken("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(MAX_SAFE_COMPONENT_LENGTH2, "})") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH2, "}))?") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH2, "}))?") + "(?:$|[^\\d])");
  createToken("COERCERTL", src[t4.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", "(\\s*)".concat(src[t4.LONETILDE], "\\s+"), true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", "^".concat(src[t4.LONETILDE]).concat(src[t4.XRANGEPLAIN], "$"));
  createToken("TILDELOOSE", "^".concat(src[t4.LONETILDE]).concat(src[t4.XRANGEPLAINLOOSE], "$"));
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", "(\\s*)".concat(src[t4.LONECARET], "\\s+"), true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", "^".concat(src[t4.LONECARET]).concat(src[t4.XRANGEPLAIN], "$"));
  createToken("CARETLOOSE", "^".concat(src[t4.LONECARET]).concat(src[t4.XRANGEPLAINLOOSE], "$"));
  createToken("COMPARATORLOOSE", "^".concat(src[t4.GTLT], "\\s*(").concat(src[t4.LOOSEPLAIN], ")$|^$"));
  createToken("COMPARATOR", "^".concat(src[t4.GTLT], "\\s*(").concat(src[t4.FULLPLAIN], ")$|^$"));
  createToken("COMPARATORTRIM", "(\\s*)".concat(src[t4.GTLT], "\\s*(").concat(src[t4.LOOSEPLAIN], "|").concat(src[t4.XRANGEPLAIN], ")"), true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", "^\\s*(".concat(src[t4.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(src[t4.XRANGEPLAIN], ")") + "\\s*$");
  createToken("HYPHENRANGELOOSE", "^\\s*(".concat(src[t4.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(src[t4.XRANGEPLAINLOOSE], ")") + "\\s*$");
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$1, re$1.exports);
var numeric = /^[0-9]+$/;
var compareIdentifiers$1 = (a2, b2) => {
  var anum = numeric.test(a2);
  var bnum = numeric.test(b2);
  if (anum && bnum) {
    a2 = +a2;
    b2 = +b2;
  }
  return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
};
var identifiers = {
  compareIdentifiers: compareIdentifiers$1
};
var debug = debug_1;
var MAX_LENGTH = constants.MAX_LENGTH, MAX_SAFE_INTEGER = constants.MAX_SAFE_INTEGER;
var re = re$1.exports.re, t = re$1.exports.t;
var parseOptions = parseOptions_1;
var compareIdentifiers = identifiers.compareIdentifiers;
class SemVer$1 {
  constructor(version2, options) {
    options = parseOptions(options);
    if (version2 instanceof SemVer$1) {
      if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError("Invalid Version: ".concat(version2));
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError("version is longer than ".concat(MAX_LENGTH, " characters"));
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    var m2 = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m2) {
      throw new TypeError("Invalid Version: ".concat(version2));
    }
    this.raw = version2;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          var num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
    if (this.prerelease.length) {
      this.version += "-".concat(this.prerelease.join("."));
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer$1)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer$1(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer$1)) {
      other = new SemVer$1(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer$1)) {
      other = new SemVer$1(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i = 0;
    do {
      var a2 = this.prerelease[i];
      var b2 = other.prerelease[i];
      debug("prerelease compare", i, a2, b2);
      if (a2 === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a2 === void 0) {
        return -1;
      } else if (a2 === b2) {
        continue;
      } else {
        return compareIdentifiers(a2, b2);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer$1)) {
      other = new SemVer$1(other, this.options);
    }
    var i = 0;
    do {
      var a2 = this.build[i];
      var b2 = other.build[i];
      debug("prerelease compare", i, a2, b2);
      if (a2 === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a2 === void 0) {
        return -1;
      } else if (a2 === b2) {
        continue;
      } else {
        return compareIdentifiers(a2, b2);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier2) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier2);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier2);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier2);
        this.inc("pre", identifier2);
        break;
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier2);
        }
        this.inc("pre", identifier2);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier2) {
          if (compareIdentifiers(this.prerelease[0], identifier2) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier2, 0];
            }
          } else {
            this.prerelease = [identifier2, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: ".concat(release));
    }
    this.format();
    this.raw = this.version;
    return this;
  }
}
var semver = SemVer$1;
var SemVer = semver;
var compare$6 = (a2, b2, loose) => new SemVer(a2, loose).compare(new SemVer(b2, loose));
var compare_1 = compare$6;
var compare$5 = compare_1;
var eq$1 = (a2, b2, loose) => compare$5(a2, b2, loose) === 0;
var eq_1 = eq$1;
var compare$4 = compare_1;
var neq$1 = (a2, b2, loose) => compare$4(a2, b2, loose) !== 0;
var neq_1 = neq$1;
var compare$3 = compare_1;
var gt$1 = (a2, b2, loose) => compare$3(a2, b2, loose) > 0;
var gt_1 = gt$1;
var compare$2 = compare_1;
var gte$1 = (a2, b2, loose) => compare$2(a2, b2, loose) >= 0;
var gte_1 = gte$1;
var compare$1 = compare_1;
var lt$1 = (a2, b2, loose) => compare$1(a2, b2, loose) < 0;
var lt_1 = lt$1;
var compare = compare_1;
var lte$1 = (a2, b2, loose) => compare(a2, b2, loose) <= 0;
var lte_1 = lte$1;
var eq = eq_1;
var neq = neq_1;
var gt = gt_1;
var gte = gte_1;
var lt = lt_1;
var lte = lte_1;
var cmp = (a2, op, b2, loose) => {
  switch (op) {
    case "===":
      if (typeof a2 === "object") {
        a2 = a2.version;
      }
      if (typeof b2 === "object") {
        b2 = b2.version;
      }
      return a2 === b2;
    case "!==":
      if (typeof a2 === "object") {
        a2 = a2.version;
      }
      if (typeof b2 === "object") {
        b2 = b2.version;
      }
      return a2 !== b2;
    case "":
    case "=":
    case "==":
      return eq(a2, b2, loose);
    case "!=":
      return neq(a2, b2, loose);
    case ">":
      return gt(a2, b2, loose);
    case ">=":
      return gte(a2, b2, loose);
    case "<":
      return lt(a2, b2, loose);
    case "<=":
      return lte(a2, b2, loose);
    default:
      throw new TypeError("Invalid operator: ".concat(op));
  }
};
var cmp_1 = cmp;
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  var ANY = Symbol("SemVer ANY");
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      var r2 = this.options.loose ? re2[t4.COMPARATORLOOSE] : re2[t4.COMPARATOR];
      var m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError("Invalid comparator: ".concat(comp));
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer2(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer2(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp2(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
      var oppositeDirectionsGreaterThan = cmp2(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  }
  comparator = Comparator;
  var parseOptions2 = parseOptions_1;
  var re2 = re$1.exports.re, t4 = re$1.exports.t;
  var cmp2 = cmp_1;
  var debug2 = debug_1;
  var SemVer2 = semver;
  var Range2 = requireRange();
  return comparator;
}
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike) {
      if (it) o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e3(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e3(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2;
      this.set = range2.split("||").map((r2) => this.parseRange(r2.trim())).filter((c3) => c3.length);
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: ".concat(range2));
      }
      if (this.set.length > 1) {
        var first = this.set[0];
        this.set = this.set.filter((c3) => !isNullSet(c3[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          var _iterator = _createForOfIteratorHelper$1(this.set), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var c2 = _step.value;
              if (c2.length === 1 && isAny(c2[0])) {
                this.set = [c2];
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      range2 = range2.trim();
      var memoOpts = Object.keys(this.options).join(",");
      var memoKey = "parseRange:".concat(memoOpts, ":").concat(range2);
      var cached = cache2.get(memoKey);
      if (cached) {
        return cached;
      }
      var loose = this.options.loose;
      var hr = loose ? re2[t4.HYPHENRANGELOOSE] : re2[t4.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t4.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t4.TILDETRIM], tildeTrimReplace);
      range2 = range2.replace(re2[t4.CARETTRIM], caretTrimReplace);
      range2 = range2.split(/\s+/).join(" ");
      var rangeList = range2.split(" ").map((comp2) => parseComparator(comp2, this.options)).join(" ").split(/\s+/).map((comp2) => replaceGTE0(comp2, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp2) => {
          debug2("loose invalid filter", comp2, this.options);
          return !!comp2.match(re2[t4.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      var rangeMap = /* @__PURE__ */ new Map();
      var comparators = rangeList.map((comp2) => new Comparator(comp2, this.options));
      var _iterator2 = _createForOfIteratorHelper$1(comparators), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var comp = _step2.value;
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      var result = [...rangeMap.values()];
      cache2.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer2(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  var LRU = lruCache;
  var cache2 = new LRU({
    max: 1e3
  });
  var parseOptions2 = parseOptions_1;
  var Comparator = requireComparator();
  var debug2 = debug_1;
  var SemVer2 = semver;
  var re2 = re$1.exports.re, t4 = re$1.exports.t, comparatorTrimReplace = re$1.exports.comparatorTrimReplace, tildeTrimReplace = re$1.exports.tildeTrimReplace, caretTrimReplace = re$1.exports.caretTrimReplace;
  var isNullSet = (c2) => c2.value === "<0.0.0-0";
  var isAny = (c2) => c2.value === "";
  var isSatisfiable = (comparators, options) => {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  var isX2 = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c2) => {
    return replaceTilde(c2, options);
  }).join(" ");
  var replaceTilde = (comp, options) => {
    var r2 = options.loose ? re2[t4.TILDELOOSE] : re2[t4.TILDE];
    return comp.replace(r2, (_, M2, m2, p, pr) => {
      debug2("tilde", comp, _, M2, m2, p, pr);
      var ret;
      if (isX2(M2)) {
        ret = "";
      } else if (isX2(m2)) {
        ret = ">=".concat(M2, ".0.0 <").concat(+M2 + 1, ".0.0-0");
      } else if (isX2(p)) {
        ret = ">=".concat(M2, ".").concat(m2, ".0 <").concat(M2, ".").concat(+m2 + 1, ".0-0");
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = ">=".concat(M2, ".").concat(m2, ".").concat(p, "-").concat(pr, " <").concat(M2, ".").concat(+m2 + 1, ".0-0");
      } else {
        ret = ">=".concat(M2, ".").concat(m2, ".").concat(p, " <").concat(M2, ".").concat(+m2 + 1, ".0-0");
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c2) => {
    return replaceCaret(c2, options);
  }).join(" ");
  var replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    var r2 = options.loose ? re2[t4.CARETLOOSE] : re2[t4.CARET];
    var z2 = options.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_, M2, m2, p, pr) => {
      debug2("caret", comp, _, M2, m2, p, pr);
      var ret;
      if (isX2(M2)) {
        ret = "";
      } else if (isX2(m2)) {
        ret = ">=".concat(M2, ".0.0").concat(z2, " <").concat(+M2 + 1, ".0.0-0");
      } else if (isX2(p)) {
        if (M2 === "0") {
          ret = ">=".concat(M2, ".").concat(m2, ".0").concat(z2, " <").concat(M2, ".").concat(+m2 + 1, ".0-0");
        } else {
          ret = ">=".concat(M2, ".").concat(m2, ".0").concat(z2, " <").concat(+M2 + 1, ".0.0-0");
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M2 === "0") {
          if (m2 === "0") {
            ret = ">=".concat(M2, ".").concat(m2, ".").concat(p, "-").concat(pr, " <").concat(M2, ".").concat(m2, ".").concat(+p + 1, "-0");
          } else {
            ret = ">=".concat(M2, ".").concat(m2, ".").concat(p, "-").concat(pr, " <").concat(M2, ".").concat(+m2 + 1, ".0-0");
          }
        } else {
          ret = ">=".concat(M2, ".").concat(m2, ".").concat(p, "-").concat(pr, " <").concat(+M2 + 1, ".0.0-0");
        }
      } else {
        debug2("no pr");
        if (M2 === "0") {
          if (m2 === "0") {
            ret = ">=".concat(M2, ".").concat(m2, ".").concat(p).concat(z2, " <").concat(M2, ".").concat(m2, ".").concat(+p + 1, "-0");
          } else {
            ret = ">=".concat(M2, ".").concat(m2, ".").concat(p).concat(z2, " <").concat(M2, ".").concat(+m2 + 1, ".0-0");
          }
        } else {
          ret = ">=".concat(M2, ".").concat(m2, ".").concat(p, " <").concat(+M2 + 1, ".0.0-0");
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c2) => {
      return replaceXRange(c2, options);
    }).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    var r2 = options.loose ? re2[t4.XRANGELOOSE] : re2[t4.XRANGE];
    return comp.replace(r2, (ret, gtlt, M2, m2, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M2, m2, p, pr);
      var xM = isX2(M2);
      var xm = xM || isX2(m2);
      var xp = xm || isX2(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M2 = +M2 + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M2 = +M2 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = "".concat(gtlt + M2, ".").concat(m2, ".").concat(p).concat(pr);
      } else if (xm) {
        ret = ">=".concat(M2, ".0.0").concat(pr, " <").concat(+M2 + 1, ".0.0-0");
      } else if (xp) {
        ret = ">=".concat(M2, ".").concat(m2, ".0").concat(pr, " <").concat(M2, ".").concat(+m2 + 1, ".0-0");
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t4.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t4.GTE0PRE : t4.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from2, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX2(fM)) {
      from2 = "";
    } else if (isX2(fm)) {
      from2 = ">=".concat(fM, ".0.0").concat(incPr ? "-0" : "");
    } else if (isX2(fp)) {
      from2 = ">=".concat(fM, ".").concat(fm, ".0").concat(incPr ? "-0" : "");
    } else if (fpr) {
      from2 = ">=".concat(from2);
    } else {
      from2 = ">=".concat(from2).concat(incPr ? "-0" : "");
    }
    if (isX2(tM)) {
      to = "";
    } else if (isX2(tm)) {
      to = "<".concat(+tM + 1, ".0.0-0");
    } else if (isX2(tp)) {
      to = "<".concat(tM, ".").concat(+tm + 1, ".0-0");
    } else if (tpr) {
      to = "<=".concat(tM, ".").concat(tm, ".").concat(tp, "-").concat(tpr);
    } else if (incPr) {
      to = "<".concat(tM, ".").concat(tm, ".").concat(+tp + 1, "-0");
    } else {
      to = "<=".concat(to);
    }
    return "".concat(from2, " ").concat(to).trim();
  };
  var testSet = (set2, version2, options) => {
    for (var i = 0; i < set2.length; i++) {
      if (!set2[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (var _i = 0; _i < set2.length; _i++) {
        debug2(set2[_i].semver);
        if (set2[_i].semver === Comparator.ANY) {
          continue;
        }
        if (set2[_i].semver.prerelease.length > 0) {
          var allowed = set2[_i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var Range = requireRange();
var satisfies = (version2, range2, options) => {
  try {
    range2 = new Range(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version2);
};
var satisfies_1 = satisfies;
function post(window2, url, data2) {
  var editor = window2.open(url);
  var step = 250;
  var _URL = new URL(url), origin = _URL.origin;
  var count2 = 40;
  function listen(evt) {
    if (evt.source === editor) {
      count2 = 0;
      window2.removeEventListener("message", listen, false);
    }
  }
  window2.addEventListener("message", listen, false);
  function send() {
    if (count2 <= 0) {
      return;
    }
    editor.postMessage(data2, origin);
    setTimeout(send, step);
    count2 -= 1;
  }
  setTimeout(send, step);
}
var embedStyle = '.vega-embed {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n}\n.vega-embed.has-actions {\n  padding-right: 38px;\n}\n.vega-embed details:not([open]) > :not(summary) {\n  display: none !important;\n}\n.vega-embed summary {\n  list-style: none;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 6px;\n  z-index: 1000;\n  background: white;\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);\n  color: #1b1e23;\n  border: 1px solid #aaa;\n  border-radius: 999px;\n  opacity: 0.2;\n  transition: opacity 0.4s ease-in;\n  cursor: pointer;\n  line-height: 0px;\n}\n.vega-embed summary::-webkit-details-marker {\n  display: none;\n}\n.vega-embed summary:active {\n  box-shadow: #aaa 0px 0px 0px 1px inset;\n}\n.vega-embed summary svg {\n  width: 14px;\n  height: 14px;\n}\n.vega-embed details[open] summary {\n  opacity: 0.7;\n}\n.vega-embed:hover summary, .vega-embed:focus-within summary {\n  opacity: 1 !important;\n  transition: opacity 0.2s ease;\n}\n.vega-embed .vega-actions {\n  position: absolute;\n  z-index: 1001;\n  top: 35px;\n  right: -9px;\n  display: flex;\n  flex-direction: column;\n  padding-bottom: 8px;\n  padding-top: 8px;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);\n  border: 1px solid #d9d9d9;\n  background: white;\n  animation-duration: 0.15s;\n  animation-name: scale-in;\n  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);\n  text-align: left;\n}\n.vega-embed .vega-actions a {\n  padding: 8px 16px;\n  font-family: sans-serif;\n  font-size: 14px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #434a56;\n  text-decoration: none;\n}\n.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {\n  background-color: #f7f7f9;\n  color: black;\n}\n.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {\n  content: "";\n  display: inline-block;\n  position: absolute;\n}\n.vega-embed .vega-actions::before {\n  left: auto;\n  right: 14px;\n  top: -16px;\n  border: 8px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #d9d9d9;\n}\n.vega-embed .vega-actions::after {\n  left: auto;\n  right: 15px;\n  top: -14px;\n  border: 7px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #fff;\n}\n.vega-embed .chart-wrapper.fit-x {\n  width: 100%;\n}\n.vega-embed .chart-wrapper.fit-y {\n  height: 100%;\n}\n\n.vega-embed-wrapper {\n  max-width: 100%;\n  overflow: auto;\n  padding-right: 14px;\n}\n\n@keyframes scale-in {\n  from {\n    opacity: 0;\n    transform: scale(0.6);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n';
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
}
function mergeDeep(dest) {
  for (var _len = arguments.length, src = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    src[_key - 1] = arguments[_key];
  }
  for (var _i = 0, _src = src; _i < _src.length; _i++) {
    var s = _src[_i];
    deepMerge_(dest, s);
  }
  return dest;
}
function deepMerge_(dest, src) {
  for (var _i2 = 0, _Object$keys = Object.keys(src); _i2 < _Object$keys.length; _i2++) {
    var property2 = _Object$keys[_i2];
    writeConfig(dest, property2, src[property2], true);
  }
}
var _w$vl;
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
      if (it) o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e3(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e3(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread(target2) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source2), true).forEach(function(key2) {
      _defineProperty$2(target2, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target2, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target2;
}
var vega = vegaImport;
var _vegaLite = vegaLiteImport;
var w = typeof window !== "undefined" ? window : void 0;
if (_vegaLite === void 0 && w !== null && w !== void 0 && (_w$vl = w.vl) !== null && _w$vl !== void 0 && _w$vl.compile) {
  _vegaLite = w.vl;
}
var DEFAULT_ACTIONS = {
  export: {
    svg: true,
    png: true
  },
  source: true,
  compiled: true,
  editor: true
};
var I18N = {
  CLICK_TO_VIEW_ACTIONS: "Click to view actions",
  COMPILED_ACTION: "View Compiled Vega",
  EDITOR_ACTION: "Open in Vega Editor",
  PNG_ACTION: "Save as PNG",
  SOURCE_ACTION: "View Source",
  SVG_ACTION: "Save as SVG"
};
var NAMES = {
  vega: "Vega",
  "vega-lite": "Vega-Lite"
};
var VERSION = {
  vega: vega.version,
  "vega-lite": _vegaLite ? _vegaLite.version : "not available"
};
var PREPROCESSOR = {
  vega: (vgSpec) => vgSpec,
  "vega-lite": (vlSpec, config) => _vegaLite.compile(vlSpec, {
    config
  }).spec
};
var SVG_CIRCLES = '\n<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">\n  <circle r="2" cy="8" cx="2"></circle>\n  <circle r="2" cy="8" cx="8"></circle>\n  <circle r="2" cy="8" cx="14"></circle>\n</svg>';
var CHART_WRAPPER_CLASS = "chart-wrapper";
function isTooltipHandler(h2) {
  return typeof h2 === "function";
}
function viewSource(source2, sourceHeader, sourceFooter, mode) {
  var header = "<html><head>".concat(sourceHeader, '</head><body><pre><code class="json">');
  var footer = "</code></pre>".concat(sourceFooter, "</body></html>");
  var win = window.open("");
  win.document.write(header + source2 + footer);
  win.document.title = "".concat(NAMES[mode], " JSON Source");
}
function guessMode(spec, providedMode) {
  if (spec.$schema) {
    var parsed = e(spec.$schema);
    if (providedMode && providedMode !== parsed.library) {
      var _NAMES$providedMode;
      console.warn("The given visualization spec is written in ".concat(NAMES[parsed.library], ", but mode argument sets ").concat((_NAMES$providedMode = NAMES[providedMode]) !== null && _NAMES$providedMode !== void 0 ? _NAMES$providedMode : providedMode, "."));
    }
    var mode = parsed.library;
    if (!satisfies_1(VERSION[mode], "^".concat(parsed.version.slice(1)))) {
      console.warn("The input spec uses ".concat(NAMES[mode], " ").concat(parsed.version, ", but the current version of ").concat(NAMES[mode], " is v").concat(VERSION[mode], "."));
    }
    return mode;
  }
  if ("mark" in spec || "encoding" in spec || "layer" in spec || "hconcat" in spec || "vconcat" in spec || "facet" in spec || "repeat" in spec) {
    return "vega-lite";
  }
  if ("marks" in spec || "signals" in spec || "scales" in spec || "axes" in spec) {
    return "vega";
  }
  return providedMode !== null && providedMode !== void 0 ? providedMode : "vega";
}
function isLoader(o) {
  return !!(o && "load" in o);
}
function createLoader(opts2) {
  return isLoader(opts2) ? opts2 : vega.loader(opts2);
}
function embedOptionsFromUsermeta(parsedSpec) {
  var _embedOptions, _parsedSpec$usermeta;
  var opts2 = (_embedOptions = (_parsedSpec$usermeta = parsedSpec.usermeta) === null || _parsedSpec$usermeta === void 0 ? void 0 : _parsedSpec$usermeta.embedOptions) !== null && _embedOptions !== void 0 ? _embedOptions : {};
  if (isString(opts2.defaultStyle)) {
    opts2.defaultStyle = false;
  }
  return opts2;
}
function embed(_x3, _x22) {
  return _embed2.apply(this, arguments);
}
function _embed2() {
  _embed2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee(el, spec) {
    var _parsedOpts$config, _usermetaOpts$config;
    var opts2, parsedSpec, loader2, loadedEmbedOptions, usermetaLoader, _opts$loader, usermetaOpts, parsedOpts, mergedOpts, _args = arguments;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            opts2 = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
            if (!isString(spec)) {
              _context.next = 10;
              break;
            }
            loader2 = createLoader(opts2.loader);
            _context.t0 = JSON;
            _context.next = 6;
            return loader2.load(spec);
          case 6:
            _context.t1 = _context.sent;
            parsedSpec = _context.t0.parse.call(_context.t0, _context.t1);
            _context.next = 11;
            break;
          case 10:
            parsedSpec = spec;
          case 11:
            loadedEmbedOptions = embedOptionsFromUsermeta(parsedSpec);
            usermetaLoader = loadedEmbedOptions.loader;
            if (!loader2 || usermetaLoader) {
              loader2 = createLoader((_opts$loader = opts2.loader) !== null && _opts$loader !== void 0 ? _opts$loader : usermetaLoader);
            }
            _context.next = 16;
            return loadOpts(loadedEmbedOptions, loader2);
          case 16:
            usermetaOpts = _context.sent;
            _context.next = 19;
            return loadOpts(opts2, loader2);
          case 19:
            parsedOpts = _context.sent;
            mergedOpts = _objectSpread(_objectSpread({}, mergeDeep(parsedOpts, usermetaOpts)), {}, {
              config: mergeConfig((_parsedOpts$config = parsedOpts.config) !== null && _parsedOpts$config !== void 0 ? _parsedOpts$config : {}, (_usermetaOpts$config = usermetaOpts.config) !== null && _usermetaOpts$config !== void 0 ? _usermetaOpts$config : {})
            });
            _context.next = 23;
            return _embed(el, parsedSpec, mergedOpts, loader2);
          case 23:
            return _context.abrupt("return", _context.sent);
          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _embed2.apply(this, arguments);
}
function loadOpts(_x3, _x4) {
  return _loadOpts.apply(this, arguments);
}
function _loadOpts() {
  _loadOpts = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee2(opt, loader2) {
    var _opt$config;
    var config, patch2;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!isString(opt.config)) {
              _context2.next = 8;
              break;
            }
            _context2.t1 = JSON;
            _context2.next = 4;
            return loader2.load(opt.config);
          case 4:
            _context2.t2 = _context2.sent;
            _context2.t0 = _context2.t1.parse.call(_context2.t1, _context2.t2);
            _context2.next = 9;
            break;
          case 8:
            _context2.t0 = (_opt$config = opt.config) !== null && _opt$config !== void 0 ? _opt$config : {};
          case 9:
            config = _context2.t0;
            if (!isString(opt.patch)) {
              _context2.next = 18;
              break;
            }
            _context2.t4 = JSON;
            _context2.next = 14;
            return loader2.load(opt.patch);
          case 14:
            _context2.t5 = _context2.sent;
            _context2.t3 = _context2.t4.parse.call(_context2.t4, _context2.t5);
            _context2.next = 19;
            break;
          case 18:
            _context2.t3 = opt.patch;
          case 19:
            patch2 = _context2.t3;
            return _context2.abrupt("return", _objectSpread(_objectSpread(_objectSpread({}, opt), patch2 ? {
              patch: patch2
            } : {}), config ? {
              config
            } : {}));
          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadOpts.apply(this, arguments);
}
function getRoot(el) {
  var _document$head;
  var possibleRoot = el.getRootNode ? el.getRootNode() : document;
  return possibleRoot instanceof ShadowRoot ? {
    root: possibleRoot,
    rootContainer: possibleRoot
  } : {
    root: document,
    rootContainer: (_document$head = document.head) !== null && _document$head !== void 0 ? _document$head : document.body
  };
}
function _embed(_x5, _x6) {
  return _embed3.apply(this, arguments);
}
function _embed3() {
  _embed3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee4(el, spec) {
    var _opts$config, _opts$actions, _opts$renderer, _opts$logLevel, _opts$downloadFileNam, _ref, _expressionInterprete;
    var opts2, loader2, config, actions, i18n, renderer, logLevel, downloadFileName, element2, ID, _getRoot, root2, rootContainer, style2, mode, vgSpec, parsed, container, chartWrapper, patch2, name, expressionFunction2, ast, runtime2, view, handler, hover2, _ref2, hoverSet, updateSet, documentClickHandler, wrapper, details, summary, ctrl, _iterator, _step, _loop, viewSourceLink, compileLink, _opts$editorUrl, editorUrl, editorLink, finalize2, _args4 = arguments;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            finalize2 = function _finalize() {
              if (documentClickHandler) {
                document.removeEventListener("click", documentClickHandler);
              }
              view.finalize();
            };
            opts2 = _args4.length > 2 && _args4[2] !== void 0 ? _args4[2] : {};
            loader2 = _args4.length > 3 ? _args4[3] : void 0;
            config = opts2.theme ? mergeConfig(themes[opts2.theme], (_opts$config = opts2.config) !== null && _opts$config !== void 0 ? _opts$config : {}) : opts2.config;
            actions = isBoolean$2(opts2.actions) ? opts2.actions : mergeDeep({}, DEFAULT_ACTIONS, (_opts$actions = opts2.actions) !== null && _opts$actions !== void 0 ? _opts$actions : {});
            i18n = _objectSpread(_objectSpread({}, I18N), opts2.i18n);
            renderer = (_opts$renderer = opts2.renderer) !== null && _opts$renderer !== void 0 ? _opts$renderer : "canvas";
            logLevel = (_opts$logLevel = opts2.logLevel) !== null && _opts$logLevel !== void 0 ? _opts$logLevel : vega.Warn;
            downloadFileName = (_opts$downloadFileNam = opts2.downloadFileName) !== null && _opts$downloadFileNam !== void 0 ? _opts$downloadFileNam : "visualization";
            element2 = typeof el === "string" ? document.querySelector(el) : el;
            if (element2) {
              _context4.next = 12;
              break;
            }
            throw new Error("".concat(el, " does not exist"));
          case 12:
            if (opts2.defaultStyle !== false) {
              ID = "vega-embed-style";
              _getRoot = getRoot(element2), root2 = _getRoot.root, rootContainer = _getRoot.rootContainer;
              if (!root2.getElementById(ID)) {
                style2 = document.createElement("style");
                style2.id = ID;
                style2.innerHTML = opts2.defaultStyle === void 0 || opts2.defaultStyle === true ? embedStyle.toString() : opts2.defaultStyle;
                rootContainer.appendChild(style2);
              }
            }
            mode = guessMode(spec, opts2.mode);
            vgSpec = PREPROCESSOR[mode](spec, config);
            if (mode === "vega-lite") {
              if (vgSpec.$schema) {
                parsed = e(vgSpec.$schema);
                if (!satisfies_1(VERSION.vega, "^".concat(parsed.version.slice(1)))) {
                  console.warn("The compiled spec uses Vega ".concat(parsed.version, ", but current version is v").concat(VERSION.vega, "."));
                }
              }
            }
            element2.classList.add("vega-embed");
            if (actions) {
              element2.classList.add("has-actions");
            }
            element2.innerHTML = "";
            container = element2;
            if (actions) {
              chartWrapper = document.createElement("div");
              chartWrapper.classList.add(CHART_WRAPPER_CLASS);
              element2.appendChild(chartWrapper);
              container = chartWrapper;
            }
            patch2 = opts2.patch;
            if (patch2) {
              vgSpec = patch2 instanceof Function ? patch2(vgSpec) : applyPatch(vgSpec, patch2, true, false).newDocument;
            }
            if (opts2.formatLocale) {
              vega.formatLocale(opts2.formatLocale);
            }
            if (opts2.timeFormatLocale) {
              vega.timeFormatLocale(opts2.timeFormatLocale);
            }
            if (opts2.expressionFunctions) {
              for (name in opts2.expressionFunctions) {
                expressionFunction2 = opts2.expressionFunctions[name];
                if ("fn" in expressionFunction2) {
                  vega.expressionFunction(name, expressionFunction2.fn, expressionFunction2["visitor"]);
                } else if (expressionFunction2 instanceof Function) {
                  vega.expressionFunction(name, expressionFunction2);
                }
              }
            }
            ast = opts2.ast;
            runtime2 = vega.parse(vgSpec, mode === "vega-lite" ? {} : config, {
              ast
            });
            view = new (opts2.viewClass || vega.View)(runtime2, _objectSpread({
              loader: loader2,
              logLevel,
              renderer
            }, ast ? {
              expr: (_ref = (_expressionInterprete = vega.expressionInterpreter) !== null && _expressionInterprete !== void 0 ? _expressionInterprete : opts2.expr) !== null && _ref !== void 0 ? _ref : expression$1
            } : {}));
            view.addSignalListener("autosize", (_, autosize) => {
              var type2 = autosize.type;
              if (type2 == "fit-x") {
                container.classList.add("fit-x");
                container.classList.remove("fit-y");
              } else if (type2 == "fit-y") {
                container.classList.remove("fit-x");
                container.classList.add("fit-y");
              } else if (type2 == "fit") {
                container.classList.add("fit-x", "fit-y");
              } else {
                container.classList.remove("fit-x", "fit-y");
              }
            });
            if (opts2.tooltip !== false) {
              handler = isTooltipHandler(opts2.tooltip) ? opts2.tooltip : (
                // user provided boolean true or tooltip options
                new Handler2(opts2.tooltip === true ? {} : opts2.tooltip).call
              );
              view.tooltip(handler);
            }
            hover2 = opts2.hover;
            if (hover2 === void 0) {
              hover2 = mode === "vega";
            }
            if (hover2) {
              _ref2 = typeof hover2 === "boolean" ? {} : hover2, hoverSet = _ref2.hoverSet, updateSet = _ref2.updateSet;
              view.hover(hoverSet, updateSet);
            }
            if (opts2) {
              if (opts2.width != null) {
                view.width(opts2.width);
              }
              if (opts2.height != null) {
                view.height(opts2.height);
              }
              if (opts2.padding != null) {
                view.padding(opts2.padding);
              }
            }
            _context4.next = 37;
            return view.initialize(container, opts2.bind).runAsync();
          case 37:
            if (actions !== false) {
              wrapper = element2;
              if (opts2.defaultStyle !== false) {
                details = document.createElement("details");
                details.title = i18n.CLICK_TO_VIEW_ACTIONS;
                element2.append(details);
                wrapper = details;
                summary = document.createElement("summary");
                summary.innerHTML = SVG_CIRCLES;
                details.append(summary);
                documentClickHandler = (ev) => {
                  if (!details.contains(ev.target)) {
                    details.removeAttribute("open");
                  }
                };
                document.addEventListener("click", documentClickHandler);
              }
              ctrl = document.createElement("div");
              wrapper.append(ctrl);
              ctrl.classList.add("vega-actions");
              if (actions === true || actions.export !== false) {
                _iterator = _createForOfIteratorHelper(["svg", "png"]);
                try {
                  _loop = function _loop2() {
                    var ext = _step.value;
                    if (actions === true || actions.export === true || actions.export[ext]) {
                      var i18nExportAction = i18n["".concat(ext.toUpperCase(), "_ACTION")];
                      var exportLink = document.createElement("a");
                      exportLink.text = i18nExportAction;
                      exportLink.href = "#";
                      exportLink.target = "_blank";
                      exportLink.download = "".concat(downloadFileName, ".").concat(ext);
                      exportLink.addEventListener("mousedown", /* @__PURE__ */ function() {
                        var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee3(e3) {
                          var url;
                          return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                            while (1) {
                              switch (_context3.prev = _context3.next) {
                                case 0:
                                  e3.preventDefault();
                                  _context3.next = 3;
                                  return view.toImageURL(ext, opts2.scaleFactor);
                                case 3:
                                  url = _context3.sent;
                                  this.href = url;
                                case 5:
                                case "end":
                                  return _context3.stop();
                              }
                            }
                          }, _callee3, this);
                        }));
                        return function(_x7) {
                          return _ref3.apply(this, arguments);
                        };
                      }());
                      ctrl.append(exportLink);
                    }
                  };
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    _loop();
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              if (actions === true || actions.source !== false) {
                viewSourceLink = document.createElement("a");
                viewSourceLink.text = i18n.SOURCE_ACTION;
                viewSourceLink.href = "#";
                viewSourceLink.addEventListener("click", function(e3) {
                  var _opts$sourceHeader, _opts$sourceFooter;
                  viewSource(stringify$2(spec), (_opts$sourceHeader = opts2.sourceHeader) !== null && _opts$sourceHeader !== void 0 ? _opts$sourceHeader : "", (_opts$sourceFooter = opts2.sourceFooter) !== null && _opts$sourceFooter !== void 0 ? _opts$sourceFooter : "", mode);
                  e3.preventDefault();
                });
                ctrl.append(viewSourceLink);
              }
              if (mode === "vega-lite" && (actions === true || actions.compiled !== false)) {
                compileLink = document.createElement("a");
                compileLink.text = i18n.COMPILED_ACTION;
                compileLink.href = "#";
                compileLink.addEventListener("click", function(e3) {
                  var _opts$sourceHeader2, _opts$sourceFooter2;
                  viewSource(stringify$2(vgSpec), (_opts$sourceHeader2 = opts2.sourceHeader) !== null && _opts$sourceHeader2 !== void 0 ? _opts$sourceHeader2 : "", (_opts$sourceFooter2 = opts2.sourceFooter) !== null && _opts$sourceFooter2 !== void 0 ? _opts$sourceFooter2 : "", "vega");
                  e3.preventDefault();
                });
                ctrl.append(compileLink);
              }
              if (actions === true || actions.editor !== false) {
                editorUrl = (_opts$editorUrl = opts2.editorUrl) !== null && _opts$editorUrl !== void 0 ? _opts$editorUrl : "https://vega.github.io/editor/";
                editorLink = document.createElement("a");
                editorLink.text = i18n.EDITOR_ACTION;
                editorLink.href = "#";
                editorLink.addEventListener("click", function(e3) {
                  post(window, editorUrl, {
                    config,
                    mode,
                    renderer,
                    spec: stringify$2(spec)
                  });
                  e3.preventDefault();
                });
                ctrl.append(editorLink);
              }
            }
            return _context4.abrupt("return", {
              view,
              spec,
              vgSpec,
              finalize: finalize2,
              embedOptions: opts2
            });
          case 39:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _embed3.apply(this, arguments);
}
function isFunction(functionToCheck) {
  const getType = {};
  return !!functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
}
function updateSingleDatasetInView(view, name, value2) {
  if (value2) {
    if (isFunction(value2)) {
      value2(view.data(name));
    } else {
      view.change(name, vega.changeset().remove(() => true).insert(value2));
    }
  }
}
function updateMultipleDatasetsInView(view, data2) {
  Object.keys(data2).forEach((name) => {
    updateSingleDatasetInView(view, name, data2[name]);
  });
}
function getUniqueFieldNames(objects) {
  const fields = /* @__PURE__ */ new Set();
  objects.forEach((o) => {
    Object.keys(o).forEach((field2) => {
      fields.add(field2);
    });
  });
  return fields;
}
const NOOP = () => {
};
function addSignalListenersToView(view, signalListeners) {
  const signalNames = Object.keys(signalListeners);
  signalNames.forEach((signalName) => {
    try {
      view.addSignalListener(signalName, signalListeners[signalName]);
    } catch (error2) {
      console.warn("Cannot add invalid signal listener.", error2);
    }
  });
  return signalNames.length > 0;
}
function computeSpecChanges(newSpec, oldSpec) {
  if (newSpec === oldSpec) return false;
  const changes = {
    width: false,
    height: false,
    isExpensive: false
  };
  const fieldNames2 = getUniqueFieldNames([newSpec, oldSpec]);
  if (fieldNames2.has("width") && (!("width" in newSpec) || !("width" in oldSpec) || newSpec.width !== oldSpec.width)) {
    if ("width" in newSpec && typeof newSpec.width === "number") {
      changes.width = newSpec.width;
    } else {
      changes.isExpensive = true;
    }
  }
  if (fieldNames2.has("height") && (!("height" in newSpec) || !("height" in oldSpec) || newSpec.height !== oldSpec.height)) {
    if ("height" in newSpec && typeof newSpec.height === "number") {
      changes.height = newSpec.height;
    } else {
      changes.isExpensive = true;
    }
  }
  fieldNames2.delete("width");
  fieldNames2.delete("height");
  if ([...fieldNames2].some((field2) => !(field2 in newSpec) || !(field2 in oldSpec) || !equal(newSpec[field2], oldSpec[field2]))) {
    changes.isExpensive = true;
  }
  return changes.width !== false || changes.height !== false || changes.isExpensive ? changes : false;
}
function removeSignalListenersFromView(view, signalListeners) {
  const signalNames = Object.keys(signalListeners);
  signalNames.forEach((signalName) => {
    try {
      view.removeSignalListener(signalName, signalListeners[signalName]);
    } catch (error2) {
      console.warn("Cannot remove invalid signal listener.", error2);
    }
  });
  return signalNames.length > 0;
}
function combineSpecWithDimension(props) {
  const {
    spec,
    width: width2,
    height: height2
  } = props;
  if (typeof width2 !== "undefined" && typeof height2 !== "undefined") {
    return {
      ...spec,
      width: width2,
      height: height2
    };
  }
  if (typeof width2 !== "undefined") {
    return {
      ...spec,
      width: width2
    };
  }
  if (typeof height2 !== "undefined") {
    return {
      ...spec,
      height: height2
    };
  }
  return spec;
}
function _defineProperty$1(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
class VegaEmbed extends React__default.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty$1(this, "containerRef", /* @__PURE__ */ React__default.createRef());
    _defineProperty$1(this, "resultPromise", void 0);
    _defineProperty$1(this, "handleError", (error2) => {
      const {
        onError = NOOP
      } = this.props;
      onError(error2, this.containerRef.current);
      console.warn(error2);
      return void 0;
    });
    _defineProperty$1(this, "modifyView", (action) => {
      if (this.resultPromise) {
        this.resultPromise.then((result) => {
          if (result) {
            action(result.view);
          }
          return true;
        }).catch(this.handleError);
      }
    });
  }
  componentDidMount() {
    this.createView();
  }
  componentDidUpdate(prevProps) {
    const fieldSet = getUniqueFieldNames([this.props, prevProps]);
    fieldSet.delete("className");
    fieldSet.delete("signalListeners");
    fieldSet.delete("spec");
    fieldSet.delete("style");
    fieldSet.delete("width");
    fieldSet.delete("height");
    if (Array.from(fieldSet).some((f) => this.props[f] !== prevProps[f])) {
      this.clearView();
      this.createView();
    } else {
      const specChanges = computeSpecChanges(combineSpecWithDimension(this.props), combineSpecWithDimension(prevProps));
      const {
        signalListeners: newSignalListeners
      } = this.props;
      const {
        signalListeners: oldSignalListeners
      } = prevProps;
      if (specChanges) {
        if (specChanges.isExpensive) {
          this.clearView();
          this.createView();
        } else {
          const areSignalListenersChanged = !shallowEqual(newSignalListeners, oldSignalListeners);
          this.modifyView((view) => {
            if (specChanges.width !== false) {
              view.width(specChanges.width);
            }
            if (specChanges.height !== false) {
              view.height(specChanges.height);
            }
            if (areSignalListenersChanged) {
              if (oldSignalListeners) {
                removeSignalListenersFromView(view, oldSignalListeners);
              }
              if (newSignalListeners) {
                addSignalListenersToView(view, newSignalListeners);
              }
            }
            view.run();
          });
        }
      } else if (!shallowEqual(newSignalListeners, oldSignalListeners)) {
        this.modifyView((view) => {
          if (oldSignalListeners) {
            removeSignalListenersFromView(view, oldSignalListeners);
          }
          if (newSignalListeners) {
            addSignalListenersToView(view, newSignalListeners);
          }
          view.run();
        });
      }
    }
  }
  componentWillUnmount() {
    this.clearView();
  }
  createView() {
    const {
      spec,
      onNewView,
      signalListeners = {},
      width: width2,
      height: height2,
      ...options
    } = this.props;
    if (this.containerRef.current) {
      const finalSpec = combineSpecWithDimension(this.props);
      this.resultPromise = embed(this.containerRef.current, finalSpec, options).then((result) => {
        if (result) {
          const {
            view
          } = result;
          if (addSignalListenersToView(view, signalListeners)) {
            view.run();
          }
        }
        return result;
      }).catch(this.handleError);
      if (onNewView) {
        this.modifyView(onNewView);
      }
    }
  }
  clearView() {
    if (this.resultPromise) {
      this.resultPromise.then((result) => {
        if (result) {
          result.finalize();
        }
      }).catch(this.handleError);
    }
    this.resultPromise = void 0;
    return this;
  }
  render() {
    const {
      className,
      style: style2
    } = this.props;
    return /* @__PURE__ */ React__default.createElement("div", {
      ref: this.containerRef,
      className,
      style: style2
    });
  }
}
_defineProperty$1(VegaEmbed, "propTypes", {
  className: _pt.string,
  onError: _pt.func
});
function _extends() {
  _extends = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key2 in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key2)) {
          target2[key2] = source2[key2];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}
function _defineProperty(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
const EMPTY = {};
class Vega extends React__default.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty(this, "vegaEmbed", /* @__PURE__ */ React__default.createRef());
    _defineProperty(this, "handleNewView", (view) => {
      this.update();
      const {
        onNewView = NOOP
      } = this.props;
      onNewView(view);
    });
  }
  componentDidMount() {
    this.update();
  }
  componentDidUpdate(prevProps) {
    if (!shallowEqual(this.props.data, prevProps.data)) {
      this.update();
    }
  }
  update() {
    const {
      data: data2
    } = this.props;
    if (this.vegaEmbed.current && data2 && Object.keys(data2).length > 0) {
      this.vegaEmbed.current.modifyView((view) => {
        updateMultipleDatasetsInView(view, data2);
        view.resize().run();
      });
    }
  }
  render() {
    const {
      data: data2,
      ...restProps
    } = this.props;
    return /* @__PURE__ */ React__default.createElement(VegaEmbed, _extends({
      ref: this.vegaEmbed
    }, restProps, {
      onNewView: this.handleNewView
    }));
  }
}
_defineProperty(Vega, "defaultProps", {
  data: EMPTY
});
const VEGA_THEMES = {
  dark: {
    // The vega-themes dark theme.
    // Reference: https://github.com/vega/vega-themes/blob/master/src/theme-dark.ts
    background: null,
    title: { color: "#fff" },
    style: {
      "guide-label": {
        fill: "#fff"
      },
      "guide-title": {
        fill: "#fff"
      }
    },
    axis: {
      domainColor: "#fff",
      gridColor: "#888",
      tickColor: "#fff"
    }
  },
  light: {
    // The default vega theme.
    background: null
  },
  light2: {
    // The default vega theme.
    background: null
  }
};
const DATASET_NAME = "table";
function VegaGlobalStyles() {
  const { theme } = useStyles$1();
  return /* @__PURE__ */ React.createElement(
    GlobalStyles,
    {
      styles: {
        "#vg-tooltip-element.vg-tooltip.custom-theme": {
          boxShadow: "0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12)",
          padding: "0px",
          backgroundColor: theme.palette.gridLayoutBackground,
          color: theme.palette.secondaryForeground,
          border: "none",
          opacity: 0.9,
          fontSize: "12px",
          borderRadius: "4px",
          "& > div": {
            backgroundColor: "transparent"
          }
        }
      }
    }
  );
}
scheme$1("jet", getInterpolateFunction("jet"));
function isVega(spec) {
  return spec.$schema === "https://vega.github.io/schema/vega/v5.json";
}
function renderTooltipContents(tooltipText) {
  const tableRows = Object.entries(tooltipText).map(([key2, value2]) => `<tr key=${key2}>
        <th>${key2}</th>
        <td>${value2}</td>
      </tr>`).join("");
  return `<table>
      <tbody>
        ${tableRows}
      </tbody>
    </table>`;
}
function VegaPlot(props) {
  const {
    spec: partialSpec,
    data: data2,
    getTooltipText,
    signalListeners,
    renderer = "svg",
    onNewView
  } = props;
  const { classes: tooltipClasses } = useStyles();
  const tooltipHandler = useMemo(() => {
    if (typeof getTooltipText === "function") {
      const tooltipConfig = {
        theme: "custom",
        offsetX: 10,
        offsetY: 10,
        // Use table element to match packages/tooltip/TooltipContent implementation.
        formatTooltip: (tooltipText) => `
          <div class="${tooltipClasses.tooltipContent}">
            ${renderTooltipContents(tooltipText)}
          </div>
        `
      };
      const handlerInstance = new Handler$2(tooltipConfig);
      const originalCall = handlerInstance.call;
      handlerInstance.call = (handler, event2, item, value2) => {
        if (item && item.datum && value2) {
          const tooltipText = getTooltipText(item);
          originalCall.call(this, handler, event2, item, tooltipText);
        } else {
          originalCall.call(this, handler, event2, item, value2);
        }
      };
      return handlerInstance.call;
    }
    return false;
  }, [getTooltipText, tooltipClasses.tooltipContent]);
  const spec = useMemo(() => ({
    ...partialSpec,
    data: isVega(partialSpec) ? [
      { name: DATASET_NAME },
      ...partialSpec.data
    ] : { name: DATASET_NAME }
  }), [partialSpec]);
  const vegaComponent = useMemo(() => /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(VegaGlobalStyles, null), /* @__PURE__ */ React__default.createElement(
    Vega,
    {
      spec,
      data: {
        [DATASET_NAME]: data2
      },
      signalListeners,
      tooltip: tooltipHandler,
      renderer,
      scaleFactor: 3,
      key: JSON.stringify({ width: spec.width, height: spec.height }),
      onNewView
    }
  )), [spec, data2, signalListeners, tooltipHandler, renderer, onNewView]);
  return spec && data2 && data2.length > 0 ? /* @__PURE__ */ React__default.createElement(Suspense, { fallback: /* @__PURE__ */ React__default.createElement("div", null, "Loading...") }, vegaComponent) : null;
}
export {
  DATASET_NAME,
  VEGA_THEMES,
  VegaPlot
};
