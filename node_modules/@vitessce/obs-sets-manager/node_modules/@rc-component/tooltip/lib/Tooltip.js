"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _trigger = _interopRequireDefault(require("@rc-component/trigger"));
var _useId = _interopRequireDefault(require("@rc-component/util/lib/hooks/useId"));
var _classnames = _interopRequireDefault(require("classnames"));
var _react = _interopRequireWildcard(require("react"));
var React = _react;
var _placements = require("./placements");
var _Popup = _interopRequireDefault(require("./Popup"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const Tooltip = /*#__PURE__*/React.forwardRef((props, ref) => {
  const {
    overlayClassName,
    trigger = ['hover'],
    mouseEnterDelay = 0,
    mouseLeaveDelay = 0.1,
    overlayStyle,
    prefixCls = 'rc-tooltip',
    children,
    onVisibleChange,
    afterVisibleChange,
    motion,
    placement = 'right',
    align = {},
    destroyOnHidden = false,
    defaultVisible,
    getTooltipContainer,
    overlayInnerStyle,
    arrowContent,
    overlay,
    id,
    showArrow = true,
    classNames: tooltipClassNames,
    styles: tooltipStyles,
    ...restProps
  } = props;
  const mergedId = (0, _useId.default)(id);
  const triggerRef = (0, _react.useRef)(null);
  (0, _react.useImperativeHandle)(ref, () => triggerRef.current);
  const extraProps = {
    ...restProps
  };
  if ('visible' in props) {
    extraProps.popupVisible = props.visible;
  }
  const getPopupElement = () => /*#__PURE__*/React.createElement(_Popup.default, {
    key: "content",
    prefixCls: prefixCls,
    id: mergedId,
    bodyClassName: tooltipClassNames?.body,
    overlayInnerStyle: {
      ...overlayInnerStyle,
      ...tooltipStyles?.body
    }
  }, overlay);
  const getChildren = () => {
    const child = React.Children.only(children);
    const originalProps = child?.props || {};
    const childProps = {
      ...originalProps,
      'aria-describedby': overlay ? mergedId : null
    };
    return /*#__PURE__*/React.cloneElement(children, childProps);
  };
  return /*#__PURE__*/React.createElement(_trigger.default, _extends({
    popupClassName: (0, _classnames.default)(overlayClassName, tooltipClassNames?.root),
    prefixCls: prefixCls,
    popup: getPopupElement,
    action: trigger,
    builtinPlacements: _placements.placements,
    popupPlacement: placement,
    ref: triggerRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onOpenChange: onVisibleChange,
    afterOpenChange: afterVisibleChange,
    popupMotion: motion,
    defaultPopupVisible: defaultVisible,
    autoDestroy: destroyOnHidden,
    mouseLeaveDelay: mouseLeaveDelay,
    popupStyle: {
      ...overlayStyle,
      ...tooltipStyles?.root
    },
    mouseEnterDelay: mouseEnterDelay,
    arrow: showArrow
  }, extraProps), getChildren());
});
var _default = exports.default = Tooltip;